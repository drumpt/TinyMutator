{"files":[{"path":["/","usr","src","regex","bench","src","ffi","d_phobos.rs"],"content":"#![allow(non_camel_case_types)]\n\nuse libc::{c_uchar, c_void};\n\n/// Regex wraps a D regular expression\npub struct Regex {\n    re: *mut d_regex,\n}\n\nunsafe impl Send for Regex {}\n\nimpl Drop for Regex {\n    fn drop(&mut self) {\n        unsafe {\n            d_phobos_regex_free(self.re);\n            rt_term();\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct Error(());\n\nimpl Regex {\n    pub fn new(pattern: &str) -> Result<Regex, Error> {\n        unsafe {\n            rt_init();\n\n            Ok(Regex { re: d_phobos_regex_new(pattern.into()) })\n        }\n    }\n\n    pub fn is_match(&self, text: &str) -> bool {\n        unsafe { d_phobos_regex_is_match(self.re, text.into()) }\n    }\n\n    pub fn find_iter<'r, 't>(&'r self, text: &'t str) -> FindMatches<'r, 't> {\n        FindMatches { re: self, text: text, last_end: 0, last_match: None }\n    }\n\n    fn find_at(&self, text: &str, start: usize) -> Option<(usize, usize)> {\n        let (mut s, mut e): (usize, usize) = (0, 0);\n        let matched = unsafe {\n            d_phobos_regex_find_at(self.re, text.into(), start, &mut s, &mut e)\n        };\n        if matched {\n            Some((s, e))\n        } else {\n            None\n        }\n    }\n}\n\npub struct FindMatches<'r, 't> {\n    re: &'r Regex,\n    text: &'t str,\n    last_end: usize,\n    last_match: Option<usize>,\n}\n\nimpl<'r, 't> Iterator for FindMatches<'r, 't> {\n    type Item = (usize, usize);\n\n    fn next(&mut self) -> Option<(usize, usize)> {\n        match self.re.find_at(self.text, self.last_end) {\n            None => None,\n            Some((s, e)) => {\n                self.last_end = e;\n                Some((s, e))\n            }\n        }\n    }\n}\n\ntype d_regex = c_void;\n\n#[repr(C)]\nstruct d_string {\n    len: usize,\n    text: *const c_uchar,\n}\n\nimpl<'a> From<&'a str> for d_string {\n    fn from(s: &'a str) -> d_string {\n        d_string { len: s.len(), text: s.as_ptr() }\n    }\n}\n\nextern \"C\" {\n    fn rt_init() -> i32;\n    fn rt_term() -> i32;\n    fn d_phobos_regex_new(s: d_string) -> *mut d_regex;\n    fn d_phobos_regex_free(r: *mut d_regex);\n    fn d_phobos_regex_is_match(r: *mut d_regex, s: d_string) -> bool;\n    fn d_phobos_regex_find_at(\n        r: *mut d_regex,\n        s: d_string,\n        start: usize,\n        match_start: *mut usize,\n        match_end: *mut usize,\n    ) -> bool;\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":23},{"path":["/","usr","src","regex","bench","src","ffi","onig.rs"],"content":"use onig;\n\npub struct Regex(onig::Regex);\n\nunsafe impl Send for Regex {}\n\nimpl Regex {\n    pub fn new(pattern: &str) -> Result<Self, onig::Error> {\n        onig::Regex::new(pattern).map(Regex)\n    }\n\n    pub fn is_match(&self, text: &str) -> bool {\n        // Gah. onig's is_match function is anchored, but find is not.\n        self.0\n            .search_with_options(\n                text,\n                0,\n                text.len(),\n                onig::SearchOptions::SEARCH_OPTION_NONE,\n                None,\n            )\n            .is_some()\n    }\n\n    pub fn find_iter<'r, 't>(\n        &'r self,\n        text: &'t str,\n    ) -> onig::FindMatches<'r, 't> {\n        self.0.find_iter(text)\n    }\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","usr","src","regex","bench","src","ffi","pcre1.rs"],"content":"#![allow(non_snake_case)]\n\nuse std::ffi::{CStr, CString};\nuse std::fmt;\nuse std::ptr;\n\nuse libc::{c_char, c_int, c_void};\nuse libpcre_sys::{\n    pcre, pcre_compile, pcre_exec, pcre_extra, pcre_free, pcre_free_study,\n    pcre_study, PCRE_ERROR_NOMATCH, PCRE_NO_UTF8_CHECK, PCRE_UTF8,\n};\n\nconst PCRE_UCP: c_int = 0x20000000;\nconst PCRE_STUDY_JIT_COMPLETE: c_int = 0x0001;\n\n// We use libpcre-sys directly because the pcre crate has unavoidable\n// performance problems in its core matching routines. (e.g., It always\n// allocates an ovector.)\npub struct Regex {\n    code: *mut pcre,\n    extra: *mut pcre_extra,\n}\n\nunsafe impl Send for Regex {}\n\nimpl Drop for Regex {\n    fn drop(&mut self) {\n        unsafe {\n            pcre_free_study(self.extra);\n            pcre_free(self.code as *mut c_void);\n        }\n    }\n}\n\npub struct Error {\n    msg: String,\n    offset: c_int,\n}\n\nimpl Regex {\n    pub fn new(pattern: &str) -> Result<Regex, Error> {\n        let pattern = CString::new(pattern.to_owned()).unwrap();\n        let mut errptr: *const c_char = ptr::null();\n        let mut erroffset: c_int = 0;\n        let code = unsafe {\n            pcre_compile(\n                pattern.as_ptr(),\n                PCRE_UCP | PCRE_UTF8,\n                &mut errptr,\n                &mut erroffset,\n                ptr::null(),\n            )\n        };\n        if code.is_null() {\n            let msg =\n                unsafe { CStr::from_ptr(errptr).to_str().unwrap().to_owned() };\n            return Err(Error { msg: msg, offset: erroffset });\n        }\n\n        let extra =\n            unsafe { pcre_study(code, PCRE_STUDY_JIT_COMPLETE, &mut errptr) };\n        if extra.is_null() {\n            if errptr.is_null() {\n                panic!(\"unexpected error. Maybe JIT support isn't enabled?\");\n            }\n            let msg =\n                unsafe { CStr::from_ptr(errptr).to_str().unwrap().to_owned() };\n            return Err(Error { msg: msg, offset: 0 });\n        }\n        Ok(Regex { code: code, extra: extra })\n    }\n\n    pub fn is_match(&self, text: &str) -> bool {\n        self.find_at(text, 0).is_some()\n    }\n\n    pub fn find_iter<'r, 't>(&'r self, text: &'t str) -> FindMatches<'r, 't> {\n        FindMatches { re: self, text: text, last_match_end: 0 }\n    }\n\n    fn find_at(&self, text: &str, start: usize) -> Option<(usize, usize)> {\n        const OVEC_SIZE: usize = 15 * 3; // hopefully enough for benchmarks?\n        let mut ovec: [c_int; OVEC_SIZE] = [0; OVEC_SIZE];\n        let err = unsafe {\n            pcre_exec(\n                self.code,\n                self.extra,\n                text.as_ptr() as *const i8,\n                text.len() as c_int,\n                start as c_int,\n                PCRE_NO_UTF8_CHECK,\n                ovec.as_mut_ptr(),\n                OVEC_SIZE as c_int,\n            )\n        };\n        if err == PCRE_ERROR_NOMATCH {\n            None\n        } else if err < 0 {\n            panic!(\"unknown error code: {:?}\", err)\n        } else {\n            Some((ovec[0] as usize, ovec[1] as usize))\n        }\n    }\n}\n\npub struct FindMatches<'r, 't> {\n    re: &'r Regex,\n    text: &'t str,\n    last_match_end: usize,\n}\n\nimpl<'r, 't> Iterator for FindMatches<'r, 't> {\n    type Item = (usize, usize);\n\n    fn next(&mut self) -> Option<(usize, usize)> {\n        match self.re.find_at(self.text, self.last_match_end) {\n            None => None,\n            Some((s, e)) => {\n                self.last_match_end = e;\n                Some((s, e))\n            }\n        }\n    }\n}\n\nimpl fmt::Debug for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"PCRE error at {:?}: {}\", self.offset, self.msg)\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":51},{"path":["/","usr","src","regex","bench","src","ffi","pcre2.rs"],"content":"#![allow(non_camel_case_types)]\n\nuse std::fmt;\nuse std::ptr;\nuse std::str;\n\nuse libc::{c_int, c_void, size_t, uint32_t, uint8_t};\n\npub struct Regex {\n    code: *mut code,\n    match_data: *mut match_data,\n    ovector: *mut size_t,\n}\n\nunsafe impl Send for Regex {}\n\nimpl Drop for Regex {\n    fn drop(&mut self) {\n        unsafe {\n            pcre2_match_data_free_8(self.match_data);\n            pcre2_code_free_8(self.code);\n        }\n    }\n}\n\npub struct Error {\n    code: c_int,\n    offset: size_t,\n}\n\nimpl Regex {\n    pub fn new(pattern: &str) -> Result<Regex, Error> {\n        let mut error_code: c_int = 0;\n        let mut error_offset: size_t = 0;\n        let code = unsafe {\n            pcre2_compile_8(\n                pattern.as_ptr(),\n                pattern.len(),\n                // PCRE2 can get significantly faster in some cases depending\n                // on the permutation of these options (in particular, dropping\n                // UCP). We should endeavor to have a separate \"ASCII compatible\"\n                // benchmark.\n                PCRE2_UCP | PCRE2_UTF,\n                &mut error_code,\n                &mut error_offset,\n                ptr::null_mut(),\n            )\n        };\n        if code.is_null() {\n            return Err(Error { code: error_code, offset: error_offset });\n        }\n        let err = unsafe { pcre2_jit_compile_8(code, PCRE2_JIT_COMPLETE) };\n        if err < 0 {\n            panic!(\"pcre2_jit_compile_8 failed with error: {:?}\", err);\n        }\n        let match_data = unsafe {\n            pcre2_match_data_create_from_pattern_8(code, ptr::null_mut())\n        };\n        if match_data.is_null() {\n            panic!(\"could not allocate match_data\");\n        }\n        let ovector = unsafe { pcre2_get_ovector_pointer_8(match_data) };\n        if ovector.is_null() {\n            panic!(\"could not get ovector\");\n        }\n        Ok(Regex { code: code, match_data: match_data, ovector: ovector })\n    }\n\n    pub fn is_match(&self, text: &str) -> bool {\n        self.find_at(text, 0).is_some()\n    }\n\n    pub fn find_iter<'r, 't>(&'r self, text: &'t str) -> FindMatches<'r, 't> {\n        FindMatches { re: self, text: text, last_match_end: 0 }\n    }\n\n    fn find_at(&self, text: &str, start: usize) -> Option<(usize, usize)> {\n        // The man pages for PCRE2 say that pcre2_jit_match is the fastest\n        // way to execute a JIT match because it skips sanity checks. We also\n        // explicitly disable the UTF-8 validity check, but it's probably not\n        // necessary.\n        let err = unsafe {\n            pcre2_jit_match_8(\n                self.code,\n                text.as_ptr(),\n                text.len(),\n                start,\n                PCRE2_NO_UTF_CHECK,\n                self.match_data,\n                ptr::null_mut(),\n            )\n        };\n        if err == PCRE2_ERROR_NOMATCH {\n            None\n        } else if err < 0 {\n            panic!(\"unknown error code: {:?}\", err)\n        } else {\n            Some(unsafe { (*self.ovector, *self.ovector.offset(1)) })\n        }\n    }\n}\n\npub struct FindMatches<'r, 't> {\n    re: &'r Regex,\n    text: &'t str,\n    last_match_end: usize,\n}\n\nimpl<'r, 't> Iterator for FindMatches<'r, 't> {\n    type Item = (usize, usize);\n\n    fn next(&mut self) -> Option<(usize, usize)> {\n        match self.re.find_at(self.text, self.last_match_end) {\n            None => None,\n            Some((s, e)) => {\n                self.last_match_end = e;\n                Some((s, e))\n            }\n        }\n    }\n}\n\nimpl fmt::Debug for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        const BUF_LEN: size_t = 256;\n        let mut buf = [0; BUF_LEN];\n        let len = unsafe {\n            pcre2_get_error_message_8(self.code, buf.as_mut_ptr(), BUF_LEN)\n        };\n        if len < 0 {\n            write!(\n                f,\n                \"Unknown PCRE error. (code: {:?}, offset: {:?})\",\n                self.code, self.offset\n            )\n        } else {\n            let msg = str::from_utf8(&buf[..len as usize]).unwrap();\n            write!(f, \"error at {:?}: {}\", self.offset, msg)\n        }\n    }\n}\n\n// PCRE2 FFI. We only wrap the bits we need.\n\nconst PCRE2_UCP: uint32_t = 0x00020000;\nconst PCRE2_UTF: uint32_t = 0x00080000;\nconst PCRE2_NO_UTF_CHECK: uint32_t = 0x40000000;\nconst PCRE2_JIT_COMPLETE: uint32_t = 0x00000001;\nconst PCRE2_ERROR_NOMATCH: c_int = -1;\n\ntype code = c_void;\n\ntype match_data = c_void;\n\ntype compile_context = c_void; // unused\n\ntype general_context = c_void; // unused\n\ntype match_context = c_void; // unused\n\nextern \"C\" {\n    fn pcre2_compile_8(\n        pattern: *const uint8_t,\n        len: size_t,\n        options: uint32_t,\n        error_code: *mut c_int,\n        error_offset: *mut size_t,\n        context: *mut compile_context,\n    ) -> *mut code;\n\n    fn pcre2_code_free_8(code: *mut code);\n\n    fn pcre2_match_data_create_from_pattern_8(\n        code: *const code,\n        context: *mut general_context,\n    ) -> *mut match_data;\n\n    fn pcre2_match_data_free_8(match_data: *mut match_data);\n\n    fn pcre2_get_ovector_pointer_8(match_data: *mut match_data)\n        -> *mut size_t;\n\n    fn pcre2_jit_compile_8(code: *const code, options: uint32_t) -> c_int;\n\n    fn pcre2_jit_match_8(\n        code: *const code,\n        subject: *const uint8_t,\n        length: size_t,\n        startoffset: size_t,\n        options: uint32_t,\n        match_data: *mut match_data,\n        match_context: *mut match_context,\n    ) -> c_int;\n\n    fn pcre2_get_error_message_8(\n        error_code: c_int,\n        buf: *mut uint8_t,\n        buflen: size_t,\n    ) -> c_int;\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":55},{"path":["/","usr","src","regex","bench","src","ffi","re2.rs"],"content":"#![allow(non_camel_case_types)]\n\nuse libc::{c_int, c_uchar, c_void};\n\n/// Regex wraps an RE2 regular expression.\n///\n/// It cannot be used safely from multiple threads simultaneously.\npub struct Regex {\n    re: *mut re2_regexp,\n}\n\nunsafe impl Send for Regex {}\n\nimpl Drop for Regex {\n    fn drop(&mut self) {\n        unsafe {\n            re2_regexp_free(self.re);\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct Error(());\n\nimpl Regex {\n    pub fn new(pattern: &str) -> Result<Regex, Error> {\n        unsafe { Ok(Regex { re: re2_regexp_new(pattern.into()) }) }\n    }\n\n    pub fn is_match(&self, text: &str) -> bool {\n        unsafe {\n            re2_regexp_match(self.re, text.into(), 0, text.len() as c_int)\n        }\n    }\n\n    pub fn find_iter<'r, 't>(&'r self, text: &'t str) -> FindMatches<'r, 't> {\n        FindMatches { re: self, text: text, last_end: 0, last_match: None }\n    }\n\n    fn find_at(&self, text: &str, start: usize) -> Option<(usize, usize)> {\n        let (mut s, mut e): (c_int, c_int) = (0, 0);\n        let matched = unsafe {\n            re2_regexp_find(\n                self.re,\n                text.into(),\n                start as c_int,\n                text.len() as c_int,\n                &mut s,\n                &mut e,\n            )\n        };\n        if matched {\n            Some((s as usize, e as usize))\n        } else {\n            None\n        }\n    }\n}\n\npub struct FindMatches<'r, 't> {\n    re: &'r Regex,\n    text: &'t str,\n    last_end: usize,\n    last_match: Option<usize>,\n}\n\n// This implementation is identical to the one Rust uses, since both Rust's\n// regex engine and RE2 handle empty matches in the same way.\nimpl<'r, 't> Iterator for FindMatches<'r, 't> {\n    type Item = (usize, usize);\n\n    fn next(&mut self) -> Option<(usize, usize)> {\n        fn next_after_empty(text: &str, i: usize) -> usize {\n            let b = match text.as_bytes().get(i) {\n                None => return text.len() + 1,\n                Some(&b) => b,\n            };\n            let inc = if b <= 0x7F {\n                1\n            } else if b <= 0b110_11111 {\n                2\n            } else if b <= 0b1110_1111 {\n                3\n            } else {\n                4\n            };\n            i + inc\n        }\n\n        if self.last_end > self.text.len() {\n            return None;\n        }\n        let (s, e) = match self.re.find_at(self.text, self.last_end) {\n            None => return None,\n            Some((s, e)) => (s, e),\n        };\n        assert!(s >= self.last_end);\n        if s == e {\n            // This is an empty match. To ensure we make progress, start\n            // the next search at the smallest possible starting position\n            // of the next match following this one.\n            self.last_end = next_after_empty(&self.text, e);\n            // Don't accept empty matches immediately following a match.\n            // Just move on to the next match.\n            if Some(e) == self.last_match {\n                return self.next();\n            }\n        } else {\n            self.last_end = e;\n        }\n        self.last_match = Some(self.last_end);\n        Some((s, e))\n    }\n}\n\n// RE2 FFI is below. Note that this uses a hand-rolled C API that is defined\n// in re2.cpp.\n\ntype re2_regexp = c_void;\n\n#[repr(C)]\nstruct re2_string {\n    text: *const c_uchar,\n    len: c_int,\n}\n\nimpl<'a> From<&'a str> for re2_string {\n    fn from(s: &'a str) -> re2_string {\n        re2_string { text: s.as_ptr(), len: s.len() as c_int }\n    }\n}\n\nextern \"C\" {\n    fn re2_regexp_new(pat: re2_string) -> *mut re2_regexp;\n    fn re2_regexp_free(re: *mut re2_regexp);\n    fn re2_regexp_match(\n        re: *mut re2_regexp,\n        text: re2_string,\n        startpos: c_int,\n        endpos: c_int,\n    ) -> bool;\n    fn re2_regexp_find(\n        re: *mut re2_regexp,\n        text: re2_string,\n        startpos: c_int,\n        endpos: c_int,\n        match_start: *mut c_int,\n        match_end: *mut c_int,\n    ) -> bool;\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":46},{"path":["/","usr","src","regex","bench","src","ffi","stdcpp.rs"],"content":"#![allow(non_camel_case_types)]\n\nuse libc::{c_int, c_uchar, c_void};\n\n/// Regex wraps a std::regex regular expression.\n///\n/// It cannot be used safely from multiple threads simultaneously.\npub struct Regex {\n    re: *mut stdcpp_regexp,\n}\n\nunsafe impl Send for Regex {}\n\nimpl Drop for Regex {\n    fn drop(&mut self) {\n        unsafe {\n            stdcpp_regexp_free(self.re);\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct Error(());\n\nimpl Regex {\n    pub fn new(pattern: &str) -> Result<Regex, Error> {\n        unsafe { Ok(Regex { re: stdcpp_regexp_new(pattern.into()) }) }\n    }\n\n    pub fn is_match(&self, text: &str) -> bool {\n        unsafe {\n            stdcpp_regexp_match(self.re, text.into(), 0, text.len() as c_int)\n        }\n    }\n\n    pub fn find_iter<'r, 't>(&'r self, text: &'t str) -> FindMatches<'r, 't> {\n        FindMatches { re: self, text: text, last_end: 0, last_match: None }\n    }\n\n    fn find_at(&self, text: &str, start: usize) -> Option<(usize, usize)> {\n        let (mut s, mut e): (c_int, c_int) = (0, 0);\n        let matched = unsafe {\n            stdcpp_regexp_find(\n                self.re,\n                text.into(),\n                start as c_int,\n                text.len() as c_int,\n                &mut s,\n                &mut e,\n            )\n        };\n        if matched {\n            Some((s as usize, e as usize))\n        } else {\n            None\n        }\n    }\n}\n\npub struct FindMatches<'r, 't> {\n    re: &'r Regex,\n    text: &'t str,\n    last_end: usize,\n    last_match: Option<usize>,\n}\n\n// This implementation is identical to the one Rust uses, since both Rust's\n// regex engine and std::regex handle empty matches in the same way.\nimpl<'r, 't> Iterator for FindMatches<'r, 't> {\n    type Item = (usize, usize);\n\n    fn next(&mut self) -> Option<(usize, usize)> {\n        fn next_after_empty(text: &str, i: usize) -> usize {\n            let b = match text.as_bytes().get(i) {\n                None => return text.len() + 1,\n                Some(&b) => b,\n            };\n            let inc = if b <= 0x7F {\n                1\n            } else if b <= 0b110_11111 {\n                2\n            } else if b <= 0b1110_1111 {\n                3\n            } else {\n                4\n            };\n            i + inc\n        }\n\n        if self.last_end > self.text.len() {\n            return None;\n        }\n        let (s, e) = match self.re.find_at(self.text, self.last_end) {\n            None => return None,\n            Some((s, e)) => (s, e),\n        };\n        assert!(s >= self.last_end);\n        if s == e {\n            // This is an empty match. To ensure we make progress, start\n            // the next search at the smallest possible starting position\n            // of the next match following this one.\n            self.last_end = next_after_empty(&self.text, e);\n            // Don't accept empty matches immediately following a match.\n            // Just move on to the next match.\n            if Some(e) == self.last_match {\n                return self.next();\n            }\n        } else {\n            self.last_end = e;\n        }\n        self.last_match = Some(self.last_end);\n        Some((s, e))\n    }\n}\n\n// stdcpp FFI is below. Note that this uses a hand-rolled C API that is defined\n// in stdcpp.cpp.\n\ntype stdcpp_regexp = c_void;\n\n#[repr(C)]\nstruct stdcpp_string {\n    text: *const c_uchar,\n    len: c_int,\n}\n\nimpl<'a> From<&'a str> for stdcpp_string {\n    fn from(s: &'a str) -> stdcpp_string {\n        stdcpp_string { text: s.as_ptr(), len: s.len() as c_int }\n    }\n}\n\nextern \"C\" {\n    fn stdcpp_regexp_new(pat: stdcpp_string) -> *mut stdcpp_regexp;\n    fn stdcpp_regexp_free(re: *mut stdcpp_regexp);\n    fn stdcpp_regexp_match(\n        re: *mut stdcpp_regexp,\n        text: stdcpp_string,\n        startpos: c_int,\n        endpos: c_int,\n    ) -> bool;\n    fn stdcpp_regexp_find(\n        re: *mut stdcpp_regexp,\n        text: stdcpp_string,\n        startpos: c_int,\n        endpos: c_int,\n        match_start: *mut c_int,\n        match_end: *mut c_int,\n    ) -> bool;\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":46},{"path":["/","usr","src","regex","bench","src","ffi","tcl.rs"],"content":"#![allow(non_camel_case_types)]\n\nuse std::mem;\nuse std::ptr;\nuse std::sync::Once;\n\nuse libc::{c_char, c_int, c_long, c_void};\n\n// Used to initialize the TCL interpreter exactly once.\nstatic ONCE: Once = Once::new();\n\n/// Text is a TCL string object backed by a Rust string.\n///\n/// This is a special type that is created once per benchmark and is not\n/// included in timings. In particular, all regex searches execute on values\n/// of this type, so we're careful to avoid the overhead of creating such\n/// objects on every search.\npub struct Text {\n    s: String,\n    obj: *mut tcl_obj,\n}\n\n// TCL's objects are ref-counted in a thread-unsafe manner, which would\n// normally disqualify a Send bound. However, we don't permit Text to be used\n// in a way that can lead to unsafety. In particular, the ref count is always\n// 1, until it is dropped, in which the ref count is decreased to zero and\n// the underlying memory is freed.\nunsafe impl Send for Text {}\n\nimpl Drop for Text {\n    fn drop(&mut self) {\n        unsafe {\n            assert_eq!((*self.obj).ref_count, 1);\n            // This will drop the ref count to 0 and cause it to be freed.\n            (*self.obj).decr_ref_count();\n        }\n    }\n}\n\nimpl Text {\n    pub fn new(text: String) -> Text {\n        let ptr = text.as_ptr() as *const c_char;\n        let len = text.len() as c_int;\n        let obj = unsafe { Tcl_NewStringObj(ptr, len) };\n        unsafe {\n            (*obj).incr_ref_count();\n        }\n        Text { s: text, obj: obj }\n    }\n\n    pub fn len(&self) -> usize {\n        self.s.len()\n    }\n}\n\n/// Regex wraps a TCL regex. It owns a TCL string object and a pointer to a\n/// regexp object. The two share storage.\n///\n/// There's no Drop impl for Regex because the memory for the regex will be\n/// freed when `pat` is dropped.\npub struct Regex {\n    pat: Text,\n    re: *mut tcl_regexp,\n}\n\nunsafe impl Send for Regex {}\n\n#[derive(Debug)]\npub struct Error(());\n\nimpl Regex {\n    pub fn new(pattern: &str) -> Result<Regex, Error> {\n        ONCE.call_once(|| unsafe {\n            Tcl_CreateInterp();\n        });\n\n        let pat = Text::new(pattern.to_owned());\n        let re = unsafe {\n            Tcl_GetRegExpFromObj(ptr::null_mut(), pat.obj, TCL_REG_ADVANCED)\n        };\n        if re.is_null() {\n            return Err(Error(()));\n        }\n        Ok(Regex { pat: pat, re: re })\n    }\n\n    pub fn is_match(&self, text: &Text) -> bool {\n        let result = unsafe {\n            Tcl_RegExpExecObj(ptr::null_mut(), self.re, text.obj, 0, 1, 0)\n        };\n        if result == -1 {\n            panic!(\"Tcl_RegExpExecObj failed\");\n        }\n        result > 0\n    }\n\n    pub fn find_iter<'r, 't>(&'r self, text: &'t Text) -> FindMatches<'r, 't> {\n        FindMatches { re: self, text: text, last_match: 0 }\n    }\n\n    fn find_at(&self, text: &Text, start: usize) -> Option<(usize, usize)> {\n        let result = unsafe {\n            Tcl_RegExpExecObj(\n                ptr::null_mut(),\n                self.re,\n                text.obj,\n                start as c_int,\n                1,\n                0,\n            )\n        };\n        if result == -1 {\n            panic!(\"Tcl_RegExpExecObj failed\");\n        } else if result == 0 {\n            return None;\n        }\n        let mut info: tcl_regexp_info = unsafe { mem::zeroed() };\n        unsafe {\n            Tcl_RegExpGetInfo(self.re, &mut info);\n            let s = start as c_long + (*info.matches).start;\n            let e = start as c_long + (*info.matches).end;\n            Some((s as usize, e as usize))\n        }\n    }\n}\n\npub struct FindMatches<'r, 't> {\n    re: &'r Regex,\n    text: &'t Text,\n    last_match: usize,\n}\n\nimpl<'r, 't> Iterator for FindMatches<'r, 't> {\n    type Item = (usize, usize);\n\n    fn next(&mut self) -> Option<(usize, usize)> {\n        match self.re.find_at(self.text, self.last_match) {\n            None => None,\n            Some((s, e)) => {\n                self.last_match = e;\n                Some((s, e))\n            }\n        }\n    }\n}\n\n// TCL's FFI. We only wrap the bits we need.\n\nconst TCL_REG_ADVANCED: c_int = 3;\n\ntype tcl_interp = c_void;\ntype tcl_regexp = c_void;\n\n#[repr(C)]\nstruct tcl_obj {\n    ref_count: c_int,\n    // There are more fields, but we don't care about them.\n    // We're careful to only access ref_count so we can increment/decrement it.\n    // This is necessary because Tcl_IncRefCount and Tcl_DecrRefCount are\n    // macros.\n}\n\nimpl tcl_obj {\n    unsafe fn incr_ref_count(&mut self) {\n        self.ref_count += 1;\n    }\n\n    unsafe fn decr_ref_count(&mut self) {\n        self.ref_count -= 1;\n        if self.ref_count <= 0 {\n            TclFreeObj(self);\n        }\n    }\n}\n\n#[repr(C)]\nstruct tcl_regexp_info {\n    nsubs: c_int,\n    matches: *mut tcl_regexp_indices,\n    extend_start: c_long,\n    reserved: c_long,\n}\n\n#[repr(C)]\nstruct tcl_regexp_indices {\n    start: c_long,\n    end: c_long,\n}\n\nextern \"C\" {\n    fn Tcl_CreateInterp() -> *mut tcl_interp;\n\n    fn Tcl_NewStringObj(pat: *const c_char, len: c_int) -> *mut tcl_obj;\n\n    fn TclFreeObj(obj: *mut tcl_obj);\n\n    fn Tcl_GetRegExpFromObj(\n        int: *mut tcl_interp,\n        pat: *mut tcl_obj,\n        flags: c_int,\n    ) -> *mut tcl_regexp;\n\n    fn Tcl_RegExpExecObj(\n        int: *mut tcl_interp,\n        re: *mut tcl_regexp,\n        text: *mut tcl_obj,\n        offset: c_int,\n        nmatches: c_int,\n        flags: c_int,\n    ) -> c_int;\n\n    fn Tcl_RegExpGetInfo(re: *mut tcl_regexp, info: *mut tcl_regexp_info);\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":50},{"path":["/","usr","src","regex","bench","src","main.rs"],"content":"extern crate docopt;\nextern crate libc;\n#[cfg(feature = \"re-pcre1\")]\nextern crate libpcre_sys;\nextern crate memmap;\n#[cfg(feature = \"re-onig\")]\nextern crate onig;\n#[cfg(any(feature = \"re-rust\", feature = \"re-rust-bytes\",))]\nextern crate regex;\n#[cfg(feature = \"re-rust\")]\nextern crate regex_syntax;\nextern crate serde;\n#[macro_use]\nextern crate serde_derive;\n\nuse std::fs::File;\nuse std::str;\n\nuse docopt::Docopt;\nuse memmap::Mmap;\n\nmod ffi;\n\nconst USAGE: &'static str = \"\nCount the number of matches of <pattern> in <file>.\n\nThis compiles the pattern once and counts all successive non-overlapping\nmatches in <file>. <file> is memory mapped. Matching is done as if <file> were\na single string (it is not line oriented).\n\nSince this tool includes compilation of the <pattern>, sufficiently large\nhaystacks should be used to amortize the cost of compilation. (e.g., >1MB.)\n\nUsage:\n    regex-run-one [options] [onig | pcre1 | pcre2 | stdcpp | re2 | rust | rust-bytes | tcl] <file> <pattern>\n    regex-run-one [options] (-h | --help)\n\nOptions:\n    -h, --help   Show this usage message.\n\";\n\n#[derive(Debug, Deserialize)]\nstruct Args {\n    arg_pattern: String,\n    arg_file: String,\n    cmd_onig: bool,\n    cmd_pcre1: bool,\n    cmd_pcre2: bool,\n    cmd_stdcpp: bool,\n    cmd_re2: bool,\n    cmd_rust: bool,\n    cmd_rust_bytes: bool,\n    cmd_tcl: bool,\n}\n\nfn main() {\n    let args: Args = Docopt::new(USAGE)\n        .and_then(|d| d.deserialize())\n        .unwrap_or_else(|e| e.exit());\n\n    let mmap =\n        unsafe { Mmap::map(&File::open(&args.arg_file).unwrap()).unwrap() };\n    let haystack = unsafe { str::from_utf8_unchecked(&mmap) };\n\n    println!(\"{}\", args.count(&haystack));\n}\n\nimpl Args {\n    fn count(&self, haystack: &str) -> usize {\n        let pat = &self.arg_pattern;\n        if self.cmd_onig {\n            count_onig(pat, haystack)\n        } else if self.cmd_pcre1 {\n            count_pcre1(pat, haystack)\n        } else if self.cmd_pcre2 {\n            count_pcre2(pat, haystack)\n        } else if self.cmd_stdcpp {\n            count_stdcpp(pat, haystack)\n        } else if self.cmd_re2 {\n            count_re2(pat, haystack)\n        } else if self.cmd_rust {\n            count_rust(pat, haystack)\n        } else if self.cmd_rust_bytes {\n            count_rust_bytes(pat, haystack)\n        } else if self.cmd_tcl {\n            count_tcl(pat, haystack)\n        } else {\n            panic!(\"unreachable\")\n        }\n    }\n}\n\nmacro_rules! nada {\n    ($feature:expr, $name:ident) => {\n        #[cfg(not(feature = $feature))]\n        fn $name(_pat: &str, _haystack: &str) -> usize {\n            panic!(\n                \"Support not enabled. Re-compile with '--features {}' \\\n                 to enable.\",\n                $feature\n            )\n        }\n    };\n}\n\nnada!(\"re-onig\", count_onig);\n#[cfg(feature = \"re-onig\")]\nfn count_onig(pat: &str, haystack: &str) -> usize {\n    use ffi::onig::Regex;\n    Regex::new(pat).unwrap().find_iter(haystack).count()\n}\n\nnada!(\"re-pcre1\", count_pcre1);\n#[cfg(feature = \"re-pcre1\")]\nfn count_pcre1(pat: &str, haystack: &str) -> usize {\n    use ffi::pcre1::Regex;\n    Regex::new(pat).unwrap().find_iter(haystack).count()\n}\n\nnada!(\"re-pcre2\", count_pcre2);\n#[cfg(feature = \"re-pcre2\")]\nfn count_pcre2(pat: &str, haystack: &str) -> usize {\n    use ffi::pcre2::Regex;\n    Regex::new(pat).unwrap().find_iter(haystack).count()\n}\n\n#[cfg(not(any(feature = \"re-stdcpp\", feature = \"re-boost\",)))]\nnada!(\"re-stdcpp\", count_stdcpp);\n#[cfg(any(feature = \"re-stdcpp\", feature = \"re-boost\",))]\nfn count_stdcpp(pat: &str, haystack: &str) -> usize {\n    use ffi::stdcpp::Regex;\n    Regex::new(pat).unwrap().find_iter(haystack).count()\n}\n\nnada!(\"re-re2\", count_re2);\n#[cfg(feature = \"re-re2\")]\nfn count_re2(pat: &str, haystack: &str) -> usize {\n    use ffi::re2::Regex;\n    Regex::new(pat).unwrap().find_iter(haystack).count()\n}\n\nnada!(\"re-rust\", count_rust);\n#[cfg(feature = \"re-rust\")]\nfn count_rust(pat: &str, haystack: &str) -> usize {\n    use regex::Regex;\n    Regex::new(pat).unwrap().find_iter(haystack).count()\n}\n\nnada!(\"re-rust-bytes\", count_rust_bytes);\n#[cfg(feature = \"re-rust-bytes\")]\nfn count_rust_bytes(pat: &str, haystack: &str) -> usize {\n    use regex::bytes::Regex;\n    Regex::new(pat).unwrap().find_iter(haystack.as_bytes()).count()\n}\n\nnada!(\"re-tcl\", count_tcl);\n#[cfg(feature = \"re-tcl\")]\nfn count_tcl(pat: &str, haystack: &str) -> usize {\n    use ffi::tcl::{Regex, Text};\n    Regex::new(pat).unwrap().find_iter(&Text::new(haystack.to_owned())).count()\n}\n","traces":[{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":19},{"path":["/","usr","src","regex","regex-capi","src","error.rs"],"content":"use std::ffi;\nuse std::ffi::CString;\nuse std::fmt;\nuse std::str;\n\nuse libc::c_char;\nuse regex;\n\n#[derive(Debug)]\npub struct Error {\n    message: Option<CString>,\n    kind: ErrorKind,\n}\n\n#[derive(Debug)]\npub enum ErrorKind {\n    None,\n    Str(str::Utf8Error),\n    Regex(regex::Error),\n    Nul(ffi::NulError),\n}\n\nimpl Error {\n    pub fn new(kind: ErrorKind) -> Error {\n        Error { message: None, kind: kind }\n    }\n\n    pub fn is_err(&self) -> bool {\n        match self.kind {\n            ErrorKind::None => false,\n            ErrorKind::Str(_) | ErrorKind::Regex(_) | ErrorKind::Nul(_) => {\n                true\n            }\n        }\n    }\n}\n\nimpl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self.kind {\n            ErrorKind::None => write!(f, \"no error\"),\n            ErrorKind::Str(ref e) => e.fmt(f),\n            ErrorKind::Regex(ref e) => e.fmt(f),\n            ErrorKind::Nul(ref e) => e.fmt(f),\n        }\n    }\n}\n\nffi_fn! {\n    fn rure_error_new() -> *mut Error {\n        Box::into_raw(Box::new(Error::new(ErrorKind::None)))\n    }\n}\n\nffi_fn! {\n    fn rure_error_free(err: *mut Error) {\n        unsafe { Box::from_raw(err); }\n    }\n}\n\nffi_fn! {\n    fn rure_error_message(err: *mut Error) -> *const c_char {\n        let err = unsafe { &mut *err };\n        let cmsg = match CString::new(format!(\"{}\", err)) {\n            Ok(msg) => msg,\n            Err(err) => {\n                // I guess this can probably happen if the regex itself has a\n                // NUL, and that NUL re-occurs in the context presented by the\n                // error message. In this case, just show as much as we can.\n                let nul = err.nul_position();\n                let msg = err.into_vec();\n                CString::new(msg[0..nul].to_owned()).unwrap()\n            }\n        };\n        let p = cmsg.as_ptr();\n        err.message = Some(cmsg);\n        p\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":12},{"path":["/","usr","src","regex","regex-capi","src","rure.rs"],"content":"use std::collections::HashMap;\nuse std::ffi::{CStr, CString};\nuse std::ops::Deref;\nuse std::ptr;\nuse std::slice;\nuse std::str;\n\nuse libc::{c_char, size_t};\nuse regex::bytes;\n\nuse error::{Error, ErrorKind};\n\nconst RURE_FLAG_CASEI: u32 = 1 << 0;\nconst RURE_FLAG_MULTI: u32 = 1 << 1;\nconst RURE_FLAG_DOTNL: u32 = 1 << 2;\nconst RURE_FLAG_SWAP_GREED: u32 = 1 << 3;\nconst RURE_FLAG_SPACE: u32 = 1 << 4;\nconst RURE_FLAG_UNICODE: u32 = 1 << 5;\nconst RURE_DEFAULT_FLAGS: u32 = RURE_FLAG_UNICODE;\n\npub struct Regex {\n    re: bytes::Regex,\n    capture_names: HashMap<String, i32>,\n}\n\npub struct Options {\n    size_limit: usize,\n    dfa_size_limit: usize,\n}\n\n// The `RegexSet` is not exposed with option support or matching at an\n// arbitrary position with a crate just yet. To circumvent this, we use\n// the `Exec` structure directly.\npub struct RegexSet {\n    re: bytes::RegexSet,\n}\n\n#[repr(C)]\npub struct rure_match {\n    pub start: size_t,\n    pub end: size_t,\n}\n\npub struct Captures(bytes::Locations);\n\npub struct Iter {\n    re: *const Regex,\n    last_end: usize,\n    last_match: Option<usize>,\n}\n\npub struct IterCaptureNames {\n    capture_names: bytes::CaptureNames<'static>,\n    name_ptrs: Vec<*mut c_char>,\n}\n\nimpl Deref for Regex {\n    type Target = bytes::Regex;\n    fn deref(&self) -> &bytes::Regex {\n        &self.re\n    }\n}\n\nimpl Deref for RegexSet {\n    type Target = bytes::RegexSet;\n    fn deref(&self) -> &bytes::RegexSet {\n        &self.re\n    }\n}\n\nimpl Default for Options {\n    fn default() -> Options {\n        Options { size_limit: 10 * (1 << 20), dfa_size_limit: 2 * (1 << 20) }\n    }\n}\n\nffi_fn! {\n    fn rure_compile_must(pattern: *const c_char) -> *const Regex {\n        let len = unsafe { CStr::from_ptr(pattern).to_bytes().len() };\n        let pat = pattern as *const u8;\n        let mut err = Error::new(ErrorKind::None);\n        let re = rure_compile(\n            pat, len, RURE_DEFAULT_FLAGS, ptr::null(), &mut err);\n        if err.is_err() {\n            let _ = writeln!(&mut io::stderr(), \"{}\", err);\n            let _ = writeln!(\n                &mut io::stderr(), \"aborting from rure_compile_must\");\n            unsafe { abort() }\n        }\n        re\n    }\n}\n\nffi_fn! {\n    fn rure_compile(\n        pattern: *const u8,\n        length: size_t,\n        flags: u32,\n        options: *const Options,\n        error: *mut Error,\n    ) -> *const Regex {\n        let pat = unsafe { slice::from_raw_parts(pattern, length) };\n        let pat = match str::from_utf8(pat) {\n            Ok(pat) => pat,\n            Err(err) => {\n                unsafe {\n                    if !error.is_null() {\n                        *error = Error::new(ErrorKind::Str(err));\n                    }\n                    return ptr::null();\n                }\n            }\n        };\n        let mut builder = bytes::RegexBuilder::new(pat);\n        if !options.is_null() {\n            let options = unsafe { &*options };\n            builder.size_limit(options.size_limit);\n            builder.dfa_size_limit(options.dfa_size_limit);\n        }\n        builder.case_insensitive(flags & RURE_FLAG_CASEI > 0);\n        builder.multi_line(flags & RURE_FLAG_MULTI > 0);\n        builder.dot_matches_new_line(flags & RURE_FLAG_DOTNL > 0);\n        builder.swap_greed(flags & RURE_FLAG_SWAP_GREED > 0);\n        builder.ignore_whitespace(flags & RURE_FLAG_SPACE > 0);\n        builder.unicode(flags & RURE_FLAG_UNICODE > 0);\n        match builder.build() {\n            Ok(re) => {\n                let mut capture_names = HashMap::new();\n                for (i, name) in re.capture_names().enumerate() {\n                    if let Some(name) = name {\n                        capture_names.insert(name.to_owned(), i as i32);\n                    }\n                }\n                let re = Regex {\n                    re: re,\n                    capture_names: capture_names,\n                };\n                Box::into_raw(Box::new(re))\n            }\n            Err(err) => {\n                unsafe {\n                    if !error.is_null() {\n                        *error = Error::new(ErrorKind::Regex(err));\n                    }\n                    ptr::null()\n                }\n            }\n        }\n    }\n}\n\nffi_fn! {\n    fn rure_free(re: *const Regex) {\n        unsafe { Box::from_raw(re as *mut Regex); }\n    }\n}\n\nffi_fn! {\n    fn rure_is_match(\n        re: *const Regex,\n        haystack: *const u8,\n        len: size_t,\n        start: size_t,\n    ) -> bool {\n        let re = unsafe { &*re };\n        let haystack = unsafe { slice::from_raw_parts(haystack, len) };\n        re.is_match_at(haystack, start)\n    }\n}\n\nffi_fn! {\n    fn rure_find(\n        re: *const Regex,\n        haystack: *const u8,\n        len: size_t,\n        start: size_t,\n        match_info: *mut rure_match,\n    ) -> bool {\n        let re = unsafe { &*re };\n        let haystack = unsafe { slice::from_raw_parts(haystack, len) };\n        re.find_at(haystack, start).map(|m| unsafe {\n            if !match_info.is_null() {\n                (*match_info).start = m.start();\n                (*match_info).end = m.end();\n            }\n        }).is_some()\n    }\n}\n\nffi_fn! {\n    fn rure_find_captures(\n        re: *const Regex,\n        haystack: *const u8,\n        len: size_t,\n        start: size_t,\n        captures: *mut Captures,\n    ) -> bool {\n        let re = unsafe { &*re };\n        let haystack = unsafe { slice::from_raw_parts(haystack, len) };\n        let slots = unsafe { &mut (*captures).0 };\n        re.read_captures_at(slots, haystack, start).is_some()\n    }\n}\n\nffi_fn! {\n    fn rure_shortest_match(\n        re: *const Regex,\n        haystack: *const u8,\n        len: size_t,\n        start: size_t,\n        end: *mut usize,\n    ) -> bool {\n        let re = unsafe { &*re };\n        let haystack = unsafe { slice::from_raw_parts(haystack, len) };\n        match re.shortest_match_at(haystack, start) {\n            None => false,\n            Some(i) => {\n                if !end.is_null() {\n                    unsafe {\n                        *end = i;\n                    }\n                }\n                true\n            }\n        }\n    }\n}\n\nffi_fn! {\n    fn rure_capture_name_index(\n        re: *const Regex,\n        name: *const c_char,\n    ) -> i32 {\n        let re = unsafe { &*re };\n        let name = unsafe { CStr::from_ptr(name) };\n        let name = match name.to_str() {\n            Err(_) => return -1,\n            Ok(name) => name,\n        };\n        re.capture_names.get(name).map(|&i|i).unwrap_or(-1)\n    }\n}\n\nffi_fn! {\n    fn rure_iter_capture_names_new(\n        re: *const Regex,\n    ) -> *mut IterCaptureNames {\n        let re = unsafe { &*re };\n        Box::into_raw(Box::new(IterCaptureNames {\n            capture_names: re.re.capture_names(),\n            name_ptrs: Vec::new(),\n        }))\n    }\n}\n\nffi_fn! {\n    fn rure_iter_capture_names_free(it: *mut IterCaptureNames) {\n        unsafe {\n            let it = &mut *it;\n            while let Some(ptr) = it.name_ptrs.pop(){\n                CString::from_raw(ptr);\n            }\n            Box::from_raw(it);\n        }\n    }\n}\n\nffi_fn! {\n    fn rure_iter_capture_names_next(\n        it: *mut IterCaptureNames,\n        capture_name: *mut *mut c_char,\n    ) -> bool {\n        if capture_name.is_null() {\n            return false;\n        }\n\n        let it = unsafe { &mut *it };\n        let cn = match it.capture_names.next() {\n            // Top-level iterator ran out of capture groups\n            None => return false,\n            Some(val) => {\n                let name = match val {\n                    // inner Option didn't have a name\n                    None => \"\",\n                    Some(name) => name\n                };\n                name\n            }\n        };\n\n        unsafe {\n            let cs = match CString::new(cn.as_bytes()) {\n                Result::Ok(val) => val,\n                Result::Err(_) => return false\n            };\n            let ptr = cs.into_raw();\n            it.name_ptrs.push(ptr);\n            *capture_name = ptr;\n        }\n        true\n\n    }\n}\n\nffi_fn! {\n    fn rure_iter_new(\n        re: *const Regex,\n    ) -> *mut Iter {\n        Box::into_raw(Box::new(Iter {\n            re: re,\n            last_end: 0,\n            last_match: None,\n        }))\n    }\n}\n\nffi_fn! {\n    fn rure_iter_free(it: *mut Iter) {\n        unsafe { Box::from_raw(it); }\n    }\n}\n\nffi_fn! {\n    fn rure_iter_next(\n        it: *mut Iter,\n        haystack: *const u8,\n        len: size_t,\n        match_info: *mut rure_match,\n    ) -> bool {\n        let it = unsafe { &mut *it };\n        let re = unsafe { &*it.re };\n        let text = unsafe { slice::from_raw_parts(haystack, len) };\n        if it.last_end > text.len() {\n            return false;\n        }\n        let (s, e) = match re.find_at(text, it.last_end) {\n            None => return false,\n            Some(m) => (m.start(), m.end()),\n        };\n        if s == e {\n            // This is an empty match. To ensure we make progress, start\n            // the next search at the smallest possible starting position\n            // of the next match following this one.\n            it.last_end += 1;\n            // Don't accept empty matches immediately following a match.\n            // Just move on to the next match.\n            if Some(e) == it.last_match {\n                return rure_iter_next(it, haystack, len, match_info);\n            }\n        } else {\n            it.last_end = e;\n        }\n        it.last_match = Some(e);\n        if !match_info.is_null() {\n            unsafe {\n                (*match_info).start = s;\n                (*match_info).end = e;\n            }\n        }\n        true\n    }\n}\n\nffi_fn! {\n    fn rure_iter_next_captures(\n        it: *mut Iter,\n        haystack: *const u8,\n        len: size_t,\n        captures: *mut Captures,\n    ) -> bool {\n        let it = unsafe { &mut *it };\n        let re = unsafe { &*it.re };\n        let slots = unsafe { &mut (*captures).0 };\n        let text = unsafe { slice::from_raw_parts(haystack, len) };\n        if it.last_end > text.len() {\n            return false;\n        }\n        let (s, e) = match re.read_captures_at(slots, text, it.last_end) {\n            None => return false,\n            Some(m) => (m.start(), m.end()),\n        };\n        if s == e {\n            // This is an empty match. To ensure we make progress, start\n            // the next search at the smallest possible starting position\n            // of the next match following this one.\n            it.last_end += 1;\n            // Don't accept empty matches immediately following a match.\n            // Just move on to the next match.\n            if Some(e) == it.last_match {\n                return rure_iter_next_captures(it, haystack, len, captures);\n            }\n        } else {\n            it.last_end = e;\n        }\n        it.last_match = Some(e);\n        true\n    }\n}\n\nffi_fn! {\n    fn rure_captures_new(re: *const Regex) -> *mut Captures {\n        let re = unsafe { &*re };\n        let captures = Captures(re.locations());\n        Box::into_raw(Box::new(captures))\n    }\n}\n\nffi_fn! {\n    fn rure_captures_free(captures: *const Captures) {\n        unsafe { Box::from_raw(captures as *mut Captures); }\n    }\n}\n\nffi_fn! {\n    fn rure_captures_at(\n        captures: *const Captures,\n        i: size_t,\n        match_info: *mut rure_match,\n    ) -> bool {\n        let locs = unsafe { &(*captures).0 };\n        match locs.pos(i) {\n            Some((start, end)) => {\n                if !match_info.is_null() {\n                    unsafe {\n                        (*match_info).start = start;\n                        (*match_info).end = end;\n                    }\n                }\n                true\n            }\n            _ => false\n        }\n    }\n}\n\nffi_fn! {\n    fn rure_captures_len(captures: *const Captures) -> size_t {\n        unsafe { (*captures).0.len() }\n    }\n}\n\nffi_fn! {\n    fn rure_options_new() -> *mut Options {\n        Box::into_raw(Box::new(Options::default()))\n    }\n}\n\nffi_fn! {\n    fn rure_options_free(options: *mut Options) {\n        unsafe { Box::from_raw(options); }\n    }\n}\n\nffi_fn! {\n    fn rure_options_size_limit(options: *mut Options, limit: size_t) {\n        let options = unsafe { &mut *options };\n        options.size_limit = limit;\n    }\n}\n\nffi_fn! {\n    fn rure_options_dfa_size_limit(options: *mut Options, limit: size_t) {\n        let options = unsafe { &mut *options };\n        options.dfa_size_limit = limit;\n    }\n}\n\nffi_fn! {\n    fn rure_compile_set(\n        patterns: *const *const u8,\n        patterns_lengths: *const size_t,\n        patterns_count: size_t,\n        flags: u32,\n        options: *const Options,\n        error: *mut Error\n    ) -> *const RegexSet {\n        let (raw_pats, raw_patsl) = unsafe {\n            (\n                slice::from_raw_parts(patterns, patterns_count),\n                slice::from_raw_parts(patterns_lengths, patterns_count)\n            )\n        };\n\n        let mut pats = Vec::with_capacity(patterns_count);\n        for (&raw_pat, &raw_patl) in raw_pats.iter().zip(raw_patsl) {\n            let pat = unsafe { slice::from_raw_parts(raw_pat, raw_patl) };\n            pats.push(match str::from_utf8(pat) {\n                Ok(pat) => pat,\n                Err(err) => {\n                    unsafe {\n                        if !error.is_null() {\n                            *error = Error::new(ErrorKind::Str(err));\n                        }\n                        return ptr::null();\n                    }\n                }\n            });\n        }\n\n        let mut builder = bytes::RegexSetBuilder::new(pats);\n        if !options.is_null() {\n            let options = unsafe { &*options };\n            builder.size_limit(options.size_limit);\n            builder.dfa_size_limit(options.dfa_size_limit);\n        }\n        builder.case_insensitive(flags & RURE_FLAG_CASEI > 0);\n        builder.multi_line(flags & RURE_FLAG_MULTI > 0);\n        builder.dot_matches_new_line(flags & RURE_FLAG_DOTNL > 0);\n        builder.swap_greed(flags & RURE_FLAG_SWAP_GREED > 0);\n        builder.ignore_whitespace(flags & RURE_FLAG_SPACE > 0);\n        builder.unicode(flags & RURE_FLAG_UNICODE > 0);\n        match builder.build() {\n            Ok(re) => {\n                Box::into_raw(Box::new(RegexSet { re: re }))\n            }\n            Err(err) => {\n                unsafe {\n                    if !error.is_null() {\n                        *error = Error::new(ErrorKind::Regex(err))\n                    }\n                    ptr::null()\n                }\n            }\n        }\n    }\n}\n\nffi_fn! {\n    fn rure_set_free(re: *const RegexSet) {\n        unsafe { Box::from_raw(re as *mut RegexSet); }\n    }\n}\n\nffi_fn! {\n    fn rure_set_is_match(\n        re: *const RegexSet,\n        haystack: *const u8,\n        len: size_t,\n        start: size_t\n    ) -> bool {\n        let re = unsafe { &*re };\n        let haystack = unsafe { slice::from_raw_parts(haystack, len) };\n        re.is_match_at(haystack, start)\n    }\n}\n\nffi_fn! {\n    fn rure_set_matches(\n        re: *const RegexSet,\n        haystack: *const u8,\n        len: size_t,\n        start: size_t,\n        matches: *mut bool\n    ) -> bool {\n        let re = unsafe { &*re };\n        let mut matches = unsafe {\n            slice::from_raw_parts_mut(matches, re.len())\n        };\n        let haystack = unsafe { slice::from_raw_parts(haystack, len) };\n\n        // read_matches_at isn't guaranteed to set non-matches to false\n        for item in matches.iter_mut() {\n            *item = false;\n        }\n        re.read_matches_at(&mut matches, haystack, start)\n    }\n}\n\nffi_fn! {\n    fn rure_set_len(re: *const RegexSet) -> size_t {\n        unsafe { (*re).len() }\n    }\n}\n\nffi_fn! {\n    fn rure_escape_must(pattern: *const c_char) -> *const c_char {\n        let len = unsafe { CStr::from_ptr(pattern).to_bytes().len() };\n        let pat = pattern as *const u8;\n        let mut err = Error::new(ErrorKind::None);\n        let esc = rure_escape(pat, len, &mut err);\n        if err.is_err() {\n            let _ = writeln!(&mut io::stderr(), \"{}\", err);\n            let _ = writeln!(\n                &mut io::stderr(), \"aborting from rure_escape_must\");\n            unsafe { abort() }\n        }\n        esc\n    }\n}\n\n/// A helper function that implements fallible escaping in a way that returns\n/// an error if escaping failed.\n///\n/// This should ideally be exposed, but it needs API design work. In\n/// particular, this should not return a C string, but a `const uint8_t *`\n/// instead, since it may contain a NUL byte.\nfn rure_escape(\n    pattern: *const u8,\n    length: size_t,\n    error: *mut Error,\n) -> *const c_char {\n    let pat: &[u8] = unsafe { slice::from_raw_parts(pattern, length) };\n    let str_pat = match str::from_utf8(pat) {\n        Ok(val) => val,\n        Err(err) => unsafe {\n            if !error.is_null() {\n                *error = Error::new(ErrorKind::Str(err));\n            }\n            return ptr::null();\n        },\n    };\n    let esc_pat = regex::escape(str_pat);\n    let c_esc_pat = match CString::new(esc_pat) {\n        Ok(val) => val,\n        Err(err) => unsafe {\n            if !error.is_null() {\n                *error = Error::new(ErrorKind::Nul(err));\n            }\n            return ptr::null();\n        },\n    };\n    c_esc_pat.into_raw() as *const c_char\n}\n\nffi_fn! {\n    fn rure_cstring_free(s: *mut c_char) {\n        unsafe { CString::from_raw(s); }\n    }\n}\n","traces":[{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["/","usr","src","regex","regex-debug","src","main.rs"],"content":"extern crate docopt;\nextern crate regex;\nextern crate regex_syntax as syntax;\nextern crate serde;\n#[macro_use]\nextern crate serde_derive;\n\nuse std::error;\nuse std::io::{self, Write};\nuse std::process;\nuse std::result;\n\nuse docopt::Docopt;\nuse regex::internal::{Compiler, LiteralSearcher};\nuse syntax::hir::literal::Literals;\nuse syntax::hir::Hir;\n\nconst USAGE: &'static str = \"\nUsage:\n    regex-debug [options] ast <pattern>\n    regex-debug [options] hir <pattern>\n    regex-debug [options] prefixes <patterns> ...\n    regex-debug [options] suffixes <patterns> ...\n    regex-debug [options] anchors <pattern>\n    regex-debug [options] captures <pattern>\n    regex-debug [options] compile <patterns> ...\n    regex-debug [options] utf8-ranges <class>\n    regex-debug [options] utf8-ranges-rev <class>\n    regex-debug --help\n\nOptions:\n    --help               Show this usage message.\n    --size-limit ARG     An approximate size limit on the total size (in bytes)\n                         of a compiled regular expression program.\n                         [default: 10485760]\n    --bytes              Show the instruction codes for byte oriented programs.\n                         (As opposed to Unicode oriented programs.)\n    --dfa                Show the instruction codes for a DFA.\n    --dfa-reverse        Show the instruction codes for a reverse DFA.\n                         This implies --dfa.\n    -a, --all-literals   Shows all literals extracted.\n                         By default, only unambiguous literals are shown.\n    --literal-limit ARG  An approximate limit on the total size (in bytes)\n                         of all literals extracted. [default: 250]\n    --class-limit ARG    A limit on the size of character classes used to\n                         extract literals. [default: 10]\n    --literal-bytes      Show raw literal bytes instead of Unicode chars.\n    --lcp                Show the longest common prefix of all the literals\n                         extracted.\n    --lcs                Show the longest common suffix of all the literals\n                         extracted.\n    --searcher           Show the debug output for the literal searcher\n                         constructed by the literals found.\n    --quiet              Show less output.\n\";\n\n#[derive(Deserialize)]\nstruct Args {\n    cmd_ast: bool,\n    cmd_hir: bool,\n    cmd_prefixes: bool,\n    cmd_suffixes: bool,\n    cmd_anchors: bool,\n    cmd_captures: bool,\n    cmd_compile: bool,\n    cmd_utf8_ranges: bool,\n    cmd_utf8_ranges_rev: bool,\n\n    arg_pattern: String,\n    arg_patterns: Vec<String>,\n    arg_class: String,\n\n    flag_size_limit: usize,\n    flag_bytes: bool,\n    flag_dfa: bool,\n    flag_dfa_reverse: bool,\n    flag_all_literals: bool,\n    flag_literal_limit: usize,\n    flag_class_limit: usize,\n    flag_literal_bytes: bool,\n    flag_lcp: bool,\n    flag_lcs: bool,\n    flag_searcher: bool,\n    flag_quiet: bool,\n}\n\ntype Result<T> = result::Result<T, Box<dyn error::Error + Send + Sync>>;\n\nfn main() {\n    let mut args: Args = Docopt::new(USAGE)\n        .and_then(|d| d.deserialize())\n        .unwrap_or_else(|e| e.exit());\n    if args.flag_dfa_reverse {\n        args.flag_dfa = true;\n    }\n    match run(&args) {\n        Ok(_) => process::exit(0),\n        Err(err) => {\n            let _ = writeln!(&mut io::stderr(), \"{}\", err);\n            process::exit(1)\n        }\n    }\n}\n\nfn run(args: &Args) -> Result<()> {\n    if args.cmd_ast {\n        cmd_ast(args)\n    } else if args.cmd_hir {\n        cmd_hir(args)\n    } else if args.cmd_prefixes {\n        cmd_literals(args)\n    } else if args.cmd_suffixes {\n        cmd_literals(args)\n    } else if args.cmd_anchors {\n        cmd_anchors(args)\n    } else if args.cmd_captures {\n        cmd_captures(args)\n    } else if args.cmd_compile {\n        cmd_compile(args)\n    } else if args.cmd_utf8_ranges {\n        cmd_utf8_ranges(args)\n    } else if args.cmd_utf8_ranges_rev {\n        cmd_utf8_ranges_rev(args)\n    } else {\n        unreachable!()\n    }\n}\n\nfn cmd_ast(args: &Args) -> Result<()> {\n    use syntax::ast::parse::Parser;\n\n    let mut parser = Parser::new();\n    let ast = parser.parse(&args.arg_pattern)?;\n    println!(\"{:#?}\", ast);\n    Ok(())\n}\n\nfn cmd_hir(args: &Args) -> Result<()> {\n    use syntax::ParserBuilder;\n\n    let mut parser = ParserBuilder::new().allow_invalid_utf8(false).build();\n    let hir = parser.parse(&args.arg_pattern)?;\n    println!(\"{:#?}\", hir);\n    Ok(())\n}\n\nfn cmd_literals(args: &Args) -> Result<()> {\n    let exprs = args.parse_many()?;\n    let mut lits = if args.cmd_prefixes {\n        args.literals(&exprs, |lits, e| lits.union_prefixes(e))\n    } else {\n        args.literals(&exprs, |lits, e| lits.union_suffixes(e))\n    };\n    if !args.flag_all_literals {\n        if args.cmd_prefixes {\n            lits = lits.unambiguous_prefixes();\n        } else {\n            lits = lits.unambiguous_suffixes();\n        }\n    }\n    if args.flag_searcher {\n        if args.cmd_prefixes {\n            println!(\"{:?}\", LiteralSearcher::prefixes(lits))\n        } else {\n            println!(\"{:?}\", LiteralSearcher::suffixes(lits))\n        }\n    } else if args.flag_lcp {\n        println!(\"{}\", escape_unicode(lits.longest_common_prefix()));\n    } else if args.flag_lcs {\n        println!(\"{}\", escape_unicode(lits.longest_common_suffix()));\n    } else {\n        for lit in lits.literals() {\n            if args.flag_literal_bytes {\n                if lit.is_cut() {\n                    println!(\"Cut({})\", escape_bytes(lit));\n                } else {\n                    println!(\"Complete({})\", escape_bytes(lit));\n                }\n            } else {\n                println!(\"{:?}\", lit);\n            }\n        }\n    }\n    Ok(())\n}\n\nfn cmd_anchors(args: &Args) -> Result<()> {\n    let expr = args.parse_one()?;\n    if expr.is_anchored_start() {\n        println!(\"start\");\n    }\n    if expr.is_anchored_end() {\n        println!(\"end\");\n    }\n    Ok(())\n}\n\nfn cmd_captures(args: &Args) -> Result<()> {\n    let expr = args.parse_one()?;\n    let prog = args.compiler().only_utf8(false).compile(&[expr])?;\n    for (i, name) in prog.captures.iter().enumerate() {\n        match *name {\n            None => println!(\"{}\", i),\n            Some(ref name) => println!(\"{}:{}\", i, name),\n        }\n    }\n    Ok(())\n}\n\nfn cmd_compile(args: &Args) -> Result<()> {\n    let exprs = args.parse_many()?;\n    let compiler = args\n        .compiler()\n        .bytes(args.flag_bytes)\n        .only_utf8(!args.flag_bytes)\n        .dfa(args.flag_dfa)\n        .reverse(args.flag_dfa_reverse);\n    let prog = compiler.compile(&exprs)?;\n    if !args.flag_quiet {\n        print!(\"{:?}\", prog);\n    } else {\n        println!(\"instruction count: {}\", prog.insts.len());\n    }\n    Ok(())\n}\n\nfn cmd_utf8_ranges(args: &Args) -> Result<()> {\n    use syntax::hir::{self, HirKind};\n    use syntax::utf8::Utf8Sequences;\n    use syntax::ParserBuilder;\n\n    let hir = ParserBuilder::new()\n        .build()\n        .parse(&format!(\"[{}]\", args.arg_class))?;\n    let cls = match hir.into_kind() {\n        HirKind::Class(hir::Class::Unicode(cls)) => cls,\n        _ => {\n            return Err(\n                format!(\"unexpected HIR, expected Unicode class\").into()\n            )\n        }\n    };\n    let mut char_count = 0;\n    for (i, range) in cls.iter().enumerate() {\n        if i > 0 {\n            println!(\"----------------------------\");\n        }\n        char_count += (range.end() as u32) - (range.start() as u32) + 1;\n        for seq in Utf8Sequences::new(range.start(), range.end()) {\n            for utf8_range in seq.into_iter() {\n                print!(\"[{:02X}-{:02X}]\", utf8_range.start, utf8_range.end);\n            }\n            println!();\n        }\n    }\n    println!(\"codepoint count: {}\", char_count);\n    Ok(())\n}\n\nfn cmd_utf8_ranges_rev(args: &Args) -> Result<()> {\n    use syntax::hir::{self, HirKind};\n    use syntax::utf8::Utf8Sequences;\n    use syntax::ParserBuilder;\n\n    let hir = ParserBuilder::new()\n        .build()\n        .parse(&format!(\"[{}]\", args.arg_class))?;\n    let cls = match hir.into_kind() {\n        HirKind::Class(hir::Class::Unicode(cls)) => cls,\n        _ => {\n            return Err(\n                format!(\"unexpected HIR, expected Unicode class\").into()\n            )\n        }\n    };\n    let mut char_count = 0;\n    let mut seqs = vec![];\n    for (_, range) in cls.iter().enumerate() {\n        char_count += (range.end() as u32) - (range.start() as u32) + 1;\n        for seq in Utf8Sequences::new(range.start(), range.end()) {\n            let mut seq = seq.as_slice().to_vec();\n            seq.reverse();\n            seqs.push(seq);\n        }\n    }\n    seqs.sort();\n    for seq in seqs {\n        for utf8_range in seq.into_iter() {\n            print!(\"[{:02X}-{:02X}]\", utf8_range.start, utf8_range.end);\n        }\n        println!();\n    }\n    println!(\"codepoint count: {}\", char_count);\n    Ok(())\n}\n\nimpl Args {\n    fn parse_one(&self) -> Result<Hir> {\n        parse(&self.arg_pattern)\n    }\n\n    fn parse_many(&self) -> Result<Vec<Hir>> {\n        self.arg_patterns.iter().map(|s| parse(s)).collect()\n    }\n\n    fn literals<F: Fn(&mut Literals, &Hir) -> bool>(\n        &self,\n        exprs: &[Hir],\n        get_literals: F,\n    ) -> Literals {\n        let mut lits = Some(self.empty_literals());\n        for e in exprs {\n            lits = lits.and_then(|mut lits| {\n                if !get_literals(&mut lits, e) {\n                    None\n                } else {\n                    Some(lits)\n                }\n            });\n        }\n        lits.unwrap_or(self.empty_literals())\n    }\n\n    fn empty_literals(&self) -> Literals {\n        let mut lits = Literals::empty();\n        lits.set_limit_size(self.flag_literal_limit);\n        lits.set_limit_class(self.flag_class_limit);\n        lits\n    }\n\n    fn compiler(&self) -> Compiler {\n        Compiler::new().size_limit(self.flag_size_limit)\n    }\n}\n\nfn parse(re: &str) -> Result<Hir> {\n    use syntax::ParserBuilder;\n    ParserBuilder::new()\n        .allow_invalid_utf8(true)\n        .build()\n        .parse(re)\n        .map_err(From::from)\n}\n\nfn escape_unicode(bytes: &[u8]) -> String {\n    let show = match ::std::str::from_utf8(bytes) {\n        Ok(v) => v.to_string(),\n        Err(_) => escape_bytes(bytes),\n    };\n    let mut space_escaped = String::new();\n    for c in show.chars() {\n        if c.is_whitespace() {\n            let escaped = if c as u32 <= 0x7F {\n                escape_byte(c as u8)\n            } else {\n                if c as u32 <= 0xFFFF {\n                    format!(r\"\\u{{{:04x}}}\", c as u32)\n                } else {\n                    format!(r\"\\U{{{:08x}}}\", c as u32)\n                }\n            };\n            space_escaped.push_str(&escaped);\n        } else {\n            space_escaped.push(c);\n        }\n    }\n    space_escaped\n}\n\nfn escape_bytes(bytes: &[u8]) -> String {\n    let mut s = String::new();\n    for &b in bytes {\n        s.push_str(&escape_byte(b));\n    }\n    s\n}\n\nfn escape_byte(byte: u8) -> String {\n    use std::ascii::escape_default;\n\n    let escaped: Vec<u8> = escape_default(byte).collect();\n    String::from_utf8_lossy(&escaped).into_owned()\n}\n","traces":[{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":19},{"path":["/","usr","src","regex","regex-syntax","src","ast","mod.rs"],"content":"/*!\nDefines an abstract syntax for regular expressions.\n*/\n\nuse std::cmp::Ordering;\nuse std::error;\nuse std::fmt;\n\npub use ast::visitor::{visit, Visitor};\n\npub mod parse;\npub mod print;\nmod visitor;\n\n/// An error that occurred while parsing a regular expression into an abstract\n/// syntax tree.\n///\n/// Note that note all ASTs represents a valid regular expression. For example,\n/// an AST is constructed without error for `\\p{Quux}`, but `Quux` is not a\n/// valid Unicode property name. That particular error is reported when\n/// translating an AST to the high-level intermediate representation (`HIR`).\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Error {\n    /// The kind of error.\n    kind: ErrorKind,\n    /// The original pattern that the parser generated the error from. Every\n    /// span in an error is a valid range into this string.\n    pattern: String,\n    /// The span of this error.\n    span: Span,\n}\n\nimpl Error {\n    /// Return the type of this error.\n    pub fn kind(&self) -> &ErrorKind {\n        &self.kind\n    }\n\n    /// The original pattern string in which this error occurred.\n    ///\n    /// Every span reported by this error is reported in terms of this string.\n    pub fn pattern(&self) -> &str {\n        &self.pattern\n    }\n\n    /// Return the span at which this error occurred.\n    pub fn span(&self) -> &Span {\n        &self.span\n    }\n\n    /// Return an auxiliary span. This span exists only for some errors that\n    /// benefit from being able to point to two locations in the original\n    /// regular expression. For example, \"duplicate\" errors will have the\n    /// main error position set to the duplicate occurrence while its\n    /// auxiliary span will be set to the initial occurrence.\n    pub fn auxiliary_span(&self) -> Option<&Span> {\n        use self::ErrorKind::*;\n        match self.kind {\n            FlagDuplicate { ref original } => Some(original),\n            FlagRepeatedNegation { ref original, .. } => Some(original),\n            GroupNameDuplicate { ref original, .. } => Some(original),\n            _ => None,\n        }\n    }\n}\n\n/// The type of an error that occurred while building an AST.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum ErrorKind {\n    /// The capturing group limit was exceeded.\n    ///\n    /// Note that this represents a limit on the total number of capturing\n    /// groups in a regex and not necessarily the number of nested capturing\n    /// groups. That is, the nest limit can be low and it is still possible for\n    /// this error to occur.\n    CaptureLimitExceeded,\n    /// An invalid escape sequence was found in a character class set.\n    ClassEscapeInvalid,\n    /// An invalid character class range was found. An invalid range is any\n    /// range where the start is greater than the end.\n    ClassRangeInvalid,\n    /// An invalid range boundary was found in a character class. Range\n    /// boundaries must be a single literal codepoint, but this error indicates\n    /// that something else was found, such as a nested class.\n    ClassRangeLiteral,\n    /// An opening `[` was found with no corresponding closing `]`.\n    ClassUnclosed,\n    /// Note that this error variant is no longer used. Namely, a decimal\n    /// number can only appear as a repetition quantifier. When the number\n    /// in a repetition quantifier is empty, then it gets its own specialized\n    /// error, `RepetitionCountDecimalEmpty`.\n    DecimalEmpty,\n    /// An invalid decimal number was given where one was expected.\n    DecimalInvalid,\n    /// A bracketed hex literal was empty.\n    EscapeHexEmpty,\n    /// A bracketed hex literal did not correspond to a Unicode scalar value.\n    EscapeHexInvalid,\n    /// An invalid hexadecimal digit was found.\n    EscapeHexInvalidDigit,\n    /// EOF was found before an escape sequence was completed.\n    EscapeUnexpectedEof,\n    /// An unrecognized escape sequence.\n    EscapeUnrecognized,\n    /// A dangling negation was used when setting flags, e.g., `i-`.\n    FlagDanglingNegation,\n    /// A flag was used twice, e.g., `i-i`.\n    FlagDuplicate {\n        /// The position of the original flag. The error position\n        /// points to the duplicate flag.\n        original: Span,\n    },\n    /// The negation operator was used twice, e.g., `-i-s`.\n    FlagRepeatedNegation {\n        /// The position of the original negation operator. The error position\n        /// points to the duplicate negation operator.\n        original: Span,\n    },\n    /// Expected a flag but got EOF, e.g., `(?`.\n    FlagUnexpectedEof,\n    /// Unrecognized flag, e.g., `a`.\n    FlagUnrecognized,\n    /// A duplicate capture name was found.\n    GroupNameDuplicate {\n        /// The position of the initial occurrence of the capture name. The\n        /// error position itself points to the duplicate occurrence.\n        original: Span,\n    },\n    /// A capture group name is empty, e.g., `(?P<>abc)`.\n    GroupNameEmpty,\n    /// An invalid character was seen for a capture group name. This includes\n    /// errors where the first character is a digit (even though subsequent\n    /// characters are allowed to be digits).\n    GroupNameInvalid,\n    /// A closing `>` could not be found for a capture group name.\n    GroupNameUnexpectedEof,\n    /// An unclosed group, e.g., `(ab`.\n    ///\n    /// The span of this error corresponds to the unclosed parenthesis.\n    GroupUnclosed,\n    /// An unopened group, e.g., `ab)`.\n    GroupUnopened,\n    /// The nest limit was exceeded. The limit stored here is the limit\n    /// configured in the parser.\n    NestLimitExceeded(u32),\n    /// The range provided in a counted repetition operator is invalid. The\n    /// range is invalid if the start is greater than the end.\n    RepetitionCountInvalid,\n    /// An opening `{` was not followed by a valid decimal value.\n    /// For example, `x{}` or `x{]}` would fail.\n    RepetitionCountDecimalEmpty,\n    /// An opening `{` was found with no corresponding closing `}`.\n    RepetitionCountUnclosed,\n    /// A repetition operator was applied to a missing sub-expression. This\n    /// occurs, for example, in the regex consisting of just a `*` or even\n    /// `(?i)*`. It is, however, possible to create a repetition operating on\n    /// an empty sub-expression. For example, `()*` is still considered valid.\n    RepetitionMissing,\n    /// The Unicode class is not valid. This typically occurs when a `\\p` is\n    /// followed by something other than a `{`.\n    UnicodeClassInvalid,\n    /// When octal support is disabled, this error is produced when an octal\n    /// escape is used. The octal escape is assumed to be an invocation of\n    /// a backreference, which is the common case.\n    UnsupportedBackreference,\n    /// When syntax similar to PCRE's look-around is used, this error is\n    /// returned. Some example syntaxes that are rejected include, but are\n    /// not necessarily limited to, `(?=re)`, `(?!re)`, `(?<=re)` and\n    /// `(?<!re)`. Note that all of these syntaxes are otherwise invalid; this\n    /// error is used to improve the user experience.\n    UnsupportedLookAround,\n    /// Hints that destructuring should not be exhaustive.\n    ///\n    /// This enum may grow additional variants, so this makes sure clients\n    /// don't count on exhaustive matching. (Otherwise, adding a new variant\n    /// could break existing code.)\n    #[doc(hidden)]\n    __Nonexhaustive,\n}\n\nimpl error::Error for Error {\n    // TODO: Remove this method entirely on the next breaking semver release.\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        use self::ErrorKind::*;\n        match self.kind {\n            CaptureLimitExceeded => \"capture group limit exceeded\",\n            ClassEscapeInvalid => \"invalid escape sequence in character class\",\n            ClassRangeInvalid => \"invalid character class range\",\n            ClassRangeLiteral => \"invalid range boundary, must be a literal\",\n            ClassUnclosed => \"unclosed character class\",\n            DecimalEmpty => \"empty decimal literal\",\n            DecimalInvalid => \"invalid decimal literal\",\n            EscapeHexEmpty => \"empty hexadecimal literal\",\n            EscapeHexInvalid => \"invalid hexadecimal literal\",\n            EscapeHexInvalidDigit => \"invalid hexadecimal digit\",\n            EscapeUnexpectedEof => \"unexpected eof (escape sequence)\",\n            EscapeUnrecognized => \"unrecognized escape sequence\",\n            FlagDanglingNegation => \"dangling flag negation operator\",\n            FlagDuplicate { .. } => \"duplicate flag\",\n            FlagRepeatedNegation { .. } => \"repeated negation\",\n            FlagUnexpectedEof => \"unexpected eof (flag)\",\n            FlagUnrecognized => \"unrecognized flag\",\n            GroupNameDuplicate { .. } => \"duplicate capture group name\",\n            GroupNameEmpty => \"empty capture group name\",\n            GroupNameInvalid => \"invalid capture group name\",\n            GroupNameUnexpectedEof => \"unclosed capture group name\",\n            GroupUnclosed => \"unclosed group\",\n            GroupUnopened => \"unopened group\",\n            NestLimitExceeded(_) => \"nest limit exceeded\",\n            RepetitionCountInvalid => \"invalid repetition count range\",\n            RepetitionCountUnclosed => \"unclosed counted repetition\",\n            RepetitionMissing => \"repetition operator missing expression\",\n            UnicodeClassInvalid => \"invalid Unicode character class\",\n            UnsupportedBackreference => \"backreferences are not supported\",\n            UnsupportedLookAround => \"look-around is not supported\",\n            _ => unreachable!(),\n        }\n    }\n}\n\nimpl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        ::error::Formatter::from(self).fmt(f)\n    }\n}\n\nimpl fmt::Display for ErrorKind {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        use self::ErrorKind::*;\n        match *self {\n            CaptureLimitExceeded => write!(\n                f,\n                \"exceeded the maximum number of \\\n                 capturing groups ({})\",\n                ::std::u32::MAX\n            ),\n            ClassEscapeInvalid => {\n                write!(f, \"invalid escape sequence found in character class\")\n            }\n            ClassRangeInvalid => write!(\n                f,\n                \"invalid character class range, \\\n                 the start must be <= the end\"\n            ),\n            ClassRangeLiteral => {\n                write!(f, \"invalid range boundary, must be a literal\")\n            }\n            ClassUnclosed => write!(f, \"unclosed character class\"),\n            DecimalEmpty => write!(f, \"decimal literal empty\"),\n            DecimalInvalid => write!(f, \"decimal literal invalid\"),\n            EscapeHexEmpty => write!(f, \"hexadecimal literal empty\"),\n            EscapeHexInvalid => {\n                write!(f, \"hexadecimal literal is not a Unicode scalar value\")\n            }\n            EscapeHexInvalidDigit => write!(f, \"invalid hexadecimal digit\"),\n            EscapeUnexpectedEof => write!(\n                f,\n                \"incomplete escape sequence, \\\n                 reached end of pattern prematurely\"\n            ),\n            EscapeUnrecognized => write!(f, \"unrecognized escape sequence\"),\n            FlagDanglingNegation => {\n                write!(f, \"dangling flag negation operator\")\n            }\n            FlagDuplicate { .. } => write!(f, \"duplicate flag\"),\n            FlagRepeatedNegation { .. } => {\n                write!(f, \"flag negation operator repeated\")\n            }\n            FlagUnexpectedEof => {\n                write!(f, \"expected flag but got end of regex\")\n            }\n            FlagUnrecognized => write!(f, \"unrecognized flag\"),\n            GroupNameDuplicate { .. } => {\n                write!(f, \"duplicate capture group name\")\n            }\n            GroupNameEmpty => write!(f, \"empty capture group name\"),\n            GroupNameInvalid => write!(f, \"invalid capture group character\"),\n            GroupNameUnexpectedEof => write!(f, \"unclosed capture group name\"),\n            GroupUnclosed => write!(f, \"unclosed group\"),\n            GroupUnopened => write!(f, \"unopened group\"),\n            NestLimitExceeded(limit) => write!(\n                f,\n                \"exceed the maximum number of \\\n                 nested parentheses/brackets ({})\",\n                limit\n            ),\n            RepetitionCountInvalid => write!(\n                f,\n                \"invalid repetition count range, \\\n                 the start must be <= the end\"\n            ),\n            RepetitionCountDecimalEmpty => {\n                write!(f, \"repetition quantifier expects a valid decimal\")\n            }\n            RepetitionCountUnclosed => {\n                write!(f, \"unclosed counted repetition\")\n            }\n            RepetitionMissing => {\n                write!(f, \"repetition operator missing expression\")\n            }\n            UnicodeClassInvalid => {\n                write!(f, \"invalid Unicode character class\")\n            }\n            UnsupportedBackreference => {\n                write!(f, \"backreferences are not supported\")\n            }\n            UnsupportedLookAround => write!(\n                f,\n                \"look-around, including look-ahead and look-behind, \\\n                 is not supported\"\n            ),\n            _ => unreachable!(),\n        }\n    }\n}\n\n/// Span represents the position information of a single AST item.\n///\n/// All span positions are absolute byte offsets that can be used on the\n/// original regular expression that was parsed.\n#[derive(Clone, Copy, Eq, PartialEq)]\npub struct Span {\n    /// The start byte offset.\n    pub start: Position,\n    /// The end byte offset.\n    pub end: Position,\n}\n\nimpl fmt::Debug for Span {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"Span({:?}, {:?})\", self.start, self.end)\n    }\n}\n\nimpl Ord for Span {\n    fn cmp(&self, other: &Span) -> Ordering {\n        (&self.start, &self.end).cmp(&(&other.start, &other.end))\n    }\n}\n\nimpl PartialOrd for Span {\n    fn partial_cmp(&self, other: &Span) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\n/// A single position in a regular expression.\n///\n/// A position encodes one half of a span, and include the byte offset, line\n/// number and column number.\n#[derive(Clone, Copy, Eq, PartialEq)]\npub struct Position {\n    /// The absolute offset of this position, starting at `0` from the\n    /// beginning of the regular expression pattern string.\n    pub offset: usize,\n    /// The line number, starting at `1`.\n    pub line: usize,\n    /// The approximate column number, starting at `1`.\n    pub column: usize,\n}\n\nimpl fmt::Debug for Position {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            f,\n            \"Position(o: {:?}, l: {:?}, c: {:?})\",\n            self.offset, self.line, self.column\n        )\n    }\n}\n\nimpl Ord for Position {\n    fn cmp(&self, other: &Position) -> Ordering {\n        self.offset.cmp(&other.offset)\n    }\n}\n\nimpl PartialOrd for Position {\n    fn partial_cmp(&self, other: &Position) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Span {\n    /// Create a new span with the given positions.\n    pub fn new(start: Position, end: Position) -> Span {\n        Span { start: start, end: end }\n    }\n\n    /// Create a new span using the given position as the start and end.\n    pub fn splat(pos: Position) -> Span {\n        Span::new(pos, pos)\n    }\n\n    /// Create a new span by replacing the starting the position with the one\n    /// given.\n    pub fn with_start(self, pos: Position) -> Span {\n        Span { start: pos, ..self }\n    }\n\n    /// Create a new span by replacing the ending the position with the one\n    /// given.\n    pub fn with_end(self, pos: Position) -> Span {\n        Span { end: pos, ..self }\n    }\n\n    /// Returns true if and only if this span occurs on a single line.\n    pub fn is_one_line(&self) -> bool {\n        self.start.line == self.end.line\n    }\n\n    /// Returns true if and only if this span is empty. That is, it points to\n    /// a single position in the concrete syntax of a regular expression.\n    pub fn is_empty(&self) -> bool {\n        self.start.offset == self.end.offset\n    }\n}\n\nimpl Position {\n    /// Create a new position with the given information.\n    ///\n    /// `offset` is the absolute offset of the position, starting at `0` from\n    /// the beginning of the regular expression pattern string.\n    ///\n    /// `line` is the line number, starting at `1`.\n    ///\n    /// `column` is the approximate column number, starting at `1`.\n    pub fn new(offset: usize, line: usize, column: usize) -> Position {\n        Position { offset: offset, line: line, column: column }\n    }\n}\n\n/// An abstract syntax tree for a singular expression along with comments\n/// found.\n///\n/// Comments are not stored in the tree itself to avoid complexity. Each\n/// comment contains a span of precisely where it occurred in the original\n/// regular expression.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct WithComments {\n    /// The actual ast.\n    pub ast: Ast,\n    /// All comments found in the original regular expression.\n    pub comments: Vec<Comment>,\n}\n\n/// A comment from a regular expression with an associated span.\n///\n/// A regular expression can only contain comments when the `x` flag is\n/// enabled.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Comment {\n    /// The span of this comment, including the beginning `#` and ending `\\n`.\n    pub span: Span,\n    /// The comment text, starting with the first character following the `#`\n    /// and ending with the last character preceding the `\\n`.\n    pub comment: String,\n}\n\n/// An abstract syntax tree for a single regular expression.\n///\n/// An `Ast`'s `fmt::Display` implementation uses constant stack space and heap\n/// space proportional to the size of the `Ast`.\n///\n/// This type defines its own destructor that uses constant stack space and\n/// heap space proportional to the size of the `Ast`.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum Ast {\n    /// An empty regex that matches everything.\n    Empty(Span),\n    /// A set of flags, e.g., `(?is)`.\n    Flags(SetFlags),\n    /// A single character literal, which includes escape sequences.\n    Literal(Literal),\n    /// The \"any character\" class.\n    Dot(Span),\n    /// A single zero-width assertion.\n    Assertion(Assertion),\n    /// A single character class. This includes all forms of character classes\n    /// except for `.`. e.g., `\\d`, `\\pN`, `[a-z]` and `[[:alpha:]]`.\n    Class(Class),\n    /// A repetition operator applied to an arbitrary regular expression.\n    Repetition(Repetition),\n    /// A grouped regular expression.\n    Group(Group),\n    /// An alternation of regular expressions.\n    Alternation(Alternation),\n    /// A concatenation of regular expressions.\n    Concat(Concat),\n}\n\nimpl Ast {\n    /// Return the span of this abstract syntax tree.\n    pub fn span(&self) -> &Span {\n        match *self {\n            Ast::Empty(ref span) => span,\n            Ast::Flags(ref x) => &x.span,\n            Ast::Literal(ref x) => &x.span,\n            Ast::Dot(ref span) => span,\n            Ast::Assertion(ref x) => &x.span,\n            Ast::Class(ref x) => x.span(),\n            Ast::Repetition(ref x) => &x.span,\n            Ast::Group(ref x) => &x.span,\n            Ast::Alternation(ref x) => &x.span,\n            Ast::Concat(ref x) => &x.span,\n        }\n    }\n\n    /// Return true if and only if this Ast is empty.\n    pub fn is_empty(&self) -> bool {\n        match *self {\n            Ast::Empty(_) => true,\n            _ => false,\n        }\n    }\n\n    /// Returns true if and only if this AST has any (including possibly empty)\n    /// subexpressions.\n    fn has_subexprs(&self) -> bool {\n        match *self {\n            Ast::Empty(_)\n            | Ast::Flags(_)\n            | Ast::Literal(_)\n            | Ast::Dot(_)\n            | Ast::Assertion(_) => false,\n            Ast::Class(_)\n            | Ast::Repetition(_)\n            | Ast::Group(_)\n            | Ast::Alternation(_)\n            | Ast::Concat(_) => true,\n        }\n    }\n}\n\n/// Print a display representation of this Ast.\n///\n/// This does not preserve any of the original whitespace formatting that may\n/// have originally been present in the concrete syntax from which this Ast\n/// was generated.\n///\n/// This implementation uses constant stack space and heap space proportional\n/// to the size of the `Ast`.\nimpl fmt::Display for Ast {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        use ast::print::Printer;\n        Printer::new().print(self, f)\n    }\n}\n\n/// An alternation of regular expressions.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Alternation {\n    /// The span of this alternation.\n    pub span: Span,\n    /// The alternate regular expressions.\n    pub asts: Vec<Ast>,\n}\n\nimpl Alternation {\n    /// Return this alternation as an AST.\n    ///\n    /// If this alternation contains zero ASTs, then Ast::Empty is\n    /// returned. If this alternation contains exactly 1 AST, then the\n    /// corresponding AST is returned. Otherwise, Ast::Alternation is returned.\n    pub fn into_ast(mut self) -> Ast {\n        match self.asts.len() {\n            0 => Ast::Empty(self.span),\n            1 => self.asts.pop().unwrap(),\n            _ => Ast::Alternation(self),\n        }\n    }\n}\n\n/// A concatenation of regular expressions.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Concat {\n    /// The span of this concatenation.\n    pub span: Span,\n    /// The concatenation regular expressions.\n    pub asts: Vec<Ast>,\n}\n\nimpl Concat {\n    /// Return this concatenation as an AST.\n    ///\n    /// If this concatenation contains zero ASTs, then Ast::Empty is\n    /// returned. If this concatenation contains exactly 1 AST, then the\n    /// corresponding AST is returned. Otherwise, Ast::Concat is returned.\n    pub fn into_ast(mut self) -> Ast {\n        match self.asts.len() {\n            0 => Ast::Empty(self.span),\n            1 => self.asts.pop().unwrap(),\n            _ => Ast::Concat(self),\n        }\n    }\n}\n\n/// A single literal expression.\n///\n/// A literal corresponds to a single Unicode scalar value. Literals may be\n/// represented in their literal form, e.g., `a` or in their escaped form,\n/// e.g., `\\x61`.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Literal {\n    /// The span of this literal.\n    pub span: Span,\n    /// The kind of this literal.\n    pub kind: LiteralKind,\n    /// The Unicode scalar value corresponding to this literal.\n    pub c: char,\n}\n\nimpl Literal {\n    /// If this literal was written as a `\\x` hex escape, then this returns\n    /// the corresponding byte value. Otherwise, this returns `None`.\n    pub fn byte(&self) -> Option<u8> {\n        let short_hex = LiteralKind::HexFixed(HexLiteralKind::X);\n        if self.c as u32 <= 255 && self.kind == short_hex {\n            Some(self.c as u8)\n        } else {\n            None\n        }\n    }\n}\n\n/// The kind of a single literal expression.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum LiteralKind {\n    /// The literal is written verbatim, e.g., `a` or `☃`.\n    Verbatim,\n    /// The literal is written as an escape because it is punctuation, e.g.,\n    /// `\\*` or `\\[`.\n    Punctuation,\n    /// The literal is written as an octal escape, e.g., `\\141`.\n    Octal,\n    /// The literal is written as a hex code with a fixed number of digits\n    /// depending on the type of the escape, e.g., `\\x61` or or `\\u0061` or\n    /// `\\U00000061`.\n    HexFixed(HexLiteralKind),\n    /// The literal is written as a hex code with a bracketed number of\n    /// digits. The only restriction is that the bracketed hex code must refer\n    /// to a valid Unicode scalar value.\n    HexBrace(HexLiteralKind),\n    /// The literal is written as a specially recognized escape, e.g., `\\f`\n    /// or `\\n`.\n    Special(SpecialLiteralKind),\n}\n\n/// The type of a special literal.\n///\n/// A special literal is a special escape sequence recognized by the regex\n/// parser, e.g., `\\f` or `\\n`.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum SpecialLiteralKind {\n    /// Bell, spelled `\\a` (`\\x07`).\n    Bell,\n    /// Form feed, spelled `\\f` (`\\x0C`).\n    FormFeed,\n    /// Tab, spelled `\\t` (`\\x09`).\n    Tab,\n    /// Line feed, spelled `\\n` (`\\x0A`).\n    LineFeed,\n    /// Carriage return, spelled `\\r` (`\\x0D`).\n    CarriageReturn,\n    /// Vertical tab, spelled `\\v` (`\\x0B`).\n    VerticalTab,\n    /// Space, spelled `\\ ` (`\\x20`). Note that this can only appear when\n    /// parsing in verbose mode.\n    Space,\n}\n\n/// The type of a Unicode hex literal.\n///\n/// Note that all variants behave the same when used with brackets. They only\n/// differ when used without brackets in the number of hex digits that must\n/// follow.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum HexLiteralKind {\n    /// A `\\x` prefix. When used without brackets, this form is limited to\n    /// two digits.\n    X,\n    /// A `\\u` prefix. When used without brackets, this form is limited to\n    /// four digits.\n    UnicodeShort,\n    /// A `\\U` prefix. When used without brackets, this form is limited to\n    /// eight digits.\n    UnicodeLong,\n}\n\nimpl HexLiteralKind {\n    /// The number of digits that must be used with this literal form when\n    /// used without brackets. When used with brackets, there is no\n    /// restriction on the number of digits.\n    pub fn digits(&self) -> u32 {\n        match *self {\n            HexLiteralKind::X => 2,\n            HexLiteralKind::UnicodeShort => 4,\n            HexLiteralKind::UnicodeLong => 8,\n        }\n    }\n}\n\n/// A single character class expression.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum Class {\n    /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n    Unicode(ClassUnicode),\n    /// A perl character class, e.g., `\\d` or `\\W`.\n    Perl(ClassPerl),\n    /// A bracketed character class set, which may contain zero or more\n    /// character ranges and/or zero or more nested classes. e.g.,\n    /// `[a-zA-Z\\pL]`.\n    Bracketed(ClassBracketed),\n}\n\nimpl Class {\n    /// Return the span of this character class.\n    pub fn span(&self) -> &Span {\n        match *self {\n            Class::Perl(ref x) => &x.span,\n            Class::Unicode(ref x) => &x.span,\n            Class::Bracketed(ref x) => &x.span,\n        }\n    }\n}\n\n/// A Perl character class.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassPerl {\n    /// The span of this class.\n    pub span: Span,\n    /// The kind of Perl class.\n    pub kind: ClassPerlKind,\n    /// Whether the class is negated or not. e.g., `\\d` is not negated but\n    /// `\\D` is.\n    pub negated: bool,\n}\n\n/// The available Perl character classes.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum ClassPerlKind {\n    /// Decimal numbers.\n    Digit,\n    /// Whitespace.\n    Space,\n    /// Word characters.\n    Word,\n}\n\n/// An ASCII character class.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassAscii {\n    /// The span of this class.\n    pub span: Span,\n    /// The kind of ASCII class.\n    pub kind: ClassAsciiKind,\n    /// Whether the class is negated or not. e.g., `[[:alpha:]]` is not negated\n    /// but `[[:^alpha:]]` is.\n    pub negated: bool,\n}\n\n/// The available ASCII character classes.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum ClassAsciiKind {\n    /// `[0-9A-Za-z]`\n    Alnum,\n    /// `[A-Za-z]`\n    Alpha,\n    /// `[\\x00-\\x7F]`\n    Ascii,\n    /// `[ \\t]`\n    Blank,\n    /// `[\\x00-\\x1F\\x7F]`\n    Cntrl,\n    /// `[0-9]`\n    Digit,\n    /// `[!-~]`\n    Graph,\n    /// `[a-z]`\n    Lower,\n    /// `[ -~]`\n    Print,\n    /// `[!-/:-@\\[-`{-~]`\n    Punct,\n    /// `[\\t\\n\\v\\f\\r ]`\n    Space,\n    /// `[A-Z]`\n    Upper,\n    /// `[0-9A-Za-z_]`\n    Word,\n    /// `[0-9A-Fa-f]`\n    Xdigit,\n}\n\nimpl ClassAsciiKind {\n    /// Return the corresponding ClassAsciiKind variant for the given name.\n    ///\n    /// The name given should correspond to the lowercase version of the\n    /// variant name. e.g., `cntrl` is the name for `ClassAsciiKind::Cntrl`.\n    ///\n    /// If no variant with the corresponding name exists, then `None` is\n    /// returned.\n    pub fn from_name(name: &str) -> Option<ClassAsciiKind> {\n        use self::ClassAsciiKind::*;\n        match name {\n            \"alnum\" => Some(Alnum),\n            \"alpha\" => Some(Alpha),\n            \"ascii\" => Some(Ascii),\n            \"blank\" => Some(Blank),\n            \"cntrl\" => Some(Cntrl),\n            \"digit\" => Some(Digit),\n            \"graph\" => Some(Graph),\n            \"lower\" => Some(Lower),\n            \"print\" => Some(Print),\n            \"punct\" => Some(Punct),\n            \"space\" => Some(Space),\n            \"upper\" => Some(Upper),\n            \"word\" => Some(Word),\n            \"xdigit\" => Some(Xdigit),\n            _ => None,\n        }\n    }\n}\n\n/// A Unicode character class.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassUnicode {\n    /// The span of this class.\n    pub span: Span,\n    /// Whether this class is negated or not.\n    ///\n    /// Note: be careful when using this attribute. This specifically refers\n    /// to whether the class is written as `\\p` or `\\P`, where the latter\n    /// is `negated = true`. However, it also possible to write something like\n    /// `\\P{scx!=Katakana}` which is actually equivalent to\n    /// `\\p{scx=Katakana}` and is therefore not actually negated even though\n    /// `negated = true` here. To test whether this class is truly negated\n    /// or not, use the `is_negated` method.\n    pub negated: bool,\n    /// The kind of Unicode class.\n    pub kind: ClassUnicodeKind,\n}\n\nimpl ClassUnicode {\n    /// Returns true if this class has been negated.\n    ///\n    /// Note that this takes the Unicode op into account, if it's present.\n    /// e.g., `is_negated` for `\\P{scx!=Katakana}` will return `false`.\n    pub fn is_negated(&self) -> bool {\n        match self.kind {\n            ClassUnicodeKind::NamedValue {\n                op: ClassUnicodeOpKind::NotEqual,\n                ..\n            } => !self.negated,\n            _ => self.negated,\n        }\n    }\n}\n\n/// The available forms of Unicode character classes.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum ClassUnicodeKind {\n    /// A one letter abbreviated class, e.g., `\\pN`.\n    OneLetter(char),\n    /// A binary property, general category or script. The string may be\n    /// empty.\n    Named(String),\n    /// A property name and an associated value.\n    NamedValue {\n        /// The type of Unicode op used to associate `name` with `value`.\n        op: ClassUnicodeOpKind,\n        /// The property name (which may be empty).\n        name: String,\n        /// The property value (which may be empty).\n        value: String,\n    },\n}\n\n/// The type of op used in a Unicode character class.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum ClassUnicodeOpKind {\n    /// A property set to a specific value, e.g., `\\p{scx=Katakana}`.\n    Equal,\n    /// A property set to a specific value using a colon, e.g.,\n    /// `\\p{scx:Katakana}`.\n    Colon,\n    /// A property that isn't a particular value, e.g., `\\p{scx!=Katakana}`.\n    NotEqual,\n}\n\nimpl ClassUnicodeOpKind {\n    /// Whether the op is an equality op or not.\n    pub fn is_equal(&self) -> bool {\n        match *self {\n            ClassUnicodeOpKind::Equal | ClassUnicodeOpKind::Colon => true,\n            _ => false,\n        }\n    }\n}\n\n/// A bracketed character class, e.g., `[a-z0-9]`.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassBracketed {\n    /// The span of this class.\n    pub span: Span,\n    /// Whether this class is negated or not. e.g., `[a]` is not negated but\n    /// `[^a]` is.\n    pub negated: bool,\n    /// The type of this set. A set is either a normal union of things, e.g.,\n    /// `[abc]` or a result of applying set operations, e.g., `[\\pL--c]`.\n    pub kind: ClassSet,\n}\n\n/// A character class set.\n///\n/// This type corresponds to the internal structure of a bracketed character\n/// class. That is, every bracketed character is one of two types: a union of\n/// items (literals, ranges, other bracketed classes) or a tree of binary set\n/// operations.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum ClassSet {\n    /// An item, which can be a single literal, range, nested character class\n    /// or a union of items.\n    Item(ClassSetItem),\n    /// A single binary operation (i.e., &&, -- or ~~).\n    BinaryOp(ClassSetBinaryOp),\n}\n\nimpl ClassSet {\n    /// Build a set from a union.\n    pub fn union(ast: ClassSetUnion) -> ClassSet {\n        ClassSet::Item(ClassSetItem::Union(ast))\n    }\n\n    /// Return the span of this character class set.\n    pub fn span(&self) -> &Span {\n        match *self {\n            ClassSet::Item(ref x) => x.span(),\n            ClassSet::BinaryOp(ref x) => &x.span,\n        }\n    }\n\n    /// Return true if and only if this class set is empty.\n    fn is_empty(&self) -> bool {\n        match *self {\n            ClassSet::Item(ClassSetItem::Empty(_)) => true,\n            _ => false,\n        }\n    }\n}\n\n/// A single component of a character class set.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum ClassSetItem {\n    /// An empty item.\n    ///\n    /// Note that a bracketed character class cannot contain a single empty\n    /// item. Empty items can appear when using one of the binary operators.\n    /// For example, `[&&]` is the intersection of two empty classes.\n    Empty(Span),\n    /// A single literal.\n    Literal(Literal),\n    /// A range between two literals.\n    Range(ClassSetRange),\n    /// An ASCII character class, e.g., `[:alnum:]` or `[:punct:]`.\n    Ascii(ClassAscii),\n    /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n    Unicode(ClassUnicode),\n    /// A perl character class, e.g., `\\d` or `\\W`.\n    Perl(ClassPerl),\n    /// A bracketed character class set, which may contain zero or more\n    /// character ranges and/or zero or more nested classes. e.g.,\n    /// `[a-zA-Z\\pL]`.\n    Bracketed(Box<ClassBracketed>),\n    /// A union of items.\n    Union(ClassSetUnion),\n}\n\nimpl ClassSetItem {\n    /// Return the span of this character class set item.\n    pub fn span(&self) -> &Span {\n        match *self {\n            ClassSetItem::Empty(ref span) => span,\n            ClassSetItem::Literal(ref x) => &x.span,\n            ClassSetItem::Range(ref x) => &x.span,\n            ClassSetItem::Ascii(ref x) => &x.span,\n            ClassSetItem::Perl(ref x) => &x.span,\n            ClassSetItem::Unicode(ref x) => &x.span,\n            ClassSetItem::Bracketed(ref x) => &x.span,\n            ClassSetItem::Union(ref x) => &x.span,\n        }\n    }\n}\n\n/// A single character class range in a set.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassSetRange {\n    /// The span of this range.\n    pub span: Span,\n    /// The start of this range.\n    pub start: Literal,\n    /// The end of this range.\n    pub end: Literal,\n}\n\nimpl ClassSetRange {\n    /// Returns true if and only if this character class range is valid.\n    ///\n    /// The only case where a range is invalid is if its start is greater than\n    /// its end.\n    pub fn is_valid(&self) -> bool {\n        self.start.c <= self.end.c\n    }\n}\n\n/// A union of items inside a character class set.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassSetUnion {\n    /// The span of the items in this operation. e.g., the `a-z0-9` in\n    /// `[^a-z0-9]`\n    pub span: Span,\n    /// The sequence of items that make up this union.\n    pub items: Vec<ClassSetItem>,\n}\n\nimpl ClassSetUnion {\n    /// Push a new item in this union.\n    ///\n    /// The ending position of this union's span is updated to the ending\n    /// position of the span of the item given. If the union is empty, then\n    /// the starting position of this union is set to the starting position\n    /// of this item.\n    ///\n    /// In other words, if you only use this method to add items to a union\n    /// and you set the spans on each item correctly, then you should never\n    /// need to adjust the span of the union directly.\n    pub fn push(&mut self, item: ClassSetItem) {\n        if self.items.is_empty() {\n            self.span.start = item.span().start;\n        }\n        self.span.end = item.span().end;\n        self.items.push(item);\n    }\n\n    /// Return this union as a character class set item.\n    ///\n    /// If this union contains zero items, then an empty union is\n    /// returned. If this concatenation contains exactly 1 item, then the\n    /// corresponding item is returned. Otherwise, ClassSetItem::Union is\n    /// returned.\n    pub fn into_item(mut self) -> ClassSetItem {\n        match self.items.len() {\n            0 => ClassSetItem::Empty(self.span),\n            1 => self.items.pop().unwrap(),\n            _ => ClassSetItem::Union(self),\n        }\n    }\n}\n\n/// A Unicode character class set operation.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassSetBinaryOp {\n    /// The span of this operation. e.g., the `a-z--[h-p]` in `[a-z--h-p]`.\n    pub span: Span,\n    /// The type of this set operation.\n    pub kind: ClassSetBinaryOpKind,\n    /// The left hand side of the operation.\n    pub lhs: Box<ClassSet>,\n    /// The right hand side of the operation.\n    pub rhs: Box<ClassSet>,\n}\n\n/// The type of a Unicode character class set operation.\n///\n/// Note that this doesn't explicitly represent union since there is no\n/// explicit union operator. Concatenation inside a character class corresponds\n/// to the union operation.\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum ClassSetBinaryOpKind {\n    /// The intersection of two sets, e.g., `\\pN&&[a-z]`.\n    Intersection,\n    /// The difference of two sets, e.g., `\\pN--[0-9]`.\n    Difference,\n    /// The symmetric difference of two sets. The symmetric difference is the\n    /// set of elements belonging to one but not both sets.\n    /// e.g., `[\\pL~~[:ascii:]]`.\n    SymmetricDifference,\n}\n\n/// A single zero-width assertion.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Assertion {\n    /// The span of this assertion.\n    pub span: Span,\n    /// The assertion kind, e.g., `\\b` or `^`.\n    pub kind: AssertionKind,\n}\n\n/// An assertion kind.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum AssertionKind {\n    /// `^`\n    StartLine,\n    /// `$`\n    EndLine,\n    /// `\\A`\n    StartText,\n    /// `\\z`\n    EndText,\n    /// `\\b`\n    WordBoundary,\n    /// `\\B`\n    NotWordBoundary,\n}\n\n/// A repetition operation applied to a regular expression.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Repetition {\n    /// The span of this operation.\n    pub span: Span,\n    /// The actual operation.\n    pub op: RepetitionOp,\n    /// Whether this operation was applied greedily or not.\n    pub greedy: bool,\n    /// The regular expression under repetition.\n    pub ast: Box<Ast>,\n}\n\n/// The repetition operator itself.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct RepetitionOp {\n    /// The span of this operator. This includes things like `+`, `*?` and\n    /// `{m,n}`.\n    pub span: Span,\n    /// The type of operation.\n    pub kind: RepetitionKind,\n}\n\n/// The kind of a repetition operator.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum RepetitionKind {\n    /// `?`\n    ZeroOrOne,\n    /// `*`\n    ZeroOrMore,\n    /// `+`\n    OneOrMore,\n    /// `{m,n}`\n    Range(RepetitionRange),\n}\n\n/// A range repetition operator.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum RepetitionRange {\n    /// `{m}`\n    Exactly(u32),\n    /// `{m,}`\n    AtLeast(u32),\n    /// `{m,n}`\n    Bounded(u32, u32),\n}\n\nimpl RepetitionRange {\n    /// Returns true if and only if this repetition range is valid.\n    ///\n    /// The only case where a repetition range is invalid is if it is bounded\n    /// and its start is greater than its end.\n    pub fn is_valid(&self) -> bool {\n        match *self {\n            RepetitionRange::Bounded(s, e) if s > e => false,\n            _ => true,\n        }\n    }\n}\n\n/// A grouped regular expression.\n///\n/// This includes both capturing and non-capturing groups. This does **not**\n/// include flag-only groups like `(?is)`, but does contain any group that\n/// contains a sub-expression, e.g., `(a)`, `(?P<name>a)`, `(?:a)` and\n/// `(?is:a)`.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Group {\n    /// The span of this group.\n    pub span: Span,\n    /// The kind of this group.\n    pub kind: GroupKind,\n    /// The regular expression in this group.\n    pub ast: Box<Ast>,\n}\n\nimpl Group {\n    /// If this group is non-capturing, then this returns the (possibly empty)\n    /// set of flags. Otherwise, `None` is returned.\n    pub fn flags(&self) -> Option<&Flags> {\n        match self.kind {\n            GroupKind::NonCapturing(ref flags) => Some(flags),\n            _ => None,\n        }\n    }\n\n    /// Returns true if and only if this group is capturing.\n    pub fn is_capturing(&self) -> bool {\n        match self.kind {\n            GroupKind::CaptureIndex(_) | GroupKind::CaptureName(_) => true,\n            GroupKind::NonCapturing(_) => false,\n        }\n    }\n\n    /// Returns the capture index of this group, if this is a capturing group.\n    ///\n    /// This returns a capture index precisely when `is_capturing` is `true`.\n    pub fn capture_index(&self) -> Option<u32> {\n        match self.kind {\n            GroupKind::CaptureIndex(i) => Some(i),\n            GroupKind::CaptureName(ref x) => Some(x.index),\n            GroupKind::NonCapturing(_) => None,\n        }\n    }\n}\n\n/// The kind of a group.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum GroupKind {\n    /// `(a)`\n    CaptureIndex(u32),\n    /// `(?P<name>a)`\n    CaptureName(CaptureName),\n    /// `(?:a)` and `(?i:a)`\n    NonCapturing(Flags),\n}\n\n/// A capture name.\n///\n/// This corresponds to the name itself between the angle brackets in, e.g.,\n/// `(?P<foo>expr)`.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct CaptureName {\n    /// The span of this capture name.\n    pub span: Span,\n    /// The capture name.\n    pub name: String,\n    /// The capture index.\n    pub index: u32,\n}\n\n/// A group of flags that is not applied to a particular regular expression.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct SetFlags {\n    /// The span of these flags, including the grouping parentheses.\n    pub span: Span,\n    /// The actual sequence of flags.\n    pub flags: Flags,\n}\n\n/// A group of flags.\n///\n/// This corresponds only to the sequence of flags themselves, e.g., `is-u`.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Flags {\n    /// The span of this group of flags.\n    pub span: Span,\n    /// A sequence of flag items. Each item is either a flag or a negation\n    /// operator.\n    pub items: Vec<FlagsItem>,\n}\n\nimpl Flags {\n    /// Add the given item to this sequence of flags.\n    ///\n    /// If the item was added successfully, then `None` is returned. If the\n    /// given item is a duplicate, then `Some(i)` is returned, where\n    /// `items[i].kind == item.kind`.\n    pub fn add_item(&mut self, item: FlagsItem) -> Option<usize> {\n        for (i, x) in self.items.iter().enumerate() {\n            if x.kind == item.kind {\n                return Some(i);\n            }\n        }\n        self.items.push(item);\n        None\n    }\n\n    /// Returns the state of the given flag in this set.\n    ///\n    /// If the given flag is in the set but is negated, then `Some(false)` is\n    /// returned.\n    ///\n    /// If the given flag is in the set and is not negated, then `Some(true)`\n    /// is returned.\n    ///\n    /// Otherwise, `None` is returned.\n    pub fn flag_state(&self, flag: Flag) -> Option<bool> {\n        let mut negated = false;\n        for x in &self.items {\n            match x.kind {\n                FlagsItemKind::Negation => {\n                    negated = true;\n                }\n                FlagsItemKind::Flag(ref xflag) if xflag == &flag => {\n                    return Some(!negated);\n                }\n                _ => {}\n            }\n        }\n        None\n    }\n}\n\n/// A single item in a group of flags.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct FlagsItem {\n    /// The span of this item.\n    pub span: Span,\n    /// The kind of this item.\n    pub kind: FlagsItemKind,\n}\n\n/// The kind of an item in a group of flags.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum FlagsItemKind {\n    /// A negation operator applied to all subsequent flags in the enclosing\n    /// group.\n    Negation,\n    /// A single flag in a group.\n    Flag(Flag),\n}\n\nimpl FlagsItemKind {\n    /// Returns true if and only if this item is a negation operator.\n    pub fn is_negation(&self) -> bool {\n        match *self {\n            FlagsItemKind::Negation => true,\n            _ => false,\n        }\n    }\n}\n\n/// A single flag.\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum Flag {\n    /// `i`\n    CaseInsensitive,\n    /// `m`\n    MultiLine,\n    /// `s`\n    DotMatchesNewLine,\n    /// `U`\n    SwapGreed,\n    /// `u`\n    Unicode,\n    /// `x`\n    IgnoreWhitespace,\n}\n\n/// A custom `Drop` impl is used for `Ast` such that it uses constant stack\n/// space but heap space proportional to the depth of the `Ast`.\nimpl Drop for Ast {\n    fn drop(&mut self) {\n        use std::mem;\n\n        match *self {\n            Ast::Empty(_)\n            | Ast::Flags(_)\n            | Ast::Literal(_)\n            | Ast::Dot(_)\n            | Ast::Assertion(_)\n            // Classes are recursive, so they get their own Drop impl.\n            | Ast::Class(_) => return,\n            Ast::Repetition(ref x) if !x.ast.has_subexprs() => return,\n            Ast::Group(ref x) if !x.ast.has_subexprs() => return,\n            Ast::Alternation(ref x) if x.asts.is_empty() => return,\n            Ast::Concat(ref x) if x.asts.is_empty() => return,\n            _ => {}\n        }\n\n        let empty_span = || Span::splat(Position::new(0, 0, 0));\n        let empty_ast = || Ast::Empty(empty_span());\n        let mut stack = vec![mem::replace(self, empty_ast())];\n        while let Some(mut ast) = stack.pop() {\n            match ast {\n                Ast::Empty(_)\n                | Ast::Flags(_)\n                | Ast::Literal(_)\n                | Ast::Dot(_)\n                | Ast::Assertion(_)\n                // Classes are recursive, so they get their own Drop impl.\n                | Ast::Class(_) => {}\n                Ast::Repetition(ref mut x) => {\n                    stack.push(mem::replace(&mut x.ast, empty_ast()));\n                }\n                Ast::Group(ref mut x) => {\n                    stack.push(mem::replace(&mut x.ast, empty_ast()));\n                }\n                Ast::Alternation(ref mut x) => {\n                    stack.extend(x.asts.drain(..));\n                }\n                Ast::Concat(ref mut x) => {\n                    stack.extend(x.asts.drain(..));\n                }\n            }\n        }\n    }\n}\n\n/// A custom `Drop` impl is used for `ClassSet` such that it uses constant\n/// stack space but heap space proportional to the depth of the `ClassSet`.\nimpl Drop for ClassSet {\n    fn drop(&mut self) {\n        use std::mem;\n\n        match *self {\n            ClassSet::Item(ref item) => match *item {\n                ClassSetItem::Empty(_)\n                | ClassSetItem::Literal(_)\n                | ClassSetItem::Range(_)\n                | ClassSetItem::Ascii(_)\n                | ClassSetItem::Unicode(_)\n                | ClassSetItem::Perl(_) => return,\n                ClassSetItem::Bracketed(ref x) => {\n                    if x.kind.is_empty() {\n                        return;\n                    }\n                }\n                ClassSetItem::Union(ref x) => {\n                    if x.items.is_empty() {\n                        return;\n                    }\n                }\n            },\n            ClassSet::BinaryOp(ref op) => {\n                if op.lhs.is_empty() && op.rhs.is_empty() {\n                    return;\n                }\n            }\n        }\n\n        let empty_span = || Span::splat(Position::new(0, 0, 0));\n        let empty_set = || ClassSet::Item(ClassSetItem::Empty(empty_span()));\n        let mut stack = vec![mem::replace(self, empty_set())];\n        while let Some(mut set) = stack.pop() {\n            match set {\n                ClassSet::Item(ref mut item) => match *item {\n                    ClassSetItem::Empty(_)\n                    | ClassSetItem::Literal(_)\n                    | ClassSetItem::Range(_)\n                    | ClassSetItem::Ascii(_)\n                    | ClassSetItem::Unicode(_)\n                    | ClassSetItem::Perl(_) => {}\n                    ClassSetItem::Bracketed(ref mut x) => {\n                        stack.push(mem::replace(&mut x.kind, empty_set()));\n                    }\n                    ClassSetItem::Union(ref mut x) => {\n                        stack.extend(x.items.drain(..).map(ClassSet::Item));\n                    }\n                },\n                ClassSet::BinaryOp(ref mut op) => {\n                    stack.push(mem::replace(&mut op.lhs, empty_set()));\n                    stack.push(mem::replace(&mut op.rhs, empty_set()));\n                }\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // We use a thread with an explicit stack size to test that our destructor\n    // for Ast can handle arbitrarily sized expressions in constant stack\n    // space. In case we run on a platform without threads (WASM?), we limit\n    // this test to Windows/Unix.\n    #[test]\n    #[cfg(any(unix, windows))]\n    fn no_stack_overflow_on_drop() {\n        use std::thread;\n\n        let run = || {\n            let span = || Span::splat(Position::new(0, 0, 0));\n            let mut ast = Ast::Empty(span());\n            for i in 0..200 {\n                ast = Ast::Group(Group {\n                    span: span(),\n                    kind: GroupKind::CaptureIndex(i),\n                    ast: Box::new(ast),\n                });\n            }\n            assert!(!ast.is_empty());\n        };\n\n        // We run our test on a thread with a small stack size so we can\n        // force the issue more easily.\n        thread::Builder::new()\n            .stack_size(1 << 10)\n            .spawn(run)\n            .unwrap()\n            .join()\n            .unwrap();\n    }\n}\n","traces":[{"line":35,"address":[6360208],"length":1,"stats":{"Line":14},"fn_name":"kind"},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[6360224],"length":1,"stats":{"Line":15},"fn_name":"pattern"},{"line":43,"address":[6360233],"length":1,"stats":{"Line":14},"fn_name":null},{"line":47,"address":[6360272],"length":1,"stats":{"Line":16},"fn_name":"span"},{"line":48,"address":[6360277],"length":1,"stats":{"Line":17},"fn_name":null},{"line":56,"address":[6360304],"length":1,"stats":{"Line":18},"fn_name":"auxiliary_span"},{"line":58,"address":[6360416,6360370,6360393],"length":1,"stats":{"Line":26},"fn_name":null},{"line":59,"address":[6360313,6360377],"length":1,"stats":{"Line":18},"fn_name":null},{"line":60,"address":[6360400],"length":1,"stats":{"Line":8},"fn_name":null},{"line":61,"address":[6360423],"length":1,"stats":{"Line":8},"fn_name":null},{"line":62,"address":[6360361],"length":1,"stats":{"Line":20},"fn_name":null},{"line":184,"address":[6360464],"length":1,"stats":{"Line":0},"fn_name":"description"},{"line":186,"address":[6360875,6360745,6360667,6360719,6361161,6361005,6361279,6361135,6361109,6360641,6360823,6361057,6360979,6361256,6360771,6361233,6360693,6360615,6361210,6360849,6361031,6360563,6361187,6360797,6360953,6360901,6360927,6361083,6360589],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[6360473,6360549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[6360575],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[6360601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[6360627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[6360653],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[6360679],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[6360705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[6360731],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[6360757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[6360783],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[6360809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[6360835],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[6360861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[6360887],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[6360913],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[6360939],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[6360965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[6360991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[6361017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[6361043],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[6361069],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[6361095],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[6361121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[6361147],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[6361173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[6361196],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[6361219],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[6361242],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[6361265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[6361288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[6361328],"length":1,"stats":{"Line":15},"fn_name":"fmt"},{"line":224,"address":[6361342],"length":1,"stats":{"Line":15},"fn_name":null},{"line":229,"address":[6361408],"length":1,"stats":{"Line":18},"fn_name":"fmt"},{"line":231,"address":[6363611,6364432,6363522,6363789,6363053,6364254,6364521,6362293,6362388,6363700,6361723,6362198,6361818,6364076,6362483,6362768,6363338,6364607,6363243,6364165,6364343,6361913,6362103,6362578,6363148,6362008,6362863,6363987,6362958,6362673,6363433],"length":1,"stats":{"Line":161},"fn_name":null},{"line":232,"address":[6361431,6361543],"length":1,"stats":{"Line":24},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[6361536],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[6361733],"length":1,"stats":{"Line":10},"fn_name":null},{"line":241,"address":[6361835],"length":1,"stats":{"Line":8},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[6361923],"length":1,"stats":{"Line":12},"fn_name":null},{"line":249,"address":[6362018],"length":1,"stats":{"Line":8},"fn_name":null},{"line":250,"address":[6362113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[6362208],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[6362303],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[6362398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[6362493],"length":1,"stats":{"Line":10},"fn_name":null},{"line":257,"address":[6362595],"length":1,"stats":{"Line":8},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[6362683],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[6362778],"length":1,"stats":{"Line":8},"fn_name":null},{"line":266,"address":[6362873],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[6362968],"length":1,"stats":{"Line":8},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[6363063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[6363158],"length":1,"stats":{"Line":8},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[6363253],"length":1,"stats":{"Line":8},"fn_name":null},{"line":277,"address":[6363348],"length":1,"stats":{"Line":8},"fn_name":null},{"line":278,"address":[6363443],"length":1,"stats":{"Line":8},"fn_name":null},{"line":279,"address":[6363532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[6363621],"length":1,"stats":{"Line":8},"fn_name":null},{"line":281,"address":[6363710],"length":1,"stats":{"Line":8},"fn_name":null},{"line":282,"address":[6363809,6363826],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[6364004],"length":1,"stats":{"Line":8},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[6364086],"length":1,"stats":{"Line":8},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[6364175],"length":1,"stats":{"Line":8},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[6364264],"length":1,"stats":{"Line":8},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[6364353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[6364442],"length":1,"stats":{"Line":8},"fn_name":null},{"line":308,"address":[6364535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[6364640],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":332,"address":[6364670],"length":1,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[6364944],"length":1,"stats":{"Line":9},"fn_name":"cmp"},{"line":338,"address":[6364958],"length":1,"stats":{"Line":9},"fn_name":null},{"line":343,"address":[6365040],"length":1,"stats":{"Line":9},"fn_name":"partial_cmp"},{"line":344,"address":[6365054],"length":1,"stats":{"Line":9},"fn_name":null},{"line":364,"address":[6365088],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":365,"address":[6365138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[6365118],"length":1,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[6365472],"length":1,"stats":{"Line":9},"fn_name":"cmp"},{"line":375,"address":[6365486],"length":1,"stats":{"Line":9},"fn_name":null},{"line":380,"address":[6365504],"length":1,"stats":{"Line":0},"fn_name":"partial_cmp"},{"line":381,"address":[6365518],"length":1,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[6365552],"length":1,"stats":{"Line":34},"fn_name":"new"},{"line":392,"address":[6365680],"length":1,"stats":{"Line":34},"fn_name":"splat"},{"line":393,"address":[6365687],"length":1,"stats":{"Line":34},"fn_name":null},{"line":398,"address":[6365776],"length":1,"stats":{"Line":0},"fn_name":"with_start"},{"line":404,"address":[6365872],"length":1,"stats":{"Line":23},"fn_name":"with_end"},{"line":409,"address":[6365968],"length":1,"stats":{"Line":14},"fn_name":"is_one_line"},{"line":410,"address":[6365973],"length":1,"stats":{"Line":17},"fn_name":null},{"line":415,"address":[6366000],"length":1,"stats":{"Line":0},"fn_name":"is_empty"},{"line":416,"address":[6366005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[6366032],"length":1,"stats":{"Line":10},"fn_name":"new"},{"line":495,"address":[6366080],"length":1,"stats":{"Line":23},"fn_name":"span"},{"line":496,"address":[6366276,6366224,6366198,6366316,6366339,6366362,6366172,6366250,6366144,6366385],"length":1,"stats":{"Line":78},"fn_name":null},{"line":497,"address":[6366089,6366156],"length":1,"stats":{"Line":23},"fn_name":null},{"line":498,"address":[6366182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[6366208],"length":1,"stats":{"Line":8},"fn_name":null},{"line":500,"address":[6366234],"length":1,"stats":{"Line":23},"fn_name":null},{"line":501,"address":[6366260],"length":1,"stats":{"Line":8},"fn_name":null},{"line":502,"address":[6366283],"length":1,"stats":{"Line":8},"fn_name":null},{"line":503,"address":[6366323],"length":1,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[6366346],"length":1,"stats":{"Line":8},"fn_name":null},{"line":505,"address":[6366369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[6366128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[6366400],"length":1,"stats":{"Line":0},"fn_name":"is_empty"},{"line":512,"address":[6366420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[6366409,6366422],"length":1,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[6366415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[6366448],"length":1,"stats":{"Line":9},"fn_name":"has_subexprs"},{"line":521,"address":[6366470,6366477],"length":1,"stats":{"Line":9},"fn_name":null},{"line":522,"address":[6366457],"length":1,"stats":{"Line":9},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[6366472],"length":1,"stats":{"Line":9},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[6366479],"length":1,"stats":{"Line":8},"fn_name":null},{"line":545,"address":[6366512],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":547,"address":[6366536],"length":1,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[6366659,6366592],"length":1,"stats":{"Line":8},"fn_name":"into_ast"},{"line":567,"address":[6366972,6366825,6366914,6366602],"length":1,"stats":{"Line":16},"fn_name":null},{"line":568,"address":[6366679,6366835],"length":1,"stats":{"Line":8},"fn_name":null},{"line":569,"address":[6366921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":570,"address":[6366728],"length":1,"stats":{"Line":8},"fn_name":null},{"line":590,"address":[6367107,6367040],"length":1,"stats":{"Line":23},"fn_name":"into_ast"},{"line":591,"address":[6367273,6367050,6367420,6367362],"length":1,"stats":{"Line":80},"fn_name":null},{"line":592,"address":[6367283,6367127],"length":1,"stats":{"Line":33},"fn_name":null},{"line":593,"address":[6367369],"length":1,"stats":{"Line":23},"fn_name":null},{"line":594,"address":[6367176],"length":1,"stats":{"Line":24},"fn_name":null},{"line":617,"address":[6367488],"length":1,"stats":{"Line":8},"fn_name":"byte"},{"line":618,"address":[6367497],"length":1,"stats":{"Line":9},"fn_name":null},{"line":619,"address":[6367601,6367515],"length":1,"stats":{"Line":18},"fn_name":null},{"line":620,"address":[6367608],"length":1,"stats":{"Line":8},"fn_name":null},{"line":622,"address":[6367596],"length":1,"stats":{"Line":9},"fn_name":null},{"line":695,"address":[6367648],"length":1,"stats":{"Line":14},"fn_name":"digits"},{"line":696,"address":[6367705,6367693],"length":1,"stats":{"Line":14},"fn_name":null},{"line":697,"address":[6367657,6367697],"length":1,"stats":{"Line":25},"fn_name":null},{"line":698,"address":[6367707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":699,"address":[6367685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":719,"address":[6367728],"length":1,"stats":{"Line":8},"fn_name":"span"},{"line":720,"address":[6367837,6367789,6367814],"length":1,"stats":{"Line":32},"fn_name":null},{"line":721,"address":[6367737,6367798],"length":1,"stats":{"Line":27},"fn_name":null},{"line":722,"address":[6367821],"length":1,"stats":{"Line":8},"fn_name":null},{"line":723,"address":[6367773],"length":1,"stats":{"Line":8},"fn_name":null},{"line":804,"address":[6367856],"length":1,"stats":{"Line":12},"fn_name":"from_name"},{"line":806,"address":[6368715,6368619,6368547,6368583,6368655,6368760,6368700,6368670,6368565,6368685,6368730,6368637,6368745,6368601],"length":1,"stats":{"Line":48},"fn_name":null},{"line":807,"address":[6368552,6367887],"length":1,"stats":{"Line":12},"fn_name":null},{"line":808,"address":[6367935,6368570],"length":1,"stats":{"Line":20},"fn_name":null},{"line":809,"address":[6367983,6368588],"length":1,"stats":{"Line":8},"fn_name":null},{"line":810,"address":[6368031,6368606],"length":1,"stats":{"Line":16},"fn_name":null},{"line":811,"address":[6368079,6368624],"length":1,"stats":{"Line":8},"fn_name":null},{"line":812,"address":[6368642,6368127],"length":1,"stats":{"Line":8},"fn_name":null},{"line":813,"address":[6368175,6368657],"length":1,"stats":{"Line":8},"fn_name":null},{"line":814,"address":[6368223,6368672],"length":1,"stats":{"Line":16},"fn_name":null},{"line":815,"address":[6368271,6368687],"length":1,"stats":{"Line":8},"fn_name":null},{"line":816,"address":[6368319,6368702],"length":1,"stats":{"Line":8},"fn_name":null},{"line":817,"address":[6368367,6368717],"length":1,"stats":{"Line":16},"fn_name":null},{"line":818,"address":[6368732,6368415],"length":1,"stats":{"Line":16},"fn_name":null},{"line":819,"address":[6368747,6368463],"length":1,"stats":{"Line":16},"fn_name":null},{"line":820,"address":[6368762,6368511],"length":1,"stats":{"Line":0},"fn_name":null},{"line":821,"address":[6368542],"length":1,"stats":{"Line":0},"fn_name":null},{"line":850,"address":[6368784],"length":1,"stats":{"Line":0},"fn_name":"is_negated"},{"line":851,"address":[6368823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":852,"address":[6368793],"length":1,"stats":{"Line":0},"fn_name":null},{"line":853,"address":[6368829],"length":1,"stats":{"Line":0},"fn_name":null},{"line":854,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":855,"address":[6368845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":856,"address":[6368813],"length":1,"stats":{"Line":0},"fn_name":null},{"line":894,"address":[6368880],"length":1,"stats":{"Line":0},"fn_name":"is_equal"},{"line":895,"address":[6368902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":896,"address":[6368889,6368904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":897,"address":[6368897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":932,"address":[6368928],"length":1,"stats":{"Line":8},"fn_name":"union"},{"line":933,"address":[6368938],"length":1,"stats":{"Line":8},"fn_name":null},{"line":937,"address":[6369088],"length":1,"stats":{"Line":0},"fn_name":"span"},{"line":938,"address":[6369133,6369177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":939,"address":[6369097,6369142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":940,"address":[6369117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":945,"address":[6369200],"length":1,"stats":{"Line":0},"fn_name":"is_empty"},{"line":946,"address":[6369235],"length":1,"stats":{"Line":0},"fn_name":null},{"line":947,"address":[6369209,6369237],"length":1,"stats":{"Line":0},"fn_name":null},{"line":948,"address":[6369230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":982,"address":[6369264],"length":1,"stats":{"Line":8},"fn_name":"span"},{"line":983,"address":[6369426,6369354,6369403,6369472,6369504,6369380,6369449,6369326],"length":1,"stats":{"Line":47},"fn_name":null},{"line":984,"address":[6369338,6369273],"length":1,"stats":{"Line":8},"fn_name":null},{"line":985,"address":[6369364],"length":1,"stats":{"Line":8},"fn_name":null},{"line":986,"address":[6369387],"length":1,"stats":{"Line":8},"fn_name":null},{"line":987,"address":[6369410],"length":1,"stats":{"Line":10},"fn_name":null},{"line":988,"address":[6369433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":989,"address":[6369456],"length":1,"stats":{"Line":11},"fn_name":null},{"line":990,"address":[6369479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":991,"address":[6369310],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1012,"address":[6369520],"length":1,"stats":{"Line":8},"fn_name":"is_valid"},{"line":1013,"address":[6369525],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1038,"address":[6369618,6369552],"length":1,"stats":{"Line":8},"fn_name":"push"},{"line":1039,"address":[6369567,6369637],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1040,"address":[6369643],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1042,"address":[6369726],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1043,"address":[6369799],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1052,"address":[6369968,6370035],"length":1,"stats":{"Line":8},"fn_name":"into_item"},{"line":1053,"address":[6369978,6370201,6370290,6370348],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1054,"address":[6370211,6370055],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1055,"address":[6370297],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1056,"address":[6370104],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1169,"address":[6370416],"length":1,"stats":{"Line":8},"fn_name":"is_valid"},{"line":1170,"address":[6370444,6370511],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1171,"address":[6370450,6370425,6370513],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1172,"address":[6370439],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1196,"address":[6370544],"length":1,"stats":{"Line":32},"fn_name":"flags"},{"line":1197,"address":[6370577],"length":1,"stats":{"Line":31},"fn_name":null},{"line":1198,"address":[6370583,6370553],"length":1,"stats":{"Line":42},"fn_name":null},{"line":1199,"address":[6370568],"length":1,"stats":{"Line":31},"fn_name":null},{"line":1204,"address":[6370624],"length":1,"stats":{"Line":0},"fn_name":"is_capturing"},{"line":1205,"address":[6370651],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1206,"address":[6370633,6370655],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1207,"address":[6370646],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1214,"address":[6370688],"length":1,"stats":{"Line":0},"fn_name":"capture_index"},{"line":1215,"address":[6370738,6370766],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1216,"address":[6370747,6370697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1217,"address":[6370773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1218,"address":[6370730],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1275,"address":[6370832],"length":1,"stats":{"Line":16},"fn_name":"add_item"},{"line":1276,"address":[6370847,6371116,6371231],"length":1,"stats":{"Line":31},"fn_name":null},{"line":1277,"address":[6371182],"length":1,"stats":{"Line":15},"fn_name":null},{"line":1278,"address":[6371241],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1281,"address":[6371050],"length":1,"stats":{"Line":17},"fn_name":null},{"line":1282,"address":[6371273],"length":1,"stats":{"Line":15},"fn_name":null},{"line":1294,"address":[6371296],"length":1,"stats":{"Line":18},"fn_name":"flag_state"},{"line":1295,"address":[6371313],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1296,"address":[6371409,6371579,6371574,6371318],"length":1,"stats":{"Line":32},"fn_name":null},{"line":1297,"address":[6371477],"length":1,"stats":{"Line":15},"fn_name":null},{"line":1298,"address":[6371431],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1299,"address":[6371472],"length":1,"stats":{"Line":15},"fn_name":null},{"line":1301,"address":[6371560,6371484],"length":1,"stats":{"Line":32},"fn_name":null},{"line":1302,"address":[6371546],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1307,"address":[6371399],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1332,"address":[6371584],"length":1,"stats":{"Line":0},"fn_name":"is_negation"},{"line":1333,"address":[6371625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1334,"address":[6371627,6371597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1335,"address":[6371620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1360,"address":[6624768,6624826],"length":1,"stats":{"Line":24},"fn_name":"drop"},{"line":1363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1364,"address":[6624783],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1370,"address":[6624902],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1371,"address":[6624909],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1372,"address":[6624972],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1373,"address":[6625044],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1374,"address":[6625117],"length":1,"stats":{"Line":25},"fn_name":null},{"line":1375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1378,"address":[6535552,6535536],"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":1379,"address":[6535616,6535628],"length":1,"stats":{"Line":30},"fn_name":"{{closure}}"},{"line":1380,"address":[6625861,6624861,6625185],"length":1,"stats":{"Line":20},"fn_name":null},{"line":1381,"address":[6625270,6625316,6625840,6625568],"length":1,"stats":{"Line":30},"fn_name":null},{"line":1382,"address":[6625613,6625793,6625819,6625482,6625724],"length":1,"stats":{"Line":50},"fn_name":null},{"line":1383,"address":[6625402],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1390,"address":[6625484],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1391,"address":[6625500,6625589],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1393,"address":[6625618],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1394,"address":[6625634],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1396,"address":[6625726],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1397,"address":[6625742],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1399,"address":[6625436],"length":1,"stats":{"Line":25},"fn_name":null},{"line":1400,"address":[6625795,6625452],"length":1,"stats":{"Line":50},"fn_name":null},{"line":1410,"address":[6626000,6625968],"length":1,"stats":{"Line":8},"fn_name":"drop"},{"line":1413,"address":[6626318,6626062,6626253],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1414,"address":[6626249,6625983,6626164,6626069,6626235],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1415,"address":[6626086],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1416,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1420,"address":[6626174],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1421,"address":[6626183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1422,"address":[6626202],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1423,"address":[6626237],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1426,"address":[6626129],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1427,"address":[6626143,6626243],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1428,"address":[6626251],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1432,"address":[6626020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1433,"address":[6626255,6626039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1434,"address":[6626320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1439,"address":[6535712,6535728],"length":1,"stats":{"Line":16},"fn_name":"{{closure}}"},{"line":1440,"address":[6535810,6535792],"length":1,"stats":{"Line":24},"fn_name":"{{closure}}"},{"line":1441,"address":[6627200,6626345],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1442,"address":[6626524,6627176,6626472,6626889],"length":1,"stats":{"Line":27},"fn_name":null},{"line":1443,"address":[6626995,6626685,6627155],"length":1,"stats":{"Line":11},"fn_name":null},{"line":1444,"address":[6626687,6626800,6626610,6626993,6626937],"length":1,"stats":{"Line":27},"fn_name":null},{"line":1445,"address":[6626703],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1446,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1447,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1448,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1449,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1450,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1451,"address":[6626807],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1452,"address":[6626910,6626824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1454,"address":[6626754],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1455,"address":[6626939,6626771],"length":1,"stats":{"Line":20},"fn_name":null},{"line":1458,"address":[6626625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1459,"address":[6627000,6626641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1460,"address":[6627064],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":180,"coverable":344},{"path":["/","usr","src","regex","regex-syntax","src","ast","parse.rs"],"content":"/*!\nThis module provides a regular expression parser.\n*/\n\nuse std::borrow::Borrow;\nuse std::cell::{Cell, RefCell};\nuse std::mem;\nuse std::result;\n\nuse ast::{self, Ast, Position, Span};\nuse either::Either;\n\nuse is_meta_character;\n\ntype Result<T> = result::Result<T, ast::Error>;\n\n/// A primitive is an expression with no sub-expressions. This includes\n/// literals, assertions and non-set character classes. This representation\n/// is used as intermediate state in the parser.\n///\n/// This does not include ASCII character classes, since they can only appear\n/// within a set character class.\n#[derive(Clone, Debug, Eq, PartialEq)]\nenum Primitive {\n    Literal(ast::Literal),\n    Assertion(ast::Assertion),\n    Dot(Span),\n    Perl(ast::ClassPerl),\n    Unicode(ast::ClassUnicode),\n}\n\nimpl Primitive {\n    /// Return the span of this primitive.\n    fn span(&self) -> &Span {\n        match *self {\n            Primitive::Literal(ref x) => &x.span,\n            Primitive::Assertion(ref x) => &x.span,\n            Primitive::Dot(ref span) => span,\n            Primitive::Perl(ref x) => &x.span,\n            Primitive::Unicode(ref x) => &x.span,\n        }\n    }\n\n    /// Convert this primitive into a proper AST.\n    fn into_ast(self) -> Ast {\n        match self {\n            Primitive::Literal(lit) => Ast::Literal(lit),\n            Primitive::Assertion(assert) => Ast::Assertion(assert),\n            Primitive::Dot(span) => Ast::Dot(span),\n            Primitive::Perl(cls) => Ast::Class(ast::Class::Perl(cls)),\n            Primitive::Unicode(cls) => Ast::Class(ast::Class::Unicode(cls)),\n        }\n    }\n\n    /// Convert this primitive into an item in a character class.\n    ///\n    /// If this primitive is not a legal item (i.e., an assertion or a dot),\n    /// then return an error.\n    fn into_class_set_item<P: Borrow<Parser>>(\n        self,\n        p: &ParserI<P>,\n    ) -> Result<ast::ClassSetItem> {\n        use self::Primitive::*;\n        use ast::ClassSetItem;\n\n        match self {\n            Literal(lit) => Ok(ClassSetItem::Literal(lit)),\n            Perl(cls) => Ok(ClassSetItem::Perl(cls)),\n            Unicode(cls) => Ok(ClassSetItem::Unicode(cls)),\n            x => Err(p.error(*x.span(), ast::ErrorKind::ClassEscapeInvalid)),\n        }\n    }\n\n    /// Convert this primitive into a literal in a character class. In\n    /// particular, literals are the only valid items that can appear in\n    /// ranges.\n    ///\n    /// If this primitive is not a legal item (i.e., a class, assertion or a\n    /// dot), then return an error.\n    fn into_class_literal<P: Borrow<Parser>>(\n        self,\n        p: &ParserI<P>,\n    ) -> Result<ast::Literal> {\n        use self::Primitive::*;\n\n        match self {\n            Literal(lit) => Ok(lit),\n            x => Err(p.error(*x.span(), ast::ErrorKind::ClassRangeLiteral)),\n        }\n    }\n}\n\n/// Returns true if the given character is a hexadecimal digit.\nfn is_hex(c: char) -> bool {\n    ('0' <= c && c <= '9') || ('a' <= c && c <= 'f') || ('A' <= c && c <= 'F')\n}\n\n/// Returns true if the given character is a valid in a capture group name.\n///\n/// If `first` is true, then `c` is treated as the first character in the\n/// group name (which is not allowed to be a digit).\nfn is_capture_char(c: char, first: bool) -> bool {\n    c == '_'\n        || (!first && c >= '0' && c <= '9')\n        || (c >= 'a' && c <= 'z')\n        || (c >= 'A' && c <= 'Z')\n}\n\n/// A builder for a regular expression parser.\n///\n/// This builder permits modifying configuration options for the parser.\n#[derive(Clone, Debug)]\npub struct ParserBuilder {\n    ignore_whitespace: bool,\n    nest_limit: u32,\n    octal: bool,\n}\n\nimpl Default for ParserBuilder {\n    fn default() -> ParserBuilder {\n        ParserBuilder::new()\n    }\n}\n\nimpl ParserBuilder {\n    /// Create a new parser builder with a default configuration.\n    pub fn new() -> ParserBuilder {\n        ParserBuilder {\n            ignore_whitespace: false,\n            nest_limit: 250,\n            octal: false,\n        }\n    }\n\n    /// Build a parser from this configuration with the given pattern.\n    pub fn build(&self) -> Parser {\n        Parser {\n            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),\n            capture_index: Cell::new(0),\n            nest_limit: self.nest_limit,\n            octal: self.octal,\n            initial_ignore_whitespace: self.ignore_whitespace,\n            ignore_whitespace: Cell::new(self.ignore_whitespace),\n            comments: RefCell::new(vec![]),\n            stack_group: RefCell::new(vec![]),\n            stack_class: RefCell::new(vec![]),\n            capture_names: RefCell::new(vec![]),\n            scratch: RefCell::new(String::new()),\n        }\n    }\n\n    /// Set the nesting limit for this parser.\n    ///\n    /// The nesting limit controls how deep the abstract syntax tree is allowed\n    /// to be. If the AST exceeds the given limit (e.g., with too many nested\n    /// groups), then an error is returned by the parser.\n    ///\n    /// The purpose of this limit is to act as a heuristic to prevent stack\n    /// overflow for consumers that do structural induction on an `Ast` using\n    /// explicit recursion. While this crate never does this (instead using\n    /// constant stack space and moving the call stack to the heap), other\n    /// crates may.\n    ///\n    /// This limit is not checked until the entire Ast is parsed. Therefore,\n    /// if callers want to put a limit on the amount of heap space used, then\n    /// they should impose a limit on the length, in bytes, of the concrete\n    /// pattern string. In particular, this is viable since this parser\n    /// implementation will limit itself to heap space proportional to the\n    /// lenth of the pattern string.\n    ///\n    /// Note that a nest limit of `0` will return a nest limit error for most\n    /// patterns but not all. For example, a nest limit of `0` permits `a` but\n    /// not `ab`, since `ab` requires a concatenation, which results in a nest\n    /// depth of `1`. In general, a nest limit is not something that manifests\n    /// in an obvious way in the concrete syntax, therefore, it should not be\n    /// used in a granular way.\n    pub fn nest_limit(&mut self, limit: u32) -> &mut ParserBuilder {\n        self.nest_limit = limit;\n        self\n    }\n\n    /// Whether to support octal syntax or not.\n    ///\n    /// Octal syntax is a little-known way of uttering Unicode codepoints in\n    /// a regular expression. For example, `a`, `\\x61`, `\\u0061` and\n    /// `\\141` are all equivalent regular expressions, where the last example\n    /// shows octal syntax.\n    ///\n    /// While supporting octal syntax isn't in and of itself a problem, it does\n    /// make good error messages harder. That is, in PCRE based regex engines,\n    /// syntax like `\\0` invokes a backreference, which is explicitly\n    /// unsupported in Rust's regex engine. However, many users expect it to\n    /// be supported. Therefore, when octal support is disabled, the error\n    /// message will explicitly mention that backreferences aren't supported.\n    ///\n    /// Octal syntax is disabled by default.\n    pub fn octal(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.octal = yes;\n        self\n    }\n\n    /// Enable verbose mode in the regular expression.\n    ///\n    /// When enabled, verbose mode permits insigificant whitespace in many\n    /// places in the regular expression, as well as comments. Comments are\n    /// started using `#` and continue until the end of the line.\n    ///\n    /// By default, this is disabled. It may be selectively enabled in the\n    /// regular expression by using the `x` flag regardless of this setting.\n    pub fn ignore_whitespace(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.ignore_whitespace = yes;\n        self\n    }\n}\n\n/// A regular expression parser.\n///\n/// This parses a string representation of a regular expression into an\n/// abstract syntax tree. The size of the tree is proportional to the length\n/// of the regular expression pattern.\n///\n/// A `Parser` can be configured in more detail via a\n/// [`ParserBuilder`](struct.ParserBuilder.html).\n#[derive(Clone, Debug)]\npub struct Parser {\n    /// The current position of the parser.\n    pos: Cell<Position>,\n    /// The current capture index.\n    capture_index: Cell<u32>,\n    /// The maximum number of open parens/brackets allowed. If the parser\n    /// exceeds this number, then an error is returned.\n    nest_limit: u32,\n    /// Whether to support octal syntax or not. When `false`, the parser will\n    /// return an error helpfully pointing out that backreferences are not\n    /// supported.\n    octal: bool,\n    /// The initial setting for `ignore_whitespace` as provided by\n    /// Th`ParserBuilder`. is is used when reseting the parser's state.\n    initial_ignore_whitespace: bool,\n    /// Whether whitespace should be ignored. When enabled, comments are\n    /// also permitted.\n    ignore_whitespace: Cell<bool>,\n    /// A list of comments, in order of appearance.\n    comments: RefCell<Vec<ast::Comment>>,\n    /// A stack of grouped sub-expressions, including alternations.\n    stack_group: RefCell<Vec<GroupState>>,\n    /// A stack of nested character classes. This is only non-empty when\n    /// parsing a class.\n    stack_class: RefCell<Vec<ClassState>>,\n    /// A sorted sequence of capture names. This is used to detect duplicate\n    /// capture names and report an error if one is detected.\n    capture_names: RefCell<Vec<ast::CaptureName>>,\n    /// A scratch buffer used in various places. Mostly this is used to\n    /// accumulate relevant characters from parts of a pattern.\n    scratch: RefCell<String>,\n}\n\n/// ParserI is the internal parser implementation.\n///\n/// We use this separate type so that we can carry the provided pattern string\n/// along with us. In particular, a `Parser` internal state is not tied to any\n/// one pattern, but `ParserI` is.\n///\n/// This type also lets us use `ParserI<&Parser>` in production code while\n/// retaining the convenience of `ParserI<Parser>` for tests, which sometimes\n/// work against the internal interface of the parser.\n#[derive(Clone, Debug)]\nstruct ParserI<'s, P> {\n    /// The parser state/configuration.\n    parser: P,\n    /// The full regular expression provided by the user.\n    pattern: &'s str,\n}\n\n/// GroupState represents a single stack frame while parsing nested groups\n/// and alternations. Each frame records the state up to an opening parenthesis\n/// or a alternating bracket `|`.\n#[derive(Clone, Debug)]\nenum GroupState {\n    /// This state is pushed whenever an opening group is found.\n    Group {\n        /// The concatenation immediately preceding the opening group.\n        concat: ast::Concat,\n        /// The group that has been opened. Its sub-AST is always empty.\n        group: ast::Group,\n        /// Whether this group has the `x` flag enabled or not.\n        ignore_whitespace: bool,\n    },\n    /// This state is pushed whenever a new alternation branch is found. If\n    /// an alternation branch is found and this state is at the top of the\n    /// stack, then this state should be modified to include the new\n    /// alternation.\n    Alternation(ast::Alternation),\n}\n\n/// ClassState represents a single stack frame while parsing character classes.\n/// Each frame records the state up to an intersection, difference, symmetric\n/// difference or nested class.\n///\n/// Note that a parser's character class stack is only non-empty when parsing\n/// a character class. In all other cases, it is empty.\n#[derive(Clone, Debug)]\nenum ClassState {\n    /// This state is pushed whenever an opening bracket is found.\n    Open {\n        /// The union of class items immediately preceding this class.\n        union: ast::ClassSetUnion,\n        /// The class that has been opened. Typically this just corresponds\n        /// to the `[`, but it can also include `[^` since `^` indicates\n        /// negation of the class.\n        set: ast::ClassBracketed,\n    },\n    /// This state is pushed when a operator is seen. When popped, the stored\n    /// set becomes the left hand side of the operator.\n    Op {\n        /// The type of the operation, i.e., &&, -- or ~~.\n        kind: ast::ClassSetBinaryOpKind,\n        /// The left-hand side of the operator.\n        lhs: ast::ClassSet,\n    },\n}\n\nimpl Parser {\n    /// Create a new parser with a default configuration.\n    ///\n    /// The parser can be run with either the `parse` or `parse_with_comments`\n    /// methods. The parse methods return an abstract syntax tree.\n    ///\n    /// To set configuration options on the parser, use\n    /// [`ParserBuilder`](struct.ParserBuilder.html).\n    pub fn new() -> Parser {\n        ParserBuilder::new().build()\n    }\n\n    /// Parse the regular expression into an abstract syntax tree.\n    pub fn parse(&mut self, pattern: &str) -> Result<Ast> {\n        ParserI::new(self, pattern).parse()\n    }\n\n    /// Parse the regular expression and return an abstract syntax tree with\n    /// all of the comments found in the pattern.\n    pub fn parse_with_comments(\n        &mut self,\n        pattern: &str,\n    ) -> Result<ast::WithComments> {\n        ParserI::new(self, pattern).parse_with_comments()\n    }\n\n    /// Reset the internal state of a parser.\n    ///\n    /// This is called at the beginning of every parse. This prevents the\n    /// parser from running with inconsistent state (say, if a previous\n    /// invocation returned an error and the parser is reused).\n    fn reset(&self) {\n        // These settings should be in line with the construction\n        // in `ParserBuilder::build`.\n        self.pos.set(Position { offset: 0, line: 1, column: 1 });\n        self.ignore_whitespace.set(self.initial_ignore_whitespace);\n        self.comments.borrow_mut().clear();\n        self.stack_group.borrow_mut().clear();\n        self.stack_class.borrow_mut().clear();\n    }\n}\n\nimpl<'s, P: Borrow<Parser>> ParserI<'s, P> {\n    /// Build an internal parser from a parser configuration and a pattern.\n    fn new(parser: P, pattern: &'s str) -> ParserI<'s, P> {\n        ParserI { parser: parser, pattern: pattern }\n    }\n\n    /// Return a reference to the parser state.\n    fn parser(&self) -> &Parser {\n        self.parser.borrow()\n    }\n\n    /// Return a reference to the pattern being parsed.\n    fn pattern(&self) -> &str {\n        self.pattern.borrow()\n    }\n\n    /// Create a new error with the given span and error type.\n    fn error(&self, span: Span, kind: ast::ErrorKind) -> ast::Error {\n        ast::Error {\n            kind: kind,\n            pattern: self.pattern().to_string(),\n            span: span,\n        }\n    }\n\n    /// Return the current offset of the parser.\n    ///\n    /// The offset starts at `0` from the beginning of the regular expression\n    /// pattern string.\n    fn offset(&self) -> usize {\n        self.parser().pos.get().offset\n    }\n\n    /// Return the current line number of the parser.\n    ///\n    /// The line number starts at `1`.\n    fn line(&self) -> usize {\n        self.parser().pos.get().line\n    }\n\n    /// Return the current column of the parser.\n    ///\n    /// The column number starts at `1` and is reset whenever a `\\n` is seen.\n    fn column(&self) -> usize {\n        self.parser().pos.get().column\n    }\n\n    /// Return the next capturing index. Each subsequent call increments the\n    /// internal index.\n    ///\n    /// The span given should correspond to the location of the opening\n    /// parenthesis.\n    ///\n    /// If the capture limit is exceeded, then an error is returned.\n    fn next_capture_index(&self, span: Span) -> Result<u32> {\n        let current = self.parser().capture_index.get();\n        let i = current.checked_add(1).ok_or_else(|| {\n            self.error(span, ast::ErrorKind::CaptureLimitExceeded)\n        })?;\n        self.parser().capture_index.set(i);\n        Ok(i)\n    }\n\n    /// Adds the given capture name to this parser. If this capture name has\n    /// already been used, then an error is returned.\n    fn add_capture_name(&self, cap: &ast::CaptureName) -> Result<()> {\n        let mut names = self.parser().capture_names.borrow_mut();\n        match names\n            .binary_search_by_key(&cap.name.as_str(), |c| c.name.as_str())\n        {\n            Err(i) => {\n                names.insert(i, cap.clone());\n                Ok(())\n            }\n            Ok(i) => Err(self.error(\n                cap.span,\n                ast::ErrorKind::GroupNameDuplicate { original: names[i].span },\n            )),\n        }\n    }\n\n    /// Return whether the parser should ignore whitespace or not.\n    fn ignore_whitespace(&self) -> bool {\n        self.parser().ignore_whitespace.get()\n    }\n\n    /// Return the character at the current position of the parser.\n    ///\n    /// This panics if the current position does not point to a valid char.\n    fn char(&self) -> char {\n        self.char_at(self.offset())\n    }\n\n    /// Return the character at the given position.\n    ///\n    /// This panics if the given position does not point to a valid char.\n    fn char_at(&self, i: usize) -> char {\n        self.pattern()[i..]\n            .chars()\n            .next()\n            .unwrap_or_else(|| panic!(\"expected char at offset {}\", i))\n    }\n\n    /// Bump the parser to the next Unicode scalar value.\n    ///\n    /// If the end of the input has been reached, then `false` is returned.\n    fn bump(&self) -> bool {\n        if self.is_eof() {\n            return false;\n        }\n        let Position { mut offset, mut line, mut column } = self.pos();\n        if self.char() == '\\n' {\n            line = line.checked_add(1).unwrap();\n            column = 1;\n        } else {\n            column = column.checked_add(1).unwrap();\n        }\n        offset += self.char().len_utf8();\n        self.parser().pos.set(Position {\n            offset: offset,\n            line: line,\n            column: column,\n        });\n        self.pattern()[self.offset()..].chars().next().is_some()\n    }\n\n    /// If the substring starting at the current position of the parser has\n    /// the given prefix, then bump the parser to the character immediately\n    /// following the prefix and return true. Otherwise, don't bump the parser\n    /// and return false.\n    fn bump_if(&self, prefix: &str) -> bool {\n        if self.pattern()[self.offset()..].starts_with(prefix) {\n            for _ in 0..prefix.chars().count() {\n                self.bump();\n            }\n            true\n        } else {\n            false\n        }\n    }\n\n    /// Returns true if and only if the parser is positioned at a look-around\n    /// prefix. The conditions under which this returns true must always\n    /// correspond to a regular expression that would otherwise be consider\n    /// invalid.\n    ///\n    /// This should only be called immediately after parsing the opening of\n    /// a group or a set of flags.\n    fn is_lookaround_prefix(&self) -> bool {\n        self.bump_if(\"?=\")\n            || self.bump_if(\"?!\")\n            || self.bump_if(\"?<=\")\n            || self.bump_if(\"?<!\")\n    }\n\n    /// Bump the parser, and if the `x` flag is enabled, bump through any\n    /// subsequent spaces. Return true if and only if the parser is not at\n    /// EOF.\n    fn bump_and_bump_space(&self) -> bool {\n        if !self.bump() {\n            return false;\n        }\n        self.bump_space();\n        !self.is_eof()\n    }\n\n    /// If the `x` flag is enabled (i.e., whitespace insensitivity with\n    /// comments), then this will advance the parser through all whitespace\n    /// and comments to the next non-whitespace non-comment byte.\n    ///\n    /// If the `x` flag is disabled, then this is a no-op.\n    ///\n    /// This should be used selectively throughout the parser where\n    /// arbitrary whitespace is permitted when the `x` flag is enabled. For\n    /// example, `{   5  , 6}` is equivalent to `{5,6}`.\n    fn bump_space(&self) {\n        if !self.ignore_whitespace() {\n            return;\n        }\n        while !self.is_eof() {\n            if self.char().is_whitespace() {\n                self.bump();\n            } else if self.char() == '#' {\n                let start = self.pos();\n                let mut comment_text = String::new();\n                self.bump();\n                while !self.is_eof() {\n                    let c = self.char();\n                    self.bump();\n                    if c == '\\n' {\n                        break;\n                    }\n                    comment_text.push(c);\n                }\n                let comment = ast::Comment {\n                    span: Span::new(start, self.pos()),\n                    comment: comment_text,\n                };\n                self.parser().comments.borrow_mut().push(comment);\n            } else {\n                break;\n            }\n        }\n    }\n\n    /// Peek at the next character in the input without advancing the parser.\n    ///\n    /// If the input has been exhausted, then this returns `None`.\n    fn peek(&self) -> Option<char> {\n        if self.is_eof() {\n            return None;\n        }\n        self.pattern()[self.offset() + self.char().len_utf8()..].chars().next()\n    }\n\n    /// Like peek, but will ignore spaces when the parser is in whitespace\n    /// insensitive mode.\n    fn peek_space(&self) -> Option<char> {\n        if !self.ignore_whitespace() {\n            return self.peek();\n        }\n        if self.is_eof() {\n            return None;\n        }\n        let mut start = self.offset() + self.char().len_utf8();\n        let mut in_comment = false;\n        for (i, c) in self.pattern()[start..].char_indices() {\n            if c.is_whitespace() {\n                continue;\n            } else if !in_comment && c == '#' {\n                in_comment = true;\n            } else if in_comment && c == '\\n' {\n                in_comment = false;\n            } else {\n                start += i;\n                break;\n            }\n        }\n        self.pattern()[start..].chars().next()\n    }\n\n    /// Returns true if the next call to `bump` would return false.\n    fn is_eof(&self) -> bool {\n        self.offset() == self.pattern().len()\n    }\n\n    /// Return the current position of the parser, which includes the offset,\n    /// line and column.\n    fn pos(&self) -> Position {\n        self.parser().pos.get()\n    }\n\n    /// Create a span at the current position of the parser. Both the start\n    /// and end of the span are set.\n    fn span(&self) -> Span {\n        Span::splat(self.pos())\n    }\n\n    /// Create a span that covers the current character.\n    fn span_char(&self) -> Span {\n        let mut next = Position {\n            offset: self.offset().checked_add(self.char().len_utf8()).unwrap(),\n            line: self.line(),\n            column: self.column().checked_add(1).unwrap(),\n        };\n        if self.char() == '\\n' {\n            next.line += 1;\n            next.column = 1;\n        }\n        Span::new(self.pos(), next)\n    }\n\n    /// Parse and push a single alternation on to the parser's internal stack.\n    /// If the top of the stack already has an alternation, then add to that\n    /// instead of pushing a new one.\n    ///\n    /// The concatenation given corresponds to a single alternation branch.\n    /// The concatenation returned starts the next branch and is empty.\n    ///\n    /// This assumes the parser is currently positioned at `|` and will advance\n    /// the parser to the character following `|`.\n    #[inline(never)]\n    fn push_alternate(&self, mut concat: ast::Concat) -> Result<ast::Concat> {\n        assert_eq!(self.char(), '|');\n        concat.span.end = self.pos();\n        self.push_or_add_alternation(concat);\n        self.bump();\n        Ok(ast::Concat { span: self.span(), asts: vec![] })\n    }\n\n    /// Pushes or adds the given branch of an alternation to the parser's\n    /// internal stack of state.\n    fn push_or_add_alternation(&self, concat: ast::Concat) {\n        use self::GroupState::*;\n\n        let mut stack = self.parser().stack_group.borrow_mut();\n        if let Some(&mut Alternation(ref mut alts)) = stack.last_mut() {\n            alts.asts.push(concat.into_ast());\n            return;\n        }\n        stack.push(Alternation(ast::Alternation {\n            span: Span::new(concat.span.start, self.pos()),\n            asts: vec![concat.into_ast()],\n        }));\n    }\n\n    /// Parse and push a group AST (and its parent concatenation) on to the\n    /// parser's internal stack. Return a fresh concatenation corresponding\n    /// to the group's sub-AST.\n    ///\n    /// If a set of flags was found (with no group), then the concatenation\n    /// is returned with that set of flags added.\n    ///\n    /// This assumes that the parser is currently positioned on the opening\n    /// parenthesis. It advances the parser to the character at the start\n    /// of the sub-expression (or adjoining expression).\n    ///\n    /// If there was a problem parsing the start of the group, then an error\n    /// is returned.\n    #[inline(never)]\n    fn push_group(&self, mut concat: ast::Concat) -> Result<ast::Concat> {\n        assert_eq!(self.char(), '(');\n        match self.parse_group()? {\n            Either::Left(set) => {\n                let ignore = set.flags.flag_state(ast::Flag::IgnoreWhitespace);\n                if let Some(v) = ignore {\n                    self.parser().ignore_whitespace.set(v);\n                }\n\n                concat.asts.push(Ast::Flags(set));\n                Ok(concat)\n            }\n            Either::Right(group) => {\n                let old_ignore_whitespace = self.ignore_whitespace();\n                let new_ignore_whitespace = group\n                    .flags()\n                    .and_then(|f| f.flag_state(ast::Flag::IgnoreWhitespace))\n                    .unwrap_or(old_ignore_whitespace);\n                self.parser().stack_group.borrow_mut().push(\n                    GroupState::Group {\n                        concat: concat,\n                        group: group,\n                        ignore_whitespace: old_ignore_whitespace,\n                    },\n                );\n                self.parser().ignore_whitespace.set(new_ignore_whitespace);\n                Ok(ast::Concat { span: self.span(), asts: vec![] })\n            }\n        }\n    }\n\n    /// Pop a group AST from the parser's internal stack and set the group's\n    /// AST to the given concatenation. Return the concatenation containing\n    /// the group.\n    ///\n    /// This assumes that the parser is currently positioned on the closing\n    /// parenthesis and advances the parser to the character following the `)`.\n    ///\n    /// If no such group could be popped, then an unopened group error is\n    /// returned.\n    #[inline(never)]\n    fn pop_group(&self, mut group_concat: ast::Concat) -> Result<ast::Concat> {\n        use self::GroupState::*;\n\n        assert_eq!(self.char(), ')');\n        let mut stack = self.parser().stack_group.borrow_mut();\n        let (mut prior_concat, mut group, ignore_whitespace, alt) = match stack\n            .pop()\n        {\n            Some(Group { concat, group, ignore_whitespace }) => {\n                (concat, group, ignore_whitespace, None)\n            }\n            Some(Alternation(alt)) => match stack.pop() {\n                Some(Group { concat, group, ignore_whitespace }) => {\n                    (concat, group, ignore_whitespace, Some(alt))\n                }\n                None | Some(Alternation(_)) => {\n                    return Err(self.error(\n                        self.span_char(),\n                        ast::ErrorKind::GroupUnopened,\n                    ));\n                }\n            },\n            None => {\n                return Err(self\n                    .error(self.span_char(), ast::ErrorKind::GroupUnopened));\n            }\n        };\n        self.parser().ignore_whitespace.set(ignore_whitespace);\n        group_concat.span.end = self.pos();\n        self.bump();\n        group.span.end = self.pos();\n        match alt {\n            Some(mut alt) => {\n                alt.span.end = group_concat.span.end;\n                alt.asts.push(group_concat.into_ast());\n                group.ast = Box::new(alt.into_ast());\n            }\n            None => {\n                group.ast = Box::new(group_concat.into_ast());\n            }\n        }\n        prior_concat.asts.push(Ast::Group(group));\n        Ok(prior_concat)\n    }\n\n    /// Pop the last state from the parser's internal stack, if it exists, and\n    /// add the given concatenation to it. There either must be no state or a\n    /// single alternation item on the stack. Any other scenario produces an\n    /// error.\n    ///\n    /// This assumes that the parser has advanced to the end.\n    #[inline(never)]\n    fn pop_group_end(&self, mut concat: ast::Concat) -> Result<Ast> {\n        concat.span.end = self.pos();\n        let mut stack = self.parser().stack_group.borrow_mut();\n        let ast = match stack.pop() {\n            None => Ok(concat.into_ast()),\n            Some(GroupState::Alternation(mut alt)) => {\n                alt.span.end = self.pos();\n                alt.asts.push(concat.into_ast());\n                Ok(Ast::Alternation(alt))\n            }\n            Some(GroupState::Group { group, .. }) => {\n                return Err(\n                    self.error(group.span, ast::ErrorKind::GroupUnclosed)\n                );\n            }\n        };\n        // If we try to pop again, there should be nothing.\n        match stack.pop() {\n            None => ast,\n            Some(GroupState::Alternation(_)) => {\n                // This unreachable is unfortunate. This case can't happen\n                // because the only way we can be here is if there were two\n                // `GroupState::Alternation`s adjacent in the parser's stack,\n                // which we guarantee to never happen because we never push a\n                // `GroupState::Alternation` if one is already at the top of\n                // the stack.\n                unreachable!()\n            }\n            Some(GroupState::Group { group, .. }) => {\n                Err(self.error(group.span, ast::ErrorKind::GroupUnclosed))\n            }\n        }\n    }\n\n    /// Parse the opening of a character class and push the current class\n    /// parsing context onto the parser's stack. This assumes that the parser\n    /// is positioned at an opening `[`. The given union should correspond to\n    /// the union of set items built up before seeing the `[`.\n    ///\n    /// If there was a problem parsing the opening of the class, then an error\n    /// is returned. Otherwise, a new union of set items for the class is\n    /// returned (which may be populated with either a `]` or a `-`).\n    #[inline(never)]\n    fn push_class_open(\n        &self,\n        parent_union: ast::ClassSetUnion,\n    ) -> Result<ast::ClassSetUnion> {\n        assert_eq!(self.char(), '[');\n\n        let (nested_set, nested_union) = self.parse_set_class_open()?;\n        self.parser()\n            .stack_class\n            .borrow_mut()\n            .push(ClassState::Open { union: parent_union, set: nested_set });\n        Ok(nested_union)\n    }\n\n    /// Parse the end of a character class set and pop the character class\n    /// parser stack. The union given corresponds to the last union built\n    /// before seeing the closing `]`. The union returned corresponds to the\n    /// parent character class set with the nested class added to it.\n    ///\n    /// This assumes that the parser is positioned at a `]` and will advance\n    /// the parser to the byte immediately following the `]`.\n    ///\n    /// If the stack is empty after popping, then this returns the final\n    /// \"top-level\" character class AST (where a \"top-level\" character class\n    /// is one that is not nested inside any other character class).\n    ///\n    /// If there is no corresponding opening bracket on the parser's stack,\n    /// then an error is returned.\n    #[inline(never)]\n    fn pop_class(\n        &self,\n        nested_union: ast::ClassSetUnion,\n    ) -> Result<Either<ast::ClassSetUnion, ast::Class>> {\n        assert_eq!(self.char(), ']');\n\n        let item = ast::ClassSet::Item(nested_union.into_item());\n        let prevset = self.pop_class_op(item);\n        let mut stack = self.parser().stack_class.borrow_mut();\n        match stack.pop() {\n            None => {\n                // We can never observe an empty stack:\n                //\n                // 1) We are guaranteed to start with a non-empty stack since\n                //    the character class parser is only initiated when it sees\n                //    a `[`.\n                // 2) If we ever observe an empty stack while popping after\n                //    seeing a `]`, then we signal the character class parser\n                //    to terminate.\n                panic!(\"unexpected empty character class stack\")\n            }\n            Some(ClassState::Op { .. }) => {\n                // This panic is unfortunate, but this case is impossible\n                // since we already popped the Op state if one exists above.\n                // Namely, every push to the class parser stack is guarded by\n                // whether an existing Op is already on the top of the stack.\n                // If it is, the existing Op is modified. That is, the stack\n                // can never have consecutive Op states.\n                panic!(\"unexpected ClassState::Op\")\n            }\n            Some(ClassState::Open { mut union, mut set }) => {\n                self.bump();\n                set.span.end = self.pos();\n                set.kind = prevset;\n                if stack.is_empty() {\n                    Ok(Either::Right(ast::Class::Bracketed(set)))\n                } else {\n                    union.push(ast::ClassSetItem::Bracketed(Box::new(set)));\n                    Ok(Either::Left(union))\n                }\n            }\n        }\n    }\n\n    /// Return an \"unclosed class\" error whose span points to the most\n    /// recently opened class.\n    ///\n    /// This should only be called while parsing a character class.\n    #[inline(never)]\n    fn unclosed_class_error(&self) -> ast::Error {\n        for state in self.parser().stack_class.borrow().iter().rev() {\n            match *state {\n                ClassState::Open { ref set, .. } => {\n                    return self\n                        .error(set.span, ast::ErrorKind::ClassUnclosed);\n                }\n                _ => {}\n            }\n        }\n        // We are guaranteed to have a non-empty stack with at least\n        // one open bracket, so we should never get here.\n        panic!(\"no open character class found\")\n    }\n\n    /// Push the current set of class items on to the class parser's stack as\n    /// the left hand side of the given operator.\n    ///\n    /// A fresh set union is returned, which should be used to build the right\n    /// hand side of this operator.\n    #[inline(never)]\n    fn push_class_op(\n        &self,\n        next_kind: ast::ClassSetBinaryOpKind,\n        next_union: ast::ClassSetUnion,\n    ) -> ast::ClassSetUnion {\n        let item = ast::ClassSet::Item(next_union.into_item());\n        let new_lhs = self.pop_class_op(item);\n        self.parser()\n            .stack_class\n            .borrow_mut()\n            .push(ClassState::Op { kind: next_kind, lhs: new_lhs });\n        ast::ClassSetUnion { span: self.span(), items: vec![] }\n    }\n\n    /// Pop a character class set from the character class parser stack. If the\n    /// top of the stack is just an item (not an operation), then return the\n    /// given set unchanged. If the top of the stack is an operation, then the\n    /// given set will be used as the rhs of the operation on the top of the\n    /// stack. In that case, the binary operation is returned as a set.\n    #[inline(never)]\n    fn pop_class_op(&self, rhs: ast::ClassSet) -> ast::ClassSet {\n        let mut stack = self.parser().stack_class.borrow_mut();\n        let (kind, lhs) = match stack.pop() {\n            Some(ClassState::Op { kind, lhs }) => (kind, lhs),\n            Some(state @ ClassState::Open { .. }) => {\n                stack.push(state);\n                return rhs;\n            }\n            None => unreachable!(),\n        };\n        let span = Span::new(lhs.span().start, rhs.span().end);\n        ast::ClassSet::BinaryOp(ast::ClassSetBinaryOp {\n            span: span,\n            kind: kind,\n            lhs: Box::new(lhs),\n            rhs: Box::new(rhs),\n        })\n    }\n}\n\nimpl<'s, P: Borrow<Parser>> ParserI<'s, P> {\n    /// Parse the regular expression into an abstract syntax tree.\n    fn parse(&self) -> Result<Ast> {\n        self.parse_with_comments().map(|astc| astc.ast)\n    }\n\n    /// Parse the regular expression and return an abstract syntax tree with\n    /// all of the comments found in the pattern.\n    fn parse_with_comments(&self) -> Result<ast::WithComments> {\n        assert_eq!(self.offset(), 0, \"parser can only be used once\");\n        self.parser().reset();\n        let mut concat = ast::Concat { span: self.span(), asts: vec![] };\n        loop {\n            self.bump_space();\n            if self.is_eof() {\n                break;\n            }\n            match self.char() {\n                '(' => concat = self.push_group(concat)?,\n                ')' => concat = self.pop_group(concat)?,\n                '|' => concat = self.push_alternate(concat)?,\n                '[' => {\n                    let class = self.parse_set_class()?;\n                    concat.asts.push(Ast::Class(class));\n                }\n                '?' => {\n                    concat = self.parse_uncounted_repetition(\n                        concat,\n                        ast::RepetitionKind::ZeroOrOne,\n                    )?;\n                }\n                '*' => {\n                    concat = self.parse_uncounted_repetition(\n                        concat,\n                        ast::RepetitionKind::ZeroOrMore,\n                    )?;\n                }\n                '+' => {\n                    concat = self.parse_uncounted_repetition(\n                        concat,\n                        ast::RepetitionKind::OneOrMore,\n                    )?;\n                }\n                '{' => {\n                    concat = self.parse_counted_repetition(concat)?;\n                }\n                _ => concat.asts.push(self.parse_primitive()?.into_ast()),\n            }\n        }\n        let ast = self.pop_group_end(concat)?;\n        NestLimiter::new(self).check(&ast)?;\n        Ok(ast::WithComments {\n            ast: ast,\n            comments: mem::replace(\n                &mut *self.parser().comments.borrow_mut(),\n                vec![],\n            ),\n        })\n    }\n\n    /// Parses an uncounted repetition operation. An uncounted repetition\n    /// operator includes ?, * and +, but does not include the {m,n} syntax.\n    /// The given `kind` should correspond to the operator observed by the\n    /// caller.\n    ///\n    /// This assumes that the paser is currently positioned at the repetition\n    /// operator and advances the parser to the first character after the\n    /// operator. (Note that the operator may include a single additional `?`,\n    /// which makes the operator ungreedy.)\n    ///\n    /// The caller should include the concatenation that is being built. The\n    /// concatenation returned includes the repetition operator applied to the\n    /// last expression in the given concatenation.\n    #[inline(never)]\n    fn parse_uncounted_repetition(\n        &self,\n        mut concat: ast::Concat,\n        kind: ast::RepetitionKind,\n    ) -> Result<ast::Concat> {\n        assert!(\n            self.char() == '?' || self.char() == '*' || self.char() == '+'\n        );\n        let op_start = self.pos();\n        let ast = match concat.asts.pop() {\n            Some(ast) => ast,\n            None => {\n                return Err(\n                    self.error(self.span(), ast::ErrorKind::RepetitionMissing)\n                )\n            }\n        };\n        match ast {\n            Ast::Empty(_) | Ast::Flags(_) => {\n                return Err(\n                    self.error(self.span(), ast::ErrorKind::RepetitionMissing)\n                )\n            }\n            _ => {}\n        }\n        let mut greedy = true;\n        if self.bump() && self.char() == '?' {\n            greedy = false;\n            self.bump();\n        }\n        concat.asts.push(Ast::Repetition(ast::Repetition {\n            span: ast.span().with_end(self.pos()),\n            op: ast::RepetitionOp {\n                span: Span::new(op_start, self.pos()),\n                kind: kind,\n            },\n            greedy: greedy,\n            ast: Box::new(ast),\n        }));\n        Ok(concat)\n    }\n\n    /// Parses a counted repetition operation. A counted repetition operator\n    /// corresponds to the {m,n} syntax, and does not include the ?, * or +\n    /// operators.\n    ///\n    /// This assumes that the paser is currently positioned at the opening `{`\n    /// and advances the parser to the first character after the operator.\n    /// (Note that the operator may include a single additional `?`, which\n    /// makes the operator ungreedy.)\n    ///\n    /// The caller should include the concatenation that is being built. The\n    /// concatenation returned includes the repetition operator applied to the\n    /// last expression in the given concatenation.\n    #[inline(never)]\n    fn parse_counted_repetition(\n        &self,\n        mut concat: ast::Concat,\n    ) -> Result<ast::Concat> {\n        assert!(self.char() == '{');\n        let start = self.pos();\n        let ast = match concat.asts.pop() {\n            Some(ast) => ast,\n            None => {\n                return Err(\n                    self.error(self.span(), ast::ErrorKind::RepetitionMissing)\n                )\n            }\n        };\n        match ast {\n            Ast::Empty(_) | Ast::Flags(_) => {\n                return Err(\n                    self.error(self.span(), ast::ErrorKind::RepetitionMissing)\n                )\n            }\n            _ => {}\n        }\n        if !self.bump_and_bump_space() {\n            return Err(self.error(\n                Span::new(start, self.pos()),\n                ast::ErrorKind::RepetitionCountUnclosed,\n            ));\n        }\n        let count_start = specialize_err(\n            self.parse_decimal(),\n            ast::ErrorKind::DecimalEmpty,\n            ast::ErrorKind::RepetitionCountDecimalEmpty,\n        )?;\n        let mut range = ast::RepetitionRange::Exactly(count_start);\n        if self.is_eof() {\n            return Err(self.error(\n                Span::new(start, self.pos()),\n                ast::ErrorKind::RepetitionCountUnclosed,\n            ));\n        }\n        if self.char() == ',' {\n            if !self.bump_and_bump_space() {\n                return Err(self.error(\n                    Span::new(start, self.pos()),\n                    ast::ErrorKind::RepetitionCountUnclosed,\n                ));\n            }\n            if self.char() != '}' {\n                let count_end = specialize_err(\n                    self.parse_decimal(),\n                    ast::ErrorKind::DecimalEmpty,\n                    ast::ErrorKind::RepetitionCountDecimalEmpty,\n                )?;\n                range = ast::RepetitionRange::Bounded(count_start, count_end);\n            } else {\n                range = ast::RepetitionRange::AtLeast(count_start);\n            }\n        }\n        if self.is_eof() || self.char() != '}' {\n            return Err(self.error(\n                Span::new(start, self.pos()),\n                ast::ErrorKind::RepetitionCountUnclosed,\n            ));\n        }\n\n        let mut greedy = true;\n        if self.bump_and_bump_space() && self.char() == '?' {\n            greedy = false;\n            self.bump();\n        }\n\n        let op_span = Span::new(start, self.pos());\n        if !range.is_valid() {\n            return Err(\n                self.error(op_span, ast::ErrorKind::RepetitionCountInvalid)\n            );\n        }\n        concat.asts.push(Ast::Repetition(ast::Repetition {\n            span: ast.span().with_end(self.pos()),\n            op: ast::RepetitionOp {\n                span: op_span,\n                kind: ast::RepetitionKind::Range(range),\n            },\n            greedy: greedy,\n            ast: Box::new(ast),\n        }));\n        Ok(concat)\n    }\n\n    /// Parse a group (which contains a sub-expression) or a set of flags.\n    ///\n    /// If a group was found, then it is returned with an empty AST. If a set\n    /// of flags is found, then that set is returned.\n    ///\n    /// The parser should be positioned at the opening parenthesis.\n    ///\n    /// This advances the parser to the character before the start of the\n    /// sub-expression (in the case of a group) or to the closing parenthesis\n    /// immediately following the set of flags.\n    ///\n    /// # Errors\n    ///\n    /// If flags are given and incorrectly specified, then a corresponding\n    /// error is returned.\n    ///\n    /// If a capture name is given and it is incorrectly specified, then a\n    /// corresponding error is returned.\n    #[inline(never)]\n    fn parse_group(&self) -> Result<Either<ast::SetFlags, ast::Group>> {\n        assert_eq!(self.char(), '(');\n        let open_span = self.span_char();\n        self.bump();\n        self.bump_space();\n        if self.is_lookaround_prefix() {\n            return Err(self.error(\n                Span::new(open_span.start, self.span().end),\n                ast::ErrorKind::UnsupportedLookAround,\n            ));\n        }\n        let inner_span = self.span();\n        if self.bump_if(\"?P<\") {\n            let capture_index = self.next_capture_index(open_span)?;\n            let cap = self.parse_capture_name(capture_index)?;\n            Ok(Either::Right(ast::Group {\n                span: open_span,\n                kind: ast::GroupKind::CaptureName(cap),\n                ast: Box::new(Ast::Empty(self.span())),\n            }))\n        } else if self.bump_if(\"?\") {\n            if self.is_eof() {\n                return Err(\n                    self.error(open_span, ast::ErrorKind::GroupUnclosed)\n                );\n            }\n            let flags = self.parse_flags()?;\n            let char_end = self.char();\n            self.bump();\n            if char_end == ')' {\n                // We don't allow empty flags, e.g., `(?)`. We instead\n                // interpret it as a repetition operator missing its argument.\n                if flags.items.is_empty() {\n                    return Err(self.error(\n                        inner_span,\n                        ast::ErrorKind::RepetitionMissing,\n                    ));\n                }\n                Ok(Either::Left(ast::SetFlags {\n                    span: Span { end: self.pos(), ..open_span },\n                    flags: flags,\n                }))\n            } else {\n                assert_eq!(char_end, ':');\n                Ok(Either::Right(ast::Group {\n                    span: open_span,\n                    kind: ast::GroupKind::NonCapturing(flags),\n                    ast: Box::new(Ast::Empty(self.span())),\n                }))\n            }\n        } else {\n            let capture_index = self.next_capture_index(open_span)?;\n            Ok(Either::Right(ast::Group {\n                span: open_span,\n                kind: ast::GroupKind::CaptureIndex(capture_index),\n                ast: Box::new(Ast::Empty(self.span())),\n            }))\n        }\n    }\n\n    /// Parses a capture group name. Assumes that the parser is positioned at\n    /// the first character in the name following the opening `<` (and may\n    /// possibly be EOF). This advances the parser to the first character\n    /// following the closing `>`.\n    ///\n    /// The caller must provide the capture index of the group for this name.\n    #[inline(never)]\n    fn parse_capture_name(\n        &self,\n        capture_index: u32,\n    ) -> Result<ast::CaptureName> {\n        if self.is_eof() {\n            return Err(self\n                .error(self.span(), ast::ErrorKind::GroupNameUnexpectedEof));\n        }\n        let start = self.pos();\n        loop {\n            if self.char() == '>' {\n                break;\n            }\n            if !is_capture_char(self.char(), self.pos() == start) {\n                return Err(self.error(\n                    self.span_char(),\n                    ast::ErrorKind::GroupNameInvalid,\n                ));\n            }\n            if !self.bump() {\n                break;\n            }\n        }\n        let end = self.pos();\n        if self.is_eof() {\n            return Err(self\n                .error(self.span(), ast::ErrorKind::GroupNameUnexpectedEof));\n        }\n        assert_eq!(self.char(), '>');\n        self.bump();\n        let name = &self.pattern()[start.offset..end.offset];\n        if name.is_empty() {\n            return Err(self.error(\n                Span::new(start, start),\n                ast::ErrorKind::GroupNameEmpty,\n            ));\n        }\n        let capname = ast::CaptureName {\n            span: Span::new(start, end),\n            name: name.to_string(),\n            index: capture_index,\n        };\n        self.add_capture_name(&capname)?;\n        Ok(capname)\n    }\n\n    /// Parse a sequence of flags starting at the current character.\n    ///\n    /// This advances the parser to the character immediately following the\n    /// flags, which is guaranteed to be either `:` or `)`.\n    ///\n    /// # Errors\n    ///\n    /// If any flags are duplicated, then an error is returned.\n    ///\n    /// If the negation operator is used more than once, then an error is\n    /// returned.\n    ///\n    /// If no flags could be found or if the negation operation is not followed\n    /// by any flags, then an error is returned.\n    #[inline(never)]\n    fn parse_flags(&self) -> Result<ast::Flags> {\n        let mut flags = ast::Flags { span: self.span(), items: vec![] };\n        let mut last_was_negation = None;\n        while self.char() != ':' && self.char() != ')' {\n            if self.char() == '-' {\n                last_was_negation = Some(self.span_char());\n                let item = ast::FlagsItem {\n                    span: self.span_char(),\n                    kind: ast::FlagsItemKind::Negation,\n                };\n                if let Some(i) = flags.add_item(item) {\n                    return Err(self.error(\n                        self.span_char(),\n                        ast::ErrorKind::FlagRepeatedNegation {\n                            original: flags.items[i].span,\n                        },\n                    ));\n                }\n            } else {\n                last_was_negation = None;\n                let item = ast::FlagsItem {\n                    span: self.span_char(),\n                    kind: ast::FlagsItemKind::Flag(self.parse_flag()?),\n                };\n                if let Some(i) = flags.add_item(item) {\n                    return Err(self.error(\n                        self.span_char(),\n                        ast::ErrorKind::FlagDuplicate {\n                            original: flags.items[i].span,\n                        },\n                    ));\n                }\n            }\n            if !self.bump() {\n                return Err(\n                    self.error(self.span(), ast::ErrorKind::FlagUnexpectedEof)\n                );\n            }\n        }\n        if let Some(span) = last_was_negation {\n            return Err(self.error(span, ast::ErrorKind::FlagDanglingNegation));\n        }\n        flags.span.end = self.pos();\n        Ok(flags)\n    }\n\n    /// Parse the current character as a flag. Do not advance the parser.\n    ///\n    /// # Errors\n    ///\n    /// If the flag is not recognized, then an error is returned.\n    #[inline(never)]\n    fn parse_flag(&self) -> Result<ast::Flag> {\n        match self.char() {\n            'i' => Ok(ast::Flag::CaseInsensitive),\n            'm' => Ok(ast::Flag::MultiLine),\n            's' => Ok(ast::Flag::DotMatchesNewLine),\n            'U' => Ok(ast::Flag::SwapGreed),\n            'u' => Ok(ast::Flag::Unicode),\n            'x' => Ok(ast::Flag::IgnoreWhitespace),\n            _ => {\n                Err(self\n                    .error(self.span_char(), ast::ErrorKind::FlagUnrecognized))\n            }\n        }\n    }\n\n    /// Parse a primitive AST. e.g., A literal, non-set character class or\n    /// assertion.\n    ///\n    /// This assumes that the parser expects a primitive at the current\n    /// location. i.e., All other non-primitive cases have been handled.\n    /// For example, if the parser's position is at `|`, then `|` will be\n    /// treated as a literal (e.g., inside a character class).\n    ///\n    /// This advances the parser to the first character immediately following\n    /// the primitive.\n    fn parse_primitive(&self) -> Result<Primitive> {\n        match self.char() {\n            '\\\\' => self.parse_escape(),\n            '.' => {\n                let ast = Primitive::Dot(self.span_char());\n                self.bump();\n                Ok(ast)\n            }\n            '^' => {\n                let ast = Primitive::Assertion(ast::Assertion {\n                    span: self.span_char(),\n                    kind: ast::AssertionKind::StartLine,\n                });\n                self.bump();\n                Ok(ast)\n            }\n            '$' => {\n                let ast = Primitive::Assertion(ast::Assertion {\n                    span: self.span_char(),\n                    kind: ast::AssertionKind::EndLine,\n                });\n                self.bump();\n                Ok(ast)\n            }\n            c => {\n                let ast = Primitive::Literal(ast::Literal {\n                    span: self.span_char(),\n                    kind: ast::LiteralKind::Verbatim,\n                    c: c,\n                });\n                self.bump();\n                Ok(ast)\n            }\n        }\n    }\n\n    /// Parse an escape sequence as a primitive AST.\n    ///\n    /// This assumes the parser is positioned at the start of the escape\n    /// sequence, i.e., `\\`. It advances the parser to the first position\n    /// immediately following the escape sequence.\n    #[inline(never)]\n    fn parse_escape(&self) -> Result<Primitive> {\n        assert_eq!(self.char(), '\\\\');\n        let start = self.pos();\n        if !self.bump() {\n            return Err(self.error(\n                Span::new(start, self.pos()),\n                ast::ErrorKind::EscapeUnexpectedEof,\n            ));\n        }\n        let c = self.char();\n        // Put some of the more complicated routines into helpers.\n        match c {\n            '0'..='7' => {\n                if !self.parser().octal {\n                    return Err(self.error(\n                        Span::new(start, self.span_char().end),\n                        ast::ErrorKind::UnsupportedBackreference,\n                    ));\n                }\n                let mut lit = self.parse_octal();\n                lit.span.start = start;\n                return Ok(Primitive::Literal(lit));\n            }\n            '8'..='9' if !self.parser().octal => {\n                return Err(self.error(\n                    Span::new(start, self.span_char().end),\n                    ast::ErrorKind::UnsupportedBackreference,\n                ));\n            }\n            'x' | 'u' | 'U' => {\n                let mut lit = self.parse_hex()?;\n                lit.span.start = start;\n                return Ok(Primitive::Literal(lit));\n            }\n            'p' | 'P' => {\n                let mut cls = self.parse_unicode_class()?;\n                cls.span.start = start;\n                return Ok(Primitive::Unicode(cls));\n            }\n            'd' | 's' | 'w' | 'D' | 'S' | 'W' => {\n                let mut cls = self.parse_perl_class();\n                cls.span.start = start;\n                return Ok(Primitive::Perl(cls));\n            }\n            _ => {}\n        }\n\n        // Handle all of the one letter sequences inline.\n        self.bump();\n        let span = Span::new(start, self.pos());\n        if is_meta_character(c) {\n            return Ok(Primitive::Literal(ast::Literal {\n                span: span,\n                kind: ast::LiteralKind::Punctuation,\n                c: c,\n            }));\n        }\n        let special = |kind, c| {\n            Ok(Primitive::Literal(ast::Literal {\n                span: span,\n                kind: ast::LiteralKind::Special(kind),\n                c: c,\n            }))\n        };\n        match c {\n            'a' => special(ast::SpecialLiteralKind::Bell, '\\x07'),\n            'f' => special(ast::SpecialLiteralKind::FormFeed, '\\x0C'),\n            't' => special(ast::SpecialLiteralKind::Tab, '\\t'),\n            'n' => special(ast::SpecialLiteralKind::LineFeed, '\\n'),\n            'r' => special(ast::SpecialLiteralKind::CarriageReturn, '\\r'),\n            'v' => special(ast::SpecialLiteralKind::VerticalTab, '\\x0B'),\n            ' ' if self.ignore_whitespace() => {\n                special(ast::SpecialLiteralKind::Space, ' ')\n            }\n            'A' => Ok(Primitive::Assertion(ast::Assertion {\n                span: span,\n                kind: ast::AssertionKind::StartText,\n            })),\n            'z' => Ok(Primitive::Assertion(ast::Assertion {\n                span: span,\n                kind: ast::AssertionKind::EndText,\n            })),\n            'b' => Ok(Primitive::Assertion(ast::Assertion {\n                span: span,\n                kind: ast::AssertionKind::WordBoundary,\n            })),\n            'B' => Ok(Primitive::Assertion(ast::Assertion {\n                span: span,\n                kind: ast::AssertionKind::NotWordBoundary,\n            })),\n            _ => Err(self.error(span, ast::ErrorKind::EscapeUnrecognized)),\n        }\n    }\n\n    /// Parse an octal representation of a Unicode codepoint up to 3 digits\n    /// long. This expects the parser to be positioned at the first octal\n    /// digit and advances the parser to the first character immediately\n    /// following the octal number. This also assumes that parsing octal\n    /// escapes is enabled.\n    ///\n    /// Assuming the preconditions are met, this routine can never fail.\n    #[inline(never)]\n    fn parse_octal(&self) -> ast::Literal {\n        use std::char;\n        use std::u32;\n\n        assert!(self.parser().octal);\n        assert!('0' <= self.char() && self.char() <= '7');\n        let start = self.pos();\n        // Parse up to two more digits.\n        while self.bump()\n            && '0' <= self.char()\n            && self.char() <= '7'\n            && self.pos().offset - start.offset <= 2\n        {}\n        let end = self.pos();\n        let octal = &self.pattern()[start.offset..end.offset];\n        // Parsing the octal should never fail since the above guarantees a\n        // valid number.\n        let codepoint =\n            u32::from_str_radix(octal, 8).expect(\"valid octal number\");\n        // The max value for 3 digit octal is 0777 = 511 and [0, 511] has no\n        // invalid Unicode scalar values.\n        let c = char::from_u32(codepoint).expect(\"Unicode scalar value\");\n        ast::Literal {\n            span: Span::new(start, end),\n            kind: ast::LiteralKind::Octal,\n            c: c,\n        }\n    }\n\n    /// Parse a hex representation of a Unicode codepoint. This handles both\n    /// hex notations, i.e., `\\xFF` and `\\x{FFFF}`. This expects the parser to\n    /// be positioned at the `x`, `u` or `U` prefix. The parser is advanced to\n    /// the first character immediately following the hexadecimal literal.\n    #[inline(never)]\n    fn parse_hex(&self) -> Result<ast::Literal> {\n        assert!(\n            self.char() == 'x' || self.char() == 'u' || self.char() == 'U'\n        );\n\n        let hex_kind = match self.char() {\n            'x' => ast::HexLiteralKind::X,\n            'u' => ast::HexLiteralKind::UnicodeShort,\n            _ => ast::HexLiteralKind::UnicodeLong,\n        };\n        if !self.bump_and_bump_space() {\n            return Err(\n                self.error(self.span(), ast::ErrorKind::EscapeUnexpectedEof)\n            );\n        }\n        if self.char() == '{' {\n            self.parse_hex_brace(hex_kind)\n        } else {\n            self.parse_hex_digits(hex_kind)\n        }\n    }\n\n    /// Parse an N-digit hex representation of a Unicode codepoint. This\n    /// expects the parser to be positioned at the first digit and will advance\n    /// the parser to the first character immediately following the escape\n    /// sequence.\n    ///\n    /// The number of digits given must be 2 (for `\\xNN`), 4 (for `\\uNNNN`)\n    /// or 8 (for `\\UNNNNNNNN`).\n    #[inline(never)]\n    fn parse_hex_digits(\n        &self,\n        kind: ast::HexLiteralKind,\n    ) -> Result<ast::Literal> {\n        use std::char;\n        use std::u32;\n\n        let mut scratch = self.parser().scratch.borrow_mut();\n        scratch.clear();\n\n        let start = self.pos();\n        for i in 0..kind.digits() {\n            if i > 0 && !self.bump_and_bump_space() {\n                return Err(self\n                    .error(self.span(), ast::ErrorKind::EscapeUnexpectedEof));\n            }\n            if !is_hex(self.char()) {\n                return Err(self.error(\n                    self.span_char(),\n                    ast::ErrorKind::EscapeHexInvalidDigit,\n                ));\n            }\n            scratch.push(self.char());\n        }\n        // The final bump just moves the parser past the literal, which may\n        // be EOF.\n        self.bump_and_bump_space();\n        let end = self.pos();\n        let hex = scratch.as_str();\n        match u32::from_str_radix(hex, 16).ok().and_then(char::from_u32) {\n            None => Err(self.error(\n                Span::new(start, end),\n                ast::ErrorKind::EscapeHexInvalid,\n            )),\n            Some(c) => Ok(ast::Literal {\n                span: Span::new(start, end),\n                kind: ast::LiteralKind::HexFixed(kind),\n                c: c,\n            }),\n        }\n    }\n\n    /// Parse a hex representation of any Unicode scalar value. This expects\n    /// the parser to be positioned at the opening brace `{` and will advance\n    /// the parser to the first character following the closing brace `}`.\n    #[inline(never)]\n    fn parse_hex_brace(\n        &self,\n        kind: ast::HexLiteralKind,\n    ) -> Result<ast::Literal> {\n        use std::char;\n        use std::u32;\n\n        let mut scratch = self.parser().scratch.borrow_mut();\n        scratch.clear();\n\n        let brace_pos = self.pos();\n        let start = self.span_char().end;\n        while self.bump_and_bump_space() && self.char() != '}' {\n            if !is_hex(self.char()) {\n                return Err(self.error(\n                    self.span_char(),\n                    ast::ErrorKind::EscapeHexInvalidDigit,\n                ));\n            }\n            scratch.push(self.char());\n        }\n        if self.is_eof() {\n            return Err(self.error(\n                Span::new(brace_pos, self.pos()),\n                ast::ErrorKind::EscapeUnexpectedEof,\n            ));\n        }\n        let end = self.pos();\n        let hex = scratch.as_str();\n        assert_eq!(self.char(), '}');\n        self.bump_and_bump_space();\n\n        if hex.is_empty() {\n            return Err(self.error(\n                Span::new(brace_pos, self.pos()),\n                ast::ErrorKind::EscapeHexEmpty,\n            ));\n        }\n        match u32::from_str_radix(hex, 16).ok().and_then(char::from_u32) {\n            None => Err(self.error(\n                Span::new(start, end),\n                ast::ErrorKind::EscapeHexInvalid,\n            )),\n            Some(c) => Ok(ast::Literal {\n                span: Span::new(start, self.pos()),\n                kind: ast::LiteralKind::HexBrace(kind),\n                c: c,\n            }),\n        }\n    }\n\n    /// Parse a decimal number into a u32 while trimming leading and trailing\n    /// whitespace.\n    ///\n    /// This expects the parser to be positioned at the first position where\n    /// a decimal digit could occur. This will advance the parser to the byte\n    /// immediately following the last contiguous decimal digit.\n    ///\n    /// If no decimal digit could be found or if there was a problem parsing\n    /// the complete set of digits into a u32, then an error is returned.\n    fn parse_decimal(&self) -> Result<u32> {\n        let mut scratch = self.parser().scratch.borrow_mut();\n        scratch.clear();\n\n        while !self.is_eof() && self.char().is_whitespace() {\n            self.bump();\n        }\n        let start = self.pos();\n        while !self.is_eof() && '0' <= self.char() && self.char() <= '9' {\n            scratch.push(self.char());\n            self.bump_and_bump_space();\n        }\n        let span = Span::new(start, self.pos());\n        while !self.is_eof() && self.char().is_whitespace() {\n            self.bump_and_bump_space();\n        }\n        let digits = scratch.as_str();\n        if digits.is_empty() {\n            return Err(self.error(span, ast::ErrorKind::DecimalEmpty));\n        }\n        match u32::from_str_radix(digits, 10).ok() {\n            Some(n) => Ok(n),\n            None => Err(self.error(span, ast::ErrorKind::DecimalInvalid)),\n        }\n    }\n\n    /// Parse a standard character class consisting primarily of characters or\n    /// character ranges, but can also contain nested character classes of\n    /// any type (sans `.`).\n    ///\n    /// This assumes the parser is positioned at the opening `[`. If parsing\n    /// is successful, then the parser is advanced to the position immediately\n    /// following the closing `]`.\n    #[inline(never)]\n    fn parse_set_class(&self) -> Result<ast::Class> {\n        assert_eq!(self.char(), '[');\n\n        let mut union =\n            ast::ClassSetUnion { span: self.span(), items: vec![] };\n        loop {\n            self.bump_space();\n            if self.is_eof() {\n                return Err(self.unclosed_class_error());\n            }\n            match self.char() {\n                '[' => {\n                    // If we've already parsed the opening bracket, then\n                    // attempt to treat this as the beginning of an ASCII\n                    // class. If ASCII class parsing fails, then the parser\n                    // backs up to `[`.\n                    if !self.parser().stack_class.borrow().is_empty() {\n                        if let Some(cls) = self.maybe_parse_ascii_class() {\n                            union.push(ast::ClassSetItem::Ascii(cls));\n                            continue;\n                        }\n                    }\n                    union = self.push_class_open(union)?;\n                }\n                ']' => match self.pop_class(union)? {\n                    Either::Left(nested_union) => {\n                        union = nested_union;\n                    }\n                    Either::Right(class) => return Ok(class),\n                },\n                '&' if self.peek() == Some('&') => {\n                    assert!(self.bump_if(\"&&\"));\n                    union = self.push_class_op(\n                        ast::ClassSetBinaryOpKind::Intersection,\n                        union,\n                    );\n                }\n                '-' if self.peek() == Some('-') => {\n                    assert!(self.bump_if(\"--\"));\n                    union = self.push_class_op(\n                        ast::ClassSetBinaryOpKind::Difference,\n                        union,\n                    );\n                }\n                '~' if self.peek() == Some('~') => {\n                    assert!(self.bump_if(\"~~\"));\n                    union = self.push_class_op(\n                        ast::ClassSetBinaryOpKind::SymmetricDifference,\n                        union,\n                    );\n                }\n                _ => {\n                    union.push(self.parse_set_class_range()?);\n                }\n            }\n        }\n    }\n\n    /// Parse a single primitive item in a character class set. The item to\n    /// be parsed can either be one of a simple literal character, a range\n    /// between two simple literal characters or a \"primitive\" character\n    /// class like \\w or \\p{Greek}.\n    ///\n    /// If an invalid escape is found, or if a character class is found where\n    /// a simple literal is expected (e.g., in a range), then an error is\n    /// returned.\n    #[inline(never)]\n    fn parse_set_class_range(&self) -> Result<ast::ClassSetItem> {\n        let prim1 = self.parse_set_class_item()?;\n        self.bump_space();\n        if self.is_eof() {\n            return Err(self.unclosed_class_error());\n        }\n        // If the next char isn't a `-`, then we don't have a range.\n        // There are two exceptions. If the char after a `-` is a `]`, then\n        // `-` is interpreted as a literal `-`. Alternatively, if the char\n        // after a `-` is a `-`, then `--` corresponds to a \"difference\"\n        // operation.\n        if self.char() != '-'\n            || self.peek_space() == Some(']')\n            || self.peek_space() == Some('-')\n        {\n            return prim1.into_class_set_item(self);\n        }\n        // OK, now we're parsing a range, so bump past the `-` and parse the\n        // second half of the range.\n        if !self.bump_and_bump_space() {\n            return Err(self.unclosed_class_error());\n        }\n        let prim2 = self.parse_set_class_item()?;\n        let range = ast::ClassSetRange {\n            span: Span::new(prim1.span().start, prim2.span().end),\n            start: prim1.into_class_literal(self)?,\n            end: prim2.into_class_literal(self)?,\n        };\n        if !range.is_valid() {\n            return Err(\n                self.error(range.span, ast::ErrorKind::ClassRangeInvalid)\n            );\n        }\n        Ok(ast::ClassSetItem::Range(range))\n    }\n\n    /// Parse a single item in a character class as a primitive, where the\n    /// primitive either consists of a verbatim literal or a single escape\n    /// sequence.\n    ///\n    /// This assumes the parser is positioned at the beginning of a primitive,\n    /// and advances the parser to the first position after the primitive if\n    /// successful.\n    ///\n    /// Note that it is the caller's responsibility to report an error if an\n    /// illegal primitive was parsed.\n    #[inline(never)]\n    fn parse_set_class_item(&self) -> Result<Primitive> {\n        if self.char() == '\\\\' {\n            self.parse_escape()\n        } else {\n            let x = Primitive::Literal(ast::Literal {\n                span: self.span_char(),\n                kind: ast::LiteralKind::Verbatim,\n                c: self.char(),\n            });\n            self.bump();\n            Ok(x)\n        }\n    }\n\n    /// Parses the opening of a character class set. This includes the opening\n    /// bracket along with `^` if present to indicate negation. This also\n    /// starts parsing the opening set of unioned items if applicable, since\n    /// there are special rules applied to certain characters in the opening\n    /// of a character class. For example, `[^]]` is the class of all\n    /// characters not equal to `]`. (`]` would need to be escaped in any other\n    /// position.) Similarly for `-`.\n    ///\n    /// In all cases, the op inside the returned `ast::ClassBracketed` is an\n    /// empty union. This empty union should be replaced with the actual item\n    /// when it is popped from the parser's stack.\n    ///\n    /// This assumes the parser is positioned at the opening `[` and advances\n    /// the parser to the first non-special byte of the character class.\n    ///\n    /// An error is returned if EOF is found.\n    #[inline(never)]\n    fn parse_set_class_open(\n        &self,\n    ) -> Result<(ast::ClassBracketed, ast::ClassSetUnion)> {\n        assert_eq!(self.char(), '[');\n        let start = self.pos();\n        if !self.bump_and_bump_space() {\n            return Err(self.error(\n                Span::new(start, self.pos()),\n                ast::ErrorKind::ClassUnclosed,\n            ));\n        }\n\n        let negated = if self.char() != '^' {\n            false\n        } else {\n            if !self.bump_and_bump_space() {\n                return Err(self.error(\n                    Span::new(start, self.pos()),\n                    ast::ErrorKind::ClassUnclosed,\n                ));\n            }\n            true\n        };\n        // Accept any number of `-` as literal `-`.\n        let mut union =\n            ast::ClassSetUnion { span: self.span(), items: vec![] };\n        while self.char() == '-' {\n            union.push(ast::ClassSetItem::Literal(ast::Literal {\n                span: self.span_char(),\n                kind: ast::LiteralKind::Verbatim,\n                c: '-',\n            }));\n            if !self.bump_and_bump_space() {\n                return Err(self.error(\n                    Span::new(start, self.pos()),\n                    ast::ErrorKind::ClassUnclosed,\n                ));\n            }\n        }\n        // If `]` is the *first* char in a set, then interpret it as a literal\n        // `]`. That is, an empty class is impossible to write.\n        if union.items.is_empty() && self.char() == ']' {\n            union.push(ast::ClassSetItem::Literal(ast::Literal {\n                span: self.span_char(),\n                kind: ast::LiteralKind::Verbatim,\n                c: ']',\n            }));\n            if !self.bump_and_bump_space() {\n                return Err(self.error(\n                    Span::new(start, self.pos()),\n                    ast::ErrorKind::ClassUnclosed,\n                ));\n            }\n        }\n        let set = ast::ClassBracketed {\n            span: Span::new(start, self.pos()),\n            negated: negated,\n            kind: ast::ClassSet::union(ast::ClassSetUnion {\n                span: Span::new(union.span.start, union.span.start),\n                items: vec![],\n            }),\n        };\n        Ok((set, union))\n    }\n\n    /// Attempt to parse an ASCII character class, e.g., `[:alnum:]`.\n    ///\n    /// This assumes the parser is positioned at the opening `[`.\n    ///\n    /// If no valid ASCII character class could be found, then this does not\n    /// advance the parser and `None` is returned. Otherwise, the parser is\n    /// advanced to the first byte following the closing `]` and the\n    /// corresponding ASCII class is returned.\n    #[inline(never)]\n    fn maybe_parse_ascii_class(&self) -> Option<ast::ClassAscii> {\n        // ASCII character classes are interesting from a parsing perspective\n        // because parsing cannot fail with any interesting error. For example,\n        // in order to use an ASCII character class, it must be enclosed in\n        // double brackets, e.g., `[[:alnum:]]`. Alternatively, you might think\n        // of it as \"ASCII character characters have the syntax `[:NAME:]`\n        // which can only appear within character brackets.\" This means that\n        // things like `[[:lower:]A]` are legal constructs.\n        //\n        // However, if one types an incorrect ASCII character class, e.g.,\n        // `[[:loower:]]`, then we treat that as a normal nested character\n        // class containing the characters `:elorw`. One might argue that we\n        // should return an error instead since the repeated colons give away\n        // the intent to write an ASCII class. But what if the user typed\n        // `[[:lower]]` instead? How can we tell that was intended to be an\n        // ASCII class and not just a normal nested class?\n        //\n        // Reasonable people can probably disagree over this, but for better\n        // or worse, we implement semantics that never fails at the expense\n        // of better failure modes.\n        assert_eq!(self.char(), '[');\n        // If parsing fails, then we back up the parser to this starting point.\n        let start = self.pos();\n        let mut negated = false;\n        if !self.bump() || self.char() != ':' {\n            self.parser().pos.set(start);\n            return None;\n        }\n        if !self.bump() {\n            self.parser().pos.set(start);\n            return None;\n        }\n        if self.char() == '^' {\n            negated = true;\n            if !self.bump() {\n                self.parser().pos.set(start);\n                return None;\n            }\n        }\n        let name_start = self.offset();\n        while self.char() != ':' && self.bump() {}\n        if self.is_eof() {\n            self.parser().pos.set(start);\n            return None;\n        }\n        let name = &self.pattern()[name_start..self.offset()];\n        if !self.bump_if(\":]\") {\n            self.parser().pos.set(start);\n            return None;\n        }\n        let kind = match ast::ClassAsciiKind::from_name(name) {\n            Some(kind) => kind,\n            None => {\n                self.parser().pos.set(start);\n                return None;\n            }\n        };\n        Some(ast::ClassAscii {\n            span: Span::new(start, self.pos()),\n            kind: kind,\n            negated: negated,\n        })\n    }\n\n    /// Parse a Unicode class in either the single character notation, `\\pN`\n    /// or the multi-character bracketed notation, `\\p{Greek}`. This assumes\n    /// the parser is positioned at the `p` (or `P` for negation) and will\n    /// advance the parser to the character immediately following the class.\n    ///\n    /// Note that this does not check whether the class name is valid or not.\n    #[inline(never)]\n    fn parse_unicode_class(&self) -> Result<ast::ClassUnicode> {\n        assert!(self.char() == 'p' || self.char() == 'P');\n\n        let mut scratch = self.parser().scratch.borrow_mut();\n        scratch.clear();\n\n        let negated = self.char() == 'P';\n        if !self.bump_and_bump_space() {\n            return Err(\n                self.error(self.span(), ast::ErrorKind::EscapeUnexpectedEof)\n            );\n        }\n        let (start, kind) = if self.char() == '{' {\n            let start = self.span_char().end;\n            while self.bump_and_bump_space() && self.char() != '}' {\n                scratch.push(self.char());\n            }\n            if self.is_eof() {\n                return Err(self\n                    .error(self.span(), ast::ErrorKind::EscapeUnexpectedEof));\n            }\n            assert_eq!(self.char(), '}');\n            self.bump();\n\n            let name = scratch.as_str();\n            if let Some(i) = name.find(\"!=\") {\n                (\n                    start,\n                    ast::ClassUnicodeKind::NamedValue {\n                        op: ast::ClassUnicodeOpKind::NotEqual,\n                        name: name[..i].to_string(),\n                        value: name[i + 2..].to_string(),\n                    },\n                )\n            } else if let Some(i) = name.find(':') {\n                (\n                    start,\n                    ast::ClassUnicodeKind::NamedValue {\n                        op: ast::ClassUnicodeOpKind::Colon,\n                        name: name[..i].to_string(),\n                        value: name[i + 1..].to_string(),\n                    },\n                )\n            } else if let Some(i) = name.find('=') {\n                (\n                    start,\n                    ast::ClassUnicodeKind::NamedValue {\n                        op: ast::ClassUnicodeOpKind::Equal,\n                        name: name[..i].to_string(),\n                        value: name[i + 1..].to_string(),\n                    },\n                )\n            } else {\n                (start, ast::ClassUnicodeKind::Named(name.to_string()))\n            }\n        } else {\n            let start = self.pos();\n            let c = self.char();\n            if c == '\\\\' {\n                return Err(self.error(\n                    self.span_char(),\n                    ast::ErrorKind::UnicodeClassInvalid,\n                ));\n            }\n            self.bump_and_bump_space();\n            let kind = ast::ClassUnicodeKind::OneLetter(c);\n            (start, kind)\n        };\n        Ok(ast::ClassUnicode {\n            span: Span::new(start, self.pos()),\n            negated: negated,\n            kind: kind,\n        })\n    }\n\n    /// Parse a Perl character class, e.g., `\\d` or `\\W`. This assumes the\n    /// parser is currently at a valid character class name and will be\n    /// advanced to the character immediately following the class.\n    #[inline(never)]\n    fn parse_perl_class(&self) -> ast::ClassPerl {\n        let c = self.char();\n        let span = self.span_char();\n        self.bump();\n        let (negated, kind) = match c {\n            'd' => (false, ast::ClassPerlKind::Digit),\n            'D' => (true, ast::ClassPerlKind::Digit),\n            's' => (false, ast::ClassPerlKind::Space),\n            'S' => (true, ast::ClassPerlKind::Space),\n            'w' => (false, ast::ClassPerlKind::Word),\n            'W' => (true, ast::ClassPerlKind::Word),\n            c => panic!(\"expected valid Perl class but got '{}'\", c),\n        };\n        ast::ClassPerl { span: span, kind: kind, negated: negated }\n    }\n}\n\n/// A type that traverses a fully parsed Ast and checks whether its depth\n/// exceeds the specified nesting limit. If it does, then an error is returned.\n#[derive(Debug)]\nstruct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n    /// The parser that is checking the nest limit.\n    p: &'p ParserI<'s, P>,\n    /// The current depth while walking an Ast.\n    depth: u32,\n}\n\nimpl<'p, 's, P: Borrow<Parser>> NestLimiter<'p, 's, P> {\n    fn new(p: &'p ParserI<'s, P>) -> NestLimiter<'p, 's, P> {\n        NestLimiter { p: p, depth: 0 }\n    }\n\n    #[inline(never)]\n    fn check(self, ast: &Ast) -> Result<()> {\n        ast::visit(ast, self)\n    }\n\n    fn increment_depth(&mut self, span: &Span) -> Result<()> {\n        let new = self.depth.checked_add(1).ok_or_else(|| {\n            self.p.error(\n                span.clone(),\n                ast::ErrorKind::NestLimitExceeded(::std::u32::MAX),\n            )\n        })?;\n        let limit = self.p.parser().nest_limit;\n        if new > limit {\n            return Err(self.p.error(\n                span.clone(),\n                ast::ErrorKind::NestLimitExceeded(limit),\n            ));\n        }\n        self.depth = new;\n        Ok(())\n    }\n\n    fn decrement_depth(&mut self) {\n        // Assuming the correctness of the visitor, this should never drop\n        // below 0.\n        self.depth = self.depth.checked_sub(1).unwrap();\n    }\n}\n\nimpl<'p, 's, P: Borrow<Parser>> ast::Visitor for NestLimiter<'p, 's, P> {\n    type Output = ();\n    type Err = ast::Error;\n\n    fn finish(self) -> Result<()> {\n        Ok(())\n    }\n\n    fn visit_pre(&mut self, ast: &Ast) -> Result<()> {\n        let span = match *ast {\n            Ast::Empty(_)\n            | Ast::Flags(_)\n            | Ast::Literal(_)\n            | Ast::Dot(_)\n            | Ast::Assertion(_)\n            | Ast::Class(ast::Class::Unicode(_))\n            | Ast::Class(ast::Class::Perl(_)) => {\n                // These are all base cases, so we don't increment depth.\n                return Ok(());\n            }\n            Ast::Class(ast::Class::Bracketed(ref x)) => &x.span,\n            Ast::Repetition(ref x) => &x.span,\n            Ast::Group(ref x) => &x.span,\n            Ast::Alternation(ref x) => &x.span,\n            Ast::Concat(ref x) => &x.span,\n        };\n        self.increment_depth(span)\n    }\n\n    fn visit_post(&mut self, ast: &Ast) -> Result<()> {\n        match *ast {\n            Ast::Empty(_)\n            | Ast::Flags(_)\n            | Ast::Literal(_)\n            | Ast::Dot(_)\n            | Ast::Assertion(_)\n            | Ast::Class(ast::Class::Unicode(_))\n            | Ast::Class(ast::Class::Perl(_)) => {\n                // These are all base cases, so we don't decrement depth.\n                Ok(())\n            }\n            Ast::Class(ast::Class::Bracketed(_))\n            | Ast::Repetition(_)\n            | Ast::Group(_)\n            | Ast::Alternation(_)\n            | Ast::Concat(_) => {\n                self.decrement_depth();\n                Ok(())\n            }\n        }\n    }\n\n    fn visit_class_set_item_pre(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<()> {\n        let span = match *ast {\n            ast::ClassSetItem::Empty(_)\n            | ast::ClassSetItem::Literal(_)\n            | ast::ClassSetItem::Range(_)\n            | ast::ClassSetItem::Ascii(_)\n            | ast::ClassSetItem::Unicode(_)\n            | ast::ClassSetItem::Perl(_) => {\n                // These are all base cases, so we don't increment depth.\n                return Ok(());\n            }\n            ast::ClassSetItem::Bracketed(ref x) => &x.span,\n            ast::ClassSetItem::Union(ref x) => &x.span,\n        };\n        self.increment_depth(span)\n    }\n\n    fn visit_class_set_item_post(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<()> {\n        match *ast {\n            ast::ClassSetItem::Empty(_)\n            | ast::ClassSetItem::Literal(_)\n            | ast::ClassSetItem::Range(_)\n            | ast::ClassSetItem::Ascii(_)\n            | ast::ClassSetItem::Unicode(_)\n            | ast::ClassSetItem::Perl(_) => {\n                // These are all base cases, so we don't decrement depth.\n                Ok(())\n            }\n            ast::ClassSetItem::Bracketed(_) | ast::ClassSetItem::Union(_) => {\n                self.decrement_depth();\n                Ok(())\n            }\n        }\n    }\n\n    fn visit_class_set_binary_op_pre(\n        &mut self,\n        ast: &ast::ClassSetBinaryOp,\n    ) -> Result<()> {\n        self.increment_depth(&ast.span)\n    }\n\n    fn visit_class_set_binary_op_post(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<()> {\n        self.decrement_depth();\n        Ok(())\n    }\n}\n\n/// When the result is an error, transforms the ast::ErrorKind from the source\n/// Result into another one. This function is used to return clearer error\n/// messages when possible.\nfn specialize_err<T>(\n    result: Result<T>,\n    from: ast::ErrorKind,\n    to: ast::ErrorKind,\n) -> Result<T> {\n    if let Err(e) = result {\n        if e.kind == from {\n            Err(ast::Error { kind: to, pattern: e.pattern, span: e.span })\n        } else {\n            Err(e)\n        }\n    } else {\n        result\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::ops::Range;\n\n    use super::{Parser, ParserBuilder, ParserI, Primitive};\n    use ast::{self, Ast, Position, Span};\n\n    // Our own assert_eq, which has slightly better formatting (but honestly\n    // still kind of crappy).\n    macro_rules! assert_eq {\n        ($left:expr, $right:expr) => {{\n            match (&$left, &$right) {\n                (left_val, right_val) => {\n                    if !(*left_val == *right_val) {\n                        panic!(\n                            \"assertion failed: `(left == right)`\\n\\n\\\n                             left:  `{:?}`\\nright: `{:?}`\\n\\n\",\n                            left_val, right_val\n                        )\n                    }\n                }\n            }\n        }};\n    }\n\n    // We create these errors to compare with real ast::Errors in the tests.\n    // We define equality between TestError and ast::Error to disregard the\n    // pattern string in ast::Error, which is annoying to provide in tests.\n    #[derive(Clone, Debug)]\n    struct TestError {\n        span: Span,\n        kind: ast::ErrorKind,\n    }\n\n    impl PartialEq<ast::Error> for TestError {\n        fn eq(&self, other: &ast::Error) -> bool {\n            self.span == other.span && self.kind == other.kind\n        }\n    }\n\n    impl PartialEq<TestError> for ast::Error {\n        fn eq(&self, other: &TestError) -> bool {\n            self.span == other.span && self.kind == other.kind\n        }\n    }\n\n    fn s(str: &str) -> String {\n        str.to_string()\n    }\n\n    fn parser(pattern: &str) -> ParserI<Parser> {\n        ParserI::new(Parser::new(), pattern)\n    }\n\n    fn parser_octal(pattern: &str) -> ParserI<Parser> {\n        let parser = ParserBuilder::new().octal(true).build();\n        ParserI::new(parser, pattern)\n    }\n\n    fn parser_nest_limit(pattern: &str, nest_limit: u32) -> ParserI<Parser> {\n        let p = ParserBuilder::new().nest_limit(nest_limit).build();\n        ParserI::new(p, pattern)\n    }\n\n    fn parser_ignore_whitespace(pattern: &str) -> ParserI<Parser> {\n        let p = ParserBuilder::new().ignore_whitespace(true).build();\n        ParserI::new(p, pattern)\n    }\n\n    /// Short alias for creating a new span.\n    fn nspan(start: Position, end: Position) -> Span {\n        Span::new(start, end)\n    }\n\n    /// Short alias for creating a new position.\n    fn npos(offset: usize, line: usize, column: usize) -> Position {\n        Position::new(offset, line, column)\n    }\n\n    /// Create a new span from the given offset range. This assumes a single\n    /// line and sets the columns based on the offsets. i.e., This only works\n    /// out of the box for ASCII, which is fine for most tests.\n    fn span(range: Range<usize>) -> Span {\n        let start = Position::new(range.start, 1, range.start + 1);\n        let end = Position::new(range.end, 1, range.end + 1);\n        Span::new(start, end)\n    }\n\n    /// Create a new span for the corresponding byte range in the given string.\n    fn span_range(subject: &str, range: Range<usize>) -> Span {\n        let start = Position {\n            offset: range.start,\n            line: 1 + subject[..range.start].matches('\\n').count(),\n            column: 1 + subject[..range.start]\n                .chars()\n                .rev()\n                .position(|c| c == '\\n')\n                .unwrap_or(subject[..range.start].chars().count()),\n        };\n        let end = Position {\n            offset: range.end,\n            line: 1 + subject[..range.end].matches('\\n').count(),\n            column: 1 + subject[..range.end]\n                .chars()\n                .rev()\n                .position(|c| c == '\\n')\n                .unwrap_or(subject[..range.end].chars().count()),\n        };\n        Span::new(start, end)\n    }\n\n    /// Create a verbatim literal starting at the given position.\n    fn lit(c: char, start: usize) -> Ast {\n        lit_with(c, span(start..start + c.len_utf8()))\n    }\n\n    /// Create a punctuation literal starting at the given position.\n    fn punct_lit(c: char, span: Span) -> Ast {\n        Ast::Literal(ast::Literal {\n            span: span,\n            kind: ast::LiteralKind::Punctuation,\n            c: c,\n        })\n    }\n\n    /// Create a verbatim literal with the given span.\n    fn lit_with(c: char, span: Span) -> Ast {\n        Ast::Literal(ast::Literal {\n            span: span,\n            kind: ast::LiteralKind::Verbatim,\n            c: c,\n        })\n    }\n\n    /// Create a concatenation with the given range.\n    fn concat(range: Range<usize>, asts: Vec<Ast>) -> Ast {\n        concat_with(span(range), asts)\n    }\n\n    /// Create a concatenation with the given span.\n    fn concat_with(span: Span, asts: Vec<Ast>) -> Ast {\n        Ast::Concat(ast::Concat { span: span, asts: asts })\n    }\n\n    /// Create an alternation with the given span.\n    fn alt(range: Range<usize>, asts: Vec<Ast>) -> Ast {\n        Ast::Alternation(ast::Alternation { span: span(range), asts: asts })\n    }\n\n    /// Create a capturing group with the given span.\n    fn group(range: Range<usize>, index: u32, ast: Ast) -> Ast {\n        Ast::Group(ast::Group {\n            span: span(range),\n            kind: ast::GroupKind::CaptureIndex(index),\n            ast: Box::new(ast),\n        })\n    }\n\n    /// Create an ast::SetFlags.\n    ///\n    /// The given pattern should be the full pattern string. The range given\n    /// should correspond to the byte offsets where the flag set occurs.\n    ///\n    /// If negated is true, then the set is interpreted as beginning with a\n    /// negation.\n    fn flag_set(\n        pat: &str,\n        range: Range<usize>,\n        flag: ast::Flag,\n        negated: bool,\n    ) -> Ast {\n        let mut items = vec![ast::FlagsItem {\n            span: span_range(pat, (range.end - 2)..(range.end - 1)),\n            kind: ast::FlagsItemKind::Flag(flag),\n        }];\n        if negated {\n            items.insert(\n                0,\n                ast::FlagsItem {\n                    span: span_range(pat, (range.start + 2)..(range.end - 2)),\n                    kind: ast::FlagsItemKind::Negation,\n                },\n            );\n        }\n        Ast::Flags(ast::SetFlags {\n            span: span_range(pat, range.clone()),\n            flags: ast::Flags {\n                span: span_range(pat, (range.start + 2)..(range.end - 1)),\n                items: items,\n            },\n        })\n    }\n\n    #[test]\n    fn parse_nest_limit() {\n        // A nest limit of 0 still allows some types of regexes.\n        assert_eq!(\n            parser_nest_limit(\"\", 0).parse(),\n            Ok(Ast::Empty(span(0..0)))\n        );\n        assert_eq!(parser_nest_limit(\"a\", 0).parse(), Ok(lit('a', 0)));\n\n        // Test repetition operations, which require one level of nesting.\n        assert_eq!(\n            parser_nest_limit(\"a+\", 0).parse().unwrap_err(),\n            TestError {\n                span: span(0..2),\n                kind: ast::ErrorKind::NestLimitExceeded(0),\n            }\n        );\n        assert_eq!(\n            parser_nest_limit(\"a+\", 1).parse(),\n            Ok(Ast::Repetition(ast::Repetition {\n                span: span(0..2),\n                op: ast::RepetitionOp {\n                    span: span(1..2),\n                    kind: ast::RepetitionKind::OneOrMore,\n                },\n                greedy: true,\n                ast: Box::new(lit('a', 0)),\n            }))\n        );\n        assert_eq!(\n            parser_nest_limit(\"(a)+\", 1).parse().unwrap_err(),\n            TestError {\n                span: span(0..3),\n                kind: ast::ErrorKind::NestLimitExceeded(1),\n            }\n        );\n        assert_eq!(\n            parser_nest_limit(\"a+*\", 1).parse().unwrap_err(),\n            TestError {\n                span: span(0..2),\n                kind: ast::ErrorKind::NestLimitExceeded(1),\n            }\n        );\n        assert_eq!(\n            parser_nest_limit(\"a+*\", 2).parse(),\n            Ok(Ast::Repetition(ast::Repetition {\n                span: span(0..3),\n                op: ast::RepetitionOp {\n                    span: span(2..3),\n                    kind: ast::RepetitionKind::ZeroOrMore,\n                },\n                greedy: true,\n                ast: Box::new(Ast::Repetition(ast::Repetition {\n                    span: span(0..2),\n                    op: ast::RepetitionOp {\n                        span: span(1..2),\n                        kind: ast::RepetitionKind::OneOrMore,\n                    },\n                    greedy: true,\n                    ast: Box::new(lit('a', 0)),\n                })),\n            }))\n        );\n\n        // Test concatenations. A concatenation requires one level of nesting.\n        assert_eq!(\n            parser_nest_limit(\"ab\", 0).parse().unwrap_err(),\n            TestError {\n                span: span(0..2),\n                kind: ast::ErrorKind::NestLimitExceeded(0),\n            }\n        );\n        assert_eq!(\n            parser_nest_limit(\"ab\", 1).parse(),\n            Ok(concat(0..2, vec![lit('a', 0), lit('b', 1)]))\n        );\n        assert_eq!(\n            parser_nest_limit(\"abc\", 1).parse(),\n            Ok(concat(0..3, vec![lit('a', 0), lit('b', 1), lit('c', 2)]))\n        );\n\n        // Test alternations. An alternation requires one level of nesting.\n        assert_eq!(\n            parser_nest_limit(\"a|b\", 0).parse().unwrap_err(),\n            TestError {\n                span: span(0..3),\n                kind: ast::ErrorKind::NestLimitExceeded(0),\n            }\n        );\n        assert_eq!(\n            parser_nest_limit(\"a|b\", 1).parse(),\n            Ok(alt(0..3, vec![lit('a', 0), lit('b', 2)]))\n        );\n        assert_eq!(\n            parser_nest_limit(\"a|b|c\", 1).parse(),\n            Ok(alt(0..5, vec![lit('a', 0), lit('b', 2), lit('c', 4)]))\n        );\n\n        // Test character classes. Classes form their own mini-recursive\n        // syntax!\n        assert_eq!(\n            parser_nest_limit(\"[a]\", 0).parse().unwrap_err(),\n            TestError {\n                span: span(0..3),\n                kind: ast::ErrorKind::NestLimitExceeded(0),\n            }\n        );\n        assert_eq!(\n            parser_nest_limit(\"[a]\", 1).parse(),\n            Ok(Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {\n                span: span(0..3),\n                negated: false,\n                kind: ast::ClassSet::Item(ast::ClassSetItem::Literal(\n                    ast::Literal {\n                        span: span(1..2),\n                        kind: ast::LiteralKind::Verbatim,\n                        c: 'a',\n                    }\n                )),\n            })))\n        );\n        assert_eq!(\n            parser_nest_limit(\"[ab]\", 1).parse().unwrap_err(),\n            TestError {\n                span: span(1..3),\n                kind: ast::ErrorKind::NestLimitExceeded(1),\n            }\n        );\n        assert_eq!(\n            parser_nest_limit(\"[ab[cd]]\", 2).parse().unwrap_err(),\n            TestError {\n                span: span(3..7),\n                kind: ast::ErrorKind::NestLimitExceeded(2),\n            }\n        );\n        assert_eq!(\n            parser_nest_limit(\"[ab[cd]]\", 3).parse().unwrap_err(),\n            TestError {\n                span: span(4..6),\n                kind: ast::ErrorKind::NestLimitExceeded(3),\n            }\n        );\n        assert_eq!(\n            parser_nest_limit(\"[a--b]\", 1).parse().unwrap_err(),\n            TestError {\n                span: span(1..5),\n                kind: ast::ErrorKind::NestLimitExceeded(1),\n            }\n        );\n        assert_eq!(\n            parser_nest_limit(\"[a--bc]\", 2).parse().unwrap_err(),\n            TestError {\n                span: span(4..6),\n                kind: ast::ErrorKind::NestLimitExceeded(2),\n            }\n        );\n    }\n\n    #[test]\n    fn parse_comments() {\n        let pat = \"(?x)\n# This is comment 1.\nfoo # This is comment 2.\n  # This is comment 3.\nbar\n# This is comment 4.\";\n        let astc = parser(pat).parse_with_comments().unwrap();\n        assert_eq!(\n            astc.ast,\n            concat_with(\n                span_range(pat, 0..pat.len()),\n                vec![\n                    flag_set(pat, 0..4, ast::Flag::IgnoreWhitespace, false),\n                    lit_with('f', span_range(pat, 26..27)),\n                    lit_with('o', span_range(pat, 27..28)),\n                    lit_with('o', span_range(pat, 28..29)),\n                    lit_with('b', span_range(pat, 74..75)),\n                    lit_with('a', span_range(pat, 75..76)),\n                    lit_with('r', span_range(pat, 76..77)),\n                ]\n            )\n        );\n        assert_eq!(\n            astc.comments,\n            vec![\n                ast::Comment {\n                    span: span_range(pat, 5..26),\n                    comment: s(\" This is comment 1.\"),\n                },\n                ast::Comment {\n                    span: span_range(pat, 30..51),\n                    comment: s(\" This is comment 2.\"),\n                },\n                ast::Comment {\n                    span: span_range(pat, 53..74),\n                    comment: s(\" This is comment 3.\"),\n                },\n                ast::Comment {\n                    span: span_range(pat, 78..98),\n                    comment: s(\" This is comment 4.\"),\n                },\n            ]\n        );\n    }\n\n    #[test]\n    fn parse_holistic() {\n        assert_eq!(parser(\"]\").parse(), Ok(lit(']', 0)));\n        assert_eq!(\n            parser(r\"\\\\\\.\\+\\*\\?\\(\\)\\|\\[\\]\\{\\}\\^\\$\\#\\&\\-\\~\").parse(),\n            Ok(concat(\n                0..36,\n                vec![\n                    punct_lit('\\\\', span(0..2)),\n                    punct_lit('.', span(2..4)),\n                    punct_lit('+', span(4..6)),\n                    punct_lit('*', span(6..8)),\n                    punct_lit('?', span(8..10)),\n                    punct_lit('(', span(10..12)),\n                    punct_lit(')', span(12..14)),\n                    punct_lit('|', span(14..16)),\n                    punct_lit('[', span(16..18)),\n                    punct_lit(']', span(18..20)),\n                    punct_lit('{', span(20..22)),\n                    punct_lit('}', span(22..24)),\n                    punct_lit('^', span(24..26)),\n                    punct_lit('$', span(26..28)),\n                    punct_lit('#', span(28..30)),\n                    punct_lit('&', span(30..32)),\n                    punct_lit('-', span(32..34)),\n                    punct_lit('~', span(34..36)),\n                ]\n            ))\n        );\n    }\n\n    #[test]\n    fn parse_ignore_whitespace() {\n        // Test that basic whitespace insensitivity works.\n        let pat = \"(?x)a b\";\n        assert_eq!(\n            parser(pat).parse(),\n            Ok(concat_with(\n                nspan(npos(0, 1, 1), npos(7, 1, 8)),\n                vec![\n                    flag_set(pat, 0..4, ast::Flag::IgnoreWhitespace, false),\n                    lit_with('a', nspan(npos(4, 1, 5), npos(5, 1, 6))),\n                    lit_with('b', nspan(npos(6, 1, 7), npos(7, 1, 8))),\n                ]\n            ))\n        );\n\n        // Test that we can toggle whitespace insensitivity.\n        let pat = \"(?x)a b(?-x)a b\";\n        assert_eq!(\n            parser(pat).parse(),\n            Ok(concat_with(\n                nspan(npos(0, 1, 1), npos(15, 1, 16)),\n                vec![\n                    flag_set(pat, 0..4, ast::Flag::IgnoreWhitespace, false),\n                    lit_with('a', nspan(npos(4, 1, 5), npos(5, 1, 6))),\n                    lit_with('b', nspan(npos(6, 1, 7), npos(7, 1, 8))),\n                    flag_set(pat, 7..12, ast::Flag::IgnoreWhitespace, true),\n                    lit_with('a', nspan(npos(12, 1, 13), npos(13, 1, 14))),\n                    lit_with(' ', nspan(npos(13, 1, 14), npos(14, 1, 15))),\n                    lit_with('b', nspan(npos(14, 1, 15), npos(15, 1, 16))),\n                ]\n            ))\n        );\n\n        // Test that nesting whitespace insensitive flags works.\n        let pat = \"a (?x:a )a \";\n        assert_eq!(\n            parser(pat).parse(),\n            Ok(concat_with(\n                span_range(pat, 0..11),\n                vec![\n                    lit_with('a', span_range(pat, 0..1)),\n                    lit_with(' ', span_range(pat, 1..2)),\n                    Ast::Group(ast::Group {\n                        span: span_range(pat, 2..9),\n                        kind: ast::GroupKind::NonCapturing(ast::Flags {\n                            span: span_range(pat, 4..5),\n                            items: vec![ast::FlagsItem {\n                                span: span_range(pat, 4..5),\n                                kind: ast::FlagsItemKind::Flag(\n                                    ast::Flag::IgnoreWhitespace\n                                ),\n                            },],\n                        }),\n                        ast: Box::new(lit_with('a', span_range(pat, 6..7))),\n                    }),\n                    lit_with('a', span_range(pat, 9..10)),\n                    lit_with(' ', span_range(pat, 10..11)),\n                ]\n            ))\n        );\n\n        // Test that whitespace after an opening paren is insignificant.\n        let pat = \"(?x)( ?P<foo> a )\";\n        assert_eq!(\n            parser(pat).parse(),\n            Ok(concat_with(\n                span_range(pat, 0..pat.len()),\n                vec![\n                    flag_set(pat, 0..4, ast::Flag::IgnoreWhitespace, false),\n                    Ast::Group(ast::Group {\n                        span: span_range(pat, 4..pat.len()),\n                        kind: ast::GroupKind::CaptureName(ast::CaptureName {\n                            span: span_range(pat, 9..12),\n                            name: s(\"foo\"),\n                            index: 1,\n                        }),\n                        ast: Box::new(lit_with('a', span_range(pat, 14..15))),\n                    }),\n                ]\n            ))\n        );\n        let pat = \"(?x)(  a )\";\n        assert_eq!(\n            parser(pat).parse(),\n            Ok(concat_with(\n                span_range(pat, 0..pat.len()),\n                vec![\n                    flag_set(pat, 0..4, ast::Flag::IgnoreWhitespace, false),\n                    Ast::Group(ast::Group {\n                        span: span_range(pat, 4..pat.len()),\n                        kind: ast::GroupKind::CaptureIndex(1),\n                        ast: Box::new(lit_with('a', span_range(pat, 7..8))),\n                    }),\n                ]\n            ))\n        );\n        let pat = \"(?x)(  ?:  a )\";\n        assert_eq!(\n            parser(pat).parse(),\n            Ok(concat_with(\n                span_range(pat, 0..pat.len()),\n                vec![\n                    flag_set(pat, 0..4, ast::Flag::IgnoreWhitespace, false),\n                    Ast::Group(ast::Group {\n                        span: span_range(pat, 4..pat.len()),\n                        kind: ast::GroupKind::NonCapturing(ast::Flags {\n                            span: span_range(pat, 8..8),\n                            items: vec![],\n                        }),\n                        ast: Box::new(lit_with('a', span_range(pat, 11..12))),\n                    }),\n                ]\n            ))\n        );\n        let pat = r\"(?x)\\x { 53 }\";\n        assert_eq!(\n            parser(pat).parse(),\n            Ok(concat_with(\n                span_range(pat, 0..pat.len()),\n                vec![\n                    flag_set(pat, 0..4, ast::Flag::IgnoreWhitespace, false),\n                    Ast::Literal(ast::Literal {\n                        span: span(4..13),\n                        kind: ast::LiteralKind::HexBrace(\n                            ast::HexLiteralKind::X\n                        ),\n                        c: 'S',\n                    }),\n                ]\n            ))\n        );\n\n        // Test that whitespace after an escape is OK.\n        let pat = r\"(?x)\\ \";\n        assert_eq!(\n            parser(pat).parse(),\n            Ok(concat_with(\n                span_range(pat, 0..pat.len()),\n                vec![\n                    flag_set(pat, 0..4, ast::Flag::IgnoreWhitespace, false),\n                    Ast::Literal(ast::Literal {\n                        span: span_range(pat, 4..6),\n                        kind: ast::LiteralKind::Special(\n                            ast::SpecialLiteralKind::Space\n                        ),\n                        c: ' ',\n                    }),\n                ]\n            ))\n        );\n        // ... but only when `x` mode is enabled.\n        let pat = r\"\\ \";\n        assert_eq!(\n            parser(pat).parse().unwrap_err(),\n            TestError {\n                span: span_range(pat, 0..2),\n                kind: ast::ErrorKind::EscapeUnrecognized,\n            }\n        );\n    }\n\n    #[test]\n    fn parse_newlines() {\n        let pat = \".\\n.\";\n        assert_eq!(\n            parser(pat).parse(),\n            Ok(concat_with(\n                span_range(pat, 0..3),\n                vec![\n                    Ast::Dot(span_range(pat, 0..1)),\n                    lit_with('\\n', span_range(pat, 1..2)),\n                    Ast::Dot(span_range(pat, 2..3)),\n                ]\n            ))\n        );\n\n        let pat = \"foobar\\nbaz\\nquux\\n\";\n        assert_eq!(\n            parser(pat).parse(),\n            Ok(concat_with(\n                span_range(pat, 0..pat.len()),\n                vec![\n                    lit_with('f', nspan(npos(0, 1, 1), npos(1, 1, 2))),\n                    lit_with('o', nspan(npos(1, 1, 2), npos(2, 1, 3))),\n                    lit_with('o', nspan(npos(2, 1, 3), npos(3, 1, 4))),\n                    lit_with('b', nspan(npos(3, 1, 4), npos(4, 1, 5))),\n                    lit_with('a', nspan(npos(4, 1, 5), npos(5, 1, 6))),\n                    lit_with('r', nspan(npos(5, 1, 6), npos(6, 1, 7))),\n                    lit_with('\\n', nspan(npos(6, 1, 7), npos(7, 2, 1))),\n                    lit_with('b', nspan(npos(7, 2, 1), npos(8, 2, 2))),\n                    lit_with('a', nspan(npos(8, 2, 2), npos(9, 2, 3))),\n                    lit_with('z', nspan(npos(9, 2, 3), npos(10, 2, 4))),\n                    lit_with('\\n', nspan(npos(10, 2, 4), npos(11, 3, 1))),\n                    lit_with('q', nspan(npos(11, 3, 1), npos(12, 3, 2))),\n                    lit_with('u', nspan(npos(12, 3, 2), npos(13, 3, 3))),\n                    lit_with('u', nspan(npos(13, 3, 3), npos(14, 3, 4))),\n                    lit_with('x', nspan(npos(14, 3, 4), npos(15, 3, 5))),\n                    lit_with('\\n', nspan(npos(15, 3, 5), npos(16, 4, 1))),\n                ]\n            ))\n        );\n    }\n\n    #[test]\n    fn parse_uncounted_repetition() {\n        assert_eq!(\n            parser(r\"a*\").parse(),\n            Ok(Ast::Repetition(ast::Repetition {\n                span: span(0..2),\n                op: ast::RepetitionOp {\n                    span: span(1..2),\n                    kind: ast::RepetitionKind::ZeroOrMore,\n                },\n                greedy: true,\n                ast: Box::new(lit('a', 0)),\n            }))\n        );\n        assert_eq!(\n            parser(r\"a+\").parse(),\n            Ok(Ast::Repetition(ast::Repetition {\n                span: span(0..2),\n                op: ast::RepetitionOp {\n                    span: span(1..2),\n                    kind: ast::RepetitionKind::OneOrMore,\n                },\n                greedy: true,\n                ast: Box::new(lit('a', 0)),\n            }))\n        );\n\n        assert_eq!(\n            parser(r\"a?\").parse(),\n            Ok(Ast::Repetition(ast::Repetition {\n                span: span(0..2),\n                op: ast::RepetitionOp {\n                    span: span(1..2),\n                    kind: ast::RepetitionKind::ZeroOrOne,\n                },\n                greedy: true,\n                ast: Box::new(lit('a', 0)),\n            }))\n        );\n        assert_eq!(\n            parser(r\"a??\").parse(),\n            Ok(Ast::Repetition(ast::Repetition {\n                span: span(0..3),\n                op: ast::RepetitionOp {\n                    span: span(1..3),\n                    kind: ast::RepetitionKind::ZeroOrOne,\n                },\n                greedy: false,\n                ast: Box::new(lit('a', 0)),\n            }))\n        );\n        assert_eq!(\n            parser(r\"a?\").parse(),\n            Ok(Ast::Repetition(ast::Repetition {\n                span: span(0..2),\n                op: ast::RepetitionOp {\n                    span: span(1..2),\n                    kind: ast::RepetitionKind::ZeroOrOne,\n                },\n                greedy: true,\n                ast: Box::new(lit('a', 0)),\n            }))\n        );\n        assert_eq!(\n            parser(r\"a?b\").parse(),\n            Ok(concat(\n                0..3,\n                vec![\n                    Ast::Repetition(ast::Repetition {\n                        span: span(0..2),\n                        op: ast::RepetitionOp {\n                            span: span(1..2),\n                            kind: ast::RepetitionKind::ZeroOrOne,\n                        },\n                        greedy: true,\n                        ast: Box::new(lit('a', 0)),\n                    }),\n                    lit('b', 2),\n                ]\n            ))\n        );\n        assert_eq!(\n            parser(r\"a??b\").parse(),\n            Ok(concat(\n                0..4,\n                vec![\n                    Ast::Repetition(ast::Repetition {\n                        span: span(0..3),\n                        op: ast::RepetitionOp {\n                            span: span(1..3),\n                            kind: ast::RepetitionKind::ZeroOrOne,\n                        },\n                        greedy: false,\n                        ast: Box::new(lit('a', 0)),\n                    }),\n                    lit('b', 3),\n                ]\n            ))\n        );\n        assert_eq!(\n            parser(r\"ab?\").parse(),\n            Ok(concat(\n                0..3,\n                vec![\n                    lit('a', 0),\n                    Ast::Repetition(ast::Repetition {\n                        span: span(1..3),\n                        op: ast::RepetitionOp {\n                            span: span(2..3),\n                            kind: ast::RepetitionKind::ZeroOrOne,\n                        },\n                        greedy: true,\n                        ast: Box::new(lit('b', 1)),\n                    }),\n                ]\n            ))\n        );\n        assert_eq!(\n            parser(r\"(ab)?\").parse(),\n            Ok(Ast::Repetition(ast::Repetition {\n                span: span(0..5),\n                op: ast::RepetitionOp {\n                    span: span(4..5),\n                    kind: ast::RepetitionKind::ZeroOrOne,\n                },\n                greedy: true,\n                ast: Box::new(group(\n                    0..4,\n                    1,\n                    concat(1..3, vec![lit('a', 1), lit('b', 2),])\n                )),\n            }))\n        );\n        assert_eq!(\n            parser(r\"|a?\").parse(),\n            Ok(alt(\n                0..3,\n                vec![\n                    Ast::Empty(span(0..0)),\n                    Ast::Repetition(ast::Repetition {\n                        span: span(1..3),\n                        op: ast::RepetitionOp {\n                            span: span(2..3),\n                            kind: ast::RepetitionKind::ZeroOrOne,\n                        },\n                        greedy: true,\n                        ast: Box::new(lit('a', 1)),\n                    }),\n                ]\n            ))\n        );\n\n        assert_eq!(\n            parser(r\"*\").parse().unwrap_err(),\n            TestError {\n                span: span(0..0),\n                kind: ast::ErrorKind::RepetitionMissing,\n            }\n        );\n        assert_eq!(\n            parser(r\"(?i)*\").parse().unwrap_err(),\n            TestError {\n                span: span(4..4),\n                kind: ast::ErrorKind::RepetitionMissing,\n            }\n        );\n        assert_eq!(\n            parser(r\"(*)\").parse().unwrap_err(),\n            TestError {\n                span: span(1..1),\n                kind: ast::ErrorKind::RepetitionMissing,\n            }\n        );\n        assert_eq!(\n            parser(r\"(?:?)\").parse().unwrap_err(),\n            TestError {\n                span: span(3..3),\n                kind: ast::ErrorKind::RepetitionMissing,\n            }\n        );\n        assert_eq!(\n            parser(r\"+\").parse().unwrap_err(),\n            TestError {\n                span: span(0..0),\n                kind: ast::ErrorKind::RepetitionMissing,\n            }\n        );\n        assert_eq!(\n            parser(r\"?\").parse().unwrap_err(),\n            TestError {\n                span: span(0..0),\n                kind: ast::ErrorKind::RepetitionMissing,\n            }\n        );\n        assert_eq!(\n            parser(r\"(?)\").parse().unwrap_err(),\n            TestError {\n                span: span(1..1),\n                kind: ast::ErrorKind::RepetitionMissing,\n            }\n        );\n        assert_eq!(\n            parser(r\"|*\").parse().unwrap_err(),\n            TestError {\n                span: span(1..1),\n                kind: ast::ErrorKind::RepetitionMissing,\n            }\n        );\n        assert_eq!(\n            parser(r\"|+\").parse().unwrap_err(),\n            TestError {\n                span: span(1..1),\n                kind: ast::ErrorKind::RepetitionMissing,\n            }\n        );\n        assert_eq!(\n            parser(r\"|?\").parse().unwrap_err(),\n            TestError {\n                span: span(1..1),\n                kind: ast::ErrorKind::RepetitionMissing,\n            }\n        );\n    }\n\n    #[test]\n    fn parse_counted_repetition() {\n        assert_eq!(\n            parser(r\"a{5}\").parse(),\n            Ok(Ast::Repetition(ast::Repetition {\n                span: span(0..4),\n                op: ast::RepetitionOp {\n                    span: span(1..4),\n                    kind: ast::RepetitionKind::Range(\n                        ast::RepetitionRange::Exactly(5)\n                    ),\n                },\n                greedy: true,\n                ast: Box::new(lit('a', 0)),\n            }))\n        );\n        assert_eq!(\n            parser(r\"a{5,}\").parse(),\n            Ok(Ast::Repetition(ast::Repetition {\n                span: span(0..5),\n                op: ast::RepetitionOp {\n                    span: span(1..5),\n                    kind: ast::RepetitionKind::Range(\n                        ast::RepetitionRange::AtLeast(5)\n                    ),\n                },\n                greedy: true,\n                ast: Box::new(lit('a', 0)),\n            }))\n        );\n        assert_eq!(\n            parser(r\"a{5,9}\").parse(),\n            Ok(Ast::Repetition(ast::Repetition {\n                span: span(0..6),\n                op: ast::RepetitionOp {\n                    span: span(1..6),\n                    kind: ast::RepetitionKind::Range(\n                        ast::RepetitionRange::Bounded(5, 9)\n                    ),\n                },\n                greedy: true,\n                ast: Box::new(lit('a', 0)),\n            }))\n        );\n        assert_eq!(\n            parser(r\"a{5}?\").parse(),\n            Ok(Ast::Repetition(ast::Repetition {\n                span: span(0..5),\n                op: ast::RepetitionOp {\n                    span: span(1..5),\n                    kind: ast::RepetitionKind::Range(\n                        ast::RepetitionRange::Exactly(5)\n                    ),\n                },\n                greedy: false,\n                ast: Box::new(lit('a', 0)),\n            }))\n        );\n        assert_eq!(\n            parser(r\"ab{5}\").parse(),\n            Ok(concat(\n                0..5,\n                vec![\n                    lit('a', 0),\n                    Ast::Repetition(ast::Repetition {\n                        span: span(1..5),\n                        op: ast::RepetitionOp {\n                            span: span(2..5),\n                            kind: ast::RepetitionKind::Range(\n                                ast::RepetitionRange::Exactly(5)\n                            ),\n                        },\n                        greedy: true,\n                        ast: Box::new(lit('b', 1)),\n                    }),\n                ]\n            ))\n        );\n        assert_eq!(\n            parser(r\"ab{5}c\").parse(),\n            Ok(concat(\n                0..6,\n                vec![\n                    lit('a', 0),\n                    Ast::Repetition(ast::Repetition {\n                        span: span(1..5),\n                        op: ast::RepetitionOp {\n                            span: span(2..5),\n                            kind: ast::RepetitionKind::Range(\n                                ast::RepetitionRange::Exactly(5)\n                            ),\n                        },\n                        greedy: true,\n                        ast: Box::new(lit('b', 1)),\n                    }),\n                    lit('c', 5),\n                ]\n            ))\n        );\n\n        assert_eq!(\n            parser(r\"a{ 5 }\").parse(),\n            Ok(Ast::Repetition(ast::Repetition {\n                span: span(0..6),\n                op: ast::RepetitionOp {\n                    span: span(1..6),\n                    kind: ast::RepetitionKind::Range(\n                        ast::RepetitionRange::Exactly(5)\n                    ),\n                },\n                greedy: true,\n                ast: Box::new(lit('a', 0)),\n            }))\n        );\n        assert_eq!(\n            parser(r\"a{ 5 , 9 }\").parse(),\n            Ok(Ast::Repetition(ast::Repetition {\n                span: span(0..10),\n                op: ast::RepetitionOp {\n                    span: span(1..10),\n                    kind: ast::RepetitionKind::Range(\n                        ast::RepetitionRange::Bounded(5, 9)\n                    ),\n                },\n                greedy: true,\n                ast: Box::new(lit('a', 0)),\n            }))\n        );\n        assert_eq!(\n            parser_ignore_whitespace(r\"a{5,9} ?\").parse(),\n            Ok(Ast::Repetition(ast::Repetition {\n                span: span(0..8),\n                op: ast::RepetitionOp {\n                    span: span(1..8),\n                    kind: ast::RepetitionKind::Range(\n                        ast::RepetitionRange::Bounded(5, 9)\n                    ),\n                },\n                greedy: false,\n                ast: Box::new(lit('a', 0)),\n            }))\n        );\n\n        assert_eq!(\n            parser(r\"(?i){0}\").parse().unwrap_err(),\n            TestError {\n                span: span(4..4),\n                kind: ast::ErrorKind::RepetitionMissing,\n            }\n        );\n        assert_eq!(\n            parser(r\"(?m){1,1}\").parse().unwrap_err(),\n            TestError {\n                span: span(4..4),\n                kind: ast::ErrorKind::RepetitionMissing,\n            }\n        );\n        assert_eq!(\n            parser(r\"a{]}\").parse().unwrap_err(),\n            TestError {\n                span: span(2..2),\n                kind: ast::ErrorKind::RepetitionCountDecimalEmpty,\n            }\n        );\n        assert_eq!(\n            parser(r\"a{1,]}\").parse().unwrap_err(),\n            TestError {\n                span: span(4..4),\n                kind: ast::ErrorKind::RepetitionCountDecimalEmpty,\n            }\n        );\n        assert_eq!(\n            parser(r\"a{\").parse().unwrap_err(),\n            TestError {\n                span: span(1..2),\n                kind: ast::ErrorKind::RepetitionCountUnclosed,\n            }\n        );\n        assert_eq!(\n            parser(r\"a{}\").parse().unwrap_err(),\n            TestError {\n                span: span(2..2),\n                kind: ast::ErrorKind::RepetitionCountDecimalEmpty,\n            }\n        );\n        assert_eq!(\n            parser(r\"a{a\").parse().unwrap_err(),\n            TestError {\n                span: span(2..2),\n                kind: ast::ErrorKind::RepetitionCountDecimalEmpty,\n            }\n        );\n        assert_eq!(\n            parser(r\"a{9999999999}\").parse().unwrap_err(),\n            TestError {\n                span: span(2..12),\n                kind: ast::ErrorKind::DecimalInvalid,\n            }\n        );\n        assert_eq!(\n            parser(r\"a{9\").parse().unwrap_err(),\n            TestError {\n                span: span(1..3),\n                kind: ast::ErrorKind::RepetitionCountUnclosed,\n            }\n        );\n        assert_eq!(\n            parser(r\"a{9,a\").parse().unwrap_err(),\n            TestError {\n                span: span(4..4),\n                kind: ast::ErrorKind::RepetitionCountDecimalEmpty,\n            }\n        );\n        assert_eq!(\n            parser(r\"a{9,9999999999}\").parse().unwrap_err(),\n            TestError {\n                span: span(4..14),\n                kind: ast::ErrorKind::DecimalInvalid,\n            }\n        );\n        assert_eq!(\n            parser(r\"a{9,\").parse().unwrap_err(),\n            TestError {\n                span: span(1..4),\n                kind: ast::ErrorKind::RepetitionCountUnclosed,\n            }\n        );\n        assert_eq!(\n            parser(r\"a{9,11\").parse().unwrap_err(),\n            TestError {\n                span: span(1..6),\n                kind: ast::ErrorKind::RepetitionCountUnclosed,\n            }\n        );\n        assert_eq!(\n            parser(r\"a{2,1}\").parse().unwrap_err(),\n            TestError {\n                span: span(1..6),\n                kind: ast::ErrorKind::RepetitionCountInvalid,\n            }\n        );\n        assert_eq!(\n            parser(r\"{5}\").parse().unwrap_err(),\n            TestError {\n                span: span(0..0),\n                kind: ast::ErrorKind::RepetitionMissing,\n            }\n        );\n        assert_eq!(\n            parser(r\"|{5}\").parse().unwrap_err(),\n            TestError {\n                span: span(1..1),\n                kind: ast::ErrorKind::RepetitionMissing,\n            }\n        );\n    }\n\n    #[test]\n    fn parse_alternate() {\n        assert_eq!(\n            parser(r\"a|b\").parse(),\n            Ok(Ast::Alternation(ast::Alternation {\n                span: span(0..3),\n                asts: vec![lit('a', 0), lit('b', 2)],\n            }))\n        );\n        assert_eq!(\n            parser(r\"(a|b)\").parse(),\n            Ok(group(\n                0..5,\n                1,\n                Ast::Alternation(ast::Alternation {\n                    span: span(1..4),\n                    asts: vec![lit('a', 1), lit('b', 3)],\n                })\n            ))\n        );\n\n        assert_eq!(\n            parser(r\"a|b|c\").parse(),\n            Ok(Ast::Alternation(ast::Alternation {\n                span: span(0..5),\n                asts: vec![lit('a', 0), lit('b', 2), lit('c', 4)],\n            }))\n        );\n        assert_eq!(\n            parser(r\"ax|by|cz\").parse(),\n            Ok(Ast::Alternation(ast::Alternation {\n                span: span(0..8),\n                asts: vec![\n                    concat(0..2, vec![lit('a', 0), lit('x', 1)]),\n                    concat(3..5, vec![lit('b', 3), lit('y', 4)]),\n                    concat(6..8, vec![lit('c', 6), lit('z', 7)]),\n                ],\n            }))\n        );\n        assert_eq!(\n            parser(r\"(ax|by|cz)\").parse(),\n            Ok(group(\n                0..10,\n                1,\n                Ast::Alternation(ast::Alternation {\n                    span: span(1..9),\n                    asts: vec![\n                        concat(1..3, vec![lit('a', 1), lit('x', 2)]),\n                        concat(4..6, vec![lit('b', 4), lit('y', 5)]),\n                        concat(7..9, vec![lit('c', 7), lit('z', 8)]),\n                    ],\n                })\n            ))\n        );\n        assert_eq!(\n            parser(r\"(ax|(by|(cz)))\").parse(),\n            Ok(group(\n                0..14,\n                1,\n                alt(\n                    1..13,\n                    vec![\n                        concat(1..3, vec![lit('a', 1), lit('x', 2)]),\n                        group(\n                            4..13,\n                            2,\n                            alt(\n                                5..12,\n                                vec![\n                                    concat(\n                                        5..7,\n                                        vec![lit('b', 5), lit('y', 6)]\n                                    ),\n                                    group(\n                                        8..12,\n                                        3,\n                                        concat(\n                                            9..11,\n                                            vec![lit('c', 9), lit('z', 10),]\n                                        )\n                                    ),\n                                ]\n                            )\n                        ),\n                    ]\n                )\n            ))\n        );\n\n        assert_eq!(\n            parser(r\"|\").parse(),\n            Ok(alt(\n                0..1,\n                vec![Ast::Empty(span(0..0)), Ast::Empty(span(1..1)),]\n            ))\n        );\n        assert_eq!(\n            parser(r\"||\").parse(),\n            Ok(alt(\n                0..2,\n                vec![\n                    Ast::Empty(span(0..0)),\n                    Ast::Empty(span(1..1)),\n                    Ast::Empty(span(2..2)),\n                ]\n            ))\n        );\n        assert_eq!(\n            parser(r\"a|\").parse(),\n            Ok(alt(0..2, vec![lit('a', 0), Ast::Empty(span(2..2)),]))\n        );\n        assert_eq!(\n            parser(r\"|a\").parse(),\n            Ok(alt(0..2, vec![Ast::Empty(span(0..0)), lit('a', 1),]))\n        );\n\n        assert_eq!(\n            parser(r\"(|)\").parse(),\n            Ok(group(\n                0..3,\n                1,\n                alt(\n                    1..2,\n                    vec![Ast::Empty(span(1..1)), Ast::Empty(span(2..2)),]\n                )\n            ))\n        );\n        assert_eq!(\n            parser(r\"(a|)\").parse(),\n            Ok(group(\n                0..4,\n                1,\n                alt(1..3, vec![lit('a', 1), Ast::Empty(span(3..3)),])\n            ))\n        );\n        assert_eq!(\n            parser(r\"(|a)\").parse(),\n            Ok(group(\n                0..4,\n                1,\n                alt(1..3, vec![Ast::Empty(span(1..1)), lit('a', 2),])\n            ))\n        );\n\n        assert_eq!(\n            parser(r\"a|b)\").parse().unwrap_err(),\n            TestError {\n                span: span(3..4),\n                kind: ast::ErrorKind::GroupUnopened,\n            }\n        );\n        assert_eq!(\n            parser(r\"(a|b\").parse().unwrap_err(),\n            TestError {\n                span: span(0..1),\n                kind: ast::ErrorKind::GroupUnclosed,\n            }\n        );\n    }\n\n    #[test]\n    fn parse_unsupported_lookaround() {\n        assert_eq!(\n            parser(r\"(?=a)\").parse().unwrap_err(),\n            TestError {\n                span: span(0..3),\n                kind: ast::ErrorKind::UnsupportedLookAround,\n            }\n        );\n        assert_eq!(\n            parser(r\"(?!a)\").parse().unwrap_err(),\n            TestError {\n                span: span(0..3),\n                kind: ast::ErrorKind::UnsupportedLookAround,\n            }\n        );\n        assert_eq!(\n            parser(r\"(?<=a)\").parse().unwrap_err(),\n            TestError {\n                span: span(0..4),\n                kind: ast::ErrorKind::UnsupportedLookAround,\n            }\n        );\n        assert_eq!(\n            parser(r\"(?<!a)\").parse().unwrap_err(),\n            TestError {\n                span: span(0..4),\n                kind: ast::ErrorKind::UnsupportedLookAround,\n            }\n        );\n    }\n\n    #[test]\n    fn parse_group() {\n        assert_eq!(\n            parser(\"(?i)\").parse(),\n            Ok(Ast::Flags(ast::SetFlags {\n                span: span(0..4),\n                flags: ast::Flags {\n                    span: span(2..3),\n                    items: vec![ast::FlagsItem {\n                        span: span(2..3),\n                        kind: ast::FlagsItemKind::Flag(\n                            ast::Flag::CaseInsensitive\n                        ),\n                    }],\n                },\n            }))\n        );\n        assert_eq!(\n            parser(\"(?iU)\").parse(),\n            Ok(Ast::Flags(ast::SetFlags {\n                span: span(0..5),\n                flags: ast::Flags {\n                    span: span(2..4),\n                    items: vec![\n                        ast::FlagsItem {\n                            span: span(2..3),\n                            kind: ast::FlagsItemKind::Flag(\n                                ast::Flag::CaseInsensitive\n                            ),\n                        },\n                        ast::FlagsItem {\n                            span: span(3..4),\n                            kind: ast::FlagsItemKind::Flag(\n                                ast::Flag::SwapGreed\n                            ),\n                        },\n                    ],\n                },\n            }))\n        );\n        assert_eq!(\n            parser(\"(?i-U)\").parse(),\n            Ok(Ast::Flags(ast::SetFlags {\n                span: span(0..6),\n                flags: ast::Flags {\n                    span: span(2..5),\n                    items: vec![\n                        ast::FlagsItem {\n                            span: span(2..3),\n                            kind: ast::FlagsItemKind::Flag(\n                                ast::Flag::CaseInsensitive\n                            ),\n                        },\n                        ast::FlagsItem {\n                            span: span(3..4),\n                            kind: ast::FlagsItemKind::Negation,\n                        },\n                        ast::FlagsItem {\n                            span: span(4..5),\n                            kind: ast::FlagsItemKind::Flag(\n                                ast::Flag::SwapGreed\n                            ),\n                        },\n                    ],\n                },\n            }))\n        );\n\n        assert_eq!(\n            parser(\"()\").parse(),\n            Ok(Ast::Group(ast::Group {\n                span: span(0..2),\n                kind: ast::GroupKind::CaptureIndex(1),\n                ast: Box::new(Ast::Empty(span(1..1))),\n            }))\n        );\n        assert_eq!(\n            parser(\"(a)\").parse(),\n            Ok(Ast::Group(ast::Group {\n                span: span(0..3),\n                kind: ast::GroupKind::CaptureIndex(1),\n                ast: Box::new(lit('a', 1)),\n            }))\n        );\n        assert_eq!(\n            parser(\"(())\").parse(),\n            Ok(Ast::Group(ast::Group {\n                span: span(0..4),\n                kind: ast::GroupKind::CaptureIndex(1),\n                ast: Box::new(Ast::Group(ast::Group {\n                    span: span(1..3),\n                    kind: ast::GroupKind::CaptureIndex(2),\n                    ast: Box::new(Ast::Empty(span(2..2))),\n                })),\n            }))\n        );\n\n        assert_eq!(\n            parser(\"(?:a)\").parse(),\n            Ok(Ast::Group(ast::Group {\n                span: span(0..5),\n                kind: ast::GroupKind::NonCapturing(ast::Flags {\n                    span: span(2..2),\n                    items: vec![],\n                }),\n                ast: Box::new(lit('a', 3)),\n            }))\n        );\n\n        assert_eq!(\n            parser(\"(?i:a)\").parse(),\n            Ok(Ast::Group(ast::Group {\n                span: span(0..6),\n                kind: ast::GroupKind::NonCapturing(ast::Flags {\n                    span: span(2..3),\n                    items: vec![ast::FlagsItem {\n                        span: span(2..3),\n                        kind: ast::FlagsItemKind::Flag(\n                            ast::Flag::CaseInsensitive\n                        ),\n                    },],\n                }),\n                ast: Box::new(lit('a', 4)),\n            }))\n        );\n        assert_eq!(\n            parser(\"(?i-U:a)\").parse(),\n            Ok(Ast::Group(ast::Group {\n                span: span(0..8),\n                kind: ast::GroupKind::NonCapturing(ast::Flags {\n                    span: span(2..5),\n                    items: vec![\n                        ast::FlagsItem {\n                            span: span(2..3),\n                            kind: ast::FlagsItemKind::Flag(\n                                ast::Flag::CaseInsensitive\n                            ),\n                        },\n                        ast::FlagsItem {\n                            span: span(3..4),\n                            kind: ast::FlagsItemKind::Negation,\n                        },\n                        ast::FlagsItem {\n                            span: span(4..5),\n                            kind: ast::FlagsItemKind::Flag(\n                                ast::Flag::SwapGreed\n                            ),\n                        },\n                    ],\n                }),\n                ast: Box::new(lit('a', 6)),\n            }))\n        );\n\n        assert_eq!(\n            parser(\"(\").parse().unwrap_err(),\n            TestError {\n                span: span(0..1),\n                kind: ast::ErrorKind::GroupUnclosed,\n            }\n        );\n        assert_eq!(\n            parser(\"(?\").parse().unwrap_err(),\n            TestError {\n                span: span(0..1),\n                kind: ast::ErrorKind::GroupUnclosed,\n            }\n        );\n        assert_eq!(\n            parser(\"(?P\").parse().unwrap_err(),\n            TestError {\n                span: span(2..3),\n                kind: ast::ErrorKind::FlagUnrecognized,\n            }\n        );\n        assert_eq!(\n            parser(\"(?P<\").parse().unwrap_err(),\n            TestError {\n                span: span(4..4),\n                kind: ast::ErrorKind::GroupNameUnexpectedEof,\n            }\n        );\n        assert_eq!(\n            parser(\"(a\").parse().unwrap_err(),\n            TestError {\n                span: span(0..1),\n                kind: ast::ErrorKind::GroupUnclosed,\n            }\n        );\n        assert_eq!(\n            parser(\"(()\").parse().unwrap_err(),\n            TestError {\n                span: span(0..1),\n                kind: ast::ErrorKind::GroupUnclosed,\n            }\n        );\n        assert_eq!(\n            parser(\")\").parse().unwrap_err(),\n            TestError {\n                span: span(0..1),\n                kind: ast::ErrorKind::GroupUnopened,\n            }\n        );\n        assert_eq!(\n            parser(\"a)\").parse().unwrap_err(),\n            TestError {\n                span: span(1..2),\n                kind: ast::ErrorKind::GroupUnopened,\n            }\n        );\n    }\n\n    #[test]\n    fn parse_capture_name() {\n        assert_eq!(\n            parser(\"(?P<a>z)\").parse(),\n            Ok(Ast::Group(ast::Group {\n                span: span(0..8),\n                kind: ast::GroupKind::CaptureName(ast::CaptureName {\n                    span: span(4..5),\n                    name: s(\"a\"),\n                    index: 1,\n                }),\n                ast: Box::new(lit('z', 6)),\n            }))\n        );\n        assert_eq!(\n            parser(\"(?P<abc>z)\").parse(),\n            Ok(Ast::Group(ast::Group {\n                span: span(0..10),\n                kind: ast::GroupKind::CaptureName(ast::CaptureName {\n                    span: span(4..7),\n                    name: s(\"abc\"),\n                    index: 1,\n                }),\n                ast: Box::new(lit('z', 8)),\n            }))\n        );\n\n        assert_eq!(\n            parser(\"(?P<\").parse().unwrap_err(),\n            TestError {\n                span: span(4..4),\n                kind: ast::ErrorKind::GroupNameUnexpectedEof,\n            }\n        );\n        assert_eq!(\n            parser(\"(?P<>z)\").parse().unwrap_err(),\n            TestError {\n                span: span(4..4),\n                kind: ast::ErrorKind::GroupNameEmpty,\n            }\n        );\n        assert_eq!(\n            parser(\"(?P<a\").parse().unwrap_err(),\n            TestError {\n                span: span(5..5),\n                kind: ast::ErrorKind::GroupNameUnexpectedEof,\n            }\n        );\n        assert_eq!(\n            parser(\"(?P<ab\").parse().unwrap_err(),\n            TestError {\n                span: span(6..6),\n                kind: ast::ErrorKind::GroupNameUnexpectedEof,\n            }\n        );\n        assert_eq!(\n            parser(\"(?P<0a\").parse().unwrap_err(),\n            TestError {\n                span: span(4..5),\n                kind: ast::ErrorKind::GroupNameInvalid,\n            }\n        );\n        assert_eq!(\n            parser(\"(?P<~\").parse().unwrap_err(),\n            TestError {\n                span: span(4..5),\n                kind: ast::ErrorKind::GroupNameInvalid,\n            }\n        );\n        assert_eq!(\n            parser(\"(?P<abc~\").parse().unwrap_err(),\n            TestError {\n                span: span(7..8),\n                kind: ast::ErrorKind::GroupNameInvalid,\n            }\n        );\n        assert_eq!(\n            parser(\"(?P<a>y)(?P<a>z)\").parse().unwrap_err(),\n            TestError {\n                span: span(12..13),\n                kind: ast::ErrorKind::GroupNameDuplicate {\n                    original: span(4..5),\n                },\n            }\n        );\n    }\n\n    #[test]\n    fn parse_flags() {\n        assert_eq!(\n            parser(\"i:\").parse_flags(),\n            Ok(ast::Flags {\n                span: span(0..1),\n                items: vec![ast::FlagsItem {\n                    span: span(0..1),\n                    kind: ast::FlagsItemKind::Flag(ast::Flag::CaseInsensitive),\n                }],\n            })\n        );\n        assert_eq!(\n            parser(\"i)\").parse_flags(),\n            Ok(ast::Flags {\n                span: span(0..1),\n                items: vec![ast::FlagsItem {\n                    span: span(0..1),\n                    kind: ast::FlagsItemKind::Flag(ast::Flag::CaseInsensitive),\n                }],\n            })\n        );\n\n        assert_eq!(\n            parser(\"isU:\").parse_flags(),\n            Ok(ast::Flags {\n                span: span(0..3),\n                items: vec![\n                    ast::FlagsItem {\n                        span: span(0..1),\n                        kind: ast::FlagsItemKind::Flag(\n                            ast::Flag::CaseInsensitive\n                        ),\n                    },\n                    ast::FlagsItem {\n                        span: span(1..2),\n                        kind: ast::FlagsItemKind::Flag(\n                            ast::Flag::DotMatchesNewLine\n                        ),\n                    },\n                    ast::FlagsItem {\n                        span: span(2..3),\n                        kind: ast::FlagsItemKind::Flag(ast::Flag::SwapGreed),\n                    },\n                ],\n            })\n        );\n\n        assert_eq!(\n            parser(\"-isU:\").parse_flags(),\n            Ok(ast::Flags {\n                span: span(0..4),\n                items: vec![\n                    ast::FlagsItem {\n                        span: span(0..1),\n                        kind: ast::FlagsItemKind::Negation,\n                    },\n                    ast::FlagsItem {\n                        span: span(1..2),\n                        kind: ast::FlagsItemKind::Flag(\n                            ast::Flag::CaseInsensitive\n                        ),\n                    },\n                    ast::FlagsItem {\n                        span: span(2..3),\n                        kind: ast::FlagsItemKind::Flag(\n                            ast::Flag::DotMatchesNewLine\n                        ),\n                    },\n                    ast::FlagsItem {\n                        span: span(3..4),\n                        kind: ast::FlagsItemKind::Flag(ast::Flag::SwapGreed),\n                    },\n                ],\n            })\n        );\n        assert_eq!(\n            parser(\"i-sU:\").parse_flags(),\n            Ok(ast::Flags {\n                span: span(0..4),\n                items: vec![\n                    ast::FlagsItem {\n                        span: span(0..1),\n                        kind: ast::FlagsItemKind::Flag(\n                            ast::Flag::CaseInsensitive\n                        ),\n                    },\n                    ast::FlagsItem {\n                        span: span(1..2),\n                        kind: ast::FlagsItemKind::Negation,\n                    },\n                    ast::FlagsItem {\n                        span: span(2..3),\n                        kind: ast::FlagsItemKind::Flag(\n                            ast::Flag::DotMatchesNewLine\n                        ),\n                    },\n                    ast::FlagsItem {\n                        span: span(3..4),\n                        kind: ast::FlagsItemKind::Flag(ast::Flag::SwapGreed),\n                    },\n                ],\n            })\n        );\n\n        assert_eq!(\n            parser(\"isU\").parse_flags().unwrap_err(),\n            TestError {\n                span: span(3..3),\n                kind: ast::ErrorKind::FlagUnexpectedEof,\n            }\n        );\n        assert_eq!(\n            parser(\"isUa:\").parse_flags().unwrap_err(),\n            TestError {\n                span: span(3..4),\n                kind: ast::ErrorKind::FlagUnrecognized,\n            }\n        );\n        assert_eq!(\n            parser(\"isUi:\").parse_flags().unwrap_err(),\n            TestError {\n                span: span(3..4),\n                kind: ast::ErrorKind::FlagDuplicate { original: span(0..1) },\n            }\n        );\n        assert_eq!(\n            parser(\"i-sU-i:\").parse_flags().unwrap_err(),\n            TestError {\n                span: span(4..5),\n                kind: ast::ErrorKind::FlagRepeatedNegation {\n                    original: span(1..2),\n                },\n            }\n        );\n        assert_eq!(\n            parser(\"-)\").parse_flags().unwrap_err(),\n            TestError {\n                span: span(0..1),\n                kind: ast::ErrorKind::FlagDanglingNegation,\n            }\n        );\n        assert_eq!(\n            parser(\"i-)\").parse_flags().unwrap_err(),\n            TestError {\n                span: span(1..2),\n                kind: ast::ErrorKind::FlagDanglingNegation,\n            }\n        );\n        assert_eq!(\n            parser(\"iU-)\").parse_flags().unwrap_err(),\n            TestError {\n                span: span(2..3),\n                kind: ast::ErrorKind::FlagDanglingNegation,\n            }\n        );\n    }\n\n    #[test]\n    fn parse_flag() {\n        assert_eq!(parser(\"i\").parse_flag(), Ok(ast::Flag::CaseInsensitive));\n        assert_eq!(parser(\"m\").parse_flag(), Ok(ast::Flag::MultiLine));\n        assert_eq!(parser(\"s\").parse_flag(), Ok(ast::Flag::DotMatchesNewLine));\n        assert_eq!(parser(\"U\").parse_flag(), Ok(ast::Flag::SwapGreed));\n        assert_eq!(parser(\"u\").parse_flag(), Ok(ast::Flag::Unicode));\n        assert_eq!(parser(\"x\").parse_flag(), Ok(ast::Flag::IgnoreWhitespace));\n\n        assert_eq!(\n            parser(\"a\").parse_flag().unwrap_err(),\n            TestError {\n                span: span(0..1),\n                kind: ast::ErrorKind::FlagUnrecognized,\n            }\n        );\n        assert_eq!(\n            parser(\"☃\").parse_flag().unwrap_err(),\n            TestError {\n                span: span_range(\"☃\", 0..3),\n                kind: ast::ErrorKind::FlagUnrecognized,\n            }\n        );\n    }\n\n    #[test]\n    fn parse_primitive_non_escape() {\n        assert_eq!(\n            parser(r\".\").parse_primitive(),\n            Ok(Primitive::Dot(span(0..1)))\n        );\n        assert_eq!(\n            parser(r\"^\").parse_primitive(),\n            Ok(Primitive::Assertion(ast::Assertion {\n                span: span(0..1),\n                kind: ast::AssertionKind::StartLine,\n            }))\n        );\n        assert_eq!(\n            parser(r\"$\").parse_primitive(),\n            Ok(Primitive::Assertion(ast::Assertion {\n                span: span(0..1),\n                kind: ast::AssertionKind::EndLine,\n            }))\n        );\n\n        assert_eq!(\n            parser(r\"a\").parse_primitive(),\n            Ok(Primitive::Literal(ast::Literal {\n                span: span(0..1),\n                kind: ast::LiteralKind::Verbatim,\n                c: 'a',\n            }))\n        );\n        assert_eq!(\n            parser(r\"|\").parse_primitive(),\n            Ok(Primitive::Literal(ast::Literal {\n                span: span(0..1),\n                kind: ast::LiteralKind::Verbatim,\n                c: '|',\n            }))\n        );\n        assert_eq!(\n            parser(r\"☃\").parse_primitive(),\n            Ok(Primitive::Literal(ast::Literal {\n                span: span_range(\"☃\", 0..3),\n                kind: ast::LiteralKind::Verbatim,\n                c: '☃',\n            }))\n        );\n    }\n\n    #[test]\n    fn parse_escape() {\n        assert_eq!(\n            parser(r\"\\|\").parse_primitive(),\n            Ok(Primitive::Literal(ast::Literal {\n                span: span(0..2),\n                kind: ast::LiteralKind::Punctuation,\n                c: '|',\n            }))\n        );\n        let specials = &[\n            (r\"\\a\", '\\x07', ast::SpecialLiteralKind::Bell),\n            (r\"\\f\", '\\x0C', ast::SpecialLiteralKind::FormFeed),\n            (r\"\\t\", '\\t', ast::SpecialLiteralKind::Tab),\n            (r\"\\n\", '\\n', ast::SpecialLiteralKind::LineFeed),\n            (r\"\\r\", '\\r', ast::SpecialLiteralKind::CarriageReturn),\n            (r\"\\v\", '\\x0B', ast::SpecialLiteralKind::VerticalTab),\n        ];\n        for &(pat, c, ref kind) in specials {\n            assert_eq!(\n                parser(pat).parse_primitive(),\n                Ok(Primitive::Literal(ast::Literal {\n                    span: span(0..2),\n                    kind: ast::LiteralKind::Special(kind.clone()),\n                    c: c,\n                }))\n            );\n        }\n        assert_eq!(\n            parser(r\"\\A\").parse_primitive(),\n            Ok(Primitive::Assertion(ast::Assertion {\n                span: span(0..2),\n                kind: ast::AssertionKind::StartText,\n            }))\n        );\n        assert_eq!(\n            parser(r\"\\z\").parse_primitive(),\n            Ok(Primitive::Assertion(ast::Assertion {\n                span: span(0..2),\n                kind: ast::AssertionKind::EndText,\n            }))\n        );\n        assert_eq!(\n            parser(r\"\\b\").parse_primitive(),\n            Ok(Primitive::Assertion(ast::Assertion {\n                span: span(0..2),\n                kind: ast::AssertionKind::WordBoundary,\n            }))\n        );\n        assert_eq!(\n            parser(r\"\\B\").parse_primitive(),\n            Ok(Primitive::Assertion(ast::Assertion {\n                span: span(0..2),\n                kind: ast::AssertionKind::NotWordBoundary,\n            }))\n        );\n\n        assert_eq!(\n            parser(r\"\\\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(0..1),\n                kind: ast::ErrorKind::EscapeUnexpectedEof,\n            }\n        );\n        assert_eq!(\n            parser(r\"\\y\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(0..2),\n                kind: ast::ErrorKind::EscapeUnrecognized,\n            }\n        );\n    }\n\n    #[test]\n    fn parse_unsupported_backreference() {\n        assert_eq!(\n            parser(r\"\\0\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(0..2),\n                kind: ast::ErrorKind::UnsupportedBackreference,\n            }\n        );\n        assert_eq!(\n            parser(r\"\\9\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(0..2),\n                kind: ast::ErrorKind::UnsupportedBackreference,\n            }\n        );\n    }\n\n    #[test]\n    fn parse_octal() {\n        for i in 0..511 {\n            let pat = format!(r\"\\{:o}\", i);\n            assert_eq!(\n                parser_octal(&pat).parse_escape(),\n                Ok(Primitive::Literal(ast::Literal {\n                    span: span(0..pat.len()),\n                    kind: ast::LiteralKind::Octal,\n                    c: ::std::char::from_u32(i).unwrap(),\n                }))\n            );\n        }\n        assert_eq!(\n            parser_octal(r\"\\778\").parse_escape(),\n            Ok(Primitive::Literal(ast::Literal {\n                span: span(0..3),\n                kind: ast::LiteralKind::Octal,\n                c: '?',\n            }))\n        );\n        assert_eq!(\n            parser_octal(r\"\\7777\").parse_escape(),\n            Ok(Primitive::Literal(ast::Literal {\n                span: span(0..4),\n                kind: ast::LiteralKind::Octal,\n                c: '\\u{01FF}',\n            }))\n        );\n        assert_eq!(\n            parser_octal(r\"\\778\").parse(),\n            Ok(Ast::Concat(ast::Concat {\n                span: span(0..4),\n                asts: vec![\n                    Ast::Literal(ast::Literal {\n                        span: span(0..3),\n                        kind: ast::LiteralKind::Octal,\n                        c: '?',\n                    }),\n                    Ast::Literal(ast::Literal {\n                        span: span(3..4),\n                        kind: ast::LiteralKind::Verbatim,\n                        c: '8',\n                    }),\n                ],\n            }))\n        );\n        assert_eq!(\n            parser_octal(r\"\\7777\").parse(),\n            Ok(Ast::Concat(ast::Concat {\n                span: span(0..5),\n                asts: vec![\n                    Ast::Literal(ast::Literal {\n                        span: span(0..4),\n                        kind: ast::LiteralKind::Octal,\n                        c: '\\u{01FF}',\n                    }),\n                    Ast::Literal(ast::Literal {\n                        span: span(4..5),\n                        kind: ast::LiteralKind::Verbatim,\n                        c: '7',\n                    }),\n                ],\n            }))\n        );\n\n        assert_eq!(\n            parser_octal(r\"\\8\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(0..2),\n                kind: ast::ErrorKind::EscapeUnrecognized,\n            }\n        );\n    }\n\n    #[test]\n    fn parse_hex_two() {\n        for i in 0..256 {\n            let pat = format!(r\"\\x{:02x}\", i);\n            assert_eq!(\n                parser(&pat).parse_escape(),\n                Ok(Primitive::Literal(ast::Literal {\n                    span: span(0..pat.len()),\n                    kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X),\n                    c: ::std::char::from_u32(i).unwrap(),\n                }))\n            );\n        }\n\n        assert_eq!(\n            parser(r\"\\xF\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(3..3),\n                kind: ast::ErrorKind::EscapeUnexpectedEof,\n            }\n        );\n        assert_eq!(\n            parser(r\"\\xG\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(2..3),\n                kind: ast::ErrorKind::EscapeHexInvalidDigit,\n            }\n        );\n        assert_eq!(\n            parser(r\"\\xFG\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(3..4),\n                kind: ast::ErrorKind::EscapeHexInvalidDigit,\n            }\n        );\n    }\n\n    #[test]\n    fn parse_hex_four() {\n        for i in 0..65536 {\n            let c = match ::std::char::from_u32(i) {\n                None => continue,\n                Some(c) => c,\n            };\n            let pat = format!(r\"\\u{:04x}\", i);\n            assert_eq!(\n                parser(&pat).parse_escape(),\n                Ok(Primitive::Literal(ast::Literal {\n                    span: span(0..pat.len()),\n                    kind: ast::LiteralKind::HexFixed(\n                        ast::HexLiteralKind::UnicodeShort\n                    ),\n                    c: c,\n                }))\n            );\n        }\n\n        assert_eq!(\n            parser(r\"\\uF\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(3..3),\n                kind: ast::ErrorKind::EscapeUnexpectedEof,\n            }\n        );\n        assert_eq!(\n            parser(r\"\\uG\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(2..3),\n                kind: ast::ErrorKind::EscapeHexInvalidDigit,\n            }\n        );\n        assert_eq!(\n            parser(r\"\\uFG\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(3..4),\n                kind: ast::ErrorKind::EscapeHexInvalidDigit,\n            }\n        );\n        assert_eq!(\n            parser(r\"\\uFFG\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(4..5),\n                kind: ast::ErrorKind::EscapeHexInvalidDigit,\n            }\n        );\n        assert_eq!(\n            parser(r\"\\uFFFG\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(5..6),\n                kind: ast::ErrorKind::EscapeHexInvalidDigit,\n            }\n        );\n        assert_eq!(\n            parser(r\"\\uD800\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(2..6),\n                kind: ast::ErrorKind::EscapeHexInvalid,\n            }\n        );\n    }\n\n    #[test]\n    fn parse_hex_eight() {\n        for i in 0..65536 {\n            let c = match ::std::char::from_u32(i) {\n                None => continue,\n                Some(c) => c,\n            };\n            let pat = format!(r\"\\U{:08x}\", i);\n            assert_eq!(\n                parser(&pat).parse_escape(),\n                Ok(Primitive::Literal(ast::Literal {\n                    span: span(0..pat.len()),\n                    kind: ast::LiteralKind::HexFixed(\n                        ast::HexLiteralKind::UnicodeLong\n                    ),\n                    c: c,\n                }))\n            );\n        }\n\n        assert_eq!(\n            parser(r\"\\UF\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(3..3),\n                kind: ast::ErrorKind::EscapeUnexpectedEof,\n            }\n        );\n        assert_eq!(\n            parser(r\"\\UG\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(2..3),\n                kind: ast::ErrorKind::EscapeHexInvalidDigit,\n            }\n        );\n        assert_eq!(\n            parser(r\"\\UFG\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(3..4),\n                kind: ast::ErrorKind::EscapeHexInvalidDigit,\n            }\n        );\n        assert_eq!(\n            parser(r\"\\UFFG\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(4..5),\n                kind: ast::ErrorKind::EscapeHexInvalidDigit,\n            }\n        );\n        assert_eq!(\n            parser(r\"\\UFFFG\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(5..6),\n                kind: ast::ErrorKind::EscapeHexInvalidDigit,\n            }\n        );\n        assert_eq!(\n            parser(r\"\\UFFFFG\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(6..7),\n                kind: ast::ErrorKind::EscapeHexInvalidDigit,\n            }\n        );\n        assert_eq!(\n            parser(r\"\\UFFFFFG\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(7..8),\n                kind: ast::ErrorKind::EscapeHexInvalidDigit,\n            }\n        );\n        assert_eq!(\n            parser(r\"\\UFFFFFFG\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(8..9),\n                kind: ast::ErrorKind::EscapeHexInvalidDigit,\n            }\n        );\n        assert_eq!(\n            parser(r\"\\UFFFFFFFG\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(9..10),\n                kind: ast::ErrorKind::EscapeHexInvalidDigit,\n            }\n        );\n    }\n\n    #[test]\n    fn parse_hex_brace() {\n        assert_eq!(\n            parser(r\"\\u{26c4}\").parse_escape(),\n            Ok(Primitive::Literal(ast::Literal {\n                span: span(0..8),\n                kind: ast::LiteralKind::HexBrace(\n                    ast::HexLiteralKind::UnicodeShort\n                ),\n                c: '⛄',\n            }))\n        );\n        assert_eq!(\n            parser(r\"\\U{26c4}\").parse_escape(),\n            Ok(Primitive::Literal(ast::Literal {\n                span: span(0..8),\n                kind: ast::LiteralKind::HexBrace(\n                    ast::HexLiteralKind::UnicodeLong\n                ),\n                c: '⛄',\n            }))\n        );\n        assert_eq!(\n            parser(r\"\\x{26c4}\").parse_escape(),\n            Ok(Primitive::Literal(ast::Literal {\n                span: span(0..8),\n                kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),\n                c: '⛄',\n            }))\n        );\n        assert_eq!(\n            parser(r\"\\x{26C4}\").parse_escape(),\n            Ok(Primitive::Literal(ast::Literal {\n                span: span(0..8),\n                kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),\n                c: '⛄',\n            }))\n        );\n        assert_eq!(\n            parser(r\"\\x{10fFfF}\").parse_escape(),\n            Ok(Primitive::Literal(ast::Literal {\n                span: span(0..10),\n                kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),\n                c: '\\u{10FFFF}',\n            }))\n        );\n\n        assert_eq!(\n            parser(r\"\\x\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(2..2),\n                kind: ast::ErrorKind::EscapeUnexpectedEof,\n            }\n        );\n        assert_eq!(\n            parser(r\"\\x{\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(2..3),\n                kind: ast::ErrorKind::EscapeUnexpectedEof,\n            }\n        );\n        assert_eq!(\n            parser(r\"\\x{FF\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(2..5),\n                kind: ast::ErrorKind::EscapeUnexpectedEof,\n            }\n        );\n        assert_eq!(\n            parser(r\"\\x{}\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(2..4),\n                kind: ast::ErrorKind::EscapeHexEmpty,\n            }\n        );\n        assert_eq!(\n            parser(r\"\\x{FGF}\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(4..5),\n                kind: ast::ErrorKind::EscapeHexInvalidDigit,\n            }\n        );\n        assert_eq!(\n            parser(r\"\\x{FFFFFF}\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(3..9),\n                kind: ast::ErrorKind::EscapeHexInvalid,\n            }\n        );\n        assert_eq!(\n            parser(r\"\\x{D800}\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(3..7),\n                kind: ast::ErrorKind::EscapeHexInvalid,\n            }\n        );\n        assert_eq!(\n            parser(r\"\\x{FFFFFFFFF}\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(3..12),\n                kind: ast::ErrorKind::EscapeHexInvalid,\n            }\n        );\n    }\n\n    #[test]\n    fn parse_decimal() {\n        assert_eq!(parser(\"123\").parse_decimal(), Ok(123));\n        assert_eq!(parser(\"0\").parse_decimal(), Ok(0));\n        assert_eq!(parser(\"01\").parse_decimal(), Ok(1));\n\n        assert_eq!(\n            parser(\"-1\").parse_decimal().unwrap_err(),\n            TestError { span: span(0..0), kind: ast::ErrorKind::DecimalEmpty }\n        );\n        assert_eq!(\n            parser(\"\").parse_decimal().unwrap_err(),\n            TestError { span: span(0..0), kind: ast::ErrorKind::DecimalEmpty }\n        );\n        assert_eq!(\n            parser(\"9999999999\").parse_decimal().unwrap_err(),\n            TestError {\n                span: span(0..10),\n                kind: ast::ErrorKind::DecimalInvalid,\n            }\n        );\n    }\n\n    #[test]\n    fn parse_set_class() {\n        fn union(span: Span, items: Vec<ast::ClassSetItem>) -> ast::ClassSet {\n            ast::ClassSet::union(ast::ClassSetUnion {\n                span: span,\n                items: items,\n            })\n        }\n\n        fn intersection(\n            span: Span,\n            lhs: ast::ClassSet,\n            rhs: ast::ClassSet,\n        ) -> ast::ClassSet {\n            ast::ClassSet::BinaryOp(ast::ClassSetBinaryOp {\n                span: span,\n                kind: ast::ClassSetBinaryOpKind::Intersection,\n                lhs: Box::new(lhs),\n                rhs: Box::new(rhs),\n            })\n        }\n\n        fn difference(\n            span: Span,\n            lhs: ast::ClassSet,\n            rhs: ast::ClassSet,\n        ) -> ast::ClassSet {\n            ast::ClassSet::BinaryOp(ast::ClassSetBinaryOp {\n                span: span,\n                kind: ast::ClassSetBinaryOpKind::Difference,\n                lhs: Box::new(lhs),\n                rhs: Box::new(rhs),\n            })\n        }\n\n        fn symdifference(\n            span: Span,\n            lhs: ast::ClassSet,\n            rhs: ast::ClassSet,\n        ) -> ast::ClassSet {\n            ast::ClassSet::BinaryOp(ast::ClassSetBinaryOp {\n                span: span,\n                kind: ast::ClassSetBinaryOpKind::SymmetricDifference,\n                lhs: Box::new(lhs),\n                rhs: Box::new(rhs),\n            })\n        }\n\n        fn itemset(item: ast::ClassSetItem) -> ast::ClassSet {\n            ast::ClassSet::Item(item)\n        }\n\n        fn item_ascii(cls: ast::ClassAscii) -> ast::ClassSetItem {\n            ast::ClassSetItem::Ascii(cls)\n        }\n\n        fn item_unicode(cls: ast::ClassUnicode) -> ast::ClassSetItem {\n            ast::ClassSetItem::Unicode(cls)\n        }\n\n        fn item_perl(cls: ast::ClassPerl) -> ast::ClassSetItem {\n            ast::ClassSetItem::Perl(cls)\n        }\n\n        fn item_bracket(cls: ast::ClassBracketed) -> ast::ClassSetItem {\n            ast::ClassSetItem::Bracketed(Box::new(cls))\n        }\n\n        fn lit(span: Span, c: char) -> ast::ClassSetItem {\n            ast::ClassSetItem::Literal(ast::Literal {\n                span: span,\n                kind: ast::LiteralKind::Verbatim,\n                c: c,\n            })\n        }\n\n        fn empty(span: Span) -> ast::ClassSetItem {\n            ast::ClassSetItem::Empty(span)\n        }\n\n        fn range(span: Span, start: char, end: char) -> ast::ClassSetItem {\n            let pos1 = Position {\n                offset: span.start.offset + start.len_utf8(),\n                column: span.start.column + 1,\n                ..span.start\n            };\n            let pos2 = Position {\n                offset: span.end.offset - end.len_utf8(),\n                column: span.end.column - 1,\n                ..span.end\n            };\n            ast::ClassSetItem::Range(ast::ClassSetRange {\n                span: span,\n                start: ast::Literal {\n                    span: Span { end: pos1, ..span },\n                    kind: ast::LiteralKind::Verbatim,\n                    c: start,\n                },\n                end: ast::Literal {\n                    span: Span { start: pos2, ..span },\n                    kind: ast::LiteralKind::Verbatim,\n                    c: end,\n                },\n            })\n        }\n\n        fn alnum(span: Span, negated: bool) -> ast::ClassAscii {\n            ast::ClassAscii {\n                span: span,\n                kind: ast::ClassAsciiKind::Alnum,\n                negated: negated,\n            }\n        }\n\n        fn lower(span: Span, negated: bool) -> ast::ClassAscii {\n            ast::ClassAscii {\n                span: span,\n                kind: ast::ClassAsciiKind::Lower,\n                negated: negated,\n            }\n        }\n\n        assert_eq!(\n            parser(\"[[:alnum:]]\").parse(),\n            Ok(Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {\n                span: span(0..11),\n                negated: false,\n                kind: itemset(item_ascii(alnum(span(1..10), false))),\n            })))\n        );\n        assert_eq!(\n            parser(\"[[[:alnum:]]]\").parse(),\n            Ok(Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {\n                span: span(0..13),\n                negated: false,\n                kind: itemset(item_bracket(ast::ClassBracketed {\n                    span: span(1..12),\n                    negated: false,\n                    kind: itemset(item_ascii(alnum(span(2..11), false))),\n                })),\n            })))\n        );\n        assert_eq!(\n            parser(\"[[:alnum:]&&[:lower:]]\").parse(),\n            Ok(Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {\n                span: span(0..22),\n                negated: false,\n                kind: intersection(\n                    span(1..21),\n                    itemset(item_ascii(alnum(span(1..10), false))),\n                    itemset(item_ascii(lower(span(12..21), false))),\n                ),\n            })))\n        );\n        assert_eq!(\n            parser(\"[[:alnum:]--[:lower:]]\").parse(),\n            Ok(Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {\n                span: span(0..22),\n                negated: false,\n                kind: difference(\n                    span(1..21),\n                    itemset(item_ascii(alnum(span(1..10), false))),\n                    itemset(item_ascii(lower(span(12..21), false))),\n                ),\n            })))\n        );\n        assert_eq!(\n            parser(\"[[:alnum:]~~[:lower:]]\").parse(),\n            Ok(Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {\n                span: span(0..22),\n                negated: false,\n                kind: symdifference(\n                    span(1..21),\n                    itemset(item_ascii(alnum(span(1..10), false))),\n                    itemset(item_ascii(lower(span(12..21), false))),\n                ),\n            })))\n        );\n\n        assert_eq!(\n            parser(\"[a]\").parse(),\n            Ok(Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {\n                span: span(0..3),\n                negated: false,\n                kind: itemset(lit(span(1..2), 'a')),\n            })))\n        );\n        assert_eq!(\n            parser(r\"[a\\]]\").parse(),\n            Ok(Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {\n                span: span(0..5),\n                negated: false,\n                kind: union(\n                    span(1..4),\n                    vec![\n                        lit(span(1..2), 'a'),\n                        ast::ClassSetItem::Literal(ast::Literal {\n                            span: span(2..4),\n                            kind: ast::LiteralKind::Punctuation,\n                            c: ']',\n                        }),\n                    ]\n                ),\n            })))\n        );\n        assert_eq!(\n            parser(r\"[a\\-z]\").parse(),\n            Ok(Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {\n                span: span(0..6),\n                negated: false,\n                kind: union(\n                    span(1..5),\n                    vec![\n                        lit(span(1..2), 'a'),\n                        ast::ClassSetItem::Literal(ast::Literal {\n                            span: span(2..4),\n                            kind: ast::LiteralKind::Punctuation,\n                            c: '-',\n                        }),\n                        lit(span(4..5), 'z'),\n                    ]\n                ),\n            })))\n        );\n        assert_eq!(\n            parser(\"[ab]\").parse(),\n            Ok(Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {\n                span: span(0..4),\n                negated: false,\n                kind: union(\n                    span(1..3),\n                    vec![lit(span(1..2), 'a'), lit(span(2..3), 'b'),]\n                ),\n            })))\n        );\n        assert_eq!(\n            parser(\"[a-]\").parse(),\n            Ok(Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {\n                span: span(0..4),\n                negated: false,\n                kind: union(\n                    span(1..3),\n                    vec![lit(span(1..2), 'a'), lit(span(2..3), '-'),]\n                ),\n            })))\n        );\n        assert_eq!(\n            parser(\"[-a]\").parse(),\n            Ok(Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {\n                span: span(0..4),\n                negated: false,\n                kind: union(\n                    span(1..3),\n                    vec![lit(span(1..2), '-'), lit(span(2..3), 'a'),]\n                ),\n            })))\n        );\n        assert_eq!(\n            parser(r\"[\\pL]\").parse(),\n            Ok(Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {\n                span: span(0..5),\n                negated: false,\n                kind: itemset(item_unicode(ast::ClassUnicode {\n                    span: span(1..4),\n                    negated: false,\n                    kind: ast::ClassUnicodeKind::OneLetter('L'),\n                })),\n            })))\n        );\n        assert_eq!(\n            parser(r\"[\\w]\").parse(),\n            Ok(Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {\n                span: span(0..4),\n                negated: false,\n                kind: itemset(item_perl(ast::ClassPerl {\n                    span: span(1..3),\n                    kind: ast::ClassPerlKind::Word,\n                    negated: false,\n                })),\n            })))\n        );\n        assert_eq!(\n            parser(r\"[a\\wz]\").parse(),\n            Ok(Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {\n                span: span(0..6),\n                negated: false,\n                kind: union(\n                    span(1..5),\n                    vec![\n                        lit(span(1..2), 'a'),\n                        item_perl(ast::ClassPerl {\n                            span: span(2..4),\n                            kind: ast::ClassPerlKind::Word,\n                            negated: false,\n                        }),\n                        lit(span(4..5), 'z'),\n                    ]\n                ),\n            })))\n        );\n\n        assert_eq!(\n            parser(\"[a-z]\").parse(),\n            Ok(Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {\n                span: span(0..5),\n                negated: false,\n                kind: itemset(range(span(1..4), 'a', 'z')),\n            })))\n        );\n        assert_eq!(\n            parser(\"[a-cx-z]\").parse(),\n            Ok(Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {\n                span: span(0..8),\n                negated: false,\n                kind: union(\n                    span(1..7),\n                    vec![\n                        range(span(1..4), 'a', 'c'),\n                        range(span(4..7), 'x', 'z'),\n                    ]\n                ),\n            })))\n        );\n        assert_eq!(\n            parser(r\"[\\w&&a-cx-z]\").parse(),\n            Ok(Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {\n                span: span(0..12),\n                negated: false,\n                kind: intersection(\n                    span(1..11),\n                    itemset(item_perl(ast::ClassPerl {\n                        span: span(1..3),\n                        kind: ast::ClassPerlKind::Word,\n                        negated: false,\n                    })),\n                    union(\n                        span(5..11),\n                        vec![\n                            range(span(5..8), 'a', 'c'),\n                            range(span(8..11), 'x', 'z'),\n                        ]\n                    ),\n                ),\n            })))\n        );\n        assert_eq!(\n            parser(r\"[a-cx-z&&\\w]\").parse(),\n            Ok(Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {\n                span: span(0..12),\n                negated: false,\n                kind: intersection(\n                    span(1..11),\n                    union(\n                        span(1..7),\n                        vec![\n                            range(span(1..4), 'a', 'c'),\n                            range(span(4..7), 'x', 'z'),\n                        ]\n                    ),\n                    itemset(item_perl(ast::ClassPerl {\n                        span: span(9..11),\n                        kind: ast::ClassPerlKind::Word,\n                        negated: false,\n                    })),\n                ),\n            })))\n        );\n        assert_eq!(\n            parser(r\"[a--b--c]\").parse(),\n            Ok(Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {\n                span: span(0..9),\n                negated: false,\n                kind: difference(\n                    span(1..8),\n                    difference(\n                        span(1..5),\n                        itemset(lit(span(1..2), 'a')),\n                        itemset(lit(span(4..5), 'b')),\n                    ),\n                    itemset(lit(span(7..8), 'c')),\n                ),\n            })))\n        );\n        assert_eq!(\n            parser(r\"[a~~b~~c]\").parse(),\n            Ok(Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {\n                span: span(0..9),\n                negated: false,\n                kind: symdifference(\n                    span(1..8),\n                    symdifference(\n                        span(1..5),\n                        itemset(lit(span(1..2), 'a')),\n                        itemset(lit(span(4..5), 'b')),\n                    ),\n                    itemset(lit(span(7..8), 'c')),\n                ),\n            })))\n        );\n        assert_eq!(\n            parser(r\"[\\^&&^]\").parse(),\n            Ok(Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {\n                span: span(0..7),\n                negated: false,\n                kind: intersection(\n                    span(1..6),\n                    itemset(ast::ClassSetItem::Literal(ast::Literal {\n                        span: span(1..3),\n                        kind: ast::LiteralKind::Punctuation,\n                        c: '^',\n                    })),\n                    itemset(lit(span(5..6), '^')),\n                ),\n            })))\n        );\n        assert_eq!(\n            parser(r\"[\\&&&&]\").parse(),\n            Ok(Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {\n                span: span(0..7),\n                negated: false,\n                kind: intersection(\n                    span(1..6),\n                    itemset(ast::ClassSetItem::Literal(ast::Literal {\n                        span: span(1..3),\n                        kind: ast::LiteralKind::Punctuation,\n                        c: '&',\n                    })),\n                    itemset(lit(span(5..6), '&')),\n                ),\n            })))\n        );\n        assert_eq!(\n            parser(r\"[&&&&]\").parse(),\n            Ok(Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {\n                span: span(0..6),\n                negated: false,\n                kind: intersection(\n                    span(1..5),\n                    intersection(\n                        span(1..3),\n                        itemset(empty(span(1..1))),\n                        itemset(empty(span(3..3))),\n                    ),\n                    itemset(empty(span(5..5))),\n                ),\n            })))\n        );\n\n        let pat = \"[☃-⛄]\";\n        assert_eq!(\n            parser(pat).parse(),\n            Ok(Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {\n                span: span_range(pat, 0..9),\n                negated: false,\n                kind: itemset(ast::ClassSetItem::Range(ast::ClassSetRange {\n                    span: span_range(pat, 1..8),\n                    start: ast::Literal {\n                        span: span_range(pat, 1..4),\n                        kind: ast::LiteralKind::Verbatim,\n                        c: '☃',\n                    },\n                    end: ast::Literal {\n                        span: span_range(pat, 5..8),\n                        kind: ast::LiteralKind::Verbatim,\n                        c: '⛄',\n                    },\n                })),\n            })))\n        );\n\n        assert_eq!(\n            parser(r\"[]]\").parse(),\n            Ok(Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {\n                span: span(0..3),\n                negated: false,\n                kind: itemset(lit(span(1..2), ']')),\n            })))\n        );\n        assert_eq!(\n            parser(r\"[]\\[]\").parse(),\n            Ok(Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {\n                span: span(0..5),\n                negated: false,\n                kind: union(\n                    span(1..4),\n                    vec![\n                        lit(span(1..2), ']'),\n                        ast::ClassSetItem::Literal(ast::Literal {\n                            span: span(2..4),\n                            kind: ast::LiteralKind::Punctuation,\n                            c: '[',\n                        }),\n                    ]\n                ),\n            })))\n        );\n        assert_eq!(\n            parser(r\"[\\[]]\").parse(),\n            Ok(concat(\n                0..5,\n                vec![\n                    Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {\n                        span: span(0..4),\n                        negated: false,\n                        kind: itemset(ast::ClassSetItem::Literal(\n                            ast::Literal {\n                                span: span(1..3),\n                                kind: ast::LiteralKind::Punctuation,\n                                c: '[',\n                            }\n                        )),\n                    })),\n                    Ast::Literal(ast::Literal {\n                        span: span(4..5),\n                        kind: ast::LiteralKind::Verbatim,\n                        c: ']',\n                    }),\n                ]\n            ))\n        );\n\n        assert_eq!(\n            parser(\"[\").parse().unwrap_err(),\n            TestError {\n                span: span(0..1),\n                kind: ast::ErrorKind::ClassUnclosed,\n            }\n        );\n        assert_eq!(\n            parser(\"[[\").parse().unwrap_err(),\n            TestError {\n                span: span(1..2),\n                kind: ast::ErrorKind::ClassUnclosed,\n            }\n        );\n        assert_eq!(\n            parser(\"[[-]\").parse().unwrap_err(),\n            TestError {\n                span: span(0..1),\n                kind: ast::ErrorKind::ClassUnclosed,\n            }\n        );\n        assert_eq!(\n            parser(\"[[[:alnum:]\").parse().unwrap_err(),\n            TestError {\n                span: span(1..2),\n                kind: ast::ErrorKind::ClassUnclosed,\n            }\n        );\n        assert_eq!(\n            parser(r\"[\\b]\").parse().unwrap_err(),\n            TestError {\n                span: span(1..3),\n                kind: ast::ErrorKind::ClassEscapeInvalid,\n            }\n        );\n        assert_eq!(\n            parser(r\"[\\w-a]\").parse().unwrap_err(),\n            TestError {\n                span: span(1..3),\n                kind: ast::ErrorKind::ClassRangeLiteral,\n            }\n        );\n        assert_eq!(\n            parser(r\"[a-\\w]\").parse().unwrap_err(),\n            TestError {\n                span: span(3..5),\n                kind: ast::ErrorKind::ClassRangeLiteral,\n            }\n        );\n        assert_eq!(\n            parser(r\"[z-a]\").parse().unwrap_err(),\n            TestError {\n                span: span(1..4),\n                kind: ast::ErrorKind::ClassRangeInvalid,\n            }\n        );\n\n        assert_eq!(\n            parser_ignore_whitespace(\"[a \").parse().unwrap_err(),\n            TestError {\n                span: span(0..1),\n                kind: ast::ErrorKind::ClassUnclosed,\n            }\n        );\n        assert_eq!(\n            parser_ignore_whitespace(\"[a- \").parse().unwrap_err(),\n            TestError {\n                span: span(0..1),\n                kind: ast::ErrorKind::ClassUnclosed,\n            }\n        );\n    }\n\n    #[test]\n    fn parse_set_class_open() {\n        assert_eq!(parser(\"[a]\").parse_set_class_open(), {\n            let set = ast::ClassBracketed {\n                span: span(0..1),\n                negated: false,\n                kind: ast::ClassSet::union(ast::ClassSetUnion {\n                    span: span(1..1),\n                    items: vec![],\n                }),\n            };\n            let union = ast::ClassSetUnion { span: span(1..1), items: vec![] };\n            Ok((set, union))\n        });\n        assert_eq!(\n            parser_ignore_whitespace(\"[   a]\").parse_set_class_open(),\n            {\n                let set = ast::ClassBracketed {\n                    span: span(0..4),\n                    negated: false,\n                    kind: ast::ClassSet::union(ast::ClassSetUnion {\n                        span: span(4..4),\n                        items: vec![],\n                    }),\n                };\n                let union =\n                    ast::ClassSetUnion { span: span(4..4), items: vec![] };\n                Ok((set, union))\n            }\n        );\n        assert_eq!(parser(\"[^a]\").parse_set_class_open(), {\n            let set = ast::ClassBracketed {\n                span: span(0..2),\n                negated: true,\n                kind: ast::ClassSet::union(ast::ClassSetUnion {\n                    span: span(2..2),\n                    items: vec![],\n                }),\n            };\n            let union = ast::ClassSetUnion { span: span(2..2), items: vec![] };\n            Ok((set, union))\n        });\n        assert_eq!(\n            parser_ignore_whitespace(\"[ ^ a]\").parse_set_class_open(),\n            {\n                let set = ast::ClassBracketed {\n                    span: span(0..4),\n                    negated: true,\n                    kind: ast::ClassSet::union(ast::ClassSetUnion {\n                        span: span(4..4),\n                        items: vec![],\n                    }),\n                };\n                let union =\n                    ast::ClassSetUnion { span: span(4..4), items: vec![] };\n                Ok((set, union))\n            }\n        );\n        assert_eq!(parser(\"[-a]\").parse_set_class_open(), {\n            let set = ast::ClassBracketed {\n                span: span(0..2),\n                negated: false,\n                kind: ast::ClassSet::union(ast::ClassSetUnion {\n                    span: span(1..1),\n                    items: vec![],\n                }),\n            };\n            let union = ast::ClassSetUnion {\n                span: span(1..2),\n                items: vec![ast::ClassSetItem::Literal(ast::Literal {\n                    span: span(1..2),\n                    kind: ast::LiteralKind::Verbatim,\n                    c: '-',\n                })],\n            };\n            Ok((set, union))\n        });\n        assert_eq!(\n            parser_ignore_whitespace(\"[ - a]\").parse_set_class_open(),\n            {\n                let set = ast::ClassBracketed {\n                    span: span(0..4),\n                    negated: false,\n                    kind: ast::ClassSet::union(ast::ClassSetUnion {\n                        span: span(2..2),\n                        items: vec![],\n                    }),\n                };\n                let union = ast::ClassSetUnion {\n                    span: span(2..3),\n                    items: vec![ast::ClassSetItem::Literal(ast::Literal {\n                        span: span(2..3),\n                        kind: ast::LiteralKind::Verbatim,\n                        c: '-',\n                    })],\n                };\n                Ok((set, union))\n            }\n        );\n        assert_eq!(parser(\"[^-a]\").parse_set_class_open(), {\n            let set = ast::ClassBracketed {\n                span: span(0..3),\n                negated: true,\n                kind: ast::ClassSet::union(ast::ClassSetUnion {\n                    span: span(2..2),\n                    items: vec![],\n                }),\n            };\n            let union = ast::ClassSetUnion {\n                span: span(2..3),\n                items: vec![ast::ClassSetItem::Literal(ast::Literal {\n                    span: span(2..3),\n                    kind: ast::LiteralKind::Verbatim,\n                    c: '-',\n                })],\n            };\n            Ok((set, union))\n        });\n        assert_eq!(parser(\"[--a]\").parse_set_class_open(), {\n            let set = ast::ClassBracketed {\n                span: span(0..3),\n                negated: false,\n                kind: ast::ClassSet::union(ast::ClassSetUnion {\n                    span: span(1..1),\n                    items: vec![],\n                }),\n            };\n            let union = ast::ClassSetUnion {\n                span: span(1..3),\n                items: vec![\n                    ast::ClassSetItem::Literal(ast::Literal {\n                        span: span(1..2),\n                        kind: ast::LiteralKind::Verbatim,\n                        c: '-',\n                    }),\n                    ast::ClassSetItem::Literal(ast::Literal {\n                        span: span(2..3),\n                        kind: ast::LiteralKind::Verbatim,\n                        c: '-',\n                    }),\n                ],\n            };\n            Ok((set, union))\n        });\n        assert_eq!(parser(\"[]a]\").parse_set_class_open(), {\n            let set = ast::ClassBracketed {\n                span: span(0..2),\n                negated: false,\n                kind: ast::ClassSet::union(ast::ClassSetUnion {\n                    span: span(1..1),\n                    items: vec![],\n                }),\n            };\n            let union = ast::ClassSetUnion {\n                span: span(1..2),\n                items: vec![ast::ClassSetItem::Literal(ast::Literal {\n                    span: span(1..2),\n                    kind: ast::LiteralKind::Verbatim,\n                    c: ']',\n                })],\n            };\n            Ok((set, union))\n        });\n        assert_eq!(\n            parser_ignore_whitespace(\"[ ] a]\").parse_set_class_open(),\n            {\n                let set = ast::ClassBracketed {\n                    span: span(0..4),\n                    negated: false,\n                    kind: ast::ClassSet::union(ast::ClassSetUnion {\n                        span: span(2..2),\n                        items: vec![],\n                    }),\n                };\n                let union = ast::ClassSetUnion {\n                    span: span(2..3),\n                    items: vec![ast::ClassSetItem::Literal(ast::Literal {\n                        span: span(2..3),\n                        kind: ast::LiteralKind::Verbatim,\n                        c: ']',\n                    })],\n                };\n                Ok((set, union))\n            }\n        );\n        assert_eq!(parser(\"[^]a]\").parse_set_class_open(), {\n            let set = ast::ClassBracketed {\n                span: span(0..3),\n                negated: true,\n                kind: ast::ClassSet::union(ast::ClassSetUnion {\n                    span: span(2..2),\n                    items: vec![],\n                }),\n            };\n            let union = ast::ClassSetUnion {\n                span: span(2..3),\n                items: vec![ast::ClassSetItem::Literal(ast::Literal {\n                    span: span(2..3),\n                    kind: ast::LiteralKind::Verbatim,\n                    c: ']',\n                })],\n            };\n            Ok((set, union))\n        });\n        assert_eq!(parser(\"[-]a]\").parse_set_class_open(), {\n            let set = ast::ClassBracketed {\n                span: span(0..2),\n                negated: false,\n                kind: ast::ClassSet::union(ast::ClassSetUnion {\n                    span: span(1..1),\n                    items: vec![],\n                }),\n            };\n            let union = ast::ClassSetUnion {\n                span: span(1..2),\n                items: vec![ast::ClassSetItem::Literal(ast::Literal {\n                    span: span(1..2),\n                    kind: ast::LiteralKind::Verbatim,\n                    c: '-',\n                })],\n            };\n            Ok((set, union))\n        });\n\n        assert_eq!(\n            parser(\"[\").parse_set_class_open().unwrap_err(),\n            TestError {\n                span: span(0..1),\n                kind: ast::ErrorKind::ClassUnclosed,\n            }\n        );\n        assert_eq!(\n            parser_ignore_whitespace(\"[    \")\n                .parse_set_class_open()\n                .unwrap_err(),\n            TestError {\n                span: span(0..5),\n                kind: ast::ErrorKind::ClassUnclosed,\n            }\n        );\n        assert_eq!(\n            parser(\"[^\").parse_set_class_open().unwrap_err(),\n            TestError {\n                span: span(0..2),\n                kind: ast::ErrorKind::ClassUnclosed,\n            }\n        );\n        assert_eq!(\n            parser(\"[]\").parse_set_class_open().unwrap_err(),\n            TestError {\n                span: span(0..2),\n                kind: ast::ErrorKind::ClassUnclosed,\n            }\n        );\n        assert_eq!(\n            parser(\"[-\").parse_set_class_open().unwrap_err(),\n            TestError {\n                span: span(0..2),\n                kind: ast::ErrorKind::ClassUnclosed,\n            }\n        );\n        assert_eq!(\n            parser(\"[--\").parse_set_class_open().unwrap_err(),\n            TestError {\n                span: span(0..3),\n                kind: ast::ErrorKind::ClassUnclosed,\n            }\n        );\n    }\n\n    #[test]\n    fn maybe_parse_ascii_class() {\n        assert_eq!(\n            parser(r\"[:alnum:]\").maybe_parse_ascii_class(),\n            Some(ast::ClassAscii {\n                span: span(0..9),\n                kind: ast::ClassAsciiKind::Alnum,\n                negated: false,\n            })\n        );\n        assert_eq!(\n            parser(r\"[:alnum:]A\").maybe_parse_ascii_class(),\n            Some(ast::ClassAscii {\n                span: span(0..9),\n                kind: ast::ClassAsciiKind::Alnum,\n                negated: false,\n            })\n        );\n        assert_eq!(\n            parser(r\"[:^alnum:]\").maybe_parse_ascii_class(),\n            Some(ast::ClassAscii {\n                span: span(0..10),\n                kind: ast::ClassAsciiKind::Alnum,\n                negated: true,\n            })\n        );\n\n        let p = parser(r\"[:\");\n        assert_eq!(p.maybe_parse_ascii_class(), None);\n        assert_eq!(p.offset(), 0);\n\n        let p = parser(r\"[:^\");\n        assert_eq!(p.maybe_parse_ascii_class(), None);\n        assert_eq!(p.offset(), 0);\n\n        let p = parser(r\"[^:alnum:]\");\n        assert_eq!(p.maybe_parse_ascii_class(), None);\n        assert_eq!(p.offset(), 0);\n\n        let p = parser(r\"[:alnnum:]\");\n        assert_eq!(p.maybe_parse_ascii_class(), None);\n        assert_eq!(p.offset(), 0);\n\n        let p = parser(r\"[:alnum]\");\n        assert_eq!(p.maybe_parse_ascii_class(), None);\n        assert_eq!(p.offset(), 0);\n\n        let p = parser(r\"[:alnum:\");\n        assert_eq!(p.maybe_parse_ascii_class(), None);\n        assert_eq!(p.offset(), 0);\n    }\n\n    #[test]\n    fn parse_unicode_class() {\n        assert_eq!(\n            parser(r\"\\pN\").parse_escape(),\n            Ok(Primitive::Unicode(ast::ClassUnicode {\n                span: span(0..3),\n                negated: false,\n                kind: ast::ClassUnicodeKind::OneLetter('N'),\n            }))\n        );\n        assert_eq!(\n            parser(r\"\\PN\").parse_escape(),\n            Ok(Primitive::Unicode(ast::ClassUnicode {\n                span: span(0..3),\n                negated: true,\n                kind: ast::ClassUnicodeKind::OneLetter('N'),\n            }))\n        );\n        assert_eq!(\n            parser(r\"\\p{N}\").parse_escape(),\n            Ok(Primitive::Unicode(ast::ClassUnicode {\n                span: span(0..5),\n                negated: false,\n                kind: ast::ClassUnicodeKind::Named(s(\"N\")),\n            }))\n        );\n        assert_eq!(\n            parser(r\"\\P{N}\").parse_escape(),\n            Ok(Primitive::Unicode(ast::ClassUnicode {\n                span: span(0..5),\n                negated: true,\n                kind: ast::ClassUnicodeKind::Named(s(\"N\")),\n            }))\n        );\n        assert_eq!(\n            parser(r\"\\p{Greek}\").parse_escape(),\n            Ok(Primitive::Unicode(ast::ClassUnicode {\n                span: span(0..9),\n                negated: false,\n                kind: ast::ClassUnicodeKind::Named(s(\"Greek\")),\n            }))\n        );\n\n        assert_eq!(\n            parser(r\"\\p{scx:Katakana}\").parse_escape(),\n            Ok(Primitive::Unicode(ast::ClassUnicode {\n                span: span(0..16),\n                negated: false,\n                kind: ast::ClassUnicodeKind::NamedValue {\n                    op: ast::ClassUnicodeOpKind::Colon,\n                    name: s(\"scx\"),\n                    value: s(\"Katakana\"),\n                },\n            }))\n        );\n        assert_eq!(\n            parser(r\"\\p{scx=Katakana}\").parse_escape(),\n            Ok(Primitive::Unicode(ast::ClassUnicode {\n                span: span(0..16),\n                negated: false,\n                kind: ast::ClassUnicodeKind::NamedValue {\n                    op: ast::ClassUnicodeOpKind::Equal,\n                    name: s(\"scx\"),\n                    value: s(\"Katakana\"),\n                },\n            }))\n        );\n        assert_eq!(\n            parser(r\"\\p{scx!=Katakana}\").parse_escape(),\n            Ok(Primitive::Unicode(ast::ClassUnicode {\n                span: span(0..17),\n                negated: false,\n                kind: ast::ClassUnicodeKind::NamedValue {\n                    op: ast::ClassUnicodeOpKind::NotEqual,\n                    name: s(\"scx\"),\n                    value: s(\"Katakana\"),\n                },\n            }))\n        );\n\n        assert_eq!(\n            parser(r\"\\p{:}\").parse_escape(),\n            Ok(Primitive::Unicode(ast::ClassUnicode {\n                span: span(0..5),\n                negated: false,\n                kind: ast::ClassUnicodeKind::NamedValue {\n                    op: ast::ClassUnicodeOpKind::Colon,\n                    name: s(\"\"),\n                    value: s(\"\"),\n                },\n            }))\n        );\n        assert_eq!(\n            parser(r\"\\p{=}\").parse_escape(),\n            Ok(Primitive::Unicode(ast::ClassUnicode {\n                span: span(0..5),\n                negated: false,\n                kind: ast::ClassUnicodeKind::NamedValue {\n                    op: ast::ClassUnicodeOpKind::Equal,\n                    name: s(\"\"),\n                    value: s(\"\"),\n                },\n            }))\n        );\n        assert_eq!(\n            parser(r\"\\p{!=}\").parse_escape(),\n            Ok(Primitive::Unicode(ast::ClassUnicode {\n                span: span(0..6),\n                negated: false,\n                kind: ast::ClassUnicodeKind::NamedValue {\n                    op: ast::ClassUnicodeOpKind::NotEqual,\n                    name: s(\"\"),\n                    value: s(\"\"),\n                },\n            }))\n        );\n\n        assert_eq!(\n            parser(r\"\\p\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(2..2),\n                kind: ast::ErrorKind::EscapeUnexpectedEof,\n            }\n        );\n        assert_eq!(\n            parser(r\"\\p{\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(3..3),\n                kind: ast::ErrorKind::EscapeUnexpectedEof,\n            }\n        );\n        assert_eq!(\n            parser(r\"\\p{N\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(4..4),\n                kind: ast::ErrorKind::EscapeUnexpectedEof,\n            }\n        );\n        assert_eq!(\n            parser(r\"\\p{Greek\").parse_escape().unwrap_err(),\n            TestError {\n                span: span(8..8),\n                kind: ast::ErrorKind::EscapeUnexpectedEof,\n            }\n        );\n\n        assert_eq!(\n            parser(r\"\\pNz\").parse(),\n            Ok(Ast::Concat(ast::Concat {\n                span: span(0..4),\n                asts: vec![\n                    Ast::Class(ast::Class::Unicode(ast::ClassUnicode {\n                        span: span(0..3),\n                        negated: false,\n                        kind: ast::ClassUnicodeKind::OneLetter('N'),\n                    })),\n                    Ast::Literal(ast::Literal {\n                        span: span(3..4),\n                        kind: ast::LiteralKind::Verbatim,\n                        c: 'z',\n                    }),\n                ],\n            }))\n        );\n        assert_eq!(\n            parser(r\"\\p{Greek}z\").parse(),\n            Ok(Ast::Concat(ast::Concat {\n                span: span(0..10),\n                asts: vec![\n                    Ast::Class(ast::Class::Unicode(ast::ClassUnicode {\n                        span: span(0..9),\n                        negated: false,\n                        kind: ast::ClassUnicodeKind::Named(s(\"Greek\")),\n                    })),\n                    Ast::Literal(ast::Literal {\n                        span: span(9..10),\n                        kind: ast::LiteralKind::Verbatim,\n                        c: 'z',\n                    }),\n                ],\n            }))\n        );\n        assert_eq!(\n            parser(r\"\\p\\{\").parse().unwrap_err(),\n            TestError {\n                span: span(2..3),\n                kind: ast::ErrorKind::UnicodeClassInvalid,\n            }\n        );\n        assert_eq!(\n            parser(r\"\\P\\{\").parse().unwrap_err(),\n            TestError {\n                span: span(2..3),\n                kind: ast::ErrorKind::UnicodeClassInvalid,\n            }\n        );\n    }\n\n    #[test]\n    fn parse_perl_class() {\n        assert_eq!(\n            parser(r\"\\d\").parse_escape(),\n            Ok(Primitive::Perl(ast::ClassPerl {\n                span: span(0..2),\n                kind: ast::ClassPerlKind::Digit,\n                negated: false,\n            }))\n        );\n        assert_eq!(\n            parser(r\"\\D\").parse_escape(),\n            Ok(Primitive::Perl(ast::ClassPerl {\n                span: span(0..2),\n                kind: ast::ClassPerlKind::Digit,\n                negated: true,\n            }))\n        );\n        assert_eq!(\n            parser(r\"\\s\").parse_escape(),\n            Ok(Primitive::Perl(ast::ClassPerl {\n                span: span(0..2),\n                kind: ast::ClassPerlKind::Space,\n                negated: false,\n            }))\n        );\n        assert_eq!(\n            parser(r\"\\S\").parse_escape(),\n            Ok(Primitive::Perl(ast::ClassPerl {\n                span: span(0..2),\n                kind: ast::ClassPerlKind::Space,\n                negated: true,\n            }))\n        );\n        assert_eq!(\n            parser(r\"\\w\").parse_escape(),\n            Ok(Primitive::Perl(ast::ClassPerl {\n                span: span(0..2),\n                kind: ast::ClassPerlKind::Word,\n                negated: false,\n            }))\n        );\n        assert_eq!(\n            parser(r\"\\W\").parse_escape(),\n            Ok(Primitive::Perl(ast::ClassPerl {\n                span: span(0..2),\n                kind: ast::ClassPerlKind::Word,\n                negated: true,\n            }))\n        );\n\n        assert_eq!(\n            parser(r\"\\d\").parse(),\n            Ok(Ast::Class(ast::Class::Perl(ast::ClassPerl {\n                span: span(0..2),\n                kind: ast::ClassPerlKind::Digit,\n                negated: false,\n            })))\n        );\n        assert_eq!(\n            parser(r\"\\dz\").parse(),\n            Ok(Ast::Concat(ast::Concat {\n                span: span(0..3),\n                asts: vec![\n                    Ast::Class(ast::Class::Perl(ast::ClassPerl {\n                        span: span(0..2),\n                        kind: ast::ClassPerlKind::Digit,\n                        negated: false,\n                    })),\n                    Ast::Literal(ast::Literal {\n                        span: span(2..3),\n                        kind: ast::LiteralKind::Verbatim,\n                        c: 'z',\n                    }),\n                ],\n            }))\n        );\n    }\n\n    // This tests a bug fix where the nest limit checker wasn't decrementing\n    // its depth during post-traversal, which causes long regexes to trip\n    // the default limit too aggressively.\n    #[test]\n    fn regression_454_nest_too_big() {\n        let pattern = r#\"\n        2(?:\n          [45]\\d{3}|\n          7(?:\n            1[0-267]|\n            2[0-289]|\n            3[0-29]|\n            4[01]|\n            5[1-3]|\n            6[013]|\n            7[0178]|\n            91\n          )|\n          8(?:\n            0[125]|\n            [139][1-6]|\n            2[0157-9]|\n            41|\n            6[1-35]|\n            7[1-5]|\n            8[1-8]|\n            90\n          )|\n          9(?:\n            0[0-2]|\n            1[0-4]|\n            2[568]|\n            3[3-6]|\n            5[5-7]|\n            6[0167]|\n            7[15]|\n            8[0146-9]\n          )\n        )\\d{4}\n        \"#;\n        assert!(parser_nest_limit(pattern, 50).parse().is_ok());\n    }\n\n    // This tests that we treat a trailing `-` in a character class as a\n    // literal `-` even when whitespace mode is enabled and there is whitespace\n    // after the trailing `-`.\n    #[test]\n    fn regression_455_trailing_dash_ignore_whitespace() {\n        assert!(parser(\"(?x)[ / - ]\").parse().is_ok());\n        assert!(parser(\"(?x)[ a - ]\").parse().is_ok());\n        assert!(parser(\n            \"(?x)[\n            a\n            - ]\n        \"\n        )\n        .parse()\n        .is_ok());\n        assert!(parser(\n            \"(?x)[\n            a # wat\n            - ]\n        \"\n        )\n        .parse()\n        .is_ok());\n\n        assert!(parser(\"(?x)[ / -\").parse().is_err());\n        assert!(parser(\"(?x)[ / - \").parse().is_err());\n        assert!(parser(\n            \"(?x)[\n            / -\n        \"\n        )\n        .parse()\n        .is_err());\n        assert!(parser(\n            \"(?x)[\n            / - # wat\n        \"\n        )\n        .parse()\n        .is_err());\n    }\n}\n","traces":[{"line":34,"address":[7313888],"length":1,"stats":{"Line":8},"fn_name":"span"},{"line":35,"address":[7314044,7313975,7314021,7313998,7313950],"length":1,"stats":{"Line":25},"fn_name":null},{"line":36,"address":[7313897,7313959],"length":1,"stats":{"Line":16},"fn_name":null},{"line":37,"address":[7313982],"length":1,"stats":{"Line":9},"fn_name":null},{"line":38,"address":[7314005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[7314028],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[7313934],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[7314064],"length":1,"stats":{"Line":25},"fn_name":"into_ast"},{"line":46,"address":[7314630,7314336,7314484,7314776],"length":1,"stats":{"Line":65},"fn_name":null},{"line":47,"address":[7314351,7314074],"length":1,"stats":{"Line":34},"fn_name":null},{"line":48,"address":[7314497],"length":1,"stats":{"Line":25},"fn_name":null},{"line":49,"address":[7314643],"length":1,"stats":{"Line":23},"fn_name":null},{"line":50,"address":[7314789],"length":1,"stats":{"Line":16},"fn_name":null},{"line":51,"address":[7314141],"length":1,"stats":{"Line":8},"fn_name":null},{"line":59,"address":[7085632,7085168],"length":1,"stats":{"Line":8},"fn_name":"into_class_set_item<&mut regex_syntax::ast::parse::Parser>"},{"line":66,"address":[7085844,7086258,7086046,7085627],"length":1,"stats":{"Line":28},"fn_name":null},{"line":67,"address":[7085186,7085438],"length":1,"stats":{"Line":16},"fn_name":null},{"line":68,"address":[7085655],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[7085857],"length":1,"stats":{"Line":9},"fn_name":null},{"line":70,"address":[7086056,7085296],"length":1,"stats":{"Line":18},"fn_name":null},{"line":80,"address":[7086386,7086320],"length":1,"stats":{"Line":8},"fn_name":"into_class_literal<&mut regex_syntax::ast::parse::Parser>"},{"line":86,"address":[7086661,7086862],"length":1,"stats":{"Line":20},"fn_name":null},{"line":87,"address":[7086537,7086338],"length":1,"stats":{"Line":16},"fn_name":null},{"line":88,"address":[7086401,7086671],"length":1,"stats":{"Line":19},"fn_name":null},{"line":94,"address":[7314992],"length":1,"stats":{"Line":12},"fn_name":"is_hex"},{"line":95,"address":[7315000,7315060],"length":1,"stats":{"Line":24},"fn_name":null},{"line":102,"address":[7315216],"length":1,"stats":{"Line":31},"fn_name":"is_capture_char"},{"line":103,"address":[7315233,7315393,7315502,7315461,7315359,7315518,7315324,7315295],"length":1,"stats":{"Line":194},"fn_name":null},{"line":104,"address":[7315351,7315368,7315402],"length":1,"stats":{"Line":62},"fn_name":null},{"line":105,"address":[7315313,7315436],"length":1,"stats":{"Line":62},"fn_name":null},{"line":106,"address":[7315477,7315267],"length":1,"stats":{"Line":8},"fn_name":null},{"line":120,"address":[7315520],"length":1,"stats":{"Line":34},"fn_name":"default"},{"line":121,"address":[7315524],"length":1,"stats":{"Line":34},"fn_name":null},{"line":127,"address":[7315568],"length":1,"stats":{"Line":34},"fn_name":"new"},{"line":136,"address":[7315600,7315684],"length":1,"stats":{"Line":34},"fn_name":"build"},{"line":138,"address":[7315618],"length":1,"stats":{"Line":34},"fn_name":null},{"line":139,"address":[7315701],"length":1,"stats":{"Line":34},"fn_name":null},{"line":140,"address":[7315716],"length":1,"stats":{"Line":34},"fn_name":null},{"line":141,"address":[7315718],"length":1,"stats":{"Line":34},"fn_name":null},{"line":142,"address":[7315721],"length":1,"stats":{"Line":34},"fn_name":null},{"line":143,"address":[7315725],"length":1,"stats":{"Line":34},"fn_name":null},{"line":144,"address":[7315764],"length":1,"stats":{"Line":34},"fn_name":null},{"line":145,"address":[7315879,7315823],"length":1,"stats":{"Line":68},"fn_name":null},{"line":146,"address":[7315915,7315971],"length":1,"stats":{"Line":68},"fn_name":null},{"line":147,"address":[7316063,7316007],"length":1,"stats":{"Line":68},"fn_name":null},{"line":148,"address":[7316121,7316098],"length":1,"stats":{"Line":68},"fn_name":null},{"line":177,"address":[7316608],"length":1,"stats":{"Line":34},"fn_name":"nest_limit"},{"line":178,"address":[7316620],"length":1,"stats":{"Line":34},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[7316640],"length":1,"stats":{"Line":34},"fn_name":"octal"},{"line":198,"address":[7316657],"length":1,"stats":{"Line":34},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[7316688],"length":1,"stats":{"Line":34},"fn_name":"ignore_whitespace"},{"line":211,"address":[7316705],"length":1,"stats":{"Line":34},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[7316736],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":332,"address":[7316753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[7316800],"length":1,"stats":{"Line":34},"fn_name":"parse"},{"line":337,"address":[7316822],"length":1,"stats":{"Line":34},"fn_name":null},{"line":342,"address":[7316880],"length":1,"stats":{"Line":0},"fn_name":"parse_with_comments"},{"line":346,"address":[7316902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[7317023,7316960],"length":1,"stats":{"Line":34},"fn_name":"reset"},{"line":357,"address":[7316972],"length":1,"stats":{"Line":34},"fn_name":null},{"line":358,"address":[7317040],"length":1,"stats":{"Line":34},"fn_name":null},{"line":359,"address":[7317077],"length":1,"stats":{"Line":34},"fn_name":null},{"line":360,"address":[7317172],"length":1,"stats":{"Line":34},"fn_name":null},{"line":361,"address":[7317267],"length":1,"stats":{"Line":34},"fn_name":null},{"line":367,"address":[7086944],"length":1,"stats":{"Line":34},"fn_name":"new<&mut regex_syntax::ast::parse::Parser>"},{"line":372,"address":[7086992],"length":1,"stats":{"Line":34},"fn_name":"parser<&mut regex_syntax::ast::parse::Parser>"},{"line":373,"address":[7087001],"length":1,"stats":{"Line":34},"fn_name":null},{"line":377,"address":[7087024],"length":1,"stats":{"Line":34},"fn_name":"pattern<&mut regex_syntax::ast::parse::Parser>"},{"line":378,"address":[7087033],"length":1,"stats":{"Line":34},"fn_name":null},{"line":382,"address":[7087088],"length":1,"stats":{"Line":8},"fn_name":"error<&mut regex_syntax::ast::parse::Parser>"},{"line":385,"address":[7087155],"length":1,"stats":{"Line":9},"fn_name":null},{"line":394,"address":[7087344],"length":1,"stats":{"Line":34},"fn_name":"offset<&mut regex_syntax::ast::parse::Parser>"},{"line":395,"address":[7087353],"length":1,"stats":{"Line":34},"fn_name":null},{"line":401,"address":[7087392],"length":1,"stats":{"Line":25},"fn_name":"line<&mut regex_syntax::ast::parse::Parser>"},{"line":402,"address":[7087401],"length":1,"stats":{"Line":33},"fn_name":null},{"line":408,"address":[7087440],"length":1,"stats":{"Line":33},"fn_name":"column<&mut regex_syntax::ast::parse::Parser>"},{"line":409,"address":[7087449],"length":1,"stats":{"Line":33},"fn_name":null},{"line":419,"address":[7087488,7087688],"length":1,"stats":{"Line":31},"fn_name":"next_capture_index<&mut regex_syntax::ast::parse::Parser>"},{"line":420,"address":[7087503],"length":1,"stats":{"Line":31},"fn_name":null},{"line":421,"address":[7087703,7087741,7087572,7088144],"length":1,"stats":{"Line":62},"fn_name":"{{closure}}<&mut regex_syntax::ast::parse::Parser>"},{"line":422,"address":[7088170],"length":1,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[7088053],"length":1,"stats":{"Line":31},"fn_name":null},{"line":425,"address":[7088100],"length":1,"stats":{"Line":31},"fn_name":null},{"line":430,"address":[7088272,7088349],"length":1,"stats":{"Line":31},"fn_name":"add_capture_name<&mut regex_syntax::ast::parse::Parser>"},{"line":431,"address":[7088372,7088306],"length":1,"stats":{"Line":62},"fn_name":null},{"line":432,"address":[7088760,7088404,7088563,7088873],"length":1,"stats":{"Line":93},"fn_name":null},{"line":433,"address":[7089168,7089182,7088503],"length":1,"stats":{"Line":47},"fn_name":"{{closure}}<&mut regex_syntax::ast::parse::Parser>"},{"line":435,"address":[7088762,7088655],"length":1,"stats":{"Line":62},"fn_name":null},{"line":436,"address":[7088778],"length":1,"stats":{"Line":31},"fn_name":null},{"line":437,"address":[7088867],"length":1,"stats":{"Line":31},"fn_name":null},{"line":439,"address":[7088672,7089003],"length":1,"stats":{"Line":16},"fn_name":null},{"line":440,"address":[7088696],"length":1,"stats":{"Line":8},"fn_name":null},{"line":441,"address":[7088731,7088878],"length":1,"stats":{"Line":16},"fn_name":null},{"line":447,"address":[7089232],"length":1,"stats":{"Line":34},"fn_name":"ignore_whitespace<&mut regex_syntax::ast::parse::Parser>"},{"line":448,"address":[7089241],"length":1,"stats":{"Line":34},"fn_name":null},{"line":454,"address":[7089296],"length":1,"stats":{"Line":34},"fn_name":"char<&mut regex_syntax::ast::parse::Parser>"},{"line":455,"address":[7089310],"length":1,"stats":{"Line":34},"fn_name":null},{"line":461,"address":[7089360],"length":1,"stats":{"Line":34},"fn_name":"char_at<&mut regex_syntax::ast::parse::Parser>"},{"line":462,"address":[7089480,7089374],"length":1,"stats":{"Line":68},"fn_name":null},{"line":465,"address":[7089520,7089536,7089470],"length":1,"stats":{"Line":34},"fn_name":"{{closure}}<&mut regex_syntax::ast::parse::Parser>"},{"line":471,"address":[7089664],"length":1,"stats":{"Line":10},"fn_name":"bump<&mut regex_syntax::ast::parse::Parser>"},{"line":472,"address":[7089687],"length":1,"stats":{"Line":10},"fn_name":null},{"line":473,"address":[7089735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[7089763,7089712],"length":1,"stats":{"Line":62},"fn_name":null},{"line":476,"address":[7089819,7089957],"length":1,"stats":{"Line":39},"fn_name":null},{"line":477,"address":[7089873],"length":1,"stats":{"Line":8},"fn_name":null},{"line":478,"address":[7089945],"length":1,"stats":{"Line":8},"fn_name":null},{"line":480,"address":[7089843,7089976],"length":1,"stats":{"Line":63},"fn_name":null},{"line":482,"address":[7090011,7090334,7090364],"length":1,"stats":{"Line":32},"fn_name":null},{"line":483,"address":[7090085,7090125],"length":1,"stats":{"Line":68},"fn_name":null},{"line":484,"address":[7090101],"length":1,"stats":{"Line":34},"fn_name":null},{"line":485,"address":[7090109],"length":1,"stats":{"Line":34},"fn_name":null},{"line":486,"address":[7090117],"length":1,"stats":{"Line":34},"fn_name":null},{"line":488,"address":[7090174],"length":1,"stats":{"Line":34},"fn_name":null},{"line":495,"address":[7090368],"length":1,"stats":{"Line":9},"fn_name":"bump_if<&mut regex_syntax::ast::parse::Parser>"},{"line":496,"address":[7090414,7090531,7090717],"length":1,"stats":{"Line":50},"fn_name":null},{"line":497,"address":[7090755,7090546,7090719],"length":1,"stats":{"Line":64},"fn_name":null},{"line":498,"address":[7090750],"length":1,"stats":{"Line":32},"fn_name":null},{"line":500,"address":[7090712],"length":1,"stats":{"Line":32},"fn_name":null},{"line":502,"address":[7090526],"length":1,"stats":{"Line":9},"fn_name":null},{"line":513,"address":[7090784],"length":1,"stats":{"Line":9},"fn_name":"is_lookaround_prefix<&mut regex_syntax::ast::parse::Parser>"},{"line":514,"address":[7090988,7090805,7090889,7090934],"length":1,"stats":{"Line":73},"fn_name":null},{"line":515,"address":[7090969],"length":1,"stats":{"Line":9},"fn_name":null},{"line":516,"address":[7090915],"length":1,"stats":{"Line":32},"fn_name":null},{"line":517,"address":[7090853],"length":1,"stats":{"Line":32},"fn_name":null},{"line":523,"address":[7091056],"length":1,"stats":{"Line":8},"fn_name":"bump_and_bump_space<&mut regex_syntax::ast::parse::Parser>"},{"line":524,"address":[7091070],"length":1,"stats":{"Line":8},"fn_name":null},{"line":525,"address":[7091101],"length":1,"stats":{"Line":8},"fn_name":null},{"line":527,"address":[7091094],"length":1,"stats":{"Line":8},"fn_name":null},{"line":528,"address":[7091125],"length":1,"stats":{"Line":8},"fn_name":null},{"line":540,"address":[7091152,7091199],"length":1,"stats":{"Line":34},"fn_name":"bump_space<&mut regex_syntax::ast::parse::Parser>"},{"line":541,"address":[7091167,7091218],"length":1,"stats":{"Line":68},"fn_name":null},{"line":542,"address":[7091226],"length":1,"stats":{"Line":34},"fn_name":null},{"line":544,"address":[7091224,7091241,7091962],"length":1,"stats":{"Line":16},"fn_name":null},{"line":545,"address":[7091955,7091328,7091270],"length":1,"stats":{"Line":8},"fn_name":null},{"line":546,"address":[7091323],"length":1,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[7091307,7091337],"length":1,"stats":{"Line":16},"fn_name":null},{"line":548,"address":[7091347],"length":1,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[7091362],"length":1,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[7091385],"length":1,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[7091392,7091534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":552,"address":[7091427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":553,"address":[7091454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[7091465],"length":1,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[7091486],"length":1,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[7091479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[7091488,7091539],"length":1,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[7091693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[7091342,7091957],"length":1,"stats":{"Line":16},"fn_name":null},{"line":573,"address":[7092096],"length":1,"stats":{"Line":8},"fn_name":"peek<&mut regex_syntax::ast::parse::Parser>"},{"line":574,"address":[7092110],"length":1,"stats":{"Line":8},"fn_name":null},{"line":575,"address":[7092152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[7092351,7092321,7092174,7092134],"length":1,"stats":{"Line":32},"fn_name":null},{"line":582,"address":[7092352],"length":1,"stats":{"Line":8},"fn_name":"peek_space<&mut regex_syntax::ast::parse::Parser>"},{"line":583,"address":[7092375],"length":1,"stats":{"Line":8},"fn_name":null},{"line":584,"address":[7092450,7092421],"length":1,"stats":{"Line":16},"fn_name":null},{"line":586,"address":[7092402,7092456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":587,"address":[7092482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":589,"address":[7092470,7092503,7093216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[7092569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[7093107,7092585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":592,"address":[7092862,7092917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":593,"address":[7092938],"length":1,"stats":{"Line":0},"fn_name":null},{"line":594,"address":[7093004,7093087,7092923,7092943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[7092996],"length":1,"stats":{"Line":0},"fn_name":null},{"line":596,"address":[7093006,7092984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":597,"address":[7093079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":599,"address":[7093276,7093052,7093094,7093246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[7093102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":603,"address":[7092892,7093112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":607,"address":[7093280],"length":1,"stats":{"Line":34},"fn_name":"is_eof<&mut regex_syntax::ast::parse::Parser>"},{"line":608,"address":[7093294],"length":1,"stats":{"Line":34},"fn_name":null},{"line":613,"address":[7093376],"length":1,"stats":{"Line":34},"fn_name":"pos<&mut regex_syntax::ast::parse::Parser>"},{"line":614,"address":[7093393],"length":1,"stats":{"Line":34},"fn_name":null},{"line":619,"address":[7093456],"length":1,"stats":{"Line":34},"fn_name":"span<&mut regex_syntax::ast::parse::Parser>"},{"line":620,"address":[7093468],"length":1,"stats":{"Line":34},"fn_name":null},{"line":624,"address":[7093520],"length":1,"stats":{"Line":25},"fn_name":"span_char<&mut regex_syntax::ast::parse::Parser>"},{"line":626,"address":[7093546],"length":1,"stats":{"Line":25},"fn_name":null},{"line":627,"address":[7093658],"length":1,"stats":{"Line":25},"fn_name":null},{"line":628,"address":[7093673],"length":1,"stats":{"Line":33},"fn_name":null},{"line":630,"address":[7093783],"length":1,"stats":{"Line":33},"fn_name":null},{"line":631,"address":[7093996,7093966,7093801],"length":1,"stats":{"Line":8},"fn_name":null},{"line":632,"address":[7093845],"length":1,"stats":{"Line":8},"fn_name":null},{"line":634,"address":[7093857],"length":1,"stats":{"Line":33},"fn_name":null},{"line":647,"address":[7094000,7094900],"length":1,"stats":{"Line":8},"fn_name":"push_alternate<&mut regex_syntax::ast::parse::Parser>"},{"line":648,"address":[7094199,7094018],"length":1,"stats":{"Line":8},"fn_name":null},{"line":649,"address":[7094189,7094514],"length":1,"stats":{"Line":16},"fn_name":null},{"line":650,"address":[7094546],"length":1,"stats":{"Line":8},"fn_name":null},{"line":651,"address":[7094638],"length":1,"stats":{"Line":8},"fn_name":null},{"line":652,"address":[7094658],"length":1,"stats":{"Line":8},"fn_name":null},{"line":657,"address":[7094944,7095001],"length":1,"stats":{"Line":8},"fn_name":"push_or_add_alternation<&mut regex_syntax::ast::parse::Parser>"},{"line":660,"address":[7095021,7094959],"length":1,"stats":{"Line":16},"fn_name":null},{"line":661,"address":[7095132,7095069,7095217],"length":1,"stats":{"Line":24},"fn_name":null},{"line":662,"address":[7095258],"length":1,"stats":{"Line":8},"fn_name":null},{"line":663,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":665,"address":[7095193,7095681],"length":1,"stats":{"Line":16},"fn_name":null},{"line":666,"address":[7095415],"length":1,"stats":{"Line":8},"fn_name":null},{"line":667,"address":[7095503,7095933],"length":1,"stats":{"Line":8},"fn_name":null},{"line":685,"address":[7096115,7096016],"length":1,"stats":{"Line":9},"fn_name":"push_group<&mut regex_syntax::ast::parse::Parser>"},{"line":686,"address":[7096034,7096267,7096137],"length":1,"stats":{"Line":18},"fn_name":null},{"line":687,"address":[7096257,7096636,7096688,7096823,7098027,7097246,7097124],"length":1,"stats":{"Line":98},"fn_name":null},{"line":688,"address":[7097248,7096799],"length":1,"stats":{"Line":49},"fn_name":null},{"line":689,"address":[7097392],"length":1,"stats":{"Line":15},"fn_name":null},{"line":690,"address":[7097482,7097444,7097589],"length":1,"stats":{"Line":31},"fn_name":null},{"line":691,"address":[7097496],"length":1,"stats":{"Line":8},"fn_name":null},{"line":694,"address":[7097599],"length":1,"stats":{"Line":15},"fn_name":null},{"line":695,"address":[7097901],"length":1,"stats":{"Line":15},"fn_name":null},{"line":697,"address":[7098942,7097175,7098019],"length":1,"stats":{"Line":47},"fn_name":null},{"line":698,"address":[7097229,7098039],"length":1,"stats":{"Line":64},"fn_name":null},{"line":699,"address":[7098048],"length":1,"stats":{"Line":32},"fn_name":null},{"line":701,"address":[7099145,7099136],"length":1,"stats":{"Line":20},"fn_name":"{{closure}}<&mut regex_syntax::ast::parse::Parser>"},{"line":702,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":703,"address":[7098159,7098541],"length":1,"stats":{"Line":64},"fn_name":null},{"line":704,"address":[7098403],"length":1,"stats":{"Line":32},"fn_name":null},{"line":705,"address":[7098266],"length":1,"stats":{"Line":32},"fn_name":null},{"line":706,"address":[7098341],"length":1,"stats":{"Line":32},"fn_name":null},{"line":707,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":710,"address":[7098608],"length":1,"stats":{"Line":32},"fn_name":null},{"line":711,"address":[7098695],"length":1,"stats":{"Line":32},"fn_name":null},{"line":726,"address":[7099321,7099184],"length":1,"stats":{"Line":24},"fn_name":"pop_group<&mut regex_syntax::ast::parse::Parser>"},{"line":729,"address":[7099208,7099343,7099477],"length":1,"stats":{"Line":48},"fn_name":null},{"line":730,"address":[7099854,7099447],"length":1,"stats":{"Line":48},"fn_name":null},{"line":731,"address":[7101651,7103337,7100064,7099920,7100481],"length":1,"stats":{"Line":80},"fn_name":null},{"line":732,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":734,"address":[7099993,7100066,7100042],"length":1,"stats":{"Line":72},"fn_name":null},{"line":735,"address":[7100221],"length":1,"stats":{"Line":24},"fn_name":null},{"line":737,"address":[7100675,7100486],"length":1,"stats":{"Line":8},"fn_name":null},{"line":738,"address":[7100628,7100681],"length":1,"stats":{"Line":16},"fn_name":null},{"line":739,"address":[7100843],"length":1,"stats":{"Line":8},"fn_name":null},{"line":741,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":742,"address":[7101503,7101295],"length":1,"stats":{"Line":0},"fn_name":null},{"line":743,"address":[7101261],"length":1,"stats":{"Line":0},"fn_name":null},{"line":744,"address":[7101284],"length":1,"stats":{"Line":0},"fn_name":null},{"line":748,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":749,"address":[7101546],"length":1,"stats":{"Line":8},"fn_name":null},{"line":750,"address":[7100032,7101535],"length":1,"stats":{"Line":16},"fn_name":null},{"line":753,"address":[7101933,7103606],"length":1,"stats":{"Line":48},"fn_name":null},{"line":754,"address":[7102006],"length":1,"stats":{"Line":24},"fn_name":null},{"line":755,"address":[7102053],"length":1,"stats":{"Line":24},"fn_name":null},{"line":756,"address":[7102076],"length":1,"stats":{"Line":24},"fn_name":null},{"line":757,"address":[7103737,7103789,7102245],"length":1,"stats":{"Line":32},"fn_name":null},{"line":758,"address":[7102115,7102247],"length":1,"stats":{"Line":32},"fn_name":null},{"line":759,"address":[7102359],"length":1,"stats":{"Line":8},"fn_name":null},{"line":760,"address":[7102415],"length":1,"stats":{"Line":8},"fn_name":null},{"line":761,"address":[7103685,7102541,7102714],"length":1,"stats":{"Line":16},"fn_name":null},{"line":763,"address":[7103635,7103729],"length":1,"stats":{"Line":8},"fn_name":null},{"line":764,"address":[7102802,7103742,7102140],"length":1,"stats":{"Line":48},"fn_name":null},{"line":767,"address":[7102832],"length":1,"stats":{"Line":24},"fn_name":null},{"line":768,"address":[7102989],"length":1,"stats":{"Line":24},"fn_name":null},{"line":778,"address":[7103984,7104076],"length":1,"stats":{"Line":23},"fn_name":"pop_group_end<&mut regex_syntax::ast::parse::Parser>"},{"line":779,"address":[7104002,7104091],"length":1,"stats":{"Line":46},"fn_name":null},{"line":780,"address":[7104123],"length":1,"stats":{"Line":23},"fn_name":null},{"line":781,"address":[7104649,7104206,7105109,7104487],"length":1,"stats":{"Line":54},"fn_name":null},{"line":782,"address":[7104273,7104489],"length":1,"stats":{"Line":46},"fn_name":null},{"line":783,"address":[7104654,7104298],"length":1,"stats":{"Line":16},"fn_name":null},{"line":784,"address":[7104750],"length":1,"stats":{"Line":8},"fn_name":null},{"line":785,"address":[7104789,7104926],"length":1,"stats":{"Line":16},"fn_name":null},{"line":786,"address":[7104950],"length":1,"stats":{"Line":8},"fn_name":null},{"line":788,"address":[7104907,7104320],"length":1,"stats":{"Line":8},"fn_name":null},{"line":789,"address":[7105130],"length":1,"stats":{"Line":8},"fn_name":null},{"line":790,"address":[7104350],"length":1,"stats":{"Line":8},"fn_name":null},{"line":795,"address":[7105711,7105420,7105979,7106253,7105669],"length":1,"stats":{"Line":69},"fn_name":null},{"line":796,"address":[7105671,7105455],"length":1,"stats":{"Line":46},"fn_name":null},{"line":806,"address":[7105502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":807,"address":[7105830,7105532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":821,"address":[7106795,7106704],"length":1,"stats":{"Line":8},"fn_name":"push_class_open<&mut regex_syntax::ast::parse::Parser>"},{"line":825,"address":[7106722,7106947,7106817],"length":1,"stats":{"Line":16},"fn_name":null},{"line":827,"address":[7107939,7107638,7106937,7107316],"length":1,"stats":{"Line":16},"fn_name":null},{"line":828,"address":[7107606,7108363,7108030],"length":1,"stats":{"Line":24},"fn_name":null},{"line":829,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":831,"address":[7108108,7108392],"length":1,"stats":{"Line":8},"fn_name":null},{"line":832,"address":[7108430],"length":1,"stats":{"Line":8},"fn_name":null},{"line":850,"address":[7108795,7108688],"length":1,"stats":{"Line":8},"fn_name":"pop_class<&mut regex_syntax::ast::parse::Parser>"},{"line":854,"address":[7109026,7108706,7108817],"length":1,"stats":{"Line":16},"fn_name":null},{"line":856,"address":[7109395,7108921],"length":1,"stats":{"Line":16},"fn_name":null},{"line":857,"address":[7109466],"length":1,"stats":{"Line":8},"fn_name":null},{"line":858,"address":[7109543,7109647],"length":1,"stats":{"Line":16},"fn_name":null},{"line":859,"address":[7109671,7109943],"length":1,"stats":{"Line":8},"fn_name":null},{"line":860,"address":[7109744],"length":1,"stats":{"Line":8},"fn_name":null},{"line":869,"address":[7109945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":871,"address":[7109769],"length":1,"stats":{"Line":8},"fn_name":null},{"line":878,"address":[7110051],"length":1,"stats":{"Line":0},"fn_name":null},{"line":880,"address":[7109791],"length":1,"stats":{"Line":8},"fn_name":null},{"line":881,"address":[7109933],"length":1,"stats":{"Line":8},"fn_name":null},{"line":882,"address":[7110100],"length":1,"stats":{"Line":8},"fn_name":null},{"line":883,"address":[7110139,7111087],"length":1,"stats":{"Line":8},"fn_name":null},{"line":884,"address":[7111173,7110217,7110590],"length":1,"stats":{"Line":24},"fn_name":null},{"line":885,"address":[7110372],"length":1,"stats":{"Line":8},"fn_name":null},{"line":887,"address":[7110600,7110258],"length":1,"stats":{"Line":0},"fn_name":null},{"line":888,"address":[7110647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":899,"address":[7111440,7111492],"length":1,"stats":{"Line":8},"fn_name":"unclosed_class_error<&mut regex_syntax::ast::parse::Parser>"},{"line":900,"address":[7111466,7111512,7112004,7111865],"length":1,"stats":{"Line":24},"fn_name":null},{"line":901,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":902,"address":[7111844,7111875],"length":1,"stats":{"Line":16},"fn_name":null},{"line":903,"address":[7111939],"length":1,"stats":{"Line":8},"fn_name":null},{"line":904,"address":[7111892],"length":1,"stats":{"Line":8},"fn_name":null},{"line":906,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":911,"address":[7112031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":920,"address":[7112210,7112096],"length":1,"stats":{"Line":0},"fn_name":"push_class_op<&mut regex_syntax::ast::parse::Parser>"},{"line":925,"address":[7112225,7112121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":926,"address":[7112284],"length":1,"stats":{"Line":0},"fn_name":null},{"line":927,"address":[7112355,7112578],"length":1,"stats":{"Line":0},"fn_name":null},{"line":928,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":930,"address":[7112607,7112462],"length":1,"stats":{"Line":0},"fn_name":null},{"line":931,"address":[7112661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":940,"address":[7112992,7112896],"length":1,"stats":{"Line":8},"fn_name":"pop_class_op<&mut regex_syntax::ast::parse::Parser>"},{"line":941,"address":[7112914,7113015],"length":1,"stats":{"Line":16},"fn_name":null},{"line":942,"address":[7113081,7113436,7113233],"length":1,"stats":{"Line":8},"fn_name":null},{"line":943,"address":[7113154,7113239,7113210],"length":1,"stats":{"Line":16},"fn_name":null},{"line":944,"address":[7113558],"length":1,"stats":{"Line":8},"fn_name":null},{"line":945,"address":[7113596],"length":1,"stats":{"Line":8},"fn_name":null},{"line":946,"address":[7113697],"length":1,"stats":{"Line":8},"fn_name":null},{"line":950,"address":[7114553,7113809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":951,"address":[7114246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":952,"address":[7113936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":953,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":954,"address":[7113984,7114098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":955,"address":[7114106],"length":1,"stats":{"Line":0},"fn_name":null},{"line":962,"address":[7114752],"length":1,"stats":{"Line":34},"fn_name":"parse<&mut regex_syntax::ast::parse::Parser>"},{"line":963,"address":[7114770,7114832,7114839],"length":1,"stats":{"Line":80},"fn_name":"{{closure}}<&mut regex_syntax::ast::parse::Parser>"},{"line":968,"address":[7114896,7114986],"length":1,"stats":{"Line":34},"fn_name":"parse_with_comments<&mut regex_syntax::ast::parse::Parser>"},{"line":969,"address":[7114920,7115001,7115132],"length":1,"stats":{"Line":68},"fn_name":null},{"line":970,"address":[7115108,7115625],"length":1,"stats":{"Line":68},"fn_name":null},{"line":971,"address":[7115630],"length":1,"stats":{"Line":34},"fn_name":null},{"line":972,"address":[7122133],"length":1,"stats":{"Line":25},"fn_name":null},{"line":973,"address":[7115782],"length":1,"stats":{"Line":34},"fn_name":null},{"line":974,"address":[7115797],"length":1,"stats":{"Line":34},"fn_name":null},{"line":975,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":977,"address":[7117145,7116477,7123684,7115832,7117787,7119181,7119842,7120503,7121130,7118837],"length":1,"stats":{"Line":181},"fn_name":null},{"line":978,"address":[7116482,7116783,7116823,7116157,7115975],"length":1,"stats":{"Line":65},"fn_name":null},{"line":979,"address":[7116825,7117150],"length":1,"stats":{"Line":24},"fn_name":null},{"line":980,"address":[7117467,7117792],"length":1,"stats":{"Line":8},"fn_name":null},{"line":981,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":982,"address":[7118805,7118125,7118485],"length":1,"stats":{"Line":16},"fn_name":null},{"line":983,"address":[7118315],"length":1,"stats":{"Line":8},"fn_name":null},{"line":985,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":986,"address":[7119032,7119186,7118973],"length":1,"stats":{"Line":16},"fn_name":null},{"line":987,"address":[7118842],"length":1,"stats":{"Line":8},"fn_name":null},{"line":988,"address":[7118930],"length":1,"stats":{"Line":8},"fn_name":null},{"line":991,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":992,"address":[7119634,7119693,7119847],"length":1,"stats":{"Line":16},"fn_name":null},{"line":993,"address":[7119503],"length":1,"stats":{"Line":8},"fn_name":null},{"line":994,"address":[7119591],"length":1,"stats":{"Line":8},"fn_name":null},{"line":997,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":998,"address":[7120508,7120295,7120354],"length":1,"stats":{"Line":46},"fn_name":null},{"line":999,"address":[7120164],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1000,"address":[7120252],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1003,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1004,"address":[7120825,7121135],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1006,"address":[7121452,7116112],"length":1,"stats":{"Line":51},"fn_name":null},{"line":1009,"address":[7122317,7122637,7122138,7115846],"length":1,"stats":{"Line":54},"fn_name":null},{"line":1010,"address":[7122686,7123115,7122298],"length":1,"stats":{"Line":46},"fn_name":null},{"line":1011,"address":[7123405],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1012,"address":[7123120],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1013,"address":[7123373],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1014,"address":[7123244,7123158],"length":1,"stats":{"Line":46},"fn_name":null},{"line":1015,"address":[7123298],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1034,"address":[7124221,7124032],"length":1,"stats":{"Line":23},"fn_name":"parse_uncounted_repetition<&mut regex_syntax::ast::parse::Parser>"},{"line":1039,"address":[7124050,7124151,7124315],"length":1,"stats":{"Line":46},"fn_name":null},{"line":1040,"address":[7124240,7124066,7124170,7124267],"length":1,"stats":{"Line":77},"fn_name":null},{"line":1042,"address":[7124308],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1043,"address":[7124356,7124434],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1044,"address":[7124464,7124382],"length":1,"stats":{"Line":46},"fn_name":null},{"line":1045,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1046,"address":[7124643],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1047,"address":[7124589,7124424],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1051,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1052,"address":[7124531],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1053,"address":[7124926,7125072],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1054,"address":[7124865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1057,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1059,"address":[7124819],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1060,"address":[7125077,7125172,7124835],"length":1,"stats":{"Line":39},"fn_name":null},{"line":1061,"address":[7125149],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1062,"address":[7125165],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1064,"address":[7125182,7125637],"length":1,"stats":{"Line":46},"fn_name":null},{"line":1065,"address":[7125186],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1066,"address":[7125432],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1067,"address":[7125313],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1068,"address":[7125411],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1070,"address":[7125510],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1071,"address":[7125518],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1073,"address":[7125939],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1089,"address":[7126225,7126144],"length":1,"stats":{"Line":8},"fn_name":"parse_counted_repetition<&mut regex_syntax::ast::parse::Parser>"},{"line":1093,"address":[7126247,7126302,7126168],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1094,"address":[7126295],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1095,"address":[7126343,7126421],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1096,"address":[7126369,7126451],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1097,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1098,"address":[7126651],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1099,"address":[7126597,7126411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1104,"address":[7126539],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1105,"address":[7127014,7126934],"length":1,"stats":{"Line":19},"fn_name":null},{"line":1106,"address":[7126865],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1111,"address":[7127023,7126835],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1112,"address":[7127156],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1113,"address":[7127055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1114,"address":[7127145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1117,"address":[7127311,7127368,7127415],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1118,"address":[7127045],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1119,"address":[7127257],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1120,"address":[7127268],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1122,"address":[7127736],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1123,"address":[7127762],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1124,"address":[7127906],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1125,"address":[7127805],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1126,"address":[7127895],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1129,"address":[7128900,7127791,7128011],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1130,"address":[7128028],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1131,"address":[7128172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1132,"address":[7128071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1133,"address":[7128161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1136,"address":[7128277,7128057,7128334],"length":1,"stats":{"Line":26},"fn_name":null},{"line":1137,"address":[7128520,7128416,7128473],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1138,"address":[7128355],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1139,"address":[7128362],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1140,"address":[7128373],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1142,"address":[7128841],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1144,"address":[7128286],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1147,"address":[7128910],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1148,"address":[7129124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1149,"address":[7129023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1150,"address":[7129113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1154,"address":[7128993],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1155,"address":[7129009,7129225,7129320],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1156,"address":[7129297],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1157,"address":[7129313],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1160,"address":[7129322],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1161,"address":[7129412],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1162,"address":[7129599],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1163,"address":[7129489],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1166,"address":[7129453,7130054],"length":1,"stats":{"Line":19},"fn_name":null},{"line":1167,"address":[7129457,7129654],"length":1,"stats":{"Line":17},"fn_name":null},{"line":1168,"address":[7129855],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1169,"address":[7129747],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1170,"address":[7129795],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1172,"address":[7129933],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1173,"address":[7129940],"length":1,"stats":{"Line":11},"fn_name":null},{"line":1175,"address":[7130356],"length":1,"stats":{"Line":11},"fn_name":null},{"line":1197,"address":[7130608,7130689],"length":1,"stats":{"Line":9},"fn_name":"parse_group<&mut regex_syntax::ast::parse::Parser>"},{"line":1198,"address":[7130704,7130834,7130632],"length":1,"stats":{"Line":18},"fn_name":null},{"line":1199,"address":[7130801],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1200,"address":[7131169],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1201,"address":[7131182],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1202,"address":[7131195],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1203,"address":[7131422],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1204,"address":[7131246,7131333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1205,"address":[7131411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1208,"address":[7131220],"length":1,"stats":{"Line":32},"fn_name":null},{"line":1209,"address":[7136698,7133292,7131533],"length":1,"stats":{"Line":77},"fn_name":null},{"line":1210,"address":[7131606],"length":1,"stats":{"Line":31},"fn_name":null},{"line":1211,"address":[7132905,7132089,7132585],"length":1,"stats":{"Line":39},"fn_name":null},{"line":1212,"address":[7133075],"length":1,"stats":{"Line":31},"fn_name":null},{"line":1213,"address":[7132332],"length":1,"stats":{"Line":31},"fn_name":null},{"line":1214,"address":[7132380],"length":1,"stats":{"Line":31},"fn_name":null},{"line":1215,"address":[7132575,7132945],"length":1,"stats":{"Line":62},"fn_name":null},{"line":1217,"address":[7133284,7132897,7131581,7133304,7132910,7135864,7136705],"length":1,"stats":{"Line":83},"fn_name":null},{"line":1218,"address":[7133395],"length":1,"stats":{"Line":13},"fn_name":null},{"line":1219,"address":[7133546],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1220,"address":[7133446],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1223,"address":[7133420,7133836,7133596,7134156],"length":1,"stats":{"Line":38},"fn_name":null},{"line":1224,"address":[7134187,7133819],"length":1,"stats":{"Line":34},"fn_name":null},{"line":1225,"address":[7134202],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1226,"address":[7134209,7134937],"length":1,"stats":{"Line":35},"fn_name":null},{"line":1229,"address":[7134325],"length":1,"stats":{"Line":15},"fn_name":null},{"line":1230,"address":[7134575,7134449],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1231,"address":[7134390],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1232,"address":[7134438],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1235,"address":[7134738],"length":1,"stats":{"Line":15},"fn_name":null},{"line":1236,"address":[7134580,7134380],"length":1,"stats":{"Line":32},"fn_name":null},{"line":1237,"address":[7134676],"length":1,"stats":{"Line":17},"fn_name":null},{"line":1240,"address":[7134219,7135195],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1241,"address":[7135665],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1242,"address":[7134942],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1243,"address":[7134990],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1244,"address":[7135185,7135547],"length":1,"stats":{"Line":20},"fn_name":null},{"line":1248,"address":[7133310,7135869],"length":1,"stats":{"Line":26},"fn_name":null},{"line":1249,"address":[7136507],"length":1,"stats":{"Line":13},"fn_name":null},{"line":1250,"address":[7136275],"length":1,"stats":{"Line":13},"fn_name":null},{"line":1251,"address":[7136327],"length":1,"stats":{"Line":13},"fn_name":null},{"line":1252,"address":[7136361],"length":1,"stats":{"Line":13},"fn_name":null},{"line":1264,"address":[7136928,7137001],"length":1,"stats":{"Line":31},"fn_name":"parse_capture_name<&mut regex_syntax::ast::parse::Parser>"},{"line":1268,"address":[7137023,7136961],"length":1,"stats":{"Line":62},"fn_name":null},{"line":1269,"address":[7137105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1270,"address":[7137055,7137094],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1272,"address":[7137029],"length":1,"stats":{"Line":31},"fn_name":null},{"line":1273,"address":[7137198,7137544],"length":1,"stats":{"Line":62},"fn_name":null},{"line":1274,"address":[7137234],"length":1,"stats":{"Line":31},"fn_name":null},{"line":1275,"address":[7137280],"length":1,"stats":{"Line":31},"fn_name":null},{"line":1277,"address":[7137282,7137266],"length":1,"stats":{"Line":62},"fn_name":null},{"line":1278,"address":[7137435],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1279,"address":[7137403],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1280,"address":[7137424],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1283,"address":[7137386,7137538],"length":1,"stats":{"Line":62},"fn_name":null},{"line":1284,"address":[7137549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1287,"address":[7137200],"length":1,"stats":{"Line":31},"fn_name":null},{"line":1288,"address":[7137562],"length":1,"stats":{"Line":31},"fn_name":null},{"line":1289,"address":[7137644],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1290,"address":[7137612],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1292,"address":[7137740,7137856,7137595],"length":1,"stats":{"Line":62},"fn_name":null},{"line":1293,"address":[7137839],"length":1,"stats":{"Line":31},"fn_name":null},{"line":1294,"address":[7138143],"length":1,"stats":{"Line":31},"fn_name":null},{"line":1295,"address":[7138259],"length":1,"stats":{"Line":31},"fn_name":null},{"line":1296,"address":[7138556],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1297,"address":[7138419],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1298,"address":[7138545],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1302,"address":[7138288],"length":1,"stats":{"Line":31},"fn_name":null},{"line":1303,"address":[7138652],"length":1,"stats":{"Line":31},"fn_name":null},{"line":1306,"address":[7139220,7138846,7138793],"length":1,"stats":{"Line":70},"fn_name":null},{"line":1307,"address":[7139225],"length":1,"stats":{"Line":31},"fn_name":null},{"line":1325,"address":[7139436,7139376],"length":1,"stats":{"Line":15},"fn_name":"parse_flags<&mut regex_syntax::ast::parse::Parser>"},{"line":1326,"address":[7139455,7139394],"length":1,"stats":{"Line":27},"fn_name":null},{"line":1327,"address":[7139566],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1328,"address":[7139586,7141536,7139619],"length":1,"stats":{"Line":44},"fn_name":null},{"line":1329,"address":[7140229,7141202,7139729],"length":1,"stats":{"Line":47},"fn_name":null},{"line":1330,"address":[7139867],"length":1,"stats":{"Line":11},"fn_name":null},{"line":1332,"address":[7140014],"length":1,"stats":{"Line":14},"fn_name":null},{"line":1335,"address":[7140234,7140091],"length":1,"stats":{"Line":19},"fn_name":null},{"line":1336,"address":[7140422,7140563],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1337,"address":[7140271],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1338,"address":[7140363],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1339,"address":[7140294],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1344,"address":[7139749],"length":1,"stats":{"Line":15},"fn_name":null},{"line":1346,"address":[7139841],"length":1,"stats":{"Line":17},"fn_name":null},{"line":1347,"address":[7140747,7140584,7140642],"length":1,"stats":{"Line":30},"fn_name":null},{"line":1349,"address":[7141207,7141064],"length":1,"stats":{"Line":17},"fn_name":null},{"line":1350,"address":[7141379],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1351,"address":[7141244],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1352,"address":[7141320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1353,"address":[7141251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1358,"address":[7141515],"length":1,"stats":{"Line":15},"fn_name":null},{"line":1359,"address":[7141626],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1360,"address":[7141557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1364,"address":[7139701,7141702],"length":1,"stats":{"Line":26},"fn_name":null},{"line":1365,"address":[7141750],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1367,"address":[7141692,7141910],"length":1,"stats":{"Line":34},"fn_name":null},{"line":1368,"address":[7141958],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1377,"address":[7142112],"length":1,"stats":{"Line":17},"fn_name":"parse_flag<&mut regex_syntax::ast::parse::Parser>"},{"line":1378,"address":[7142240,7142315,7142337,7142135,7142265,7142290,7142359],"length":1,"stats":{"Line":75},"fn_name":null},{"line":1379,"address":[7142220,7142161],"length":1,"stats":{"Line":25},"fn_name":null},{"line":1380,"address":[7142245],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1381,"address":[7142270],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1382,"address":[7142295],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1383,"address":[7142317],"length":1,"stats":{"Line":15},"fn_name":null},{"line":1384,"address":[7142339],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1386,"address":[7142372],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1387,"address":[7142361,7142197],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1402,"address":[7142464,7142511],"length":1,"stats":{"Line":26},"fn_name":"parse_primitive<&mut regex_syntax::ast::parse::Parser>"},{"line":1403,"address":[7142487,7143094,7142805,7143386,7142627,7143685],"length":1,"stats":{"Line":125},"fn_name":null},{"line":1404,"address":[7142530,7142622],"length":1,"stats":{"Line":41},"fn_name":null},{"line":1405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1406,"address":[7142632],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1407,"address":[7142709],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1408,"address":[7142716],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1411,"address":[7142852],"length":1,"stats":{"Line":25},"fn_name":null},{"line":1412,"address":[7142826],"length":1,"stats":{"Line":25},"fn_name":null},{"line":1413,"address":[7142844],"length":1,"stats":{"Line":25},"fn_name":null},{"line":1415,"address":[7142995],"length":1,"stats":{"Line":25},"fn_name":null},{"line":1416,"address":[7143002],"length":1,"stats":{"Line":25},"fn_name":null},{"line":1418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1419,"address":[7143144],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1420,"address":[7143118],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1421,"address":[7143136],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1423,"address":[7143287],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1424,"address":[7143294],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1426,"address":[7142582],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1427,"address":[7143418],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1428,"address":[7142589],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1429,"address":[7143410],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1432,"address":[7143586],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1433,"address":[7143593],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1444,"address":[7143873,7143808],"length":1,"stats":{"Line":16},"fn_name":"parse_escape<&mut regex_syntax::ast::parse::Parser>"},{"line":1445,"address":[7143888,7144018,7143840],"length":1,"stats":{"Line":31},"fn_name":null},{"line":1446,"address":[7143985],"length":1,"stats":{"Line":15},"fn_name":null},{"line":1447,"address":[7144353],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1448,"address":[7144538],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1449,"address":[7144497,7144410],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1450,"address":[7144527],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1453,"address":[7144386],"length":1,"stats":{"Line":15},"fn_name":null},{"line":1455,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1456,"address":[7144634],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1457,"address":[7144927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1458,"address":[7145147],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1459,"address":[7144989],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1460,"address":[7145136],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1463,"address":[7144963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1464,"address":[7145245],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1465,"address":[7145341],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1467,"address":[7144666,7145635,7145526],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1468,"address":[7145729],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1469,"address":[7145564,7145640],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1470,"address":[7145718],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1473,"address":[7144725],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1474,"address":[7146264,7145825],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1475,"address":[7145999],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1476,"address":[7146095],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1478,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1479,"address":[7146581,7147020],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1480,"address":[7146755],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1481,"address":[7146851],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1484,"address":[7147337],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1485,"address":[7147358],"length":1,"stats":{"Line":18},"fn_name":null},{"line":1486,"address":[7147454],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1488,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1492,"address":[7144708],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1493,"address":[7147631],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1494,"address":[7147737],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1495,"address":[7147894],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1496,"address":[7147832],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1497,"address":[7147886],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1498,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1501,"address":[7149760,7147771],"length":1,"stats":{"Line":16},"fn_name":"{{closure}}<&mut regex_syntax::ast::parse::Parser>"},{"line":1502,"address":[7149872],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1503,"address":[7149792],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1504,"address":[7149856],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1505,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1508,"address":[7148276,7148772,7148504,7148998,7149438,7148656,7148580,7149218,7148428,7149658,7148352],"length":1,"stats":{"Line":50},"fn_name":null},{"line":1509,"address":[7148205,7147786],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1510,"address":[7148281],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1511,"address":[7148357],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1512,"address":[7148433],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1513,"address":[7148509],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1514,"address":[7148585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1515,"address":[7148767,7148669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1516,"address":[7148694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1518,"address":[7148836],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1519,"address":[7148777],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1520,"address":[7148828],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1522,"address":[7149059],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1523,"address":[7149003],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1524,"address":[7149051],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1526,"address":[7149279],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1527,"address":[7149223],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1528,"address":[7149271],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1530,"address":[7149499],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1531,"address":[7149443],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1532,"address":[7149491],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1534,"address":[7149668,7148108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1546,"address":[7150064],"length":1,"stats":{"Line":1},"fn_name":"parse_octal<&mut regex_syntax::ast::parse::Parser>"},{"line":1550,"address":[7150087,7150146],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1551,"address":[7150135,7150176,7150264],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1552,"address":[7150244],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1554,"address":[7150555,7150586,7150358,7150461,7150505,7150294,7150494,7150413],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1555,"address":[7150450,7150483],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1556,"address":[7150502,7150402],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1557,"address":[7150335,7151100,7151070,7150513],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1559,"address":[7150566],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1560,"address":[7150596],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1563,"address":[7150712],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1564,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1567,"address":[7150804],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1569,"address":[7150856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1580,"address":[7151104],"length":1,"stats":{"Line":10},"fn_name":"parse_hex<&mut regex_syntax::ast::parse::Parser>"},{"line":1581,"address":[7151281,7151181],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1582,"address":[7151193,7151127],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1585,"address":[7151345,7151338,7151270],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1586,"address":[7151340,7151315],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1587,"address":[7151347],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1588,"address":[7151333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1590,"address":[7151357],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1591,"address":[7151472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1592,"address":[7151424,7151391],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1595,"address":[7151381,7151563,7151516],"length":1,"stats":{"Line":36},"fn_name":null},{"line":1596,"address":[7151553],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1598,"address":[7151531],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1610,"address":[7151584,7151652],"length":1,"stats":{"Line":9},"fn_name":"parse_hex_digits<&mut regex_syntax::ast::parse::Parser>"},{"line":1617,"address":[7151675,7151617],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1618,"address":[7151709],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1620,"address":[7151783],"length":1,"stats":{"Line":13},"fn_name":null},{"line":1621,"address":[7152484,7151975,7151790],"length":1,"stats":{"Line":25},"fn_name":null},{"line":1622,"address":[7152005],"length":1,"stats":{"Line":13},"fn_name":null},{"line":1623,"address":[7152147,7152257],"length":1,"stats":{"Line":17},"fn_name":null},{"line":1624,"address":[7152113,7152136],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1626,"address":[7152083,7152266],"length":1,"stats":{"Line":29},"fn_name":null},{"line":1627,"address":[7152348],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1628,"address":[7152330],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1629,"address":[7152337],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1632,"address":[7152287,7152457],"length":1,"stats":{"Line":22},"fn_name":null},{"line":1636,"address":[7151965],"length":1,"stats":{"Line":11},"fn_name":null},{"line":1637,"address":[7152505],"length":1,"stats":{"Line":11},"fn_name":null},{"line":1638,"address":[7152512],"length":1,"stats":{"Line":11},"fn_name":null},{"line":1639,"address":[7152584,7152869,7153077],"length":1,"stats":{"Line":11},"fn_name":null},{"line":1640,"address":[7152724,7152981],"length":1,"stats":{"Line":11},"fn_name":null},{"line":1641,"address":[7152871],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1642,"address":[7152970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1644,"address":[7152749,7153104],"length":1,"stats":{"Line":22},"fn_name":null},{"line":1645,"address":[7152763],"length":1,"stats":{"Line":11},"fn_name":null},{"line":1646,"address":[7153082],"length":1,"stats":{"Line":11},"fn_name":null},{"line":1647,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1656,"address":[7153280,7153355],"length":1,"stats":{"Line":12},"fn_name":"parse_hex_brace<&mut regex_syntax::ast::parse::Parser>"},{"line":1663,"address":[7153313,7153378],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1664,"address":[7153412],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1666,"address":[7153486],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1667,"address":[7153509],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1668,"address":[7153987,7153572],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1669,"address":[7153700],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1670,"address":[7153828,7153938],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1671,"address":[7153794],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1672,"address":[7153817],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1675,"address":[7153748,7153951],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1677,"address":[7153675,7153999],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1678,"address":[7154132],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1679,"address":[7154031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1680,"address":[7154121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1683,"address":[7154021],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1684,"address":[7154233],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1685,"address":[7154363,7154494],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1686,"address":[7154484],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1688,"address":[7154825],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1689,"address":[7154987],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1690,"address":[7154886],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1691,"address":[7154976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1694,"address":[7155279,7155093,7155487,7154846],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1695,"address":[7155178,7155391],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1696,"address":[7155281],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1697,"address":[7155380],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1699,"address":[7155203,7155549],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1700,"address":[7155492,7155217],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1701,"address":[7155534],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1702,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1716,"address":[7155786,7155728],"length":1,"stats":{"Line":8},"fn_name":"parse_decimal<&mut regex_syntax::ast::parse::Parser>"},{"line":1717,"address":[7155806,7155754],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1718,"address":[7155840],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1720,"address":[7155892,7156039],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1721,"address":[7156032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1723,"address":[7156017],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1724,"address":[7156044,7156345],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1725,"address":[7156271],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1726,"address":[7156338],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1728,"address":[7156216,7156350],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1729,"address":[7156533,7156385],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1730,"address":[7156526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1732,"address":[7156494,7156543],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1733,"address":[7156596],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1734,"address":[7156664,7156790,7156848],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1736,"address":[7156855,7157046,7157079,7156630],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1737,"address":[7157048,7156926],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1738,"address":[7157089,7156944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1750,"address":[7157257,7157184],"length":1,"stats":{"Line":8},"fn_name":"parse_set_class<&mut regex_syntax::ast::parse::Parser>"},{"line":1751,"address":[7157208,7157402,7157272],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1753,"address":[7157369,7157733],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1754,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1755,"address":[7161708],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1756,"address":[7157860],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1757,"address":[7157875],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1758,"address":[7157940],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1760,"address":[7160208,7158990,7157910,7160541,7160874,7161207],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1761,"address":[7158045],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1766,"address":[7158429,7158150],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1767,"address":[7158390,7158434],"length":1,"stats":{"Line":17},"fn_name":null},{"line":1768,"address":[7158498],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1769,"address":[7158665],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1772,"address":[7158995,7158670],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1774,"address":[7160078,7159483,7159312,7159615],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1775,"address":[7159591,7160080],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1776,"address":[7160134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1778,"address":[7159932],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1780,"address":[7160314,7160221],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1781,"address":[7160283,7160468,7160323],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1782,"address":[7160429,7160501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1783,"address":[7160333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1784,"address":[7160341],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1787,"address":[7160554,7160647],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1788,"address":[7160801,7160656,7160616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1789,"address":[7160834,7160762],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1790,"address":[7160666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1791,"address":[7160674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1794,"address":[7160887,7160980],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1795,"address":[7160949,7160989,7161134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1796,"address":[7161095,7161167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1797,"address":[7160999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1798,"address":[7161007],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1801,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1802,"address":[7161212,7158140],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1817,"address":[7161888,7161961],"length":1,"stats":{"Line":8},"fn_name":"parse_set_class_range<&mut regex_syntax::ast::parse::Parser>"},{"line":1818,"address":[7162293,7161976,7162591,7161912,7162623],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1819,"address":[7162283],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1820,"address":[7162649],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1821,"address":[7162702,7162778],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1828,"address":[7162945,7162877,7162822,7162675,7162996,7162783],"length":1,"stats":{"Line":48},"fn_name":null},{"line":1829,"address":[7162866,7162904],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1830,"address":[7162808,7162955],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1832,"address":[7163028],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1836,"address":[7163192,7163014],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1837,"address":[7163231],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1839,"address":[7163290,7163943,7163626,7163211],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1841,"address":[7163611,7163972],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1842,"address":[7164584,7164915,7164079,7164289],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1843,"address":[7164972,7165302,7164920,7164417],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1845,"address":[7165620,7165276],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1846,"address":[7165901],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1847,"address":[7165797],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1850,"address":[7165630],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1864,"address":[7166176,7166223],"length":1,"stats":{"Line":8},"fn_name":"parse_set_class_item<&mut regex_syntax::ast::parse::Parser>"},{"line":1865,"address":[7166199,7166282,7166558,7166242],"length":1,"stats":{"Line":32},"fn_name":null},{"line":1866,"address":[7166277],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1868,"address":[7166309],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1869,"address":[7166247],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1870,"address":[7166287],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1871,"address":[7166300],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1873,"address":[7166462],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1874,"address":[7166469],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1895,"address":[7166667,7166608],"length":1,"stats":{"Line":8},"fn_name":"parse_set_class_open<&mut regex_syntax::ast::parse::Parser>"},{"line":1898,"address":[7166634,7166682,7166812],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1899,"address":[7166779],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1900,"address":[7167123],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1901,"address":[7167292],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1902,"address":[7167251,7167164],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1903,"address":[7167281],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1907,"address":[7167447,7167150,7167424,7167392],"length":1,"stats":{"Line":35},"fn_name":null},{"line":1908,"address":[7167416],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1910,"address":[7167405,7167433],"length":1,"stats":{"Line":19},"fn_name":null},{"line":1911,"address":[7167562],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1912,"address":[7167452],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1913,"address":[7167551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1916,"address":[7167439],"length":1,"stats":{"Line":11},"fn_name":null},{"line":1919,"address":[7167658],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1920,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1921,"address":[7167836,7168117,7167802],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1922,"address":[7167898],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1923,"address":[7167883],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1924,"address":[7167890],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1925,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1927,"address":[7168096],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1928,"address":[7168223,7168333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1929,"address":[7168122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1930,"address":[7168212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1936,"address":[7168663,7168338,7167841],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1937,"address":[7168444],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1938,"address":[7168429],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1939,"address":[7168436],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1940,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1942,"address":[7168642],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1943,"address":[7168769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1944,"address":[7168668],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1945,"address":[7168758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1950,"address":[7168870],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1952,"address":[7169119],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1957,"address":[7169318],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1969,"address":[7169568],"length":1,"stats":{"Line":9},"fn_name":"maybe_parse_ascii_class<&mut regex_syntax::ast::parse::Parser>"},{"line":1989,"address":[7169594,7169755],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1991,"address":[7169722],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1992,"address":[7170082],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1993,"address":[7170098],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1994,"address":[7170225],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1995,"address":[7170320,7170342],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1997,"address":[7170351,7170203],"length":1,"stats":{"Line":20},"fn_name":null},{"line":1998,"address":[7170387],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1999,"address":[7170476],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2001,"address":[7170365,7170492,7170536],"length":1,"stats":{"Line":30},"fn_name":null},{"line":2002,"address":[7170501],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2003,"address":[7170517],"length":1,"stats":{"Line":10},"fn_name":null},{"line":2004,"address":[7170546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2005,"address":[7170635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2008,"address":[7170652],"length":1,"stats":{"Line":11},"fn_name":null},{"line":2009,"address":[7170670,7170782],"length":1,"stats":{"Line":22},"fn_name":null},{"line":2010,"address":[7170771,7170788],"length":1,"stats":{"Line":23},"fn_name":null},{"line":2011,"address":[7170828],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2012,"address":[7170917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2014,"address":[7170802,7170934],"length":1,"stats":{"Line":24},"fn_name":null},{"line":2015,"address":[7171053],"length":1,"stats":{"Line":12},"fn_name":null},{"line":2016,"address":[7171113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2017,"address":[7171202],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2019,"address":[7171255,7171090],"length":1,"stats":{"Line":12},"fn_name":null},{"line":2020,"address":[7171257,7171211],"length":1,"stats":{"Line":16},"fn_name":null},{"line":2021,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2022,"address":[7171358,7171242],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2023,"address":[7171431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2026,"address":[7171477],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2027,"address":[7171278,7171440],"length":1,"stats":{"Line":16},"fn_name":null},{"line":2028,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2029,"address":[7171470],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2040,"address":[7171700,7171584],"length":1,"stats":{"Line":8},"fn_name":"parse_unicode_class<&mut regex_syntax::ast::parse::Parser>"},{"line":2041,"address":[7171767,7171722,7171610],"length":1,"stats":{"Line":16},"fn_name":null},{"line":2043,"address":[7171805,7171751],"length":1,"stats":{"Line":16},"fn_name":null},{"line":2044,"address":[7171839],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2046,"address":[7171908],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2047,"address":[7171965],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2048,"address":[7172118,7172177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2049,"address":[7172056,7172033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2052,"address":[7172000,7175670,7172189,7175284],"length":1,"stats":{"Line":32},"fn_name":null},{"line":2053,"address":[7172236],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2054,"address":[7172487,7172299],"length":1,"stats":{"Line":16},"fn_name":null},{"line":2055,"address":[7172416],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2057,"address":[7172402,7172499],"length":1,"stats":{"Line":16},"fn_name":null},{"line":2058,"address":[7172564],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2059,"address":[7172546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2061,"address":[7172672,7172794,7172513],"length":1,"stats":{"Line":16},"fn_name":null},{"line":2062,"address":[7172784],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2064,"address":[7173163],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2065,"address":[7173269,7175282,7173960,7173450],"length":1,"stats":{"Line":16},"fn_name":null},{"line":2067,"address":[7173466],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2068,"address":[7173755],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2069,"address":[7173498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2070,"address":[7173506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2071,"address":[7173612,7173748,7176203],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2074,"address":[7173399,7175280,7173973,7174545,7174059],"length":1,"stats":{"Line":24},"fn_name":null},{"line":2076,"address":[7174075],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2077,"address":[7174340],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2078,"address":[7174107],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2079,"address":[7174115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2080,"address":[7174333,7176153,7174215],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2083,"address":[7174008,7174558,7175133,7174659],"length":1,"stats":{"Line":34},"fn_name":null},{"line":2085,"address":[7174675],"length":1,"stats":{"Line":9},"fn_name":null},{"line":2086,"address":[7174928],"length":1,"stats":{"Line":10},"fn_name":null},{"line":2087,"address":[7174707],"length":1,"stats":{"Line":10},"fn_name":null},{"line":2088,"address":[7174715],"length":1,"stats":{"Line":10},"fn_name":null},{"line":2089,"address":[7174803,7174921,7176103],"length":1,"stats":{"Line":20},"fn_name":null},{"line":2093,"address":[7175138,7174593],"length":1,"stats":{"Line":16},"fn_name":null},{"line":2096,"address":[7172210],"length":1,"stats":{"Line":11},"fn_name":null},{"line":2097,"address":[7175297],"length":1,"stats":{"Line":13},"fn_name":null},{"line":2098,"address":[7175319],"length":1,"stats":{"Line":14},"fn_name":null},{"line":2099,"address":[7175376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2100,"address":[7175358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2101,"address":[7175365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2104,"address":[7175332],"length":1,"stats":{"Line":14},"fn_name":null},{"line":2105,"address":[7175481],"length":1,"stats":{"Line":14},"fn_name":null},{"line":2106,"address":[7175496],"length":1,"stats":{"Line":14},"fn_name":null},{"line":2108,"address":[7175923],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2109,"address":[7175766,7175840],"length":1,"stats":{"Line":16},"fn_name":null},{"line":2110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2111,"address":[7175875],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2119,"address":[7176288],"length":1,"stats":{"Line":15},"fn_name":"parse_perl_class<&mut regex_syntax::ast::parse::Parser>"},{"line":2120,"address":[7176311],"length":1,"stats":{"Line":16},"fn_name":null},{"line":2121,"address":[7176340],"length":1,"stats":{"Line":15},"fn_name":null},{"line":2122,"address":[7176360],"length":1,"stats":{"Line":16},"fn_name":null},{"line":2123,"address":[7176521,7176661,7176591,7176696,7176556,7176801,7176626],"length":1,"stats":{"Line":74},"fn_name":null},{"line":2124,"address":[7176369,7176491],"length":1,"stats":{"Line":24},"fn_name":null},{"line":2125,"address":[7176526],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2126,"address":[7176561],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2127,"address":[7176596],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2128,"address":[7176631],"length":1,"stats":{"Line":16},"fn_name":null},{"line":2129,"address":[7176666],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2130,"address":[7176416,7176703],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2147,"address":[7176960],"length":1,"stats":{"Line":23},"fn_name":"new<&mut regex_syntax::ast::parse::Parser>"},{"line":2152,"address":[7177008],"length":1,"stats":{"Line":23},"fn_name":"check<&mut regex_syntax::ast::parse::Parser>"},{"line":2153,"address":[7177034],"length":1,"stats":{"Line":23},"fn_name":null},{"line":2156,"address":[7177088,7177246],"length":1,"stats":{"Line":24},"fn_name":"increment_depth<&mut regex_syntax::ast::parse::Parser>"},{"line":2157,"address":[7177261,7177840,7177108,7177299],"length":1,"stats":{"Line":48},"fn_name":"{{closure}}<&mut regex_syntax::ast::parse::Parser>"},{"line":2158,"address":[7177866,7177932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2159,"address":[7177872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2160,"address":[7177906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2163,"address":[7177614],"length":1,"stats":{"Line":24},"fn_name":null},{"line":2164,"address":[7177655],"length":1,"stats":{"Line":24},"fn_name":null},{"line":2165,"address":[7177744,7177688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2166,"address":[7177696],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2167,"address":[7177726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2170,"address":[7177663],"length":1,"stats":{"Line":24},"fn_name":null},{"line":2171,"address":[7177680],"length":1,"stats":{"Line":24},"fn_name":null},{"line":2174,"address":[7177968],"length":1,"stats":{"Line":24},"fn_name":"decrement_depth<&mut regex_syntax::ast::parse::Parser>"},{"line":2177,"address":[7177977],"length":1,"stats":{"Line":24},"fn_name":null},{"line":2185,"address":[7178064],"length":1,"stats":{"Line":23},"fn_name":"finish<&mut regex_syntax::ast::parse::Parser>"},{"line":2186,"address":[7178079],"length":1,"stats":{"Line":23},"fn_name":null},{"line":2189,"address":[7178096],"length":1,"stats":{"Line":23},"fn_name":"visit_pre<&mut regex_syntax::ast::parse::Parser>"},{"line":2190,"address":[7178298,7178202,7178252,7178179,7178275],"length":1,"stats":{"Line":93},"fn_name":null},{"line":2191,"address":[7178113],"length":1,"stats":{"Line":23},"fn_name":null},{"line":2192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2196,"address":[7178165],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2199,"address":[7178209],"length":1,"stats":{"Line":23},"fn_name":null},{"line":2201,"address":[7178230],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2202,"address":[7178259],"length":1,"stats":{"Line":30},"fn_name":null},{"line":2203,"address":[7178282],"length":1,"stats":{"Line":31},"fn_name":null},{"line":2204,"address":[7178305],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2205,"address":[7178186],"length":1,"stats":{"Line":24},"fn_name":null},{"line":2207,"address":[7178321],"length":1,"stats":{"Line":24},"fn_name":null},{"line":2210,"address":[7178352],"length":1,"stats":{"Line":23},"fn_name":"visit_post<&mut regex_syntax::ast::parse::Parser>"},{"line":2211,"address":[7178440,7178453],"length":1,"stats":{"Line":23},"fn_name":null},{"line":2212,"address":[7178369],"length":1,"stats":{"Line":23},"fn_name":null},{"line":2213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2217,"address":[7178426],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2220,"address":[7178447],"length":1,"stats":{"Line":23},"fn_name":null},{"line":2222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2227,"address":[7178460],"length":1,"stats":{"Line":24},"fn_name":null},{"line":2228,"address":[7178471],"length":1,"stats":{"Line":24},"fn_name":null},{"line":2233,"address":[7178496],"length":1,"stats":{"Line":8},"fn_name":"visit_class_set_item_pre<&mut regex_syntax::ast::parse::Parser>"},{"line":2237,"address":[7178586],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2238,"address":[7178513],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2245,"address":[7178595],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2247,"address":[7178616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2248,"address":[7178570],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2250,"address":[7178641],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2253,"address":[7178672],"length":1,"stats":{"Line":8},"fn_name":"visit_class_set_item_post<&mut regex_syntax::ast::parse::Parser>"},{"line":2257,"address":[7178716,7178729],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2258,"address":[7178689],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2265,"address":[7178723],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2268,"address":[7178736],"length":1,"stats":{"Line":9},"fn_name":null},{"line":2269,"address":[7178747],"length":1,"stats":{"Line":9},"fn_name":null},{"line":2274,"address":[7178768],"length":1,"stats":{"Line":0},"fn_name":"visit_class_set_binary_op_pre<&mut regex_syntax::ast::parse::Parser>"},{"line":2278,"address":[7178789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2281,"address":[7178816],"length":1,"stats":{"Line":0},"fn_name":"visit_class_set_binary_op_post<&mut regex_syntax::ast::parse::Parser>"},{"line":2285,"address":[7178838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2286,"address":[7178857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2293,"address":[7178945,7178880],"length":1,"stats":{"Line":8},"fn_name":"specialize_err<u32>"},{"line":2298,"address":[7178890,7178994],"length":1,"stats":{"Line":16},"fn_name":null},{"line":2299,"address":[7179107,7179257],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2300,"address":[7179262],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2302,"address":[7179169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2305,"address":[7178960],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":776,"coverable":1034},{"path":["/","usr","src","regex","regex-syntax","src","ast","print.rs"],"content":"/*!\nThis module provides a regular expression printer for `Ast`.\n*/\n\nuse std::fmt;\n\nuse ast::visitor::{self, Visitor};\nuse ast::{self, Ast};\n\n/// A builder for constructing a printer.\n///\n/// Note that since a printer doesn't have any configuration knobs, this type\n/// remains unexported.\n#[derive(Clone, Debug)]\nstruct PrinterBuilder {\n    _priv: (),\n}\n\nimpl Default for PrinterBuilder {\n    fn default() -> PrinterBuilder {\n        PrinterBuilder::new()\n    }\n}\n\nimpl PrinterBuilder {\n    fn new() -> PrinterBuilder {\n        PrinterBuilder { _priv: () }\n    }\n\n    fn build(&self) -> Printer {\n        Printer { _priv: () }\n    }\n}\n\n/// A printer for a regular expression abstract syntax tree.\n///\n/// A printer converts an abstract syntax tree (AST) to a regular expression\n/// pattern string. This particular printer uses constant stack space and heap\n/// space proportional to the size of the AST.\n///\n/// This printer will not necessarily preserve the original formatting of the\n/// regular expression pattern string. For example, all whitespace and comments\n/// are ignored.\n#[derive(Debug)]\npub struct Printer {\n    _priv: (),\n}\n\nimpl Printer {\n    /// Create a new printer.\n    pub fn new() -> Printer {\n        PrinterBuilder::new().build()\n    }\n\n    /// Print the given `Ast` to the given writer. The writer must implement\n    /// `fmt::Write`. Typical implementations of `fmt::Write` that can be used\n    /// here are a `fmt::Formatter` (which is available in `fmt::Display`\n    /// implementations) or a `&mut String`.\n    pub fn print<W: fmt::Write>(&mut self, ast: &Ast, wtr: W) -> fmt::Result {\n        visitor::visit(ast, Writer { printer: self, wtr: wtr })\n    }\n}\n\n#[derive(Debug)]\nstruct Writer<'p, W> {\n    printer: &'p mut Printer,\n    wtr: W,\n}\n\nimpl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    type Output = ();\n    type Err = fmt::Error;\n\n    fn finish(self) -> fmt::Result {\n        Ok(())\n    }\n\n    fn visit_pre(&mut self, ast: &Ast) -> fmt::Result {\n        match *ast {\n            Ast::Group(ref x) => self.fmt_group_pre(x),\n            Ast::Class(ast::Class::Bracketed(ref x)) => {\n                self.fmt_class_bracketed_pre(x)\n            }\n            _ => Ok(()),\n        }\n    }\n\n    fn visit_post(&mut self, ast: &Ast) -> fmt::Result {\n        use ast::Class;\n\n        match *ast {\n            Ast::Empty(_) => Ok(()),\n            Ast::Flags(ref x) => self.fmt_set_flags(x),\n            Ast::Literal(ref x) => self.fmt_literal(x),\n            Ast::Dot(_) => self.wtr.write_str(\".\"),\n            Ast::Assertion(ref x) => self.fmt_assertion(x),\n            Ast::Class(Class::Perl(ref x)) => self.fmt_class_perl(x),\n            Ast::Class(Class::Unicode(ref x)) => self.fmt_class_unicode(x),\n            Ast::Class(Class::Bracketed(ref x)) => {\n                self.fmt_class_bracketed_post(x)\n            }\n            Ast::Repetition(ref x) => self.fmt_repetition(x),\n            Ast::Group(ref x) => self.fmt_group_post(x),\n            Ast::Alternation(_) => Ok(()),\n            Ast::Concat(_) => Ok(()),\n        }\n    }\n\n    fn visit_alternation_in(&mut self) -> fmt::Result {\n        self.wtr.write_str(\"|\")\n    }\n\n    fn visit_class_set_item_pre(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<(), Self::Err> {\n        match *ast {\n            ast::ClassSetItem::Bracketed(ref x) => {\n                self.fmt_class_bracketed_pre(x)\n            }\n            _ => Ok(()),\n        }\n    }\n\n    fn visit_class_set_item_post(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<(), Self::Err> {\n        use ast::ClassSetItem::*;\n\n        match *ast {\n            Empty(_) => Ok(()),\n            Literal(ref x) => self.fmt_literal(x),\n            Range(ref x) => {\n                self.fmt_literal(&x.start)?;\n                self.wtr.write_str(\"-\")?;\n                self.fmt_literal(&x.end)?;\n                Ok(())\n            }\n            Ascii(ref x) => self.fmt_class_ascii(x),\n            Unicode(ref x) => self.fmt_class_unicode(x),\n            Perl(ref x) => self.fmt_class_perl(x),\n            Bracketed(ref x) => self.fmt_class_bracketed_post(x),\n            Union(_) => Ok(()),\n        }\n    }\n\n    fn visit_class_set_binary_op_in(\n        &mut self,\n        ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err> {\n        self.fmt_class_set_binary_op_kind(&ast.kind)\n    }\n}\n\nimpl<'p, W: fmt::Write> Writer<'p, W> {\n    fn fmt_group_pre(&mut self, ast: &ast::Group) -> fmt::Result {\n        use ast::GroupKind::*;\n        match ast.kind {\n            CaptureIndex(_) => self.wtr.write_str(\"(\"),\n            CaptureName(ref x) => {\n                self.wtr.write_str(\"(?P<\")?;\n                self.wtr.write_str(&x.name)?;\n                self.wtr.write_str(\">\")?;\n                Ok(())\n            }\n            NonCapturing(ref flags) => {\n                self.wtr.write_str(\"(?\")?;\n                self.fmt_flags(flags)?;\n                self.wtr.write_str(\":\")?;\n                Ok(())\n            }\n        }\n    }\n\n    fn fmt_group_post(&mut self, _ast: &ast::Group) -> fmt::Result {\n        self.wtr.write_str(\")\")\n    }\n\n    fn fmt_repetition(&mut self, ast: &ast::Repetition) -> fmt::Result {\n        use ast::RepetitionKind::*;\n        match ast.op.kind {\n            ZeroOrOne if ast.greedy => self.wtr.write_str(\"?\"),\n            ZeroOrOne => self.wtr.write_str(\"??\"),\n            ZeroOrMore if ast.greedy => self.wtr.write_str(\"*\"),\n            ZeroOrMore => self.wtr.write_str(\"*?\"),\n            OneOrMore if ast.greedy => self.wtr.write_str(\"+\"),\n            OneOrMore => self.wtr.write_str(\"+?\"),\n            Range(ref x) => {\n                self.fmt_repetition_range(x)?;\n                if !ast.greedy {\n                    self.wtr.write_str(\"?\")?;\n                }\n                Ok(())\n            }\n        }\n    }\n\n    fn fmt_repetition_range(\n        &mut self,\n        ast: &ast::RepetitionRange,\n    ) -> fmt::Result {\n        use ast::RepetitionRange::*;\n        match *ast {\n            Exactly(x) => write!(self.wtr, \"{{{}}}\", x),\n            AtLeast(x) => write!(self.wtr, \"{{{},}}\", x),\n            Bounded(x, y) => write!(self.wtr, \"{{{},{}}}\", x, y),\n        }\n    }\n\n    fn fmt_literal(&mut self, ast: &ast::Literal) -> fmt::Result {\n        use ast::LiteralKind::*;\n\n        match ast.kind {\n            Verbatim => self.wtr.write_char(ast.c),\n            Punctuation => write!(self.wtr, r\"\\{}\", ast.c),\n            Octal => write!(self.wtr, r\"\\{:o}\", ast.c as u32),\n            HexFixed(ast::HexLiteralKind::X) => {\n                write!(self.wtr, r\"\\x{:02X}\", ast.c as u32)\n            }\n            HexFixed(ast::HexLiteralKind::UnicodeShort) => {\n                write!(self.wtr, r\"\\u{:04X}\", ast.c as u32)\n            }\n            HexFixed(ast::HexLiteralKind::UnicodeLong) => {\n                write!(self.wtr, r\"\\U{:08X}\", ast.c as u32)\n            }\n            HexBrace(ast::HexLiteralKind::X) => {\n                write!(self.wtr, r\"\\x{{{:X}}}\", ast.c as u32)\n            }\n            HexBrace(ast::HexLiteralKind::UnicodeShort) => {\n                write!(self.wtr, r\"\\u{{{:X}}}\", ast.c as u32)\n            }\n            HexBrace(ast::HexLiteralKind::UnicodeLong) => {\n                write!(self.wtr, r\"\\U{{{:X}}}\", ast.c as u32)\n            }\n            Special(ast::SpecialLiteralKind::Bell) => {\n                self.wtr.write_str(r\"\\a\")\n            }\n            Special(ast::SpecialLiteralKind::FormFeed) => {\n                self.wtr.write_str(r\"\\f\")\n            }\n            Special(ast::SpecialLiteralKind::Tab) => self.wtr.write_str(r\"\\t\"),\n            Special(ast::SpecialLiteralKind::LineFeed) => {\n                self.wtr.write_str(r\"\\n\")\n            }\n            Special(ast::SpecialLiteralKind::CarriageReturn) => {\n                self.wtr.write_str(r\"\\r\")\n            }\n            Special(ast::SpecialLiteralKind::VerticalTab) => {\n                self.wtr.write_str(r\"\\v\")\n            }\n            Special(ast::SpecialLiteralKind::Space) => {\n                self.wtr.write_str(r\"\\ \")\n            }\n        }\n    }\n\n    fn fmt_assertion(&mut self, ast: &ast::Assertion) -> fmt::Result {\n        use ast::AssertionKind::*;\n        match ast.kind {\n            StartLine => self.wtr.write_str(\"^\"),\n            EndLine => self.wtr.write_str(\"$\"),\n            StartText => self.wtr.write_str(r\"\\A\"),\n            EndText => self.wtr.write_str(r\"\\z\"),\n            WordBoundary => self.wtr.write_str(r\"\\b\"),\n            NotWordBoundary => self.wtr.write_str(r\"\\B\"),\n        }\n    }\n\n    fn fmt_set_flags(&mut self, ast: &ast::SetFlags) -> fmt::Result {\n        self.wtr.write_str(\"(?\")?;\n        self.fmt_flags(&ast.flags)?;\n        self.wtr.write_str(\")\")?;\n        Ok(())\n    }\n\n    fn fmt_flags(&mut self, ast: &ast::Flags) -> fmt::Result {\n        use ast::{Flag, FlagsItemKind};\n\n        for item in &ast.items {\n            match item.kind {\n                FlagsItemKind::Negation => self.wtr.write_str(\"-\"),\n                FlagsItemKind::Flag(ref flag) => match *flag {\n                    Flag::CaseInsensitive => self.wtr.write_str(\"i\"),\n                    Flag::MultiLine => self.wtr.write_str(\"m\"),\n                    Flag::DotMatchesNewLine => self.wtr.write_str(\"s\"),\n                    Flag::SwapGreed => self.wtr.write_str(\"U\"),\n                    Flag::Unicode => self.wtr.write_str(\"u\"),\n                    Flag::IgnoreWhitespace => self.wtr.write_str(\"x\"),\n                },\n            }?;\n        }\n        Ok(())\n    }\n\n    fn fmt_class_bracketed_pre(\n        &mut self,\n        ast: &ast::ClassBracketed,\n    ) -> fmt::Result {\n        if ast.negated {\n            self.wtr.write_str(\"[^\")\n        } else {\n            self.wtr.write_str(\"[\")\n        }\n    }\n\n    fn fmt_class_bracketed_post(\n        &mut self,\n        _ast: &ast::ClassBracketed,\n    ) -> fmt::Result {\n        self.wtr.write_str(\"]\")\n    }\n\n    fn fmt_class_set_binary_op_kind(\n        &mut self,\n        ast: &ast::ClassSetBinaryOpKind,\n    ) -> fmt::Result {\n        use ast::ClassSetBinaryOpKind::*;\n        match *ast {\n            Intersection => self.wtr.write_str(\"&&\"),\n            Difference => self.wtr.write_str(\"--\"),\n            SymmetricDifference => self.wtr.write_str(\"~~\"),\n        }\n    }\n\n    fn fmt_class_perl(&mut self, ast: &ast::ClassPerl) -> fmt::Result {\n        use ast::ClassPerlKind::*;\n        match ast.kind {\n            Digit if ast.negated => self.wtr.write_str(r\"\\D\"),\n            Digit => self.wtr.write_str(r\"\\d\"),\n            Space if ast.negated => self.wtr.write_str(r\"\\S\"),\n            Space => self.wtr.write_str(r\"\\s\"),\n            Word if ast.negated => self.wtr.write_str(r\"\\W\"),\n            Word => self.wtr.write_str(r\"\\w\"),\n        }\n    }\n\n    fn fmt_class_ascii(&mut self, ast: &ast::ClassAscii) -> fmt::Result {\n        use ast::ClassAsciiKind::*;\n        match ast.kind {\n            Alnum if ast.negated => self.wtr.write_str(\"[:^alnum:]\"),\n            Alnum => self.wtr.write_str(\"[:alnum:]\"),\n            Alpha if ast.negated => self.wtr.write_str(\"[:^alpha:]\"),\n            Alpha => self.wtr.write_str(\"[:alpha:]\"),\n            Ascii if ast.negated => self.wtr.write_str(\"[:^ascii:]\"),\n            Ascii => self.wtr.write_str(\"[:ascii:]\"),\n            Blank if ast.negated => self.wtr.write_str(\"[:^blank:]\"),\n            Blank => self.wtr.write_str(\"[:blank:]\"),\n            Cntrl if ast.negated => self.wtr.write_str(\"[:^cntrl:]\"),\n            Cntrl => self.wtr.write_str(\"[:cntrl:]\"),\n            Digit if ast.negated => self.wtr.write_str(\"[:^digit:]\"),\n            Digit => self.wtr.write_str(\"[:digit:]\"),\n            Graph if ast.negated => self.wtr.write_str(\"[:^graph:]\"),\n            Graph => self.wtr.write_str(\"[:graph:]\"),\n            Lower if ast.negated => self.wtr.write_str(\"[:^lower:]\"),\n            Lower => self.wtr.write_str(\"[:lower:]\"),\n            Print if ast.negated => self.wtr.write_str(\"[:^print:]\"),\n            Print => self.wtr.write_str(\"[:print:]\"),\n            Punct if ast.negated => self.wtr.write_str(\"[:^punct:]\"),\n            Punct => self.wtr.write_str(\"[:punct:]\"),\n            Space if ast.negated => self.wtr.write_str(\"[:^space:]\"),\n            Space => self.wtr.write_str(\"[:space:]\"),\n            Upper if ast.negated => self.wtr.write_str(\"[:^upper:]\"),\n            Upper => self.wtr.write_str(\"[:upper:]\"),\n            Word if ast.negated => self.wtr.write_str(\"[:^word:]\"),\n            Word => self.wtr.write_str(\"[:word:]\"),\n            Xdigit if ast.negated => self.wtr.write_str(\"[:^xdigit:]\"),\n            Xdigit => self.wtr.write_str(\"[:xdigit:]\"),\n        }\n    }\n\n    fn fmt_class_unicode(&mut self, ast: &ast::ClassUnicode) -> fmt::Result {\n        use ast::ClassUnicodeKind::*;\n        use ast::ClassUnicodeOpKind::*;\n\n        if ast.negated {\n            self.wtr.write_str(r\"\\P\")?;\n        } else {\n            self.wtr.write_str(r\"\\p\")?;\n        }\n        match ast.kind {\n            OneLetter(c) => self.wtr.write_char(c),\n            Named(ref x) => write!(self.wtr, \"{{{}}}\", x),\n            NamedValue { op: Equal, ref name, ref value } => {\n                write!(self.wtr, \"{{{}={}}}\", name, value)\n            }\n            NamedValue { op: Colon, ref name, ref value } => {\n                write!(self.wtr, \"{{{}:{}}}\", name, value)\n            }\n            NamedValue { op: NotEqual, ref name, ref value } => {\n                write!(self.wtr, \"{{{}!={}}}\", name, value)\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Printer;\n    use ast::parse::ParserBuilder;\n\n    fn roundtrip(given: &str) {\n        roundtrip_with(|b| b, given);\n    }\n\n    fn roundtrip_with<F>(mut f: F, given: &str)\n    where\n        F: FnMut(&mut ParserBuilder) -> &mut ParserBuilder,\n    {\n        let mut builder = ParserBuilder::new();\n        f(&mut builder);\n        let ast = builder.build().parse(given).unwrap();\n\n        let mut printer = Printer::new();\n        let mut dst = String::new();\n        printer.print(&ast, &mut dst).unwrap();\n        assert_eq!(given, dst);\n    }\n\n    #[test]\n    fn print_literal() {\n        roundtrip(\"a\");\n        roundtrip(r\"\\[\");\n        roundtrip_with(|b| b.octal(true), r\"\\141\");\n        roundtrip(r\"\\x61\");\n        roundtrip(r\"\\x7F\");\n        roundtrip(r\"\\u0061\");\n        roundtrip(r\"\\U00000061\");\n        roundtrip(r\"\\x{61}\");\n        roundtrip(r\"\\x{7F}\");\n        roundtrip(r\"\\u{61}\");\n        roundtrip(r\"\\U{61}\");\n\n        roundtrip(r\"\\a\");\n        roundtrip(r\"\\f\");\n        roundtrip(r\"\\t\");\n        roundtrip(r\"\\n\");\n        roundtrip(r\"\\r\");\n        roundtrip(r\"\\v\");\n        roundtrip(r\"(?x)\\ \");\n    }\n\n    #[test]\n    fn print_dot() {\n        roundtrip(\".\");\n    }\n\n    #[test]\n    fn print_concat() {\n        roundtrip(\"ab\");\n        roundtrip(\"abcde\");\n        roundtrip(\"a(bcd)ef\");\n    }\n\n    #[test]\n    fn print_alternation() {\n        roundtrip(\"a|b\");\n        roundtrip(\"a|b|c|d|e\");\n        roundtrip(\"|a|b|c|d|e\");\n        roundtrip(\"|a|b|c|d|e|\");\n        roundtrip(\"a(b|c|d)|e|f\");\n    }\n\n    #[test]\n    fn print_assertion() {\n        roundtrip(r\"^\");\n        roundtrip(r\"$\");\n        roundtrip(r\"\\A\");\n        roundtrip(r\"\\z\");\n        roundtrip(r\"\\b\");\n        roundtrip(r\"\\B\");\n    }\n\n    #[test]\n    fn print_repetition() {\n        roundtrip(\"a?\");\n        roundtrip(\"a??\");\n        roundtrip(\"a*\");\n        roundtrip(\"a*?\");\n        roundtrip(\"a+\");\n        roundtrip(\"a+?\");\n        roundtrip(\"a{5}\");\n        roundtrip(\"a{5}?\");\n        roundtrip(\"a{5,}\");\n        roundtrip(\"a{5,}?\");\n        roundtrip(\"a{5,10}\");\n        roundtrip(\"a{5,10}?\");\n    }\n\n    #[test]\n    fn print_flags() {\n        roundtrip(\"(?i)\");\n        roundtrip(\"(?-i)\");\n        roundtrip(\"(?s-i)\");\n        roundtrip(\"(?-si)\");\n        roundtrip(\"(?siUmux)\");\n    }\n\n    #[test]\n    fn print_group() {\n        roundtrip(\"(?i:a)\");\n        roundtrip(\"(?P<foo>a)\");\n        roundtrip(\"(a)\");\n    }\n\n    #[test]\n    fn print_class() {\n        roundtrip(r\"[abc]\");\n        roundtrip(r\"[a-z]\");\n        roundtrip(r\"[^a-z]\");\n        roundtrip(r\"[a-z0-9]\");\n        roundtrip(r\"[-a-z0-9]\");\n        roundtrip(r\"[-a-z0-9]\");\n        roundtrip(r\"[a-z0-9---]\");\n        roundtrip(r\"[a-z&&m-n]\");\n        roundtrip(r\"[[a-z&&m-n]]\");\n        roundtrip(r\"[a-z--m-n]\");\n        roundtrip(r\"[a-z~~m-n]\");\n        roundtrip(r\"[a-z[0-9]]\");\n        roundtrip(r\"[a-z[^0-9]]\");\n\n        roundtrip(r\"\\d\");\n        roundtrip(r\"\\D\");\n        roundtrip(r\"\\s\");\n        roundtrip(r\"\\S\");\n        roundtrip(r\"\\w\");\n        roundtrip(r\"\\W\");\n\n        roundtrip(r\"[[:alnum:]]\");\n        roundtrip(r\"[[:^alnum:]]\");\n        roundtrip(r\"[[:alpha:]]\");\n        roundtrip(r\"[[:^alpha:]]\");\n        roundtrip(r\"[[:ascii:]]\");\n        roundtrip(r\"[[:^ascii:]]\");\n        roundtrip(r\"[[:blank:]]\");\n        roundtrip(r\"[[:^blank:]]\");\n        roundtrip(r\"[[:cntrl:]]\");\n        roundtrip(r\"[[:^cntrl:]]\");\n        roundtrip(r\"[[:digit:]]\");\n        roundtrip(r\"[[:^digit:]]\");\n        roundtrip(r\"[[:graph:]]\");\n        roundtrip(r\"[[:^graph:]]\");\n        roundtrip(r\"[[:lower:]]\");\n        roundtrip(r\"[[:^lower:]]\");\n        roundtrip(r\"[[:print:]]\");\n        roundtrip(r\"[[:^print:]]\");\n        roundtrip(r\"[[:punct:]]\");\n        roundtrip(r\"[[:^punct:]]\");\n        roundtrip(r\"[[:space:]]\");\n        roundtrip(r\"[[:^space:]]\");\n        roundtrip(r\"[[:upper:]]\");\n        roundtrip(r\"[[:^upper:]]\");\n        roundtrip(r\"[[:word:]]\");\n        roundtrip(r\"[[:^word:]]\");\n        roundtrip(r\"[[:xdigit:]]\");\n        roundtrip(r\"[[:^xdigit:]]\");\n\n        roundtrip(r\"\\pL\");\n        roundtrip(r\"\\PL\");\n        roundtrip(r\"\\p{L}\");\n        roundtrip(r\"\\P{L}\");\n        roundtrip(r\"\\p{X=Y}\");\n        roundtrip(r\"\\P{X=Y}\");\n        roundtrip(r\"\\p{X:Y}\");\n        roundtrip(r\"\\P{X:Y}\");\n        roundtrip(r\"\\p{X!=Y}\");\n        roundtrip(r\"\\P{X!=Y}\");\n    }\n}\n","traces":[{"line":20,"address":[6443920],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":21,"address":[6443921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[6443936],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[6443952],"length":1,"stats":{"Line":0},"fn_name":"build"},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[6443968],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":52,"address":[6443969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[6816112],"length":1,"stats":{"Line":0},"fn_name":"print<&mut core::fmt::Formatter>"},{"line":60,"address":[6816131],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[6816192],"length":1,"stats":{"Line":0},"fn_name":"finish<&mut core::fmt::Formatter>"},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[6816224],"length":1,"stats":{"Line":0},"fn_name":"visit_pre<&mut core::fmt::Formatter>"},{"line":79,"address":[6816337,6816381,6816285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[6816306,6816238],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[6816292,6816344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[6816366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[6816280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[6816400],"length":1,"stats":{"Line":0},"fn_name":"visit_post<&mut core::fmt::Formatter>"},{"line":91,"address":[6816644,6816685,6816861,6816899,6816505,6816515,6816779,6816498,6816597,6816732,6816823,6816556],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[6816414,6816510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[6816525],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[6816566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[6816614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[6816654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[6816695,6816458],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[6816742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[6816786],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[6816808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[6816830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[6816868],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[6816901],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[6816500],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[6816928],"length":1,"stats":{"Line":0},"fn_name":"visit_alternation_in<&mut core::fmt::Formatter>"},{"line":110,"address":[6816944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[6816992],"length":1,"stats":{"Line":0},"fn_name":"visit_class_set_item_pre<&mut core::fmt::Formatter>"},{"line":117,"address":[6817027,6817071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[6817034,6817006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[6817050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[6817022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[6817088],"length":1,"stats":{"Line":0},"fn_name":"visit_class_set_item_post<&mut core::fmt::Formatter>"},{"line":131,"address":[6817534,6817691,6817738,6817647,6817743,6817161,6817205,6817603,6817149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[6817105,6817156],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[6817171],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[6817215],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[6817229,6817374,6817347],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[6817394,6817317,6817464],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[6817539,6817438,6817490],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[6817529],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[6817569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[6817613],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[6817657],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[6817701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[6817144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[6817744],"length":1,"stats":{"Line":0},"fn_name":"visit_class_set_binary_op_in<&mut core::fmt::Formatter>"},{"line":152,"address":[6817758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[6817792],"length":1,"stats":{"Line":0},"fn_name":"fmt_group_pre<&mut core::fmt::Formatter>"},{"line":159,"address":[6817974,6817930,6818645,6818368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[6817809,6817944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[6817991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[6818018,6818169,6818142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[6818099,6818200,6818295],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[6818265,6818373,6818324],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[6818363],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[6817865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[6817892,6818402,6818463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[6818494,6818451,6818575],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[6818650,6818545,6818601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[6818640],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[6818688],"length":1,"stats":{"Line":0},"fn_name":"fmt_group_post<&mut core::fmt::Formatter>"},{"line":177,"address":[6818709],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[6818752],"length":1,"stats":{"Line":0},"fn_name":"fmt_repetition<&mut core::fmt::Formatter>"},{"line":182,"address":[6819080,6819189,6818971,6818870,6819409,6819414],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[6818877,6818766],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[6818939],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[6818986],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[6819048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[6819095],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[6819157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[6818830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[6819257,6819281,6818852,6819197],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[6819241,6819380],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[6819309,6819382],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[6819404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[6819424],"length":1,"stats":{"Line":0},"fn_name":"fmt_repetition_range<&mut core::fmt::Formatter>"},{"line":204,"address":[6820108,6819675,6820280,6819890],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[6819692,6819447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[6819910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[6820128,6819521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[6820304],"length":1,"stats":{"Line":0},"fn_name":"fmt_literal<&mut core::fmt::Formatter>"},{"line":214,"address":[6820871,6820439,6820641,6821946,6822603,6822656,6822709,6821668,6822815,6822762,6822169,6821112,6822386,6821390,6822915,6822865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[6820327,6820606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[6820661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[6820891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[6820389],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[6821132],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[6821410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[6821688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[6820449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[6821966],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[6822189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[6822406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[6820507],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[6822623],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[6822676],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[6822729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[6822782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[6822832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[6822882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[6820560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[6822944],"length":1,"stats":{"Line":0},"fn_name":"fmt_assertion<&mut core::fmt::Formatter>"},{"line":260,"address":[6823222,6823131,6823178,6823266,6823084,6823040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[6822958,6823054],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[6823101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[6823148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[6823192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[6823236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[6823005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[6823296],"length":1,"stats":{"Line":0},"fn_name":"fmt_set_flags<&mut core::fmt::Formatter>"},{"line":271,"address":[6823317,6823432,6823456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[6823555,6823406,6823474],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[6823525,6823633,6823584],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[6823623],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[6823664],"length":1,"stats":{"Line":0},"fn_name":"fmt_flags<&mut core::fmt::Formatter>"},{"line":280,"address":[6823780,6824250,6823681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[6823929,6823885,6824211,6824255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[6823899,6823808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[6824072,6824025,6824119,6823981,6824163,6824207,6823836],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[6823853,6823995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[6824042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[6824089],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[6824133],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[6824177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[6823946],"length":1,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[6823770],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[6824304],"length":1,"stats":{"Line":0},"fn_name":"fmt_class_bracketed_pre<&mut core::fmt::Formatter>"},{"line":300,"address":[6824418,6824318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[6824388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[6824344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[6824448],"length":1,"stats":{"Line":0},"fn_name":"fmt_class_bracketed_post<&mut core::fmt::Formatter>"},{"line":311,"address":[6824469],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[6824512],"length":1,"stats":{"Line":0},"fn_name":"fmt_class_set_binary_op_kind<&mut core::fmt::Formatter>"},{"line":319,"address":[6824603,6824691,6824647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[6824617,6824526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[6824661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[6824571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[6824720],"length":1,"stats":{"Line":0},"fn_name":"fmt_class_perl<&mut core::fmt::Formatter>"},{"line":328,"address":[6825093,6824881,6824990,6824780],"length":1,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[6824787,6824734],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[6824849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[6824896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[6824958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[6824999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[6825061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[6825120],"length":1,"stats":{"Line":0},"fn_name":"fmt_class_ascii<&mut core::fmt::Formatter>"},{"line":340,"address":[6826585,6825495,6825713,6825822,6826040,6826476,6825931,6825277,6826367,6825604,6826688,6825386,6826149,6825176,6826258],"length":1,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[6825183,6825134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[6825245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[6825292],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[6825354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[6825401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[6825463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[6825510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[6825572],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[6825619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[6825681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[6825728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[6825790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[6825837],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[6825899],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[6825946],"length":1,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[6826008],"length":1,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[6826055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[6826117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[6826164],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[6826226],"length":1,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[6826273],"length":1,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[6826335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[6826382],"length":1,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[6826444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[6826491],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[6826553],"length":1,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[6826594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[6826656],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[6826720],"length":1,"stats":{"Line":0},"fn_name":"fmt_class_unicode<&mut core::fmt::Formatter>"},{"line":376,"address":[6827020,6826743,6826914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[6826831,6826949,6826919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[6826975,6826780,6827022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[6827410,6827355,6828030,6828551,6828375,6828556,6827667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[6827365,6827055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[6827430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[6827108,6827687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[6827743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[6828050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[6828106],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[6827168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[6828395,6827224],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":206},{"path":["/","usr","src","regex","regex-syntax","src","ast","visitor.rs"],"content":"use std::fmt;\n\nuse ast::{self, Ast};\n\n/// A trait for visiting an abstract syntax tree (AST) in depth first order.\n///\n/// The principle aim of this trait is to enable callers to perform case\n/// analysis on an abstract syntax tree without necessarily using recursion.\n/// In particular, this permits callers to do case analysis with constant stack\n/// usage, which can be important since the size of an abstract syntax tree\n/// may be proportional to end user input.\n///\n/// Typical usage of this trait involves providing an implementation and then\n/// running it using the [`visit`](fn.visit.html) function.\n///\n/// Note that the abstract syntax tree for a regular expression is quite\n/// complex. Unless you specifically need it, you might be able to use the\n/// much simpler\n/// [high-level intermediate representation](../hir/struct.Hir.html)\n/// and its\n/// [corresponding `Visitor` trait](../hir/trait.Visitor.html)\n/// instead.\npub trait Visitor {\n    /// The result of visiting an AST.\n    type Output;\n    /// An error that visiting an AST might return.\n    type Err;\n\n    /// All implementors of `Visitor` must provide a `finish` method, which\n    /// yields the result of visiting the AST or an error.\n    fn finish(self) -> Result<Self::Output, Self::Err>;\n\n    /// This method is called before beginning traversal of the AST.\n    fn start(&mut self) {}\n\n    /// This method is called on an `Ast` before descending into child `Ast`\n    /// nodes.\n    fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n        Ok(())\n    }\n\n    /// This method is called on an `Ast` after descending all of its child\n    /// `Ast` nodes.\n    fn visit_post(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n        Ok(())\n    }\n\n    /// This method is called between child nodes of an\n    /// [`Alternation`](struct.Alternation.html).\n    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {\n        Ok(())\n    }\n\n    /// This method is called on every\n    /// [`ClassSetItem`](enum.ClassSetItem.html)\n    /// before descending into child nodes.\n    fn visit_class_set_item_pre(\n        &mut self,\n        _ast: &ast::ClassSetItem,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n\n    /// This method is called on every\n    /// [`ClassSetItem`](enum.ClassSetItem.html)\n    /// after descending into child nodes.\n    fn visit_class_set_item_post(\n        &mut self,\n        _ast: &ast::ClassSetItem,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n\n    /// This method is called on every\n    /// [`ClassSetBinaryOp`](struct.ClassSetBinaryOp.html)\n    /// before descending into child nodes.\n    fn visit_class_set_binary_op_pre(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n\n    /// This method is called on every\n    /// [`ClassSetBinaryOp`](struct.ClassSetBinaryOp.html)\n    /// after descending into child nodes.\n    fn visit_class_set_binary_op_post(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n\n    /// This method is called between the left hand and right hand child nodes\n    /// of a [`ClassSetBinaryOp`](struct.ClassSetBinaryOp.html).\n    fn visit_class_set_binary_op_in(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n}\n\n/// Executes an implementation of `Visitor` in constant stack space.\n///\n/// This function will visit every node in the given `Ast` while calling the\n/// appropriate methods provided by the\n/// [`Visitor`](trait.Visitor.html) trait.\n///\n/// The primary use case for this method is when one wants to perform case\n/// analysis over an `Ast` without using a stack size proportional to the depth\n/// of the `Ast`. Namely, this method will instead use constant stack size, but\n/// will use heap space proportional to the size of the `Ast`. This may be\n/// desirable in cases where the size of `Ast` is proportional to end user\n/// input.\n///\n/// If the visitor returns an error at any point, then visiting is stopped and\n/// the error is returned.\npub fn visit<V: Visitor>(ast: &Ast, visitor: V) -> Result<V::Output, V::Err> {\n    HeapVisitor::new().visit(ast, visitor)\n}\n\n/// HeapVisitor visits every item in an `Ast` recursively using constant stack\n/// size and a heap size proportional to the size of the `Ast`.\nstruct HeapVisitor<'a> {\n    /// A stack of `Ast` nodes. This is roughly analogous to the call stack\n    /// used in a typical recursive visitor.\n    stack: Vec<(&'a Ast, Frame<'a>)>,\n    /// Similar to the `Ast` stack above, but is used only for character\n    /// classes. In particular, character classes embed their own mini\n    /// recursive syntax.\n    stack_class: Vec<(ClassInduct<'a>, ClassFrame<'a>)>,\n}\n\n/// Represents a single stack frame while performing structural induction over\n/// an `Ast`.\nenum Frame<'a> {\n    /// A stack frame allocated just before descending into a repetition\n    /// operator's child node.\n    Repetition(&'a ast::Repetition),\n    /// A stack frame allocated just before descending into a group's child\n    /// node.\n    Group(&'a ast::Group),\n    /// The stack frame used while visiting every child node of a concatenation\n    /// of expressions.\n    Concat {\n        /// The child node we are currently visiting.\n        head: &'a Ast,\n        /// The remaining child nodes to visit (which may be empty).\n        tail: &'a [Ast],\n    },\n    /// The stack frame used while visiting every child node of an alternation\n    /// of expressions.\n    Alternation {\n        /// The child node we are currently visiting.\n        head: &'a Ast,\n        /// The remaining child nodes to visit (which may be empty).\n        tail: &'a [Ast],\n    },\n}\n\n/// Represents a single stack frame while performing structural induction over\n/// a character class.\nenum ClassFrame<'a> {\n    /// The stack frame used while visiting every child node of a union of\n    /// character class items.\n    Union {\n        /// The child node we are currently visiting.\n        head: &'a ast::ClassSetItem,\n        /// The remaining child nodes to visit (which may be empty).\n        tail: &'a [ast::ClassSetItem],\n    },\n    /// The stack frame used while a binary class operation.\n    Binary { op: &'a ast::ClassSetBinaryOp },\n    /// A stack frame allocated just before descending into a binary operator's\n    /// left hand child node.\n    BinaryLHS {\n        op: &'a ast::ClassSetBinaryOp,\n        lhs: &'a ast::ClassSet,\n        rhs: &'a ast::ClassSet,\n    },\n    /// A stack frame allocated just before descending into a binary operator's\n    /// right hand child node.\n    BinaryRHS { op: &'a ast::ClassSetBinaryOp, rhs: &'a ast::ClassSet },\n}\n\n/// A representation of the inductive step when performing structural induction\n/// over a character class.\n///\n/// Note that there is no analogous explicit type for the inductive step for\n/// `Ast` nodes because the inductive step is just an `Ast`. For character\n/// classes, the inductive step can produce one of two possible child nodes:\n/// an item or a binary operation. (An item cannot be a binary operation\n/// because that would imply binary operations can be unioned in the concrete\n/// syntax, which is not possible.)\nenum ClassInduct<'a> {\n    Item(&'a ast::ClassSetItem),\n    BinaryOp(&'a ast::ClassSetBinaryOp),\n}\n\nimpl<'a> HeapVisitor<'a> {\n    fn new() -> HeapVisitor<'a> {\n        HeapVisitor { stack: vec![], stack_class: vec![] }\n    }\n\n    fn visit<V: Visitor>(\n        &mut self,\n        mut ast: &'a Ast,\n        mut visitor: V,\n    ) -> Result<V::Output, V::Err> {\n        self.stack.clear();\n        self.stack_class.clear();\n\n        visitor.start();\n        loop {\n            visitor.visit_pre(ast)?;\n            if let Some(x) = self.induct(ast, &mut visitor)? {\n                let child = x.child();\n                self.stack.push((ast, x));\n                ast = child;\n                continue;\n            }\n            // No induction means we have a base case, so we can post visit\n            // it now.\n            visitor.visit_post(ast)?;\n\n            // At this point, we now try to pop our call stack until it is\n            // either empty or we hit another inductive case.\n            loop {\n                let (post_ast, frame) = match self.stack.pop() {\n                    None => return visitor.finish(),\n                    Some((post_ast, frame)) => (post_ast, frame),\n                };\n                // If this is a concat/alternate, then we might have additional\n                // inductive steps to process.\n                if let Some(x) = self.pop(frame) {\n                    if let Frame::Alternation { .. } = x {\n                        visitor.visit_alternation_in()?;\n                    }\n                    ast = x.child();\n                    self.stack.push((post_ast, x));\n                    break;\n                }\n                // Otherwise, we've finished visiting all the child nodes for\n                // this AST, so we can post visit it now.\n                visitor.visit_post(post_ast)?;\n            }\n        }\n    }\n\n    /// Build a stack frame for the given AST if one is needed (which occurs if\n    /// and only if there are child nodes in the AST). Otherwise, return None.\n    ///\n    /// If this visits a class, then the underlying visitor implementation may\n    /// return an error which will be passed on here.\n    fn induct<V: Visitor>(\n        &mut self,\n        ast: &'a Ast,\n        visitor: &mut V,\n    ) -> Result<Option<Frame<'a>>, V::Err> {\n        Ok(match *ast {\n            Ast::Class(ast::Class::Bracketed(ref x)) => {\n                self.visit_class(x, visitor)?;\n                None\n            }\n            Ast::Repetition(ref x) => Some(Frame::Repetition(x)),\n            Ast::Group(ref x) => Some(Frame::Group(x)),\n            Ast::Concat(ref x) if x.asts.is_empty() => None,\n            Ast::Concat(ref x) => {\n                Some(Frame::Concat { head: &x.asts[0], tail: &x.asts[1..] })\n            }\n            Ast::Alternation(ref x) if x.asts.is_empty() => None,\n            Ast::Alternation(ref x) => Some(Frame::Alternation {\n                head: &x.asts[0],\n                tail: &x.asts[1..],\n            }),\n            _ => None,\n        })\n    }\n\n    /// Pops the given frame. If the frame has an additional inductive step,\n    /// then return it, otherwise return `None`.\n    fn pop(&self, induct: Frame<'a>) -> Option<Frame<'a>> {\n        match induct {\n            Frame::Repetition(_) => None,\n            Frame::Group(_) => None,\n            Frame::Concat { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(Frame::Concat { head: &tail[0], tail: &tail[1..] })\n                }\n            }\n            Frame::Alternation { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(Frame::Alternation {\n                        head: &tail[0],\n                        tail: &tail[1..],\n                    })\n                }\n            }\n        }\n    }\n\n    fn visit_class<V: Visitor>(\n        &mut self,\n        ast: &'a ast::ClassBracketed,\n        visitor: &mut V,\n    ) -> Result<(), V::Err> {\n        let mut ast = ClassInduct::from_bracketed(ast);\n        loop {\n            self.visit_class_pre(&ast, visitor)?;\n            if let Some(x) = self.induct_class(&ast) {\n                let child = x.child();\n                self.stack_class.push((ast, x));\n                ast = child;\n                continue;\n            }\n            self.visit_class_post(&ast, visitor)?;\n\n            // At this point, we now try to pop our call stack until it is\n            // either empty or we hit another inductive case.\n            loop {\n                let (post_ast, frame) = match self.stack_class.pop() {\n                    None => return Ok(()),\n                    Some((post_ast, frame)) => (post_ast, frame),\n                };\n                // If this is a union or a binary op, then we might have\n                // additional inductive steps to process.\n                if let Some(x) = self.pop_class(frame) {\n                    if let ClassFrame::BinaryRHS { ref op, .. } = x {\n                        visitor.visit_class_set_binary_op_in(op)?;\n                    }\n                    ast = x.child();\n                    self.stack_class.push((post_ast, x));\n                    break;\n                }\n                // Otherwise, we've finished visiting all the child nodes for\n                // this class node, so we can post visit it now.\n                self.visit_class_post(&post_ast, visitor)?;\n            }\n        }\n    }\n\n    /// Call the appropriate `Visitor` methods given an inductive step.\n    fn visit_class_pre<V: Visitor>(\n        &self,\n        ast: &ClassInduct<'a>,\n        visitor: &mut V,\n    ) -> Result<(), V::Err> {\n        match *ast {\n            ClassInduct::Item(item) => {\n                visitor.visit_class_set_item_pre(item)?;\n            }\n            ClassInduct::BinaryOp(op) => {\n                visitor.visit_class_set_binary_op_pre(op)?;\n            }\n        }\n        Ok(())\n    }\n\n    /// Call the appropriate `Visitor` methods given an inductive step.\n    fn visit_class_post<V: Visitor>(\n        &self,\n        ast: &ClassInduct<'a>,\n        visitor: &mut V,\n    ) -> Result<(), V::Err> {\n        match *ast {\n            ClassInduct::Item(item) => {\n                visitor.visit_class_set_item_post(item)?;\n            }\n            ClassInduct::BinaryOp(op) => {\n                visitor.visit_class_set_binary_op_post(op)?;\n            }\n        }\n        Ok(())\n    }\n\n    /// Build a stack frame for the given class node if one is needed (which\n    /// occurs if and only if there are child nodes). Otherwise, return None.\n    fn induct_class(&self, ast: &ClassInduct<'a>) -> Option<ClassFrame<'a>> {\n        match *ast {\n            ClassInduct::Item(&ast::ClassSetItem::Bracketed(ref x)) => {\n                match x.kind {\n                    ast::ClassSet::Item(ref item) => {\n                        Some(ClassFrame::Union { head: item, tail: &[] })\n                    }\n                    ast::ClassSet::BinaryOp(ref op) => {\n                        Some(ClassFrame::Binary { op: op })\n                    }\n                }\n            }\n            ClassInduct::Item(&ast::ClassSetItem::Union(ref x)) => {\n                if x.items.is_empty() {\n                    None\n                } else {\n                    Some(ClassFrame::Union {\n                        head: &x.items[0],\n                        tail: &x.items[1..],\n                    })\n                }\n            }\n            ClassInduct::BinaryOp(op) => Some(ClassFrame::BinaryLHS {\n                op: op,\n                lhs: &op.lhs,\n                rhs: &op.rhs,\n            }),\n            _ => None,\n        }\n    }\n\n    /// Pops the given frame. If the frame has an additional inductive step,\n    /// then return it, otherwise return `None`.\n    fn pop_class(&self, induct: ClassFrame<'a>) -> Option<ClassFrame<'a>> {\n        match induct {\n            ClassFrame::Union { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(ClassFrame::Union {\n                        head: &tail[0],\n                        tail: &tail[1..],\n                    })\n                }\n            }\n            ClassFrame::Binary { .. } => None,\n            ClassFrame::BinaryLHS { op, rhs, .. } => {\n                Some(ClassFrame::BinaryRHS { op: op, rhs: rhs })\n            }\n            ClassFrame::BinaryRHS { .. } => None,\n        }\n    }\n}\n\nimpl<'a> Frame<'a> {\n    /// Perform the next inductive step on this frame and return the next\n    /// child AST node to visit.\n    fn child(&self) -> &'a Ast {\n        match *self {\n            Frame::Repetition(rep) => &rep.ast,\n            Frame::Group(group) => &group.ast,\n            Frame::Concat { head, .. } => head,\n            Frame::Alternation { head, .. } => head,\n        }\n    }\n}\n\nimpl<'a> ClassFrame<'a> {\n    /// Perform the next inductive step on this frame and return the next\n    /// child class node to visit.\n    fn child(&self) -> ClassInduct<'a> {\n        match *self {\n            ClassFrame::Union { head, .. } => ClassInduct::Item(head),\n            ClassFrame::Binary { op, .. } => ClassInduct::BinaryOp(op),\n            ClassFrame::BinaryLHS { ref lhs, .. } => {\n                ClassInduct::from_set(lhs)\n            }\n            ClassFrame::BinaryRHS { ref rhs, .. } => {\n                ClassInduct::from_set(rhs)\n            }\n        }\n    }\n}\n\nimpl<'a> ClassInduct<'a> {\n    fn from_bracketed(ast: &'a ast::ClassBracketed) -> ClassInduct<'a> {\n        ClassInduct::from_set(&ast.kind)\n    }\n\n    fn from_set(ast: &'a ast::ClassSet) -> ClassInduct<'a> {\n        match *ast {\n            ast::ClassSet::Item(ref item) => ClassInduct::Item(item),\n            ast::ClassSet::BinaryOp(ref op) => ClassInduct::BinaryOp(op),\n        }\n    }\n}\n\nimpl<'a> fmt::Debug for ClassFrame<'a> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let x = match *self {\n            ClassFrame::Union { .. } => \"Union\",\n            ClassFrame::Binary { .. } => \"Binary\",\n            ClassFrame::BinaryLHS { .. } => \"BinaryLHS\",\n            ClassFrame::BinaryRHS { .. } => \"BinaryRHS\",\n        };\n        write!(f, \"{}\", x)\n    }\n}\n\nimpl<'a> fmt::Debug for ClassInduct<'a> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let x = match *self {\n            ClassInduct::Item(it) => match *it {\n                ast::ClassSetItem::Empty(_) => \"Item(Empty)\",\n                ast::ClassSetItem::Literal(_) => \"Item(Literal)\",\n                ast::ClassSetItem::Range(_) => \"Item(Range)\",\n                ast::ClassSetItem::Ascii(_) => \"Item(Ascii)\",\n                ast::ClassSetItem::Perl(_) => \"Item(Perl)\",\n                ast::ClassSetItem::Unicode(_) => \"Item(Unicode)\",\n                ast::ClassSetItem::Bracketed(_) => \"Item(Bracketed)\",\n                ast::ClassSetItem::Union(_) => \"Item(Union)\",\n            },\n            ClassInduct::BinaryOp(it) => match it.kind {\n                ast::ClassSetBinaryOpKind::Intersection => {\n                    \"BinaryOp(Intersection)\"\n                }\n                ast::ClassSetBinaryOpKind::Difference => {\n                    \"BinaryOp(Difference)\"\n                }\n                ast::ClassSetBinaryOpKind::SymmetricDifference => {\n                    \"BinaryOp(SymmetricDifference)\"\n                }\n            },\n        };\n        write!(f, \"{}\", x)\n    }\n}\n","traces":[{"line":34,"address":[6539895,6539893,6539888],"length":1,"stats":{"Line":92},"fn_name":"start<regex_syntax::hir::translate::TranslatorI>"},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[6539904],"length":1,"stats":{"Line":16},"fn_name":"visit_alternation_in<regex_syntax::hir::translate::TranslatorI>"},{"line":51,"address":[6539912],"length":1,"stats":{"Line":16},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[6828576],"length":1,"stats":{"Line":0},"fn_name":"visit_class_set_binary_op_pre<regex_syntax::ast::print::Writer<&mut core::fmt::Formatter>>"},{"line":81,"address":[6828590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[6828624],"length":1,"stats":{"Line":0},"fn_name":"visit_class_set_binary_op_post<regex_syntax::ast::print::Writer<&mut core::fmt::Formatter>>"},{"line":91,"address":[6828638],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[7179712],"length":1,"stats":{"Line":0},"fn_name":"visit_class_set_binary_op_in<regex_syntax::ast::parse::NestLimiter<&mut regex_syntax::ast::parse::Parser>>"},{"line":100,"address":[7179728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[7036912,7036989,7037136,7037203,7037408,7037474],"length":1,"stats":{"Line":46},"fn_name":"visit<regex_syntax::ast::parse::NestLimiter<&mut regex_syntax::ast::parse::Parser>>"},{"line":120,"address":[7037218,7037486,7037001,7037154,7036936,7037430],"length":1,"stats":{"Line":92},"fn_name":null},{"line":202,"address":[7383216,7383270],"length":1,"stats":{"Line":23},"fn_name":"new"},{"line":203,"address":[7383232,7383291],"length":1,"stats":{"Line":46},"fn_name":null},{"line":206,"address":[7040960,7043902,7037694,7041033,7043840,7037616],"length":1,"stats":{"Line":46},"fn_name":"visit<regex_syntax::ast::parse::NestLimiter<&mut regex_syntax::ast::parse::Parser>>"},{"line":211,"address":[7037649,7040983,7043870],"length":1,"stats":{"Line":46},"fn_name":null},{"line":212,"address":[7041053,7043922,7037714],"length":1,"stats":{"Line":46},"fn_name":null},{"line":214,"address":[7043940,7037732,7041071],"length":1,"stats":{"Line":46},"fn_name":null},{"line":215,"address":[7043956,7040392,7037748,7045471,7041087,7043369],"length":1,"stats":{"Line":95},"fn_name":null},{"line":216,"address":[7041089,7043958,7037750],"length":1,"stats":{"Line":46},"fn_name":null},{"line":217,"address":[7041928,7038265,7044431,7044112,7041507,7038782,7038175,7041417,7044211],"length":1,"stats":{"Line":142},"fn_name":null},{"line":218,"address":[7038814,7044457,7041960],"length":1,"stats":{"Line":49},"fn_name":null},{"line":219,"address":[7038851,7041997,7044494],"length":1,"stats":{"Line":56},"fn_name":null},{"line":220,"address":[7042103,7044600,7038957],"length":1,"stats":{"Line":56},"fn_name":null},{"line":221,"address":[7044605,7042108,7038962],"length":1,"stats":{"Line":56},"fn_name":null},{"line":225,"address":[7038750,7038967,7044614,7044403,7041896,7042113],"length":1,"stats":{"Line":94},"fn_name":null},{"line":229,"address":[7042408,7039359,7040789,7043669,7044719,7045582],"length":1,"stats":{"Line":99},"fn_name":null},{"line":230,"address":[7042699,7044893,7039361,7042410,7044721,7039533,7042582,7045010,7039650],"length":1,"stats":{"Line":96},"fn_name":null},{"line":231,"address":[7042701,7044745,7039652,7045012,7039385,7042434],"length":1,"stats":{"Line":80},"fn_name":null},{"line":232,"address":[7044773,7039413,7042462],"length":1,"stats":{"Line":49},"fn_name":null},{"line":236,"address":[7039760,7042770,7045126,7045064,7042836,7039694,7042630,7044941,7039581],"length":1,"stats":{"Line":147},"fn_name":null},{"line":237,"address":[7043234,7045190,7039824,7045334,7042900,7040255],"length":1,"stats":{"Line":65},"fn_name":null},{"line":238,"address":[7042915,7045205,7039839],"length":1,"stats":{"Line":16},"fn_name":null},{"line":240,"address":[7045336,7043236,7040257],"length":1,"stats":{"Line":49},"fn_name":null},{"line":241,"address":[7040291,7043268,7045370],"length":1,"stats":{"Line":49},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[7045480,7045098,7040397,7043374,7039728,7042804],"length":1,"stats":{"Line":95},"fn_name":null},{"line":256,"address":[7047184,7045760,7045987,7048720,7047412,7048947],"length":1,"stats":{"Line":46},"fn_name":"induct<regex_syntax::hir::translate::TranslatorI>"},{"line":261,"address":[7049020,7046369,7047297,7048399,7049236,7045873,7047890,7047998,7046878,7046566,7049128,7049637,7049858,7048087,7049325,7048620,7047099,7048833,7047782,7048310,7049548,7046477,7046789,7046261],"length":1,"stats":{"Line":237},"fn_name":null},{"line":262,"address":[7047307,7048843,7045883,7047218,7045794,7048754],"length":1,"stats":{"Line":62},"fn_name":null},{"line":263,"address":[7047339,7047744,7046223,7047427,7048990,7048880,7046002,7048962,7045915],"length":1,"stats":{"Line":33},"fn_name":null},{"line":264,"address":[7049008,7046249,7047770],"length":1,"stats":{"Line":16},"fn_name":null},{"line":266,"address":[7047792,7046271,7049030],"length":1,"stats":{"Line":39},"fn_name":null},{"line":267,"address":[7046379,7047900,7049138],"length":1,"stats":{"Line":41},"fn_name":null},{"line":268,"address":[7046487,7048008,7049246],"length":1,"stats":{"Line":48},"fn_name":null},{"line":269,"address":[7048101,7049339,7046580],"length":1,"stats":{"Line":48},"fn_name":null},{"line":270,"address":[7046595,7049354,7048116],"length":1,"stats":{"Line":48},"fn_name":null},{"line":272,"address":[7046799,7048320,7049558],"length":1,"stats":{"Line":16},"fn_name":null},{"line":273,"address":[7048511,7049749,7046892,7049651,7048413,7046990],"length":1,"stats":{"Line":32},"fn_name":null},{"line":274,"address":[7049666,7046907,7048428],"length":1,"stats":{"Line":16},"fn_name":null},{"line":275,"address":[7049700,7046941,7048462],"length":1,"stats":{"Line":16},"fn_name":null},{"line":277,"address":[7045861,7047285,7048821],"length":1,"stats":{"Line":47},"fn_name":null},{"line":283,"address":[7383424],"length":1,"stats":{"Line":24},"fn_name":"pop"},{"line":284,"address":[7384034,7383546,7383560,7383577,7383828],"length":1,"stats":{"Line":79},"fn_name":null},{"line":285,"address":[7383553,7383442],"length":1,"stats":{"Line":47},"fn_name":null},{"line":286,"address":[7383570],"length":1,"stats":{"Line":24},"fn_name":null},{"line":287,"address":[7383587],"length":1,"stats":{"Line":24},"fn_name":null},{"line":288,"address":[7383611,7383686],"length":1,"stats":{"Line":48},"fn_name":null},{"line":289,"address":[7383679],"length":1,"stats":{"Line":24},"fn_name":null},{"line":291,"address":[7383656,7384076,7384103,7383691],"length":1,"stats":{"Line":48},"fn_name":null},{"line":294,"address":[7383491],"length":1,"stats":{"Line":8},"fn_name":null},{"line":295,"address":[7383515,7383882,7383837],"length":1,"stats":{"Line":24},"fn_name":null},{"line":296,"address":[7383875],"length":1,"stats":{"Line":8},"fn_name":null},{"line":298,"address":[7383937],"length":1,"stats":{"Line":8},"fn_name":null},{"line":299,"address":[7383852,7384049],"length":1,"stats":{"Line":8},"fn_name":null},{"line":300,"address":[7383887],"length":1,"stats":{"Line":8},"fn_name":null},{"line":307,"address":[7054639,7052640,7049936,7054560,7050015,7052705],"length":1,"stats":{"Line":16},"fn_name":"visit_class<regex_syntax::hir::translate::TranslatorI>"},{"line":312,"address":[7054594,7052671,7049970],"length":1,"stats":{"Line":16},"fn_name":null},{"line":313,"address":[7050030,7054367,7052720,7054654,7052258,7057172],"length":1,"stats":{"Line":34},"fn_name":null},{"line":314,"address":[7050032,7054656,7052727],"length":1,"stats":{"Line":16},"fn_name":null},{"line":315,"address":[7052935,7055152,7055056,7052849,7050434,7050338],"length":1,"stats":{"Line":33},"fn_name":null},{"line":316,"address":[7050498,7052993,7055216],"length":1,"stats":{"Line":17},"fn_name":null},{"line":317,"address":[7053038,7050543,7055261],"length":1,"stats":{"Line":18},"fn_name":null},{"line":318,"address":[7050725,7053220,7055443],"length":1,"stats":{"Line":18},"fn_name":null},{"line":319,"address":[7050740,7055458,7053235],"length":1,"stats":{"Line":18},"fn_name":null},{"line":321,"address":[7050745,7055118,7055463,7053244,7050400,7052910],"length":1,"stats":{"Line":32},"fn_name":null},{"line":325,"address":[7053339,7055847,7051032,7052550,7054471,7057561],"length":1,"stats":{"Line":33},"fn_name":null},{"line":326,"address":[7053637,7051039,7056334,7056145,7053346,7053826,7055854,7051519,7051330],"length":1,"stats":{"Line":33},"fn_name":null},{"line":327,"address":[7055877,7051062,7053828,7056341,7051526,7053369],"length":1,"stats":{"Line":32},"fn_name":null},{"line":328,"address":[7051090,7053397,7055905],"length":1,"stats":{"Line":17},"fn_name":null},{"line":332,"address":[7053909,7051610,7053842,7056427,7056241,7053733,7051426,7051539,7056356],"length":1,"stats":{"Line":51},"fn_name":null},{"line":333,"address":[7056939,7053973,7051674,7054132,7052025,7056491],"length":1,"stats":{"Line":17},"fn_name":null},{"line":334,"address":[7054010,7056528,7051711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[7056941,7052027,7054134],"length":1,"stats":{"Line":17},"fn_name":null},{"line":337,"address":[7054183,7056988,7052074],"length":1,"stats":{"Line":18},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[7054376,7053881,7052263,7051573,7056390,7057177],"length":1,"stats":{"Line":34},"fn_name":null},{"line":348,"address":[7057713,7058497,7058432,7057648,7059424,7059465],"length":1,"stats":{"Line":16},"fn_name":"visit_class_pre<regex_syntax::hir::translate::TranslatorI>"},{"line":353,"address":[7059514,7059649,7059352,7057772,7058556,7058963,7058371,7058079,7059741],"length":1,"stats":{"Line":16},"fn_name":null},{"line":354,"address":[7058466,7057682,7058563,7059443,7057779,7059521],"length":1,"stats":{"Line":32},"fn_name":null},{"line":355,"address":[7058053,7058937,7059535,7057791,7059622,7058575],"length":1,"stats":{"Line":16},"fn_name":null},{"line":357,"address":[7057733,7058517,7059482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[7057745,7058968,7059655,7058529,7059496,7058084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[7059743,7058378,7059359],"length":1,"stats":{"Line":16},"fn_name":null},{"line":365,"address":[7060576,7061568,7061609,7059792,7060641,7059857],"length":1,"stats":{"Line":16},"fn_name":"visit_class_post<regex_syntax::hir::translate::TranslatorI>"},{"line":370,"address":[7061496,7061107,7060515,7059916,7061793,7060223,7061885,7061658,7060700],"length":1,"stats":{"Line":16},"fn_name":null},{"line":371,"address":[7060707,7060610,7061587,7061665,7059826,7059923],"length":1,"stats":{"Line":32},"fn_name":null},{"line":372,"address":[7060197,7060719,7059935,7061081,7061679,7061766],"length":1,"stats":{"Line":17},"fn_name":null},{"line":374,"address":[7060661,7059877,7061626],"length":1,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[7061640,7060673,7061112,7060228,7061799,7059889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[7060522,7061887,7061503],"length":1,"stats":{"Line":16},"fn_name":null},{"line":383,"address":[7384112],"length":1,"stats":{"Line":8},"fn_name":"induct_class"},{"line":384,"address":[7384242,7384496,7384763],"length":1,"stats":{"Line":16},"fn_name":null},{"line":385,"address":[7384138,7384252],"length":1,"stats":{"Line":8},"fn_name":null},{"line":386,"address":[7384387],"length":1,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[7384271,7384396],"length":1,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[7384421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[7384296],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[7384321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[7384506],"length":1,"stats":{"Line":8},"fn_name":null},{"line":396,"address":[7384607,7384525],"length":1,"stats":{"Line":8},"fn_name":null},{"line":397,"address":[7384600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[7384666],"length":1,"stats":{"Line":8},"fn_name":null},{"line":400,"address":[7384572],"length":1,"stats":{"Line":8},"fn_name":null},{"line":401,"address":[7384617],"length":1,"stats":{"Line":8},"fn_name":null},{"line":405,"address":[7384770,7384790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[7384782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[7384786],"length":1,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[7384235],"length":1,"stats":{"Line":8},"fn_name":null},{"line":416,"address":[7384896],"length":1,"stats":{"Line":9},"fn_name":"pop_class"},{"line":417,"address":[7385214,7385200,7384970],"length":1,"stats":{"Line":9},"fn_name":null},{"line":418,"address":[7384982,7384914],"length":1,"stats":{"Line":18},"fn_name":null},{"line":419,"address":[7385006,7385081],"length":1,"stats":{"Line":18},"fn_name":null},{"line":420,"address":[7385074],"length":1,"stats":{"Line":9},"fn_name":null},{"line":422,"address":[7385127],"length":1,"stats":{"Line":9},"fn_name":null},{"line":423,"address":[7385051,7385326,7385353],"length":1,"stats":{"Line":9},"fn_name":null},{"line":424,"address":[7385083],"length":1,"stats":{"Line":8},"fn_name":null},{"line":428,"address":[7385207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[7385221],"length":1,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[7385245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[7384963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[7385360],"length":1,"stats":{"Line":24},"fn_name":"child"},{"line":441,"address":[7385496,7385447,7385420,7385475],"length":1,"stats":{"Line":93},"fn_name":null},{"line":442,"address":[7385369,7385429],"length":1,"stats":{"Line":54},"fn_name":null},{"line":443,"address":[7385454],"length":1,"stats":{"Line":31},"fn_name":null},{"line":444,"address":[7385482],"length":1,"stats":{"Line":24},"fn_name":null},{"line":445,"address":[7385406],"length":1,"stats":{"Line":8},"fn_name":null},{"line":453,"address":[7385520],"length":1,"stats":{"Line":8},"fn_name":"child"},{"line":454,"address":[7385701,7385631,7385601,7385661],"length":1,"stats":{"Line":9},"fn_name":null},{"line":455,"address":[7385608,7385529],"length":1,"stats":{"Line":16},"fn_name":null},{"line":456,"address":[7385638],"length":1,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[7385668],"length":1,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[7385682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[7385566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[7385580],"length":1,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[7385728],"length":1,"stats":{"Line":8},"fn_name":"from_bracketed"},{"line":469,"address":[7385737],"length":1,"stats":{"Line":8},"fn_name":null},{"line":472,"address":[7385776],"length":1,"stats":{"Line":8},"fn_name":"from_set"},{"line":473,"address":[7385828],"length":1,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[7385785,7385836],"length":1,"stats":{"Line":16},"fn_name":null},{"line":475,"address":[7385803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[7385888],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":482,"address":[7386014,7385966,7385991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[7385977,7385911],"length":1,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[7386000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[7386023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[7385952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[7386044],"length":1,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[7386208],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":494,"address":[7386550,7386312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[7386319,7386231,7386409,7386527,7386481,7386504,7386435,7386381,7386458],"length":1,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[7386395,7386331],"length":1,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[7386421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[7386444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[7386467],"length":1,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[7386490],"length":1,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[7386513],"length":1,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[7386536],"length":1,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[7386367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[7386256,7386573,7386621,7386598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[7386268],"length":1,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[7386584],"length":1,"stats":{"Line":0},"fn_name":null},{"line":509,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[7386607],"length":1,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[7386559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[7386648],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":117,"coverable":185},{"path":["/","usr","src","regex","regex-syntax","src","error.rs"],"content":"use std::cmp;\nuse std::error;\nuse std::fmt;\nuse std::result;\n\nuse ast;\nuse hir;\n\n/// A type alias for dealing with errors returned by this crate.\npub type Result<T> = result::Result<T, Error>;\n\n/// This error type encompasses any error that can be returned by this crate.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum Error {\n    /// An error that occurred while translating concrete syntax into abstract\n    /// syntax (AST).\n    Parse(ast::Error),\n    /// An error that occurred while translating abstract syntax into a high\n    /// level intermediate representation (HIR).\n    Translate(hir::Error),\n    /// Hints that destructuring should not be exhaustive.\n    ///\n    /// This enum may grow additional variants, so this makes sure clients\n    /// don't count on exhaustive matching. (Otherwise, adding a new variant\n    /// could break existing code.)\n    #[doc(hidden)]\n    __Nonexhaustive,\n}\n\nimpl From<ast::Error> for Error {\n    fn from(err: ast::Error) -> Error {\n        Error::Parse(err)\n    }\n}\n\nimpl From<hir::Error> for Error {\n    fn from(err: hir::Error) -> Error {\n        Error::Translate(err)\n    }\n}\n\nimpl error::Error for Error {\n    // TODO: Remove this method entirely on the next breaking semver release.\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        match *self {\n            Error::Parse(ref x) => x.description(),\n            Error::Translate(ref x) => x.description(),\n            _ => unreachable!(),\n        }\n    }\n}\n\nimpl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            Error::Parse(ref x) => x.fmt(f),\n            Error::Translate(ref x) => x.fmt(f),\n            _ => unreachable!(),\n        }\n    }\n}\n\n/// A helper type for formatting nice error messages.\n///\n/// This type is responsible for reporting regex parse errors in a nice human\n/// readable format. Most of its complexity is from interspersing notational\n/// markers pointing out the position where an error occurred.\n#[derive(Debug)]\npub struct Formatter<'e, E: 'e> {\n    /// The original regex pattern in which the error occurred.\n    pattern: &'e str,\n    /// The error kind. It must impl fmt::Display.\n    err: &'e E,\n    /// The primary span of the error.\n    span: &'e ast::Span,\n    /// An auxiliary and optional span, in case the error needs to point to\n    /// two locations (e.g., when reporting a duplicate capture group name).\n    aux_span: Option<&'e ast::Span>,\n}\n\nimpl<'e> From<&'e ast::Error> for Formatter<'e, ast::ErrorKind> {\n    fn from(err: &'e ast::Error) -> Self {\n        Formatter {\n            pattern: err.pattern(),\n            err: err.kind(),\n            span: err.span(),\n            aux_span: err.auxiliary_span(),\n        }\n    }\n}\n\nimpl<'e> From<&'e hir::Error> for Formatter<'e, hir::ErrorKind> {\n    fn from(err: &'e hir::Error) -> Self {\n        Formatter {\n            pattern: err.pattern(),\n            err: err.kind(),\n            span: err.span(),\n            aux_span: None,\n        }\n    }\n}\n\nimpl<'e, E: fmt::Display> fmt::Display for Formatter<'e, E> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let spans = Spans::from_formatter(self);\n        if self.pattern.contains('\\n') {\n            let divider = repeat_char('~', 79);\n\n            writeln!(f, \"regex parse error:\")?;\n            writeln!(f, \"{}\", divider)?;\n            let notated = spans.notate();\n            write!(f, \"{}\", notated)?;\n            writeln!(f, \"{}\", divider)?;\n            // If we have error spans that cover multiple lines, then we just\n            // note the line numbers.\n            if !spans.multi_line.is_empty() {\n                let mut notes = vec![];\n                for span in &spans.multi_line {\n                    notes.push(format!(\n                        \"on line {} (column {}) through line {} (column {})\",\n                        span.start.line,\n                        span.start.column,\n                        span.end.line,\n                        span.end.column - 1\n                    ));\n                }\n                writeln!(f, \"{}\", notes.join(\"\\n\"))?;\n            }\n            write!(f, \"error: {}\", self.err)?;\n        } else {\n            writeln!(f, \"regex parse error:\")?;\n            let notated = Spans::from_formatter(self).notate();\n            write!(f, \"{}\", notated)?;\n            write!(f, \"error: {}\", self.err)?;\n        }\n        Ok(())\n    }\n}\n\n/// This type represents an arbitrary number of error spans in a way that makes\n/// it convenient to notate the regex pattern. (\"Notate\" means \"point out\n/// exactly where the error occurred in the regex pattern.\")\n///\n/// Technically, we can only ever have two spans given our current error\n/// structure. However, after toiling with a specific algorithm for handling\n/// two spans, it became obvious that an algorithm to handle an arbitrary\n/// number of spans was actually much simpler.\nstruct Spans<'p> {\n    /// The original regex pattern string.\n    pattern: &'p str,\n    /// The total width that should be used for line numbers. The width is\n    /// used for left padding the line numbers for alignment.\n    ///\n    /// A value of `0` means line numbers should not be displayed. That is,\n    /// the pattern is itself only one line.\n    line_number_width: usize,\n    /// All error spans that occur on a single line. This sequence always has\n    /// length equivalent to the number of lines in `pattern`, where the index\n    /// of the sequence represents a line number, starting at `0`. The spans\n    /// in each line are sorted in ascending order.\n    by_line: Vec<Vec<ast::Span>>,\n    /// All error spans that occur over one or more lines. That is, the start\n    /// and end position of the span have different line numbers. The spans are\n    /// sorted in ascending order.\n    multi_line: Vec<ast::Span>,\n}\n\nimpl<'p> Spans<'p> {\n    /// Build a sequence of spans from a formatter.\n    fn from_formatter<'e, E: fmt::Display>(\n        fmter: &'p Formatter<'e, E>,\n    ) -> Spans<'p> {\n        let mut line_count = fmter.pattern.lines().count();\n        // If the pattern ends with a `\\n` literal, then our line count is\n        // off by one, since a span can occur immediately after the last `\\n`,\n        // which is consider to be an additional line.\n        if fmter.pattern.ends_with('\\n') {\n            line_count += 1;\n        }\n        let line_number_width =\n            if line_count <= 1 { 0 } else { line_count.to_string().len() };\n        let mut spans = Spans {\n            pattern: &fmter.pattern,\n            line_number_width: line_number_width,\n            by_line: vec![vec![]; line_count],\n            multi_line: vec![],\n        };\n        spans.add(fmter.span.clone());\n        if let Some(span) = fmter.aux_span {\n            spans.add(span.clone());\n        }\n        spans\n    }\n\n    /// Add the given span to this sequence, putting it in the right place.\n    fn add(&mut self, span: ast::Span) {\n        // This is grossly inefficient since we sort after each add, but right\n        // now, we only ever add two spans at most.\n        if span.is_one_line() {\n            let i = span.start.line - 1; // because lines are 1-indexed\n            self.by_line[i].push(span);\n            self.by_line[i].sort();\n        } else {\n            self.multi_line.push(span);\n            self.multi_line.sort();\n        }\n    }\n\n    /// Notate the pattern string with carents (`^`) pointing at each span\n    /// location. This only applies to spans that occur within a single line.\n    fn notate(&self) -> String {\n        let mut notated = String::new();\n        for (i, line) in self.pattern.lines().enumerate() {\n            if self.line_number_width > 0 {\n                notated.push_str(&self.left_pad_line_number(i + 1));\n                notated.push_str(\": \");\n            } else {\n                notated.push_str(\"    \");\n            }\n            notated.push_str(line);\n            notated.push('\\n');\n            if let Some(notes) = self.notate_line(i) {\n                notated.push_str(&notes);\n                notated.push('\\n');\n            }\n        }\n        notated\n    }\n\n    /// Return notes for the line indexed at `i` (zero-based). If there are no\n    /// spans for the given line, then `None` is returned. Otherwise, an\n    /// appropriately space padded string with correctly positioned `^` is\n    /// returned, accounting for line numbers.\n    fn notate_line(&self, i: usize) -> Option<String> {\n        let spans = &self.by_line[i];\n        if spans.is_empty() {\n            return None;\n        }\n        let mut notes = String::new();\n        for _ in 0..self.line_number_padding() {\n            notes.push(' ');\n        }\n        let mut pos = 0;\n        for span in spans {\n            for _ in pos..(span.start.column - 1) {\n                notes.push(' ');\n                pos += 1;\n            }\n            let note_len = span.end.column.saturating_sub(span.start.column);\n            for _ in 0..cmp::max(1, note_len) {\n                notes.push('^');\n                pos += 1;\n            }\n        }\n        Some(notes)\n    }\n\n    /// Left pad the given line number with spaces such that it is aligned with\n    /// other line numbers.\n    fn left_pad_line_number(&self, n: usize) -> String {\n        let n = n.to_string();\n        let pad = self.line_number_width.checked_sub(n.len()).unwrap();\n        let mut result = repeat_char(' ', pad);\n        result.push_str(&n);\n        result\n    }\n\n    /// Return the line number padding beginning at the start of each line of\n    /// the pattern.\n    ///\n    /// If the pattern is only one line, then this returns a fixed padding\n    /// for visual indentation.\n    fn line_number_padding(&self) -> usize {\n        if self.line_number_width == 0 {\n            4\n        } else {\n            2 + self.line_number_width\n        }\n    }\n}\n\nfn repeat_char(c: char, count: usize) -> String {\n    ::std::iter::repeat(c).take(count).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use ast::parse::Parser;\n\n    fn assert_panic_message(pattern: &str, expected_msg: &str) -> () {\n        let result = Parser::new().parse(pattern);\n        match result {\n            Ok(_) => {\n                panic!(\"regex should not have parsed\");\n            }\n            Err(err) => {\n                assert_eq!(err.to_string(), expected_msg.trim());\n            }\n        }\n    }\n\n    // See: https://github.com/rust-lang/regex/issues/464\n    #[test]\n    fn regression_464() {\n        let err = Parser::new().parse(\"a{\\n\").unwrap_err();\n        // This test checks that the error formatter doesn't panic.\n        assert!(!err.to_string().is_empty());\n    }\n\n    // See: https://github.com/rust-lang/regex/issues/545\n    #[test]\n    fn repetition_quantifier_expects_a_valid_decimal() {\n        assert_panic_message(\n            r\"\\\\u{[^}]*}\",\n            r#\"\nregex parse error:\n    \\\\u{[^}]*}\n        ^\nerror: repetition quantifier expects a valid decimal\n\"#,\n        );\n    }\n}\n","traces":[{"line":31,"address":[6350864],"length":1,"stats":{"Line":13},"fn_name":"from"},{"line":32,"address":[6350874],"length":1,"stats":{"Line":13},"fn_name":null},{"line":37,"address":[6350976],"length":1,"stats":{"Line":4},"fn_name":"from"},{"line":38,"address":[6350983],"length":1,"stats":{"Line":4},"fn_name":null},{"line":45,"address":[6351088],"length":1,"stats":{"Line":0},"fn_name":"description"},{"line":46,"address":[6351215,6351270],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[6351097,6351165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[6351222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[6351296],"length":1,"stats":{"Line":12},"fn_name":"fmt"},{"line":56,"address":[6351414,6351452],"length":1,"stats":{"Line":22},"fn_name":null},{"line":57,"address":[6351310,6351383],"length":1,"stats":{"Line":28},"fn_name":null},{"line":58,"address":[6351421],"length":1,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[6351472],"length":1,"stats":{"Line":15},"fn_name":"from"},{"line":85,"address":[6351489],"length":1,"stats":{"Line":14},"fn_name":null},{"line":86,"address":[6351523],"length":1,"stats":{"Line":15},"fn_name":null},{"line":87,"address":[6351539],"length":1,"stats":{"Line":16},"fn_name":null},{"line":88,"address":[6351555],"length":1,"stats":{"Line":17},"fn_name":null},{"line":94,"address":[6351632],"length":1,"stats":{"Line":4},"fn_name":"from"},{"line":96,"address":[6351649],"length":1,"stats":{"Line":4},"fn_name":null},{"line":97,"address":[6351683],"length":1,"stats":{"Line":4},"fn_name":null},{"line":98,"address":[6351699],"length":1,"stats":{"Line":4},"fn_name":null},{"line":105,"address":[6924832,6920352,6920421,6924901],"length":1,"stats":{"Line":24},"fn_name":"fmt<regex_syntax::ast::ErrorKind>"},{"line":106,"address":[6924855,6920375],"length":1,"stats":{"Line":23},"fn_name":null},{"line":107,"address":[6924627,6928247,6920444,6929107,6924924,6923767],"length":1,"stats":{"Line":44},"fn_name":null},{"line":108,"address":[6920545,6925025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[6920574,6925403,6925054,6920673,6925387,6920821,6925301,6920907,6925153,6920854,6925334,6920923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[6921128,6925413,6920933,6925608,6925214,6920734],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[6921101,6925581],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[6925850,6925660,6921559,6921180,6921370,6921625,6926039,6926105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[6921472,6926312,6926118,6921832,6921638,6925952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[6926371,6927914,6926286,6923434,6921806,6921891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[6921911,6926391],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[6926437,6922989,6922166,6927469,6921957,6922045,6926525,6926646],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[6922332,6926812],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[6926680,6922200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[6922207,6926687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[6922217,6926697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[6922227,6926707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[6926724,6929216,6922244,6924736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[6927890,6926593,6922113,6922994,6927474,6923410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[6923436,6928182,6927916,6923702],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[6928252,6928369,6924983,6923772,6920503,6923889],"length":1,"stats":{"Line":49},"fn_name":null},{"line":133,"address":[6928415,6923862,6923935,6928342],"length":1,"stats":{"Line":49},"fn_name":null},{"line":134,"address":[6924398,6928818,6928878,6924338,6928499,6924019],"length":1,"stats":{"Line":27},"fn_name":null},{"line":135,"address":[6928736,6929061,6924581,6924256,6924408,6928888],"length":1,"stats":{"Line":50},"fn_name":null},{"line":137,"address":[6929109,6924629],"length":1,"stats":{"Line":28},"fn_name":null},{"line":171,"address":[6930160,6930218,6929370,6929312],"length":1,"stats":{"Line":24},"fn_name":"from_formatter<regex_syntax::hir::ErrorKind>"},{"line":174,"address":[6929385,6930178,6929330,6930233],"length":1,"stats":{"Line":49},"fn_name":null},{"line":178,"address":[6930254,6929406],"length":1,"stats":{"Line":24},"fn_name":null},{"line":179,"address":[6930068,6929438,6930286,6930916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[6930324,6929476],"length":1,"stats":{"Line":26},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[6929598,6930446],"length":1,"stats":{"Line":24},"fn_name":null},{"line":186,"address":[6930461,6929613],"length":1,"stats":{"Line":26},"fn_name":null},{"line":187,"address":[6930549,6929701],"length":1,"stats":{"Line":24},"fn_name":null},{"line":189,"address":[6929868,6930716],"length":1,"stats":{"Line":26},"fn_name":null},{"line":190,"address":[6929942,6930790,6930872,6930024],"length":1,"stats":{"Line":33},"fn_name":null},{"line":191,"address":[6930835,6929987],"length":1,"stats":{"Line":8},"fn_name":null},{"line":193,"address":[6930879,6930031],"length":1,"stats":{"Line":27},"fn_name":null},{"line":197,"address":[6351776],"length":1,"stats":{"Line":14},"fn_name":"add"},{"line":200,"address":[6351796,6352087,6352133],"length":1,"stats":{"Line":35},"fn_name":null},{"line":201,"address":[6351900,6352173,6352143],"length":1,"stats":{"Line":14},"fn_name":null},{"line":202,"address":[6351946],"length":1,"stats":{"Line":17},"fn_name":null},{"line":203,"address":[6352025],"length":1,"stats":{"Line":14},"fn_name":null},{"line":205,"address":[6351829],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[6352094],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[6352176,6352232],"length":1,"stats":{"Line":18},"fn_name":"notate"},{"line":213,"address":[6352194],"length":1,"stats":{"Line":14},"fn_name":null},{"line":214,"address":[6352463,6352314,6352252,6353135],"length":1,"stats":{"Line":53},"fn_name":null},{"line":215,"address":[6352662,6352873],"length":1,"stats":{"Line":19},"fn_name":null},{"line":216,"address":[6353227,6352716],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[6352849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[6352684],"length":1,"stats":{"Line":15},"fn_name":null},{"line":221,"address":[6352892],"length":1,"stats":{"Line":19},"fn_name":null},{"line":222,"address":[6352909],"length":1,"stats":{"Line":15},"fn_name":null},{"line":223,"address":[6353125,6352934],"length":1,"stats":{"Line":34},"fn_name":null},{"line":224,"address":[6353029],"length":1,"stats":{"Line":15},"fn_name":null},{"line":225,"address":[6353099],"length":1,"stats":{"Line":19},"fn_name":null},{"line":228,"address":[6352419],"length":1,"stats":{"Line":15},"fn_name":null},{"line":235,"address":[6353328,6353410],"length":1,"stats":{"Line":15},"fn_name":"notate_line"},{"line":236,"address":[6353433,6353354],"length":1,"stats":{"Line":34},"fn_name":null},{"line":237,"address":[6353441],"length":1,"stats":{"Line":19},"fn_name":null},{"line":238,"address":[6353493],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[6353470],"length":1,"stats":{"Line":15},"fn_name":null},{"line":241,"address":[6353838,6353792,6353524,6353637],"length":1,"stats":{"Line":49},"fn_name":null},{"line":242,"address":[6353831],"length":1,"stats":{"Line":19},"fn_name":null},{"line":244,"address":[6353745],"length":1,"stats":{"Line":19},"fn_name":null},{"line":245,"address":[6353851,6354033,6353757,6354593],"length":1,"stats":{"Line":49},"fn_name":null},{"line":246,"address":[6354707,6354301,6354067,6354391],"length":1,"stats":{"Line":30},"fn_name":null},{"line":247,"address":[6354340],"length":1,"stats":{"Line":15},"fn_name":null},{"line":248,"address":[6354347,6354739],"length":1,"stats":{"Line":14},"fn_name":null},{"line":250,"address":[6354281,6354401],"length":1,"stats":{"Line":16},"fn_name":null},{"line":251,"address":[6354598,6354682,6354409],"length":1,"stats":{"Line":27},"fn_name":null},{"line":252,"address":[6354637],"length":1,"stats":{"Line":19},"fn_name":null},{"line":253,"address":[6354799,6354769,6354644],"length":1,"stats":{"Line":15},"fn_name":null},{"line":256,"address":[6353937],"length":1,"stats":{"Line":19},"fn_name":null},{"line":261,"address":[6354862,6354800],"length":1,"stats":{"Line":0},"fn_name":"left_pad_line_number"},{"line":262,"address":[6354823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[6354951,6354882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[6354997],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[6355026],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[6355079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[6355184],"length":1,"stats":{"Line":15},"fn_name":"line_number_padding"},{"line":275,"address":[6355245,6355193],"length":1,"stats":{"Line":38},"fn_name":null},{"line":276,"address":[6355236],"length":1,"stats":{"Line":15},"fn_name":null},{"line":278,"address":[6355210,6355267,6355252,6355297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[6355312],"length":1,"stats":{"Line":0},"fn_name":"repeat_char"},{"line":284,"address":[6355333],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":71,"coverable":108},{"path":["/","usr","src","regex","regex-syntax","src","hir","interval.rs"],"content":"use std::char;\nuse std::cmp;\nuse std::fmt::Debug;\nuse std::slice;\nuse std::u8;\n\nuse unicode;\n\n// This module contains an *internal* implementation of interval sets.\n//\n// The primary invariant that interval sets guards is canonical ordering. That\n// is, every interval set contains an ordered sequence of intervals where\n// no two intervals are overlapping or adjacent. While this invariant is\n// occasionally broken within the implementation, it should be impossible for\n// callers to observe it.\n//\n// Since case folding (as implemented below) breaks that invariant, we roll\n// that into this API even though it is a little out of place in an otherwise\n// generic interval set. (Hence the reason why the `unicode` module is imported\n// here.)\n//\n// Some of the implementation complexity here is a result of me wanting to\n// preserve the sequential representation without using additional memory.\n// In many cases, we do use linear extra memory, but it is at most 2x and it\n// is amortized. If we relaxed the memory requirements, this implementation\n// could become much simpler. The extra memory is honestly probably OK, but\n// character classes (especially of the Unicode variety) can become quite\n// large, and it would be nice to keep regex compilation snappy even in debug\n// builds. (In the past, I have been careless with this area of code and it has\n// caused slow regex compilations in debug mode, so this isn't entirely\n// unwarranted.)\n//\n// Tests on this are relegated to the public API of HIR in src/hir.rs.\n\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct IntervalSet<I> {\n    ranges: Vec<I>,\n}\n\nimpl<I: Interval> IntervalSet<I> {\n    /// Create a new set from a sequence of intervals. Each interval is\n    /// specified as a pair of bounds, where both bounds are inclusive.\n    ///\n    /// The given ranges do not need to be in any specific order, and ranges\n    /// may overlap.\n    pub fn new<T: IntoIterator<Item = I>>(intervals: T) -> IntervalSet<I> {\n        let mut set = IntervalSet { ranges: intervals.into_iter().collect() };\n        set.canonicalize();\n        set\n    }\n\n    /// Add a new interval to this set.\n    pub fn push(&mut self, interval: I) {\n        // TODO: This could be faster. e.g., Push the interval such that\n        // it preserves canonicalization.\n        self.ranges.push(interval);\n        self.canonicalize();\n    }\n\n    /// Return an iterator over all intervals in this set.\n    ///\n    /// The iterator yields intervals in ascending order.\n    pub fn iter(&self) -> IntervalSetIter<I> {\n        IntervalSetIter(self.ranges.iter())\n    }\n\n    /// Return an immutable slice of intervals in this set.\n    ///\n    /// The sequence returned is in canonical ordering.\n    pub fn intervals(&self) -> &[I] {\n        &self.ranges\n    }\n\n    /// Expand this interval set such that it contains all case folded\n    /// characters. For example, if this class consists of the range `a-z`,\n    /// then applying case folding will result in the class containing both the\n    /// ranges `a-z` and `A-Z`.\n    ///\n    /// This returns an error if the necessary case mapping data is not\n    /// available.\n    pub fn case_fold_simple(&mut self) -> Result<(), unicode::CaseFoldError> {\n        let len = self.ranges.len();\n        for i in 0..len {\n            let range = self.ranges[i];\n            if let Err(err) = range.case_fold_simple(&mut self.ranges) {\n                self.canonicalize();\n                return Err(err);\n            }\n        }\n        self.canonicalize();\n        Ok(())\n    }\n\n    /// Union this set with the given set, in place.\n    pub fn union(&mut self, other: &IntervalSet<I>) {\n        // This could almost certainly be done more efficiently.\n        self.ranges.extend(&other.ranges);\n        self.canonicalize();\n    }\n\n    /// Intersect this set with the given set, in place.\n    pub fn intersect(&mut self, other: &IntervalSet<I>) {\n        if self.ranges.is_empty() {\n            return;\n        }\n        if other.ranges.is_empty() {\n            self.ranges.clear();\n            return;\n        }\n\n        // There should be a way to do this in-place with constant memory,\n        // but I couldn't figure out a simple way to do it. So just append\n        // the intersection to the end of this range, and then drain it before\n        // we're done.\n        let drain_end = self.ranges.len();\n\n        let mut ita = (0..drain_end).into_iter();\n        let mut itb = (0..other.ranges.len()).into_iter();\n        let mut a = ita.next().unwrap();\n        let mut b = itb.next().unwrap();\n        loop {\n            if let Some(ab) = self.ranges[a].intersect(&other.ranges[b]) {\n                self.ranges.push(ab);\n            }\n            let (it, aorb) =\n                if self.ranges[a].upper() < other.ranges[b].upper() {\n                    (&mut ita, &mut a)\n                } else {\n                    (&mut itb, &mut b)\n                };\n            match it.next() {\n                Some(v) => *aorb = v,\n                None => break,\n            }\n        }\n        self.ranges.drain(..drain_end);\n    }\n\n    /// Subtract the given set from this set, in place.\n    pub fn difference(&mut self, other: &IntervalSet<I>) {\n        if self.ranges.is_empty() || other.ranges.is_empty() {\n            return;\n        }\n\n        // This algorithm is (to me) surprisingly complex. A search of the\n        // interwebs indicate that this is a potentially interesting problem.\n        // Folks seem to suggest interval or segment trees, but I'd like to\n        // avoid the overhead (both runtime and conceptual) of that.\n        //\n        // The following is basically my Shitty First Draft. Therefore, in\n        // order to grok it, you probably need to read each line carefully.\n        // Simplifications are most welcome!\n        //\n        // Remember, we can assume the canonical format invariant here, which\n        // says that all ranges are sorted, not overlapping and not adjacent in\n        // each class.\n        let drain_end = self.ranges.len();\n        let (mut a, mut b) = (0, 0);\n        'LOOP: while a < drain_end && b < other.ranges.len() {\n            // Basically, the easy cases are when neither range overlaps with\n            // each other. If the `b` range is less than our current `a`\n            // range, then we can skip it and move on.\n            if other.ranges[b].upper() < self.ranges[a].lower() {\n                b += 1;\n                continue;\n            }\n            // ... similarly for the `a` range. If it's less than the smallest\n            // `b` range, then we can add it as-is.\n            if self.ranges[a].upper() < other.ranges[b].lower() {\n                let range = self.ranges[a];\n                self.ranges.push(range);\n                a += 1;\n                continue;\n            }\n            // Otherwise, we have overlapping ranges.\n            assert!(!self.ranges[a].is_intersection_empty(&other.ranges[b]));\n\n            // This part is tricky and was non-obvious to me without looking\n            // at explicit examples (see the tests). The trickiness stems from\n            // two things: 1) subtracting a range from another range could\n            // yield two ranges and 2) after subtracting a range, it's possible\n            // that future ranges can have an impact. The loop below advances\n            // the `b` ranges until they can't possible impact the current\n            // range.\n            //\n            // For example, if our `a` range is `a-t` and our next three `b`\n            // ranges are `a-c`, `g-i`, `r-t` and `x-z`, then we need to apply\n            // subtraction three times before moving on to the next `a` range.\n            let mut range = self.ranges[a];\n            while b < other.ranges.len()\n                && !range.is_intersection_empty(&other.ranges[b])\n            {\n                let old_range = range;\n                range = match range.difference(&other.ranges[b]) {\n                    (None, None) => {\n                        // We lost the entire range, so move on to the next\n                        // without adding this one.\n                        a += 1;\n                        continue 'LOOP;\n                    }\n                    (Some(range1), None) | (None, Some(range1)) => range1,\n                    (Some(range1), Some(range2)) => {\n                        self.ranges.push(range1);\n                        range2\n                    }\n                };\n                // It's possible that the `b` range has more to contribute\n                // here. In particular, if it is greater than the original\n                // range, then it might impact the next `a` range *and* it\n                // has impacted the current `a` range as much as possible,\n                // so we can quit. We don't bump `b` so that the next `a`\n                // range can apply it.\n                if other.ranges[b].upper() > old_range.upper() {\n                    break;\n                }\n                // Otherwise, the next `b` range might apply to the current\n                // `a` range.\n                b += 1;\n            }\n            self.ranges.push(range);\n            a += 1;\n        }\n        while a < drain_end {\n            let range = self.ranges[a];\n            self.ranges.push(range);\n            a += 1;\n        }\n        self.ranges.drain(..drain_end);\n    }\n\n    /// Compute the symmetric difference of the two sets, in place.\n    ///\n    /// This computes the symmetric difference of two interval sets. This\n    /// removes all elements in this set that are also in the given set,\n    /// but also adds all elements from the given set that aren't in this\n    /// set. That is, the set will contain all elements in either set,\n    /// but will not contain any elements that are in both sets.\n    pub fn symmetric_difference(&mut self, other: &IntervalSet<I>) {\n        // TODO(burntsushi): Fix this so that it amortizes allocation.\n        let mut intersection = self.clone();\n        intersection.intersect(other);\n        self.union(other);\n        self.difference(&intersection);\n    }\n\n    /// Negate this interval set.\n    ///\n    /// For all `x` where `x` is any element, if `x` was in this set, then it\n    /// will not be in this set after negation.\n    pub fn negate(&mut self) {\n        if self.ranges.is_empty() {\n            let (min, max) = (I::Bound::min_value(), I::Bound::max_value());\n            self.ranges.push(I::create(min, max));\n            return;\n        }\n\n        // There should be a way to do this in-place with constant memory,\n        // but I couldn't figure out a simple way to do it. So just append\n        // the negation to the end of this range, and then drain it before\n        // we're done.\n        let drain_end = self.ranges.len();\n\n        // We do checked arithmetic below because of the canonical ordering\n        // invariant.\n        if self.ranges[0].lower() > I::Bound::min_value() {\n            let upper = self.ranges[0].lower().decrement();\n            self.ranges.push(I::create(I::Bound::min_value(), upper));\n        }\n        for i in 1..drain_end {\n            let lower = self.ranges[i - 1].upper().increment();\n            let upper = self.ranges[i].lower().decrement();\n            self.ranges.push(I::create(lower, upper));\n        }\n        if self.ranges[drain_end - 1].upper() < I::Bound::max_value() {\n            let lower = self.ranges[drain_end - 1].upper().increment();\n            self.ranges.push(I::create(lower, I::Bound::max_value()));\n        }\n        self.ranges.drain(..drain_end);\n    }\n\n    /// Converts this set into a canonical ordering.\n    fn canonicalize(&mut self) {\n        if self.is_canonical() {\n            return;\n        }\n        self.ranges.sort();\n        assert!(!self.ranges.is_empty());\n\n        // Is there a way to do this in-place with constant memory? I couldn't\n        // figure out a way to do it. So just append the canonicalization to\n        // the end of this range, and then drain it before we're done.\n        let drain_end = self.ranges.len();\n        for oldi in 0..drain_end {\n            // If we've added at least one new range, then check if we can\n            // merge this range in the previously added range.\n            if self.ranges.len() > drain_end {\n                let (last, rest) = self.ranges.split_last_mut().unwrap();\n                if let Some(union) = last.union(&rest[oldi]) {\n                    *last = union;\n                    continue;\n                }\n            }\n            let range = self.ranges[oldi];\n            self.ranges.push(range);\n        }\n        self.ranges.drain(..drain_end);\n    }\n\n    /// Returns true if and only if this class is in a canonical ordering.\n    fn is_canonical(&self) -> bool {\n        for pair in self.ranges.windows(2) {\n            if pair[0] >= pair[1] {\n                return false;\n            }\n            if pair[0].is_contiguous(&pair[1]) {\n                return false;\n            }\n        }\n        true\n    }\n}\n\n/// An iterator over intervals.\n#[derive(Debug)]\npub struct IntervalSetIter<'a, I: 'a>(slice::Iter<'a, I>);\n\nimpl<'a, I> Iterator for IntervalSetIter<'a, I> {\n    type Item = &'a I;\n\n    fn next(&mut self) -> Option<&'a I> {\n        self.0.next()\n    }\n}\n\npub trait Interval:\n    Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n{\n    type Bound: Bound;\n\n    fn lower(&self) -> Self::Bound;\n    fn upper(&self) -> Self::Bound;\n    fn set_lower(&mut self, bound: Self::Bound);\n    fn set_upper(&mut self, bound: Self::Bound);\n    fn case_fold_simple(\n        &self,\n        intervals: &mut Vec<Self>,\n    ) -> Result<(), unicode::CaseFoldError>;\n\n    /// Create a new interval.\n    fn create(lower: Self::Bound, upper: Self::Bound) -> Self {\n        let mut int = Self::default();\n        if lower <= upper {\n            int.set_lower(lower);\n            int.set_upper(upper);\n        } else {\n            int.set_lower(upper);\n            int.set_upper(lower);\n        }\n        int\n    }\n\n    /// Union the given overlapping range into this range.\n    ///\n    /// If the two ranges aren't contiguous, then this returns `None`.\n    fn union(&self, other: &Self) -> Option<Self> {\n        if !self.is_contiguous(other) {\n            return None;\n        }\n        let lower = cmp::min(self.lower(), other.lower());\n        let upper = cmp::max(self.upper(), other.upper());\n        Some(Self::create(lower, upper))\n    }\n\n    /// Intersect this range with the given range and return the result.\n    ///\n    /// If the intersection is empty, then this returns `None`.\n    fn intersect(&self, other: &Self) -> Option<Self> {\n        let lower = cmp::max(self.lower(), other.lower());\n        let upper = cmp::min(self.upper(), other.upper());\n        if lower <= upper {\n            Some(Self::create(lower, upper))\n        } else {\n            None\n        }\n    }\n\n    /// Subtract the given range from this range and return the resulting\n    /// ranges.\n    ///\n    /// If subtraction would result in an empty range, then no ranges are\n    /// returned.\n    fn difference(&self, other: &Self) -> (Option<Self>, Option<Self>) {\n        if self.is_subset(other) {\n            return (None, None);\n        }\n        if self.is_intersection_empty(other) {\n            return (Some(self.clone()), None);\n        }\n        let add_lower = other.lower() > self.lower();\n        let add_upper = other.upper() < self.upper();\n        // We know this because !self.is_subset(other) and the ranges have\n        // a non-empty intersection.\n        assert!(add_lower || add_upper);\n        let mut ret = (None, None);\n        if add_lower {\n            let upper = other.lower().decrement();\n            ret.0 = Some(Self::create(self.lower(), upper));\n        }\n        if add_upper {\n            let lower = other.upper().increment();\n            let range = Self::create(lower, self.upper());\n            if ret.0.is_none() {\n                ret.0 = Some(range);\n            } else {\n                ret.1 = Some(range);\n            }\n        }\n        ret\n    }\n\n    /// Compute the symmetric difference the given range from this range. This\n    /// returns the union of the two ranges minus its intersection.\n    fn symmetric_difference(\n        &self,\n        other: &Self,\n    ) -> (Option<Self>, Option<Self>) {\n        let union = match self.union(other) {\n            None => return (Some(self.clone()), Some(other.clone())),\n            Some(union) => union,\n        };\n        let intersection = match self.intersect(other) {\n            None => return (Some(self.clone()), Some(other.clone())),\n            Some(intersection) => intersection,\n        };\n        union.difference(&intersection)\n    }\n\n    /// Returns true if and only if the two ranges are contiguous. Two ranges\n    /// are contiguous if and only if the ranges are either overlapping or\n    /// adjacent.\n    fn is_contiguous(&self, other: &Self) -> bool {\n        let lower1 = self.lower().as_u32();\n        let upper1 = self.upper().as_u32();\n        let lower2 = other.lower().as_u32();\n        let upper2 = other.upper().as_u32();\n        cmp::max(lower1, lower2) <= cmp::min(upper1, upper2).saturating_add(1)\n    }\n\n    /// Returns true if and only if the intersection of this range and the\n    /// other range is empty.\n    fn is_intersection_empty(&self, other: &Self) -> bool {\n        let (lower1, upper1) = (self.lower(), self.upper());\n        let (lower2, upper2) = (other.lower(), other.upper());\n        cmp::max(lower1, lower2) > cmp::min(upper1, upper2)\n    }\n\n    /// Returns true if and only if this range is a subset of the other range.\n    fn is_subset(&self, other: &Self) -> bool {\n        let (lower1, upper1) = (self.lower(), self.upper());\n        let (lower2, upper2) = (other.lower(), other.upper());\n        (lower2 <= lower1 && lower1 <= upper2)\n            && (lower2 <= upper1 && upper1 <= upper2)\n    }\n}\n\npub trait Bound:\n    Copy + Clone + Debug + Eq + PartialEq + PartialOrd + Ord\n{\n    fn min_value() -> Self;\n    fn max_value() -> Self;\n    fn as_u32(self) -> u32;\n    fn increment(self) -> Self;\n    fn decrement(self) -> Self;\n}\n\nimpl Bound for u8 {\n    fn min_value() -> Self {\n        u8::MIN\n    }\n    fn max_value() -> Self {\n        u8::MAX\n    }\n    fn as_u32(self) -> u32 {\n        self as u32\n    }\n    fn increment(self) -> Self {\n        self.checked_add(1).unwrap()\n    }\n    fn decrement(self) -> Self {\n        self.checked_sub(1).unwrap()\n    }\n}\n\nimpl Bound for char {\n    fn min_value() -> Self {\n        '\\x00'\n    }\n    fn max_value() -> Self {\n        '\\u{10FFFF}'\n    }\n    fn as_u32(self) -> u32 {\n        self as u32\n    }\n\n    fn increment(self) -> Self {\n        match self {\n            '\\u{D7FF}' => '\\u{E000}',\n            c => char::from_u32((c as u32).checked_add(1).unwrap()).unwrap(),\n        }\n    }\n\n    fn decrement(self) -> Self {\n        match self {\n            '\\u{E000}' => '\\u{D7FF}',\n            c => char::from_u32((c as u32).checked_sub(1).unwrap()).unwrap(),\n        }\n    }\n}\n\n// Tests for interval sets are written in src/hir.rs against the public API.\n","traces":[{"line":46,"address":[7363792,7363584,7363650,7363858],"length":1,"stats":{"Line":21},"fn_name":"new<regex_syntax::hir::ClassBytesRange,alloc::vec::Vec<regex_syntax::hir::ClassBytesRange>>"},{"line":47,"address":[7363870,7363802,7363594,7363662],"length":1,"stats":{"Line":46},"fn_name":null},{"line":48,"address":[7363698,7363906],"length":1,"stats":{"Line":25},"fn_name":null},{"line":49,"address":[7363922,7363714],"length":1,"stats":{"Line":23},"fn_name":null},{"line":53,"address":[7364000,7364064],"length":1,"stats":{"Line":23},"fn_name":"push<regex_syntax::hir::ClassBytesRange>"},{"line":56,"address":[7364081,7364018],"length":1,"stats":{"Line":21},"fn_name":null},{"line":57,"address":[7364101,7364045],"length":1,"stats":{"Line":23},"fn_name":null},{"line":63,"address":[7364208,7364112],"length":1,"stats":{"Line":21},"fn_name":"iter<regex_syntax::hir::ClassBytesRange>"},{"line":64,"address":[7364121,7364217],"length":1,"stats":{"Line":22},"fn_name":null},{"line":70,"address":[7364304,7364352],"length":1,"stats":{"Line":21},"fn_name":"intervals<regex_syntax::hir::ClassBytesRange>"},{"line":71,"address":[7364313,7364361],"length":1,"stats":{"Line":25},"fn_name":null},{"line":81,"address":[7364720,7364400],"length":1,"stats":{"Line":16},"fn_name":"case_fold_simple<regex_syntax::hir::ClassUnicodeRange>"},{"line":82,"address":[7364732,7364412],"length":1,"stats":{"Line":16},"fn_name":null},{"line":83,"address":[7364561,7364759,7364878,7364986,7364671,7364442],"length":1,"stats":{"Line":36},"fn_name":null},{"line":84,"address":[7364914,7364597],"length":1,"stats":{"Line":16},"fn_name":null},{"line":85,"address":[7364952,7364637],"length":1,"stats":{"Line":16},"fn_name":null},{"line":86,"address":[7364681,7364996],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[7365002,7364687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[7364867,7364550],"length":1,"stats":{"Line":20},"fn_name":null},{"line":91,"address":[7364709,7365024],"length":1,"stats":{"Line":19},"fn_name":null},{"line":95,"address":[7365088,7365040],"length":1,"stats":{"Line":12},"fn_name":"union<regex_syntax::hir::ClassUnicodeRange>"},{"line":97,"address":[7365102,7365054],"length":1,"stats":{"Line":12},"fn_name":null},{"line":98,"address":[7365122,7365074],"length":1,"stats":{"Line":12},"fn_name":null},{"line":102,"address":[7365136,7366112],"length":1,"stats":{"Line":0},"fn_name":"intersect<regex_syntax::hir::ClassBytesRange>"},{"line":103,"address":[7365159,7366135],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[7365215,7366191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[7366205,7366176,7365200,7365229],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[7366245,7365269],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[7366254,7365278],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[7366216,7365240],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[7365280,7366256],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[7365348,7366327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[7365428,7366407],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[7365483,7366465],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[7366523,7367036,7366074,7365541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[7365735,7366692,7365548,7366530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[7365720,7366679],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[7365892,7366849,7366699,7365742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[7365894,7366851],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[7366817,7365860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[7365955,7366049,7367010,7366915],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[7366051,7365987,7366948,7367012],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[7367041,7366975,7366079,7366014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[7367072,7369344],"length":1,"stats":{"Line":0},"fn_name":"difference<regex_syntax::hir::ClassUnicodeRange>"},{"line":141,"address":[7369367,7367095],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[7369523,7367251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[7367224,7369496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[7367261,7369533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[7371270,7367325,7368948,7369597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[7367448,7369720],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[7369161,7367622,7371487,7369894],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[7367672,7369944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[7367595,7367685,7369957,7369867],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[7370109,7367837],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[7367897,7370169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[7367908,7369191,7370184,7371517],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[7367958,7370234],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[7368060,7370071,7367799,7370247,7370336,7367971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[7370371,7370312,7368036,7368095],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[7370479,7368114,7370540,7368264,7370390,7368899,7371221,7368203],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[7368235,7370511,7368179,7370455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[7368270,7370546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[7370982,7370952,7371006,7368306,7368634,7370922,7368410,7368664,7368688,7370582,7368604,7370722],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[7368355,7370677],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[7370845,7371577,7368527,7369251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[7368571,7370889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[7368636,7368606,7368412,7370724,7370924,7370894,7368576,7370954],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[7368440,7370745],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[7370811,7368508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[7370988,7368670],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[7371042,7368724],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[7368851,7371169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[7368818,7369221,7368891,7371547,7371213,7371136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[7371179,7368861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[7371607,7371226,7368904,7369281],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[7369707,7369137,7368961,7371283,7371463,7367435],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[7369030,7371352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[7371406,7369084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[7371421,7371667,7369095,7369311,7369341,7371637],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[7368987,7371309,7371468,7369142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[7371680,7371727,7371840,7371887],"length":1,"stats":{"Line":0},"fn_name":"symmetric_difference<regex_syntax::hir::ClassBytesRange>"},{"line":240,"address":[7371854,7371694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[7371748,7371908],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[7371764,7371924],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[7371954,7371794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[7373424,7372000],"length":1,"stats":{"Line":16},"fn_name":"negate<regex_syntax::hir::ClassUnicodeRange>"},{"line":251,"address":[7373439,7372015],"length":1,"stats":{"Line":16},"fn_name":null},{"line":252,"address":[7372093,7373517],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[7372191,7373609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[7372241,7373682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[7372063,7373487],"length":1,"stats":{"Line":16},"fn_name":null},{"line":265,"address":[7372524,7373704,7373980,7372263],"length":1,"stats":{"Line":34},"fn_name":null},{"line":266,"address":[7372369,7373810],"length":1,"stats":{"Line":17},"fn_name":null},{"line":267,"address":[7373893,7372449],"length":1,"stats":{"Line":17},"fn_name":null},{"line":269,"address":[7374186,7374463,7373982,7372526,7372730,7372995],"length":1,"stats":{"Line":41},"fn_name":null},{"line":270,"address":[7374228,7374813,7372772,7373330],"length":1,"stats":{"Line":19},"fn_name":null},{"line":271,"address":[7372884,7374337],"length":1,"stats":{"Line":22},"fn_name":null},{"line":272,"address":[7372962,7374409],"length":1,"stats":{"Line":23},"fn_name":null},{"line":274,"address":[7373016,7374743,7374484,7373360,7374843,7372690,7373260,7374146],"length":1,"stats":{"Line":57},"fn_name":null},{"line":275,"address":[7373390,7374579,7373420,7373111,7374873,7374903],"length":1,"stats":{"Line":18},"fn_name":null},{"line":276,"address":[7373209,7374680],"length":1,"stats":{"Line":19},"fn_name":null},{"line":278,"address":[7373278,7374761],"length":1,"stats":{"Line":19},"fn_name":null},{"line":282,"address":[7375824,7374912],"length":1,"stats":{"Line":21},"fn_name":"canonicalize<regex_syntax::hir::ClassBytesRange>"},{"line":283,"address":[7375844,7374935],"length":1,"stats":{"Line":25},"fn_name":null},{"line":284,"address":[7374984,7375890],"length":1,"stats":{"Line":27},"fn_name":null},{"line":286,"address":[7375869,7375004,7374963,7375910],"length":1,"stats":{"Line":32},"fn_name":null},{"line":287,"address":[7375018,7375075,7375975,7375921],"length":1,"stats":{"Line":16},"fn_name":null},{"line":292,"address":[7375051,7375951],"length":1,"stats":{"Line":16},"fn_name":null},{"line":293,"address":[7376612,7376005,7375760,7375289,7375105,7376186],"length":1,"stats":{"Line":32},"fn_name":null},{"line":296,"address":[7375641,7375331,7376505,7376225],"length":1,"stats":{"Line":32},"fn_name":null},{"line":297,"address":[7376268,7375377],"length":1,"stats":{"Line":16},"fn_name":null},{"line":298,"address":[7375643,7375784,7375505,7376664,7376396,7376636,7376507,7375812],"length":1,"stats":{"Line":32},"fn_name":null},{"line":299,"address":[7376540,7375676],"length":1,"stats":{"Line":16},"fn_name":null},{"line":300,"address":[7376545,7375681],"length":1,"stats":{"Line":16},"fn_name":null},{"line":303,"address":[7375694,7376555],"length":1,"stats":{"Line":16},"fn_name":null},{"line":304,"address":[7376601,7375745],"length":1,"stats":{"Line":16},"fn_name":null},{"line":306,"address":[7375765,7376148,7375251,7376617],"length":1,"stats":{"Line":32},"fn_name":null},{"line":310,"address":[7376672,7377248],"length":1,"stats":{"Line":23},"fn_name":"is_canonical<regex_syntax::hir::ClassUnicodeRange>"},{"line":311,"address":[7376840,7377263,7377696,7376687,7377416,7377120],"length":1,"stats":{"Line":71},"fn_name":null},{"line":312,"address":[7377708,7377132,7377486,7376910],"length":1,"stats":{"Line":38},"fn_name":null},{"line":313,"address":[7377605,7377029,7377629,7377053],"length":1,"stats":{"Line":38},"fn_name":null},{"line":315,"address":[7377055,7377587,7377631,7377763,7377011,7377187],"length":1,"stats":{"Line":82},"fn_name":null},{"line":316,"address":[7377125,7377701],"length":1,"stats":{"Line":16},"fn_name":null},{"line":319,"address":[7377406,7376830],"length":1,"stats":{"Line":23},"fn_name":null},{"line":330,"address":[7377856,7377824],"length":1,"stats":{"Line":21},"fn_name":"next<regex_syntax::hir::ClassUnicodeRange>"},{"line":331,"address":[7377833,7377865],"length":1,"stats":{"Line":22},"fn_name":null},{"line":350,"address":[7252896,7253040],"length":1,"stats":{"Line":22},"fn_name":"create<regex_syntax::hir::ClassBytesRange>"},{"line":351,"address":[7252910,7253052],"length":1,"stats":{"Line":26},"fn_name":null},{"line":352,"address":[7253016,7252999,7252923,7253065,7253154,7253138],"length":1,"stats":{"Line":48},"fn_name":null},{"line":353,"address":[7253110,7252969],"length":1,"stats":{"Line":26},"fn_name":null},{"line":354,"address":[7252984,7253124],"length":1,"stats":{"Line":22},"fn_name":null},{"line":356,"address":[7253094,7252952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[7253140,7253001],"length":1,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[7253156,7253018],"length":1,"stats":{"Line":22},"fn_name":null},{"line":365,"address":[7253424,7253184],"length":1,"stats":{"Line":16},"fn_name":"union<regex_syntax::hir::ClassBytesRange>"},{"line":366,"address":[7253208,7253448],"length":1,"stats":{"Line":16},"fn_name":null},{"line":367,"address":[7253244,7253484],"length":1,"stats":{"Line":16},"fn_name":null},{"line":369,"address":[7253276,7253233,7253510,7253473],"length":1,"stats":{"Line":32},"fn_name":null},{"line":370,"address":[7253546,7253318],"length":1,"stats":{"Line":16},"fn_name":null},{"line":371,"address":[7253373,7253599],"length":1,"stats":{"Line":16},"fn_name":null},{"line":377,"address":[7253648,7253888],"length":1,"stats":{"Line":0},"fn_name":"intersect<regex_syntax::hir::ClassBytesRange>"},{"line":378,"address":[7253672,7253912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[7253724,7253958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[7253771,7253805,7254036,7253999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[7253807,7254038],"length":1,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[7254028,7253800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[7254096,7255056],"length":1,"stats":{"Line":0},"fn_name":"difference<regex_syntax::hir::ClassUnicodeRange>"},{"line":393,"address":[7254127,7255089],"length":1,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[7255131,7254190],"length":1,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[7254178,7255119,7254255,7255212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[7254285,7255239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[7254361,7255328,7255223,7254266],"length":1,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[7255373,7254415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[7254485,7255531,7254626,7255431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[7254534,7255471],"length":1,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[7254616,7255521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[7255566,7254661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[7255604,7254696],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[7255008,7254781,7255686,7255916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[7254795,7255700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[7255738,7254830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[7255789,7254956,7255873,7254875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[7254962,7255879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[7255821,7254910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[7255010,7255918],"length":1,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[7256544,7255952],"length":1,"stats":{"Line":0},"fn_name":"symmetric_difference<regex_syntax::hir::ClassBytesRange>"},{"line":427,"address":[7256138,7255969,7256693,7256570],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[7256021,7256145,7256700,7256195,7256732,7256613],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[7256634,7256035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[7256065,7256886,7256410,7256664],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[7256893,7256296,7256812,7256417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[7256833,7256310],"length":1,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[7256868,7256340],"length":1,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[7257264,7257024],"length":1,"stats":{"Line":44},"fn_name":"is_contiguous<regex_syntax::hir::ClassUnicodeRange>"},{"line":442,"address":[7257288,7257048],"length":1,"stats":{"Line":38},"fn_name":null},{"line":443,"address":[7257080,7257323],"length":1,"stats":{"Line":44},"fn_name":null},{"line":444,"address":[7257358,7257112],"length":1,"stats":{"Line":38},"fn_name":null},{"line":445,"address":[7257393,7257144],"length":1,"stats":{"Line":44},"fn_name":null},{"line":446,"address":[7257179,7257431],"length":1,"stats":{"Line":38},"fn_name":null},{"line":451,"address":[7257504,7257744],"length":1,"stats":{"Line":12},"fn_name":"is_intersection_empty<regex_syntax::hir::ClassBytesRange>"},{"line":452,"address":[7257768,7257528],"length":1,"stats":{"Line":12},"fn_name":null},{"line":453,"address":[7257836,7257599],"length":1,"stats":{"Line":12},"fn_name":null},{"line":454,"address":[7257899,7257661],"length":1,"stats":{"Line":12},"fn_name":null},{"line":458,"address":[7257968,7258320],"length":1,"stats":{"Line":0},"fn_name":"is_subset<regex_syntax::hir::ClassBytesRange>"},{"line":459,"address":[7257992,7258344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[7258052,7258404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[7258532,7258107,7258459,7258631,7258279,7258180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[7258651,7258299,7258142,7258494,7258596,7258244],"length":1,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[7378848],"length":1,"stats":{"Line":8},"fn_name":"min_value"},{"line":478,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[7378864],"length":1,"stats":{"Line":11},"fn_name":"max_value"},{"line":481,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[7378880],"length":1,"stats":{"Line":21},"fn_name":"as_u32"},{"line":484,"address":[7378888],"length":1,"stats":{"Line":15},"fn_name":null},{"line":486,"address":[7378912],"length":1,"stats":{"Line":10},"fn_name":"increment"},{"line":487,"address":[7378921],"length":1,"stats":{"Line":10},"fn_name":null},{"line":489,"address":[7379008],"length":1,"stats":{"Line":9},"fn_name":"decrement"},{"line":490,"address":[7379017],"length":1,"stats":{"Line":9},"fn_name":null},{"line":495,"address":[7379104],"length":1,"stats":{"Line":8},"fn_name":"min_value"},{"line":496,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[7379120],"length":1,"stats":{"Line":8},"fn_name":"max_value"},{"line":499,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[7379136],"length":1,"stats":{"Line":23},"fn_name":"as_u32"},{"line":502,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[7379152],"length":1,"stats":{"Line":8},"fn_name":"increment"},{"line":506,"address":[7379277,7379210],"length":1,"stats":{"Line":8},"fn_name":null},{"line":507,"address":[7379160,7379202],"length":1,"stats":{"Line":8},"fn_name":null},{"line":508,"address":[7379176,7379227],"length":1,"stats":{"Line":16},"fn_name":null},{"line":512,"address":[7379296],"length":1,"stats":{"Line":8},"fn_name":"decrement"},{"line":513,"address":[7379421,7379354],"length":1,"stats":{"Line":8},"fn_name":null},{"line":514,"address":[7379304,7379346],"length":1,"stats":{"Line":8},"fn_name":null},{"line":515,"address":[7379320,7379371],"length":1,"stats":{"Line":16},"fn_name":null}],"covered":100,"coverable":214},{"path":["/","usr","src","regex","regex-syntax","src","hir","literal","mod.rs"],"content":"/*!\nProvides routines for extracting literal prefixes and suffixes from an `Hir`.\n*/\n\nuse std::cmp;\nuse std::fmt;\nuse std::iter;\nuse std::mem;\nuse std::ops;\n\nuse hir::{self, Hir, HirKind};\n\n/// A set of literal byte strings extracted from a regular expression.\n///\n/// Every member of the set is a `Literal`, which is represented by a\n/// `Vec<u8>`. (Notably, it may contain invalid UTF-8.) Every member is\n/// said to be either *complete* or *cut*. A complete literal means that\n/// it extends until the beginning (or end) of the regular expression. In\n/// some circumstances, this can be used to indicate a match in the regular\n/// expression.\n///\n/// A key aspect of literal extraction is knowing when to stop. It is not\n/// feasible to blindly extract all literals from a regular expression, even if\n/// there are finitely many. For example, the regular expression `[0-9]{10}`\n/// has `10^10` distinct literals. For this reason, literal extraction is\n/// bounded to some low number by default using heuristics, but the limits can\n/// be tweaked.\n///\n/// **WARNING**: Literal extraction uses stack space proportional to the size\n/// of the `Hir` expression. At some point, this drawback will be eliminated.\n/// To protect yourself, set a reasonable\n/// [`nest_limit` on your `Parser`](../../struct.ParserBuilder.html#method.nest_limit).\n/// This is done for you by default.\n#[derive(Clone, Eq, PartialEq)]\npub struct Literals {\n    lits: Vec<Literal>,\n    limit_size: usize,\n    limit_class: usize,\n}\n\n/// A single member of a set of literals extracted from a regular expression.\n///\n/// This type has `Deref` and `DerefMut` impls to `Vec<u8>` so that all slice\n/// and `Vec` operations are available.\n#[derive(Clone, Eq, Ord)]\npub struct Literal {\n    v: Vec<u8>,\n    cut: bool,\n}\n\nimpl Literals {\n    /// Returns a new empty set of literals using default limits.\n    pub fn empty() -> Literals {\n        Literals { lits: vec![], limit_size: 250, limit_class: 10 }\n    }\n\n    /// Returns a set of literal prefixes extracted from the given `Hir`.\n    pub fn prefixes(expr: &Hir) -> Literals {\n        let mut lits = Literals::empty();\n        lits.union_prefixes(expr);\n        lits\n    }\n\n    /// Returns a set of literal suffixes extracted from the given `Hir`.\n    pub fn suffixes(expr: &Hir) -> Literals {\n        let mut lits = Literals::empty();\n        lits.union_suffixes(expr);\n        lits\n    }\n\n    /// Get the approximate size limit (in bytes) of this set.\n    pub fn limit_size(&self) -> usize {\n        self.limit_size\n    }\n\n    /// Set the approximate size limit (in bytes) of this set.\n    ///\n    /// If extracting a literal would put the set over this limit, then\n    /// extraction stops.\n    ///\n    /// The new limits will only apply to additions to this set. Existing\n    /// members remain unchanged, even if the set exceeds the new limit.\n    pub fn set_limit_size(&mut self, size: usize) -> &mut Literals {\n        self.limit_size = size;\n        self\n    }\n\n    /// Get the character class size limit for this set.\n    pub fn limit_class(&self) -> usize {\n        self.limit_class\n    }\n\n    /// Limits the size of character(or byte) classes considered.\n    ///\n    /// A value of `0` prevents all character classes from being considered.\n    ///\n    /// This limit also applies to case insensitive literals, since each\n    /// character in the case insensitive literal is converted to a class, and\n    /// then case folded.\n    ///\n    /// The new limits will only apply to additions to this set. Existing\n    /// members remain unchanged, even if the set exceeds the new limit.\n    pub fn set_limit_class(&mut self, size: usize) -> &mut Literals {\n        self.limit_class = size;\n        self\n    }\n\n    /// Returns the set of literals as a slice. Its order is unspecified.\n    pub fn literals(&self) -> &[Literal] {\n        &self.lits\n    }\n\n    /// Returns the length of the smallest literal.\n    ///\n    /// Returns None is there are no literals in the set.\n    pub fn min_len(&self) -> Option<usize> {\n        let mut min = None;\n        for lit in &self.lits {\n            match min {\n                None => min = Some(lit.len()),\n                Some(m) if lit.len() < m => min = Some(lit.len()),\n                _ => {}\n            }\n        }\n        min\n    }\n\n    /// Returns true if all members in this set are complete.\n    pub fn all_complete(&self) -> bool {\n        !self.lits.is_empty() && self.lits.iter().all(|l| !l.is_cut())\n    }\n\n    /// Returns true if any member in this set is complete.\n    pub fn any_complete(&self) -> bool {\n        self.lits.iter().any(|lit| !lit.is_cut())\n    }\n\n    /// Returns true if this set contains an empty literal.\n    pub fn contains_empty(&self) -> bool {\n        self.lits.iter().any(|lit| lit.is_empty())\n    }\n\n    /// Returns true if this set is empty or if all of its members is empty.\n    pub fn is_empty(&self) -> bool {\n        self.lits.is_empty() || self.lits.iter().all(|lit| lit.is_empty())\n    }\n\n    /// Returns a new empty set of literals using this set's limits.\n    pub fn to_empty(&self) -> Literals {\n        let mut lits = Literals::empty();\n        lits.set_limit_size(self.limit_size).set_limit_class(self.limit_class);\n        lits\n    }\n\n    /// Returns the longest common prefix of all members in this set.\n    pub fn longest_common_prefix(&self) -> &[u8] {\n        if self.is_empty() {\n            return &[];\n        }\n        let lit0 = &*self.lits[0];\n        let mut len = lit0.len();\n        for lit in &self.lits[1..] {\n            len = cmp::min(\n                len,\n                lit.iter().zip(lit0).take_while(|&(a, b)| a == b).count(),\n            );\n        }\n        &self.lits[0][..len]\n    }\n\n    /// Returns the longest common suffix of all members in this set.\n    pub fn longest_common_suffix(&self) -> &[u8] {\n        if self.is_empty() {\n            return &[];\n        }\n        let lit0 = &*self.lits[0];\n        let mut len = lit0.len();\n        for lit in &self.lits[1..] {\n            len = cmp::min(\n                len,\n                lit.iter()\n                    .rev()\n                    .zip(lit0.iter().rev())\n                    .take_while(|&(a, b)| a == b)\n                    .count(),\n            );\n        }\n        &self.lits[0][self.lits[0].len() - len..]\n    }\n\n    /// Returns a new set of literals with the given number of bytes trimmed\n    /// from the suffix of each literal.\n    ///\n    /// If any literal would be cut out completely by trimming, then None is\n    /// returned.\n    ///\n    /// Any duplicates that are created as a result of this transformation are\n    /// removed.\n    pub fn trim_suffix(&self, num_bytes: usize) -> Option<Literals> {\n        if self.min_len().map(|len| len <= num_bytes).unwrap_or(true) {\n            return None;\n        }\n        let mut new = self.to_empty();\n        for mut lit in self.lits.iter().cloned() {\n            let new_len = lit.len() - num_bytes;\n            lit.truncate(new_len);\n            lit.cut();\n            new.lits.push(lit);\n        }\n        new.lits.sort();\n        new.lits.dedup();\n        Some(new)\n    }\n\n    /// Returns a new set of prefixes of this set of literals that are\n    /// guaranteed to be unambiguous.\n    ///\n    /// Any substring match with a member of the set is returned is guaranteed\n    /// to never overlap with a substring match of another member of the set\n    /// at the same starting position.\n    ///\n    /// Given any two members of the returned set, neither is a substring of\n    /// the other.\n    pub fn unambiguous_prefixes(&self) -> Literals {\n        if self.lits.is_empty() {\n            return self.to_empty();\n        }\n        let mut old: Vec<Literal> = self.lits.iter().cloned().collect();\n        let mut new = self.to_empty();\n        'OUTER: while let Some(mut candidate) = old.pop() {\n            if candidate.is_empty() {\n                continue;\n            }\n            if new.lits.is_empty() {\n                new.lits.push(candidate);\n                continue;\n            }\n            for lit2 in &mut new.lits {\n                if lit2.is_empty() {\n                    continue;\n                }\n                if &candidate == lit2 {\n                    // If the literal is already in the set, then we can\n                    // just drop it. But make sure that cut literals are\n                    // infectious!\n                    candidate.cut = candidate.cut || lit2.cut;\n                    lit2.cut = candidate.cut;\n                    continue 'OUTER;\n                }\n                if candidate.len() < lit2.len() {\n                    if let Some(i) = position(&candidate, &lit2) {\n                        candidate.cut();\n                        let mut lit3 = lit2.clone();\n                        lit3.truncate(i);\n                        lit3.cut();\n                        old.push(lit3);\n                        lit2.clear();\n                    }\n                } else {\n                    if let Some(i) = position(&lit2, &candidate) {\n                        lit2.cut();\n                        let mut new_candidate = candidate.clone();\n                        new_candidate.truncate(i);\n                        new_candidate.cut();\n                        old.push(new_candidate);\n                        candidate.clear();\n                    }\n                }\n                // Oops, the candidate is already represented in the set.\n                if candidate.is_empty() {\n                    continue 'OUTER;\n                }\n            }\n            new.lits.push(candidate);\n        }\n        new.lits.retain(|lit| !lit.is_empty());\n        new.lits.sort();\n        new.lits.dedup();\n        new\n    }\n\n    /// Returns a new set of suffixes of this set of literals that are\n    /// guaranteed to be unambiguous.\n    ///\n    /// Any substring match with a member of the set is returned is guaranteed\n    /// to never overlap with a substring match of another member of the set\n    /// at the same ending position.\n    ///\n    /// Given any two members of the returned set, neither is a substring of\n    /// the other.\n    pub fn unambiguous_suffixes(&self) -> Literals {\n        // This is a touch wasteful...\n        let mut lits = self.clone();\n        lits.reverse();\n        let mut unamb = lits.unambiguous_prefixes();\n        unamb.reverse();\n        unamb\n    }\n\n    /// Unions the prefixes from the given expression to this set.\n    ///\n    /// If prefixes could not be added (for example, this set would exceed its\n    /// size limits or the set of prefixes from `expr` includes the empty\n    /// string), then false is returned.\n    ///\n    /// Note that prefix literals extracted from `expr` are said to be complete\n    /// if and only if the literal extends from the beginning of `expr` to the\n    /// end of `expr`.\n    pub fn union_prefixes(&mut self, expr: &Hir) -> bool {\n        let mut lits = self.to_empty();\n        prefixes(expr, &mut lits);\n        !lits.is_empty() && !lits.contains_empty() && self.union(lits)\n    }\n\n    /// Unions the suffixes from the given expression to this set.\n    ///\n    /// If suffixes could not be added (for example, this set would exceed its\n    /// size limits or the set of suffixes from `expr` includes the empty\n    /// string), then false is returned.\n    ///\n    /// Note that prefix literals extracted from `expr` are said to be complete\n    /// if and only if the literal extends from the end of `expr` to the\n    /// beginning of `expr`.\n    pub fn union_suffixes(&mut self, expr: &Hir) -> bool {\n        let mut lits = self.to_empty();\n        suffixes(expr, &mut lits);\n        lits.reverse();\n        !lits.is_empty() && !lits.contains_empty() && self.union(lits)\n    }\n\n    /// Unions this set with another set.\n    ///\n    /// If the union would cause the set to exceed its limits, then the union\n    /// is skipped and it returns false. Otherwise, if the union succeeds, it\n    /// returns true.\n    pub fn union(&mut self, lits: Literals) -> bool {\n        if self.num_bytes() + lits.num_bytes() > self.limit_size {\n            return false;\n        }\n        if lits.is_empty() {\n            self.lits.push(Literal::empty());\n        } else {\n            self.lits.extend(lits.lits);\n        }\n        true\n    }\n\n    /// Extends this set with another set.\n    ///\n    /// The set of literals is extended via a cross product.\n    ///\n    /// If a cross product would cause this set to exceed its limits, then the\n    /// cross product is skipped and it returns false. Otherwise, if the cross\n    /// product succeeds, it returns true.\n    pub fn cross_product(&mut self, lits: &Literals) -> bool {\n        if lits.is_empty() {\n            return true;\n        }\n        // Check that we make sure we stay in our limits.\n        let mut size_after;\n        if self.is_empty() || !self.any_complete() {\n            size_after = self.num_bytes();\n            for lits_lit in lits.literals() {\n                size_after += lits_lit.len();\n            }\n        } else {\n            size_after = self.lits.iter().fold(0, |accum, lit| {\n                accum + if lit.is_cut() { lit.len() } else { 0 }\n            });\n            for lits_lit in lits.literals() {\n                for self_lit in self.literals() {\n                    if !self_lit.is_cut() {\n                        size_after += self_lit.len() + lits_lit.len();\n                    }\n                }\n            }\n        }\n        if size_after > self.limit_size {\n            return false;\n        }\n\n        let mut base = self.remove_complete();\n        if base.is_empty() {\n            base = vec![Literal::empty()];\n        }\n        for lits_lit in lits.literals() {\n            for mut self_lit in base.clone() {\n                self_lit.extend(&**lits_lit);\n                self_lit.cut = lits_lit.cut;\n                self.lits.push(self_lit);\n            }\n        }\n        true\n    }\n\n    /// Extends each literal in this set with the bytes given.\n    ///\n    /// If the set is empty, then the given literal is added to the set.\n    ///\n    /// If adding any number of bytes to all members of this set causes a limit\n    /// to be exceeded, then no bytes are added and false is returned. If a\n    /// prefix of `bytes` can be fit into this set, then it is used and all\n    /// resulting literals are cut.\n    pub fn cross_add(&mut self, bytes: &[u8]) -> bool {\n        // N.B. This could be implemented by simply calling cross_product with\n        // a literal set containing just `bytes`, but we can be smarter about\n        // taking shorter prefixes of `bytes` if they'll fit.\n        if bytes.is_empty() {\n            return true;\n        }\n        if self.lits.is_empty() {\n            let i = cmp::min(self.limit_size, bytes.len());\n            self.lits.push(Literal::new(bytes[..i].to_owned()));\n            self.lits[0].cut = i < bytes.len();\n            return !self.lits[0].is_cut();\n        }\n        let size = self.num_bytes();\n        if size + self.lits.len() >= self.limit_size {\n            return false;\n        }\n        let mut i = 1;\n        while size + (i * self.lits.len()) <= self.limit_size\n            && i < bytes.len()\n        {\n            i += 1;\n        }\n        for lit in &mut self.lits {\n            if !lit.is_cut() {\n                lit.extend(&bytes[..i]);\n                if i < bytes.len() {\n                    lit.cut();\n                }\n            }\n        }\n        true\n    }\n\n    /// Adds the given literal to this set.\n    ///\n    /// Returns false if adding this literal would cause the class to be too\n    /// big.\n    pub fn add(&mut self, lit: Literal) -> bool {\n        if self.num_bytes() + lit.len() > self.limit_size {\n            return false;\n        }\n        self.lits.push(lit);\n        true\n    }\n\n    /// Extends each literal in this set with the character class given.\n    ///\n    /// Returns false if the character class was too big to add.\n    pub fn add_char_class(&mut self, cls: &hir::ClassUnicode) -> bool {\n        self._add_char_class(cls, false)\n    }\n\n    /// Extends each literal in this set with the character class given,\n    /// writing the bytes of each character in reverse.\n    ///\n    /// Returns false if the character class was too big to add.\n    fn add_char_class_reverse(&mut self, cls: &hir::ClassUnicode) -> bool {\n        self._add_char_class(cls, true)\n    }\n\n    fn _add_char_class(\n        &mut self,\n        cls: &hir::ClassUnicode,\n        reverse: bool,\n    ) -> bool {\n        use std::char;\n\n        if self.class_exceeds_limits(cls_char_count(cls)) {\n            return false;\n        }\n        let mut base = self.remove_complete();\n        if base.is_empty() {\n            base = vec![Literal::empty()];\n        }\n        for r in cls.iter() {\n            let (s, e) = (r.start as u32, r.end as u32 + 1);\n            for c in (s..e).filter_map(char::from_u32) {\n                for mut lit in base.clone() {\n                    let mut bytes = c.to_string().into_bytes();\n                    if reverse {\n                        bytes.reverse();\n                    }\n                    lit.extend(&bytes);\n                    self.lits.push(lit);\n                }\n            }\n        }\n        true\n    }\n\n    /// Extends each literal in this set with the byte class given.\n    ///\n    /// Returns false if the byte class was too big to add.\n    pub fn add_byte_class(&mut self, cls: &hir::ClassBytes) -> bool {\n        if self.class_exceeds_limits(cls_byte_count(cls)) {\n            return false;\n        }\n        let mut base = self.remove_complete();\n        if base.is_empty() {\n            base = vec![Literal::empty()];\n        }\n        for r in cls.iter() {\n            let (s, e) = (r.start as u32, r.end as u32 + 1);\n            for b in (s..e).map(|b| b as u8) {\n                for mut lit in base.clone() {\n                    lit.push(b);\n                    self.lits.push(lit);\n                }\n            }\n        }\n        true\n    }\n\n    /// Cuts every member of this set. When a member is cut, it can never\n    /// be extended.\n    pub fn cut(&mut self) {\n        for lit in &mut self.lits {\n            lit.cut();\n        }\n    }\n\n    /// Reverses all members in place.\n    pub fn reverse(&mut self) {\n        for lit in &mut self.lits {\n            lit.reverse();\n        }\n    }\n\n    /// Clears this set of all members.\n    pub fn clear(&mut self) {\n        self.lits.clear();\n    }\n\n    /// Pops all complete literals out of this set.\n    fn remove_complete(&mut self) -> Vec<Literal> {\n        let mut base = vec![];\n        for lit in mem::replace(&mut self.lits, vec![]) {\n            if lit.is_cut() {\n                self.lits.push(lit);\n            } else {\n                base.push(lit);\n            }\n        }\n        base\n    }\n\n    /// Returns the total number of bytes in this set.\n    fn num_bytes(&self) -> usize {\n        self.lits.iter().fold(0, |accum, lit| accum + lit.len())\n    }\n\n    /// Returns true if a character class with the given size would cause this\n    /// set to exceed its limits.\n    ///\n    /// The size given should correspond to the number of items in the class.\n    fn class_exceeds_limits(&self, size: usize) -> bool {\n        if size > self.limit_class {\n            return true;\n        }\n        // This is an approximation since codepoints in a char class can encode\n        // to 1-4 bytes.\n        let new_byte_count = if self.lits.is_empty() {\n            size\n        } else {\n            self.lits.iter().fold(0, |accum, lit| {\n                accum\n                    + if lit.is_cut() {\n                        // If the literal is cut, then we'll never add\n                        // anything to it, so don't count it.\n                        0\n                    } else {\n                        (lit.len() + 1) * size\n                    }\n            })\n        };\n        new_byte_count > self.limit_size\n    }\n}\n\nfn prefixes(expr: &Hir, lits: &mut Literals) {\n    match *expr.kind() {\n        HirKind::Literal(hir::Literal::Unicode(c)) => {\n            let mut buf = [0; 4];\n            lits.cross_add(c.encode_utf8(&mut buf).as_bytes());\n        }\n        HirKind::Literal(hir::Literal::Byte(b)) => {\n            lits.cross_add(&[b]);\n        }\n        HirKind::Class(hir::Class::Unicode(ref cls)) => {\n            if !lits.add_char_class(cls) {\n                lits.cut();\n            }\n        }\n        HirKind::Class(hir::Class::Bytes(ref cls)) => {\n            if !lits.add_byte_class(cls) {\n                lits.cut();\n            }\n        }\n        HirKind::Group(hir::Group { ref hir, .. }) => {\n            prefixes(&**hir, lits);\n        }\n        HirKind::Repetition(ref x) => match x.kind {\n            hir::RepetitionKind::ZeroOrOne => {\n                repeat_zero_or_one_literals(&x.hir, lits, prefixes);\n            }\n            hir::RepetitionKind::ZeroOrMore => {\n                repeat_zero_or_more_literals(&x.hir, lits, prefixes);\n            }\n            hir::RepetitionKind::OneOrMore => {\n                repeat_one_or_more_literals(&x.hir, lits, prefixes);\n            }\n            hir::RepetitionKind::Range(ref rng) => {\n                let (min, max) = match *rng {\n                    hir::RepetitionRange::Exactly(m) => (m, Some(m)),\n                    hir::RepetitionRange::AtLeast(m) => (m, None),\n                    hir::RepetitionRange::Bounded(m, n) => (m, Some(n)),\n                };\n                repeat_range_literals(\n                    &x.hir, min, max, x.greedy, lits, prefixes,\n                )\n            }\n        },\n        HirKind::Concat(ref es) if es.is_empty() => {}\n        HirKind::Concat(ref es) if es.len() == 1 => prefixes(&es[0], lits),\n        HirKind::Concat(ref es) => {\n            for e in es {\n                if let HirKind::Anchor(hir::Anchor::StartText) = *e.kind() {\n                    if !lits.is_empty() {\n                        lits.cut();\n                        break;\n                    }\n                    lits.add(Literal::empty());\n                    continue;\n                }\n                let mut lits2 = lits.to_empty();\n                prefixes(e, &mut lits2);\n                if !lits.cross_product(&lits2) || !lits2.any_complete() {\n                    // If this expression couldn't yield any literal that\n                    // could be extended, then we need to quit. Since we're\n                    // short-circuiting, we also need to freeze every member.\n                    lits.cut();\n                    break;\n                }\n            }\n        }\n        HirKind::Alternation(ref es) => {\n            alternate_literals(es, lits, prefixes);\n        }\n        _ => lits.cut(),\n    }\n}\n\nfn suffixes(expr: &Hir, lits: &mut Literals) {\n    match *expr.kind() {\n        HirKind::Literal(hir::Literal::Unicode(c)) => {\n            let mut buf = [0u8; 4];\n            let i = c.encode_utf8(&mut buf).len();\n            let buf = &mut buf[..i];\n            buf.reverse();\n            lits.cross_add(buf);\n        }\n        HirKind::Literal(hir::Literal::Byte(b)) => {\n            lits.cross_add(&[b]);\n        }\n        HirKind::Class(hir::Class::Unicode(ref cls)) => {\n            if !lits.add_char_class_reverse(cls) {\n                lits.cut();\n            }\n        }\n        HirKind::Class(hir::Class::Bytes(ref cls)) => {\n            if !lits.add_byte_class(cls) {\n                lits.cut();\n            }\n        }\n        HirKind::Group(hir::Group { ref hir, .. }) => {\n            suffixes(&**hir, lits);\n        }\n        HirKind::Repetition(ref x) => match x.kind {\n            hir::RepetitionKind::ZeroOrOne => {\n                repeat_zero_or_one_literals(&x.hir, lits, suffixes);\n            }\n            hir::RepetitionKind::ZeroOrMore => {\n                repeat_zero_or_more_literals(&x.hir, lits, suffixes);\n            }\n            hir::RepetitionKind::OneOrMore => {\n                repeat_one_or_more_literals(&x.hir, lits, suffixes);\n            }\n            hir::RepetitionKind::Range(ref rng) => {\n                let (min, max) = match *rng {\n                    hir::RepetitionRange::Exactly(m) => (m, Some(m)),\n                    hir::RepetitionRange::AtLeast(m) => (m, None),\n                    hir::RepetitionRange::Bounded(m, n) => (m, Some(n)),\n                };\n                repeat_range_literals(\n                    &x.hir, min, max, x.greedy, lits, suffixes,\n                )\n            }\n        },\n        HirKind::Concat(ref es) if es.is_empty() => {}\n        HirKind::Concat(ref es) if es.len() == 1 => suffixes(&es[0], lits),\n        HirKind::Concat(ref es) => {\n            for e in es.iter().rev() {\n                if let HirKind::Anchor(hir::Anchor::EndText) = *e.kind() {\n                    if !lits.is_empty() {\n                        lits.cut();\n                        break;\n                    }\n                    lits.add(Literal::empty());\n                    continue;\n                }\n                let mut lits2 = lits.to_empty();\n                suffixes(e, &mut lits2);\n                if !lits.cross_product(&lits2) || !lits2.any_complete() {\n                    // If this expression couldn't yield any literal that\n                    // could be extended, then we need to quit. Since we're\n                    // short-circuiting, we also need to freeze every member.\n                    lits.cut();\n                    break;\n                }\n            }\n        }\n        HirKind::Alternation(ref es) => {\n            alternate_literals(es, lits, suffixes);\n        }\n        _ => lits.cut(),\n    }\n}\n\nfn repeat_zero_or_one_literals<F: FnMut(&Hir, &mut Literals)>(\n    e: &Hir,\n    lits: &mut Literals,\n    mut f: F,\n) {\n    let (mut lits2, mut lits3) = (lits.clone(), lits.to_empty());\n    lits3.set_limit_size(lits.limit_size() / 2);\n    f(e, &mut lits3);\n\n    if lits3.is_empty() || !lits2.cross_product(&lits3) {\n        lits.cut();\n        return;\n    }\n    lits2.add(Literal::empty());\n    if !lits.union(lits2) {\n        lits.cut();\n    }\n}\n\nfn repeat_zero_or_more_literals<F: FnMut(&Hir, &mut Literals)>(\n    e: &Hir,\n    lits: &mut Literals,\n    mut f: F,\n) {\n    let (mut lits2, mut lits3) = (lits.clone(), lits.to_empty());\n    lits3.set_limit_size(lits.limit_size() / 2);\n    f(e, &mut lits3);\n\n    if lits3.is_empty() || !lits2.cross_product(&lits3) {\n        lits.cut();\n        return;\n    }\n    lits2.cut();\n    lits2.add(Literal::empty());\n    if !lits.union(lits2) {\n        lits.cut();\n    }\n}\n\nfn repeat_one_or_more_literals<F: FnMut(&Hir, &mut Literals)>(\n    e: &Hir,\n    lits: &mut Literals,\n    mut f: F,\n) {\n    f(e, lits);\n    lits.cut();\n}\n\nfn repeat_range_literals<F: FnMut(&Hir, &mut Literals)>(\n    e: &Hir,\n    min: u32,\n    max: Option<u32>,\n    greedy: bool,\n    lits: &mut Literals,\n    mut f: F,\n) {\n    if min == 0 {\n        // This is a bit conservative. If `max` is set, then we could\n        // treat this as a finite set of alternations. For now, we\n        // just treat it as `e*`.\n        f(\n            &Hir::repetition(hir::Repetition {\n                kind: hir::RepetitionKind::ZeroOrMore,\n                greedy: greedy,\n                hir: Box::new(e.clone()),\n            }),\n            lits,\n        );\n    } else {\n        if min > 0 {\n            let n = cmp::min(lits.limit_size, min as usize);\n            let es = iter::repeat(e.clone()).take(n).collect();\n            f(&Hir::concat(es), lits);\n            if n < min as usize || lits.contains_empty() {\n                lits.cut();\n            }\n        }\n        if max.map_or(true, |max| min < max) {\n            lits.cut();\n        }\n    }\n}\n\nfn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n    es: &[Hir],\n    lits: &mut Literals,\n    mut f: F,\n) {\n    let mut lits2 = lits.to_empty();\n    for e in es {\n        let mut lits3 = lits.to_empty();\n        lits3.set_limit_size(lits.limit_size() / 5);\n        f(e, &mut lits3);\n        if lits3.is_empty() || !lits2.union(lits3) {\n            // If we couldn't find suffixes for *any* of the\n            // alternates, then the entire alternation has to be thrown\n            // away and any existing members must be frozen. Similarly,\n            // if the union couldn't complete, stop and freeze.\n            lits.cut();\n            return;\n        }\n    }\n    if !lits.cross_product(&lits2) {\n        lits.cut();\n    }\n}\n\nimpl fmt::Debug for Literals {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"Literals\")\n            .field(\"lits\", &self.lits)\n            .field(\"limit_size\", &self.limit_size)\n            .field(\"limit_class\", &self.limit_class)\n            .finish()\n    }\n}\n\nimpl Literal {\n    /// Returns a new complete literal with the bytes given.\n    pub fn new(bytes: Vec<u8>) -> Literal {\n        Literal { v: bytes, cut: false }\n    }\n\n    /// Returns a new complete empty literal.\n    pub fn empty() -> Literal {\n        Literal { v: vec![], cut: false }\n    }\n\n    /// Returns true if this literal was \"cut.\"\n    pub fn is_cut(&self) -> bool {\n        self.cut\n    }\n\n    /// Cuts this literal.\n    pub fn cut(&mut self) {\n        self.cut = true;\n    }\n}\n\nimpl PartialEq for Literal {\n    fn eq(&self, other: &Literal) -> bool {\n        self.v == other.v\n    }\n}\n\nimpl PartialOrd for Literal {\n    fn partial_cmp(&self, other: &Literal) -> Option<cmp::Ordering> {\n        self.v.partial_cmp(&other.v)\n    }\n}\n\nimpl fmt::Debug for Literal {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        if self.is_cut() {\n            write!(f, \"Cut({})\", escape_unicode(&self.v))\n        } else {\n            write!(f, \"Complete({})\", escape_unicode(&self.v))\n        }\n    }\n}\n\nimpl AsRef<[u8]> for Literal {\n    fn as_ref(&self) -> &[u8] {\n        &self.v\n    }\n}\n\nimpl ops::Deref for Literal {\n    type Target = Vec<u8>;\n    fn deref(&self) -> &Vec<u8> {\n        &self.v\n    }\n}\n\nimpl ops::DerefMut for Literal {\n    fn deref_mut(&mut self) -> &mut Vec<u8> {\n        &mut self.v\n    }\n}\n\nfn position(needle: &[u8], mut haystack: &[u8]) -> Option<usize> {\n    let mut i = 0;\n    while haystack.len() >= needle.len() {\n        if needle == &haystack[..needle.len()] {\n            return Some(i);\n        }\n        i += 1;\n        haystack = &haystack[1..];\n    }\n    None\n}\n\nfn escape_unicode(bytes: &[u8]) -> String {\n    let show = match ::std::str::from_utf8(bytes) {\n        Ok(v) => v.to_string(),\n        Err(_) => escape_bytes(bytes),\n    };\n    let mut space_escaped = String::new();\n    for c in show.chars() {\n        if c.is_whitespace() {\n            let escaped = if c as u32 <= 0x7F {\n                escape_byte(c as u8)\n            } else {\n                if c as u32 <= 0xFFFF {\n                    format!(r\"\\u{{{:04x}}}\", c as u32)\n                } else {\n                    format!(r\"\\U{{{:08x}}}\", c as u32)\n                }\n            };\n            space_escaped.push_str(&escaped);\n        } else {\n            space_escaped.push(c);\n        }\n    }\n    space_escaped\n}\n\nfn escape_bytes(bytes: &[u8]) -> String {\n    let mut s = String::new();\n    for &b in bytes {\n        s.push_str(&escape_byte(b));\n    }\n    s\n}\n\nfn escape_byte(byte: u8) -> String {\n    use std::ascii::escape_default;\n\n    let escaped: Vec<u8> = escape_default(byte).collect();\n    String::from_utf8_lossy(&escaped).into_owned()\n}\n\nfn cls_char_count(cls: &hir::ClassUnicode) -> usize {\n    cls.iter().map(|&r| 1 + (r.end as u32) - (r.start as u32)).sum::<u32>()\n        as usize\n}\n\nfn cls_byte_count(cls: &hir::ClassBytes) -> usize {\n    cls.iter().map(|&r| 1 + (r.end as u32) - (r.start as u32)).sum::<u32>()\n        as usize\n}\n\n#[cfg(test)]\nmod tests {\n    use std::fmt;\n\n    use super::{escape_bytes, Literal, Literals};\n    use hir::Hir;\n    use ParserBuilder;\n\n    // To make test failures easier to read.\n    #[derive(Debug, Eq, PartialEq)]\n    struct Bytes(Vec<ULiteral>);\n    #[derive(Debug, Eq, PartialEq)]\n    struct Unicode(Vec<ULiteral>);\n\n    fn escape_lits(blits: &[Literal]) -> Vec<ULiteral> {\n        let mut ulits = vec![];\n        for blit in blits {\n            ulits\n                .push(ULiteral { v: escape_bytes(&blit), cut: blit.is_cut() });\n        }\n        ulits\n    }\n\n    fn create_lits<I: IntoIterator<Item = Literal>>(it: I) -> Literals {\n        Literals {\n            lits: it.into_iter().collect(),\n            limit_size: 0,\n            limit_class: 0,\n        }\n    }\n\n    // Needs to be pub for 1.3?\n    #[derive(Clone, Eq, PartialEq)]\n    pub struct ULiteral {\n        v: String,\n        cut: bool,\n    }\n\n    impl ULiteral {\n        fn is_cut(&self) -> bool {\n            self.cut\n        }\n    }\n\n    impl fmt::Debug for ULiteral {\n        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n            if self.is_cut() {\n                write!(f, \"Cut({})\", self.v)\n            } else {\n                write!(f, \"Complete({})\", self.v)\n            }\n        }\n    }\n\n    impl PartialEq<Literal> for ULiteral {\n        fn eq(&self, other: &Literal) -> bool {\n            self.v.as_bytes() == &*other.v && self.is_cut() == other.is_cut()\n        }\n    }\n\n    impl PartialEq<ULiteral> for Literal {\n        fn eq(&self, other: &ULiteral) -> bool {\n            &*self.v == other.v.as_bytes() && self.is_cut() == other.is_cut()\n        }\n    }\n\n    #[allow(non_snake_case)]\n    fn C(s: &'static str) -> ULiteral {\n        ULiteral { v: s.to_owned(), cut: true }\n    }\n    #[allow(non_snake_case)]\n    fn M(s: &'static str) -> ULiteral {\n        ULiteral { v: s.to_owned(), cut: false }\n    }\n\n    fn prefixes(lits: &mut Literals, expr: &Hir) {\n        lits.union_prefixes(expr);\n    }\n\n    fn suffixes(lits: &mut Literals, expr: &Hir) {\n        lits.union_suffixes(expr);\n    }\n\n    macro_rules! assert_lit_eq {\n        ($which:ident, $got_lits:expr, $($expected_lit:expr),*) => {{\n            let expected: Vec<ULiteral> = vec![$($expected_lit),*];\n            let lits = $got_lits;\n            assert_eq!(\n                $which(expected.clone()),\n                $which(escape_lits(lits.literals())));\n            assert_eq!(\n                !expected.is_empty() && expected.iter().all(|l| !l.is_cut()),\n                lits.all_complete());\n            assert_eq!(\n                expected.iter().any(|l| !l.is_cut()),\n                lits.any_complete());\n        }};\n    }\n\n    macro_rules! test_lit {\n        ($name:ident, $which:ident, $re:expr) => {\n            test_lit!($name, $which, $re,);\n        };\n        ($name:ident, $which:ident, $re:expr, $($lit:expr),*) => {\n            #[test]\n            fn $name() {\n                let expr = ParserBuilder::new()\n                    .build()\n                    .parse($re)\n                    .unwrap();\n                let lits = Literals::$which(&expr);\n                assert_lit_eq!(Unicode, lits, $($lit),*);\n\n                let expr = ParserBuilder::new()\n                    .allow_invalid_utf8(true)\n                    .unicode(false)\n                    .build()\n                    .parse($re)\n                    .unwrap();\n                let lits = Literals::$which(&expr);\n                assert_lit_eq!(Bytes, lits, $($lit),*);\n            }\n        };\n    }\n\n    // ************************************************************************\n    // Tests for prefix literal extraction.\n    // ************************************************************************\n\n    // Elementary tests.\n    test_lit!(pfx_one_lit1, prefixes, \"a\", M(\"a\"));\n    test_lit!(pfx_one_lit2, prefixes, \"abc\", M(\"abc\"));\n    test_lit!(pfx_one_lit3, prefixes, \"(?u)☃\", M(\"\\\\xe2\\\\x98\\\\x83\"));\n    #[cfg(feature = \"unicode-case\")]\n    test_lit!(pfx_one_lit4, prefixes, \"(?ui)☃\", M(\"\\\\xe2\\\\x98\\\\x83\"));\n    test_lit!(pfx_class1, prefixes, \"[1-4]\", M(\"1\"), M(\"2\"), M(\"3\"), M(\"4\"));\n    test_lit!(\n        pfx_class2,\n        prefixes,\n        \"(?u)[☃Ⅰ]\",\n        M(\"\\\\xe2\\\\x85\\\\xa0\"),\n        M(\"\\\\xe2\\\\x98\\\\x83\")\n    );\n    #[cfg(feature = \"unicode-case\")]\n    test_lit!(\n        pfx_class3,\n        prefixes,\n        \"(?ui)[☃Ⅰ]\",\n        M(\"\\\\xe2\\\\x85\\\\xa0\"),\n        M(\"\\\\xe2\\\\x85\\\\xb0\"),\n        M(\"\\\\xe2\\\\x98\\\\x83\")\n    );\n    test_lit!(pfx_one_lit_casei1, prefixes, \"(?i-u)a\", M(\"A\"), M(\"a\"));\n    test_lit!(\n        pfx_one_lit_casei2,\n        prefixes,\n        \"(?i-u)abc\",\n        M(\"ABC\"),\n        M(\"aBC\"),\n        M(\"AbC\"),\n        M(\"abC\"),\n        M(\"ABc\"),\n        M(\"aBc\"),\n        M(\"Abc\"),\n        M(\"abc\")\n    );\n    test_lit!(pfx_group1, prefixes, \"(a)\", M(\"a\"));\n    test_lit!(pfx_rep_zero_or_one1, prefixes, \"a?\");\n    test_lit!(pfx_rep_zero_or_one2, prefixes, \"(?:abc)?\");\n    test_lit!(pfx_rep_zero_or_more1, prefixes, \"a*\");\n    test_lit!(pfx_rep_zero_or_more2, prefixes, \"(?:abc)*\");\n    test_lit!(pfx_rep_one_or_more1, prefixes, \"a+\", C(\"a\"));\n    test_lit!(pfx_rep_one_or_more2, prefixes, \"(?:abc)+\", C(\"abc\"));\n    test_lit!(pfx_rep_nested_one_or_more, prefixes, \"(?:a+)+\", C(\"a\"));\n    test_lit!(pfx_rep_range1, prefixes, \"a{0}\");\n    test_lit!(pfx_rep_range2, prefixes, \"a{0,}\");\n    test_lit!(pfx_rep_range3, prefixes, \"a{0,1}\");\n    test_lit!(pfx_rep_range4, prefixes, \"a{1}\", M(\"a\"));\n    test_lit!(pfx_rep_range5, prefixes, \"a{2}\", M(\"aa\"));\n    test_lit!(pfx_rep_range6, prefixes, \"a{1,2}\", C(\"a\"));\n    test_lit!(pfx_rep_range7, prefixes, \"a{2,3}\", C(\"aa\"));\n\n    // Test regexes with concatenations.\n    test_lit!(pfx_cat1, prefixes, \"(?:a)(?:b)\", M(\"ab\"));\n    test_lit!(pfx_cat2, prefixes, \"[ab]z\", M(\"az\"), M(\"bz\"));\n    test_lit!(\n        pfx_cat3,\n        prefixes,\n        \"(?i-u)[ab]z\",\n        M(\"AZ\"),\n        M(\"BZ\"),\n        M(\"aZ\"),\n        M(\"bZ\"),\n        M(\"Az\"),\n        M(\"Bz\"),\n        M(\"az\"),\n        M(\"bz\")\n    );\n    test_lit!(\n        pfx_cat4,\n        prefixes,\n        \"[ab][yz]\",\n        M(\"ay\"),\n        M(\"by\"),\n        M(\"az\"),\n        M(\"bz\")\n    );\n    test_lit!(pfx_cat5, prefixes, \"a*b\", C(\"a\"), M(\"b\"));\n    test_lit!(pfx_cat6, prefixes, \"a*b*c\", C(\"a\"), C(\"b\"), M(\"c\"));\n    test_lit!(pfx_cat7, prefixes, \"a*b*c+\", C(\"a\"), C(\"b\"), C(\"c\"));\n    test_lit!(pfx_cat8, prefixes, \"a*b+c\", C(\"a\"), C(\"b\"));\n    test_lit!(pfx_cat9, prefixes, \"a*b+c*\", C(\"a\"), C(\"b\"));\n    test_lit!(pfx_cat10, prefixes, \"ab*\", C(\"ab\"), M(\"a\"));\n    test_lit!(pfx_cat11, prefixes, \"ab*c\", C(\"ab\"), M(\"ac\"));\n    test_lit!(pfx_cat12, prefixes, \"ab+\", C(\"ab\"));\n    test_lit!(pfx_cat13, prefixes, \"ab+c\", C(\"ab\"));\n    test_lit!(pfx_cat14, prefixes, \"a^\", C(\"a\"));\n    test_lit!(pfx_cat15, prefixes, \"$a\");\n    test_lit!(pfx_cat16, prefixes, r\"ab*c\", C(\"ab\"), M(\"ac\"));\n    test_lit!(pfx_cat17, prefixes, r\"ab+c\", C(\"ab\"));\n    test_lit!(pfx_cat18, prefixes, r\"z*azb\", C(\"z\"), M(\"azb\"));\n    test_lit!(pfx_cat19, prefixes, \"a.z\", C(\"a\"));\n\n    // Test regexes with alternations.\n    test_lit!(pfx_alt1, prefixes, \"a|b\", M(\"a\"), M(\"b\"));\n    test_lit!(pfx_alt2, prefixes, \"[1-3]|b\", M(\"1\"), M(\"2\"), M(\"3\"), M(\"b\"));\n    test_lit!(pfx_alt3, prefixes, \"y(?:a|b)z\", M(\"yaz\"), M(\"ybz\"));\n    test_lit!(pfx_alt4, prefixes, \"a|b*\");\n    test_lit!(pfx_alt5, prefixes, \"a|b+\", M(\"a\"), C(\"b\"));\n    test_lit!(pfx_alt6, prefixes, \"a|(?:b|c*)\");\n    test_lit!(\n        pfx_alt7,\n        prefixes,\n        \"(a|b)*c|(a|ab)*c\",\n        C(\"a\"),\n        C(\"b\"),\n        M(\"c\"),\n        C(\"a\"),\n        C(\"ab\"),\n        M(\"c\")\n    );\n    test_lit!(pfx_alt8, prefixes, \"a*b|c\", C(\"a\"), M(\"b\"), M(\"c\"));\n\n    // Test regexes with empty assertions.\n    test_lit!(pfx_empty1, prefixes, \"^a\", M(\"a\"));\n    test_lit!(pfx_empty2, prefixes, \"a${2}\", C(\"a\"));\n    test_lit!(pfx_empty3, prefixes, \"^abc\", M(\"abc\"));\n    test_lit!(pfx_empty4, prefixes, \"(?:^abc)|(?:^z)\", M(\"abc\"), M(\"z\"));\n\n    // Make sure some curious regexes have no prefixes.\n    test_lit!(pfx_nothing1, prefixes, \".\");\n    test_lit!(pfx_nothing2, prefixes, \"(?s).\");\n    test_lit!(pfx_nothing3, prefixes, \"^\");\n    test_lit!(pfx_nothing4, prefixes, \"$\");\n    test_lit!(pfx_nothing6, prefixes, \"(?m)$\");\n    test_lit!(pfx_nothing7, prefixes, r\"\\b\");\n    test_lit!(pfx_nothing8, prefixes, r\"\\B\");\n\n    // Test a few regexes that defeat any prefix literal detection.\n    test_lit!(pfx_defeated1, prefixes, \".a\");\n    test_lit!(pfx_defeated2, prefixes, \"(?s).a\");\n    test_lit!(pfx_defeated3, prefixes, \"a*b*c*\");\n    test_lit!(pfx_defeated4, prefixes, \"a|.\");\n    test_lit!(pfx_defeated5, prefixes, \".|a\");\n    test_lit!(pfx_defeated6, prefixes, \"a|^\");\n    test_lit!(pfx_defeated7, prefixes, \".(?:a(?:b)(?:c))\");\n    test_lit!(pfx_defeated8, prefixes, \"$a\");\n    test_lit!(pfx_defeated9, prefixes, \"(?m)$a\");\n    test_lit!(pfx_defeated10, prefixes, r\"\\ba\");\n    test_lit!(pfx_defeated11, prefixes, r\"\\Ba\");\n    test_lit!(pfx_defeated12, prefixes, \"^*a\");\n    test_lit!(pfx_defeated13, prefixes, \"^+a\");\n\n    test_lit!(\n        pfx_crazy1,\n        prefixes,\n        r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\",\n        C(\"Mo\\\\'am\"),\n        C(\"Mu\\\\'am\"),\n        C(\"Moam\"),\n        C(\"Muam\")\n    );\n\n    // ************************************************************************\n    // Tests for quiting prefix literal search.\n    // ************************************************************************\n\n    macro_rules! test_exhausted {\n        ($name:ident, $which:ident, $re:expr) => {\n            test_exhausted!($name, $which, $re,);\n        };\n        ($name:ident, $which:ident, $re:expr, $($lit:expr),*) => {\n            #[test]\n            fn $name() {\n                let expr = ParserBuilder::new()\n                    .build()\n                    .parse($re)\n                    .unwrap();\n                let mut lits = Literals::empty();\n                lits.set_limit_size(20).set_limit_class(10);\n                $which(&mut lits, &expr);\n                assert_lit_eq!(Unicode, lits, $($lit),*);\n\n                let expr = ParserBuilder::new()\n                    .allow_invalid_utf8(true)\n                    .unicode(false)\n                    .build()\n                    .parse($re)\n                    .unwrap();\n                let mut lits = Literals::empty();\n                lits.set_limit_size(20).set_limit_class(10);\n                $which(&mut lits, &expr);\n                assert_lit_eq!(Bytes, lits, $($lit),*);\n            }\n        };\n    }\n\n    // These test use a much lower limit than the default so that we can\n    // write test cases of reasonable size.\n    test_exhausted!(pfx_exhausted1, prefixes, \"[a-z]\");\n    test_exhausted!(pfx_exhausted2, prefixes, \"[a-z]*A\");\n    test_exhausted!(pfx_exhausted3, prefixes, \"A[a-z]Z\", C(\"A\"));\n    test_exhausted!(\n        pfx_exhausted4,\n        prefixes,\n        \"(?i-u)foobar\",\n        C(\"FO\"),\n        C(\"fO\"),\n        C(\"Fo\"),\n        C(\"fo\")\n    );\n    test_exhausted!(\n        pfx_exhausted5,\n        prefixes,\n        \"(?:ab){100}\",\n        C(\"abababababababababab\")\n    );\n    test_exhausted!(\n        pfx_exhausted6,\n        prefixes,\n        \"(?:(?:ab){100})*cd\",\n        C(\"ababababab\"),\n        M(\"cd\")\n    );\n    test_exhausted!(\n        pfx_exhausted7,\n        prefixes,\n        \"z(?:(?:ab){100})*cd\",\n        C(\"zababababab\"),\n        M(\"zcd\")\n    );\n    test_exhausted!(\n        pfx_exhausted8,\n        prefixes,\n        \"aaaaaaaaaaaaaaaaaaaaz\",\n        C(\"aaaaaaaaaaaaaaaaaaaa\")\n    );\n\n    // ************************************************************************\n    // Tests for suffix literal extraction.\n    // ************************************************************************\n\n    // Elementary tests.\n    test_lit!(sfx_one_lit1, suffixes, \"a\", M(\"a\"));\n    test_lit!(sfx_one_lit2, suffixes, \"abc\", M(\"abc\"));\n    test_lit!(sfx_one_lit3, suffixes, \"(?u)☃\", M(\"\\\\xe2\\\\x98\\\\x83\"));\n    #[cfg(feature = \"unicode-case\")]\n    test_lit!(sfx_one_lit4, suffixes, \"(?ui)☃\", M(\"\\\\xe2\\\\x98\\\\x83\"));\n    test_lit!(sfx_class1, suffixes, \"[1-4]\", M(\"1\"), M(\"2\"), M(\"3\"), M(\"4\"));\n    test_lit!(\n        sfx_class2,\n        suffixes,\n        \"(?u)[☃Ⅰ]\",\n        M(\"\\\\xe2\\\\x85\\\\xa0\"),\n        M(\"\\\\xe2\\\\x98\\\\x83\")\n    );\n    #[cfg(feature = \"unicode-case\")]\n    test_lit!(\n        sfx_class3,\n        suffixes,\n        \"(?ui)[☃Ⅰ]\",\n        M(\"\\\\xe2\\\\x85\\\\xa0\"),\n        M(\"\\\\xe2\\\\x85\\\\xb0\"),\n        M(\"\\\\xe2\\\\x98\\\\x83\")\n    );\n    test_lit!(sfx_one_lit_casei1, suffixes, \"(?i-u)a\", M(\"A\"), M(\"a\"));\n    test_lit!(\n        sfx_one_lit_casei2,\n        suffixes,\n        \"(?i-u)abc\",\n        M(\"ABC\"),\n        M(\"ABc\"),\n        M(\"AbC\"),\n        M(\"Abc\"),\n        M(\"aBC\"),\n        M(\"aBc\"),\n        M(\"abC\"),\n        M(\"abc\")\n    );\n    test_lit!(sfx_group1, suffixes, \"(a)\", M(\"a\"));\n    test_lit!(sfx_rep_zero_or_one1, suffixes, \"a?\");\n    test_lit!(sfx_rep_zero_or_one2, suffixes, \"(?:abc)?\");\n    test_lit!(sfx_rep_zero_or_more1, suffixes, \"a*\");\n    test_lit!(sfx_rep_zero_or_more2, suffixes, \"(?:abc)*\");\n    test_lit!(sfx_rep_one_or_more1, suffixes, \"a+\", C(\"a\"));\n    test_lit!(sfx_rep_one_or_more2, suffixes, \"(?:abc)+\", C(\"abc\"));\n    test_lit!(sfx_rep_nested_one_or_more, suffixes, \"(?:a+)+\", C(\"a\"));\n    test_lit!(sfx_rep_range1, suffixes, \"a{0}\");\n    test_lit!(sfx_rep_range2, suffixes, \"a{0,}\");\n    test_lit!(sfx_rep_range3, suffixes, \"a{0,1}\");\n    test_lit!(sfx_rep_range4, suffixes, \"a{1}\", M(\"a\"));\n    test_lit!(sfx_rep_range5, suffixes, \"a{2}\", M(\"aa\"));\n    test_lit!(sfx_rep_range6, suffixes, \"a{1,2}\", C(\"a\"));\n    test_lit!(sfx_rep_range7, suffixes, \"a{2,3}\", C(\"aa\"));\n\n    // Test regexes with concatenations.\n    test_lit!(sfx_cat1, suffixes, \"(?:a)(?:b)\", M(\"ab\"));\n    test_lit!(sfx_cat2, suffixes, \"[ab]z\", M(\"az\"), M(\"bz\"));\n    test_lit!(\n        sfx_cat3,\n        suffixes,\n        \"(?i-u)[ab]z\",\n        M(\"AZ\"),\n        M(\"Az\"),\n        M(\"BZ\"),\n        M(\"Bz\"),\n        M(\"aZ\"),\n        M(\"az\"),\n        M(\"bZ\"),\n        M(\"bz\")\n    );\n    test_lit!(\n        sfx_cat4,\n        suffixes,\n        \"[ab][yz]\",\n        M(\"ay\"),\n        M(\"az\"),\n        M(\"by\"),\n        M(\"bz\")\n    );\n    test_lit!(sfx_cat5, suffixes, \"a*b\", C(\"ab\"), M(\"b\"));\n    test_lit!(sfx_cat6, suffixes, \"a*b*c\", C(\"bc\"), C(\"ac\"), M(\"c\"));\n    test_lit!(sfx_cat7, suffixes, \"a*b*c+\", C(\"c\"));\n    test_lit!(sfx_cat8, suffixes, \"a*b+c\", C(\"bc\"));\n    test_lit!(sfx_cat9, suffixes, \"a*b+c*\", C(\"c\"), C(\"b\"));\n    test_lit!(sfx_cat10, suffixes, \"ab*\", C(\"b\"), M(\"a\"));\n    test_lit!(sfx_cat11, suffixes, \"ab*c\", C(\"bc\"), M(\"ac\"));\n    test_lit!(sfx_cat12, suffixes, \"ab+\", C(\"b\"));\n    test_lit!(sfx_cat13, suffixes, \"ab+c\", C(\"bc\"));\n    test_lit!(sfx_cat14, suffixes, \"a^\");\n    test_lit!(sfx_cat15, suffixes, \"$a\", C(\"a\"));\n    test_lit!(sfx_cat16, suffixes, r\"ab*c\", C(\"bc\"), M(\"ac\"));\n    test_lit!(sfx_cat17, suffixes, r\"ab+c\", C(\"bc\"));\n    test_lit!(sfx_cat18, suffixes, r\"z*azb\", C(\"zazb\"), M(\"azb\"));\n    test_lit!(sfx_cat19, suffixes, \"a.z\", C(\"z\"));\n\n    // Test regexes with alternations.\n    test_lit!(sfx_alt1, suffixes, \"a|b\", M(\"a\"), M(\"b\"));\n    test_lit!(sfx_alt2, suffixes, \"[1-3]|b\", M(\"1\"), M(\"2\"), M(\"3\"), M(\"b\"));\n    test_lit!(sfx_alt3, suffixes, \"y(?:a|b)z\", M(\"yaz\"), M(\"ybz\"));\n    test_lit!(sfx_alt4, suffixes, \"a|b*\");\n    test_lit!(sfx_alt5, suffixes, \"a|b+\", M(\"a\"), C(\"b\"));\n    test_lit!(sfx_alt6, suffixes, \"a|(?:b|c*)\");\n    test_lit!(\n        sfx_alt7,\n        suffixes,\n        \"(a|b)*c|(a|ab)*c\",\n        C(\"ac\"),\n        C(\"bc\"),\n        M(\"c\"),\n        C(\"ac\"),\n        C(\"abc\"),\n        M(\"c\")\n    );\n    test_lit!(sfx_alt8, suffixes, \"a*b|c\", C(\"ab\"), M(\"b\"), M(\"c\"));\n\n    // Test regexes with empty assertions.\n    test_lit!(sfx_empty1, suffixes, \"a$\", M(\"a\"));\n    test_lit!(sfx_empty2, suffixes, \"${2}a\", C(\"a\"));\n\n    // Make sure some curious regexes have no suffixes.\n    test_lit!(sfx_nothing1, suffixes, \".\");\n    test_lit!(sfx_nothing2, suffixes, \"(?s).\");\n    test_lit!(sfx_nothing3, suffixes, \"^\");\n    test_lit!(sfx_nothing4, suffixes, \"$\");\n    test_lit!(sfx_nothing6, suffixes, \"(?m)$\");\n    test_lit!(sfx_nothing7, suffixes, r\"\\b\");\n    test_lit!(sfx_nothing8, suffixes, r\"\\B\");\n\n    // Test a few regexes that defeat any suffix literal detection.\n    test_lit!(sfx_defeated1, suffixes, \"a.\");\n    test_lit!(sfx_defeated2, suffixes, \"(?s)a.\");\n    test_lit!(sfx_defeated3, suffixes, \"a*b*c*\");\n    test_lit!(sfx_defeated4, suffixes, \"a|.\");\n    test_lit!(sfx_defeated5, suffixes, \".|a\");\n    test_lit!(sfx_defeated6, suffixes, \"a|^\");\n    test_lit!(sfx_defeated7, suffixes, \"(?:a(?:b)(?:c)).\");\n    test_lit!(sfx_defeated8, suffixes, \"a^\");\n    test_lit!(sfx_defeated9, suffixes, \"(?m)a$\");\n    test_lit!(sfx_defeated10, suffixes, r\"a\\b\");\n    test_lit!(sfx_defeated11, suffixes, r\"a\\B\");\n    test_lit!(sfx_defeated12, suffixes, \"a^*\");\n    test_lit!(sfx_defeated13, suffixes, \"a^+\");\n\n    // These test use a much lower limit than the default so that we can\n    // write test cases of reasonable size.\n    test_exhausted!(sfx_exhausted1, suffixes, \"[a-z]\");\n    test_exhausted!(sfx_exhausted2, suffixes, \"A[a-z]*\");\n    test_exhausted!(sfx_exhausted3, suffixes, \"A[a-z]Z\", C(\"Z\"));\n    test_exhausted!(\n        sfx_exhausted4,\n        suffixes,\n        \"(?i-u)foobar\",\n        C(\"AR\"),\n        C(\"Ar\"),\n        C(\"aR\"),\n        C(\"ar\")\n    );\n    test_exhausted!(\n        sfx_exhausted5,\n        suffixes,\n        \"(?:ab){100}\",\n        C(\"abababababababababab\")\n    );\n    test_exhausted!(\n        sfx_exhausted6,\n        suffixes,\n        \"cd(?:(?:ab){100})*\",\n        C(\"ababababab\"),\n        M(\"cd\")\n    );\n    test_exhausted!(\n        sfx_exhausted7,\n        suffixes,\n        \"cd(?:(?:ab){100})*z\",\n        C(\"abababababz\"),\n        M(\"cdz\")\n    );\n    test_exhausted!(\n        sfx_exhausted8,\n        suffixes,\n        \"zaaaaaaaaaaaaaaaaaaaa\",\n        C(\"aaaaaaaaaaaaaaaaaaaa\")\n    );\n\n    // ************************************************************************\n    // Tests for generating unambiguous literal sets.\n    // ************************************************************************\n\n    macro_rules! test_unamb {\n        ($name:ident, $given:expr, $expected:expr) => {\n            #[test]\n            fn $name() {\n                let given: Vec<Literal> = $given\n                    .into_iter()\n                    .map(|ul| {\n                        let cut = ul.is_cut();\n                        Literal { v: ul.v.into_bytes(), cut: cut }\n                    })\n                    .collect();\n                let lits = create_lits(given);\n                let got = lits.unambiguous_prefixes();\n                assert_eq!($expected, escape_lits(got.literals()));\n            }\n        };\n    }\n\n    test_unamb!(unambiguous1, vec![M(\"z\"), M(\"azb\")], vec![C(\"a\"), C(\"z\")]);\n    test_unamb!(\n        unambiguous2,\n        vec![M(\"zaaaaaa\"), M(\"aa\")],\n        vec![C(\"aa\"), C(\"z\")]\n    );\n    test_unamb!(\n        unambiguous3,\n        vec![M(\"Sherlock\"), M(\"Watson\")],\n        vec![M(\"Sherlock\"), M(\"Watson\")]\n    );\n    test_unamb!(unambiguous4, vec![M(\"abc\"), M(\"bc\")], vec![C(\"a\"), C(\"bc\")]);\n    test_unamb!(unambiguous5, vec![M(\"bc\"), M(\"abc\")], vec![C(\"a\"), C(\"bc\")]);\n    test_unamb!(unambiguous6, vec![M(\"a\"), M(\"aa\")], vec![C(\"a\")]);\n    test_unamb!(unambiguous7, vec![M(\"aa\"), M(\"a\")], vec![C(\"a\")]);\n    test_unamb!(unambiguous8, vec![M(\"ab\"), M(\"a\")], vec![C(\"a\")]);\n    test_unamb!(\n        unambiguous9,\n        vec![M(\"ac\"), M(\"bc\"), M(\"c\"), M(\"ac\"), M(\"abc\"), M(\"c\")],\n        vec![C(\"a\"), C(\"b\"), C(\"c\")]\n    );\n    test_unamb!(\n        unambiguous10,\n        vec![M(\"Mo'\"), M(\"Mu'\"), M(\"Mo\"), M(\"Mu\")],\n        vec![C(\"Mo\"), C(\"Mu\")]\n    );\n    test_unamb!(\n        unambiguous11,\n        vec![M(\"zazb\"), M(\"azb\")],\n        vec![C(\"a\"), C(\"z\")]\n    );\n    test_unamb!(unambiguous12, vec![M(\"foo\"), C(\"foo\")], vec![C(\"foo\")]);\n    test_unamb!(\n        unambiguous13,\n        vec![M(\"ABCX\"), M(\"CDAX\"), M(\"BCX\")],\n        vec![C(\"A\"), C(\"BCX\"), C(\"CD\")]\n    );\n    test_unamb!(\n        unambiguous14,\n        vec![M(\"IMGX\"), M(\"MVIX\"), M(\"MGX\"), M(\"DSX\")],\n        vec![M(\"DSX\"), C(\"I\"), C(\"MGX\"), C(\"MV\")]\n    );\n    test_unamb!(\n        unambiguous15,\n        vec![M(\"IMG_\"), M(\"MG_\"), M(\"CIMG\")],\n        vec![C(\"C\"), C(\"I\"), C(\"MG_\")]\n    );\n\n    // ************************************************************************\n    // Tests for suffix trimming.\n    // ************************************************************************\n    macro_rules! test_trim {\n        ($name:ident, $trim:expr, $given:expr, $expected:expr) => {\n            #[test]\n            fn $name() {\n                let given: Vec<Literal> = $given\n                    .into_iter()\n                    .map(|ul| {\n                        let cut = ul.is_cut();\n                        Literal { v: ul.v.into_bytes(), cut: cut }\n                    })\n                    .collect();\n                let lits = create_lits(given);\n                let got = lits.trim_suffix($trim).unwrap();\n                assert_eq!($expected, escape_lits(got.literals()));\n            }\n        };\n    }\n\n    test_trim!(trim1, 1, vec![M(\"ab\"), M(\"yz\")], vec![C(\"a\"), C(\"y\")]);\n    test_trim!(trim2, 1, vec![M(\"abc\"), M(\"abd\")], vec![C(\"ab\")]);\n    test_trim!(trim3, 2, vec![M(\"abc\"), M(\"abd\")], vec![C(\"a\")]);\n    test_trim!(trim4, 2, vec![M(\"abc\"), M(\"ghij\")], vec![C(\"a\"), C(\"gh\")]);\n\n    // ************************************************************************\n    // Tests for longest common prefix.\n    // ************************************************************************\n\n    macro_rules! test_lcp {\n        ($name:ident, $given:expr, $expected:expr) => {\n            #[test]\n            fn $name() {\n                let given: Vec<Literal> = $given\n                    .into_iter()\n                    .map(|s: &str| Literal {\n                        v: s.to_owned().into_bytes(),\n                        cut: false,\n                    })\n                    .collect();\n                let lits = create_lits(given);\n                let got = lits.longest_common_prefix();\n                assert_eq!($expected, escape_bytes(got));\n            }\n        };\n    }\n\n    test_lcp!(lcp1, vec![\"a\"], \"a\");\n    test_lcp!(lcp2, vec![], \"\");\n    test_lcp!(lcp3, vec![\"a\", \"b\"], \"\");\n    test_lcp!(lcp4, vec![\"ab\", \"ab\"], \"ab\");\n    test_lcp!(lcp5, vec![\"ab\", \"a\"], \"a\");\n    test_lcp!(lcp6, vec![\"a\", \"ab\"], \"a\");\n    test_lcp!(lcp7, vec![\"ab\", \"b\"], \"\");\n    test_lcp!(lcp8, vec![\"b\", \"ab\"], \"\");\n    test_lcp!(lcp9, vec![\"foobar\", \"foobaz\"], \"fooba\");\n    test_lcp!(lcp10, vec![\"foobar\", \"foobaz\", \"a\"], \"\");\n    test_lcp!(lcp11, vec![\"a\", \"foobar\", \"foobaz\"], \"\");\n    test_lcp!(lcp12, vec![\"foo\", \"flub\", \"flab\", \"floo\"], \"f\");\n\n    // ************************************************************************\n    // Tests for longest common suffix.\n    // ************************************************************************\n\n    macro_rules! test_lcs {\n        ($name:ident, $given:expr, $expected:expr) => {\n            #[test]\n            fn $name() {\n                let given: Vec<Literal> = $given\n                    .into_iter()\n                    .map(|s: &str| Literal {\n                        v: s.to_owned().into_bytes(),\n                        cut: false,\n                    })\n                    .collect();\n                let lits = create_lits(given);\n                let got = lits.longest_common_suffix();\n                assert_eq!($expected, escape_bytes(got));\n            }\n        };\n    }\n\n    test_lcs!(lcs1, vec![\"a\"], \"a\");\n    test_lcs!(lcs2, vec![], \"\");\n    test_lcs!(lcs3, vec![\"a\", \"b\"], \"\");\n    test_lcs!(lcs4, vec![\"ab\", \"ab\"], \"ab\");\n    test_lcs!(lcs5, vec![\"ab\", \"a\"], \"\");\n    test_lcs!(lcs6, vec![\"a\", \"ab\"], \"\");\n    test_lcs!(lcs7, vec![\"ab\", \"b\"], \"b\");\n    test_lcs!(lcs8, vec![\"b\", \"ab\"], \"b\");\n    test_lcs!(lcs9, vec![\"barfoo\", \"bazfoo\"], \"foo\");\n    test_lcs!(lcs10, vec![\"barfoo\", \"bazfoo\", \"a\"], \"\");\n    test_lcs!(lcs11, vec![\"a\", \"barfoo\", \"bazfoo\"], \"\");\n    test_lcs!(lcs12, vec![\"flub\", \"bub\", \"boob\", \"dub\"], \"b\");\n}\n","traces":[{"line":53,"address":[6688480],"length":1,"stats":{"Line":34},"fn_name":"empty"},{"line":54,"address":[6688496],"length":1,"stats":{"Line":34},"fn_name":null},{"line":58,"address":[6688634,6688592],"length":1,"stats":{"Line":0},"fn_name":"prefixes"},{"line":59,"address":[6688604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[6688646],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[6688672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[6688778,6688736],"length":1,"stats":{"Line":0},"fn_name":"suffixes"},{"line":66,"address":[6688748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[6688790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[6688816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[6688880],"length":1,"stats":{"Line":8},"fn_name":"limit_size"},{"line":73,"address":[6688885],"length":1,"stats":{"Line":8},"fn_name":null},{"line":83,"address":[6688896],"length":1,"stats":{"Line":10},"fn_name":"set_limit_size"},{"line":84,"address":[6688909],"length":1,"stats":{"Line":10},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[6688928],"length":1,"stats":{"Line":0},"fn_name":"limit_class"},{"line":90,"address":[6688933],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[6688944],"length":1,"stats":{"Line":10},"fn_name":"set_limit_class"},{"line":104,"address":[6688957],"length":1,"stats":{"Line":10},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[6688976],"length":1,"stats":{"Line":17},"fn_name":"literals"},{"line":110,"address":[6688985],"length":1,"stats":{"Line":21},"fn_name":null},{"line":116,"address":[6689024],"length":1,"stats":{"Line":0},"fn_name":"min_len"},{"line":117,"address":[6689039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[6689477,6689048,6689146,6689482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[6689301],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[6689180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[6689306],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[6689128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[6689488],"length":1,"stats":{"Line":27},"fn_name":"all_complete"},{"line":130,"address":[6689578,6689497],"length":1,"stats":{"Line":76},"fn_name":null},{"line":134,"address":[6689648],"length":1,"stats":{"Line":25},"fn_name":"any_complete"},{"line":135,"address":[6689657],"length":1,"stats":{"Line":45},"fn_name":null},{"line":139,"address":[6689744],"length":1,"stats":{"Line":10},"fn_name":"contains_empty"},{"line":140,"address":[6689753],"length":1,"stats":{"Line":30},"fn_name":null},{"line":144,"address":[6689840],"length":1,"stats":{"Line":24},"fn_name":"is_empty"},{"line":145,"address":[6689849,6689930],"length":1,"stats":{"Line":71},"fn_name":null},{"line":149,"address":[6690043,6690000],"length":1,"stats":{"Line":10},"fn_name":"to_empty"},{"line":150,"address":[6690012],"length":1,"stats":{"Line":10},"fn_name":null},{"line":151,"address":[6690060],"length":1,"stats":{"Line":10},"fn_name":null},{"line":152,"address":[6690128],"length":1,"stats":{"Line":10},"fn_name":null},{"line":156,"address":[6690176],"length":1,"stats":{"Line":27},"fn_name":"longest_common_prefix"},{"line":157,"address":[6690199],"length":1,"stats":{"Line":27},"fn_name":null},{"line":158,"address":[6690256],"length":1,"stats":{"Line":27},"fn_name":null},{"line":160,"address":[6690237,6690315],"length":1,"stats":{"Line":22},"fn_name":null},{"line":161,"address":[6690345],"length":1,"stats":{"Line":11},"fn_name":null},{"line":162,"address":[6690370,6690760,6690545],"length":1,"stats":{"Line":19},"fn_name":null},{"line":163,"address":[6690736],"length":1,"stats":{"Line":8},"fn_name":null},{"line":164,"address":[6690579],"length":1,"stats":{"Line":8},"fn_name":null},{"line":165,"address":[6690592],"length":1,"stats":{"Line":24},"fn_name":null},{"line":168,"address":[6690770,6690526],"length":1,"stats":{"Line":20},"fn_name":null},{"line":172,"address":[6690864],"length":1,"stats":{"Line":27},"fn_name":"longest_common_suffix"},{"line":173,"address":[6690887],"length":1,"stats":{"Line":27},"fn_name":null},{"line":174,"address":[6690944],"length":1,"stats":{"Line":27},"fn_name":null},{"line":176,"address":[6690925,6691003],"length":1,"stats":{"Line":20},"fn_name":null},{"line":177,"address":[6691033],"length":1,"stats":{"Line":10},"fn_name":null},{"line":178,"address":[6691621,6691058,6691254],"length":1,"stats":{"Line":18},"fn_name":null},{"line":179,"address":[6691597],"length":1,"stats":{"Line":8},"fn_name":null},{"line":180,"address":[6691288],"length":1,"stats":{"Line":8},"fn_name":null},{"line":181,"address":[6691304,6691503],"length":1,"stats":{"Line":16},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[6691435],"length":1,"stats":{"Line":8},"fn_name":null},{"line":184,"address":[6882158,6882144],"length":1,"stats":{"Line":16},"fn_name":"{{closure}}"},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[6691232,6691634,6691832,6691802],"length":1,"stats":{"Line":20},"fn_name":null},{"line":199,"address":[6691840,6691933],"length":1,"stats":{"Line":0},"fn_name":"trim_suffix"},{"line":200,"address":[6691948,6691866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[6692074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[6692042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[6692097,6692771,6692182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[6692496,6692560,6693030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[6692624],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[6692669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[6692688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[6692776,6692528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[6692797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[6692816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[6693072,6693159],"length":1,"stats":{"Line":0},"fn_name":"unambiguous_prefixes"},{"line":225,"address":[6693090,6693181],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[6693238,6693262],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[6693280,6693195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[6693370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[6693418,6693465,6693397,6693608,6695399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[6693620,6693555],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[6693652,6695603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[6693664,6693626],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[6693705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[6693772],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[6693670,6693947,6695381,6693785],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[6693981],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[6694097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[6694055,6694109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[6694142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[6694204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[6694224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[6694115,6694229,6694887,6695325],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[6694361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[6694635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[6694662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[6694693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[6694747],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[6694766],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[6694833],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[6694331,6694892],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[6695091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[6695131],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[6695146],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[6695191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[6695210],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[6695277],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[6695327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[6695386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[6693877],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[6695404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[6695423],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[6695473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[6695500],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[6695892,6695856],"length":1,"stats":{"Line":0},"fn_name":"unambiguous_suffixes"},{"line":293,"address":[6695868],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[6695904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[6695920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[6695954],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[6695975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[6696064,6696137],"length":1,"stats":{"Line":10},"fn_name":"union_prefixes"},{"line":310,"address":[6696087],"length":1,"stats":{"Line":10},"fn_name":null},{"line":311,"address":[6696162],"length":1,"stats":{"Line":10},"fn_name":null},{"line":312,"address":[6696169,6696285],"length":1,"stats":{"Line":20},"fn_name":null},{"line":324,"address":[6696553,6696480],"length":1,"stats":{"Line":10},"fn_name":"union_suffixes"},{"line":325,"address":[6696503],"length":1,"stats":{"Line":10},"fn_name":null},{"line":326,"address":[6696578],"length":1,"stats":{"Line":27},"fn_name":null},{"line":327,"address":[6696585],"length":1,"stats":{"Line":10},"fn_name":null},{"line":328,"address":[6696601,6696717],"length":1,"stats":{"Line":37},"fn_name":null},{"line":336,"address":[6696912,6696959],"length":1,"stats":{"Line":10},"fn_name":"union"},{"line":337,"address":[6696927,6697296,6696979],"length":1,"stats":{"Line":20},"fn_name":null},{"line":338,"address":[6697057],"length":1,"stats":{"Line":8},"fn_name":null},{"line":340,"address":[6697037,6697099,6697198],"length":1,"stats":{"Line":20},"fn_name":null},{"line":341,"address":[6697158],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[6697105],"length":1,"stats":{"Line":10},"fn_name":null},{"line":345,"address":[6697202],"length":1,"stats":{"Line":10},"fn_name":null},{"line":355,"address":[6697328,6697401],"length":1,"stats":{"Line":25},"fn_name":"cross_product"},{"line":356,"address":[6697351,6697423],"length":1,"stats":{"Line":50},"fn_name":null},{"line":357,"address":[6697452],"length":1,"stats":{"Line":25},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[6697480,6697785,6698155,6697437],"length":1,"stats":{"Line":38},"fn_name":null},{"line":362,"address":[6697609],"length":1,"stats":{"Line":10},"fn_name":null},{"line":363,"address":[6697915,6697646,6697790],"length":1,"stats":{"Line":20},"fn_name":null},{"line":364,"address":[6699812,6697824],"length":1,"stats":{"Line":10},"fn_name":null},{"line":367,"address":[6697936,6697571],"length":1,"stats":{"Line":24},"fn_name":null},{"line":368,"address":[6882339,6882478,6882448],"length":1,"stats":{"Line":8},"fn_name":null},{"line":370,"address":[6698160,6698016,6698349],"length":1,"stats":{"Line":16},"fn_name":null},{"line":371,"address":[6698210,6698354,6698573],"length":1,"stats":{"Line":16},"fn_name":null},{"line":372,"address":[6698388],"length":1,"stats":{"Line":8},"fn_name":null},{"line":373,"address":[6698438,6699842],"length":1,"stats":{"Line":8},"fn_name":null},{"line":378,"address":[6698578],"length":1,"stats":{"Line":10},"fn_name":null},{"line":379,"address":[6698623],"length":1,"stats":{"Line":8},"fn_name":null},{"line":382,"address":[6698600],"length":1,"stats":{"Line":10},"fn_name":null},{"line":383,"address":[6698636,6699724],"length":1,"stats":{"Line":20},"fn_name":null},{"line":384,"address":[6699604,6698701],"length":1,"stats":{"Line":10},"fn_name":null},{"line":386,"address":[6699594,6698818,6698993],"length":1,"stats":{"Line":20},"fn_name":null},{"line":387,"address":[6699027,6699589,6699196],"length":1,"stats":{"Line":30},"fn_name":null},{"line":388,"address":[6699395,6699449],"length":1,"stats":{"Line":20},"fn_name":null},{"line":389,"address":[6699496],"length":1,"stats":{"Line":10},"fn_name":null},{"line":390,"address":[6699506],"length":1,"stats":{"Line":10},"fn_name":null},{"line":393,"address":[6698966],"length":1,"stats":{"Line":10},"fn_name":null},{"line":404,"address":[6700016],"length":1,"stats":{"Line":10},"fn_name":"cross_add"},{"line":408,"address":[6700055],"length":1,"stats":{"Line":10},"fn_name":null},{"line":409,"address":[6700129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[6700164,6700111],"length":1,"stats":{"Line":20},"fn_name":null},{"line":412,"address":[6700212],"length":1,"stats":{"Line":10},"fn_name":null},{"line":413,"address":[6700311],"length":1,"stats":{"Line":10},"fn_name":null},{"line":414,"address":[6700463],"length":1,"stats":{"Line":10},"fn_name":null},{"line":415,"address":[6700557],"length":1,"stats":{"Line":10},"fn_name":null},{"line":417,"address":[6700178],"length":1,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[6700626,6701368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[6700718],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[6700704],"length":1,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[6700716,6700958,6701042,6700731,6701398,6700833],"length":1,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[6700791,6700955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[6701458,6701488,6700998],"length":1,"stats":{"Line":25},"fn_name":"add"},{"line":427,"address":[6701133,6701363,6701052,6700977],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[6701361,6701167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[6701205],"length":1,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[6701293,6701359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[6701353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[6701120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[6701488,6701532],"length":1,"stats":{"Line":0},"fn_name":"add"},{"line":443,"address":[6701772,6701500,6701544],"length":1,"stats":{"Line":50},"fn_name":null},{"line":444,"address":[6701680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[6701632],"length":1,"stats":{"Line":25},"fn_name":null},{"line":447,"address":[6701718],"length":1,"stats":{"Line":25},"fn_name":null},{"line":453,"address":[6701808],"length":1,"stats":{"Line":8},"fn_name":"add_char_class"},{"line":454,"address":[6701824],"length":1,"stats":{"Line":8},"fn_name":null},{"line":461,"address":[6701856],"length":1,"stats":{"Line":8},"fn_name":"add_char_class_reverse"},{"line":462,"address":[6701870],"length":1,"stats":{"Line":8},"fn_name":null},{"line":465,"address":[6701989,6701904],"length":1,"stats":{"Line":8},"fn_name":"_add_char_class"},{"line":472,"address":[6702017,6701938],"length":1,"stats":{"Line":16},"fn_name":null},{"line":473,"address":[6702059],"length":1,"stats":{"Line":23},"fn_name":null},{"line":475,"address":[6702036],"length":1,"stats":{"Line":8},"fn_name":null},{"line":476,"address":[6702087,6703560],"length":1,"stats":{"Line":16},"fn_name":null},{"line":477,"address":[6703440,6702152],"length":1,"stats":{"Line":8},"fn_name":null},{"line":479,"address":[6702269,6702444,6702716],"length":1,"stats":{"Line":16},"fn_name":null},{"line":480,"address":[6702478,6703703],"length":1,"stats":{"Line":8},"fn_name":null},{"line":481,"address":[6703430,6702721,6702558],"length":1,"stats":{"Line":16},"fn_name":null},{"line":482,"address":[6702751,6702915,6703425],"length":1,"stats":{"Line":24},"fn_name":null},{"line":483,"address":[6703114,6703187],"length":1,"stats":{"Line":16},"fn_name":null},{"line":484,"address":[6703273,6703198],"length":1,"stats":{"Line":16},"fn_name":null},{"line":485,"address":[6703204],"length":1,"stats":{"Line":8},"fn_name":null},{"line":487,"address":[6703275],"length":1,"stats":{"Line":8},"fn_name":null},{"line":488,"address":[6703323],"length":1,"stats":{"Line":8},"fn_name":null},{"line":492,"address":[6702417],"length":1,"stats":{"Line":8},"fn_name":null},{"line":498,"address":[6703808,6703872],"length":1,"stats":{"Line":13},"fn_name":"add_byte_class"},{"line":499,"address":[6703831,6703897],"length":1,"stats":{"Line":27},"fn_name":null},{"line":500,"address":[6703933],"length":1,"stats":{"Line":14},"fn_name":null},{"line":502,"address":[6703916],"length":1,"stats":{"Line":8},"fn_name":null},{"line":503,"address":[6705256,6703955],"length":1,"stats":{"Line":16},"fn_name":null},{"line":504,"address":[6705142,6704014],"length":1,"stats":{"Line":8},"fn_name":null},{"line":506,"address":[6704576,6704294,6704128],"length":1,"stats":{"Line":16},"fn_name":null},{"line":507,"address":[6704328,6705399],"length":1,"stats":{"Line":8},"fn_name":null},{"line":508,"address":[6705132,6704410,6704581],"length":1,"stats":{"Line":32},"fn_name":null},{"line":509,"address":[6704776,6704611,6705127],"length":1,"stats":{"Line":24},"fn_name":null},{"line":510,"address":[6704975,6705029],"length":1,"stats":{"Line":16},"fn_name":null},{"line":511,"address":[6705047],"length":1,"stats":{"Line":8},"fn_name":null},{"line":515,"address":[6704273],"length":1,"stats":{"Line":8},"fn_name":null},{"line":520,"address":[6705472],"length":1,"stats":{"Line":10},"fn_name":"cut"},{"line":521,"address":[6705591,6705589,6705558,6705481],"length":1,"stats":{"Line":20},"fn_name":null},{"line":522,"address":[6705580],"length":1,"stats":{"Line":10},"fn_name":null},{"line":527,"address":[6705600],"length":1,"stats":{"Line":10},"fn_name":"reverse"},{"line":528,"address":[6705609,6705763,6705761,6705688],"length":1,"stats":{"Line":20},"fn_name":null},{"line":529,"address":[6705710],"length":1,"stats":{"Line":10},"fn_name":null},{"line":534,"address":[6705776],"length":1,"stats":{"Line":0},"fn_name":"clear"},{"line":535,"address":[6705781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[6705792,6705881],"length":1,"stats":{"Line":10},"fn_name":"remove_complete"},{"line":540,"address":[6705814],"length":1,"stats":{"Line":10},"fn_name":null},{"line":541,"address":[6705910,6705982,6706540,6706130],"length":1,"stats":{"Line":40},"fn_name":null},{"line":542,"address":[6706329,6706520,6706386],"length":1,"stats":{"Line":28},"fn_name":null},{"line":543,"address":[6706456],"length":1,"stats":{"Line":8},"fn_name":null},{"line":545,"address":[6706392],"length":1,"stats":{"Line":10},"fn_name":null},{"line":548,"address":[6706545],"length":1,"stats":{"Line":10},"fn_name":null},{"line":552,"address":[6706736],"length":1,"stats":{"Line":24},"fn_name":"num_bytes"},{"line":553,"address":[6706745],"length":1,"stats":{"Line":44},"fn_name":null},{"line":560,"address":[6706832],"length":1,"stats":{"Line":8},"fn_name":"class_exceeds_limits"},{"line":561,"address":[6706846],"length":1,"stats":{"Line":8},"fn_name":null},{"line":562,"address":[6706882],"length":1,"stats":{"Line":23},"fn_name":null},{"line":566,"address":[6706867,6706905,6706947,6707013],"length":1,"stats":{"Line":24},"fn_name":null},{"line":567,"address":[6706937],"length":1,"stats":{"Line":8},"fn_name":null},{"line":569,"address":[6706959,6706916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":570,"address":[6882898,6882928,6882812],"length":1,"stats":{"Line":8},"fn_name":"repeat_zero_or_one_literals<fn(&regex_syntax::hir::Hir, &mut regex_syntax::hir::literal::Literals)>"},{"line":571,"address":[6882724,6882664],"length":1,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[6882715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[6882702,6882731,6882838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[6707015],"length":1,"stats":{"Line":8},"fn_name":null},{"line":584,"address":[6707056,6707103],"length":1,"stats":{"Line":10},"fn_name":"prefixes"},{"line":585,"address":[6709125,6707087,6707518,6707660,6707742,6708410,6708339,6708569,6707578,6707800,6708704],"length":1,"stats":{"Line":97},"fn_name":null},{"line":586,"address":[6707203,6707317,6707126],"length":1,"stats":{"Line":28},"fn_name":null},{"line":587,"address":[6707327],"length":1,"stats":{"Line":10},"fn_name":null},{"line":588,"address":[6707382,6707512],"length":1,"stats":{"Line":20},"fn_name":null},{"line":590,"address":[6707531],"length":1,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[6707541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":593,"address":[6707256,6707591],"length":1,"stats":{"Line":16},"fn_name":null},{"line":594,"address":[6707619,6707658],"length":1,"stats":{"Line":31},"fn_name":null},{"line":595,"address":[6707652],"length":1,"stats":{"Line":23},"fn_name":null},{"line":598,"address":[6707673],"length":1,"stats":{"Line":13},"fn_name":null},{"line":599,"address":[6707701,6707740],"length":1,"stats":{"Line":28},"fn_name":null},{"line":600,"address":[6707734],"length":1,"stats":{"Line":13},"fn_name":null},{"line":603,"address":[6707755],"length":1,"stats":{"Line":9},"fn_name":null},{"line":604,"address":[6707783],"length":1,"stats":{"Line":9},"fn_name":null},{"line":606,"address":[6708337,6707813,6708003,6707954,6707977,6708029],"length":1,"stats":{"Line":41},"fn_name":null},{"line":607,"address":[6707833],"length":1,"stats":{"Line":8},"fn_name":null},{"line":608,"address":[6707961],"length":1,"stats":{"Line":8},"fn_name":null},{"line":611,"address":[6707987],"length":1,"stats":{"Line":8},"fn_name":null},{"line":614,"address":[6708013],"length":1,"stats":{"Line":8},"fn_name":null},{"line":616,"address":[6707892],"length":1,"stats":{"Line":8},"fn_name":null},{"line":617,"address":[6708187,6708250,6708112],"length":1,"stats":{"Line":24},"fn_name":null},{"line":618,"address":[6707909,6708124],"length":1,"stats":{"Line":16},"fn_name":null},{"line":619,"address":[6708194],"length":1,"stats":{"Line":8},"fn_name":null},{"line":620,"address":[6708039],"length":1,"stats":{"Line":8},"fn_name":null},{"line":623,"address":[6708297],"length":1,"stats":{"Line":9},"fn_name":null},{"line":627,"address":[6708352],"length":1,"stats":{"Line":25},"fn_name":null},{"line":628,"address":[6708423,6708564],"length":1,"stats":{"Line":25},"fn_name":null},{"line":629,"address":[6708516],"length":1,"stats":{"Line":25},"fn_name":null},{"line":630,"address":[6709058,6708530,6708579],"length":1,"stats":{"Line":60},"fn_name":null},{"line":631,"address":[6708754,6708683,6708714],"length":1,"stats":{"Line":75},"fn_name":null},{"line":632,"address":[6708774],"length":1,"stats":{"Line":25},"fn_name":null},{"line":633,"address":[6708818],"length":1,"stats":{"Line":0},"fn_name":null},{"line":634,"address":[6708824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":636,"address":[6708794,6708836],"length":1,"stats":{"Line":50},"fn_name":null},{"line":637,"address":[6708850],"length":1,"stats":{"Line":25},"fn_name":null},{"line":639,"address":[6708725],"length":1,"stats":{"Line":25},"fn_name":null},{"line":640,"address":[6708868],"length":1,"stats":{"Line":25},"fn_name":null},{"line":641,"address":[6708875,6708925],"length":1,"stats":{"Line":47},"fn_name":null},{"line":645,"address":[6709020],"length":1,"stats":{"Line":23},"fn_name":null},{"line":646,"address":[6709053],"length":1,"stats":{"Line":23},"fn_name":null},{"line":650,"address":[6709071],"length":1,"stats":{"Line":13},"fn_name":null},{"line":651,"address":[6709085],"length":1,"stats":{"Line":13},"fn_name":null},{"line":653,"address":[6707184],"length":1,"stats":{"Line":10},"fn_name":null},{"line":657,"address":[6709215,6709168],"length":1,"stats":{"Line":27},"fn_name":"suffixes"},{"line":658,"address":[6709934,6710647,6709846,6711019,6711440,6709199,6709759,6709699,6709992,6710576,6710806],"length":1,"stats":{"Line":144},"fn_name":null},{"line":659,"address":[6709238,6709429,6709315],"length":1,"stats":{"Line":45},"fn_name":null},{"line":660,"address":[6709439],"length":1,"stats":{"Line":10},"fn_name":null},{"line":661,"address":[6709494],"length":1,"stats":{"Line":10},"fn_name":null},{"line":662,"address":[6709563],"length":1,"stats":{"Line":10},"fn_name":null},{"line":663,"address":[6709657],"length":1,"stats":{"Line":10},"fn_name":null},{"line":664,"address":[6709693],"length":1,"stats":{"Line":10},"fn_name":null},{"line":666,"address":[6709712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[6709722],"length":1,"stats":{"Line":0},"fn_name":null},{"line":669,"address":[6709368,6709772],"length":1,"stats":{"Line":16},"fn_name":null},{"line":670,"address":[6709800,6709844],"length":1,"stats":{"Line":31},"fn_name":null},{"line":671,"address":[6709838],"length":1,"stats":{"Line":23},"fn_name":null},{"line":674,"address":[6709859],"length":1,"stats":{"Line":14},"fn_name":null},{"line":675,"address":[6709932,6709887],"length":1,"stats":{"Line":26},"fn_name":null},{"line":676,"address":[6709926],"length":1,"stats":{"Line":14},"fn_name":null},{"line":679,"address":[6709947],"length":1,"stats":{"Line":9},"fn_name":null},{"line":680,"address":[6709975],"length":1,"stats":{"Line":9},"fn_name":null},{"line":682,"address":[6710196,6710170,6710005,6710225,6710254,6710574],"length":1,"stats":{"Line":60},"fn_name":null},{"line":683,"address":[6710025],"length":1,"stats":{"Line":8},"fn_name":null},{"line":684,"address":[6710180],"length":1,"stats":{"Line":8},"fn_name":null},{"line":687,"address":[6710209],"length":1,"stats":{"Line":8},"fn_name":null},{"line":690,"address":[6710238],"length":1,"stats":{"Line":8},"fn_name":null},{"line":692,"address":[6710096],"length":1,"stats":{"Line":10},"fn_name":null},{"line":693,"address":[6710418,6710340,6710484],"length":1,"stats":{"Line":24},"fn_name":null},{"line":694,"address":[6710355,6710116],"length":1,"stats":{"Line":18},"fn_name":null},{"line":695,"address":[6710428],"length":1,"stats":{"Line":8},"fn_name":null},{"line":696,"address":[6710267],"length":1,"stats":{"Line":8},"fn_name":null},{"line":699,"address":[6710534],"length":1,"stats":{"Line":10},"fn_name":null},{"line":703,"address":[6710589],"length":1,"stats":{"Line":25},"fn_name":null},{"line":704,"address":[6710801,6710660],"length":1,"stats":{"Line":25},"fn_name":null},{"line":705,"address":[6710753],"length":1,"stats":{"Line":25},"fn_name":null},{"line":706,"address":[6711373,6710767,6710821],"length":1,"stats":{"Line":60},"fn_name":null},{"line":707,"address":[6711069,6710998,6711029],"length":1,"stats":{"Line":75},"fn_name":null},{"line":708,"address":[6711089],"length":1,"stats":{"Line":23},"fn_name":null},{"line":709,"address":[6711133],"length":1,"stats":{"Line":0},"fn_name":null},{"line":710,"address":[6711139],"length":1,"stats":{"Line":0},"fn_name":null},{"line":712,"address":[6711109,6711151],"length":1,"stats":{"Line":46},"fn_name":null},{"line":713,"address":[6711165],"length":1,"stats":{"Line":23},"fn_name":null},{"line":715,"address":[6711040],"length":1,"stats":{"Line":25},"fn_name":null},{"line":716,"address":[6711183],"length":1,"stats":{"Line":25},"fn_name":null},{"line":717,"address":[6711240,6711190],"length":1,"stats":{"Line":49},"fn_name":null},{"line":721,"address":[6711335],"length":1,"stats":{"Line":25},"fn_name":null},{"line":722,"address":[6711368],"length":1,"stats":{"Line":25},"fn_name":null},{"line":726,"address":[6711386],"length":1,"stats":{"Line":8},"fn_name":null},{"line":727,"address":[6711400],"length":1,"stats":{"Line":8},"fn_name":null},{"line":729,"address":[6709296],"length":1,"stats":{"Line":12},"fn_name":null},{"line":733,"address":[6883883,6882987,6882928,6883824],"length":1,"stats":{"Line":8},"fn_name":"repeat_zero_or_one_literals<fn(&regex_syntax::hir::Hir, &mut regex_syntax::hir::literal::Literals)>"},{"line":738,"address":[6883924,6883898,6883002,6884130,6883234,6883847,6882951,6883028],"length":1,"stats":{"Line":48},"fn_name":null},{"line":739,"address":[6883290,6883213,6884109,6884186],"length":1,"stats":{"Line":32},"fn_name":null},{"line":740,"address":[6883317,6884213],"length":1,"stats":{"Line":16},"fn_name":null},{"line":742,"address":[6883370,6884266],"length":1,"stats":{"Line":16},"fn_name":null},{"line":743,"address":[6883488,6884384],"length":1,"stats":{"Line":16},"fn_name":null},{"line":746,"address":[6884458,6883562,6883469,6884365],"length":1,"stats":{"Line":32},"fn_name":null},{"line":747,"address":[6883689,6884482,6884585,6883586],"length":1,"stats":{"Line":16},"fn_name":null},{"line":748,"address":[6883673,6884569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":752,"address":[6885691,6884720,6884779,6885632],"length":1,"stats":{"Line":16},"fn_name":"repeat_zero_or_more_literals<fn(&regex_syntax::hir::Hir, &mut regex_syntax::hir::literal::Literals)>"},{"line":757,"address":[6884820,6884743,6885026,6885655,6885732,6884794,6885938,6885706],"length":1,"stats":{"Line":48},"fn_name":null},{"line":758,"address":[6885005,6885082,6885917,6885994],"length":1,"stats":{"Line":32},"fn_name":null},{"line":759,"address":[6885109,6886021],"length":1,"stats":{"Line":16},"fn_name":null},{"line":761,"address":[6886074,6885162],"length":1,"stats":{"Line":16},"fn_name":null},{"line":762,"address":[6885277,6886189],"length":1,"stats":{"Line":16},"fn_name":null},{"line":765,"address":[6886173,6885261],"length":1,"stats":{"Line":18},"fn_name":null},{"line":766,"address":[6885351,6886263],"length":1,"stats":{"Line":21},"fn_name":null},{"line":767,"address":[6885394,6885497,6886409,6886306],"length":1,"stats":{"Line":22},"fn_name":null},{"line":768,"address":[6885481,6886393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":772,"address":[6886544,6886656,6886714,6886602],"length":1,"stats":{"Line":16},"fn_name":"repeat_one_or_more_literals<fn(&regex_syntax::hir::Hir, &mut regex_syntax::hir::literal::Literals)>"},{"line":777,"address":[6886558,6886670],"length":1,"stats":{"Line":16},"fn_name":null},{"line":778,"address":[6886726,6886614],"length":1,"stats":{"Line":16},"fn_name":null},{"line":781,"address":[6886768,6886853,6887712,6887797],"length":1,"stats":{"Line":19},"fn_name":"repeat_range_literals<fn(&regex_syntax::hir::Hir, &mut regex_syntax::hir::literal::Literals)>"},{"line":789,"address":[6886821,6887638,6888582,6888094,6887765,6887150],"length":1,"stats":{"Line":54},"fn_name":null},{"line":794,"address":[6887921,6886977],"length":1,"stats":{"Line":16},"fn_name":null},{"line":795,"address":[6886884,6887828],"length":1,"stats":{"Line":16},"fn_name":null},{"line":797,"address":[6887852,6886908],"length":1,"stats":{"Line":16},"fn_name":null},{"line":802,"address":[6886868,6887812,6888503,6887559],"length":1,"stats":{"Line":38},"fn_name":null},{"line":803,"address":[6887160,6888104],"length":1,"stats":{"Line":19},"fn_name":null},{"line":804,"address":[6887212,6888156],"length":1,"stats":{"Line":19},"fn_name":null},{"line":805,"address":[6887305,6888249],"length":1,"stats":{"Line":19},"fn_name":null},{"line":806,"address":[6887463,6887557,6888501,6888407],"length":1,"stats":{"Line":37},"fn_name":null},{"line":807,"address":[6888485,6887541],"length":1,"stats":{"Line":18},"fn_name":null},{"line":810,"address":[6888668,6888700,6888688,6888656,6887636,6887566,6888580,6888510],"length":1,"stats":{"Line":72},"fn_name":"{{closure}}<fn(&regex_syntax::hir::Hir, &mut regex_syntax::hir::literal::Literals)>"},{"line":811,"address":[6887620,6888564],"length":1,"stats":{"Line":16},"fn_name":null},{"line":816,"address":[6888720,6889740,6889664,6888796],"length":1,"stats":{"Line":21},"fn_name":"alternate_literals<fn(&regex_syntax::hir::Hir, &mut regex_syntax::hir::literal::Literals)>"},{"line":821,"address":[6888751,6889695],"length":1,"stats":{"Line":22},"fn_name":null},{"line":822,"address":[6888849,6889443,6889919,6889793,6888885,6888811,6889755,6890387,6888975,6889829],"length":1,"stats":{"Line":99},"fn_name":null},{"line":823,"address":[6889953,6889009],"length":1,"stats":{"Line":24},"fn_name":null},{"line":824,"address":[6889046,6889990],"length":1,"stats":{"Line":23},"fn_name":null},{"line":825,"address":[6889129,6890073],"length":1,"stats":{"Line":24},"fn_name":null},{"line":826,"address":[6890129,6889185],"length":1,"stats":{"Line":23},"fn_name":null},{"line":831,"address":[6890313,6889369],"length":1,"stats":{"Line":16},"fn_name":null},{"line":835,"address":[6890396,6889476,6889891,6890420,6889452,6888947],"length":1,"stats":{"Line":61},"fn_name":null},{"line":836,"address":[6889460,6890404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":841,"address":[6711472],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":842,"address":[6711493,6711620,6711696],"length":1,"stats":{"Line":0},"fn_name":null},{"line":843,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":844,"address":[6711608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":845,"address":[6711684],"length":1,"stats":{"Line":0},"fn_name":null},{"line":852,"address":[6711776],"length":1,"stats":{"Line":10},"fn_name":"new"},{"line":857,"address":[6711856],"length":1,"stats":{"Line":10},"fn_name":"empty"},{"line":858,"address":[6711872],"length":1,"stats":{"Line":10},"fn_name":null},{"line":862,"address":[6711952],"length":1,"stats":{"Line":10},"fn_name":"is_cut"},{"line":863,"address":[6711957],"length":1,"stats":{"Line":10},"fn_name":null},{"line":867,"address":[6711968],"length":1,"stats":{"Line":10},"fn_name":"cut"},{"line":868,"address":[6711973],"length":1,"stats":{"Line":10},"fn_name":null},{"line":873,"address":[6711984],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":874,"address":[6711998],"length":1,"stats":{"Line":0},"fn_name":null},{"line":879,"address":[6712032],"length":1,"stats":{"Line":0},"fn_name":"partial_cmp"},{"line":880,"address":[6712046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":885,"address":[6712125,6712080],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":886,"address":[6712452,6712682,6712113,6712144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":887,"address":[6712191,6712397],"length":1,"stats":{"Line":0},"fn_name":null},{"line":889,"address":[6712627,6712150,6712457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":895,"address":[6712752],"length":1,"stats":{"Line":8},"fn_name":"as_ref"},{"line":896,"address":[6712761],"length":1,"stats":{"Line":8},"fn_name":null},{"line":902,"address":[6712800],"length":1,"stats":{"Line":10},"fn_name":"deref"},{"line":903,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":908,"address":[6712816],"length":1,"stats":{"Line":10},"fn_name":"deref_mut"},{"line":909,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":913,"address":[6712832],"length":1,"stats":{"Line":0},"fn_name":"position"},{"line":914,"address":[6712859],"length":1,"stats":{"Line":0},"fn_name":null},{"line":915,"address":[6713262,6712871],"length":1,"stats":{"Line":0},"fn_name":null},{"line":916,"address":[6712945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":917,"address":[6713131],"length":1,"stats":{"Line":0},"fn_name":null},{"line":919,"address":[6713297,6713188,6713267,6713098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":920,"address":[6713196],"length":1,"stats":{"Line":0},"fn_name":null},{"line":922,"address":[6712928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":925,"address":[6713312,6713389],"length":1,"stats":{"Line":0},"fn_name":"escape_unicode"},{"line":926,"address":[6713338,6713503,6713450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":927,"address":[6713404,6713452],"length":1,"stats":{"Line":0},"fn_name":null},{"line":928,"address":[6713419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":930,"address":[6713515],"length":1,"stats":{"Line":0},"fn_name":null},{"line":931,"address":[6713588,6713627,6713809,6714552,6713530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":932,"address":[6714548,6713839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":933,"address":[6713933,6713892,6714458],"length":1,"stats":{"Line":0},"fn_name":null},{"line":934,"address":[6713926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":936,"address":[6713901,6714296],"length":1,"stats":{"Line":0},"fn_name":null},{"line":937,"address":[6714040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":939,"address":[6714306,6713938],"length":1,"stats":{"Line":0},"fn_name":null},{"line":942,"address":[6714468],"length":1,"stats":{"Line":0},"fn_name":null},{"line":944,"address":[6713878],"length":1,"stats":{"Line":0},"fn_name":null},{"line":947,"address":[6713747],"length":1,"stats":{"Line":0},"fn_name":null},{"line":950,"address":[6714701,6714640],"length":1,"stats":{"Line":0},"fn_name":"escape_bytes"},{"line":951,"address":[6714666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":952,"address":[6714782,6715002,6714879,6714716,6714905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":953,"address":[6714919,6714902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":955,"address":[6714835],"length":1,"stats":{"Line":0},"fn_name":null},{"line":958,"address":[6715101,6715056],"length":1,"stats":{"Line":0},"fn_name":"escape_byte"},{"line":961,"address":[6715071,6715113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":962,"address":[6715192,6715129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":965,"address":[6715264],"length":1,"stats":{"Line":8},"fn_name":"cls_char_count"},{"line":966,"address":[6715273],"length":1,"stats":{"Line":24},"fn_name":null},{"line":970,"address":[6715360],"length":1,"stats":{"Line":13},"fn_name":"cls_byte_count"},{"line":971,"address":[6715369],"length":1,"stats":{"Line":41},"fn_name":null},{"line":1014,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1015,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1020,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1021,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1022,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1024,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1030,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1031,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1036,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1037,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":289,"coverable":459},{"path":["/","usr","src","regex","regex-syntax","src","hir","mod.rs"],"content":"/*!\nDefines a high-level intermediate representation for regular expressions.\n*/\nuse std::char;\nuse std::cmp;\nuse std::error;\nuse std::fmt;\nuse std::result;\nuse std::u8;\n\nuse ast::Span;\nuse hir::interval::{Interval, IntervalSet, IntervalSetIter};\nuse unicode;\n\npub use hir::visitor::{visit, Visitor};\npub use unicode::CaseFoldError;\n\nmod interval;\npub mod literal;\npub mod print;\npub mod translate;\nmod visitor;\n\n/// An error that can occur while translating an `Ast` to a `Hir`.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Error {\n    /// The kind of error.\n    kind: ErrorKind,\n    /// The original pattern that the translator's Ast was parsed from. Every\n    /// span in an error is a valid range into this string.\n    pattern: String,\n    /// The span of this error, derived from the Ast given to the translator.\n    span: Span,\n}\n\nimpl Error {\n    /// Return the type of this error.\n    pub fn kind(&self) -> &ErrorKind {\n        &self.kind\n    }\n\n    /// The original pattern string in which this error occurred.\n    ///\n    /// Every span reported by this error is reported in terms of this string.\n    pub fn pattern(&self) -> &str {\n        &self.pattern\n    }\n\n    /// Return the span at which this error occurred.\n    pub fn span(&self) -> &Span {\n        &self.span\n    }\n}\n\n/// The type of an error that occurred while building an `Hir`.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum ErrorKind {\n    /// This error occurs when a Unicode feature is used when Unicode\n    /// support is disabled. For example `(?-u:\\pL)` would trigger this error.\n    UnicodeNotAllowed,\n    /// This error occurs when translating a pattern that could match a byte\n    /// sequence that isn't UTF-8 and `allow_invalid_utf8` was disabled.\n    InvalidUtf8,\n    /// This occurs when an unrecognized Unicode property name could not\n    /// be found.\n    UnicodePropertyNotFound,\n    /// This occurs when an unrecognized Unicode property value could not\n    /// be found.\n    UnicodePropertyValueNotFound,\n    /// This occurs when a Unicode-aware Perl character class (`\\w`, `\\s` or\n    /// `\\d`) could not be found. This can occur when the `unicode-perl`\n    /// crate feature is not enabled.\n    UnicodePerlClassNotFound,\n    /// This occurs when the Unicode simple case mapping tables are not\n    /// available, and the regular expression required Unicode aware case\n    /// insensitivity.\n    UnicodeCaseUnavailable,\n    /// This occurs when the translator attempts to construct a character class\n    /// that is empty.\n    ///\n    /// Note that this restriction in the translator may be removed in the\n    /// future.\n    EmptyClassNotAllowed,\n    /// Hints that destructuring should not be exhaustive.\n    ///\n    /// This enum may grow additional variants, so this makes sure clients\n    /// don't count on exhaustive matching. (Otherwise, adding a new variant\n    /// could break existing code.)\n    #[doc(hidden)]\n    __Nonexhaustive,\n}\n\nimpl ErrorKind {\n    // TODO: Remove this method entirely on the next breaking semver release.\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        use self::ErrorKind::*;\n        match *self {\n            UnicodeNotAllowed => \"Unicode not allowed here\",\n            InvalidUtf8 => \"pattern can match invalid UTF-8\",\n            UnicodePropertyNotFound => \"Unicode property not found\",\n            UnicodePropertyValueNotFound => \"Unicode property value not found\",\n            UnicodePerlClassNotFound => {\n                \"Unicode-aware Perl class not found \\\n                 (make sure the unicode-perl feature is enabled)\"\n            }\n            UnicodeCaseUnavailable => {\n                \"Unicode-aware case insensitivity matching is not available \\\n                 (make sure the unicode-case feature is enabled)\"\n            }\n            EmptyClassNotAllowed => \"empty character classes are not allowed\",\n            __Nonexhaustive => unreachable!(),\n        }\n    }\n}\n\nimpl error::Error for Error {\n    // TODO: Remove this method entirely on the next breaking semver release.\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        self.kind.description()\n    }\n}\n\nimpl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        ::error::Formatter::from(self).fmt(f)\n    }\n}\n\nimpl fmt::Display for ErrorKind {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        // TODO: Remove this on the next breaking semver release.\n        #[allow(deprecated)]\n        f.write_str(self.description())\n    }\n}\n\n/// A high-level intermediate representation (HIR) for a regular expression.\n///\n/// The HIR of a regular expression represents an intermediate step between its\n/// abstract syntax (a structured description of the concrete syntax) and\n/// compiled byte codes. The purpose of HIR is to make regular expressions\n/// easier to analyze. In particular, the AST is much more complex than the\n/// HIR. For example, while an AST supports arbitrarily nested character\n/// classes, the HIR will flatten all nested classes into a single set. The HIR\n/// will also \"compile away\" every flag present in the concrete syntax. For\n/// example, users of HIR expressions never need to worry about case folding;\n/// it is handled automatically by the translator (e.g., by translating `(?i)A`\n/// to `[aA]`).\n///\n/// If the HIR was produced by a translator that disallows invalid UTF-8, then\n/// the HIR is guaranteed to match UTF-8 exclusively.\n///\n/// This type defines its own destructor that uses constant stack space and\n/// heap space proportional to the size of the HIR.\n///\n/// The specific type of an HIR expression can be accessed via its `kind`\n/// or `into_kind` methods. This extra level of indirection exists for two\n/// reasons:\n///\n/// 1. Construction of an HIR expression *must* use the constructor methods\n///    on this `Hir` type instead of building the `HirKind` values directly.\n///    This permits construction to enforce invariants like \"concatenations\n///    always consist of two or more sub-expressions.\"\n/// 2. Every HIR expression contains attributes that are defined inductively,\n///    and can be computed cheaply during the construction process. For\n///    example, one such attribute is whether the expression must match at the\n///    beginning of the text.\n///\n/// Also, an `Hir`'s `fmt::Display` implementation prints an HIR as a regular\n/// expression pattern string, and uses constant stack space and heap space\n/// proportional to the size of the `Hir`.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Hir {\n    /// The underlying HIR kind.\n    kind: HirKind,\n    /// Analysis info about this HIR, computed during construction.\n    info: HirInfo,\n}\n\n/// The kind of an arbitrary `Hir` expression.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum HirKind {\n    /// The empty regular expression, which matches everything, including the\n    /// empty string.\n    Empty,\n    /// A single literal character that matches exactly this character.\n    Literal(Literal),\n    /// A single character class that matches any of the characters in the\n    /// class. A class can either consist of Unicode scalar values as\n    /// characters, or it can use bytes.\n    Class(Class),\n    /// An anchor assertion. An anchor assertion match always has zero length.\n    Anchor(Anchor),\n    /// A word boundary assertion, which may or may not be Unicode aware. A\n    /// word boundary assertion match always has zero length.\n    WordBoundary(WordBoundary),\n    /// A repetition operation applied to a child expression.\n    Repetition(Repetition),\n    /// A possibly capturing group, which contains a child expression.\n    Group(Group),\n    /// A concatenation of expressions. A concatenation always has at least two\n    /// child expressions.\n    ///\n    /// A concatenation matches only if each of its child expression matches\n    /// one after the other.\n    Concat(Vec<Hir>),\n    /// An alternation of expressions. An alternation always has at least two\n    /// child expressions.\n    ///\n    /// An alternation matches only if at least one of its child expression\n    /// matches. If multiple expressions match, then the leftmost is preferred.\n    Alternation(Vec<Hir>),\n}\n\nimpl Hir {\n    /// Returns a reference to the underlying HIR kind.\n    pub fn kind(&self) -> &HirKind {\n        &self.kind\n    }\n\n    /// Consumes ownership of this HIR expression and returns its underlying\n    /// `HirKind`.\n    pub fn into_kind(mut self) -> HirKind {\n        use std::mem;\n        mem::replace(&mut self.kind, HirKind::Empty)\n    }\n\n    /// Returns an empty HIR expression.\n    ///\n    /// An empty HIR expression always matches, including the empty string.\n    pub fn empty() -> Hir {\n        let mut info = HirInfo::new();\n        info.set_always_utf8(true);\n        info.set_all_assertions(true);\n        info.set_anchored_start(false);\n        info.set_anchored_end(false);\n        info.set_line_anchored_start(false);\n        info.set_line_anchored_end(false);\n        info.set_any_anchored_start(false);\n        info.set_any_anchored_end(false);\n        info.set_match_empty(true);\n        info.set_literal(false);\n        info.set_alternation_literal(false);\n        Hir { kind: HirKind::Empty, info: info }\n    }\n\n    /// Creates a literal HIR expression.\n    ///\n    /// If the given literal has a `Byte` variant with an ASCII byte, then this\n    /// method panics. This enforces the invariant that `Byte` variants are\n    /// only used to express matching of invalid UTF-8.\n    pub fn literal(lit: Literal) -> Hir {\n        if let Literal::Byte(b) = lit {\n            assert!(b > 0x7F);\n        }\n\n        let mut info = HirInfo::new();\n        info.set_always_utf8(lit.is_unicode());\n        info.set_all_assertions(false);\n        info.set_anchored_start(false);\n        info.set_anchored_end(false);\n        info.set_line_anchored_start(false);\n        info.set_line_anchored_end(false);\n        info.set_any_anchored_start(false);\n        info.set_any_anchored_end(false);\n        info.set_match_empty(false);\n        info.set_literal(true);\n        info.set_alternation_literal(true);\n        Hir { kind: HirKind::Literal(lit), info: info }\n    }\n\n    /// Creates a class HIR expression.\n    pub fn class(class: Class) -> Hir {\n        let mut info = HirInfo::new();\n        info.set_always_utf8(class.is_always_utf8());\n        info.set_all_assertions(false);\n        info.set_anchored_start(false);\n        info.set_anchored_end(false);\n        info.set_line_anchored_start(false);\n        info.set_line_anchored_end(false);\n        info.set_any_anchored_start(false);\n        info.set_any_anchored_end(false);\n        info.set_match_empty(false);\n        info.set_literal(false);\n        info.set_alternation_literal(false);\n        Hir { kind: HirKind::Class(class), info: info }\n    }\n\n    /// Creates an anchor assertion HIR expression.\n    pub fn anchor(anchor: Anchor) -> Hir {\n        let mut info = HirInfo::new();\n        info.set_always_utf8(true);\n        info.set_all_assertions(true);\n        info.set_anchored_start(false);\n        info.set_anchored_end(false);\n        info.set_line_anchored_start(false);\n        info.set_line_anchored_end(false);\n        info.set_any_anchored_start(false);\n        info.set_any_anchored_end(false);\n        info.set_match_empty(true);\n        info.set_literal(false);\n        info.set_alternation_literal(false);\n        if let Anchor::StartText = anchor {\n            info.set_anchored_start(true);\n            info.set_line_anchored_start(true);\n            info.set_any_anchored_start(true);\n        }\n        if let Anchor::EndText = anchor {\n            info.set_anchored_end(true);\n            info.set_line_anchored_end(true);\n            info.set_any_anchored_end(true);\n        }\n        if let Anchor::StartLine = anchor {\n            info.set_line_anchored_start(true);\n        }\n        if let Anchor::EndLine = anchor {\n            info.set_line_anchored_end(true);\n        }\n        Hir { kind: HirKind::Anchor(anchor), info: info }\n    }\n\n    /// Creates a word boundary assertion HIR expression.\n    pub fn word_boundary(word_boundary: WordBoundary) -> Hir {\n        let mut info = HirInfo::new();\n        info.set_always_utf8(true);\n        info.set_all_assertions(true);\n        info.set_anchored_start(false);\n        info.set_anchored_end(false);\n        info.set_line_anchored_start(false);\n        info.set_line_anchored_end(false);\n        info.set_any_anchored_start(false);\n        info.set_any_anchored_end(false);\n        info.set_literal(false);\n        info.set_alternation_literal(false);\n        // A negated word boundary matches the empty string, but a normal\n        // word boundary does not!\n        info.set_match_empty(word_boundary.is_negated());\n        // Negated ASCII word boundaries can match invalid UTF-8.\n        if let WordBoundary::AsciiNegate = word_boundary {\n            info.set_always_utf8(false);\n        }\n        Hir { kind: HirKind::WordBoundary(word_boundary), info: info }\n    }\n\n    /// Creates a repetition HIR expression.\n    pub fn repetition(rep: Repetition) -> Hir {\n        let mut info = HirInfo::new();\n        info.set_always_utf8(rep.hir.is_always_utf8());\n        info.set_all_assertions(rep.hir.is_all_assertions());\n        // If this operator can match the empty string, then it can never\n        // be anchored.\n        info.set_anchored_start(\n            !rep.is_match_empty() && rep.hir.is_anchored_start(),\n        );\n        info.set_anchored_end(\n            !rep.is_match_empty() && rep.hir.is_anchored_end(),\n        );\n        info.set_line_anchored_start(\n            !rep.is_match_empty() && rep.hir.is_anchored_start(),\n        );\n        info.set_line_anchored_end(\n            !rep.is_match_empty() && rep.hir.is_anchored_end(),\n        );\n        info.set_any_anchored_start(rep.hir.is_any_anchored_start());\n        info.set_any_anchored_end(rep.hir.is_any_anchored_end());\n        info.set_match_empty(rep.is_match_empty() || rep.hir.is_match_empty());\n        info.set_literal(false);\n        info.set_alternation_literal(false);\n        Hir { kind: HirKind::Repetition(rep), info: info }\n    }\n\n    /// Creates a group HIR expression.\n    pub fn group(group: Group) -> Hir {\n        let mut info = HirInfo::new();\n        info.set_always_utf8(group.hir.is_always_utf8());\n        info.set_all_assertions(group.hir.is_all_assertions());\n        info.set_anchored_start(group.hir.is_anchored_start());\n        info.set_anchored_end(group.hir.is_anchored_end());\n        info.set_line_anchored_start(group.hir.is_line_anchored_start());\n        info.set_line_anchored_end(group.hir.is_line_anchored_end());\n        info.set_any_anchored_start(group.hir.is_any_anchored_start());\n        info.set_any_anchored_end(group.hir.is_any_anchored_end());\n        info.set_match_empty(group.hir.is_match_empty());\n        info.set_literal(false);\n        info.set_alternation_literal(false);\n        Hir { kind: HirKind::Group(group), info: info }\n    }\n\n    /// Returns the concatenation of the given expressions.\n    ///\n    /// This flattens the concatenation as appropriate.\n    pub fn concat(mut exprs: Vec<Hir>) -> Hir {\n        match exprs.len() {\n            0 => Hir::empty(),\n            1 => exprs.pop().unwrap(),\n            _ => {\n                let mut info = HirInfo::new();\n                info.set_always_utf8(true);\n                info.set_all_assertions(true);\n                info.set_any_anchored_start(false);\n                info.set_any_anchored_end(false);\n                info.set_match_empty(true);\n                info.set_literal(true);\n                info.set_alternation_literal(true);\n\n                // Some attributes require analyzing all sub-expressions.\n                for e in &exprs {\n                    let x = info.is_always_utf8() && e.is_always_utf8();\n                    info.set_always_utf8(x);\n\n                    let x = info.is_all_assertions() && e.is_all_assertions();\n                    info.set_all_assertions(x);\n\n                    let x = info.is_any_anchored_start()\n                        || e.is_any_anchored_start();\n                    info.set_any_anchored_start(x);\n\n                    let x =\n                        info.is_any_anchored_end() || e.is_any_anchored_end();\n                    info.set_any_anchored_end(x);\n\n                    let x = info.is_match_empty() && e.is_match_empty();\n                    info.set_match_empty(x);\n\n                    let x = info.is_literal() && e.is_literal();\n                    info.set_literal(x);\n\n                    let x = info.is_alternation_literal()\n                        && e.is_alternation_literal();\n                    info.set_alternation_literal(x);\n                }\n                // Anchored attributes require something slightly more\n                // sophisticated. Normally, WLOG, to determine whether an\n                // expression is anchored to the start, we'd only need to check\n                // the first expression of a concatenation. However,\n                // expressions like `$\\b^` are still anchored to the start,\n                // but the first expression in the concatenation *isn't*\n                // anchored to the start. So the \"first\" expression to look at\n                // is actually one that is either not an assertion or is\n                // specifically the StartText assertion.\n                info.set_anchored_start(\n                    exprs\n                        .iter()\n                        .take_while(|e| {\n                            e.is_anchored_start() || e.is_all_assertions()\n                        })\n                        .any(|e| e.is_anchored_start()),\n                );\n                // Similarly for the end anchor, but in reverse.\n                info.set_anchored_end(\n                    exprs\n                        .iter()\n                        .rev()\n                        .take_while(|e| {\n                            e.is_anchored_end() || e.is_all_assertions()\n                        })\n                        .any(|e| e.is_anchored_end()),\n                );\n                // Repeat the process for line anchors.\n                info.set_line_anchored_start(\n                    exprs\n                        .iter()\n                        .take_while(|e| {\n                            e.is_line_anchored_start() || e.is_all_assertions()\n                        })\n                        .any(|e| e.is_line_anchored_start()),\n                );\n                info.set_line_anchored_end(\n                    exprs\n                        .iter()\n                        .rev()\n                        .take_while(|e| {\n                            e.is_line_anchored_end() || e.is_all_assertions()\n                        })\n                        .any(|e| e.is_line_anchored_end()),\n                );\n                Hir { kind: HirKind::Concat(exprs), info: info }\n            }\n        }\n    }\n\n    /// Returns the alternation of the given expressions.\n    ///\n    /// This flattens the alternation as appropriate.\n    pub fn alternation(mut exprs: Vec<Hir>) -> Hir {\n        match exprs.len() {\n            0 => Hir::empty(),\n            1 => exprs.pop().unwrap(),\n            _ => {\n                let mut info = HirInfo::new();\n                info.set_always_utf8(true);\n                info.set_all_assertions(true);\n                info.set_anchored_start(true);\n                info.set_anchored_end(true);\n                info.set_line_anchored_start(true);\n                info.set_line_anchored_end(true);\n                info.set_any_anchored_start(false);\n                info.set_any_anchored_end(false);\n                info.set_match_empty(false);\n                info.set_literal(false);\n                info.set_alternation_literal(true);\n\n                // Some attributes require analyzing all sub-expressions.\n                for e in &exprs {\n                    let x = info.is_always_utf8() && e.is_always_utf8();\n                    info.set_always_utf8(x);\n\n                    let x = info.is_all_assertions() && e.is_all_assertions();\n                    info.set_all_assertions(x);\n\n                    let x = info.is_anchored_start() && e.is_anchored_start();\n                    info.set_anchored_start(x);\n\n                    let x = info.is_anchored_end() && e.is_anchored_end();\n                    info.set_anchored_end(x);\n\n                    let x = info.is_line_anchored_start()\n                        && e.is_line_anchored_start();\n                    info.set_line_anchored_start(x);\n\n                    let x = info.is_line_anchored_end()\n                        && e.is_line_anchored_end();\n                    info.set_line_anchored_end(x);\n\n                    let x = info.is_any_anchored_start()\n                        || e.is_any_anchored_start();\n                    info.set_any_anchored_start(x);\n\n                    let x =\n                        info.is_any_anchored_end() || e.is_any_anchored_end();\n                    info.set_any_anchored_end(x);\n\n                    let x = info.is_match_empty() || e.is_match_empty();\n                    info.set_match_empty(x);\n\n                    let x = info.is_alternation_literal() && e.is_literal();\n                    info.set_alternation_literal(x);\n                }\n                Hir { kind: HirKind::Alternation(exprs), info: info }\n            }\n        }\n    }\n\n    /// Build an HIR expression for `.`.\n    ///\n    /// A `.` expression matches any character except for `\\n`. To build an\n    /// expression that matches any character, including `\\n`, use the `any`\n    /// method.\n    ///\n    /// If `bytes` is `true`, then this assumes characters are limited to a\n    /// single byte.\n    pub fn dot(bytes: bool) -> Hir {\n        if bytes {\n            let mut cls = ClassBytes::empty();\n            cls.push(ClassBytesRange::new(b'\\0', b'\\x09'));\n            cls.push(ClassBytesRange::new(b'\\x0B', b'\\xFF'));\n            Hir::class(Class::Bytes(cls))\n        } else {\n            let mut cls = ClassUnicode::empty();\n            cls.push(ClassUnicodeRange::new('\\0', '\\x09'));\n            cls.push(ClassUnicodeRange::new('\\x0B', '\\u{10FFFF}'));\n            Hir::class(Class::Unicode(cls))\n        }\n    }\n\n    /// Build an HIR expression for `(?s).`.\n    ///\n    /// A `(?s).` expression matches any character, including `\\n`. To build an\n    /// expression that matches any character except for `\\n`, then use the\n    /// `dot` method.\n    ///\n    /// If `bytes` is `true`, then this assumes characters are limited to a\n    /// single byte.\n    pub fn any(bytes: bool) -> Hir {\n        if bytes {\n            let mut cls = ClassBytes::empty();\n            cls.push(ClassBytesRange::new(b'\\0', b'\\xFF'));\n            Hir::class(Class::Bytes(cls))\n        } else {\n            let mut cls = ClassUnicode::empty();\n            cls.push(ClassUnicodeRange::new('\\0', '\\u{10FFFF}'));\n            Hir::class(Class::Unicode(cls))\n        }\n    }\n\n    /// Return true if and only if this HIR will always match valid UTF-8.\n    ///\n    /// When this returns false, then it is possible for this HIR expression\n    /// to match invalid UTF-8.\n    pub fn is_always_utf8(&self) -> bool {\n        self.info.is_always_utf8()\n    }\n\n    /// Returns true if and only if this entire HIR expression is made up of\n    /// zero-width assertions.\n    ///\n    /// This includes expressions like `^$\\b\\A\\z` and even `((\\b)+())*^`, but\n    /// not `^a`.\n    pub fn is_all_assertions(&self) -> bool {\n        self.info.is_all_assertions()\n    }\n\n    /// Return true if and only if this HIR is required to match from the\n    /// beginning of text. This includes expressions like `^foo`, `^(foo|bar)`,\n    /// `^foo|^bar` but not `^foo|bar`.\n    pub fn is_anchored_start(&self) -> bool {\n        self.info.is_anchored_start()\n    }\n\n    /// Return true if and only if this HIR is required to match at the end\n    /// of text. This includes expressions like `foo$`, `(foo|bar)$`,\n    /// `foo$|bar$` but not `foo$|bar`.\n    pub fn is_anchored_end(&self) -> bool {\n        self.info.is_anchored_end()\n    }\n\n    /// Return true if and only if this HIR is required to match from the\n    /// beginning of text or the beginning of a line. This includes expressions\n    /// like `^foo`, `(?m)^foo`, `^(foo|bar)`, `^(foo|bar)`, `(?m)^foo|^bar`\n    /// but not `^foo|bar` or `(?m)^foo|bar`.\n    ///\n    /// Note that if `is_anchored_start` is `true`, then\n    /// `is_line_anchored_start` will also be `true`. The reverse implication\n    /// is not true. For example, `(?m)^foo` is line anchored, but not\n    /// `is_anchored_start`.\n    pub fn is_line_anchored_start(&self) -> bool {\n        self.info.is_line_anchored_start()\n    }\n\n    /// Return true if and only if this HIR is required to match at the\n    /// end of text or the end of a line. This includes expressions like\n    /// `foo$`, `(?m)foo$`, `(foo|bar)$`, `(?m)(foo|bar)$`, `foo$|bar$`,\n    /// `(?m)(foo|bar)$`, but not `foo$|bar` or `(?m)foo$|bar`.\n    ///\n    /// Note that if `is_anchored_end` is `true`, then\n    /// `is_line_anchored_end` will also be `true`. The reverse implication\n    /// is not true. For example, `(?m)foo$` is line anchored, but not\n    /// `is_anchored_end`.\n    pub fn is_line_anchored_end(&self) -> bool {\n        self.info.is_line_anchored_end()\n    }\n\n    /// Return true if and only if this HIR contains any sub-expression that\n    /// is required to match at the beginning of text. Specifically, this\n    /// returns true if the `^` symbol (when multiline mode is disabled) or the\n    /// `\\A` escape appear anywhere in the regex.\n    pub fn is_any_anchored_start(&self) -> bool {\n        self.info.is_any_anchored_start()\n    }\n\n    /// Return true if and only if this HIR contains any sub-expression that is\n    /// required to match at the end of text. Specifically, this returns true\n    /// if the `$` symbol (when multiline mode is disabled) or the `\\z` escape\n    /// appear anywhere in the regex.\n    pub fn is_any_anchored_end(&self) -> bool {\n        self.info.is_any_anchored_end()\n    }\n\n    /// Return true if and only if the empty string is part of the language\n    /// matched by this regular expression.\n    ///\n    /// This includes `a*`, `a?b*`, `a{0}`, `()`, `()+`, `^$`, `a|b?`, `\\B`,\n    /// but not `a`, `a+` or `\\b`.\n    pub fn is_match_empty(&self) -> bool {\n        self.info.is_match_empty()\n    }\n\n    /// Return true if and only if this HIR is a simple literal. This is only\n    /// true when this HIR expression is either itself a `Literal` or a\n    /// concatenation of only `Literal`s.\n    ///\n    /// For example, `f` and `foo` are literals, but `f+`, `(foo)`, `foo()`,\n    /// `` are not (even though that contain sub-expressions that are literals).\n    pub fn is_literal(&self) -> bool {\n        self.info.is_literal()\n    }\n\n    /// Return true if and only if this HIR is either a simple literal or an\n    /// alternation of simple literals. This is only\n    /// true when this HIR expression is either itself a `Literal` or a\n    /// concatenation of only `Literal`s or an alternation of only `Literal`s.\n    ///\n    /// For example, `f`, `foo`, `a|b|c`, and `foo|bar|baz` are alternation\n    /// literals, but `f+`, `(foo)`, `foo()`, ``\n    /// are not (even though that contain sub-expressions that are literals).\n    pub fn is_alternation_literal(&self) -> bool {\n        self.info.is_alternation_literal()\n    }\n}\n\nimpl HirKind {\n    /// Return true if and only if this HIR is the empty regular expression.\n    ///\n    /// Note that this is not defined inductively. That is, it only tests if\n    /// this kind is the `Empty` variant. To get the inductive definition,\n    /// use the `is_match_empty` method on [`Hir`](struct.Hir.html).\n    pub fn is_empty(&self) -> bool {\n        match *self {\n            HirKind::Empty => true,\n            _ => false,\n        }\n    }\n\n    /// Returns true if and only if this kind has any (including possibly\n    /// empty) subexpressions.\n    pub fn has_subexprs(&self) -> bool {\n        match *self {\n            HirKind::Empty\n            | HirKind::Literal(_)\n            | HirKind::Class(_)\n            | HirKind::Anchor(_)\n            | HirKind::WordBoundary(_) => false,\n            HirKind::Group(_)\n            | HirKind::Repetition(_)\n            | HirKind::Concat(_)\n            | HirKind::Alternation(_) => true,\n        }\n    }\n}\n\n/// Print a display representation of this Hir.\n///\n/// The result of this is a valid regular expression pattern string.\n///\n/// This implementation uses constant stack space and heap space proportional\n/// to the size of the `Hir`.\nimpl fmt::Display for Hir {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        use hir::print::Printer;\n        Printer::new().print(self, f)\n    }\n}\n\n/// The high-level intermediate representation of a literal.\n///\n/// A literal corresponds to a single character, where a character is either\n/// defined by a Unicode scalar value or an arbitrary byte. Unicode characters\n/// are preferred whenever possible. In particular, a `Byte` variant is only\n/// ever produced when it could match invalid UTF-8.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum Literal {\n    /// A single character represented by a Unicode scalar value.\n    Unicode(char),\n    /// A single character represented by an arbitrary byte.\n    Byte(u8),\n}\n\nimpl Literal {\n    /// Returns true if and only if this literal corresponds to a Unicode\n    /// scalar value.\n    pub fn is_unicode(&self) -> bool {\n        match *self {\n            Literal::Unicode(_) => true,\n            Literal::Byte(b) if b <= 0x7F => true,\n            Literal::Byte(_) => false,\n        }\n    }\n}\n\n/// The high-level intermediate representation of a character class.\n///\n/// A character class corresponds to a set of characters. A character is either\n/// defined by a Unicode scalar value or a byte. Unicode characters are used\n/// by default, while bytes are used when Unicode mode (via the `u` flag) is\n/// disabled.\n///\n/// A character class, regardless of its character type, is represented by a\n/// sequence of non-overlapping non-adjacent ranges of characters.\n///\n/// Note that unlike [`Literal`](enum.Literal.html), a `Bytes` variant may\n/// be produced even when it exclusively matches valid UTF-8. This is because\n/// a `Bytes` variant represents an intention by the author of the regular\n/// expression to disable Unicode mode, which in turn impacts the semantics of\n/// case insensitive matching. For example, `(?i)k` and `(?i-u)k` will not\n/// match the same set of strings.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum Class {\n    /// A set of characters represented by Unicode scalar values.\n    Unicode(ClassUnicode),\n    /// A set of characters represented by arbitrary bytes (one byte per\n    /// character).\n    Bytes(ClassBytes),\n}\n\nimpl Class {\n    /// Apply Unicode simple case folding to this character class, in place.\n    /// The character class will be expanded to include all simple case folded\n    /// character variants.\n    ///\n    /// If this is a byte oriented character class, then this will be limited\n    /// to the ASCII ranges `A-Z` and `a-z`.\n    pub fn case_fold_simple(&mut self) {\n        match *self {\n            Class::Unicode(ref mut x) => x.case_fold_simple(),\n            Class::Bytes(ref mut x) => x.case_fold_simple(),\n        }\n    }\n\n    /// Negate this character class in place.\n    ///\n    /// After completion, this character class will contain precisely the\n    /// characters that weren't previously in the class.\n    pub fn negate(&mut self) {\n        match *self {\n            Class::Unicode(ref mut x) => x.negate(),\n            Class::Bytes(ref mut x) => x.negate(),\n        }\n    }\n\n    /// Returns true if and only if this character class will only ever match\n    /// valid UTF-8.\n    ///\n    /// A character class can match invalid UTF-8 only when the following\n    /// conditions are met:\n    ///\n    /// 1. The translator was configured to permit generating an expression\n    ///    that can match invalid UTF-8. (By default, this is disabled.)\n    /// 2. Unicode mode (via the `u` flag) was disabled either in the concrete\n    ///    syntax or in the parser builder. By default, Unicode mode is\n    ///    enabled.\n    pub fn is_always_utf8(&self) -> bool {\n        match *self {\n            Class::Unicode(_) => true,\n            Class::Bytes(ref x) => x.is_all_ascii(),\n        }\n    }\n}\n\n/// A set of characters represented by Unicode scalar values.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassUnicode {\n    set: IntervalSet<ClassUnicodeRange>,\n}\n\nimpl ClassUnicode {\n    /// Create a new class from a sequence of ranges.\n    ///\n    /// The given ranges do not need to be in any specific order, and ranges\n    /// may overlap.\n    pub fn new<I>(ranges: I) -> ClassUnicode\n    where\n        I: IntoIterator<Item = ClassUnicodeRange>,\n    {\n        ClassUnicode { set: IntervalSet::new(ranges) }\n    }\n\n    /// Create a new class with no ranges.\n    pub fn empty() -> ClassUnicode {\n        ClassUnicode::new(vec![])\n    }\n\n    /// Add a new range to this set.\n    pub fn push(&mut self, range: ClassUnicodeRange) {\n        self.set.push(range);\n    }\n\n    /// Return an iterator over all ranges in this class.\n    ///\n    /// The iterator yields ranges in ascending order.\n    pub fn iter(&self) -> ClassUnicodeIter {\n        ClassUnicodeIter(self.set.iter())\n    }\n\n    /// Return the underlying ranges as a slice.\n    pub fn ranges(&self) -> &[ClassUnicodeRange] {\n        self.set.intervals()\n    }\n\n    /// Expand this character class such that it contains all case folded\n    /// characters, according to Unicode's \"simple\" mapping. For example, if\n    /// this class consists of the range `a-z`, then applying case folding will\n    /// result in the class containing both the ranges `a-z` and `A-Z`.\n    ///\n    /// # Panics\n    ///\n    /// This routine panics when the case mapping data necessary for this\n    /// routine to complete is unavailable. This occurs when the `unicode-case`\n    /// feature is not enabled.\n    ///\n    /// Callers should prefer using `try_case_fold_simple` instead, which will\n    /// return an error instead of panicking.\n    pub fn case_fold_simple(&mut self) {\n        self.set\n            .case_fold_simple()\n            .expect(\"unicode-case feature must be enabled\");\n    }\n\n    /// Expand this character class such that it contains all case folded\n    /// characters, according to Unicode's \"simple\" mapping. For example, if\n    /// this class consists of the range `a-z`, then applying case folding will\n    /// result in the class containing both the ranges `a-z` and `A-Z`.\n    ///\n    /// # Error\n    ///\n    /// This routine returns an error when the case mapping data necessary\n    /// for this routine to complete is unavailable. This occurs when the\n    /// `unicode-case` feature is not enabled.\n    pub fn try_case_fold_simple(\n        &mut self,\n    ) -> result::Result<(), CaseFoldError> {\n        self.set.case_fold_simple()\n    }\n\n    /// Negate this character class.\n    ///\n    /// For all `c` where `c` is a Unicode scalar value, if `c` was in this\n    /// set, then it will not be in this set after negation.\n    pub fn negate(&mut self) {\n        self.set.negate();\n    }\n\n    /// Union this character class with the given character class, in place.\n    pub fn union(&mut self, other: &ClassUnicode) {\n        self.set.union(&other.set);\n    }\n\n    /// Intersect this character class with the given character class, in\n    /// place.\n    pub fn intersect(&mut self, other: &ClassUnicode) {\n        self.set.intersect(&other.set);\n    }\n\n    /// Subtract the given character class from this character class, in place.\n    pub fn difference(&mut self, other: &ClassUnicode) {\n        self.set.difference(&other.set);\n    }\n\n    /// Compute the symmetric difference of the given character classes, in\n    /// place.\n    ///\n    /// This computes the symmetric difference of two character classes. This\n    /// removes all elements in this class that are also in the given class,\n    /// but all adds all elements from the given class that aren't in this\n    /// class. That is, the class will contain all elements in either class,\n    /// but will not contain any elements that are in both classes.\n    pub fn symmetric_difference(&mut self, other: &ClassUnicode) {\n        self.set.symmetric_difference(&other.set);\n    }\n\n    /// Returns true if and only if this character class will either match\n    /// nothing or only ASCII bytes. Stated differently, this returns false\n    /// if and only if this class contains a non-ASCII codepoint.\n    pub fn is_all_ascii(&self) -> bool {\n        self.set.intervals().last().map_or(true, |r| r.end <= '\\x7F')\n    }\n}\n\n/// An iterator over all ranges in a Unicode character class.\n///\n/// The lifetime `'a` refers to the lifetime of the underlying class.\n#[derive(Debug)]\npub struct ClassUnicodeIter<'a>(IntervalSetIter<'a, ClassUnicodeRange>);\n\nimpl<'a> Iterator for ClassUnicodeIter<'a> {\n    type Item = &'a ClassUnicodeRange;\n\n    fn next(&mut self) -> Option<&'a ClassUnicodeRange> {\n        self.0.next()\n    }\n}\n\n/// A single range of characters represented by Unicode scalar values.\n///\n/// The range is closed. That is, the start and end of the range are included\n/// in the range.\n#[derive(Clone, Copy, Default, Eq, PartialEq, PartialOrd, Ord)]\npub struct ClassUnicodeRange {\n    start: char,\n    end: char,\n}\n\nimpl fmt::Debug for ClassUnicodeRange {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let start = if !self.start.is_whitespace() && !self.start.is_control()\n        {\n            self.start.to_string()\n        } else {\n            format!(\"0x{:X}\", self.start as u32)\n        };\n        let end = if !self.end.is_whitespace() && !self.end.is_control() {\n            self.end.to_string()\n        } else {\n            format!(\"0x{:X}\", self.end as u32)\n        };\n        f.debug_struct(\"ClassUnicodeRange\")\n            .field(\"start\", &start)\n            .field(\"end\", &end)\n            .finish()\n    }\n}\n\nimpl Interval for ClassUnicodeRange {\n    type Bound = char;\n\n    #[inline]\n    fn lower(&self) -> char {\n        self.start\n    }\n    #[inline]\n    fn upper(&self) -> char {\n        self.end\n    }\n    #[inline]\n    fn set_lower(&mut self, bound: char) {\n        self.start = bound;\n    }\n    #[inline]\n    fn set_upper(&mut self, bound: char) {\n        self.end = bound;\n    }\n\n    /// Apply simple case folding to this Unicode scalar value range.\n    ///\n    /// Additional ranges are appended to the given vector. Canonical ordering\n    /// is *not* maintained in the given vector.\n    fn case_fold_simple(\n        &self,\n        ranges: &mut Vec<ClassUnicodeRange>,\n    ) -> Result<(), unicode::CaseFoldError> {\n        if !unicode::contains_simple_case_mapping(self.start, self.end)? {\n            return Ok(());\n        }\n        let start = self.start as u32;\n        let end = (self.end as u32).saturating_add(1);\n        let mut next_simple_cp = None;\n        for cp in (start..end).filter_map(char::from_u32) {\n            if next_simple_cp.map_or(false, |next| cp < next) {\n                continue;\n            }\n            let it = match unicode::simple_fold(cp)? {\n                Ok(it) => it,\n                Err(next) => {\n                    next_simple_cp = next;\n                    continue;\n                }\n            };\n            for cp_folded in it {\n                ranges.push(ClassUnicodeRange::new(cp_folded, cp_folded));\n            }\n        }\n        Ok(())\n    }\n}\n\nimpl ClassUnicodeRange {\n    /// Create a new Unicode scalar value range for a character class.\n    ///\n    /// The returned range is always in a canonical form. That is, the range\n    /// returned always satisfies the invariant that `start <= end`.\n    pub fn new(start: char, end: char) -> ClassUnicodeRange {\n        ClassUnicodeRange::create(start, end)\n    }\n\n    /// Return the start of this range.\n    ///\n    /// The start of a range is always less than or equal to the end of the\n    /// range.\n    pub fn start(&self) -> char {\n        self.start\n    }\n\n    /// Return the end of this range.\n    ///\n    /// The end of a range is always greater than or equal to the start of the\n    /// range.\n    pub fn end(&self) -> char {\n        self.end\n    }\n}\n\n/// A set of characters represented by arbitrary bytes (where one byte\n/// corresponds to one character).\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassBytes {\n    set: IntervalSet<ClassBytesRange>,\n}\n\nimpl ClassBytes {\n    /// Create a new class from a sequence of ranges.\n    ///\n    /// The given ranges do not need to be in any specific order, and ranges\n    /// may overlap.\n    pub fn new<I>(ranges: I) -> ClassBytes\n    where\n        I: IntoIterator<Item = ClassBytesRange>,\n    {\n        ClassBytes { set: IntervalSet::new(ranges) }\n    }\n\n    /// Create a new class with no ranges.\n    pub fn empty() -> ClassBytes {\n        ClassBytes::new(vec![])\n    }\n\n    /// Add a new range to this set.\n    pub fn push(&mut self, range: ClassBytesRange) {\n        self.set.push(range);\n    }\n\n    /// Return an iterator over all ranges in this class.\n    ///\n    /// The iterator yields ranges in ascending order.\n    pub fn iter(&self) -> ClassBytesIter {\n        ClassBytesIter(self.set.iter())\n    }\n\n    /// Return the underlying ranges as a slice.\n    pub fn ranges(&self) -> &[ClassBytesRange] {\n        self.set.intervals()\n    }\n\n    /// Expand this character class such that it contains all case folded\n    /// characters. For example, if this class consists of the range `a-z`,\n    /// then applying case folding will result in the class containing both the\n    /// ranges `a-z` and `A-Z`.\n    ///\n    /// Note that this only applies ASCII case folding, which is limited to the\n    /// characters `a-z` and `A-Z`.\n    pub fn case_fold_simple(&mut self) {\n        self.set.case_fold_simple().expect(\"ASCII case folding never fails\");\n    }\n\n    /// Negate this byte class.\n    ///\n    /// For all `b` where `b` is a any byte, if `b` was in this set, then it\n    /// will not be in this set after negation.\n    pub fn negate(&mut self) {\n        self.set.negate();\n    }\n\n    /// Union this byte class with the given byte class, in place.\n    pub fn union(&mut self, other: &ClassBytes) {\n        self.set.union(&other.set);\n    }\n\n    /// Intersect this byte class with the given byte class, in place.\n    pub fn intersect(&mut self, other: &ClassBytes) {\n        self.set.intersect(&other.set);\n    }\n\n    /// Subtract the given byte class from this byte class, in place.\n    pub fn difference(&mut self, other: &ClassBytes) {\n        self.set.difference(&other.set);\n    }\n\n    /// Compute the symmetric difference of the given byte classes, in place.\n    ///\n    /// This computes the symmetric difference of two byte classes. This\n    /// removes all elements in this class that are also in the given class,\n    /// but all adds all elements from the given class that aren't in this\n    /// class. That is, the class will contain all elements in either class,\n    /// but will not contain any elements that are in both classes.\n    pub fn symmetric_difference(&mut self, other: &ClassBytes) {\n        self.set.symmetric_difference(&other.set);\n    }\n\n    /// Returns true if and only if this character class will either match\n    /// nothing or only ASCII bytes. Stated differently, this returns false\n    /// if and only if this class contains a non-ASCII byte.\n    pub fn is_all_ascii(&self) -> bool {\n        self.set.intervals().last().map_or(true, |r| r.end <= 0x7F)\n    }\n}\n\n/// An iterator over all ranges in a byte character class.\n///\n/// The lifetime `'a` refers to the lifetime of the underlying class.\n#[derive(Debug)]\npub struct ClassBytesIter<'a>(IntervalSetIter<'a, ClassBytesRange>);\n\nimpl<'a> Iterator for ClassBytesIter<'a> {\n    type Item = &'a ClassBytesRange;\n\n    fn next(&mut self) -> Option<&'a ClassBytesRange> {\n        self.0.next()\n    }\n}\n\n/// A single range of characters represented by arbitrary bytes.\n///\n/// The range is closed. That is, the start and end of the range are included\n/// in the range.\n#[derive(Clone, Copy, Default, Eq, PartialEq, PartialOrd, Ord)]\npub struct ClassBytesRange {\n    start: u8,\n    end: u8,\n}\n\nimpl Interval for ClassBytesRange {\n    type Bound = u8;\n\n    #[inline]\n    fn lower(&self) -> u8 {\n        self.start\n    }\n    #[inline]\n    fn upper(&self) -> u8 {\n        self.end\n    }\n    #[inline]\n    fn set_lower(&mut self, bound: u8) {\n        self.start = bound;\n    }\n    #[inline]\n    fn set_upper(&mut self, bound: u8) {\n        self.end = bound;\n    }\n\n    /// Apply simple case folding to this byte range. Only ASCII case mappings\n    /// (for a-z) are applied.\n    ///\n    /// Additional ranges are appended to the given vector. Canonical ordering\n    /// is *not* maintained in the given vector.\n    fn case_fold_simple(\n        &self,\n        ranges: &mut Vec<ClassBytesRange>,\n    ) -> Result<(), unicode::CaseFoldError> {\n        if !ClassBytesRange::new(b'a', b'z').is_intersection_empty(self) {\n            let lower = cmp::max(self.start, b'a');\n            let upper = cmp::min(self.end, b'z');\n            ranges.push(ClassBytesRange::new(lower - 32, upper - 32));\n        }\n        if !ClassBytesRange::new(b'A', b'Z').is_intersection_empty(self) {\n            let lower = cmp::max(self.start, b'A');\n            let upper = cmp::min(self.end, b'Z');\n            ranges.push(ClassBytesRange::new(lower + 32, upper + 32));\n        }\n        Ok(())\n    }\n}\n\nimpl ClassBytesRange {\n    /// Create a new byte range for a character class.\n    ///\n    /// The returned range is always in a canonical form. That is, the range\n    /// returned always satisfies the invariant that `start <= end`.\n    pub fn new(start: u8, end: u8) -> ClassBytesRange {\n        ClassBytesRange::create(start, end)\n    }\n\n    /// Return the start of this range.\n    ///\n    /// The start of a range is always less than or equal to the end of the\n    /// range.\n    pub fn start(&self) -> u8 {\n        self.start\n    }\n\n    /// Return the end of this range.\n    ///\n    /// The end of a range is always greater than or equal to the start of the\n    /// range.\n    pub fn end(&self) -> u8 {\n        self.end\n    }\n}\n\nimpl fmt::Debug for ClassBytesRange {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let mut debug = f.debug_struct(\"ClassBytesRange\");\n        if self.start <= 0x7F {\n            debug.field(\"start\", &(self.start as char));\n        } else {\n            debug.field(\"start\", &self.start);\n        }\n        if self.end <= 0x7F {\n            debug.field(\"end\", &(self.end as char));\n        } else {\n            debug.field(\"end\", &self.end);\n        }\n        debug.finish()\n    }\n}\n\n/// The high-level intermediate representation for an anchor assertion.\n///\n/// A matching anchor assertion is always zero-length.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum Anchor {\n    /// Match the beginning of a line or the beginning of text. Specifically,\n    /// this matches at the starting position of the input, or at the position\n    /// immediately following a `\\n` character.\n    StartLine,\n    /// Match the end of a line or the end of text. Specifically,\n    /// this matches at the end position of the input, or at the position\n    /// immediately preceding a `\\n` character.\n    EndLine,\n    /// Match the beginning of text. Specifically, this matches at the starting\n    /// position of the input.\n    StartText,\n    /// Match the end of text. Specifically, this matches at the ending\n    /// position of the input.\n    EndText,\n}\n\n/// The high-level intermediate representation for a word-boundary assertion.\n///\n/// A matching word boundary assertion is always zero-length.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum WordBoundary {\n    /// Match a Unicode-aware word boundary. That is, this matches a position\n    /// where the left adjacent character and right adjacent character\n    /// correspond to a word and non-word or a non-word and word character.\n    Unicode,\n    /// Match a Unicode-aware negation of a word boundary.\n    UnicodeNegate,\n    /// Match an ASCII-only word boundary. That is, this matches a position\n    /// where the left adjacent character and right adjacent character\n    /// correspond to a word and non-word or a non-word and word character.\n    Ascii,\n    /// Match an ASCII-only negation of a word boundary.\n    AsciiNegate,\n}\n\nimpl WordBoundary {\n    /// Returns true if and only if this word boundary assertion is negated.\n    pub fn is_negated(&self) -> bool {\n        match *self {\n            WordBoundary::Unicode | WordBoundary::Ascii => false,\n            WordBoundary::UnicodeNegate | WordBoundary::AsciiNegate => true,\n        }\n    }\n}\n\n/// The high-level intermediate representation for a group.\n///\n/// This represents one of three possible group types:\n///\n/// 1. A non-capturing group (e.g., `(?:expr)`).\n/// 2. A capturing group (e.g., `(expr)`).\n/// 3. A named capturing group (e.g., `(?P<name>expr)`).\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Group {\n    /// The kind of this group. If it is a capturing group, then the kind\n    /// contains the capture group index (and the name, if it is a named\n    /// group).\n    pub kind: GroupKind,\n    /// The expression inside the capturing group, which may be empty.\n    pub hir: Box<Hir>,\n}\n\n/// The kind of group.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum GroupKind {\n    /// A normal unnamed capturing group.\n    ///\n    /// The value is the capture index of the group.\n    CaptureIndex(u32),\n    /// A named capturing group.\n    CaptureName {\n        /// The name of the group.\n        name: String,\n        /// The capture index of the group.\n        index: u32,\n    },\n    /// A non-capturing group.\n    NonCapturing,\n}\n\n/// The high-level intermediate representation of a repetition operator.\n///\n/// A repetition operator permits the repetition of an arbitrary\n/// sub-expression.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Repetition {\n    /// The kind of this repetition operator.\n    pub kind: RepetitionKind,\n    /// Whether this repetition operator is greedy or not. A greedy operator\n    /// will match as much as it can. A non-greedy operator will match as\n    /// little as it can.\n    ///\n    /// Typically, operators are greedy by default and are only non-greedy when\n    /// a `?` suffix is used, e.g., `(expr)*` is greedy while `(expr)*?` is\n    /// not. However, this can be inverted via the `U` \"ungreedy\" flag.\n    pub greedy: bool,\n    /// The expression being repeated.\n    pub hir: Box<Hir>,\n}\n\nimpl Repetition {\n    /// Returns true if and only if this repetition operator makes it possible\n    /// to match the empty string.\n    ///\n    /// Note that this is not defined inductively. For example, while `a*`\n    /// will report `true`, `()+` will not, even though `()` matches the empty\n    /// string and one or more occurrences of something that matches the empty\n    /// string will always match the empty string. In order to get the\n    /// inductive definition, see the corresponding method on\n    /// [`Hir`](struct.Hir.html).\n    pub fn is_match_empty(&self) -> bool {\n        match self.kind {\n            RepetitionKind::ZeroOrOne => true,\n            RepetitionKind::ZeroOrMore => true,\n            RepetitionKind::OneOrMore => false,\n            RepetitionKind::Range(RepetitionRange::Exactly(m)) => m == 0,\n            RepetitionKind::Range(RepetitionRange::AtLeast(m)) => m == 0,\n            RepetitionKind::Range(RepetitionRange::Bounded(m, _)) => m == 0,\n        }\n    }\n}\n\n/// The kind of a repetition operator.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum RepetitionKind {\n    /// Matches a sub-expression zero or one times.\n    ZeroOrOne,\n    /// Matches a sub-expression zero or more times.\n    ZeroOrMore,\n    /// Matches a sub-expression one or more times.\n    OneOrMore,\n    /// Matches a sub-expression within a bounded range of times.\n    Range(RepetitionRange),\n}\n\n/// The kind of a counted repetition operator.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum RepetitionRange {\n    /// Matches a sub-expression exactly this many times.\n    Exactly(u32),\n    /// Matches a sub-expression at least this many times.\n    AtLeast(u32),\n    /// Matches a sub-expression at least `m` times and at most `n` times.\n    Bounded(u32, u32),\n}\n\n/// A custom `Drop` impl is used for `HirKind` such that it uses constant stack\n/// space but heap space proportional to the depth of the total `Hir`.\nimpl Drop for Hir {\n    fn drop(&mut self) {\n        use std::mem;\n\n        match *self.kind() {\n            HirKind::Empty\n            | HirKind::Literal(_)\n            | HirKind::Class(_)\n            | HirKind::Anchor(_)\n            | HirKind::WordBoundary(_) => return,\n            HirKind::Group(ref x) if !x.hir.kind.has_subexprs() => return,\n            HirKind::Repetition(ref x) if !x.hir.kind.has_subexprs() => return,\n            HirKind::Concat(ref x) if x.is_empty() => return,\n            HirKind::Alternation(ref x) if x.is_empty() => return,\n            _ => {}\n        }\n\n        let mut stack = vec![mem::replace(self, Hir::empty())];\n        while let Some(mut expr) = stack.pop() {\n            match expr.kind {\n                HirKind::Empty\n                | HirKind::Literal(_)\n                | HirKind::Class(_)\n                | HirKind::Anchor(_)\n                | HirKind::WordBoundary(_) => {}\n                HirKind::Group(ref mut x) => {\n                    stack.push(mem::replace(&mut x.hir, Hir::empty()));\n                }\n                HirKind::Repetition(ref mut x) => {\n                    stack.push(mem::replace(&mut x.hir, Hir::empty()));\n                }\n                HirKind::Concat(ref mut x) => {\n                    stack.extend(x.drain(..));\n                }\n                HirKind::Alternation(ref mut x) => {\n                    stack.extend(x.drain(..));\n                }\n            }\n        }\n    }\n}\n\n/// A type that documents various attributes of an HIR expression.\n///\n/// These attributes are typically defined inductively on the HIR.\n#[derive(Clone, Debug, Eq, PartialEq)]\nstruct HirInfo {\n    /// Represent yes/no questions by a bitfield to conserve space, since\n    /// this is included in every HIR expression.\n    ///\n    /// If more attributes need to be added, it is OK to increase the size of\n    /// this as appropriate.\n    bools: u16,\n}\n\n// A simple macro for defining bitfield accessors/mutators.\nmacro_rules! define_bool {\n    ($bit:expr, $is_fn_name:ident, $set_fn_name:ident) => {\n        fn $is_fn_name(&self) -> bool {\n            self.bools & (0b1 << $bit) > 0\n        }\n\n        fn $set_fn_name(&mut self, yes: bool) {\n            if yes {\n                self.bools |= 1 << $bit;\n            } else {\n                self.bools &= !(1 << $bit);\n            }\n        }\n    };\n}\n\nimpl HirInfo {\n    fn new() -> HirInfo {\n        HirInfo { bools: 0 }\n    }\n\n    define_bool!(0, is_always_utf8, set_always_utf8);\n    define_bool!(1, is_all_assertions, set_all_assertions);\n    define_bool!(2, is_anchored_start, set_anchored_start);\n    define_bool!(3, is_anchored_end, set_anchored_end);\n    define_bool!(4, is_line_anchored_start, set_line_anchored_start);\n    define_bool!(5, is_line_anchored_end, set_line_anchored_end);\n    define_bool!(6, is_any_anchored_start, set_any_anchored_start);\n    define_bool!(7, is_any_anchored_end, set_any_anchored_end);\n    define_bool!(8, is_match_empty, set_match_empty);\n    define_bool!(9, is_literal, set_literal);\n    define_bool!(10, is_alternation_literal, set_alternation_literal);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn uclass(ranges: &[(char, char)]) -> ClassUnicode {\n        let ranges: Vec<ClassUnicodeRange> = ranges\n            .iter()\n            .map(|&(s, e)| ClassUnicodeRange::new(s, e))\n            .collect();\n        ClassUnicode::new(ranges)\n    }\n\n    fn bclass(ranges: &[(u8, u8)]) -> ClassBytes {\n        let ranges: Vec<ClassBytesRange> =\n            ranges.iter().map(|&(s, e)| ClassBytesRange::new(s, e)).collect();\n        ClassBytes::new(ranges)\n    }\n\n    fn uranges(cls: &ClassUnicode) -> Vec<(char, char)> {\n        cls.iter().map(|x| (x.start(), x.end())).collect()\n    }\n\n    #[cfg(feature = \"unicode-case\")]\n    fn ucasefold(cls: &ClassUnicode) -> ClassUnicode {\n        let mut cls_ = cls.clone();\n        cls_.case_fold_simple();\n        cls_\n    }\n\n    fn uunion(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n        let mut cls_ = cls1.clone();\n        cls_.union(cls2);\n        cls_\n    }\n\n    fn uintersect(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n        let mut cls_ = cls1.clone();\n        cls_.intersect(cls2);\n        cls_\n    }\n\n    fn udifference(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n        let mut cls_ = cls1.clone();\n        cls_.difference(cls2);\n        cls_\n    }\n\n    fn usymdifference(\n        cls1: &ClassUnicode,\n        cls2: &ClassUnicode,\n    ) -> ClassUnicode {\n        let mut cls_ = cls1.clone();\n        cls_.symmetric_difference(cls2);\n        cls_\n    }\n\n    fn unegate(cls: &ClassUnicode) -> ClassUnicode {\n        let mut cls_ = cls.clone();\n        cls_.negate();\n        cls_\n    }\n\n    fn branges(cls: &ClassBytes) -> Vec<(u8, u8)> {\n        cls.iter().map(|x| (x.start(), x.end())).collect()\n    }\n\n    fn bcasefold(cls: &ClassBytes) -> ClassBytes {\n        let mut cls_ = cls.clone();\n        cls_.case_fold_simple();\n        cls_\n    }\n\n    fn bunion(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n        let mut cls_ = cls1.clone();\n        cls_.union(cls2);\n        cls_\n    }\n\n    fn bintersect(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n        let mut cls_ = cls1.clone();\n        cls_.intersect(cls2);\n        cls_\n    }\n\n    fn bdifference(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n        let mut cls_ = cls1.clone();\n        cls_.difference(cls2);\n        cls_\n    }\n\n    fn bsymdifference(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n        let mut cls_ = cls1.clone();\n        cls_.symmetric_difference(cls2);\n        cls_\n    }\n\n    fn bnegate(cls: &ClassBytes) -> ClassBytes {\n        let mut cls_ = cls.clone();\n        cls_.negate();\n        cls_\n    }\n\n    #[test]\n    fn class_range_canonical_unicode() {\n        let range = ClassUnicodeRange::new('\\u{00FF}', '\\0');\n        assert_eq!('\\0', range.start());\n        assert_eq!('\\u{00FF}', range.end());\n    }\n\n    #[test]\n    fn class_range_canonical_bytes() {\n        let range = ClassBytesRange::new(b'\\xFF', b'\\0');\n        assert_eq!(b'\\0', range.start());\n        assert_eq!(b'\\xFF', range.end());\n    }\n\n    #[test]\n    fn class_canonicalize_unicode() {\n        let cls = uclass(&[('a', 'c'), ('x', 'z')]);\n        let expected = vec![('a', 'c'), ('x', 'z')];\n        assert_eq!(expected, uranges(&cls));\n\n        let cls = uclass(&[('x', 'z'), ('a', 'c')]);\n        let expected = vec![('a', 'c'), ('x', 'z')];\n        assert_eq!(expected, uranges(&cls));\n\n        let cls = uclass(&[('x', 'z'), ('w', 'y')]);\n        let expected = vec![('w', 'z')];\n        assert_eq!(expected, uranges(&cls));\n\n        let cls = uclass(&[\n            ('c', 'f'),\n            ('a', 'g'),\n            ('d', 'j'),\n            ('a', 'c'),\n            ('m', 'p'),\n            ('l', 's'),\n        ]);\n        let expected = vec![('a', 'j'), ('l', 's')];\n        assert_eq!(expected, uranges(&cls));\n\n        let cls = uclass(&[('x', 'z'), ('u', 'w')]);\n        let expected = vec![('u', 'z')];\n        assert_eq!(expected, uranges(&cls));\n\n        let cls = uclass(&[('\\x00', '\\u{10FFFF}'), ('\\x00', '\\u{10FFFF}')]);\n        let expected = vec![('\\x00', '\\u{10FFFF}')];\n        assert_eq!(expected, uranges(&cls));\n\n        let cls = uclass(&[('a', 'a'), ('b', 'b')]);\n        let expected = vec![('a', 'b')];\n        assert_eq!(expected, uranges(&cls));\n    }\n\n    #[test]\n    fn class_canonicalize_bytes() {\n        let cls = bclass(&[(b'a', b'c'), (b'x', b'z')]);\n        let expected = vec![(b'a', b'c'), (b'x', b'z')];\n        assert_eq!(expected, branges(&cls));\n\n        let cls = bclass(&[(b'x', b'z'), (b'a', b'c')]);\n        let expected = vec![(b'a', b'c'), (b'x', b'z')];\n        assert_eq!(expected, branges(&cls));\n\n        let cls = bclass(&[(b'x', b'z'), (b'w', b'y')]);\n        let expected = vec![(b'w', b'z')];\n        assert_eq!(expected, branges(&cls));\n\n        let cls = bclass(&[\n            (b'c', b'f'),\n            (b'a', b'g'),\n            (b'd', b'j'),\n            (b'a', b'c'),\n            (b'm', b'p'),\n            (b'l', b's'),\n        ]);\n        let expected = vec![(b'a', b'j'), (b'l', b's')];\n        assert_eq!(expected, branges(&cls));\n\n        let cls = bclass(&[(b'x', b'z'), (b'u', b'w')]);\n        let expected = vec![(b'u', b'z')];\n        assert_eq!(expected, branges(&cls));\n\n        let cls = bclass(&[(b'\\x00', b'\\xFF'), (b'\\x00', b'\\xFF')]);\n        let expected = vec![(b'\\x00', b'\\xFF')];\n        assert_eq!(expected, branges(&cls));\n\n        let cls = bclass(&[(b'a', b'a'), (b'b', b'b')]);\n        let expected = vec![(b'a', b'b')];\n        assert_eq!(expected, branges(&cls));\n    }\n\n    #[test]\n    #[cfg(feature = \"unicode-case\")]\n    fn class_case_fold_unicode() {\n        let cls = uclass(&[\n            ('C', 'F'),\n            ('A', 'G'),\n            ('D', 'J'),\n            ('A', 'C'),\n            ('M', 'P'),\n            ('L', 'S'),\n            ('c', 'f'),\n        ]);\n        let expected = uclass(&[\n            ('A', 'J'),\n            ('L', 'S'),\n            ('a', 'j'),\n            ('l', 's'),\n            ('\\u{17F}', '\\u{17F}'),\n        ]);\n        assert_eq!(expected, ucasefold(&cls));\n\n        let cls = uclass(&[('A', 'Z')]);\n        let expected = uclass(&[\n            ('A', 'Z'),\n            ('a', 'z'),\n            ('\\u{17F}', '\\u{17F}'),\n            ('\\u{212A}', '\\u{212A}'),\n        ]);\n        assert_eq!(expected, ucasefold(&cls));\n\n        let cls = uclass(&[('a', 'z')]);\n        let expected = uclass(&[\n            ('A', 'Z'),\n            ('a', 'z'),\n            ('\\u{17F}', '\\u{17F}'),\n            ('\\u{212A}', '\\u{212A}'),\n        ]);\n        assert_eq!(expected, ucasefold(&cls));\n\n        let cls = uclass(&[('A', 'A'), ('_', '_')]);\n        let expected = uclass(&[('A', 'A'), ('_', '_'), ('a', 'a')]);\n        assert_eq!(expected, ucasefold(&cls));\n\n        let cls = uclass(&[('A', 'A'), ('=', '=')]);\n        let expected = uclass(&[('=', '='), ('A', 'A'), ('a', 'a')]);\n        assert_eq!(expected, ucasefold(&cls));\n\n        let cls = uclass(&[('\\x00', '\\x10')]);\n        assert_eq!(cls, ucasefold(&cls));\n\n        let cls = uclass(&[('k', 'k')]);\n        let expected =\n            uclass(&[('K', 'K'), ('k', 'k'), ('\\u{212A}', '\\u{212A}')]);\n        assert_eq!(expected, ucasefold(&cls));\n\n        let cls = uclass(&[('@', '@')]);\n        assert_eq!(cls, ucasefold(&cls));\n    }\n\n    #[test]\n    #[cfg(not(feature = \"unicode-case\"))]\n    fn class_case_fold_unicode_disabled() {\n        let mut cls = uclass(&[\n            ('C', 'F'),\n            ('A', 'G'),\n            ('D', 'J'),\n            ('A', 'C'),\n            ('M', 'P'),\n            ('L', 'S'),\n            ('c', 'f'),\n        ]);\n        assert!(cls.try_case_fold_simple().is_err());\n    }\n\n    #[test]\n    #[should_panic]\n    #[cfg(not(feature = \"unicode-case\"))]\n    fn class_case_fold_unicode_disabled_panics() {\n        let mut cls = uclass(&[\n            ('C', 'F'),\n            ('A', 'G'),\n            ('D', 'J'),\n            ('A', 'C'),\n            ('M', 'P'),\n            ('L', 'S'),\n            ('c', 'f'),\n        ]);\n        cls.case_fold_simple();\n    }\n\n    #[test]\n    fn class_case_fold_bytes() {\n        let cls = bclass(&[\n            (b'C', b'F'),\n            (b'A', b'G'),\n            (b'D', b'J'),\n            (b'A', b'C'),\n            (b'M', b'P'),\n            (b'L', b'S'),\n            (b'c', b'f'),\n        ]);\n        let expected =\n            bclass(&[(b'A', b'J'), (b'L', b'S'), (b'a', b'j'), (b'l', b's')]);\n        assert_eq!(expected, bcasefold(&cls));\n\n        let cls = bclass(&[(b'A', b'Z')]);\n        let expected = bclass(&[(b'A', b'Z'), (b'a', b'z')]);\n        assert_eq!(expected, bcasefold(&cls));\n\n        let cls = bclass(&[(b'a', b'z')]);\n        let expected = bclass(&[(b'A', b'Z'), (b'a', b'z')]);\n        assert_eq!(expected, bcasefold(&cls));\n\n        let cls = bclass(&[(b'A', b'A'), (b'_', b'_')]);\n        let expected = bclass(&[(b'A', b'A'), (b'_', b'_'), (b'a', b'a')]);\n        assert_eq!(expected, bcasefold(&cls));\n\n        let cls = bclass(&[(b'A', b'A'), (b'=', b'=')]);\n        let expected = bclass(&[(b'=', b'='), (b'A', b'A'), (b'a', b'a')]);\n        assert_eq!(expected, bcasefold(&cls));\n\n        let cls = bclass(&[(b'\\x00', b'\\x10')]);\n        assert_eq!(cls, bcasefold(&cls));\n\n        let cls = bclass(&[(b'k', b'k')]);\n        let expected = bclass(&[(b'K', b'K'), (b'k', b'k')]);\n        assert_eq!(expected, bcasefold(&cls));\n\n        let cls = bclass(&[(b'@', b'@')]);\n        assert_eq!(cls, bcasefold(&cls));\n    }\n\n    #[test]\n    fn class_negate_unicode() {\n        let cls = uclass(&[('a', 'a')]);\n        let expected = uclass(&[('\\x00', '\\x60'), ('\\x62', '\\u{10FFFF}')]);\n        assert_eq!(expected, unegate(&cls));\n\n        let cls = uclass(&[('a', 'a'), ('b', 'b')]);\n        let expected = uclass(&[('\\x00', '\\x60'), ('\\x63', '\\u{10FFFF}')]);\n        assert_eq!(expected, unegate(&cls));\n\n        let cls = uclass(&[('a', 'c'), ('x', 'z')]);\n        let expected = uclass(&[\n            ('\\x00', '\\x60'),\n            ('\\x64', '\\x77'),\n            ('\\x7B', '\\u{10FFFF}'),\n        ]);\n        assert_eq!(expected, unegate(&cls));\n\n        let cls = uclass(&[('\\x00', 'a')]);\n        let expected = uclass(&[('\\x62', '\\u{10FFFF}')]);\n        assert_eq!(expected, unegate(&cls));\n\n        let cls = uclass(&[('a', '\\u{10FFFF}')]);\n        let expected = uclass(&[('\\x00', '\\x60')]);\n        assert_eq!(expected, unegate(&cls));\n\n        let cls = uclass(&[('\\x00', '\\u{10FFFF}')]);\n        let expected = uclass(&[]);\n        assert_eq!(expected, unegate(&cls));\n\n        let cls = uclass(&[]);\n        let expected = uclass(&[('\\x00', '\\u{10FFFF}')]);\n        assert_eq!(expected, unegate(&cls));\n\n        let cls =\n            uclass(&[('\\x00', '\\u{10FFFD}'), ('\\u{10FFFF}', '\\u{10FFFF}')]);\n        let expected = uclass(&[('\\u{10FFFE}', '\\u{10FFFE}')]);\n        assert_eq!(expected, unegate(&cls));\n\n        let cls = uclass(&[('\\x00', '\\u{D7FF}')]);\n        let expected = uclass(&[('\\u{E000}', '\\u{10FFFF}')]);\n        assert_eq!(expected, unegate(&cls));\n\n        let cls = uclass(&[('\\x00', '\\u{D7FE}')]);\n        let expected = uclass(&[('\\u{D7FF}', '\\u{10FFFF}')]);\n        assert_eq!(expected, unegate(&cls));\n\n        let cls = uclass(&[('\\u{E000}', '\\u{10FFFF}')]);\n        let expected = uclass(&[('\\x00', '\\u{D7FF}')]);\n        assert_eq!(expected, unegate(&cls));\n\n        let cls = uclass(&[('\\u{E001}', '\\u{10FFFF}')]);\n        let expected = uclass(&[('\\x00', '\\u{E000}')]);\n        assert_eq!(expected, unegate(&cls));\n    }\n\n    #[test]\n    fn class_negate_bytes() {\n        let cls = bclass(&[(b'a', b'a')]);\n        let expected = bclass(&[(b'\\x00', b'\\x60'), (b'\\x62', b'\\xFF')]);\n        assert_eq!(expected, bnegate(&cls));\n\n        let cls = bclass(&[(b'a', b'a'), (b'b', b'b')]);\n        let expected = bclass(&[(b'\\x00', b'\\x60'), (b'\\x63', b'\\xFF')]);\n        assert_eq!(expected, bnegate(&cls));\n\n        let cls = bclass(&[(b'a', b'c'), (b'x', b'z')]);\n        let expected = bclass(&[\n            (b'\\x00', b'\\x60'),\n            (b'\\x64', b'\\x77'),\n            (b'\\x7B', b'\\xFF'),\n        ]);\n        assert_eq!(expected, bnegate(&cls));\n\n        let cls = bclass(&[(b'\\x00', b'a')]);\n        let expected = bclass(&[(b'\\x62', b'\\xFF')]);\n        assert_eq!(expected, bnegate(&cls));\n\n        let cls = bclass(&[(b'a', b'\\xFF')]);\n        let expected = bclass(&[(b'\\x00', b'\\x60')]);\n        assert_eq!(expected, bnegate(&cls));\n\n        let cls = bclass(&[(b'\\x00', b'\\xFF')]);\n        let expected = bclass(&[]);\n        assert_eq!(expected, bnegate(&cls));\n\n        let cls = bclass(&[]);\n        let expected = bclass(&[(b'\\x00', b'\\xFF')]);\n        assert_eq!(expected, bnegate(&cls));\n\n        let cls = bclass(&[(b'\\x00', b'\\xFD'), (b'\\xFF', b'\\xFF')]);\n        let expected = bclass(&[(b'\\xFE', b'\\xFE')]);\n        assert_eq!(expected, bnegate(&cls));\n    }\n\n    #[test]\n    fn class_union_unicode() {\n        let cls1 = uclass(&[('a', 'g'), ('m', 't'), ('A', 'C')]);\n        let cls2 = uclass(&[('a', 'z')]);\n        let expected = uclass(&[('a', 'z'), ('A', 'C')]);\n        assert_eq!(expected, uunion(&cls1, &cls2));\n    }\n\n    #[test]\n    fn class_union_bytes() {\n        let cls1 = bclass(&[(b'a', b'g'), (b'm', b't'), (b'A', b'C')]);\n        let cls2 = bclass(&[(b'a', b'z')]);\n        let expected = bclass(&[(b'a', b'z'), (b'A', b'C')]);\n        assert_eq!(expected, bunion(&cls1, &cls2));\n    }\n\n    #[test]\n    fn class_intersect_unicode() {\n        let cls1 = uclass(&[]);\n        let cls2 = uclass(&[('a', 'a')]);\n        let expected = uclass(&[]);\n        assert_eq!(expected, uintersect(&cls1, &cls2));\n\n        let cls1 = uclass(&[('a', 'a')]);\n        let cls2 = uclass(&[('a', 'a')]);\n        let expected = uclass(&[('a', 'a')]);\n        assert_eq!(expected, uintersect(&cls1, &cls2));\n\n        let cls1 = uclass(&[('a', 'a')]);\n        let cls2 = uclass(&[('b', 'b')]);\n        let expected = uclass(&[]);\n        assert_eq!(expected, uintersect(&cls1, &cls2));\n\n        let cls1 = uclass(&[('a', 'a')]);\n        let cls2 = uclass(&[('a', 'c')]);\n        let expected = uclass(&[('a', 'a')]);\n        assert_eq!(expected, uintersect(&cls1, &cls2));\n\n        let cls1 = uclass(&[('a', 'b')]);\n        let cls2 = uclass(&[('a', 'c')]);\n        let expected = uclass(&[('a', 'b')]);\n        assert_eq!(expected, uintersect(&cls1, &cls2));\n\n        let cls1 = uclass(&[('a', 'b')]);\n        let cls2 = uclass(&[('b', 'c')]);\n        let expected = uclass(&[('b', 'b')]);\n        assert_eq!(expected, uintersect(&cls1, &cls2));\n\n        let cls1 = uclass(&[('a', 'b')]);\n        let cls2 = uclass(&[('c', 'd')]);\n        let expected = uclass(&[]);\n        assert_eq!(expected, uintersect(&cls1, &cls2));\n\n        let cls1 = uclass(&[('b', 'c')]);\n        let cls2 = uclass(&[('a', 'd')]);\n        let expected = uclass(&[('b', 'c')]);\n        assert_eq!(expected, uintersect(&cls1, &cls2));\n\n        let cls1 = uclass(&[('a', 'b'), ('d', 'e'), ('g', 'h')]);\n        let cls2 = uclass(&[('a', 'h')]);\n        let expected = uclass(&[('a', 'b'), ('d', 'e'), ('g', 'h')]);\n        assert_eq!(expected, uintersect(&cls1, &cls2));\n\n        let cls1 = uclass(&[('a', 'b'), ('d', 'e'), ('g', 'h')]);\n        let cls2 = uclass(&[('a', 'b'), ('d', 'e'), ('g', 'h')]);\n        let expected = uclass(&[('a', 'b'), ('d', 'e'), ('g', 'h')]);\n        assert_eq!(expected, uintersect(&cls1, &cls2));\n\n        let cls1 = uclass(&[('a', 'b'), ('g', 'h')]);\n        let cls2 = uclass(&[('d', 'e'), ('k', 'l')]);\n        let expected = uclass(&[]);\n        assert_eq!(expected, uintersect(&cls1, &cls2));\n\n        let cls1 = uclass(&[('a', 'b'), ('d', 'e'), ('g', 'h')]);\n        let cls2 = uclass(&[('h', 'h')]);\n        let expected = uclass(&[('h', 'h')]);\n        assert_eq!(expected, uintersect(&cls1, &cls2));\n\n        let cls1 = uclass(&[('a', 'b'), ('e', 'f'), ('i', 'j')]);\n        let cls2 = uclass(&[('c', 'd'), ('g', 'h'), ('k', 'l')]);\n        let expected = uclass(&[]);\n        assert_eq!(expected, uintersect(&cls1, &cls2));\n\n        let cls1 = uclass(&[('a', 'b'), ('c', 'd'), ('e', 'f')]);\n        let cls2 = uclass(&[('b', 'c'), ('d', 'e'), ('f', 'g')]);\n        let expected = uclass(&[('b', 'f')]);\n        assert_eq!(expected, uintersect(&cls1, &cls2));\n    }\n\n    #[test]\n    fn class_intersect_bytes() {\n        let cls1 = bclass(&[]);\n        let cls2 = bclass(&[(b'a', b'a')]);\n        let expected = bclass(&[]);\n        assert_eq!(expected, bintersect(&cls1, &cls2));\n\n        let cls1 = bclass(&[(b'a', b'a')]);\n        let cls2 = bclass(&[(b'a', b'a')]);\n        let expected = bclass(&[(b'a', b'a')]);\n        assert_eq!(expected, bintersect(&cls1, &cls2));\n\n        let cls1 = bclass(&[(b'a', b'a')]);\n        let cls2 = bclass(&[(b'b', b'b')]);\n        let expected = bclass(&[]);\n        assert_eq!(expected, bintersect(&cls1, &cls2));\n\n        let cls1 = bclass(&[(b'a', b'a')]);\n        let cls2 = bclass(&[(b'a', b'c')]);\n        let expected = bclass(&[(b'a', b'a')]);\n        assert_eq!(expected, bintersect(&cls1, &cls2));\n\n        let cls1 = bclass(&[(b'a', b'b')]);\n        let cls2 = bclass(&[(b'a', b'c')]);\n        let expected = bclass(&[(b'a', b'b')]);\n        assert_eq!(expected, bintersect(&cls1, &cls2));\n\n        let cls1 = bclass(&[(b'a', b'b')]);\n        let cls2 = bclass(&[(b'b', b'c')]);\n        let expected = bclass(&[(b'b', b'b')]);\n        assert_eq!(expected, bintersect(&cls1, &cls2));\n\n        let cls1 = bclass(&[(b'a', b'b')]);\n        let cls2 = bclass(&[(b'c', b'd')]);\n        let expected = bclass(&[]);\n        assert_eq!(expected, bintersect(&cls1, &cls2));\n\n        let cls1 = bclass(&[(b'b', b'c')]);\n        let cls2 = bclass(&[(b'a', b'd')]);\n        let expected = bclass(&[(b'b', b'c')]);\n        assert_eq!(expected, bintersect(&cls1, &cls2));\n\n        let cls1 = bclass(&[(b'a', b'b'), (b'd', b'e'), (b'g', b'h')]);\n        let cls2 = bclass(&[(b'a', b'h')]);\n        let expected = bclass(&[(b'a', b'b'), (b'd', b'e'), (b'g', b'h')]);\n        assert_eq!(expected, bintersect(&cls1, &cls2));\n\n        let cls1 = bclass(&[(b'a', b'b'), (b'd', b'e'), (b'g', b'h')]);\n        let cls2 = bclass(&[(b'a', b'b'), (b'd', b'e'), (b'g', b'h')]);\n        let expected = bclass(&[(b'a', b'b'), (b'd', b'e'), (b'g', b'h')]);\n        assert_eq!(expected, bintersect(&cls1, &cls2));\n\n        let cls1 = bclass(&[(b'a', b'b'), (b'g', b'h')]);\n        let cls2 = bclass(&[(b'd', b'e'), (b'k', b'l')]);\n        let expected = bclass(&[]);\n        assert_eq!(expected, bintersect(&cls1, &cls2));\n\n        let cls1 = bclass(&[(b'a', b'b'), (b'd', b'e'), (b'g', b'h')]);\n        let cls2 = bclass(&[(b'h', b'h')]);\n        let expected = bclass(&[(b'h', b'h')]);\n        assert_eq!(expected, bintersect(&cls1, &cls2));\n\n        let cls1 = bclass(&[(b'a', b'b'), (b'e', b'f'), (b'i', b'j')]);\n        let cls2 = bclass(&[(b'c', b'd'), (b'g', b'h'), (b'k', b'l')]);\n        let expected = bclass(&[]);\n        assert_eq!(expected, bintersect(&cls1, &cls2));\n\n        let cls1 = bclass(&[(b'a', b'b'), (b'c', b'd'), (b'e', b'f')]);\n        let cls2 = bclass(&[(b'b', b'c'), (b'd', b'e'), (b'f', b'g')]);\n        let expected = bclass(&[(b'b', b'f')]);\n        assert_eq!(expected, bintersect(&cls1, &cls2));\n    }\n\n    #[test]\n    fn class_difference_unicode() {\n        let cls1 = uclass(&[('a', 'a')]);\n        let cls2 = uclass(&[('a', 'a')]);\n        let expected = uclass(&[]);\n        assert_eq!(expected, udifference(&cls1, &cls2));\n\n        let cls1 = uclass(&[('a', 'a')]);\n        let cls2 = uclass(&[]);\n        let expected = uclass(&[('a', 'a')]);\n        assert_eq!(expected, udifference(&cls1, &cls2));\n\n        let cls1 = uclass(&[]);\n        let cls2 = uclass(&[('a', 'a')]);\n        let expected = uclass(&[]);\n        assert_eq!(expected, udifference(&cls1, &cls2));\n\n        let cls1 = uclass(&[('a', 'z')]);\n        let cls2 = uclass(&[('a', 'a')]);\n        let expected = uclass(&[('b', 'z')]);\n        assert_eq!(expected, udifference(&cls1, &cls2));\n\n        let cls1 = uclass(&[('a', 'z')]);\n        let cls2 = uclass(&[('z', 'z')]);\n        let expected = uclass(&[('a', 'y')]);\n        assert_eq!(expected, udifference(&cls1, &cls2));\n\n        let cls1 = uclass(&[('a', 'z')]);\n        let cls2 = uclass(&[('m', 'm')]);\n        let expected = uclass(&[('a', 'l'), ('n', 'z')]);\n        assert_eq!(expected, udifference(&cls1, &cls2));\n\n        let cls1 = uclass(&[('a', 'c'), ('g', 'i'), ('r', 't')]);\n        let cls2 = uclass(&[('a', 'z')]);\n        let expected = uclass(&[]);\n        assert_eq!(expected, udifference(&cls1, &cls2));\n\n        let cls1 = uclass(&[('a', 'c'), ('g', 'i'), ('r', 't')]);\n        let cls2 = uclass(&[('d', 'v')]);\n        let expected = uclass(&[('a', 'c')]);\n        assert_eq!(expected, udifference(&cls1, &cls2));\n\n        let cls1 = uclass(&[('a', 'c'), ('g', 'i'), ('r', 't')]);\n        let cls2 = uclass(&[('b', 'g'), ('s', 'u')]);\n        let expected = uclass(&[('a', 'a'), ('h', 'i'), ('r', 'r')]);\n        assert_eq!(expected, udifference(&cls1, &cls2));\n\n        let cls1 = uclass(&[('a', 'c'), ('g', 'i'), ('r', 't')]);\n        let cls2 = uclass(&[('b', 'd'), ('e', 'g'), ('s', 'u')]);\n        let expected = uclass(&[('a', 'a'), ('h', 'i'), ('r', 'r')]);\n        assert_eq!(expected, udifference(&cls1, &cls2));\n\n        let cls1 = uclass(&[('x', 'z')]);\n        let cls2 = uclass(&[('a', 'c'), ('e', 'g'), ('s', 'u')]);\n        let expected = uclass(&[('x', 'z')]);\n        assert_eq!(expected, udifference(&cls1, &cls2));\n\n        let cls1 = uclass(&[('a', 'z')]);\n        let cls2 = uclass(&[('a', 'c'), ('e', 'g'), ('s', 'u')]);\n        let expected = uclass(&[('d', 'd'), ('h', 'r'), ('v', 'z')]);\n        assert_eq!(expected, udifference(&cls1, &cls2));\n    }\n\n    #[test]\n    fn class_difference_bytes() {\n        let cls1 = bclass(&[(b'a', b'a')]);\n        let cls2 = bclass(&[(b'a', b'a')]);\n        let expected = bclass(&[]);\n        assert_eq!(expected, bdifference(&cls1, &cls2));\n\n        let cls1 = bclass(&[(b'a', b'a')]);\n        let cls2 = bclass(&[]);\n        let expected = bclass(&[(b'a', b'a')]);\n        assert_eq!(expected, bdifference(&cls1, &cls2));\n\n        let cls1 = bclass(&[]);\n        let cls2 = bclass(&[(b'a', b'a')]);\n        let expected = bclass(&[]);\n        assert_eq!(expected, bdifference(&cls1, &cls2));\n\n        let cls1 = bclass(&[(b'a', b'z')]);\n        let cls2 = bclass(&[(b'a', b'a')]);\n        let expected = bclass(&[(b'b', b'z')]);\n        assert_eq!(expected, bdifference(&cls1, &cls2));\n\n        let cls1 = bclass(&[(b'a', b'z')]);\n        let cls2 = bclass(&[(b'z', b'z')]);\n        let expected = bclass(&[(b'a', b'y')]);\n        assert_eq!(expected, bdifference(&cls1, &cls2));\n\n        let cls1 = bclass(&[(b'a', b'z')]);\n        let cls2 = bclass(&[(b'm', b'm')]);\n        let expected = bclass(&[(b'a', b'l'), (b'n', b'z')]);\n        assert_eq!(expected, bdifference(&cls1, &cls2));\n\n        let cls1 = bclass(&[(b'a', b'c'), (b'g', b'i'), (b'r', b't')]);\n        let cls2 = bclass(&[(b'a', b'z')]);\n        let expected = bclass(&[]);\n        assert_eq!(expected, bdifference(&cls1, &cls2));\n\n        let cls1 = bclass(&[(b'a', b'c'), (b'g', b'i'), (b'r', b't')]);\n        let cls2 = bclass(&[(b'd', b'v')]);\n        let expected = bclass(&[(b'a', b'c')]);\n        assert_eq!(expected, bdifference(&cls1, &cls2));\n\n        let cls1 = bclass(&[(b'a', b'c'), (b'g', b'i'), (b'r', b't')]);\n        let cls2 = bclass(&[(b'b', b'g'), (b's', b'u')]);\n        let expected = bclass(&[(b'a', b'a'), (b'h', b'i'), (b'r', b'r')]);\n        assert_eq!(expected, bdifference(&cls1, &cls2));\n\n        let cls1 = bclass(&[(b'a', b'c'), (b'g', b'i'), (b'r', b't')]);\n        let cls2 = bclass(&[(b'b', b'd'), (b'e', b'g'), (b's', b'u')]);\n        let expected = bclass(&[(b'a', b'a'), (b'h', b'i'), (b'r', b'r')]);\n        assert_eq!(expected, bdifference(&cls1, &cls2));\n\n        let cls1 = bclass(&[(b'x', b'z')]);\n        let cls2 = bclass(&[(b'a', b'c'), (b'e', b'g'), (b's', b'u')]);\n        let expected = bclass(&[(b'x', b'z')]);\n        assert_eq!(expected, bdifference(&cls1, &cls2));\n\n        let cls1 = bclass(&[(b'a', b'z')]);\n        let cls2 = bclass(&[(b'a', b'c'), (b'e', b'g'), (b's', b'u')]);\n        let expected = bclass(&[(b'd', b'd'), (b'h', b'r'), (b'v', b'z')]);\n        assert_eq!(expected, bdifference(&cls1, &cls2));\n    }\n\n    #[test]\n    fn class_symmetric_difference_unicode() {\n        let cls1 = uclass(&[('a', 'm')]);\n        let cls2 = uclass(&[('g', 't')]);\n        let expected = uclass(&[('a', 'f'), ('n', 't')]);\n        assert_eq!(expected, usymdifference(&cls1, &cls2));\n    }\n\n    #[test]\n    fn class_symmetric_difference_bytes() {\n        let cls1 = bclass(&[(b'a', b'm')]);\n        let cls2 = bclass(&[(b'g', b't')]);\n        let expected = bclass(&[(b'a', b'f'), (b'n', b't')]);\n        assert_eq!(expected, bsymdifference(&cls1, &cls2));\n    }\n\n    #[test]\n    #[should_panic]\n    fn hir_byte_literal_non_ascii() {\n        Hir::literal(Literal::Byte(b'a'));\n    }\n\n    // We use a thread with an explicit stack size to test that our destructor\n    // for Hir can handle arbitrarily sized expressions in constant stack\n    // space. In case we run on a platform without threads (WASM?), we limit\n    // this test to Windows/Unix.\n    #[test]\n    #[cfg(any(unix, windows))]\n    fn no_stack_overflow_on_drop() {\n        use std::thread;\n\n        let run = || {\n            let mut expr = Hir::empty();\n            for _ in 0..100 {\n                expr = Hir::group(Group {\n                    kind: GroupKind::NonCapturing,\n                    hir: Box::new(expr),\n                });\n                expr = Hir::repetition(Repetition {\n                    kind: RepetitionKind::ZeroOrOne,\n                    greedy: true,\n                    hir: Box::new(expr),\n                });\n\n                expr = Hir {\n                    kind: HirKind::Concat(vec![expr]),\n                    info: HirInfo::new(),\n                };\n                expr = Hir {\n                    kind: HirKind::Alternation(vec![expr]),\n                    info: HirInfo::new(),\n                };\n            }\n            assert!(!expr.kind.is_empty());\n        };\n\n        // We run our test on a thread with a small stack size so we can\n        // force the issue more easily.\n        thread::Builder::new()\n            .stack_size(1 << 10)\n            .spawn(run)\n            .unwrap()\n            .join()\n            .unwrap();\n    }\n}\n","traces":[{"line":38,"address":[6830016],"length":1,"stats":{"Line":4},"fn_name":"kind"},{"line":39,"address":[6830021],"length":1,"stats":{"Line":4},"fn_name":null},{"line":45,"address":[6830048],"length":1,"stats":{"Line":4},"fn_name":"pattern"},{"line":46,"address":[6830057],"length":1,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[6830096],"length":1,"stats":{"Line":4},"fn_name":"span"},{"line":51,"address":[6830101],"length":1,"stats":{"Line":4},"fn_name":null},{"line":96,"address":[6830128],"length":1,"stats":{"Line":4},"fn_name":"description"},{"line":98,"address":[6830270,6830293,6830247,6830316,6830339,6830221,6830198],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[6830207,6830137],"length":1,"stats":{"Line":5},"fn_name":null},{"line":100,"address":[6830233],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[6830256],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[6830279],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[6830302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[6830325],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[6830348],"length":1,"stats":{"Line":3},"fn_name":null},{"line":120,"address":[6830384],"length":1,"stats":{"Line":0},"fn_name":"description"},{"line":121,"address":[6830393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[6830432],"length":1,"stats":{"Line":4},"fn_name":"fmt"},{"line":127,"address":[6830446],"length":1,"stats":{"Line":4},"fn_name":null},{"line":132,"address":[6830512],"length":1,"stats":{"Line":4},"fn_name":"fmt"},{"line":135,"address":[6830531],"length":1,"stats":{"Line":4},"fn_name":null},{"line":219,"address":[6830592],"length":1,"stats":{"Line":23},"fn_name":"kind"},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[6830608,6830646],"length":1,"stats":{"Line":0},"fn_name":"into_kind"},{"line":227,"address":[6830615],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[6830720],"length":1,"stats":{"Line":28},"fn_name":"empty"},{"line":234,"address":[6830737],"length":1,"stats":{"Line":28},"fn_name":null},{"line":235,"address":[6830747],"length":1,"stats":{"Line":28},"fn_name":null},{"line":236,"address":[6830762],"length":1,"stats":{"Line":28},"fn_name":null},{"line":237,"address":[6830779],"length":1,"stats":{"Line":28},"fn_name":null},{"line":238,"address":[6830791],"length":1,"stats":{"Line":28},"fn_name":null},{"line":239,"address":[6830803],"length":1,"stats":{"Line":28},"fn_name":null},{"line":240,"address":[6830815],"length":1,"stats":{"Line":28},"fn_name":null},{"line":241,"address":[6830827],"length":1,"stats":{"Line":28},"fn_name":null},{"line":242,"address":[6830839],"length":1,"stats":{"Line":28},"fn_name":null},{"line":243,"address":[6830849],"length":1,"stats":{"Line":28},"fn_name":null},{"line":244,"address":[6830866],"length":1,"stats":{"Line":28},"fn_name":null},{"line":245,"address":[6830878],"length":1,"stats":{"Line":28},"fn_name":null},{"line":254,"address":[6830960],"length":1,"stats":{"Line":9},"fn_name":"literal"},{"line":255,"address":[6831031,6830982],"length":1,"stats":{"Line":12},"fn_name":null},{"line":256,"address":[6831020,6831033],"length":1,"stats":{"Line":3},"fn_name":null},{"line":259,"address":[6831063],"length":1,"stats":{"Line":9},"fn_name":null},{"line":260,"address":[6831073],"length":1,"stats":{"Line":9},"fn_name":null},{"line":261,"address":[6831112],"length":1,"stats":{"Line":9},"fn_name":null},{"line":262,"address":[6831124],"length":1,"stats":{"Line":9},"fn_name":null},{"line":263,"address":[6831136],"length":1,"stats":{"Line":9},"fn_name":null},{"line":264,"address":[6831148],"length":1,"stats":{"Line":9},"fn_name":null},{"line":265,"address":[6831160],"length":1,"stats":{"Line":9},"fn_name":null},{"line":266,"address":[6831172],"length":1,"stats":{"Line":9},"fn_name":null},{"line":267,"address":[6831184],"length":1,"stats":{"Line":9},"fn_name":null},{"line":268,"address":[6831196],"length":1,"stats":{"Line":9},"fn_name":null},{"line":269,"address":[6831206],"length":1,"stats":{"Line":10},"fn_name":null},{"line":270,"address":[6831221],"length":1,"stats":{"Line":10},"fn_name":null},{"line":271,"address":[6831236],"length":1,"stats":{"Line":10},"fn_name":null},{"line":275,"address":[6831328,6831365],"length":1,"stats":{"Line":9},"fn_name":"class"},{"line":276,"address":[6831382,6831353],"length":1,"stats":{"Line":18},"fn_name":null},{"line":277,"address":[6831387,6831424],"length":1,"stats":{"Line":18},"fn_name":null},{"line":278,"address":[6831451],"length":1,"stats":{"Line":9},"fn_name":null},{"line":279,"address":[6831465],"length":1,"stats":{"Line":9},"fn_name":null},{"line":280,"address":[6831479],"length":1,"stats":{"Line":9},"fn_name":null},{"line":281,"address":[6831493],"length":1,"stats":{"Line":9},"fn_name":null},{"line":282,"address":[6831507],"length":1,"stats":{"Line":9},"fn_name":null},{"line":283,"address":[6831521],"length":1,"stats":{"Line":9},"fn_name":null},{"line":284,"address":[6831535],"length":1,"stats":{"Line":9},"fn_name":null},{"line":285,"address":[6831549],"length":1,"stats":{"Line":9},"fn_name":null},{"line":286,"address":[6831563],"length":1,"stats":{"Line":21},"fn_name":null},{"line":287,"address":[6831577],"length":1,"stats":{"Line":21},"fn_name":null},{"line":288,"address":[6831589],"length":1,"stats":{"Line":21},"fn_name":null},{"line":292,"address":[6831760],"length":1,"stats":{"Line":25},"fn_name":"anchor"},{"line":293,"address":[6831782],"length":1,"stats":{"Line":25},"fn_name":null},{"line":294,"address":[6831792],"length":1,"stats":{"Line":25},"fn_name":null},{"line":295,"address":[6831807],"length":1,"stats":{"Line":25},"fn_name":null},{"line":296,"address":[6831824],"length":1,"stats":{"Line":25},"fn_name":null},{"line":297,"address":[6831836],"length":1,"stats":{"Line":25},"fn_name":null},{"line":298,"address":[6831848],"length":1,"stats":{"Line":25},"fn_name":null},{"line":299,"address":[6831860],"length":1,"stats":{"Line":25},"fn_name":null},{"line":300,"address":[6831872],"length":1,"stats":{"Line":25},"fn_name":null},{"line":301,"address":[6831884],"length":1,"stats":{"Line":25},"fn_name":null},{"line":302,"address":[6831894],"length":1,"stats":{"Line":25},"fn_name":null},{"line":303,"address":[6831911],"length":1,"stats":{"Line":25},"fn_name":null},{"line":304,"address":[6831923],"length":1,"stats":{"Line":25},"fn_name":null},{"line":305,"address":[6831991,6831933],"length":1,"stats":{"Line":50},"fn_name":null},{"line":306,"address":[6831946],"length":1,"stats":{"Line":25},"fn_name":null},{"line":307,"address":[6831961],"length":1,"stats":{"Line":25},"fn_name":null},{"line":308,"address":[6831976],"length":1,"stats":{"Line":25},"fn_name":null},{"line":310,"address":[6832051,6831993],"length":1,"stats":{"Line":48},"fn_name":null},{"line":311,"address":[6832006],"length":1,"stats":{"Line":23},"fn_name":null},{"line":312,"address":[6832021],"length":1,"stats":{"Line":23},"fn_name":null},{"line":313,"address":[6832036],"length":1,"stats":{"Line":23},"fn_name":null},{"line":315,"address":[6832053,6832081],"length":1,"stats":{"Line":33},"fn_name":null},{"line":316,"address":[6832066],"length":1,"stats":{"Line":8},"fn_name":null},{"line":318,"address":[6832083,6832111],"length":1,"stats":{"Line":33},"fn_name":null},{"line":319,"address":[6832096],"length":1,"stats":{"Line":8},"fn_name":null},{"line":321,"address":[6832113],"length":1,"stats":{"Line":25},"fn_name":null},{"line":325,"address":[6832192],"length":1,"stats":{"Line":8},"fn_name":"word_boundary"},{"line":326,"address":[6832214],"length":1,"stats":{"Line":8},"fn_name":null},{"line":327,"address":[6832224],"length":1,"stats":{"Line":8},"fn_name":null},{"line":328,"address":[6832239],"length":1,"stats":{"Line":8},"fn_name":null},{"line":329,"address":[6832256],"length":1,"stats":{"Line":8},"fn_name":null},{"line":330,"address":[6832268],"length":1,"stats":{"Line":8},"fn_name":null},{"line":331,"address":[6832280],"length":1,"stats":{"Line":8},"fn_name":null},{"line":332,"address":[6832292],"length":1,"stats":{"Line":8},"fn_name":null},{"line":333,"address":[6832304],"length":1,"stats":{"Line":8},"fn_name":null},{"line":334,"address":[6832316],"length":1,"stats":{"Line":8},"fn_name":null},{"line":335,"address":[6832328],"length":1,"stats":{"Line":8},"fn_name":null},{"line":336,"address":[6832340],"length":1,"stats":{"Line":8},"fn_name":null},{"line":339,"address":[6832350],"length":1,"stats":{"Line":8},"fn_name":null},{"line":341,"address":[6832412,6832387],"length":1,"stats":{"Line":13},"fn_name":null},{"line":342,"address":[6832402],"length":1,"stats":{"Line":5},"fn_name":null},{"line":344,"address":[6832414],"length":1,"stats":{"Line":8},"fn_name":null},{"line":348,"address":[6832533,6832496],"length":1,"stats":{"Line":27},"fn_name":"repetition"},{"line":349,"address":[6832521,6832553],"length":1,"stats":{"Line":54},"fn_name":null},{"line":350,"address":[6832563,6832598],"length":1,"stats":{"Line":54},"fn_name":null},{"line":351,"address":[6832623],"length":1,"stats":{"Line":27},"fn_name":null},{"line":354,"address":[6832722],"length":1,"stats":{"Line":27},"fn_name":null},{"line":355,"address":[6832743,6832665],"length":1,"stats":{"Line":54},"fn_name":null},{"line":357,"address":[6832818],"length":1,"stats":{"Line":27},"fn_name":null},{"line":358,"address":[6832839,6832761],"length":1,"stats":{"Line":54},"fn_name":null},{"line":360,"address":[6832914],"length":1,"stats":{"Line":27},"fn_name":null},{"line":361,"address":[6832935,6832857],"length":1,"stats":{"Line":54},"fn_name":null},{"line":363,"address":[6833010],"length":1,"stats":{"Line":27},"fn_name":null},{"line":364,"address":[6833031,6832953],"length":1,"stats":{"Line":54},"fn_name":null},{"line":366,"address":[6833054],"length":1,"stats":{"Line":27},"fn_name":null},{"line":367,"address":[6833101],"length":1,"stats":{"Line":27},"fn_name":null},{"line":368,"address":[6833143],"length":1,"stats":{"Line":27},"fn_name":null},{"line":369,"address":[6833244],"length":1,"stats":{"Line":27},"fn_name":null},{"line":370,"address":[6833258],"length":1,"stats":{"Line":27},"fn_name":null},{"line":371,"address":[6833270],"length":1,"stats":{"Line":27},"fn_name":null},{"line":375,"address":[6833424,6833461],"length":1,"stats":{"Line":28},"fn_name":"group"},{"line":376,"address":[6833449,6833481],"length":1,"stats":{"Line":56},"fn_name":null},{"line":377,"address":[6833491,6833527],"length":1,"stats":{"Line":56},"fn_name":null},{"line":378,"address":[6833552],"length":1,"stats":{"Line":28},"fn_name":null},{"line":379,"address":[6833600],"length":1,"stats":{"Line":28},"fn_name":null},{"line":380,"address":[6833648],"length":1,"stats":{"Line":28},"fn_name":null},{"line":381,"address":[6833696],"length":1,"stats":{"Line":28},"fn_name":null},{"line":382,"address":[6833744],"length":1,"stats":{"Line":28},"fn_name":null},{"line":383,"address":[6833792],"length":1,"stats":{"Line":28},"fn_name":null},{"line":384,"address":[6833840],"length":1,"stats":{"Line":28},"fn_name":null},{"line":385,"address":[6833888],"length":1,"stats":{"Line":28},"fn_name":null},{"line":386,"address":[6833938],"length":1,"stats":{"Line":28},"fn_name":null},{"line":387,"address":[6833952],"length":1,"stats":{"Line":28},"fn_name":null},{"line":388,"address":[6833959],"length":1,"stats":{"Line":28},"fn_name":null},{"line":394,"address":[6834216,6834144],"length":1,"stats":{"Line":24},"fn_name":"concat"},{"line":395,"address":[6834154,6834384],"length":1,"stats":{"Line":38},"fn_name":null},{"line":396,"address":[6834239,6834301,6836436],"length":1,"stats":{"Line":24},"fn_name":null},{"line":397,"address":[6834323],"length":1,"stats":{"Line":13},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[6834286,6834397],"length":1,"stats":{"Line":48},"fn_name":null},{"line":400,"address":[6834418],"length":1,"stats":{"Line":24},"fn_name":null},{"line":401,"address":[6834438],"length":1,"stats":{"Line":24},"fn_name":null},{"line":402,"address":[6834455],"length":1,"stats":{"Line":24},"fn_name":null},{"line":403,"address":[6834472],"length":1,"stats":{"Line":24},"fn_name":null},{"line":404,"address":[6834492],"length":1,"stats":{"Line":24},"fn_name":null},{"line":405,"address":[6834512],"length":1,"stats":{"Line":24},"fn_name":null},{"line":406,"address":[6834532],"length":1,"stats":{"Line":24},"fn_name":null},{"line":409,"address":[6835573,6834539,6834712],"length":1,"stats":{"Line":49},"fn_name":null},{"line":410,"address":[6834852,6834762],"length":1,"stats":{"Line":48},"fn_name":null},{"line":411,"address":[6834822],"length":1,"stats":{"Line":24},"fn_name":null},{"line":413,"address":[6834879,6834969],"length":1,"stats":{"Line":48},"fn_name":null},{"line":414,"address":[6834939],"length":1,"stats":{"Line":24},"fn_name":null},{"line":416,"address":[6834996,6835086],"length":1,"stats":{"Line":48},"fn_name":null},{"line":417,"address":[6835030],"length":1,"stats":{"Line":24},"fn_name":null},{"line":418,"address":[6835056],"length":1,"stats":{"Line":24},"fn_name":null},{"line":420,"address":[6835113,6835203],"length":1,"stats":{"Line":48},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[6835173],"length":1,"stats":{"Line":24},"fn_name":null},{"line":424,"address":[6835230,6835320],"length":1,"stats":{"Line":48},"fn_name":null},{"line":425,"address":[6835290],"length":1,"stats":{"Line":24},"fn_name":null},{"line":427,"address":[6835437,6835347],"length":1,"stats":{"Line":48},"fn_name":null},{"line":428,"address":[6835407],"length":1,"stats":{"Line":25},"fn_name":null},{"line":430,"address":[6835464,6835554],"length":1,"stats":{"Line":50},"fn_name":null},{"line":431,"address":[6835498],"length":1,"stats":{"Line":25},"fn_name":null},{"line":432,"address":[6835524],"length":1,"stats":{"Line":25},"fn_name":null},{"line":443,"address":[6835689],"length":1,"stats":{"Line":25},"fn_name":null},{"line":444,"address":[6835578,6834674],"length":1,"stats":{"Line":50},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[7258672],"length":1,"stats":{"Line":25},"fn_name":"{{closure}}"},{"line":447,"address":[7258686,7258758],"length":1,"stats":{"Line":50},"fn_name":null},{"line":449,"address":[7258798,7258784],"length":1,"stats":{"Line":50},"fn_name":"{{closure}}"},{"line":452,"address":[6835883],"length":1,"stats":{"Line":25},"fn_name":null},{"line":453,"address":[6835712],"length":1,"stats":{"Line":25},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[7258832],"length":1,"stats":{"Line":25},"fn_name":"{{closure}}"},{"line":457,"address":[7258846,7258918],"length":1,"stats":{"Line":50},"fn_name":null},{"line":459,"address":[7258944,7258958],"length":1,"stats":{"Line":46},"fn_name":"{{closure}}"},{"line":462,"address":[6836022],"length":1,"stats":{"Line":25},"fn_name":null},{"line":463,"address":[6835906],"length":1,"stats":{"Line":25},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[7258992],"length":1,"stats":{"Line":25},"fn_name":"{{closure}}"},{"line":466,"address":[7259006,7259078],"length":1,"stats":{"Line":50},"fn_name":null},{"line":468,"address":[7259104,7259118],"length":1,"stats":{"Line":50},"fn_name":"{{closure}}"},{"line":470,"address":[6836192],"length":1,"stats":{"Line":25},"fn_name":null},{"line":471,"address":[6836045],"length":1,"stats":{"Line":25},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[7259152],"length":1,"stats":{"Line":25},"fn_name":"{{closure}}"},{"line":475,"address":[7259166,7259238],"length":1,"stats":{"Line":50},"fn_name":null},{"line":477,"address":[7259264,7259278],"length":1,"stats":{"Line":46},"fn_name":"{{closure}}"},{"line":479,"address":[6836215],"length":1,"stats":{"Line":25},"fn_name":null},{"line":487,"address":[6836464,6836524],"length":1,"stats":{"Line":8},"fn_name":"alternation"},{"line":488,"address":[6836665,6837170,6836474],"length":1,"stats":{"Line":16},"fn_name":null},{"line":489,"address":[6836544,6838283,6836597],"length":1,"stats":{"Line":8},"fn_name":null},{"line":490,"address":[6836616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[6836675,6836585],"length":1,"stats":{"Line":16},"fn_name":null},{"line":493,"address":[6836696],"length":1,"stats":{"Line":8},"fn_name":null},{"line":494,"address":[6836716],"length":1,"stats":{"Line":8},"fn_name":null},{"line":495,"address":[6836736],"length":1,"stats":{"Line":8},"fn_name":null},{"line":496,"address":[6836756],"length":1,"stats":{"Line":8},"fn_name":null},{"line":497,"address":[6836776],"length":1,"stats":{"Line":8},"fn_name":null},{"line":498,"address":[6836796],"length":1,"stats":{"Line":8},"fn_name":null},{"line":499,"address":[6836813],"length":1,"stats":{"Line":8},"fn_name":null},{"line":500,"address":[6836830],"length":1,"stats":{"Line":8},"fn_name":null},{"line":501,"address":[6836847],"length":1,"stats":{"Line":8},"fn_name":null},{"line":502,"address":[6836864],"length":1,"stats":{"Line":8},"fn_name":null},{"line":503,"address":[6836884],"length":1,"stats":{"Line":8},"fn_name":null},{"line":506,"address":[6836891,6837175,6838234],"length":1,"stats":{"Line":16},"fn_name":null},{"line":507,"address":[6837300,6837222],"length":1,"stats":{"Line":16},"fn_name":null},{"line":508,"address":[6837273],"length":1,"stats":{"Line":8},"fn_name":null},{"line":510,"address":[6837402,6837324],"length":1,"stats":{"Line":16},"fn_name":null},{"line":511,"address":[6837375],"length":1,"stats":{"Line":8},"fn_name":null},{"line":513,"address":[6837504,6837426],"length":1,"stats":{"Line":16},"fn_name":null},{"line":514,"address":[6837477],"length":1,"stats":{"Line":8},"fn_name":null},{"line":516,"address":[6837606,6837528],"length":1,"stats":{"Line":16},"fn_name":null},{"line":517,"address":[6837579],"length":1,"stats":{"Line":8},"fn_name":null},{"line":519,"address":[6837630,6837708],"length":1,"stats":{"Line":16},"fn_name":null},{"line":520,"address":[6837661],"length":1,"stats":{"Line":8},"fn_name":null},{"line":521,"address":[6837681],"length":1,"stats":{"Line":8},"fn_name":null},{"line":523,"address":[6837732,6837810],"length":1,"stats":{"Line":16},"fn_name":null},{"line":524,"address":[6837763],"length":1,"stats":{"Line":8},"fn_name":null},{"line":525,"address":[6837783],"length":1,"stats":{"Line":8},"fn_name":null},{"line":527,"address":[6837834,6837912],"length":1,"stats":{"Line":16},"fn_name":null},{"line":528,"address":[6837865],"length":1,"stats":{"Line":8},"fn_name":null},{"line":529,"address":[6837885],"length":1,"stats":{"Line":8},"fn_name":null},{"line":531,"address":[6837936,6838014],"length":1,"stats":{"Line":16},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[6837987],"length":1,"stats":{"Line":8},"fn_name":null},{"line":535,"address":[6838116,6838038],"length":1,"stats":{"Line":16},"fn_name":null},{"line":536,"address":[6838089],"length":1,"stats":{"Line":8},"fn_name":null},{"line":538,"address":[6838218,6838140],"length":1,"stats":{"Line":16},"fn_name":null},{"line":539,"address":[6838191],"length":1,"stats":{"Line":8},"fn_name":null},{"line":541,"address":[6837008],"length":1,"stats":{"Line":8},"fn_name":null},{"line":554,"address":[6838320,6838377],"length":1,"stats":{"Line":23},"fn_name":"dot"},{"line":555,"address":[6838679,6838343],"length":1,"stats":{"Line":26},"fn_name":null},{"line":556,"address":[6838419],"length":1,"stats":{"Line":3},"fn_name":null},{"line":557,"address":[6838438],"length":1,"stats":{"Line":3},"fn_name":null},{"line":558,"address":[6838508],"length":1,"stats":{"Line":3},"fn_name":null},{"line":559,"address":[6838581],"length":1,"stats":{"Line":3},"fn_name":null},{"line":561,"address":[6838392],"length":1,"stats":{"Line":23},"fn_name":null},{"line":562,"address":[6838684],"length":1,"stats":{"Line":23},"fn_name":null},{"line":563,"address":[6838737],"length":1,"stats":{"Line":23},"fn_name":null},{"line":564,"address":[6838793],"length":1,"stats":{"Line":23},"fn_name":null},{"line":576,"address":[6839040,6839097],"length":1,"stats":{"Line":8},"fn_name":"any"},{"line":577,"address":[6839063,6839311],"length":1,"stats":{"Line":16},"fn_name":null},{"line":578,"address":[6839136],"length":1,"stats":{"Line":8},"fn_name":null},{"line":579,"address":[6839155],"length":1,"stats":{"Line":8},"fn_name":null},{"line":580,"address":[6839225],"length":1,"stats":{"Line":8},"fn_name":null},{"line":582,"address":[6839112],"length":1,"stats":{"Line":8},"fn_name":null},{"line":583,"address":[6839316],"length":1,"stats":{"Line":8},"fn_name":null},{"line":584,"address":[6839364],"length":1,"stats":{"Line":8},"fn_name":null},{"line":592,"address":[6839616],"length":1,"stats":{"Line":26},"fn_name":"is_always_utf8"},{"line":593,"address":[6839625],"length":1,"stats":{"Line":26},"fn_name":null},{"line":601,"address":[6839664],"length":1,"stats":{"Line":28},"fn_name":"is_all_assertions"},{"line":602,"address":[6839673],"length":1,"stats":{"Line":28},"fn_name":null},{"line":608,"address":[6839712],"length":1,"stats":{"Line":26},"fn_name":"is_anchored_start"},{"line":609,"address":[6839721],"length":1,"stats":{"Line":26},"fn_name":null},{"line":615,"address":[6839760],"length":1,"stats":{"Line":26},"fn_name":"is_anchored_end"},{"line":616,"address":[6839769],"length":1,"stats":{"Line":26},"fn_name":null},{"line":628,"address":[6839808],"length":1,"stats":{"Line":28},"fn_name":"is_line_anchored_start"},{"line":629,"address":[6839817],"length":1,"stats":{"Line":28},"fn_name":null},{"line":641,"address":[6839856],"length":1,"stats":{"Line":28},"fn_name":"is_line_anchored_end"},{"line":642,"address":[6839865],"length":1,"stats":{"Line":28},"fn_name":null},{"line":649,"address":[6839904],"length":1,"stats":{"Line":26},"fn_name":"is_any_anchored_start"},{"line":650,"address":[6839913],"length":1,"stats":{"Line":26},"fn_name":null},{"line":657,"address":[6839952],"length":1,"stats":{"Line":26},"fn_name":"is_any_anchored_end"},{"line":658,"address":[6839961],"length":1,"stats":{"Line":26},"fn_name":null},{"line":666,"address":[6840000],"length":1,"stats":{"Line":28},"fn_name":"is_match_empty"},{"line":667,"address":[6840009],"length":1,"stats":{"Line":28},"fn_name":null},{"line":676,"address":[6840048],"length":1,"stats":{"Line":24},"fn_name":"is_literal"},{"line":677,"address":[6840057],"length":1,"stats":{"Line":25},"fn_name":null},{"line":688,"address":[6840096],"length":1,"stats":{"Line":25},"fn_name":"is_alternation_literal"},{"line":689,"address":[6840105],"length":1,"stats":{"Line":25},"fn_name":null},{"line":699,"address":[6840144],"length":1,"stats":{"Line":24},"fn_name":"is_empty"},{"line":700,"address":[6840169],"length":1,"stats":{"Line":24},"fn_name":null},{"line":701,"address":[6840153,6840171],"length":1,"stats":{"Line":38},"fn_name":null},{"line":702,"address":[6840164],"length":1,"stats":{"Line":24},"fn_name":null},{"line":708,"address":[6840192],"length":1,"stats":{"Line":10},"fn_name":"has_subexprs"},{"line":709,"address":[6840216,6840223],"length":1,"stats":{"Line":10},"fn_name":null},{"line":710,"address":[6840201],"length":1,"stats":{"Line":10},"fn_name":null},{"line":711,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":712,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":713,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":714,"address":[6840218],"length":1,"stats":{"Line":10},"fn_name":null},{"line":715,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":716,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":717,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":718,"address":[6840225],"length":1,"stats":{"Line":8},"fn_name":null},{"line":730,"address":[6840256],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":732,"address":[6840280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":753,"address":[6840336],"length":1,"stats":{"Line":9},"fn_name":"is_unicode"},{"line":754,"address":[6840363,6840413,6840370],"length":1,"stats":{"Line":9},"fn_name":null},{"line":755,"address":[6840365,6840345],"length":1,"stats":{"Line":18},"fn_name":null},{"line":756,"address":[6840376],"length":1,"stats":{"Line":3},"fn_name":null},{"line":757,"address":[6840415],"length":1,"stats":{"Line":3},"fn_name":null},{"line":794,"address":[6840448],"length":1,"stats":{"Line":0},"fn_name":"case_fold_simple"},{"line":795,"address":[6840497,6840523],"length":1,"stats":{"Line":0},"fn_name":null},{"line":796,"address":[6840457,6840503],"length":1,"stats":{"Line":0},"fn_name":null},{"line":797,"address":[6840475],"length":1,"stats":{"Line":0},"fn_name":null},{"line":805,"address":[6840544],"length":1,"stats":{"Line":0},"fn_name":"negate"},{"line":806,"address":[6840619,6840593],"length":1,"stats":{"Line":0},"fn_name":null},{"line":807,"address":[6840553,6840599],"length":1,"stats":{"Line":0},"fn_name":null},{"line":808,"address":[6840571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":823,"address":[6840640],"length":1,"stats":{"Line":9},"fn_name":"is_always_utf8"},{"line":824,"address":[6840697,6840704],"length":1,"stats":{"Line":9},"fn_name":null},{"line":825,"address":[6840699,6840649],"length":1,"stats":{"Line":18},"fn_name":null},{"line":826,"address":[6840669],"length":1,"stats":{"Line":17},"fn_name":null},{"line":842,"address":[7259312],"length":1,"stats":{"Line":8},"fn_name":"new<alloc::vec::Vec<regex_syntax::hir::ClassUnicodeRange>>"},{"line":846,"address":[7259319],"length":1,"stats":{"Line":8},"fn_name":null},{"line":850,"address":[6840736],"length":1,"stats":{"Line":8},"fn_name":"empty"},{"line":851,"address":[6840752],"length":1,"stats":{"Line":8},"fn_name":null},{"line":855,"address":[6840816],"length":1,"stats":{"Line":9},"fn_name":"push"},{"line":856,"address":[6840833],"length":1,"stats":{"Line":9},"fn_name":null},{"line":862,"address":[6840848],"length":1,"stats":{"Line":8},"fn_name":"iter"},{"line":863,"address":[6840857],"length":1,"stats":{"Line":8},"fn_name":null},{"line":867,"address":[6840912],"length":1,"stats":{"Line":8},"fn_name":"ranges"},{"line":868,"address":[6840921],"length":1,"stats":{"Line":8},"fn_name":null},{"line":884,"address":[6840960],"length":1,"stats":{"Line":0},"fn_name":"case_fold_simple"},{"line":885,"address":[6840969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":900,"address":[6841056],"length":1,"stats":{"Line":8},"fn_name":"try_case_fold_simple"},{"line":903,"address":[6841065],"length":1,"stats":{"Line":8},"fn_name":null},{"line":910,"address":[6841088],"length":1,"stats":{"Line":8},"fn_name":"negate"},{"line":911,"address":[6841093],"length":1,"stats":{"Line":8},"fn_name":null},{"line":915,"address":[6841104],"length":1,"stats":{"Line":12},"fn_name":"union"},{"line":916,"address":[6841118],"length":1,"stats":{"Line":12},"fn_name":null},{"line":921,"address":[6841136],"length":1,"stats":{"Line":0},"fn_name":"intersect"},{"line":922,"address":[6841150],"length":1,"stats":{"Line":0},"fn_name":null},{"line":926,"address":[6841168],"length":1,"stats":{"Line":0},"fn_name":"difference"},{"line":927,"address":[6841182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":938,"address":[6841200],"length":1,"stats":{"Line":0},"fn_name":"symmetric_difference"},{"line":939,"address":[6841214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":945,"address":[6841232],"length":1,"stats":{"Line":0},"fn_name":"is_all_ascii"},{"line":946,"address":[6841241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":959,"address":[6841312],"length":1,"stats":{"Line":8},"fn_name":"next"},{"line":960,"address":[6841321],"length":1,"stats":{"Line":8},"fn_name":null},{"line":975,"address":[6841448,6841344],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":976,"address":[6841367,6841467,6841598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":978,"address":[6841581],"length":1,"stats":{"Line":0},"fn_name":null},{"line":980,"address":[6841494,6841608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":982,"address":[6842008,6841859,6841752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":983,"address":[6841982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":985,"address":[6841867,6842018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":987,"address":[6842263,6842157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":988,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":989,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":998,"address":[6842432],"length":1,"stats":{"Line":23},"fn_name":"lower"},{"line":999,"address":[6842437],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1002,"address":[6842448],"length":1,"stats":{"Line":23},"fn_name":"upper"},{"line":1003,"address":[6842453],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1006,"address":[6842464],"length":1,"stats":{"Line":9},"fn_name":"set_lower"},{"line":1007,"address":[6842476],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1010,"address":[6842496],"length":1,"stats":{"Line":9},"fn_name":"set_upper"},{"line":1011,"address":[6842508],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1018,"address":[6842528],"length":1,"stats":{"Line":8},"fn_name":"case_fold_simple"},{"line":1022,"address":[6842551,6842667],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1023,"address":[6842727],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1025,"address":[6842688],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1026,"address":[6842697],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1027,"address":[6842734],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1028,"address":[6842866,6843266,6842746],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1029,"address":[6842892],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1030,"address":[6842950],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1032,"address":[6843079,6842957,6842931,6843124],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1033,"address":[6843064,6843126],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1034,"address":[6843104],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1035,"address":[6843115],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1036,"address":[6843119],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1039,"address":[6843338,6843171,6843271,6843336],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1040,"address":[6843301],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1043,"address":[6842856],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1052,"address":[6843344],"length":1,"stats":{"Line":9},"fn_name":"new"},{"line":1053,"address":[6843356],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1060,"address":[6843392],"length":1,"stats":{"Line":25},"fn_name":"start"},{"line":1061,"address":[6843397],"length":1,"stats":{"Line":25},"fn_name":null},{"line":1068,"address":[6843408],"length":1,"stats":{"Line":25},"fn_name":"end"},{"line":1069,"address":[6843413],"length":1,"stats":{"Line":25},"fn_name":null},{"line":1085,"address":[7259488],"length":1,"stats":{"Line":13},"fn_name":"new<alloc::vec::Vec<regex_syntax::hir::ClassBytesRange>>"},{"line":1089,"address":[7259495],"length":1,"stats":{"Line":17},"fn_name":null},{"line":1093,"address":[6843424],"length":1,"stats":{"Line":9},"fn_name":"empty"},{"line":1094,"address":[6843440],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1098,"address":[6843504],"length":1,"stats":{"Line":14},"fn_name":"push"},{"line":1099,"address":[6843522],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1105,"address":[6843552],"length":1,"stats":{"Line":13},"fn_name":"iter"},{"line":1106,"address":[6843561],"length":1,"stats":{"Line":14},"fn_name":null},{"line":1110,"address":[6843616],"length":1,"stats":{"Line":12},"fn_name":"ranges"},{"line":1111,"address":[6843625],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1121,"address":[6843664],"length":1,"stats":{"Line":8},"fn_name":"case_fold_simple"},{"line":1122,"address":[6843673],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1129,"address":[6843760],"length":1,"stats":{"Line":8},"fn_name":"negate"},{"line":1130,"address":[6843765],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1134,"address":[6843776],"length":1,"stats":{"Line":0},"fn_name":"union"},{"line":1135,"address":[6843790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1139,"address":[6843808],"length":1,"stats":{"Line":0},"fn_name":"intersect"},{"line":1140,"address":[6843822],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1144,"address":[6843840],"length":1,"stats":{"Line":0},"fn_name":"difference"},{"line":1145,"address":[6843854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1155,"address":[6843872],"length":1,"stats":{"Line":0},"fn_name":"symmetric_difference"},{"line":1156,"address":[6843886],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1162,"address":[6843904],"length":1,"stats":{"Line":13},"fn_name":"is_all_ascii"},{"line":1163,"address":[6843913],"length":1,"stats":{"Line":47},"fn_name":null},{"line":1176,"address":[6843984],"length":1,"stats":{"Line":13},"fn_name":"next"},{"line":1177,"address":[6843993],"length":1,"stats":{"Line":14},"fn_name":null},{"line":1195,"address":[6844016],"length":1,"stats":{"Line":21},"fn_name":"lower"},{"line":1196,"address":[6844021],"length":1,"stats":{"Line":15},"fn_name":null},{"line":1199,"address":[6844032],"length":1,"stats":{"Line":15},"fn_name":"upper"},{"line":1200,"address":[6844037],"length":1,"stats":{"Line":21},"fn_name":null},{"line":1203,"address":[6844048],"length":1,"stats":{"Line":13},"fn_name":"set_lower"},{"line":1204,"address":[6844061],"length":1,"stats":{"Line":17},"fn_name":null},{"line":1207,"address":[6844080],"length":1,"stats":{"Line":17},"fn_name":"set_upper"},{"line":1208,"address":[6844093],"length":1,"stats":{"Line":13},"fn_name":null},{"line":1216,"address":[6844112],"length":1,"stats":{"Line":10},"fn_name":"case_fold_simple"},{"line":1220,"address":[6844354,6844126],"length":1,"stats":{"Line":21},"fn_name":null},{"line":1221,"address":[6844207],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1222,"address":[6844234],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1223,"address":[6844261,6844584],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1225,"address":[6844356,6844570],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1226,"address":[6844423],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1227,"address":[6844450],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1228,"address":[6844644,6844477],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1239,"address":[6844704],"length":1,"stats":{"Line":13},"fn_name":"new"},{"line":1240,"address":[6844715],"length":1,"stats":{"Line":17},"fn_name":null},{"line":1247,"address":[6844752],"length":1,"stats":{"Line":13},"fn_name":"start"},{"line":1248,"address":[6844757],"length":1,"stats":{"Line":11},"fn_name":null},{"line":1255,"address":[6844768],"length":1,"stats":{"Line":13},"fn_name":"end"},{"line":1256,"address":[6844773],"length":1,"stats":{"Line":11},"fn_name":null},{"line":1261,"address":[6844784],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":1262,"address":[6844805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1263,"address":[6844837,6844984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1264,"address":[6844927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1266,"address":[6844861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1268,"address":[6844993,6845149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1269,"address":[6845091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1271,"address":[6845018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1273,"address":[6845153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1319,"address":[6845184],"length":1,"stats":{"Line":8},"fn_name":"is_negated"},{"line":1320,"address":[6845222,6845229],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1321,"address":[6845193,6845224],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1322,"address":[6845231],"length":1,"stats":{"Line":11},"fn_name":null},{"line":1392,"address":[6845264],"length":1,"stats":{"Line":27},"fn_name":"is_match_empty"},{"line":1393,"address":[6845384,6845407,6845434,6845393,6845400],"length":1,"stats":{"Line":59},"fn_name":null},{"line":1394,"address":[6845273,6845388],"length":1,"stats":{"Line":35},"fn_name":null},{"line":1395,"address":[6845395],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1396,"address":[6845402],"length":1,"stats":{"Line":27},"fn_name":null},{"line":1397,"address":[6845331,6845414],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1398,"address":[6845441],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1399,"address":[6845364],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1431,"address":[6627296,6627329],"length":1,"stats":{"Line":11},"fn_name":"drop"},{"line":1434,"address":[6627316],"length":1,"stats":{"Line":11},"fn_name":null},{"line":1435,"address":[6627349],"length":1,"stats":{"Line":11},"fn_name":null},{"line":1436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1439,"address":[6627439],"length":1,"stats":{"Line":11},"fn_name":null},{"line":1440,"address":[6627446],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1441,"address":[6627513],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1442,"address":[6627585],"length":1,"stats":{"Line":26},"fn_name":null},{"line":1443,"address":[6627649],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1444,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1447,"address":[6627399,6627708,6628390],"length":1,"stats":{"Line":54},"fn_name":null},{"line":1448,"address":[6627787,6627833,6628106,6628369],"length":1,"stats":{"Line":82},"fn_name":null},{"line":1449,"address":[6628258,6628024,6628151,6628322,6628348],"length":1,"stats":{"Line":79},"fn_name":null},{"line":1450,"address":[6627947],"length":1,"stats":{"Line":30},"fn_name":null},{"line":1451,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1452,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1453,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1455,"address":[6628026],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1456,"address":[6628042,6628127],"length":1,"stats":{"Line":18},"fn_name":null},{"line":1458,"address":[6628156],"length":1,"stats":{"Line":26},"fn_name":null},{"line":1459,"address":[6628172],"length":1,"stats":{"Line":30},"fn_name":null},{"line":1461,"address":[6628260],"length":1,"stats":{"Line":26},"fn_name":null},{"line":1462,"address":[6628276],"length":1,"stats":{"Line":26},"fn_name":null},{"line":1464,"address":[6627983],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1465,"address":[6627999,6628324],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1488,"address":[6867376,6867712,6866704,6867488,6866992,6867088,6867280,6866800,6867184,6867600,6866896],"length":1,"stats":{"Line":291},"fn_name":"is_always_utf8"},{"line":1489,"address":[6866901,6867189,6866805,6867285,6867493,6867381,6867605,6867093,6867717,6866709,6866997],"length":1,"stats":{"Line":291},"fn_name":null},{"line":1492,"address":[6867216,6867120,6867312,6867024,6866736,6867408,6867520,6866832,6867632,6867744,6866928],"length":1,"stats":{"Line":264},"fn_name":"set_always_utf8"},{"line":1493,"address":[6867762,6867066,6867162,6867538,6866970,6867258,6867042,6866778,6867451,6867787,6867234,6866850,6867675,6867650,6866754,6867426,6867330,6867354,6867138,6867563,6866874,6866946],"length":1,"stats":{"Line":497},"fn_name":null},{"line":1494,"address":[6867264,6866784,6866880,6867168,6867072,6867457,6867569,6867681,6867793,6866976,6867360],"length":1,"stats":{"Line":266},"fn_name":null},{"line":1496,"address":[6866768,6867344,6867552,6867056,6867664,6867776,6867152,6867440,6866864,6867248,6866960],"length":1,"stats":{"Line":220},"fn_name":null},{"line":1503,"address":[6845488],"length":1,"stats":{"Line":24},"fn_name":"new"}],"covered":410,"coverable":496},{"path":["/","usr","src","regex","regex-syntax","src","hir","print.rs"],"content":"/*!\nThis module provides a regular expression printer for `Hir`.\n*/\n\nuse std::fmt;\n\nuse hir::visitor::{self, Visitor};\nuse hir::{self, Hir, HirKind};\nuse is_meta_character;\n\n/// A builder for constructing a printer.\n///\n/// Note that since a printer doesn't have any configuration knobs, this type\n/// remains unexported.\n#[derive(Clone, Debug)]\nstruct PrinterBuilder {\n    _priv: (),\n}\n\nimpl Default for PrinterBuilder {\n    fn default() -> PrinterBuilder {\n        PrinterBuilder::new()\n    }\n}\n\nimpl PrinterBuilder {\n    fn new() -> PrinterBuilder {\n        PrinterBuilder { _priv: () }\n    }\n\n    fn build(&self) -> Printer {\n        Printer { _priv: () }\n    }\n}\n\n/// A printer for a regular expression's high-level intermediate\n/// representation.\n///\n/// A printer converts a high-level intermediate representation (HIR) to a\n/// regular expression pattern string. This particular printer uses constant\n/// stack space and heap space proportional to the size of the HIR.\n///\n/// Since this printer is only using the HIR, the pattern it prints will likely\n/// not resemble the original pattern at all. For example, a pattern like\n/// `\\pL` will have its entire class written out.\n///\n/// The purpose of this printer is to provide a means to mutate an HIR and then\n/// build a regular expression from the result of that mutation. (A regex\n/// library could provide a constructor from this HIR explicitly, but that\n/// creates an unnecessary public coupling between the regex library and this\n/// specific HIR representation.)\n#[derive(Debug)]\npub struct Printer {\n    _priv: (),\n}\n\nimpl Printer {\n    /// Create a new printer.\n    pub fn new() -> Printer {\n        PrinterBuilder::new().build()\n    }\n\n    /// Print the given `Ast` to the given writer. The writer must implement\n    /// `fmt::Write`. Typical implementations of `fmt::Write` that can be used\n    /// here are a `fmt::Formatter` (which is available in `fmt::Display`\n    /// implementations) or a `&mut String`.\n    pub fn print<W: fmt::Write>(&mut self, hir: &Hir, wtr: W) -> fmt::Result {\n        visitor::visit(hir, Writer { printer: self, wtr: wtr })\n    }\n}\n\n#[derive(Debug)]\nstruct Writer<'p, W> {\n    printer: &'p mut Printer,\n    wtr: W,\n}\n\nimpl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    type Output = ();\n    type Err = fmt::Error;\n\n    fn finish(self) -> fmt::Result {\n        Ok(())\n    }\n\n    fn visit_pre(&mut self, hir: &Hir) -> fmt::Result {\n        match *hir.kind() {\n            HirKind::Empty\n            | HirKind::Repetition(_)\n            | HirKind::Concat(_)\n            | HirKind::Alternation(_) => {}\n            HirKind::Literal(hir::Literal::Unicode(c)) => {\n                self.write_literal_char(c)?;\n            }\n            HirKind::Literal(hir::Literal::Byte(b)) => {\n                self.write_literal_byte(b)?;\n            }\n            HirKind::Class(hir::Class::Unicode(ref cls)) => {\n                self.wtr.write_str(\"[\")?;\n                for range in cls.iter() {\n                    if range.start() == range.end() {\n                        self.write_literal_char(range.start())?;\n                    } else {\n                        self.write_literal_char(range.start())?;\n                        self.wtr.write_str(\"-\")?;\n                        self.write_literal_char(range.end())?;\n                    }\n                }\n                self.wtr.write_str(\"]\")?;\n            }\n            HirKind::Class(hir::Class::Bytes(ref cls)) => {\n                self.wtr.write_str(\"(?-u:[\")?;\n                for range in cls.iter() {\n                    if range.start() == range.end() {\n                        self.write_literal_class_byte(range.start())?;\n                    } else {\n                        self.write_literal_class_byte(range.start())?;\n                        self.wtr.write_str(\"-\")?;\n                        self.write_literal_class_byte(range.end())?;\n                    }\n                }\n                self.wtr.write_str(\"])\")?;\n            }\n            HirKind::Anchor(hir::Anchor::StartLine) => {\n                self.wtr.write_str(\"(?m:^)\")?;\n            }\n            HirKind::Anchor(hir::Anchor::EndLine) => {\n                self.wtr.write_str(\"(?m:$)\")?;\n            }\n            HirKind::Anchor(hir::Anchor::StartText) => {\n                self.wtr.write_str(r\"\\A\")?;\n            }\n            HirKind::Anchor(hir::Anchor::EndText) => {\n                self.wtr.write_str(r\"\\z\")?;\n            }\n            HirKind::WordBoundary(hir::WordBoundary::Unicode) => {\n                self.wtr.write_str(r\"\\b\")?;\n            }\n            HirKind::WordBoundary(hir::WordBoundary::UnicodeNegate) => {\n                self.wtr.write_str(r\"\\B\")?;\n            }\n            HirKind::WordBoundary(hir::WordBoundary::Ascii) => {\n                self.wtr.write_str(r\"(?-u:\\b)\")?;\n            }\n            HirKind::WordBoundary(hir::WordBoundary::AsciiNegate) => {\n                self.wtr.write_str(r\"(?-u:\\B)\")?;\n            }\n            HirKind::Group(ref x) => match x.kind {\n                hir::GroupKind::CaptureIndex(_) => {\n                    self.wtr.write_str(\"(\")?;\n                }\n                hir::GroupKind::CaptureName { ref name, .. } => {\n                    write!(self.wtr, \"(?P<{}>\", name)?;\n                }\n                hir::GroupKind::NonCapturing => {\n                    self.wtr.write_str(\"(?:\")?;\n                }\n            },\n        }\n        Ok(())\n    }\n\n    fn visit_post(&mut self, hir: &Hir) -> fmt::Result {\n        match *hir.kind() {\n            // Handled during visit_pre\n            HirKind::Empty\n            | HirKind::Literal(_)\n            | HirKind::Class(_)\n            | HirKind::Anchor(_)\n            | HirKind::WordBoundary(_)\n            | HirKind::Concat(_)\n            | HirKind::Alternation(_) => {}\n            HirKind::Repetition(ref x) => {\n                match x.kind {\n                    hir::RepetitionKind::ZeroOrOne => {\n                        self.wtr.write_str(\"?\")?;\n                    }\n                    hir::RepetitionKind::ZeroOrMore => {\n                        self.wtr.write_str(\"*\")?;\n                    }\n                    hir::RepetitionKind::OneOrMore => {\n                        self.wtr.write_str(\"+\")?;\n                    }\n                    hir::RepetitionKind::Range(ref x) => match *x {\n                        hir::RepetitionRange::Exactly(m) => {\n                            write!(self.wtr, \"{{{}}}\", m)?;\n                        }\n                        hir::RepetitionRange::AtLeast(m) => {\n                            write!(self.wtr, \"{{{},}}\", m)?;\n                        }\n                        hir::RepetitionRange::Bounded(m, n) => {\n                            write!(self.wtr, \"{{{},{}}}\", m, n)?;\n                        }\n                    },\n                }\n                if !x.greedy {\n                    self.wtr.write_str(\"?\")?;\n                }\n            }\n            HirKind::Group(_) => {\n                self.wtr.write_str(\")\")?;\n            }\n        }\n        Ok(())\n    }\n\n    fn visit_alternation_in(&mut self) -> fmt::Result {\n        self.wtr.write_str(\"|\")\n    }\n}\n\nimpl<'p, W: fmt::Write> Writer<'p, W> {\n    fn write_literal_char(&mut self, c: char) -> fmt::Result {\n        if is_meta_character(c) {\n            self.wtr.write_str(\"\\\\\")?;\n        }\n        self.wtr.write_char(c)\n    }\n\n    fn write_literal_byte(&mut self, b: u8) -> fmt::Result {\n        let c = b as char;\n        if c <= 0x7F as char && !c.is_control() && !c.is_whitespace() {\n            self.write_literal_char(c)\n        } else {\n            write!(self.wtr, \"(?-u:\\\\x{:02X})\", b)\n        }\n    }\n\n    fn write_literal_class_byte(&mut self, b: u8) -> fmt::Result {\n        let c = b as char;\n        if c <= 0x7F as char && !c.is_control() && !c.is_whitespace() {\n            self.write_literal_char(c)\n        } else {\n            write!(self.wtr, \"\\\\x{:02X}\", b)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Printer;\n    use ParserBuilder;\n\n    fn roundtrip(given: &str, expected: &str) {\n        roundtrip_with(|b| b, given, expected);\n    }\n\n    fn roundtrip_bytes(given: &str, expected: &str) {\n        roundtrip_with(|b| b.allow_invalid_utf8(true), given, expected);\n    }\n\n    fn roundtrip_with<F>(mut f: F, given: &str, expected: &str)\n    where\n        F: FnMut(&mut ParserBuilder) -> &mut ParserBuilder,\n    {\n        let mut builder = ParserBuilder::new();\n        f(&mut builder);\n        let hir = builder.build().parse(given).unwrap();\n\n        let mut printer = Printer::new();\n        let mut dst = String::new();\n        printer.print(&hir, &mut dst).unwrap();\n\n        // Check that the result is actually valid.\n        builder.build().parse(&dst).unwrap();\n\n        assert_eq!(expected, dst);\n    }\n\n    #[test]\n    fn print_literal() {\n        roundtrip(\"a\", \"a\");\n        roundtrip(r\"\\xff\", \"\\u{FF}\");\n        roundtrip_bytes(r\"\\xff\", \"\\u{FF}\");\n        roundtrip_bytes(r\"(?-u)\\xff\", r\"(?-u:\\xFF)\");\n        roundtrip(\"☃\", \"☃\");\n    }\n\n    #[test]\n    fn print_class() {\n        roundtrip(r\"[a]\", r\"[a]\");\n        roundtrip(r\"[a-z]\", r\"[a-z]\");\n        roundtrip(r\"[a-z--b-c--x-y]\", r\"[ad-wz]\");\n        roundtrip(r\"[^\\x01-\\u{10FFFF}]\", \"[\\u{0}]\");\n        roundtrip(r\"[-]\", r\"[\\-]\");\n        roundtrip(r\"[☃-⛄]\", r\"[☃-⛄]\");\n\n        roundtrip(r\"(?-u)[a]\", r\"(?-u:[a])\");\n        roundtrip(r\"(?-u)[a-z]\", r\"(?-u:[a-z])\");\n        roundtrip_bytes(r\"(?-u)[a-\\xFF]\", r\"(?-u:[a-\\xFF])\");\n\n        // The following test that the printer escapes meta characters\n        // in character classes.\n        roundtrip(r\"[\\[]\", r\"[\\[]\");\n        roundtrip(r\"[Z-_]\", r\"[Z-_]\");\n        roundtrip(r\"[Z-_--Z]\", r\"[\\[-_]\");\n\n        // The following test that the printer escapes meta characters\n        // in byte oriented character classes.\n        roundtrip_bytes(r\"(?-u)[\\[]\", r\"(?-u:[\\[])\");\n        roundtrip_bytes(r\"(?-u)[Z-_]\", r\"(?-u:[Z-_])\");\n        roundtrip_bytes(r\"(?-u)[Z-_--Z]\", r\"(?-u:[\\[-_])\");\n    }\n\n    #[test]\n    fn print_anchor() {\n        roundtrip(r\"^\", r\"\\A\");\n        roundtrip(r\"$\", r\"\\z\");\n        roundtrip(r\"(?m)^\", r\"(?m:^)\");\n        roundtrip(r\"(?m)$\", r\"(?m:$)\");\n    }\n\n    #[test]\n    fn print_word_boundary() {\n        roundtrip(r\"\\b\", r\"\\b\");\n        roundtrip(r\"\\B\", r\"\\B\");\n        roundtrip(r\"(?-u)\\b\", r\"(?-u:\\b)\");\n        roundtrip_bytes(r\"(?-u)\\B\", r\"(?-u:\\B)\");\n    }\n\n    #[test]\n    fn print_repetition() {\n        roundtrip(\"a?\", \"a?\");\n        roundtrip(\"a??\", \"a??\");\n        roundtrip(\"(?U)a?\", \"a??\");\n\n        roundtrip(\"a*\", \"a*\");\n        roundtrip(\"a*?\", \"a*?\");\n        roundtrip(\"(?U)a*\", \"a*?\");\n\n        roundtrip(\"a+\", \"a+\");\n        roundtrip(\"a+?\", \"a+?\");\n        roundtrip(\"(?U)a+\", \"a+?\");\n\n        roundtrip(\"a{1}\", \"a{1}\");\n        roundtrip(\"a{1,}\", \"a{1,}\");\n        roundtrip(\"a{1,5}\", \"a{1,5}\");\n        roundtrip(\"a{1}?\", \"a{1}?\");\n        roundtrip(\"a{1,}?\", \"a{1,}?\");\n        roundtrip(\"a{1,5}?\", \"a{1,5}?\");\n        roundtrip(\"(?U)a{1}\", \"a{1}?\");\n        roundtrip(\"(?U)a{1,}\", \"a{1,}?\");\n        roundtrip(\"(?U)a{1,5}\", \"a{1,5}?\");\n    }\n\n    #[test]\n    fn print_group() {\n        roundtrip(\"()\", \"()\");\n        roundtrip(\"(?P<foo>)\", \"(?P<foo>)\");\n        roundtrip(\"(?:)\", \"(?:)\");\n\n        roundtrip(\"(a)\", \"(a)\");\n        roundtrip(\"(?P<foo>a)\", \"(?P<foo>a)\");\n        roundtrip(\"(?:a)\", \"(?:a)\");\n\n        roundtrip(\"((((a))))\", \"((((a))))\");\n    }\n\n    #[test]\n    fn print_alternation() {\n        roundtrip(\"|\", \"|\");\n        roundtrip(\"||\", \"||\");\n\n        roundtrip(\"a|b\", \"a|b\");\n        roundtrip(\"a|b|c\", \"a|b|c\");\n        roundtrip(\"foo|bar|quux\", \"foo|bar|quux\");\n    }\n}\n","traces":[{"line":21,"address":[7261760],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":22,"address":[7261761],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[7261776],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[7261792],"length":1,"stats":{"Line":0},"fn_name":"build"},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[7261808],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":60,"address":[7261809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[6912576],"length":1,"stats":{"Line":0},"fn_name":"print<&mut core::fmt::Formatter>"},{"line":68,"address":[6912595],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[6912656],"length":1,"stats":{"Line":0},"fn_name":"finish<&mut core::fmt::Formatter>"},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[6912688],"length":1,"stats":{"Line":0},"fn_name":"visit_pre<&mut core::fmt::Formatter>"},{"line":87,"address":[6915956,6914340,6916910,6913111,6915456,6915581,6915331,6912811,6915831,6916081,6912719,6915706,6913259,6916206,6916331],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[6912744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[6912789,6913026],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[6913116,6913044,6913146],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[6913173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[6913264,6913191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[6912821,6913304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[6913457,6913334],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[6913433,6913503,6914283,6913655],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[6913879,6913689,6914253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[6913786,6913884],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[6913929,6913760,6914042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[6914009,6914077,6914145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[6914130,6914188,6914255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[6913619,6914295,6914345],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[6914388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[6914535,6914418],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[6914517,6914712,6915277,6914575],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[6914897,6914746,6915247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[6914902,6914813],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[6914944,6914796,6915051],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[6915145,6915021,6915083],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[6915133,6915185,6915249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[6915336,6915286,6914679],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[6912849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[6915461,6915379],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[6915586,6915504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[6915629,6915711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[6915754,6915836],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[6912895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[6915961,6915879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[6916004,6916086],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[6916211,6916129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[6916254,6916336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[6916880,6912941,6916801,6916412,6916506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[6912961],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[6916429,6916511],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[6916556],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[6916578,6916803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[6916379,6916882,6916835],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[6916912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[6916928],"length":1,"stats":{"Line":0},"fn_name":"visit_post<&mut core::fmt::Formatter>"},{"line":164,"address":[6918855,6917100,6918909,6916959],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[6916984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[6917110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[6917378,6917534,6917665,6918710,6917278],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[6917130],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[6917295,6917383,6917413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[6917451,6917539],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[6917582,6917670],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[6918138,6918430,6918680,6917873,6917201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[6917890,6917221],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[6918143,6917908],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[6918188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[6918435,6918206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[6917713],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[6918682,6918478,6917741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[6918825,6918720],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[6918827,6918748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[6918864,6917064,6918911],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[6918939],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[6918960],"length":1,"stats":{"Line":0},"fn_name":"visit_alternation_in<&mut core::fmt::Formatter>"},{"line":208,"address":[6918976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[6919024],"length":1,"stats":{"Line":0},"fn_name":"write_literal_char<&mut core::fmt::Formatter>"},{"line":214,"address":[6919151,6919042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[6919080,6919177,6919153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[6919196],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[6919232],"length":1,"stats":{"Line":0},"fn_name":"write_literal_byte<&mut core::fmt::Formatter>"},{"line":221,"address":[6919252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[6919490,6919264,6919616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[6919478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[6919396,6919497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[6919648],"length":1,"stats":{"Line":0},"fn_name":"write_literal_class_byte<&mut core::fmt::Formatter>"},{"line":230,"address":[6919668],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[6919680,6919906,6920029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[6919894],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[6919913,6919812],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":109},{"path":["/","usr","src","regex","regex-syntax","src","hir","translate.rs"],"content":"/*!\nDefines a translator that converts an `Ast` to an `Hir`.\n*/\n\nuse std::cell::{Cell, RefCell};\nuse std::result;\n\nuse ast::{self, Ast, Span, Visitor};\nuse hir::{self, Error, ErrorKind, Hir};\nuse unicode::{self, ClassQuery};\n\ntype Result<T> = result::Result<T, Error>;\n\n/// A builder for constructing an AST->HIR translator.\n#[derive(Clone, Debug)]\npub struct TranslatorBuilder {\n    allow_invalid_utf8: bool,\n    flags: Flags,\n}\n\nimpl Default for TranslatorBuilder {\n    fn default() -> TranslatorBuilder {\n        TranslatorBuilder::new()\n    }\n}\n\nimpl TranslatorBuilder {\n    /// Create a new translator builder with a default c onfiguration.\n    pub fn new() -> TranslatorBuilder {\n        TranslatorBuilder {\n            allow_invalid_utf8: false,\n            flags: Flags::default(),\n        }\n    }\n\n    /// Build a translator using the current configuration.\n    pub fn build(&self) -> Translator {\n        Translator {\n            stack: RefCell::new(vec![]),\n            flags: Cell::new(self.flags),\n            allow_invalid_utf8: self.allow_invalid_utf8,\n        }\n    }\n\n    /// When enabled, translation will permit the construction of a regular\n    /// expression that may match invalid UTF-8.\n    ///\n    /// When disabled (the default), the translator is guaranteed to produce\n    /// an expression that will only ever match valid UTF-8 (otherwise, the\n    /// translator will return an error).\n    ///\n    /// Perhaps surprisingly, when invalid UTF-8 isn't allowed, a negated ASCII\n    /// word boundary (uttered as `(?-u:\\B)` in the concrete syntax) will cause\n    /// the parser to return an error. Namely, a negated ASCII word boundary\n    /// can result in matching positions that aren't valid UTF-8 boundaries.\n    pub fn allow_invalid_utf8(&mut self, yes: bool) -> &mut TranslatorBuilder {\n        self.allow_invalid_utf8 = yes;\n        self\n    }\n\n    /// Enable or disable the case insensitive flag (`i`) by default.\n    pub fn case_insensitive(&mut self, yes: bool) -> &mut TranslatorBuilder {\n        self.flags.case_insensitive = if yes { Some(true) } else { None };\n        self\n    }\n\n    /// Enable or disable the multi-line matching flag (`m`) by default.\n    pub fn multi_line(&mut self, yes: bool) -> &mut TranslatorBuilder {\n        self.flags.multi_line = if yes { Some(true) } else { None };\n        self\n    }\n\n    /// Enable or disable the \"dot matches any character\" flag (`s`) by\n    /// default.\n    pub fn dot_matches_new_line(\n        &mut self,\n        yes: bool,\n    ) -> &mut TranslatorBuilder {\n        self.flags.dot_matches_new_line = if yes { Some(true) } else { None };\n        self\n    }\n\n    /// Enable or disable the \"swap greed\" flag (`U`) by default.\n    pub fn swap_greed(&mut self, yes: bool) -> &mut TranslatorBuilder {\n        self.flags.swap_greed = if yes { Some(true) } else { None };\n        self\n    }\n\n    /// Enable or disable the Unicode flag (`u`) by default.\n    pub fn unicode(&mut self, yes: bool) -> &mut TranslatorBuilder {\n        self.flags.unicode = if yes { None } else { Some(false) };\n        self\n    }\n}\n\n/// A translator maps abstract syntax to a high level intermediate\n/// representation.\n///\n/// A translator may be benefit from reuse. That is, a translator can translate\n/// many abstract syntax trees.\n///\n/// A `Translator` can be configured in more detail via a\n/// [`TranslatorBuilder`](struct.TranslatorBuilder.html).\n#[derive(Clone, Debug)]\npub struct Translator {\n    /// Our call stack, but on the heap.\n    stack: RefCell<Vec<HirFrame>>,\n    /// The current flag settings.\n    flags: Cell<Flags>,\n    /// Whether we're allowed to produce HIR that can match arbitrary bytes.\n    allow_invalid_utf8: bool,\n}\n\nimpl Translator {\n    /// Create a new translator using the default configuration.\n    pub fn new() -> Translator {\n        TranslatorBuilder::new().build()\n    }\n\n    /// Translate the given abstract syntax tree (AST) into a high level\n    /// intermediate representation (HIR).\n    ///\n    /// If there was a problem doing the translation, then an HIR-specific\n    /// error is returned.\n    ///\n    /// The original pattern string used to produce the `Ast` *must* also be\n    /// provided. The translator does not use the pattern string during any\n    /// correct translation, but is used for error reporting.\n    pub fn translate(&mut self, pattern: &str, ast: &Ast) -> Result<Hir> {\n        ast::visit(ast, TranslatorI::new(self, pattern))\n    }\n}\n\n/// An HirFrame is a single stack frame, represented explicitly, which is\n/// created for each item in the Ast that we traverse.\n///\n/// Note that technically, this type doesn't represent our entire stack\n/// frame. In particular, the Ast visitor represents any state associated with\n/// traversing the Ast itself.\n#[derive(Clone, Debug)]\nenum HirFrame {\n    /// An arbitrary HIR expression. These get pushed whenever we hit a base\n    /// case in the Ast. They get popped after an inductive (i.e., recursive)\n    /// step is complete.\n    Expr(Hir),\n    /// A Unicode character class. This frame is mutated as we descend into\n    /// the Ast of a character class (which is itself its own mini recursive\n    /// structure).\n    ClassUnicode(hir::ClassUnicode),\n    /// A byte-oriented character class. This frame is mutated as we descend\n    /// into the Ast of a character class (which is itself its own mini\n    /// recursive structure).\n    ///\n    /// Byte character classes are created when Unicode mode (`u`) is disabled.\n    /// If `allow_invalid_utf8` is disabled (the default), then a byte\n    /// character is only permitted to match ASCII text.\n    ClassBytes(hir::ClassBytes),\n    /// This is pushed on to the stack upon first seeing any kind of group,\n    /// indicated by parentheses (including non-capturing groups). It is popped\n    /// upon leaving a group.\n    Group {\n        /// The old active flags when this group was opened.\n        ///\n        /// If this group sets flags, then the new active flags are set to the\n        /// result of merging the old flags with the flags introduced by this\n        /// group. If the group doesn't set any flags, then this is simply\n        /// equivalent to whatever flags were set when the group was opened.\n        ///\n        /// When this group is popped, the active flags should be restored to\n        /// the flags set here.\n        ///\n        /// The \"active\" flags correspond to whatever flags are set in the\n        /// Translator.\n        old_flags: Flags,\n    },\n    /// This is pushed whenever a concatenation is observed. After visiting\n    /// every sub-expression in the concatenation, the translator's stack is\n    /// popped until it sees a Concat frame.\n    Concat,\n    /// This is pushed whenever an alternation is observed. After visiting\n    /// every sub-expression in the alternation, the translator's stack is\n    /// popped until it sees an Alternation frame.\n    Alternation,\n}\n\nimpl HirFrame {\n    /// Assert that the current stack frame is an Hir expression and return it.\n    fn unwrap_expr(self) -> Hir {\n        match self {\n            HirFrame::Expr(expr) => expr,\n            _ => panic!(\"tried to unwrap expr from HirFrame, got: {:?}\", self),\n        }\n    }\n\n    /// Assert that the current stack frame is a Unicode class expression and\n    /// return it.\n    fn unwrap_class_unicode(self) -> hir::ClassUnicode {\n        match self {\n            HirFrame::ClassUnicode(cls) => cls,\n            _ => panic!(\n                \"tried to unwrap Unicode class \\\n                 from HirFrame, got: {:?}\",\n                self\n            ),\n        }\n    }\n\n    /// Assert that the current stack frame is a byte class expression and\n    /// return it.\n    fn unwrap_class_bytes(self) -> hir::ClassBytes {\n        match self {\n            HirFrame::ClassBytes(cls) => cls,\n            _ => panic!(\n                \"tried to unwrap byte class \\\n                 from HirFrame, got: {:?}\",\n                self\n            ),\n        }\n    }\n\n    /// Assert that the current stack frame is a group indicator and return\n    /// its corresponding flags (the flags that were active at the time the\n    /// group was entered).\n    fn unwrap_group(self) -> Flags {\n        match self {\n            HirFrame::Group { old_flags } => old_flags,\n            _ => {\n                panic!(\"tried to unwrap group from HirFrame, got: {:?}\", self)\n            }\n        }\n    }\n}\n\nimpl<'t, 'p> Visitor for TranslatorI<'t, 'p> {\n    type Output = Hir;\n    type Err = Error;\n\n    fn finish(self) -> Result<Hir> {\n        // ... otherwise, we should have exactly one HIR on the stack.\n        assert_eq!(self.trans().stack.borrow().len(), 1);\n        Ok(self.pop().unwrap().unwrap_expr())\n    }\n\n    fn visit_pre(&mut self, ast: &Ast) -> Result<()> {\n        match *ast {\n            Ast::Class(ast::Class::Bracketed(_)) => {\n                if self.flags().unicode() {\n                    let cls = hir::ClassUnicode::empty();\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let cls = hir::ClassBytes::empty();\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            Ast::Group(ref x) => {\n                let old_flags = x\n                    .flags()\n                    .map(|ast| self.set_flags(ast))\n                    .unwrap_or_else(|| self.flags());\n                self.push(HirFrame::Group { old_flags });\n            }\n            Ast::Concat(ref x) if x.asts.is_empty() => {}\n            Ast::Concat(_) => {\n                self.push(HirFrame::Concat);\n            }\n            Ast::Alternation(ref x) if x.asts.is_empty() => {}\n            Ast::Alternation(_) => {\n                self.push(HirFrame::Alternation);\n            }\n            _ => {}\n        }\n        Ok(())\n    }\n\n    fn visit_post(&mut self, ast: &Ast) -> Result<()> {\n        match *ast {\n            Ast::Empty(_) => {\n                self.push(HirFrame::Expr(Hir::empty()));\n            }\n            Ast::Flags(ref x) => {\n                self.set_flags(&x.flags);\n                // Flags in the AST are generally considered directives and\n                // not actual sub-expressions. However, they can be used in\n                // the concrete syntax like `((?i))`, and we need some kind of\n                // indication of an expression there, and Empty is the correct\n                // choice.\n                //\n                // There can also be things like `(?i)+`, but we rule those out\n                // in the parser. In the future, we might allow them for\n                // consistency sake.\n                self.push(HirFrame::Expr(Hir::empty()));\n            }\n            Ast::Literal(ref x) => {\n                self.push(HirFrame::Expr(self.hir_literal(x)?));\n            }\n            Ast::Dot(span) => {\n                self.push(HirFrame::Expr(self.hir_dot(span)?));\n            }\n            Ast::Assertion(ref x) => {\n                self.push(HirFrame::Expr(self.hir_assertion(x)?));\n            }\n            Ast::Class(ast::Class::Perl(ref x)) => {\n                if self.flags().unicode() {\n                    let cls = self.hir_perl_unicode_class(x)?;\n                    let hcls = hir::Class::Unicode(cls);\n                    self.push(HirFrame::Expr(Hir::class(hcls)));\n                } else {\n                    let cls = self.hir_perl_byte_class(x);\n                    let hcls = hir::Class::Bytes(cls);\n                    self.push(HirFrame::Expr(Hir::class(hcls)));\n                }\n            }\n            Ast::Class(ast::Class::Unicode(ref x)) => {\n                let cls = hir::Class::Unicode(self.hir_unicode_class(x)?);\n                self.push(HirFrame::Expr(Hir::class(cls)));\n            }\n            Ast::Class(ast::Class::Bracketed(ref ast)) => {\n                if self.flags().unicode() {\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    self.unicode_fold_and_negate(\n                        &ast.span,\n                        ast.negated,\n                        &mut cls,\n                    )?;\n                    if cls.iter().next().is_none() {\n                        return Err(self.error(\n                            ast.span,\n                            ErrorKind::EmptyClassNotAllowed,\n                        ));\n                    }\n                    let expr = Hir::class(hir::Class::Unicode(cls));\n                    self.push(HirFrame::Expr(expr));\n                } else {\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    self.bytes_fold_and_negate(\n                        &ast.span,\n                        ast.negated,\n                        &mut cls,\n                    )?;\n                    if cls.iter().next().is_none() {\n                        return Err(self.error(\n                            ast.span,\n                            ErrorKind::EmptyClassNotAllowed,\n                        ));\n                    }\n\n                    let expr = Hir::class(hir::Class::Bytes(cls));\n                    self.push(HirFrame::Expr(expr));\n                }\n            }\n            Ast::Repetition(ref x) => {\n                let expr = self.pop().unwrap().unwrap_expr();\n                self.push(HirFrame::Expr(self.hir_repetition(x, expr)));\n            }\n            Ast::Group(ref x) => {\n                let expr = self.pop().unwrap().unwrap_expr();\n                let old_flags = self.pop().unwrap().unwrap_group();\n                self.trans().flags.set(old_flags);\n                self.push(HirFrame::Expr(self.hir_group(x, expr)));\n            }\n            Ast::Concat(_) => {\n                let mut exprs = vec![];\n                while let Some(HirFrame::Expr(expr)) = self.pop() {\n                    if !expr.kind().is_empty() {\n                        exprs.push(expr);\n                    }\n                }\n                exprs.reverse();\n                self.push(HirFrame::Expr(Hir::concat(exprs)));\n            }\n            Ast::Alternation(_) => {\n                let mut exprs = vec![];\n                while let Some(HirFrame::Expr(expr)) = self.pop() {\n                    exprs.push(expr);\n                }\n                exprs.reverse();\n                self.push(HirFrame::Expr(Hir::alternation(exprs)));\n            }\n        }\n        Ok(())\n    }\n\n    fn visit_class_set_item_pre(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<()> {\n        match *ast {\n            ast::ClassSetItem::Bracketed(_) => {\n                if self.flags().unicode() {\n                    let cls = hir::ClassUnicode::empty();\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let cls = hir::ClassBytes::empty();\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            // We needn't handle the Union case here since the visitor will\n            // do it for us.\n            _ => {}\n        }\n        Ok(())\n    }\n\n    fn visit_class_set_item_post(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<()> {\n        match *ast {\n            ast::ClassSetItem::Empty(_) => {}\n            ast::ClassSetItem::Literal(ref x) => {\n                if self.flags().unicode() {\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    cls.push(hir::ClassUnicodeRange::new(x.c, x.c));\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    let byte = self.class_literal_byte(x)?;\n                    cls.push(hir::ClassBytesRange::new(byte, byte));\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            ast::ClassSetItem::Range(ref x) => {\n                if self.flags().unicode() {\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    cls.push(hir::ClassUnicodeRange::new(x.start.c, x.end.c));\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    let start = self.class_literal_byte(&x.start)?;\n                    let end = self.class_literal_byte(&x.end)?;\n                    cls.push(hir::ClassBytesRange::new(start, end));\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            ast::ClassSetItem::Ascii(ref x) => {\n                if self.flags().unicode() {\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    for &(s, e) in ascii_class(&x.kind) {\n                        cls.push(hir::ClassUnicodeRange::new(s, e));\n                    }\n                    self.unicode_fold_and_negate(\n                        &x.span, x.negated, &mut cls,\n                    )?;\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    for &(s, e) in ascii_class(&x.kind) {\n                        cls.push(hir::ClassBytesRange::new(s as u8, e as u8));\n                    }\n                    self.bytes_fold_and_negate(&x.span, x.negated, &mut cls)?;\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            ast::ClassSetItem::Unicode(ref x) => {\n                let xcls = self.hir_unicode_class(x)?;\n                let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                cls.union(&xcls);\n                self.push(HirFrame::ClassUnicode(cls));\n            }\n            ast::ClassSetItem::Perl(ref x) => {\n                if self.flags().unicode() {\n                    let xcls = self.hir_perl_unicode_class(x)?;\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    cls.union(&xcls);\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let xcls = self.hir_perl_byte_class(x);\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    cls.union(&xcls);\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            ast::ClassSetItem::Bracketed(ref ast) => {\n                if self.flags().unicode() {\n                    let mut cls1 = self.pop().unwrap().unwrap_class_unicode();\n                    self.unicode_fold_and_negate(\n                        &ast.span,\n                        ast.negated,\n                        &mut cls1,\n                    )?;\n\n                    let mut cls2 = self.pop().unwrap().unwrap_class_unicode();\n                    cls2.union(&cls1);\n                    self.push(HirFrame::ClassUnicode(cls2));\n                } else {\n                    let mut cls1 = self.pop().unwrap().unwrap_class_bytes();\n                    self.bytes_fold_and_negate(\n                        &ast.span,\n                        ast.negated,\n                        &mut cls1,\n                    )?;\n\n                    let mut cls2 = self.pop().unwrap().unwrap_class_bytes();\n                    cls2.union(&cls1);\n                    self.push(HirFrame::ClassBytes(cls2));\n                }\n            }\n            // This is handled automatically by the visitor.\n            ast::ClassSetItem::Union(_) => {}\n        }\n        Ok(())\n    }\n\n    fn visit_class_set_binary_op_pre(\n        &mut self,\n        _op: &ast::ClassSetBinaryOp,\n    ) -> Result<()> {\n        if self.flags().unicode() {\n            let cls = hir::ClassUnicode::empty();\n            self.push(HirFrame::ClassUnicode(cls));\n        } else {\n            let cls = hir::ClassBytes::empty();\n            self.push(HirFrame::ClassBytes(cls));\n        }\n        Ok(())\n    }\n\n    fn visit_class_set_binary_op_in(\n        &mut self,\n        _op: &ast::ClassSetBinaryOp,\n    ) -> Result<()> {\n        if self.flags().unicode() {\n            let cls = hir::ClassUnicode::empty();\n            self.push(HirFrame::ClassUnicode(cls));\n        } else {\n            let cls = hir::ClassBytes::empty();\n            self.push(HirFrame::ClassBytes(cls));\n        }\n        Ok(())\n    }\n\n    fn visit_class_set_binary_op_post(\n        &mut self,\n        op: &ast::ClassSetBinaryOp,\n    ) -> Result<()> {\n        use ast::ClassSetBinaryOpKind::*;\n\n        if self.flags().unicode() {\n            let mut rhs = self.pop().unwrap().unwrap_class_unicode();\n            let mut lhs = self.pop().unwrap().unwrap_class_unicode();\n            let mut cls = self.pop().unwrap().unwrap_class_unicode();\n            if self.flags().case_insensitive() {\n                rhs.try_case_fold_simple().map_err(|_| {\n                    self.error(\n                        op.rhs.span().clone(),\n                        ErrorKind::UnicodeCaseUnavailable,\n                    )\n                })?;\n                lhs.try_case_fold_simple().map_err(|_| {\n                    self.error(\n                        op.lhs.span().clone(),\n                        ErrorKind::UnicodeCaseUnavailable,\n                    )\n                })?;\n            }\n            match op.kind {\n                Intersection => lhs.intersect(&rhs),\n                Difference => lhs.difference(&rhs),\n                SymmetricDifference => lhs.symmetric_difference(&rhs),\n            }\n            cls.union(&lhs);\n            self.push(HirFrame::ClassUnicode(cls));\n        } else {\n            let mut rhs = self.pop().unwrap().unwrap_class_bytes();\n            let mut lhs = self.pop().unwrap().unwrap_class_bytes();\n            let mut cls = self.pop().unwrap().unwrap_class_bytes();\n            if self.flags().case_insensitive() {\n                rhs.case_fold_simple();\n                lhs.case_fold_simple();\n            }\n            match op.kind {\n                Intersection => lhs.intersect(&rhs),\n                Difference => lhs.difference(&rhs),\n                SymmetricDifference => lhs.symmetric_difference(&rhs),\n            }\n            cls.union(&lhs);\n            self.push(HirFrame::ClassBytes(cls));\n        }\n        Ok(())\n    }\n}\n\n/// The internal implementation of a translator.\n///\n/// This type is responsible for carrying around the original pattern string,\n/// which is not tied to the internal state of a translator.\n///\n/// A TranslatorI exists for the time it takes to translate a single Ast.\n#[derive(Clone, Debug)]\nstruct TranslatorI<'t, 'p> {\n    trans: &'t Translator,\n    pattern: &'p str,\n}\n\nimpl<'t, 'p> TranslatorI<'t, 'p> {\n    /// Build a new internal translator.\n    fn new(trans: &'t Translator, pattern: &'p str) -> TranslatorI<'t, 'p> {\n        TranslatorI { trans: trans, pattern: pattern }\n    }\n\n    /// Return a reference to the underlying translator.\n    fn trans(&self) -> &Translator {\n        &self.trans\n    }\n\n    /// Push the given frame on to the call stack.\n    fn push(&self, frame: HirFrame) {\n        self.trans().stack.borrow_mut().push(frame);\n    }\n\n    /// Pop the top of the call stack. If the call stack is empty, return None.\n    fn pop(&self) -> Option<HirFrame> {\n        self.trans().stack.borrow_mut().pop()\n    }\n\n    /// Create a new error with the given span and error type.\n    fn error(&self, span: Span, kind: ErrorKind) -> Error {\n        Error { kind: kind, pattern: self.pattern.to_string(), span: span }\n    }\n\n    /// Return a copy of the active flags.\n    fn flags(&self) -> Flags {\n        self.trans().flags.get()\n    }\n\n    /// Set the flags of this translator from the flags set in the given AST.\n    /// Then, return the old flags.\n    fn set_flags(&self, ast_flags: &ast::Flags) -> Flags {\n        let old_flags = self.flags();\n        let mut new_flags = Flags::from_ast(ast_flags);\n        new_flags.merge(&old_flags);\n        self.trans().flags.set(new_flags);\n        old_flags\n    }\n\n    fn hir_literal(&self, lit: &ast::Literal) -> Result<Hir> {\n        let ch = match self.literal_to_char(lit)? {\n            byte @ hir::Literal::Byte(_) => return Ok(Hir::literal(byte)),\n            hir::Literal::Unicode(ch) => ch,\n        };\n        if self.flags().case_insensitive() {\n            self.hir_from_char_case_insensitive(lit.span, ch)\n        } else {\n            self.hir_from_char(lit.span, ch)\n        }\n    }\n\n    /// Convert an Ast literal to its scalar representation.\n    ///\n    /// When Unicode mode is enabled, then this always succeeds and returns a\n    /// `char` (Unicode scalar value).\n    ///\n    /// When Unicode mode is disabled, then a raw byte is returned. If that\n    /// byte is not ASCII and invalid UTF-8 is not allowed, then this returns\n    /// an error.\n    fn literal_to_char(&self, lit: &ast::Literal) -> Result<hir::Literal> {\n        if self.flags().unicode() {\n            return Ok(hir::Literal::Unicode(lit.c));\n        }\n        let byte = match lit.byte() {\n            None => return Ok(hir::Literal::Unicode(lit.c)),\n            Some(byte) => byte,\n        };\n        if byte <= 0x7F {\n            return Ok(hir::Literal::Unicode(byte as char));\n        }\n        if !self.trans().allow_invalid_utf8 {\n            return Err(self.error(lit.span, ErrorKind::InvalidUtf8));\n        }\n        Ok(hir::Literal::Byte(byte))\n    }\n\n    fn hir_from_char(&self, span: Span, c: char) -> Result<Hir> {\n        if !self.flags().unicode() && c.len_utf8() > 1 {\n            return Err(self.error(span, ErrorKind::UnicodeNotAllowed));\n        }\n        Ok(Hir::literal(hir::Literal::Unicode(c)))\n    }\n\n    fn hir_from_char_case_insensitive(\n        &self,\n        span: Span,\n        c: char,\n    ) -> Result<Hir> {\n        if self.flags().unicode() {\n            // If case folding won't do anything, then don't bother trying.\n            let map =\n                unicode::contains_simple_case_mapping(c, c).map_err(|_| {\n                    self.error(span, ErrorKind::UnicodeCaseUnavailable)\n                })?;\n            if !map {\n                return self.hir_from_char(span, c);\n            }\n            let mut cls =\n                hir::ClassUnicode::new(vec![hir::ClassUnicodeRange::new(\n                    c, c,\n                )]);\n            cls.try_case_fold_simple().map_err(|_| {\n                self.error(span, ErrorKind::UnicodeCaseUnavailable)\n            })?;\n            Ok(Hir::class(hir::Class::Unicode(cls)))\n        } else {\n            if c.len_utf8() > 1 {\n                return Err(self.error(span, ErrorKind::UnicodeNotAllowed));\n            }\n            // If case folding won't do anything, then don't bother trying.\n            match c {\n                'A'..='Z' | 'a'..='z' => {}\n                _ => return self.hir_from_char(span, c),\n            }\n            let mut cls =\n                hir::ClassBytes::new(vec![hir::ClassBytesRange::new(\n                    c as u8, c as u8,\n                )]);\n            cls.case_fold_simple();\n            Ok(Hir::class(hir::Class::Bytes(cls)))\n        }\n    }\n\n    fn hir_dot(&self, span: Span) -> Result<Hir> {\n        let unicode = self.flags().unicode();\n        if !unicode && !self.trans().allow_invalid_utf8 {\n            return Err(self.error(span, ErrorKind::InvalidUtf8));\n        }\n        Ok(if self.flags().dot_matches_new_line() {\n            Hir::any(!unicode)\n        } else {\n            Hir::dot(!unicode)\n        })\n    }\n\n    fn hir_assertion(&self, asst: &ast::Assertion) -> Result<Hir> {\n        let unicode = self.flags().unicode();\n        let multi_line = self.flags().multi_line();\n        Ok(match asst.kind {\n            ast::AssertionKind::StartLine => Hir::anchor(if multi_line {\n                hir::Anchor::StartLine\n            } else {\n                hir::Anchor::StartText\n            }),\n            ast::AssertionKind::EndLine => Hir::anchor(if multi_line {\n                hir::Anchor::EndLine\n            } else {\n                hir::Anchor::EndText\n            }),\n            ast::AssertionKind::StartText => {\n                Hir::anchor(hir::Anchor::StartText)\n            }\n            ast::AssertionKind::EndText => Hir::anchor(hir::Anchor::EndText),\n            ast::AssertionKind::WordBoundary => {\n                Hir::word_boundary(if unicode {\n                    hir::WordBoundary::Unicode\n                } else {\n                    hir::WordBoundary::Ascii\n                })\n            }\n            ast::AssertionKind::NotWordBoundary => {\n                Hir::word_boundary(if unicode {\n                    hir::WordBoundary::UnicodeNegate\n                } else {\n                    // It is possible for negated ASCII word boundaries to\n                    // match at invalid UTF-8 boundaries, even when searching\n                    // valid UTF-8.\n                    if !self.trans().allow_invalid_utf8 {\n                        return Err(\n                            self.error(asst.span, ErrorKind::InvalidUtf8)\n                        );\n                    }\n                    hir::WordBoundary::AsciiNegate\n                })\n            }\n        })\n    }\n\n    fn hir_group(&self, group: &ast::Group, expr: Hir) -> Hir {\n        let kind = match group.kind {\n            ast::GroupKind::CaptureIndex(idx) => {\n                hir::GroupKind::CaptureIndex(idx)\n            }\n            ast::GroupKind::CaptureName(ref capname) => {\n                hir::GroupKind::CaptureName {\n                    name: capname.name.clone(),\n                    index: capname.index,\n                }\n            }\n            ast::GroupKind::NonCapturing(_) => hir::GroupKind::NonCapturing,\n        };\n        Hir::group(hir::Group { kind: kind, hir: Box::new(expr) })\n    }\n\n    fn hir_repetition(&self, rep: &ast::Repetition, expr: Hir) -> Hir {\n        let kind = match rep.op.kind {\n            ast::RepetitionKind::ZeroOrOne => hir::RepetitionKind::ZeroOrOne,\n            ast::RepetitionKind::ZeroOrMore => hir::RepetitionKind::ZeroOrMore,\n            ast::RepetitionKind::OneOrMore => hir::RepetitionKind::OneOrMore,\n            ast::RepetitionKind::Range(ast::RepetitionRange::Exactly(m)) => {\n                hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(m))\n            }\n            ast::RepetitionKind::Range(ast::RepetitionRange::AtLeast(m)) => {\n                hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(m))\n            }\n            ast::RepetitionKind::Range(ast::RepetitionRange::Bounded(\n                m,\n                n,\n            )) => {\n                hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(m, n))\n            }\n        };\n        let greedy =\n            if self.flags().swap_greed() { !rep.greedy } else { rep.greedy };\n        Hir::repetition(hir::Repetition {\n            kind: kind,\n            greedy: greedy,\n            hir: Box::new(expr),\n        })\n    }\n\n    fn hir_unicode_class(\n        &self,\n        ast_class: &ast::ClassUnicode,\n    ) -> Result<hir::ClassUnicode> {\n        use ast::ClassUnicodeKind::*;\n\n        if !self.flags().unicode() {\n            return Err(\n                self.error(ast_class.span, ErrorKind::UnicodeNotAllowed)\n            );\n        }\n        let query = match ast_class.kind {\n            OneLetter(name) => ClassQuery::OneLetter(name),\n            Named(ref name) => ClassQuery::Binary(name),\n            NamedValue { ref name, ref value, .. } => ClassQuery::ByValue {\n                property_name: name,\n                property_value: value,\n            },\n        };\n        let mut result = self.convert_unicode_class_error(\n            &ast_class.span,\n            unicode::class(query),\n        );\n        if let Ok(ref mut class) = result {\n            self.unicode_fold_and_negate(\n                &ast_class.span,\n                ast_class.negated,\n                class,\n            )?;\n        }\n        result\n    }\n\n    fn hir_perl_unicode_class(\n        &self,\n        ast_class: &ast::ClassPerl,\n    ) -> Result<hir::ClassUnicode> {\n        use ast::ClassPerlKind::*;\n\n        assert!(self.flags().unicode());\n        let result = match ast_class.kind {\n            Digit => unicode::perl_digit(),\n            Space => unicode::perl_space(),\n            Word => unicode::perl_word(),\n        };\n        let mut class =\n            self.convert_unicode_class_error(&ast_class.span, result)?;\n        // We needn't apply case folding here because the Perl Unicode classes\n        // are already closed under Unicode simple case folding.\n        if ast_class.negated {\n            class.negate();\n        }\n        Ok(class)\n    }\n\n    fn hir_perl_byte_class(\n        &self,\n        ast_class: &ast::ClassPerl,\n    ) -> hir::ClassBytes {\n        use ast::ClassPerlKind::*;\n\n        assert!(!self.flags().unicode());\n        let mut class = match ast_class.kind {\n            Digit => hir_ascii_class_bytes(&ast::ClassAsciiKind::Digit),\n            Space => hir_ascii_class_bytes(&ast::ClassAsciiKind::Space),\n            Word => hir_ascii_class_bytes(&ast::ClassAsciiKind::Word),\n        };\n        // We needn't apply case folding here because the Perl ASCII classes\n        // are already closed (under ASCII case folding).\n        if ast_class.negated {\n            class.negate();\n        }\n        class\n    }\n\n    /// Converts the given Unicode specific error to an HIR translation error.\n    ///\n    /// The span given should approximate the position at which an error would\n    /// occur.\n    fn convert_unicode_class_error(\n        &self,\n        span: &Span,\n        result: unicode::Result<hir::ClassUnicode>,\n    ) -> Result<hir::ClassUnicode> {\n        result.map_err(|err| {\n            let sp = span.clone();\n            match err {\n                unicode::Error::PropertyNotFound => {\n                    self.error(sp, ErrorKind::UnicodePropertyNotFound)\n                }\n                unicode::Error::PropertyValueNotFound => {\n                    self.error(sp, ErrorKind::UnicodePropertyValueNotFound)\n                }\n                unicode::Error::PerlClassNotFound => {\n                    self.error(sp, ErrorKind::UnicodePerlClassNotFound)\n                }\n            }\n        })\n    }\n\n    fn unicode_fold_and_negate(\n        &self,\n        span: &Span,\n        negated: bool,\n        class: &mut hir::ClassUnicode,\n    ) -> Result<()> {\n        // Note that we must apply case folding before negation!\n        // Consider `(?i)[^x]`. If we applied negation field, then\n        // the result would be the character class that matched any\n        // Unicode scalar value.\n        if self.flags().case_insensitive() {\n            class.try_case_fold_simple().map_err(|_| {\n                self.error(span.clone(), ErrorKind::UnicodeCaseUnavailable)\n            })?;\n        }\n        if negated {\n            class.negate();\n        }\n        Ok(())\n    }\n\n    fn bytes_fold_and_negate(\n        &self,\n        span: &Span,\n        negated: bool,\n        class: &mut hir::ClassBytes,\n    ) -> Result<()> {\n        // Note that we must apply case folding before negation!\n        // Consider `(?i)[^x]`. If we applied negation field, then\n        // the result would be the character class that matched any\n        // Unicode scalar value.\n        if self.flags().case_insensitive() {\n            class.case_fold_simple();\n        }\n        if negated {\n            class.negate();\n        }\n        if !self.trans().allow_invalid_utf8 && !class.is_all_ascii() {\n            return Err(self.error(span.clone(), ErrorKind::InvalidUtf8));\n        }\n        Ok(())\n    }\n\n    /// Return a scalar byte value suitable for use as a literal in a byte\n    /// character class.\n    fn class_literal_byte(&self, ast: &ast::Literal) -> Result<u8> {\n        match self.literal_to_char(ast)? {\n            hir::Literal::Byte(byte) => Ok(byte),\n            hir::Literal::Unicode(ch) => {\n                if ch <= 0x7F as char {\n                    Ok(ch as u8)\n                } else {\n                    // We can't feasibly support Unicode in\n                    // byte oriented classes. Byte classes don't\n                    // do Unicode case folding.\n                    Err(self.error(ast.span, ErrorKind::UnicodeNotAllowed))\n                }\n            }\n        }\n    }\n}\n\n/// A translator's representation of a regular expression's flags at any given\n/// moment in time.\n///\n/// Each flag can be in one of three states: absent, present but disabled or\n/// present but enabled.\n#[derive(Clone, Copy, Debug, Default)]\nstruct Flags {\n    case_insensitive: Option<bool>,\n    multi_line: Option<bool>,\n    dot_matches_new_line: Option<bool>,\n    swap_greed: Option<bool>,\n    unicode: Option<bool>,\n    // Note that `ignore_whitespace` is omitted here because it is handled\n    // entirely in the parser.\n}\n\nimpl Flags {\n    fn from_ast(ast: &ast::Flags) -> Flags {\n        let mut flags = Flags::default();\n        let mut enable = true;\n        for item in &ast.items {\n            match item.kind {\n                ast::FlagsItemKind::Negation => {\n                    enable = false;\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::CaseInsensitive) => {\n                    flags.case_insensitive = Some(enable);\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::MultiLine) => {\n                    flags.multi_line = Some(enable);\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::DotMatchesNewLine) => {\n                    flags.dot_matches_new_line = Some(enable);\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::SwapGreed) => {\n                    flags.swap_greed = Some(enable);\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::Unicode) => {\n                    flags.unicode = Some(enable);\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::IgnoreWhitespace) => {}\n            }\n        }\n        flags\n    }\n\n    fn merge(&mut self, previous: &Flags) {\n        if self.case_insensitive.is_none() {\n            self.case_insensitive = previous.case_insensitive;\n        }\n        if self.multi_line.is_none() {\n            self.multi_line = previous.multi_line;\n        }\n        if self.dot_matches_new_line.is_none() {\n            self.dot_matches_new_line = previous.dot_matches_new_line;\n        }\n        if self.swap_greed.is_none() {\n            self.swap_greed = previous.swap_greed;\n        }\n        if self.unicode.is_none() {\n            self.unicode = previous.unicode;\n        }\n    }\n\n    fn case_insensitive(&self) -> bool {\n        self.case_insensitive.unwrap_or(false)\n    }\n\n    fn multi_line(&self) -> bool {\n        self.multi_line.unwrap_or(false)\n    }\n\n    fn dot_matches_new_line(&self) -> bool {\n        self.dot_matches_new_line.unwrap_or(false)\n    }\n\n    fn swap_greed(&self) -> bool {\n        self.swap_greed.unwrap_or(false)\n    }\n\n    fn unicode(&self) -> bool {\n        self.unicode.unwrap_or(true)\n    }\n}\n\nfn hir_ascii_class_bytes(kind: &ast::ClassAsciiKind) -> hir::ClassBytes {\n    let ranges: Vec<_> = ascii_class(kind)\n        .iter()\n        .cloned()\n        .map(|(s, e)| hir::ClassBytesRange::new(s as u8, e as u8))\n        .collect();\n    hir::ClassBytes::new(ranges)\n}\n\nfn ascii_class(kind: &ast::ClassAsciiKind) -> &'static [(char, char)] {\n    use ast::ClassAsciiKind::*;\n    match *kind {\n        Alnum => &[('0', '9'), ('A', 'Z'), ('a', 'z')],\n        Alpha => &[('A', 'Z'), ('a', 'z')],\n        Ascii => &[('\\x00', '\\x7F')],\n        Blank => &[('\\t', '\\t'), (' ', ' ')],\n        Cntrl => &[('\\x00', '\\x1F'), ('\\x7F', '\\x7F')],\n        Digit => &[('0', '9')],\n        Graph => &[('!', '~')],\n        Lower => &[('a', 'z')],\n        Print => &[(' ', '~')],\n        Punct => &[('!', '/'), (':', '@'), ('[', '`'), ('{', '~')],\n        Space => &[\n            ('\\t', '\\t'),\n            ('\\n', '\\n'),\n            ('\\x0B', '\\x0B'),\n            ('\\x0C', '\\x0C'),\n            ('\\r', '\\r'),\n            (' ', ' '),\n        ],\n        Upper => &[('A', 'Z')],\n        Word => &[('0', '9'), ('A', 'Z'), ('_', '_'), ('a', 'z')],\n        Xdigit => &[('0', '9'), ('A', 'F'), ('a', 'f')],\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use ast::parse::ParserBuilder;\n    use ast::{self, Ast, Position, Span};\n    use hir::{self, Hir, HirKind};\n    use unicode::{self, ClassQuery};\n\n    use super::{ascii_class, TranslatorBuilder};\n\n    // We create these errors to compare with real hir::Errors in the tests.\n    // We define equality between TestError and hir::Error to disregard the\n    // pattern string in hir::Error, which is annoying to provide in tests.\n    #[derive(Clone, Debug)]\n    struct TestError {\n        span: Span,\n        kind: hir::ErrorKind,\n    }\n\n    impl PartialEq<hir::Error> for TestError {\n        fn eq(&self, other: &hir::Error) -> bool {\n            self.span == other.span && self.kind == other.kind\n        }\n    }\n\n    impl PartialEq<TestError> for hir::Error {\n        fn eq(&self, other: &TestError) -> bool {\n            self.span == other.span && self.kind == other.kind\n        }\n    }\n\n    fn parse(pattern: &str) -> Ast {\n        ParserBuilder::new().octal(true).build().parse(pattern).unwrap()\n    }\n\n    fn t(pattern: &str) -> Hir {\n        TranslatorBuilder::new()\n            .allow_invalid_utf8(false)\n            .build()\n            .translate(pattern, &parse(pattern))\n            .unwrap()\n    }\n\n    fn t_err(pattern: &str) -> hir::Error {\n        TranslatorBuilder::new()\n            .allow_invalid_utf8(false)\n            .build()\n            .translate(pattern, &parse(pattern))\n            .unwrap_err()\n    }\n\n    fn t_bytes(pattern: &str) -> Hir {\n        TranslatorBuilder::new()\n            .allow_invalid_utf8(true)\n            .build()\n            .translate(pattern, &parse(pattern))\n            .unwrap()\n    }\n\n    fn hir_lit(s: &str) -> Hir {\n        match s.len() {\n            0 => Hir::empty(),\n            _ => {\n                let lits = s\n                    .chars()\n                    .map(hir::Literal::Unicode)\n                    .map(Hir::literal)\n                    .collect();\n                Hir::concat(lits)\n            }\n        }\n    }\n\n    fn hir_blit(s: &[u8]) -> Hir {\n        match s.len() {\n            0 => Hir::empty(),\n            1 => Hir::literal(hir::Literal::Byte(s[0])),\n            _ => {\n                let lits = s\n                    .iter()\n                    .cloned()\n                    .map(hir::Literal::Byte)\n                    .map(Hir::literal)\n                    .collect();\n                Hir::concat(lits)\n            }\n        }\n    }\n\n    fn hir_group(i: u32, expr: Hir) -> Hir {\n        Hir::group(hir::Group {\n            kind: hir::GroupKind::CaptureIndex(i),\n            hir: Box::new(expr),\n        })\n    }\n\n    fn hir_group_name(i: u32, name: &str, expr: Hir) -> Hir {\n        Hir::group(hir::Group {\n            kind: hir::GroupKind::CaptureName {\n                name: name.to_string(),\n                index: i,\n            },\n            hir: Box::new(expr),\n        })\n    }\n\n    fn hir_group_nocap(expr: Hir) -> Hir {\n        Hir::group(hir::Group {\n            kind: hir::GroupKind::NonCapturing,\n            hir: Box::new(expr),\n        })\n    }\n\n    fn hir_quest(greedy: bool, expr: Hir) -> Hir {\n        Hir::repetition(hir::Repetition {\n            kind: hir::RepetitionKind::ZeroOrOne,\n            greedy: greedy,\n            hir: Box::new(expr),\n        })\n    }\n\n    fn hir_star(greedy: bool, expr: Hir) -> Hir {\n        Hir::repetition(hir::Repetition {\n            kind: hir::RepetitionKind::ZeroOrMore,\n            greedy: greedy,\n            hir: Box::new(expr),\n        })\n    }\n\n    fn hir_plus(greedy: bool, expr: Hir) -> Hir {\n        Hir::repetition(hir::Repetition {\n            kind: hir::RepetitionKind::OneOrMore,\n            greedy: greedy,\n            hir: Box::new(expr),\n        })\n    }\n\n    fn hir_range(greedy: bool, range: hir::RepetitionRange, expr: Hir) -> Hir {\n        Hir::repetition(hir::Repetition {\n            kind: hir::RepetitionKind::Range(range),\n            greedy: greedy,\n            hir: Box::new(expr),\n        })\n    }\n\n    fn hir_alt(alts: Vec<Hir>) -> Hir {\n        Hir::alternation(alts)\n    }\n\n    fn hir_cat(exprs: Vec<Hir>) -> Hir {\n        Hir::concat(exprs)\n    }\n\n    #[allow(dead_code)]\n    fn hir_uclass_query(query: ClassQuery) -> Hir {\n        Hir::class(hir::Class::Unicode(unicode::class(query).unwrap()))\n    }\n\n    #[allow(dead_code)]\n    fn hir_uclass_perl_word() -> Hir {\n        Hir::class(hir::Class::Unicode(unicode::perl_word().unwrap()))\n    }\n\n    fn hir_uclass(ranges: &[(char, char)]) -> Hir {\n        let ranges: Vec<hir::ClassUnicodeRange> = ranges\n            .iter()\n            .map(|&(s, e)| hir::ClassUnicodeRange::new(s, e))\n            .collect();\n        Hir::class(hir::Class::Unicode(hir::ClassUnicode::new(ranges)))\n    }\n\n    fn hir_bclass(ranges: &[(u8, u8)]) -> Hir {\n        let ranges: Vec<hir::ClassBytesRange> = ranges\n            .iter()\n            .map(|&(s, e)| hir::ClassBytesRange::new(s, e))\n            .collect();\n        Hir::class(hir::Class::Bytes(hir::ClassBytes::new(ranges)))\n    }\n\n    fn hir_bclass_from_char(ranges: &[(char, char)]) -> Hir {\n        let ranges: Vec<hir::ClassBytesRange> = ranges\n            .iter()\n            .map(|&(s, e)| {\n                assert!(s as u32 <= 0x7F);\n                assert!(e as u32 <= 0x7F);\n                hir::ClassBytesRange::new(s as u8, e as u8)\n            })\n            .collect();\n        Hir::class(hir::Class::Bytes(hir::ClassBytes::new(ranges)))\n    }\n\n    fn hir_case_fold(expr: Hir) -> Hir {\n        match expr.into_kind() {\n            HirKind::Class(mut cls) => {\n                cls.case_fold_simple();\n                Hir::class(cls)\n            }\n            _ => panic!(\"cannot case fold non-class Hir expr\"),\n        }\n    }\n\n    fn hir_negate(expr: Hir) -> Hir {\n        match expr.into_kind() {\n            HirKind::Class(mut cls) => {\n                cls.negate();\n                Hir::class(cls)\n            }\n            _ => panic!(\"cannot negate non-class Hir expr\"),\n        }\n    }\n\n    #[allow(dead_code)]\n    fn hir_union(expr1: Hir, expr2: Hir) -> Hir {\n        use hir::Class::{Bytes, Unicode};\n\n        match (expr1.into_kind(), expr2.into_kind()) {\n            (HirKind::Class(Unicode(mut c1)), HirKind::Class(Unicode(c2))) => {\n                c1.union(&c2);\n                Hir::class(hir::Class::Unicode(c1))\n            }\n            (HirKind::Class(Bytes(mut c1)), HirKind::Class(Bytes(c2))) => {\n                c1.union(&c2);\n                Hir::class(hir::Class::Bytes(c1))\n            }\n            _ => panic!(\"cannot union non-class Hir exprs\"),\n        }\n    }\n\n    #[allow(dead_code)]\n    fn hir_difference(expr1: Hir, expr2: Hir) -> Hir {\n        use hir::Class::{Bytes, Unicode};\n\n        match (expr1.into_kind(), expr2.into_kind()) {\n            (HirKind::Class(Unicode(mut c1)), HirKind::Class(Unicode(c2))) => {\n                c1.difference(&c2);\n                Hir::class(hir::Class::Unicode(c1))\n            }\n            (HirKind::Class(Bytes(mut c1)), HirKind::Class(Bytes(c2))) => {\n                c1.difference(&c2);\n                Hir::class(hir::Class::Bytes(c1))\n            }\n            _ => panic!(\"cannot difference non-class Hir exprs\"),\n        }\n    }\n\n    fn hir_anchor(anchor: hir::Anchor) -> Hir {\n        Hir::anchor(anchor)\n    }\n\n    fn hir_word(wb: hir::WordBoundary) -> Hir {\n        Hir::word_boundary(wb)\n    }\n\n    #[test]\n    fn empty() {\n        assert_eq!(t(\"\"), Hir::empty());\n        assert_eq!(t(\"(?i)\"), Hir::empty());\n        assert_eq!(t(\"()\"), hir_group(1, Hir::empty()));\n        assert_eq!(t(\"(?:)\"), hir_group_nocap(Hir::empty()));\n        assert_eq!(t(\"(?P<wat>)\"), hir_group_name(1, \"wat\", Hir::empty()));\n        assert_eq!(t(\"|\"), hir_alt(vec![Hir::empty(), Hir::empty()]));\n        assert_eq!(\n            t(\"()|()\"),\n            hir_alt(vec![\n                hir_group(1, Hir::empty()),\n                hir_group(2, Hir::empty()),\n            ])\n        );\n        assert_eq!(\n            t(\"(|b)\"),\n            hir_group(1, hir_alt(vec![Hir::empty(), hir_lit(\"b\"),]))\n        );\n        assert_eq!(\n            t(\"(a|)\"),\n            hir_group(1, hir_alt(vec![hir_lit(\"a\"), Hir::empty(),]))\n        );\n        assert_eq!(\n            t(\"(a||c)\"),\n            hir_group(\n                1,\n                hir_alt(vec![hir_lit(\"a\"), Hir::empty(), hir_lit(\"c\"),])\n            )\n        );\n        assert_eq!(\n            t(\"(||)\"),\n            hir_group(\n                1,\n                hir_alt(vec![Hir::empty(), Hir::empty(), Hir::empty(),])\n            )\n        );\n    }\n\n    #[test]\n    fn literal() {\n        assert_eq!(t(\"a\"), hir_lit(\"a\"));\n        assert_eq!(t(\"(?-u)a\"), hir_lit(\"a\"));\n        assert_eq!(t(\"☃\"), hir_lit(\"☃\"));\n        assert_eq!(t(\"abcd\"), hir_lit(\"abcd\"));\n\n        assert_eq!(t_bytes(\"(?-u)a\"), hir_lit(\"a\"));\n        assert_eq!(t_bytes(\"(?-u)\\x61\"), hir_lit(\"a\"));\n        assert_eq!(t_bytes(r\"(?-u)\\x61\"), hir_lit(\"a\"));\n        assert_eq!(t_bytes(r\"(?-u)\\xFF\"), hir_blit(b\"\\xFF\"));\n\n        assert_eq!(\n            t_err(\"(?-u)☃\"),\n            TestError {\n                kind: hir::ErrorKind::UnicodeNotAllowed,\n                span: Span::new(\n                    Position::new(5, 1, 6),\n                    Position::new(8, 1, 7)\n                ),\n            }\n        );\n        assert_eq!(\n            t_err(r\"(?-u)\\xFF\"),\n            TestError {\n                kind: hir::ErrorKind::InvalidUtf8,\n                span: Span::new(\n                    Position::new(5, 1, 6),\n                    Position::new(9, 1, 10)\n                ),\n            }\n        );\n    }\n\n    #[test]\n    fn literal_case_insensitive() {\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(t(\"(?i)a\"), hir_uclass(&[('A', 'A'), ('a', 'a'),]));\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(\"(?i:a)\"),\n            hir_group_nocap(hir_uclass(&[('A', 'A'), ('a', 'a')],))\n        );\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(\"a(?i)a(?-i)a\"),\n            hir_cat(vec![\n                hir_lit(\"a\"),\n                hir_uclass(&[('A', 'A'), ('a', 'a')]),\n                hir_lit(\"a\"),\n            ])\n        );\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(\"(?i)ab@c\"),\n            hir_cat(vec![\n                hir_uclass(&[('A', 'A'), ('a', 'a')]),\n                hir_uclass(&[('B', 'B'), ('b', 'b')]),\n                hir_lit(\"@\"),\n                hir_uclass(&[('C', 'C'), ('c', 'c')]),\n            ])\n        );\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(\"(?i)β\"),\n            hir_uclass(&[('Β', 'Β'), ('β', 'β'), ('ϐ', 'ϐ'),])\n        );\n\n        assert_eq!(t(\"(?i-u)a\"), hir_bclass(&[(b'A', b'A'), (b'a', b'a'),]));\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(\"(?-u)a(?i)a(?-i)a\"),\n            hir_cat(vec![\n                hir_lit(\"a\"),\n                hir_bclass(&[(b'A', b'A'), (b'a', b'a')]),\n                hir_lit(\"a\"),\n            ])\n        );\n        assert_eq!(\n            t(\"(?i-u)ab@c\"),\n            hir_cat(vec![\n                hir_bclass(&[(b'A', b'A'), (b'a', b'a')]),\n                hir_bclass(&[(b'B', b'B'), (b'b', b'b')]),\n                hir_lit(\"@\"),\n                hir_bclass(&[(b'C', b'C'), (b'c', b'c')]),\n            ])\n        );\n\n        assert_eq!(\n            t_bytes(\"(?i-u)a\"),\n            hir_bclass(&[(b'A', b'A'), (b'a', b'a'),])\n        );\n        assert_eq!(\n            t_bytes(\"(?i-u)\\x61\"),\n            hir_bclass(&[(b'A', b'A'), (b'a', b'a'),])\n        );\n        assert_eq!(\n            t_bytes(r\"(?i-u)\\x61\"),\n            hir_bclass(&[(b'A', b'A'), (b'a', b'a'),])\n        );\n        assert_eq!(t_bytes(r\"(?i-u)\\xFF\"), hir_blit(b\"\\xFF\"));\n\n        assert_eq!(\n            t_err(\"(?i-u)β\"),\n            TestError {\n                kind: hir::ErrorKind::UnicodeNotAllowed,\n                span: Span::new(\n                    Position::new(6, 1, 7),\n                    Position::new(8, 1, 8),\n                ),\n            }\n        );\n    }\n\n    #[test]\n    fn dot() {\n        assert_eq!(\n            t(\".\"),\n            hir_uclass(&[('\\0', '\\t'), ('\\x0B', '\\u{10FFFF}'),])\n        );\n        assert_eq!(t(\"(?s).\"), hir_uclass(&[('\\0', '\\u{10FFFF}'),]));\n        assert_eq!(\n            t_bytes(\"(?-u).\"),\n            hir_bclass(&[(b'\\0', b'\\t'), (b'\\x0B', b'\\xFF'),])\n        );\n        assert_eq!(t_bytes(\"(?s-u).\"), hir_bclass(&[(b'\\0', b'\\xFF'),]));\n\n        // If invalid UTF-8 isn't allowed, then non-Unicode `.` isn't allowed.\n        assert_eq!(\n            t_err(\"(?-u).\"),\n            TestError {\n                kind: hir::ErrorKind::InvalidUtf8,\n                span: Span::new(\n                    Position::new(5, 1, 6),\n                    Position::new(6, 1, 7)\n                ),\n            }\n        );\n        assert_eq!(\n            t_err(\"(?s-u).\"),\n            TestError {\n                kind: hir::ErrorKind::InvalidUtf8,\n                span: Span::new(\n                    Position::new(6, 1, 7),\n                    Position::new(7, 1, 8)\n                ),\n            }\n        );\n    }\n\n    #[test]\n    fn assertions() {\n        assert_eq!(t(\"^\"), hir_anchor(hir::Anchor::StartText));\n        assert_eq!(t(\"$\"), hir_anchor(hir::Anchor::EndText));\n        assert_eq!(t(r\"\\A\"), hir_anchor(hir::Anchor::StartText));\n        assert_eq!(t(r\"\\z\"), hir_anchor(hir::Anchor::EndText));\n        assert_eq!(t(\"(?m)^\"), hir_anchor(hir::Anchor::StartLine));\n        assert_eq!(t(\"(?m)$\"), hir_anchor(hir::Anchor::EndLine));\n        assert_eq!(t(r\"(?m)\\A\"), hir_anchor(hir::Anchor::StartText));\n        assert_eq!(t(r\"(?m)\\z\"), hir_anchor(hir::Anchor::EndText));\n\n        assert_eq!(t(r\"\\b\"), hir_word(hir::WordBoundary::Unicode));\n        assert_eq!(t(r\"\\B\"), hir_word(hir::WordBoundary::UnicodeNegate));\n        assert_eq!(t(r\"(?-u)\\b\"), hir_word(hir::WordBoundary::Ascii));\n        assert_eq!(\n            t_bytes(r\"(?-u)\\B\"),\n            hir_word(hir::WordBoundary::AsciiNegate)\n        );\n\n        assert_eq!(\n            t_err(r\"(?-u)\\B\"),\n            TestError {\n                kind: hir::ErrorKind::InvalidUtf8,\n                span: Span::new(\n                    Position::new(5, 1, 6),\n                    Position::new(7, 1, 8)\n                ),\n            }\n        );\n    }\n\n    #[test]\n    fn group() {\n        assert_eq!(t(\"(a)\"), hir_group(1, hir_lit(\"a\")));\n        assert_eq!(\n            t(\"(a)(b)\"),\n            hir_cat(vec![\n                hir_group(1, hir_lit(\"a\")),\n                hir_group(2, hir_lit(\"b\")),\n            ])\n        );\n        assert_eq!(\n            t(\"(a)|(b)\"),\n            hir_alt(vec![\n                hir_group(1, hir_lit(\"a\")),\n                hir_group(2, hir_lit(\"b\")),\n            ])\n        );\n        assert_eq!(t(\"(?P<foo>)\"), hir_group_name(1, \"foo\", Hir::empty()));\n        assert_eq!(t(\"(?P<foo>a)\"), hir_group_name(1, \"foo\", hir_lit(\"a\")));\n        assert_eq!(\n            t(\"(?P<foo>a)(?P<bar>b)\"),\n            hir_cat(vec![\n                hir_group_name(1, \"foo\", hir_lit(\"a\")),\n                hir_group_name(2, \"bar\", hir_lit(\"b\")),\n            ])\n        );\n        assert_eq!(t(\"(?:)\"), hir_group_nocap(Hir::empty()));\n        assert_eq!(t(\"(?:a)\"), hir_group_nocap(hir_lit(\"a\")));\n        assert_eq!(\n            t(\"(?:a)(b)\"),\n            hir_cat(vec![\n                hir_group_nocap(hir_lit(\"a\")),\n                hir_group(1, hir_lit(\"b\")),\n            ])\n        );\n        assert_eq!(\n            t(\"(a)(?:b)(c)\"),\n            hir_cat(vec![\n                hir_group(1, hir_lit(\"a\")),\n                hir_group_nocap(hir_lit(\"b\")),\n                hir_group(2, hir_lit(\"c\")),\n            ])\n        );\n        assert_eq!(\n            t(\"(a)(?P<foo>b)(c)\"),\n            hir_cat(vec![\n                hir_group(1, hir_lit(\"a\")),\n                hir_group_name(2, \"foo\", hir_lit(\"b\")),\n                hir_group(3, hir_lit(\"c\")),\n            ])\n        );\n        assert_eq!(t(\"()\"), hir_group(1, Hir::empty()));\n        assert_eq!(t(\"((?i))\"), hir_group(1, Hir::empty()));\n        assert_eq!(t(\"((?x))\"), hir_group(1, Hir::empty()));\n        assert_eq!(t(\"(((?x)))\"), hir_group(1, hir_group(2, Hir::empty())));\n    }\n\n    #[test]\n    fn flags() {\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(\"(?i:a)a\"),\n            hir_cat(vec![\n                hir_group_nocap(hir_uclass(&[('A', 'A'), ('a', 'a')])),\n                hir_lit(\"a\"),\n            ])\n        );\n        assert_eq!(\n            t(\"(?i-u:a)β\"),\n            hir_cat(vec![\n                hir_group_nocap(hir_bclass(&[(b'A', b'A'), (b'a', b'a')])),\n                hir_lit(\"β\"),\n            ])\n        );\n        assert_eq!(\n            t(\"(?:(?i-u)a)b\"),\n            hir_cat(vec![\n                hir_group_nocap(hir_bclass(&[(b'A', b'A'), (b'a', b'a')])),\n                hir_lit(\"b\"),\n            ])\n        );\n        assert_eq!(\n            t(\"((?i-u)a)b\"),\n            hir_cat(vec![\n                hir_group(1, hir_bclass(&[(b'A', b'A'), (b'a', b'a')])),\n                hir_lit(\"b\"),\n            ])\n        );\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(\"(?i)(?-i:a)a\"),\n            hir_cat(vec![\n                hir_group_nocap(hir_lit(\"a\")),\n                hir_uclass(&[('A', 'A'), ('a', 'a')]),\n            ])\n        );\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(\"(?im)a^\"),\n            hir_cat(vec![\n                hir_uclass(&[('A', 'A'), ('a', 'a')]),\n                hir_anchor(hir::Anchor::StartLine),\n            ])\n        );\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(\"(?im)a^(?i-m)a^\"),\n            hir_cat(vec![\n                hir_uclass(&[('A', 'A'), ('a', 'a')]),\n                hir_anchor(hir::Anchor::StartLine),\n                hir_uclass(&[('A', 'A'), ('a', 'a')]),\n                hir_anchor(hir::Anchor::StartText),\n            ])\n        );\n        assert_eq!(\n            t(\"(?U)a*a*?(?-U)a*a*?\"),\n            hir_cat(vec![\n                hir_star(false, hir_lit(\"a\")),\n                hir_star(true, hir_lit(\"a\")),\n                hir_star(true, hir_lit(\"a\")),\n                hir_star(false, hir_lit(\"a\")),\n            ])\n        );\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(\"(?:a(?i)a)a\"),\n            hir_cat(vec![\n                hir_group_nocap(hir_cat(vec![\n                    hir_lit(\"a\"),\n                    hir_uclass(&[('A', 'A'), ('a', 'a')]),\n                ])),\n                hir_lit(\"a\"),\n            ])\n        );\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(\"(?i)(?:a(?-i)a)a\"),\n            hir_cat(vec![\n                hir_group_nocap(hir_cat(vec![\n                    hir_uclass(&[('A', 'A'), ('a', 'a')]),\n                    hir_lit(\"a\"),\n                ])),\n                hir_uclass(&[('A', 'A'), ('a', 'a')]),\n            ])\n        );\n    }\n\n    #[test]\n    fn escape() {\n        assert_eq!(\n            t(r\"\\\\\\.\\+\\*\\?\\(\\)\\|\\[\\]\\{\\}\\^\\$\\#\"),\n            hir_lit(r\"\\.+*?()|[]{}^$#\")\n        );\n    }\n\n    #[test]\n    fn repetition() {\n        assert_eq!(t(\"a?\"), hir_quest(true, hir_lit(\"a\")));\n        assert_eq!(t(\"a*\"), hir_star(true, hir_lit(\"a\")));\n        assert_eq!(t(\"a+\"), hir_plus(true, hir_lit(\"a\")));\n        assert_eq!(t(\"a??\"), hir_quest(false, hir_lit(\"a\")));\n        assert_eq!(t(\"a*?\"), hir_star(false, hir_lit(\"a\")));\n        assert_eq!(t(\"a+?\"), hir_plus(false, hir_lit(\"a\")));\n\n        assert_eq!(\n            t(\"a{1}\"),\n            hir_range(true, hir::RepetitionRange::Exactly(1), hir_lit(\"a\"),)\n        );\n        assert_eq!(\n            t(\"a{1,}\"),\n            hir_range(true, hir::RepetitionRange::AtLeast(1), hir_lit(\"a\"),)\n        );\n        assert_eq!(\n            t(\"a{1,2}\"),\n            hir_range(true, hir::RepetitionRange::Bounded(1, 2), hir_lit(\"a\"),)\n        );\n        assert_eq!(\n            t(\"a{1}?\"),\n            hir_range(false, hir::RepetitionRange::Exactly(1), hir_lit(\"a\"),)\n        );\n        assert_eq!(\n            t(\"a{1,}?\"),\n            hir_range(false, hir::RepetitionRange::AtLeast(1), hir_lit(\"a\"),)\n        );\n        assert_eq!(\n            t(\"a{1,2}?\"),\n            hir_range(\n                false,\n                hir::RepetitionRange::Bounded(1, 2),\n                hir_lit(\"a\"),\n            )\n        );\n\n        assert_eq!(\n            t(\"ab?\"),\n            hir_cat(vec![hir_lit(\"a\"), hir_quest(true, hir_lit(\"b\")),])\n        );\n        assert_eq!(\n            t(\"(ab)?\"),\n            hir_quest(\n                true,\n                hir_group(1, hir_cat(vec![hir_lit(\"a\"), hir_lit(\"b\"),]))\n            )\n        );\n        assert_eq!(\n            t(\"a|b?\"),\n            hir_alt(vec![hir_lit(\"a\"), hir_quest(true, hir_lit(\"b\")),])\n        );\n    }\n\n    #[test]\n    fn cat_alt() {\n        assert_eq!(\n            t(\"(ab)\"),\n            hir_group(1, hir_cat(vec![hir_lit(\"a\"), hir_lit(\"b\"),]))\n        );\n        assert_eq!(t(\"a|b\"), hir_alt(vec![hir_lit(\"a\"), hir_lit(\"b\"),]));\n        assert_eq!(\n            t(\"a|b|c\"),\n            hir_alt(vec![hir_lit(\"a\"), hir_lit(\"b\"), hir_lit(\"c\"),])\n        );\n        assert_eq!(\n            t(\"ab|bc|cd\"),\n            hir_alt(vec![hir_lit(\"ab\"), hir_lit(\"bc\"), hir_lit(\"cd\"),])\n        );\n        assert_eq!(\n            t(\"(a|b)\"),\n            hir_group(1, hir_alt(vec![hir_lit(\"a\"), hir_lit(\"b\"),]))\n        );\n        assert_eq!(\n            t(\"(a|b|c)\"),\n            hir_group(\n                1,\n                hir_alt(vec![hir_lit(\"a\"), hir_lit(\"b\"), hir_lit(\"c\"),])\n            )\n        );\n        assert_eq!(\n            t(\"(ab|bc|cd)\"),\n            hir_group(\n                1,\n                hir_alt(vec![hir_lit(\"ab\"), hir_lit(\"bc\"), hir_lit(\"cd\"),])\n            )\n        );\n        assert_eq!(\n            t(\"(ab|(bc|(cd)))\"),\n            hir_group(\n                1,\n                hir_alt(vec![\n                    hir_lit(\"ab\"),\n                    hir_group(\n                        2,\n                        hir_alt(vec![\n                            hir_lit(\"bc\"),\n                            hir_group(3, hir_lit(\"cd\")),\n                        ])\n                    ),\n                ])\n            )\n        );\n    }\n\n    #[test]\n    fn class_ascii() {\n        assert_eq!(\n            t(\"[[:alnum:]]\"),\n            hir_uclass(ascii_class(&ast::ClassAsciiKind::Alnum))\n        );\n        assert_eq!(\n            t(\"[[:alpha:]]\"),\n            hir_uclass(ascii_class(&ast::ClassAsciiKind::Alpha))\n        );\n        assert_eq!(\n            t(\"[[:ascii:]]\"),\n            hir_uclass(ascii_class(&ast::ClassAsciiKind::Ascii))\n        );\n        assert_eq!(\n            t(\"[[:blank:]]\"),\n            hir_uclass(ascii_class(&ast::ClassAsciiKind::Blank))\n        );\n        assert_eq!(\n            t(\"[[:cntrl:]]\"),\n            hir_uclass(ascii_class(&ast::ClassAsciiKind::Cntrl))\n        );\n        assert_eq!(\n            t(\"[[:digit:]]\"),\n            hir_uclass(ascii_class(&ast::ClassAsciiKind::Digit))\n        );\n        assert_eq!(\n            t(\"[[:graph:]]\"),\n            hir_uclass(ascii_class(&ast::ClassAsciiKind::Graph))\n        );\n        assert_eq!(\n            t(\"[[:lower:]]\"),\n            hir_uclass(ascii_class(&ast::ClassAsciiKind::Lower))\n        );\n        assert_eq!(\n            t(\"[[:print:]]\"),\n            hir_uclass(ascii_class(&ast::ClassAsciiKind::Print))\n        );\n        assert_eq!(\n            t(\"[[:punct:]]\"),\n            hir_uclass(ascii_class(&ast::ClassAsciiKind::Punct))\n        );\n        assert_eq!(\n            t(\"[[:space:]]\"),\n            hir_uclass(ascii_class(&ast::ClassAsciiKind::Space))\n        );\n        assert_eq!(\n            t(\"[[:upper:]]\"),\n            hir_uclass(ascii_class(&ast::ClassAsciiKind::Upper))\n        );\n        assert_eq!(\n            t(\"[[:word:]]\"),\n            hir_uclass(ascii_class(&ast::ClassAsciiKind::Word))\n        );\n        assert_eq!(\n            t(\"[[:xdigit:]]\"),\n            hir_uclass(ascii_class(&ast::ClassAsciiKind::Xdigit))\n        );\n\n        assert_eq!(\n            t(\"[[:^lower:]]\"),\n            hir_negate(hir_uclass(ascii_class(&ast::ClassAsciiKind::Lower)))\n        );\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(\"(?i)[[:lower:]]\"),\n            hir_uclass(&[\n                ('A', 'Z'),\n                ('a', 'z'),\n                ('\\u{17F}', '\\u{17F}'),\n                ('\\u{212A}', '\\u{212A}'),\n            ])\n        );\n\n        assert_eq!(\n            t(\"(?-u)[[:lower:]]\"),\n            hir_bclass_from_char(ascii_class(&ast::ClassAsciiKind::Lower))\n        );\n        assert_eq!(\n            t(\"(?i-u)[[:lower:]]\"),\n            hir_case_fold(hir_bclass_from_char(ascii_class(\n                &ast::ClassAsciiKind::Lower\n            )))\n        );\n\n        assert_eq!(\n            t_err(\"(?-u)[[:^lower:]]\"),\n            TestError {\n                kind: hir::ErrorKind::InvalidUtf8,\n                span: Span::new(\n                    Position::new(6, 1, 7),\n                    Position::new(16, 1, 17)\n                ),\n            }\n        );\n        assert_eq!(\n            t_err(\"(?i-u)[[:^lower:]]\"),\n            TestError {\n                kind: hir::ErrorKind::InvalidUtf8,\n                span: Span::new(\n                    Position::new(7, 1, 8),\n                    Position::new(17, 1, 18)\n                ),\n            }\n        );\n    }\n\n    #[test]\n    #[cfg(feature = \"unicode-perl\")]\n    fn class_perl() {\n        // Unicode\n        assert_eq!(t(r\"\\d\"), hir_uclass_query(ClassQuery::Binary(\"digit\")));\n        assert_eq!(t(r\"\\s\"), hir_uclass_query(ClassQuery::Binary(\"space\")));\n        assert_eq!(t(r\"\\w\"), hir_uclass_perl_word());\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(r\"(?i)\\d\"),\n            hir_uclass_query(ClassQuery::Binary(\"digit\"))\n        );\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(r\"(?i)\\s\"),\n            hir_uclass_query(ClassQuery::Binary(\"space\"))\n        );\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(t(r\"(?i)\\w\"), hir_uclass_perl_word());\n\n        // Unicode, negated\n        assert_eq!(\n            t(r\"\\D\"),\n            hir_negate(hir_uclass_query(ClassQuery::Binary(\"digit\")))\n        );\n        assert_eq!(\n            t(r\"\\S\"),\n            hir_negate(hir_uclass_query(ClassQuery::Binary(\"space\")))\n        );\n        assert_eq!(t(r\"\\W\"), hir_negate(hir_uclass_perl_word()));\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(r\"(?i)\\D\"),\n            hir_negate(hir_uclass_query(ClassQuery::Binary(\"digit\")))\n        );\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(r\"(?i)\\S\"),\n            hir_negate(hir_uclass_query(ClassQuery::Binary(\"space\")))\n        );\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(t(r\"(?i)\\W\"), hir_negate(hir_uclass_perl_word()));\n\n        // ASCII only\n        assert_eq!(\n            t(r\"(?-u)\\d\"),\n            hir_bclass_from_char(ascii_class(&ast::ClassAsciiKind::Digit))\n        );\n        assert_eq!(\n            t(r\"(?-u)\\s\"),\n            hir_bclass_from_char(ascii_class(&ast::ClassAsciiKind::Space))\n        );\n        assert_eq!(\n            t(r\"(?-u)\\w\"),\n            hir_bclass_from_char(ascii_class(&ast::ClassAsciiKind::Word))\n        );\n        assert_eq!(\n            t(r\"(?i-u)\\d\"),\n            hir_bclass_from_char(ascii_class(&ast::ClassAsciiKind::Digit))\n        );\n        assert_eq!(\n            t(r\"(?i-u)\\s\"),\n            hir_bclass_from_char(ascii_class(&ast::ClassAsciiKind::Space))\n        );\n        assert_eq!(\n            t(r\"(?i-u)\\w\"),\n            hir_bclass_from_char(ascii_class(&ast::ClassAsciiKind::Word))\n        );\n\n        // ASCII only, negated\n        assert_eq!(\n            t(r\"(?-u)\\D\"),\n            hir_negate(hir_bclass_from_char(ascii_class(\n                &ast::ClassAsciiKind::Digit\n            )))\n        );\n        assert_eq!(\n            t(r\"(?-u)\\S\"),\n            hir_negate(hir_bclass_from_char(ascii_class(\n                &ast::ClassAsciiKind::Space\n            )))\n        );\n        assert_eq!(\n            t(r\"(?-u)\\W\"),\n            hir_negate(hir_bclass_from_char(ascii_class(\n                &ast::ClassAsciiKind::Word\n            )))\n        );\n        assert_eq!(\n            t(r\"(?i-u)\\D\"),\n            hir_negate(hir_bclass_from_char(ascii_class(\n                &ast::ClassAsciiKind::Digit\n            )))\n        );\n        assert_eq!(\n            t(r\"(?i-u)\\S\"),\n            hir_negate(hir_bclass_from_char(ascii_class(\n                &ast::ClassAsciiKind::Space\n            )))\n        );\n        assert_eq!(\n            t(r\"(?i-u)\\W\"),\n            hir_negate(hir_bclass_from_char(ascii_class(\n                &ast::ClassAsciiKind::Word\n            )))\n        );\n    }\n\n    #[test]\n    #[cfg(not(feature = \"unicode-perl\"))]\n    fn class_perl_word_disabled() {\n        assert_eq!(\n            t_err(r\"\\w\"),\n            TestError {\n                kind: hir::ErrorKind::UnicodePerlClassNotFound,\n                span: Span::new(\n                    Position::new(0, 1, 1),\n                    Position::new(2, 1, 3)\n                ),\n            }\n        );\n    }\n\n    #[test]\n    #[cfg(all(not(feature = \"unicode-perl\"), not(feature = \"unicode-bool\")))]\n    fn class_perl_space_disabled() {\n        assert_eq!(\n            t_err(r\"\\s\"),\n            TestError {\n                kind: hir::ErrorKind::UnicodePerlClassNotFound,\n                span: Span::new(\n                    Position::new(0, 1, 1),\n                    Position::new(2, 1, 3)\n                ),\n            }\n        );\n    }\n\n    #[test]\n    #[cfg(all(\n        not(feature = \"unicode-perl\"),\n        not(feature = \"unicode-gencat\")\n    ))]\n    fn class_perl_digit_disabled() {\n        assert_eq!(\n            t_err(r\"\\d\"),\n            TestError {\n                kind: hir::ErrorKind::UnicodePerlClassNotFound,\n                span: Span::new(\n                    Position::new(0, 1, 1),\n                    Position::new(2, 1, 3)\n                ),\n            }\n        );\n    }\n\n    #[test]\n    #[cfg(feature = \"unicode-gencat\")]\n    fn class_unicode_gencat() {\n        assert_eq!(t(r\"\\pZ\"), hir_uclass_query(ClassQuery::Binary(\"Z\")));\n        assert_eq!(t(r\"\\pz\"), hir_uclass_query(ClassQuery::Binary(\"Z\")));\n        assert_eq!(\n            t(r\"\\p{Separator}\"),\n            hir_uclass_query(ClassQuery::Binary(\"Z\"))\n        );\n        assert_eq!(\n            t(r\"\\p{se      PaRa ToR}\"),\n            hir_uclass_query(ClassQuery::Binary(\"Z\"))\n        );\n        assert_eq!(\n            t(r\"\\p{gc:Separator}\"),\n            hir_uclass_query(ClassQuery::Binary(\"Z\"))\n        );\n        assert_eq!(\n            t(r\"\\p{gc=Separator}\"),\n            hir_uclass_query(ClassQuery::Binary(\"Z\"))\n        );\n        assert_eq!(\n            t(r\"\\p{Other}\"),\n            hir_uclass_query(ClassQuery::Binary(\"Other\"))\n        );\n        assert_eq!(t(r\"\\pC\"), hir_uclass_query(ClassQuery::Binary(\"Other\")));\n\n        assert_eq!(\n            t(r\"\\PZ\"),\n            hir_negate(hir_uclass_query(ClassQuery::Binary(\"Z\")))\n        );\n        assert_eq!(\n            t(r\"\\P{separator}\"),\n            hir_negate(hir_uclass_query(ClassQuery::Binary(\"Z\")))\n        );\n        assert_eq!(\n            t(r\"\\P{gc!=separator}\"),\n            hir_negate(hir_uclass_query(ClassQuery::Binary(\"Z\")))\n        );\n\n        assert_eq!(t(r\"\\p{any}\"), hir_uclass_query(ClassQuery::Binary(\"Any\")));\n        assert_eq!(\n            t(r\"\\p{assigned}\"),\n            hir_uclass_query(ClassQuery::Binary(\"Assigned\"))\n        );\n        assert_eq!(\n            t(r\"\\p{ascii}\"),\n            hir_uclass_query(ClassQuery::Binary(\"ASCII\"))\n        );\n        assert_eq!(\n            t(r\"\\p{gc:any}\"),\n            hir_uclass_query(ClassQuery::Binary(\"Any\"))\n        );\n        assert_eq!(\n            t(r\"\\p{gc:assigned}\"),\n            hir_uclass_query(ClassQuery::Binary(\"Assigned\"))\n        );\n        assert_eq!(\n            t(r\"\\p{gc:ascii}\"),\n            hir_uclass_query(ClassQuery::Binary(\"ASCII\"))\n        );\n\n        assert_eq!(\n            t_err(r\"(?-u)\\pZ\"),\n            TestError {\n                kind: hir::ErrorKind::UnicodeNotAllowed,\n                span: Span::new(\n                    Position::new(5, 1, 6),\n                    Position::new(8, 1, 9)\n                ),\n            }\n        );\n        assert_eq!(\n            t_err(r\"(?-u)\\p{Separator}\"),\n            TestError {\n                kind: hir::ErrorKind::UnicodeNotAllowed,\n                span: Span::new(\n                    Position::new(5, 1, 6),\n                    Position::new(18, 1, 19)\n                ),\n            }\n        );\n        assert_eq!(\n            t_err(r\"\\pE\"),\n            TestError {\n                kind: hir::ErrorKind::UnicodePropertyNotFound,\n                span: Span::new(\n                    Position::new(0, 1, 1),\n                    Position::new(3, 1, 4)\n                ),\n            }\n        );\n        assert_eq!(\n            t_err(r\"\\p{Foo}\"),\n            TestError {\n                kind: hir::ErrorKind::UnicodePropertyNotFound,\n                span: Span::new(\n                    Position::new(0, 1, 1),\n                    Position::new(7, 1, 8)\n                ),\n            }\n        );\n        assert_eq!(\n            t_err(r\"\\p{gc:Foo}\"),\n            TestError {\n                kind: hir::ErrorKind::UnicodePropertyValueNotFound,\n                span: Span::new(\n                    Position::new(0, 1, 1),\n                    Position::new(10, 1, 11)\n                ),\n            }\n        );\n    }\n\n    #[test]\n    #[cfg(not(feature = \"unicode-gencat\"))]\n    fn class_unicode_gencat_disabled() {\n        assert_eq!(\n            t_err(r\"\\p{Separator}\"),\n            TestError {\n                kind: hir::ErrorKind::UnicodePropertyNotFound,\n                span: Span::new(\n                    Position::new(0, 1, 1),\n                    Position::new(13, 1, 14)\n                ),\n            }\n        );\n\n        assert_eq!(\n            t_err(r\"\\p{Any}\"),\n            TestError {\n                kind: hir::ErrorKind::UnicodePropertyNotFound,\n                span: Span::new(\n                    Position::new(0, 1, 1),\n                    Position::new(7, 1, 8)\n                ),\n            }\n        );\n    }\n\n    #[test]\n    #[cfg(feature = \"unicode-script\")]\n    fn class_unicode_script() {\n        assert_eq!(\n            t(r\"\\p{Greek}\"),\n            hir_uclass_query(ClassQuery::Binary(\"Greek\"))\n        );\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(r\"(?i)\\p{Greek}\"),\n            hir_case_fold(hir_uclass_query(ClassQuery::Binary(\"Greek\")))\n        );\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(r\"(?i)\\P{Greek}\"),\n            hir_negate(hir_case_fold(hir_uclass_query(ClassQuery::Binary(\n                \"Greek\"\n            ))))\n        );\n\n        assert_eq!(\n            t_err(r\"\\p{sc:Foo}\"),\n            TestError {\n                kind: hir::ErrorKind::UnicodePropertyValueNotFound,\n                span: Span::new(\n                    Position::new(0, 1, 1),\n                    Position::new(10, 1, 11)\n                ),\n            }\n        );\n        assert_eq!(\n            t_err(r\"\\p{scx:Foo}\"),\n            TestError {\n                kind: hir::ErrorKind::UnicodePropertyValueNotFound,\n                span: Span::new(\n                    Position::new(0, 1, 1),\n                    Position::new(11, 1, 12)\n                ),\n            }\n        );\n    }\n\n    #[test]\n    #[cfg(not(feature = \"unicode-script\"))]\n    fn class_unicode_script_disabled() {\n        assert_eq!(\n            t_err(r\"\\p{Greek}\"),\n            TestError {\n                kind: hir::ErrorKind::UnicodePropertyNotFound,\n                span: Span::new(\n                    Position::new(0, 1, 1),\n                    Position::new(9, 1, 10)\n                ),\n            }\n        );\n\n        assert_eq!(\n            t_err(r\"\\p{scx:Greek}\"),\n            TestError {\n                kind: hir::ErrorKind::UnicodePropertyNotFound,\n                span: Span::new(\n                    Position::new(0, 1, 1),\n                    Position::new(13, 1, 14)\n                ),\n            }\n        );\n    }\n\n    #[test]\n    #[cfg(feature = \"unicode-age\")]\n    fn class_unicode_age() {\n        assert_eq!(\n            t_err(r\"\\p{age:Foo}\"),\n            TestError {\n                kind: hir::ErrorKind::UnicodePropertyValueNotFound,\n                span: Span::new(\n                    Position::new(0, 1, 1),\n                    Position::new(11, 1, 12)\n                ),\n            }\n        );\n    }\n\n    #[test]\n    #[cfg(not(feature = \"unicode-age\"))]\n    fn class_unicode_age_disabled() {\n        assert_eq!(\n            t_err(r\"\\p{age:3.0}\"),\n            TestError {\n                kind: hir::ErrorKind::UnicodePropertyNotFound,\n                span: Span::new(\n                    Position::new(0, 1, 1),\n                    Position::new(11, 1, 12)\n                ),\n            }\n        );\n    }\n\n    #[test]\n    fn class_bracketed() {\n        assert_eq!(t(\"[a]\"), hir_uclass(&[('a', 'a')]));\n        assert_eq!(t(\"[^[a]]\"), hir_negate(hir_uclass(&[('a', 'a')])));\n        assert_eq!(t(\"[a-z]\"), hir_uclass(&[('a', 'z')]));\n        assert_eq!(t(\"[a-fd-h]\"), hir_uclass(&[('a', 'h')]));\n        assert_eq!(t(\"[a-fg-m]\"), hir_uclass(&[('a', 'm')]));\n        assert_eq!(t(r\"[\\x00]\"), hir_uclass(&[('\\0', '\\0')]));\n        assert_eq!(t(r\"[\\n]\"), hir_uclass(&[('\\n', '\\n')]));\n        assert_eq!(t(\"[\\n]\"), hir_uclass(&[('\\n', '\\n')]));\n        #[cfg(any(feature = \"unicode-perl\", feature = \"unicode-gencat\"))]\n        assert_eq!(t(r\"[\\d]\"), hir_uclass_query(ClassQuery::Binary(\"digit\")));\n        #[cfg(feature = \"unicode-gencat\")]\n        assert_eq!(\n            t(r\"[\\pZ]\"),\n            hir_uclass_query(ClassQuery::Binary(\"separator\"))\n        );\n        #[cfg(feature = \"unicode-gencat\")]\n        assert_eq!(\n            t(r\"[\\p{separator}]\"),\n            hir_uclass_query(ClassQuery::Binary(\"separator\"))\n        );\n        #[cfg(any(feature = \"unicode-perl\", feature = \"unicode-gencat\"))]\n        assert_eq!(t(r\"[^\\D]\"), hir_uclass_query(ClassQuery::Binary(\"digit\")));\n        #[cfg(feature = \"unicode-gencat\")]\n        assert_eq!(\n            t(r\"[^\\PZ]\"),\n            hir_uclass_query(ClassQuery::Binary(\"separator\"))\n        );\n        #[cfg(feature = \"unicode-gencat\")]\n        assert_eq!(\n            t(r\"[^\\P{separator}]\"),\n            hir_uclass_query(ClassQuery::Binary(\"separator\"))\n        );\n        #[cfg(all(\n            feature = \"unicode-case\",\n            any(feature = \"unicode-perl\", feature = \"unicode-gencat\")\n        ))]\n        assert_eq!(\n            t(r\"(?i)[^\\D]\"),\n            hir_uclass_query(ClassQuery::Binary(\"digit\"))\n        );\n        #[cfg(all(feature = \"unicode-case\", feature = \"unicode-script\"))]\n        assert_eq!(\n            t(r\"(?i)[^\\P{greek}]\"),\n            hir_case_fold(hir_uclass_query(ClassQuery::Binary(\"greek\")))\n        );\n\n        assert_eq!(t(\"(?-u)[a]\"), hir_bclass(&[(b'a', b'a')]));\n        assert_eq!(t(r\"(?-u)[\\x00]\"), hir_bclass(&[(b'\\0', b'\\0')]));\n        assert_eq!(t_bytes(r\"(?-u)[\\xFF]\"), hir_bclass(&[(b'\\xFF', b'\\xFF')]));\n\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(t(\"(?i)[a]\"), hir_uclass(&[('A', 'A'), ('a', 'a')]));\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(\"(?i)[k]\"),\n            hir_uclass(&[('K', 'K'), ('k', 'k'), ('\\u{212A}', '\\u{212A}'),])\n        );\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(\"(?i)[β]\"),\n            hir_uclass(&[('Β', 'Β'), ('β', 'β'), ('ϐ', 'ϐ'),])\n        );\n        assert_eq!(t(\"(?i-u)[k]\"), hir_bclass(&[(b'K', b'K'), (b'k', b'k'),]));\n\n        assert_eq!(t(\"[^a]\"), hir_negate(hir_uclass(&[('a', 'a')])));\n        assert_eq!(t(r\"[^\\x00]\"), hir_negate(hir_uclass(&[('\\0', '\\0')])));\n        assert_eq!(\n            t_bytes(\"(?-u)[^a]\"),\n            hir_negate(hir_bclass(&[(b'a', b'a')]))\n        );\n        #[cfg(any(feature = \"unicode-perl\", feature = \"unicode-gencat\"))]\n        assert_eq!(\n            t(r\"[^\\d]\"),\n            hir_negate(hir_uclass_query(ClassQuery::Binary(\"digit\")))\n        );\n        #[cfg(feature = \"unicode-gencat\")]\n        assert_eq!(\n            t(r\"[^\\pZ]\"),\n            hir_negate(hir_uclass_query(ClassQuery::Binary(\"separator\")))\n        );\n        #[cfg(feature = \"unicode-gencat\")]\n        assert_eq!(\n            t(r\"[^\\p{separator}]\"),\n            hir_negate(hir_uclass_query(ClassQuery::Binary(\"separator\")))\n        );\n        #[cfg(all(feature = \"unicode-case\", feature = \"unicode-script\"))]\n        assert_eq!(\n            t(r\"(?i)[^\\p{greek}]\"),\n            hir_negate(hir_case_fold(hir_uclass_query(ClassQuery::Binary(\n                \"greek\"\n            ))))\n        );\n        #[cfg(all(feature = \"unicode-case\", feature = \"unicode-script\"))]\n        assert_eq!(\n            t(r\"(?i)[\\P{greek}]\"),\n            hir_negate(hir_case_fold(hir_uclass_query(ClassQuery::Binary(\n                \"greek\"\n            ))))\n        );\n\n        // Test some weird cases.\n        assert_eq!(t(r\"[\\[]\"), hir_uclass(&[('[', '[')]));\n\n        assert_eq!(t(r\"[&]\"), hir_uclass(&[('&', '&')]));\n        assert_eq!(t(r\"[\\&]\"), hir_uclass(&[('&', '&')]));\n        assert_eq!(t(r\"[\\&\\&]\"), hir_uclass(&[('&', '&')]));\n        assert_eq!(t(r\"[\\x00-&]\"), hir_uclass(&[('\\0', '&')]));\n        assert_eq!(t(r\"[&-\\xFF]\"), hir_uclass(&[('&', '\\u{FF}')]));\n\n        assert_eq!(t(r\"[~]\"), hir_uclass(&[('~', '~')]));\n        assert_eq!(t(r\"[\\~]\"), hir_uclass(&[('~', '~')]));\n        assert_eq!(t(r\"[\\~\\~]\"), hir_uclass(&[('~', '~')]));\n        assert_eq!(t(r\"[\\x00-~]\"), hir_uclass(&[('\\0', '~')]));\n        assert_eq!(t(r\"[~-\\xFF]\"), hir_uclass(&[('~', '\\u{FF}')]));\n\n        assert_eq!(t(r\"[-]\"), hir_uclass(&[('-', '-')]));\n        assert_eq!(t(r\"[\\-]\"), hir_uclass(&[('-', '-')]));\n        assert_eq!(t(r\"[\\-\\-]\"), hir_uclass(&[('-', '-')]));\n        assert_eq!(t(r\"[\\x00-\\-]\"), hir_uclass(&[('\\0', '-')]));\n        assert_eq!(t(r\"[\\--\\xFF]\"), hir_uclass(&[('-', '\\u{FF}')]));\n\n        assert_eq!(\n            t_err(\"(?-u)[^a]\"),\n            TestError {\n                kind: hir::ErrorKind::InvalidUtf8,\n                span: Span::new(\n                    Position::new(5, 1, 6),\n                    Position::new(9, 1, 10)\n                ),\n            }\n        );\n        #[cfg(any(feature = \"unicode-perl\", feature = \"unicode-bool\"))]\n        assert_eq!(\n            t_err(r\"[^\\s\\S]\"),\n            TestError {\n                kind: hir::ErrorKind::EmptyClassNotAllowed,\n                span: Span::new(\n                    Position::new(0, 1, 1),\n                    Position::new(7, 1, 8)\n                ),\n            }\n        );\n        #[cfg(any(feature = \"unicode-perl\", feature = \"unicode-bool\"))]\n        assert_eq!(\n            t_err(r\"(?-u)[^\\s\\S]\"),\n            TestError {\n                kind: hir::ErrorKind::EmptyClassNotAllowed,\n                span: Span::new(\n                    Position::new(5, 1, 6),\n                    Position::new(12, 1, 13)\n                ),\n            }\n        );\n    }\n\n    #[test]\n    fn class_bracketed_union() {\n        assert_eq!(t(\"[a-zA-Z]\"), hir_uclass(&[('A', 'Z'), ('a', 'z')]));\n        #[cfg(feature = \"unicode-gencat\")]\n        assert_eq!(\n            t(r\"[a\\pZb]\"),\n            hir_union(\n                hir_uclass(&[('a', 'b')]),\n                hir_uclass_query(ClassQuery::Binary(\"separator\"))\n            )\n        );\n        #[cfg(all(feature = \"unicode-gencat\", feature = \"unicode-script\"))]\n        assert_eq!(\n            t(r\"[\\pZ\\p{Greek}]\"),\n            hir_union(\n                hir_uclass_query(ClassQuery::Binary(\"greek\")),\n                hir_uclass_query(ClassQuery::Binary(\"separator\"))\n            )\n        );\n        #[cfg(all(\n            feature = \"unicode-age\",\n            feature = \"unicode-gencat\",\n            feature = \"unicode-script\"\n        ))]\n        assert_eq!(\n            t(r\"[\\p{age:3.0}\\pZ\\p{Greek}]\"),\n            hir_union(\n                hir_uclass_query(ClassQuery::ByValue {\n                    property_name: \"age\",\n                    property_value: \"3.0\",\n                }),\n                hir_union(\n                    hir_uclass_query(ClassQuery::Binary(\"greek\")),\n                    hir_uclass_query(ClassQuery::Binary(\"separator\"))\n                )\n            )\n        );\n        #[cfg(all(\n            feature = \"unicode-age\",\n            feature = \"unicode-gencat\",\n            feature = \"unicode-script\"\n        ))]\n        assert_eq!(\n            t(r\"[[[\\p{age:3.0}\\pZ]\\p{Greek}][\\p{Cyrillic}]]\"),\n            hir_union(\n                hir_uclass_query(ClassQuery::ByValue {\n                    property_name: \"age\",\n                    property_value: \"3.0\",\n                }),\n                hir_union(\n                    hir_uclass_query(ClassQuery::Binary(\"cyrillic\")),\n                    hir_union(\n                        hir_uclass_query(ClassQuery::Binary(\"greek\")),\n                        hir_uclass_query(ClassQuery::Binary(\"separator\"))\n                    )\n                )\n            )\n        );\n\n        #[cfg(all(\n            feature = \"unicode-age\",\n            feature = \"unicode-case\",\n            feature = \"unicode-gencat\",\n            feature = \"unicode-script\"\n        ))]\n        assert_eq!(\n            t(r\"(?i)[\\p{age:3.0}\\pZ\\p{Greek}]\"),\n            hir_case_fold(hir_union(\n                hir_uclass_query(ClassQuery::ByValue {\n                    property_name: \"age\",\n                    property_value: \"3.0\",\n                }),\n                hir_union(\n                    hir_uclass_query(ClassQuery::Binary(\"greek\")),\n                    hir_uclass_query(ClassQuery::Binary(\"separator\"))\n                )\n            ))\n        );\n        #[cfg(all(\n            feature = \"unicode-age\",\n            feature = \"unicode-gencat\",\n            feature = \"unicode-script\"\n        ))]\n        assert_eq!(\n            t(r\"[^\\p{age:3.0}\\pZ\\p{Greek}]\"),\n            hir_negate(hir_union(\n                hir_uclass_query(ClassQuery::ByValue {\n                    property_name: \"age\",\n                    property_value: \"3.0\",\n                }),\n                hir_union(\n                    hir_uclass_query(ClassQuery::Binary(\"greek\")),\n                    hir_uclass_query(ClassQuery::Binary(\"separator\"))\n                )\n            ))\n        );\n        #[cfg(all(\n            feature = \"unicode-age\",\n            feature = \"unicode-case\",\n            feature = \"unicode-gencat\",\n            feature = \"unicode-script\"\n        ))]\n        assert_eq!(\n            t(r\"(?i)[^\\p{age:3.0}\\pZ\\p{Greek}]\"),\n            hir_negate(hir_case_fold(hir_union(\n                hir_uclass_query(ClassQuery::ByValue {\n                    property_name: \"age\",\n                    property_value: \"3.0\",\n                }),\n                hir_union(\n                    hir_uclass_query(ClassQuery::Binary(\"greek\")),\n                    hir_uclass_query(ClassQuery::Binary(\"separator\"))\n                )\n            )))\n        );\n    }\n\n    #[test]\n    fn class_bracketed_nested() {\n        assert_eq!(t(r\"[a[^c]]\"), hir_negate(hir_uclass(&[('c', 'c')])));\n        assert_eq!(t(r\"[a-b[^c]]\"), hir_negate(hir_uclass(&[('c', 'c')])));\n        assert_eq!(t(r\"[a-c[^c]]\"), hir_negate(hir_uclass(&[])));\n\n        assert_eq!(t(r\"[^a[^c]]\"), hir_uclass(&[('c', 'c')]));\n        assert_eq!(t(r\"[^a-b[^c]]\"), hir_uclass(&[('c', 'c')]));\n\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(r\"(?i)[a[^c]]\"),\n            hir_negate(hir_case_fold(hir_uclass(&[('c', 'c')])))\n        );\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(r\"(?i)[a-b[^c]]\"),\n            hir_negate(hir_case_fold(hir_uclass(&[('c', 'c')])))\n        );\n\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(t(r\"(?i)[^a[^c]]\"), hir_uclass(&[('C', 'C'), ('c', 'c')]));\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(r\"(?i)[^a-b[^c]]\"),\n            hir_uclass(&[('C', 'C'), ('c', 'c')])\n        );\n\n        assert_eq!(\n            t_err(r\"[^a-c[^c]]\"),\n            TestError {\n                kind: hir::ErrorKind::EmptyClassNotAllowed,\n                span: Span::new(\n                    Position::new(0, 1, 1),\n                    Position::new(10, 1, 11)\n                ),\n            }\n        );\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t_err(r\"(?i)[^a-c[^c]]\"),\n            TestError {\n                kind: hir::ErrorKind::EmptyClassNotAllowed,\n                span: Span::new(\n                    Position::new(4, 1, 5),\n                    Position::new(14, 1, 15)\n                ),\n            }\n        );\n    }\n\n    #[test]\n    fn class_bracketed_intersect() {\n        assert_eq!(t(\"[abc&&b-c]\"), hir_uclass(&[('b', 'c')]));\n        assert_eq!(t(\"[abc&&[b-c]]\"), hir_uclass(&[('b', 'c')]));\n        assert_eq!(t(\"[[abc]&&[b-c]]\"), hir_uclass(&[('b', 'c')]));\n        assert_eq!(t(\"[a-z&&b-y&&c-x]\"), hir_uclass(&[('c', 'x')]));\n        assert_eq!(t(\"[c-da-b&&a-d]\"), hir_uclass(&[('a', 'd')]));\n        assert_eq!(t(\"[a-d&&c-da-b]\"), hir_uclass(&[('a', 'd')]));\n        assert_eq!(t(r\"[a-z&&a-c]\"), hir_uclass(&[('a', 'c')]));\n        assert_eq!(t(r\"[[a-z&&a-c]]\"), hir_uclass(&[('a', 'c')]));\n        assert_eq!(t(r\"[^[a-z&&a-c]]\"), hir_negate(hir_uclass(&[('a', 'c')])));\n\n        assert_eq!(t(\"(?-u)[abc&&b-c]\"), hir_bclass(&[(b'b', b'c')]));\n        assert_eq!(t(\"(?-u)[abc&&[b-c]]\"), hir_bclass(&[(b'b', b'c')]));\n        assert_eq!(t(\"(?-u)[[abc]&&[b-c]]\"), hir_bclass(&[(b'b', b'c')]));\n        assert_eq!(t(\"(?-u)[a-z&&b-y&&c-x]\"), hir_bclass(&[(b'c', b'x')]));\n        assert_eq!(t(\"(?-u)[c-da-b&&a-d]\"), hir_bclass(&[(b'a', b'd')]));\n        assert_eq!(t(\"(?-u)[a-d&&c-da-b]\"), hir_bclass(&[(b'a', b'd')]));\n\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(\"(?i)[abc&&b-c]\"),\n            hir_case_fold(hir_uclass(&[('b', 'c')]))\n        );\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(\"(?i)[abc&&[b-c]]\"),\n            hir_case_fold(hir_uclass(&[('b', 'c')]))\n        );\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(\"(?i)[[abc]&&[b-c]]\"),\n            hir_case_fold(hir_uclass(&[('b', 'c')]))\n        );\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(\"(?i)[a-z&&b-y&&c-x]\"),\n            hir_case_fold(hir_uclass(&[('c', 'x')]))\n        );\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(\"(?i)[c-da-b&&a-d]\"),\n            hir_case_fold(hir_uclass(&[('a', 'd')]))\n        );\n        #[cfg(feature = \"unicode-case\")]\n        assert_eq!(\n            t(\"(?i)[a-d&&c-da-b]\"),\n            hir_case_fold(hir_uclass(&[('a', 'd')]))\n        );\n\n        assert_eq!(\n            t(\"(?i-u)[abc&&b-c]\"),\n            hir_case_fold(hir_bclass(&[(b'b', b'c')]))\n        );\n        assert_eq!(\n            t(\"(?i-u)[abc&&[b-c]]\"),\n            hir_case_fold(hir_bclass(&[(b'b', b'c')]))\n        );\n        assert_eq!(\n            t(\"(?i-u)[[abc]&&[b-c]]\"),\n            hir_case_fold(hir_bclass(&[(b'b', b'c')]))\n        );\n        assert_eq!(\n            t(\"(?i-u)[a-z&&b-y&&c-x]\"),\n            hir_case_fold(hir_bclass(&[(b'c', b'x')]))\n        );\n        assert_eq!(\n            t(\"(?i-u)[c-da-b&&a-d]\"),\n            hir_case_fold(hir_bclass(&[(b'a', b'd')]))\n        );\n        assert_eq!(\n            t(\"(?i-u)[a-d&&c-da-b]\"),\n            hir_case_fold(hir_bclass(&[(b'a', b'd')]))\n        );\n\n        // In `[a^]`, `^` does not need to be escaped, so it makes sense that\n        // `^` is also allowed to be unescaped after `&&`.\n        assert_eq!(t(r\"[\\^&&^]\"), hir_uclass(&[('^', '^')]));\n        // `]` needs to be escaped after `&&` since it's not at start of class.\n        assert_eq!(t(r\"[]&&\\]]\"), hir_uclass(&[(']', ']')]));\n        assert_eq!(t(r\"[-&&-]\"), hir_uclass(&[('-', '-')]));\n        assert_eq!(t(r\"[\\&&&&]\"), hir_uclass(&[('&', '&')]));\n        assert_eq!(t(r\"[\\&&&\\&]\"), hir_uclass(&[('&', '&')]));\n        // Test precedence.\n        assert_eq!(\n            t(r\"[a-w&&[^c-g]z]\"),\n            hir_uclass(&[('a', 'b'), ('h', 'w')])\n        );\n    }\n\n    #[test]\n    fn class_bracketed_intersect_negate() {\n        #[cfg(feature = \"unicode-perl\")]\n        assert_eq!(\n            t(r\"[^\\w&&\\d]\"),\n            hir_negate(hir_uclass_query(ClassQuery::Binary(\"digit\")))\n        );\n        assert_eq!(t(r\"[^[a-z&&a-c]]\"), hir_negate(hir_uclass(&[('a', 'c')])));\n        #[cfg(feature = \"unicode-perl\")]\n        assert_eq!(\n            t(r\"[^[\\w&&\\d]]\"),\n            hir_negate(hir_uclass_query(ClassQuery::Binary(\"digit\")))\n        );\n        #[cfg(feature = \"unicode-perl\")]\n        assert_eq!(\n            t(r\"[^[^\\w&&\\d]]\"),\n            hir_uclass_query(ClassQuery::Binary(\"digit\"))\n        );\n        #[cfg(feature = \"unicode-perl\")]\n        assert_eq!(t(r\"[[[^\\w]&&[^\\d]]]\"), hir_negate(hir_uclass_perl_word()));\n\n        #[cfg(feature = \"unicode-perl\")]\n        assert_eq!(\n            t_bytes(r\"(?-u)[^\\w&&\\d]\"),\n            hir_negate(hir_bclass_from_char(ascii_class(\n                &ast::ClassAsciiKind::Digit\n            )))\n        );\n        assert_eq!(\n            t_bytes(r\"(?-u)[^[a-z&&a-c]]\"),\n            hir_negate(hir_bclass(&[(b'a', b'c')]))\n        );\n        assert_eq!(\n            t_bytes(r\"(?-u)[^[\\w&&\\d]]\"),\n            hir_negate(hir_bclass_from_char(ascii_class(\n                &ast::ClassAsciiKind::Digit\n            )))\n        );\n        assert_eq!(\n            t_bytes(r\"(?-u)[^[^\\w&&\\d]]\"),\n            hir_bclass_from_char(ascii_class(&ast::ClassAsciiKind::Digit))\n        );\n        assert_eq!(\n            t_bytes(r\"(?-u)[[[^\\w]&&[^\\d]]]\"),\n            hir_negate(hir_bclass_from_char(ascii_class(\n                &ast::ClassAsciiKind::Word\n            )))\n        );\n    }\n\n    #[test]\n    fn class_bracketed_difference() {\n        #[cfg(feature = \"unicode-gencat\")]\n        assert_eq!(\n            t(r\"[\\pL--[:ascii:]]\"),\n            hir_difference(\n                hir_uclass_query(ClassQuery::Binary(\"letter\")),\n                hir_uclass(&[('\\0', '\\x7F')])\n            )\n        );\n\n        assert_eq!(\n            t(r\"(?-u)[[:alpha:]--[:lower:]]\"),\n            hir_bclass(&[(b'A', b'Z')])\n        );\n    }\n\n    #[test]\n    fn class_bracketed_symmetric_difference() {\n        #[cfg(feature = \"unicode-script\")]\n        assert_eq!(\n            t(r\"[\\p{sc:Greek}~~\\p{scx:Greek}]\"),\n            hir_uclass(&[\n                ('\\u{0342}', '\\u{0342}'),\n                ('\\u{0345}', '\\u{0345}'),\n                ('\\u{1DC0}', '\\u{1DC1}'),\n            ])\n        );\n        assert_eq!(t(r\"[a-g~~c-j]\"), hir_uclass(&[('a', 'b'), ('h', 'j')]));\n\n        assert_eq!(\n            t(r\"(?-u)[a-g~~c-j]\"),\n            hir_bclass(&[(b'a', b'b'), (b'h', b'j')])\n        );\n    }\n\n    #[test]\n    fn ignore_whitespace() {\n        assert_eq!(t(r\"(?x)\\12 3\"), hir_lit(\"\\n3\"));\n        assert_eq!(t(r\"(?x)\\x { 53 }\"), hir_lit(\"S\"));\n        assert_eq!(\n            t(r\"(?x)\\x # comment\n{ # comment\n    53 # comment\n} #comment\"),\n            hir_lit(\"S\")\n        );\n\n        assert_eq!(t(r\"(?x)\\x 53\"), hir_lit(\"S\"));\n        assert_eq!(\n            t(r\"(?x)\\x # comment\n        53 # comment\"),\n            hir_lit(\"S\")\n        );\n        assert_eq!(t(r\"(?x)\\x5 3\"), hir_lit(\"S\"));\n\n        #[cfg(feature = \"unicode-gencat\")]\n        assert_eq!(\n            t(r\"(?x)\\p # comment\n{ # comment\n    Separator # comment\n} # comment\"),\n            hir_uclass_query(ClassQuery::Binary(\"separator\"))\n        );\n\n        assert_eq!(\n            t(r\"(?x)a # comment\n{ # comment\n    5 # comment\n    , # comment\n    10 # comment\n} # comment\"),\n            hir_range(\n                true,\n                hir::RepetitionRange::Bounded(5, 10),\n                hir_lit(\"a\")\n            )\n        );\n\n        assert_eq!(t(r\"(?x)a\\  # hi there\"), hir_lit(\"a \"));\n    }\n\n    #[test]\n    fn analysis_is_always_utf8() {\n        // Positive examples.\n        assert!(t_bytes(r\"a\").is_always_utf8());\n        assert!(t_bytes(r\"ab\").is_always_utf8());\n        assert!(t_bytes(r\"(?-u)a\").is_always_utf8());\n        assert!(t_bytes(r\"(?-u)ab\").is_always_utf8());\n        assert!(t_bytes(r\"\\xFF\").is_always_utf8());\n        assert!(t_bytes(r\"\\xFF\\xFF\").is_always_utf8());\n        assert!(t_bytes(r\"[^a]\").is_always_utf8());\n        assert!(t_bytes(r\"[^a][^a]\").is_always_utf8());\n        assert!(t_bytes(r\"\\b\").is_always_utf8());\n        assert!(t_bytes(r\"\\B\").is_always_utf8());\n        assert!(t_bytes(r\"(?-u)\\b\").is_always_utf8());\n\n        // Negative examples.\n        assert!(!t_bytes(r\"(?-u)\\xFF\").is_always_utf8());\n        assert!(!t_bytes(r\"(?-u)\\xFF\\xFF\").is_always_utf8());\n        assert!(!t_bytes(r\"(?-u)[^a]\").is_always_utf8());\n        assert!(!t_bytes(r\"(?-u)[^a][^a]\").is_always_utf8());\n        assert!(!t_bytes(r\"(?-u)\\B\").is_always_utf8());\n    }\n\n    #[test]\n    fn analysis_is_all_assertions() {\n        // Positive examples.\n        assert!(t(r\"\\b\").is_all_assertions());\n        assert!(t(r\"\\B\").is_all_assertions());\n        assert!(t(r\"^\").is_all_assertions());\n        assert!(t(r\"$\").is_all_assertions());\n        assert!(t(r\"\\A\").is_all_assertions());\n        assert!(t(r\"\\z\").is_all_assertions());\n        assert!(t(r\"$^\\z\\A\\b\\B\").is_all_assertions());\n        assert!(t(r\"$|^|\\z|\\A|\\b|\\B\").is_all_assertions());\n        assert!(t(r\"^$|$^\").is_all_assertions());\n        assert!(t(r\"((\\b)+())*^\").is_all_assertions());\n\n        // Negative examples.\n        assert!(!t(r\"^a\").is_all_assertions());\n    }\n\n    #[test]\n    fn analysis_is_anchored() {\n        // Positive examples.\n        assert!(t(r\"^\").is_anchored_start());\n        assert!(t(r\"$\").is_anchored_end());\n        assert!(t(r\"^\").is_line_anchored_start());\n        assert!(t(r\"$\").is_line_anchored_end());\n\n        assert!(t(r\"^^\").is_anchored_start());\n        assert!(t(r\"$$\").is_anchored_end());\n        assert!(t(r\"^^\").is_line_anchored_start());\n        assert!(t(r\"$$\").is_line_anchored_end());\n\n        assert!(t(r\"^$\").is_anchored_start());\n        assert!(t(r\"^$\").is_anchored_end());\n        assert!(t(r\"^$\").is_line_anchored_start());\n        assert!(t(r\"^$\").is_line_anchored_end());\n\n        assert!(t(r\"^foo\").is_anchored_start());\n        assert!(t(r\"foo$\").is_anchored_end());\n        assert!(t(r\"^foo\").is_line_anchored_start());\n        assert!(t(r\"foo$\").is_line_anchored_end());\n\n        assert!(t(r\"^foo|^bar\").is_anchored_start());\n        assert!(t(r\"foo$|bar$\").is_anchored_end());\n        assert!(t(r\"^foo|^bar\").is_line_anchored_start());\n        assert!(t(r\"foo$|bar$\").is_line_anchored_end());\n\n        assert!(t(r\"^(foo|bar)\").is_anchored_start());\n        assert!(t(r\"(foo|bar)$\").is_anchored_end());\n        assert!(t(r\"^(foo|bar)\").is_line_anchored_start());\n        assert!(t(r\"(foo|bar)$\").is_line_anchored_end());\n\n        assert!(t(r\"^+\").is_anchored_start());\n        assert!(t(r\"$+\").is_anchored_end());\n        assert!(t(r\"^+\").is_line_anchored_start());\n        assert!(t(r\"$+\").is_line_anchored_end());\n        assert!(t(r\"^++\").is_anchored_start());\n        assert!(t(r\"$++\").is_anchored_end());\n        assert!(t(r\"^++\").is_line_anchored_start());\n        assert!(t(r\"$++\").is_line_anchored_end());\n        assert!(t(r\"(^)+\").is_anchored_start());\n        assert!(t(r\"($)+\").is_anchored_end());\n        assert!(t(r\"(^)+\").is_line_anchored_start());\n        assert!(t(r\"($)+\").is_line_anchored_end());\n\n        assert!(t(r\"$^\").is_anchored_start());\n        assert!(t(r\"$^\").is_anchored_start());\n        assert!(t(r\"$^\").is_line_anchored_end());\n        assert!(t(r\"$^\").is_line_anchored_end());\n        assert!(t(r\"$^|^$\").is_anchored_start());\n        assert!(t(r\"$^|^$\").is_anchored_end());\n        assert!(t(r\"$^|^$\").is_line_anchored_start());\n        assert!(t(r\"$^|^$\").is_line_anchored_end());\n\n        assert!(t(r\"\\b^\").is_anchored_start());\n        assert!(t(r\"$\\b\").is_anchored_end());\n        assert!(t(r\"\\b^\").is_line_anchored_start());\n        assert!(t(r\"$\\b\").is_line_anchored_end());\n        assert!(t(r\"^(?m:^)\").is_anchored_start());\n        assert!(t(r\"(?m:$)$\").is_anchored_end());\n        assert!(t(r\"^(?m:^)\").is_line_anchored_start());\n        assert!(t(r\"(?m:$)$\").is_line_anchored_end());\n        assert!(t(r\"(?m:^)^\").is_anchored_start());\n        assert!(t(r\"$(?m:$)\").is_anchored_end());\n        assert!(t(r\"(?m:^)^\").is_line_anchored_start());\n        assert!(t(r\"$(?m:$)\").is_line_anchored_end());\n\n        // Negative examples.\n        assert!(!t(r\"(?m)^\").is_anchored_start());\n        assert!(!t(r\"(?m)$\").is_anchored_end());\n        assert!(!t(r\"(?m:^$)|$^\").is_anchored_start());\n        assert!(!t(r\"(?m:^$)|$^\").is_anchored_end());\n        assert!(!t(r\"$^|(?m:^$)\").is_anchored_start());\n        assert!(!t(r\"$^|(?m:^$)\").is_anchored_end());\n\n        assert!(!t(r\"a^\").is_anchored_start());\n        assert!(!t(r\"$a\").is_anchored_start());\n        assert!(!t(r\"a^\").is_line_anchored_start());\n        assert!(!t(r\"$a\").is_line_anchored_start());\n\n        assert!(!t(r\"a^\").is_anchored_end());\n        assert!(!t(r\"$a\").is_anchored_end());\n        assert!(!t(r\"a^\").is_line_anchored_end());\n        assert!(!t(r\"$a\").is_line_anchored_end());\n\n        assert!(!t(r\"^foo|bar\").is_anchored_start());\n        assert!(!t(r\"foo|bar$\").is_anchored_end());\n        assert!(!t(r\"^foo|bar\").is_line_anchored_start());\n        assert!(!t(r\"foo|bar$\").is_line_anchored_end());\n\n        assert!(!t(r\"^*\").is_anchored_start());\n        assert!(!t(r\"$*\").is_anchored_end());\n        assert!(!t(r\"^*\").is_line_anchored_start());\n        assert!(!t(r\"$*\").is_line_anchored_end());\n        assert!(!t(r\"^*+\").is_anchored_start());\n        assert!(!t(r\"$*+\").is_anchored_end());\n        assert!(!t(r\"^*+\").is_line_anchored_start());\n        assert!(!t(r\"$*+\").is_line_anchored_end());\n        assert!(!t(r\"^+*\").is_anchored_start());\n        assert!(!t(r\"$+*\").is_anchored_end());\n        assert!(!t(r\"^+*\").is_line_anchored_start());\n        assert!(!t(r\"$+*\").is_line_anchored_end());\n        assert!(!t(r\"(^)*\").is_anchored_start());\n        assert!(!t(r\"($)*\").is_anchored_end());\n        assert!(!t(r\"(^)*\").is_line_anchored_start());\n        assert!(!t(r\"($)*\").is_line_anchored_end());\n    }\n\n    #[test]\n    fn analysis_is_line_anchored() {\n        assert!(t(r\"(?m)^(foo|bar)\").is_line_anchored_start());\n        assert!(t(r\"(?m)(foo|bar)$\").is_line_anchored_end());\n\n        assert!(t(r\"(?m)^foo|^bar\").is_line_anchored_start());\n        assert!(t(r\"(?m)foo$|bar$\").is_line_anchored_end());\n\n        assert!(t(r\"(?m)^\").is_line_anchored_start());\n        assert!(t(r\"(?m)$\").is_line_anchored_end());\n\n        assert!(t(r\"(?m:^$)|$^\").is_line_anchored_start());\n        assert!(t(r\"(?m:^$)|$^\").is_line_anchored_end());\n\n        assert!(t(r\"$^|(?m:^$)\").is_line_anchored_start());\n        assert!(t(r\"$^|(?m:^$)\").is_line_anchored_end());\n    }\n\n    #[test]\n    fn analysis_is_any_anchored() {\n        // Positive examples.\n        assert!(t(r\"^\").is_any_anchored_start());\n        assert!(t(r\"$\").is_any_anchored_end());\n        assert!(t(r\"\\A\").is_any_anchored_start());\n        assert!(t(r\"\\z\").is_any_anchored_end());\n\n        // Negative examples.\n        assert!(!t(r\"(?m)^\").is_any_anchored_start());\n        assert!(!t(r\"(?m)$\").is_any_anchored_end());\n        assert!(!t(r\"$\").is_any_anchored_start());\n        assert!(!t(r\"^\").is_any_anchored_end());\n    }\n\n    #[test]\n    fn analysis_is_match_empty() {\n        // Positive examples.\n        assert!(t(r\"\").is_match_empty());\n        assert!(t(r\"()\").is_match_empty());\n        assert!(t(r\"()*\").is_match_empty());\n        assert!(t(r\"()+\").is_match_empty());\n        assert!(t(r\"()?\").is_match_empty());\n        assert!(t(r\"a*\").is_match_empty());\n        assert!(t(r\"a?\").is_match_empty());\n        assert!(t(r\"a{0}\").is_match_empty());\n        assert!(t(r\"a{0,}\").is_match_empty());\n        assert!(t(r\"a{0,1}\").is_match_empty());\n        assert!(t(r\"a{0,10}\").is_match_empty());\n        #[cfg(feature = \"unicode-gencat\")]\n        assert!(t(r\"\\pL*\").is_match_empty());\n        assert!(t(r\"a*|b\").is_match_empty());\n        assert!(t(r\"b|a*\").is_match_empty());\n        assert!(t(r\"a*a?(abcd)*\").is_match_empty());\n        assert!(t(r\"^\").is_match_empty());\n        assert!(t(r\"$\").is_match_empty());\n        assert!(t(r\"(?m)^\").is_match_empty());\n        assert!(t(r\"(?m)$\").is_match_empty());\n        assert!(t(r\"\\A\").is_match_empty());\n        assert!(t(r\"\\z\").is_match_empty());\n        assert!(t(r\"\\B\").is_match_empty());\n        assert!(t_bytes(r\"(?-u)\\B\").is_match_empty());\n\n        // Negative examples.\n        assert!(!t(r\"a+\").is_match_empty());\n        assert!(!t(r\"a{1}\").is_match_empty());\n        assert!(!t(r\"a{1,}\").is_match_empty());\n        assert!(!t(r\"a{1,2}\").is_match_empty());\n        assert!(!t(r\"a{1,10}\").is_match_empty());\n        assert!(!t(r\"b|a\").is_match_empty());\n        assert!(!t(r\"a*a+(abcd)*\").is_match_empty());\n        assert!(!t(r\"\\b\").is_match_empty());\n        assert!(!t(r\"(?-u)\\b\").is_match_empty());\n    }\n\n    #[test]\n    fn analysis_is_literal() {\n        // Positive examples.\n        assert!(t(r\"a\").is_literal());\n        assert!(t(r\"ab\").is_literal());\n        assert!(t(r\"abc\").is_literal());\n        assert!(t(r\"(?m)abc\").is_literal());\n\n        // Negative examples.\n        assert!(!t(r\"\").is_literal());\n        assert!(!t(r\"^\").is_literal());\n        assert!(!t(r\"a|b\").is_literal());\n        assert!(!t(r\"(a)\").is_literal());\n        assert!(!t(r\"a+\").is_literal());\n        assert!(!t(r\"foo(a)\").is_literal());\n        assert!(!t(r\"(a)foo\").is_literal());\n        assert!(!t(r\"[a]\").is_literal());\n    }\n\n    #[test]\n    fn analysis_is_alternation_literal() {\n        // Positive examples.\n        assert!(t(r\"a\").is_alternation_literal());\n        assert!(t(r\"ab\").is_alternation_literal());\n        assert!(t(r\"abc\").is_alternation_literal());\n        assert!(t(r\"(?m)abc\").is_alternation_literal());\n        assert!(t(r\"a|b\").is_alternation_literal());\n        assert!(t(r\"a|b|c\").is_alternation_literal());\n        assert!(t(r\"foo|bar\").is_alternation_literal());\n        assert!(t(r\"foo|bar|baz\").is_alternation_literal());\n\n        // Negative examples.\n        assert!(!t(r\"\").is_alternation_literal());\n        assert!(!t(r\"^\").is_alternation_literal());\n        assert!(!t(r\"(a)\").is_alternation_literal());\n        assert!(!t(r\"a+\").is_alternation_literal());\n        assert!(!t(r\"foo(a)\").is_alternation_literal());\n        assert!(!t(r\"(a)foo\").is_alternation_literal());\n        assert!(!t(r\"[a]\").is_alternation_literal());\n        assert!(!t(r\"[a]|b\").is_alternation_literal());\n        assert!(!t(r\"a|[b]\").is_alternation_literal());\n        assert!(!t(r\"(a)|b\").is_alternation_literal());\n        assert!(!t(r\"a|(b)\").is_alternation_literal());\n    }\n}\n","traces":[{"line":22,"address":[6444336],"length":1,"stats":{"Line":34},"fn_name":"default"},{"line":23,"address":[6444340],"length":1,"stats":{"Line":34},"fn_name":null},{"line":29,"address":[6444416],"length":1,"stats":{"Line":34},"fn_name":"new"},{"line":32,"address":[6444420],"length":1,"stats":{"Line":34},"fn_name":null},{"line":37,"address":[6444582,6444512],"length":1,"stats":{"Line":34},"fn_name":"build"},{"line":39,"address":[6444536,6444597],"length":1,"stats":{"Line":68},"fn_name":null},{"line":40,"address":[6444618,6444699],"length":1,"stats":{"Line":68},"fn_name":null},{"line":41,"address":[6444746],"length":1,"stats":{"Line":34},"fn_name":null},{"line":56,"address":[6444848],"length":1,"stats":{"Line":34},"fn_name":"allow_invalid_utf8"},{"line":57,"address":[6444865],"length":1,"stats":{"Line":34},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[6444880],"length":1,"stats":{"Line":34},"fn_name":"case_insensitive"},{"line":63,"address":[6444898],"length":1,"stats":{"Line":34},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[6444944],"length":1,"stats":{"Line":34},"fn_name":"multi_line"},{"line":69,"address":[6444962],"length":1,"stats":{"Line":34},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[6445008],"length":1,"stats":{"Line":34},"fn_name":"dot_matches_new_line"},{"line":79,"address":[6445026],"length":1,"stats":{"Line":34},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[6445072],"length":1,"stats":{"Line":34},"fn_name":"swap_greed"},{"line":85,"address":[6445090],"length":1,"stats":{"Line":34},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[6445136],"length":1,"stats":{"Line":34},"fn_name":"unicode"},{"line":91,"address":[6445154],"length":1,"stats":{"Line":34},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[6445200],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":117,"address":[6445207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[6445296],"length":1,"stats":{"Line":23},"fn_name":"translate"},{"line":130,"address":[6445323],"length":1,"stats":{"Line":23},"fn_name":null},{"line":188,"address":[6445430,6445392],"length":1,"stats":{"Line":24},"fn_name":"unwrap_expr"},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[6445402,6445535],"length":1,"stats":{"Line":52},"fn_name":null},{"line":191,"address":[6445645,6445445],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[6445792,6445830],"length":1,"stats":{"Line":8},"fn_name":"unwrap_class_unicode"},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[6445935,6445802],"length":1,"stats":{"Line":16},"fn_name":null},{"line":200,"address":[6445857,6446027],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[6446160,6446198],"length":1,"stats":{"Line":9},"fn_name":"unwrap_class_bytes"},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[6446170,6446303],"length":1,"stats":{"Line":18},"fn_name":null},{"line":213,"address":[6446395,6446225],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[6446553,6446528],"length":1,"stats":{"Line":28},"fn_name":"unwrap_group"},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[6446535,6446658],"length":1,"stats":{"Line":56},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[6446775,6446704,6446568],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[6446848,6446891],"length":1,"stats":{"Line":10},"fn_name":"finish"},{"line":240,"address":[6446866,6446906],"length":1,"stats":{"Line":20},"fn_name":null},{"line":241,"address":[6447437],"length":1,"stats":{"Line":10},"fn_name":null},{"line":244,"address":[6447600],"length":1,"stats":{"Line":23},"fn_name":"visit_pre"},{"line":245,"address":[6448027,6448414,6448519,6448547,6448445,6448337],"length":1,"stats":{"Line":50},"fn_name":null},{"line":246,"address":[6447623],"length":1,"stats":{"Line":23},"fn_name":null},{"line":247,"address":[6448025,6447901,6447700],"length":1,"stats":{"Line":25},"fn_name":null},{"line":248,"address":[6447792],"length":1,"stats":{"Line":8},"fn_name":null},{"line":249,"address":[6447803],"length":1,"stats":{"Line":8},"fn_name":null},{"line":251,"address":[6447776],"length":1,"stats":{"Line":9},"fn_name":null},{"line":252,"address":[6447903],"length":1,"stats":{"Line":9},"fn_name":null},{"line":255,"address":[6448037],"length":1,"stats":{"Line":10},"fn_name":null},{"line":256,"address":[6448051,6448161,6448078],"length":1,"stats":{"Line":30},"fn_name":null},{"line":258,"address":[6448070],"length":1,"stats":{"Line":30},"fn_name":null},{"line":259,"address":[6448153],"length":1,"stats":{"Line":28},"fn_name":null},{"line":260,"address":[6448255],"length":1,"stats":{"Line":10},"fn_name":null},{"line":262,"address":[6448347],"length":1,"stats":{"Line":24},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[6448419],"length":1,"stats":{"Line":24},"fn_name":null},{"line":266,"address":[6448452],"length":1,"stats":{"Line":8},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[6448521],"length":1,"stats":{"Line":8},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[6448554],"length":1,"stats":{"Line":23},"fn_name":null},{"line":275,"address":[6448576,6448739],"length":1,"stats":{"Line":24},"fn_name":"visit_post"},{"line":276,"address":[6451962,6450331,6448945,6454748,6448608,6450876,6449139,6448810,6454998,6452603,6455560,6456254,6449697],"length":1,"stats":{"Line":228},"fn_name":null},{"line":277,"address":[6448672],"length":1,"stats":{"Line":24},"fn_name":null},{"line":278,"address":[6448852],"length":1,"stats":{"Line":10},"fn_name":null},{"line":280,"address":[6448958],"length":1,"stats":{"Line":14},"fn_name":null},{"line":281,"address":[6448978],"length":1,"stats":{"Line":12},"fn_name":null},{"line":291,"address":[6449046],"length":1,"stats":{"Line":17},"fn_name":null},{"line":293,"address":[6449152],"length":1,"stats":{"Line":9},"fn_name":null},{"line":294,"address":[6449668,6449166],"length":1,"stats":{"Line":10},"fn_name":null},{"line":296,"address":[6449710],"length":1,"stats":{"Line":23},"fn_name":null},{"line":297,"address":[6449762],"length":1,"stats":{"Line":23},"fn_name":null},{"line":299,"address":[6450344],"length":1,"stats":{"Line":25},"fn_name":null},{"line":300,"address":[6450358],"length":1,"stats":{"Line":25},"fn_name":null},{"line":302,"address":[6448762,6450889],"length":1,"stats":{"Line":25},"fn_name":null},{"line":303,"address":[6451682,6450917,6451960],"length":1,"stats":{"Line":47},"fn_name":null},{"line":304,"address":[6451037,6451331,6451555],"length":1,"stats":{"Line":10},"fn_name":null},{"line":305,"address":[6451185],"length":1,"stats":{"Line":13},"fn_name":null},{"line":306,"address":[6451269,6451560],"length":1,"stats":{"Line":26},"fn_name":null},{"line":308,"address":[6451003],"length":1,"stats":{"Line":17},"fn_name":null},{"line":309,"address":[6451687],"length":1,"stats":{"Line":19},"fn_name":null},{"line":310,"address":[6451795],"length":1,"stats":{"Line":17},"fn_name":null},{"line":313,"address":[6451975],"length":1,"stats":{"Line":8},"fn_name":null},{"line":314,"address":[6451995,6452252,6452476],"length":1,"stats":{"Line":8},"fn_name":null},{"line":315,"address":[6452182,6452500],"length":1,"stats":{"Line":16},"fn_name":null},{"line":317,"address":[6452616],"length":1,"stats":{"Line":8},"fn_name":null},{"line":318,"address":[6453769,6452644],"length":1,"stats":{"Line":16},"fn_name":null},{"line":319,"address":[6452756],"length":1,"stats":{"Line":8},"fn_name":null},{"line":320,"address":[6452877,6452964],"length":1,"stats":{"Line":8},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[6452846],"length":1,"stats":{"Line":8},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[6453215],"length":1,"stats":{"Line":8},"fn_name":null},{"line":326,"address":[6453526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[6453483],"length":1,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[6453518],"length":1,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[6453364],"length":1,"stats":{"Line":8},"fn_name":null},{"line":332,"address":[6453602],"length":1,"stats":{"Line":8},"fn_name":null},{"line":334,"address":[6453781,6452730],"length":1,"stats":{"Line":26},"fn_name":null},{"line":335,"address":[6453874,6453961],"length":1,"stats":{"Line":14},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[6453843],"length":1,"stats":{"Line":12},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[6454212],"length":1,"stats":{"Line":14},"fn_name":null},{"line":341,"address":[6454505],"length":1,"stats":{"Line":3},"fn_name":null},{"line":342,"address":[6454462],"length":1,"stats":{"Line":3},"fn_name":null},{"line":343,"address":[6454497],"length":1,"stats":{"Line":3},"fn_name":null},{"line":347,"address":[6454343],"length":1,"stats":{"Line":12},"fn_name":null},{"line":348,"address":[6454581],"length":1,"stats":{"Line":14},"fn_name":null},{"line":351,"address":[6454761],"length":1,"stats":{"Line":17},"fn_name":null},{"line":352,"address":[6454775],"length":1,"stats":{"Line":24},"fn_name":null},{"line":353,"address":[6454854],"length":1,"stats":{"Line":26},"fn_name":null},{"line":355,"address":[6455011],"length":1,"stats":{"Line":28},"fn_name":null},{"line":356,"address":[6455025],"length":1,"stats":{"Line":28},"fn_name":null},{"line":357,"address":[6455128],"length":1,"stats":{"Line":28},"fn_name":null},{"line":358,"address":[6455250],"length":1,"stats":{"Line":28},"fn_name":null},{"line":359,"address":[6455349],"length":1,"stats":{"Line":28},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[6455569],"length":1,"stats":{"Line":24},"fn_name":null},{"line":363,"address":[6455624,6457120,6455821,6455997,6457013],"length":1,"stats":{"Line":72},"fn_name":null},{"line":364,"address":[6455969,6455862,6455773],"length":1,"stats":{"Line":72},"fn_name":null},{"line":365,"address":[6455870],"length":1,"stats":{"Line":24},"fn_name":null},{"line":368,"address":[6456034],"length":1,"stats":{"Line":24},"fn_name":null},{"line":369,"address":[6456084],"length":1,"stats":{"Line":24},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[6456259,6448816],"length":1,"stats":{"Line":16},"fn_name":null},{"line":373,"address":[6456283,6456519,6457202],"length":1,"stats":{"Line":16},"fn_name":null},{"line":374,"address":[6456424],"length":1,"stats":{"Line":8},"fn_name":null},{"line":376,"address":[6456556],"length":1,"stats":{"Line":8},"fn_name":null},{"line":377,"address":[6456604],"length":1,"stats":{"Line":8},"fn_name":null},{"line":380,"address":[6456782],"length":1,"stats":{"Line":24},"fn_name":null},{"line":383,"address":[6457664],"length":1,"stats":{"Line":8},"fn_name":"visit_class_set_item_pre"},{"line":387,"address":[6458042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[6457690],"length":1,"stats":{"Line":8},"fn_name":null},{"line":389,"address":[6457720,6457916,6458040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[6457807],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[6457818],"length":1,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[6457791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[6457918],"length":1,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[6458049],"length":1,"stats":{"Line":8},"fn_name":null},{"line":404,"address":[6458080,6458267],"length":1,"stats":{"Line":8},"fn_name":"visit_class_set_item_post"},{"line":408,"address":[6460821,6458112,6458282,6463274,6465836,6462632,6464306,6459369],"length":1,"stats":{"Line":49},"fn_name":null},{"line":409,"address":[6458200],"length":1,"stats":{"Line":8},"fn_name":null},{"line":410,"address":[6458292],"length":1,"stats":{"Line":8},"fn_name":null},{"line":411,"address":[6458320,6458698],"length":1,"stats":{"Line":16},"fn_name":null},{"line":412,"address":[6458432],"length":1,"stats":{"Line":8},"fn_name":null},{"line":413,"address":[6458522],"length":1,"stats":{"Line":8},"fn_name":null},{"line":414,"address":[6458587],"length":1,"stats":{"Line":8},"fn_name":null},{"line":416,"address":[6458710,6458406],"length":1,"stats":{"Line":18},"fn_name":null},{"line":417,"address":[6459158,6459101,6458788],"length":1,"stats":{"Line":12},"fn_name":null},{"line":418,"address":[6459167],"length":1,"stats":{"Line":12},"fn_name":null},{"line":419,"address":[6459258],"length":1,"stats":{"Line":12},"fn_name":null},{"line":422,"address":[6459382],"length":1,"stats":{"Line":8},"fn_name":null},{"line":423,"address":[6459410,6459790],"length":1,"stats":{"Line":16},"fn_name":null},{"line":424,"address":[6459522],"length":1,"stats":{"Line":8},"fn_name":null},{"line":425,"address":[6459612],"length":1,"stats":{"Line":8},"fn_name":null},{"line":426,"address":[6459679],"length":1,"stats":{"Line":8},"fn_name":null},{"line":428,"address":[6459802,6459496],"length":1,"stats":{"Line":25},"fn_name":null},{"line":429,"address":[6459864,6460241],"length":1,"stats":{"Line":12},"fn_name":null},{"line":430,"address":[6460254],"length":1,"stats":{"Line":13},"fn_name":null},{"line":431,"address":[6460613],"length":1,"stats":{"Line":14},"fn_name":null},{"line":432,"address":[6460710],"length":1,"stats":{"Line":13},"fn_name":null},{"line":435,"address":[6460834],"length":1,"stats":{"Line":12},"fn_name":null},{"line":436,"address":[6460862,6461810],"length":1,"stats":{"Line":25},"fn_name":null},{"line":437,"address":[6460974],"length":1,"stats":{"Line":12},"fn_name":null},{"line":438,"address":[6461064,6461366,6461271],"length":1,"stats":{"Line":20},"fn_name":null},{"line":439,"address":[6461316],"length":1,"stats":{"Line":8},"fn_name":null},{"line":441,"address":[6461371,6461448,6461261],"length":1,"stats":{"Line":26},"fn_name":null},{"line":442,"address":[6461233],"length":1,"stats":{"Line":13},"fn_name":null},{"line":444,"address":[6461699],"length":1,"stats":{"Line":13},"fn_name":null},{"line":446,"address":[6461822,6460948],"length":1,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[6462188,6462073,6461884],"length":1,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[6462118],"length":1,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[6462193,6462035,6462516],"length":1,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[6462521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[6462645],"length":1,"stats":{"Line":12},"fn_name":null},{"line":455,"address":[6462659,6462817],"length":1,"stats":{"Line":12},"fn_name":null},{"line":456,"address":[6462807,6463057],"length":1,"stats":{"Line":24},"fn_name":null},{"line":457,"address":[6463122],"length":1,"stats":{"Line":12},"fn_name":null},{"line":458,"address":[6463149],"length":1,"stats":{"Line":12},"fn_name":null},{"line":460,"address":[6463287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[6463312,6464040,6464304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[6463423,6463583],"length":1,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[6463573,6463823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[6463888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[6463915],"length":1,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[6463392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[6464061,6464137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[6464152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[6464179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[6464319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[6465151,6464344,6465834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[6464450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[6464674,6464567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[6464529],"length":1,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[6464532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[6464927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[6464999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[6465026],"length":1,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[6464424,6465163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[6465359,6465252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[6465214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[6465217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[6465610],"length":1,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[6465682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[6465709],"length":1,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[6465846],"length":1,"stats":{"Line":8},"fn_name":null},{"line":504,"address":[6466816],"length":1,"stats":{"Line":0},"fn_name":"visit_class_set_binary_op_pre"},{"line":508,"address":[6467056,6466847,6467180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":509,"address":[6466947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[6466958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[6466931],"length":1,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[6467058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[6467187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[6467216],"length":1,"stats":{"Line":0},"fn_name":"visit_class_set_binary_op_in"},{"line":522,"address":[6467456,6467247,6467580],"length":1,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[6467347],"length":1,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[6467358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[6467331],"length":1,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[6467458],"length":1,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[6467587],"length":1,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[6467616,6467723],"length":1,"stats":{"Line":0},"fn_name":"visit_class_set_binary_op_post"},{"line":538,"address":[6469308,6467636,6469995,6467738],"length":1,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[6467785],"length":1,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[6467939,6467853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[6467946,6468032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[6468047,6469025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[6468149,6468330],"length":1,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[6540097,6540166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[6540100],"length":1,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[6540151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[6468807,6468623],"length":1,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[6540278,6540209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[6540212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":552,"address":[6540263],"length":1,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[6469139,6469113,6469087],"length":1,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[6469027,6469089],"length":1,"stats":{"Line":0},"fn_name":null},{"line":558,"address":[6469115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":559,"address":[6469063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[6469143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":562,"address":[6469170],"length":1,"stats":{"Line":0},"fn_name":null},{"line":564,"address":[6469320,6467762],"length":1,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[6469455,6469366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[6469462,6469548],"length":1,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[6469700,6469563],"length":1,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[6469662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[6469681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":571,"address":[6469765,6469794,6469823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[6469702,6469767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":573,"address":[6469796],"length":1,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[6469738],"length":1,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[6469827],"length":1,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[6469854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[6470002],"length":1,"stats":{"Line":0},"fn_name":null},{"line":597,"address":[6470256],"length":1,"stats":{"Line":23},"fn_name":"new"},{"line":602,"address":[6470304],"length":1,"stats":{"Line":23},"fn_name":"trans"},{"line":603,"address":[6470309],"length":1,"stats":{"Line":23},"fn_name":null},{"line":607,"address":[6470320,6470368],"length":1,"stats":{"Line":23},"fn_name":"push"},{"line":608,"address":[6470335,6470383],"length":1,"stats":{"Line":46},"fn_name":null},{"line":612,"address":[6470677,6470640],"length":1,"stats":{"Line":10},"fn_name":"pop"},{"line":613,"address":[6470657,6470689],"length":1,"stats":{"Line":20},"fn_name":null},{"line":617,"address":[6470800],"length":1,"stats":{"Line":4},"fn_name":"error"},{"line":618,"address":[6470825],"length":1,"stats":{"Line":4},"fn_name":null},{"line":622,"address":[6471008],"length":1,"stats":{"Line":10},"fn_name":"flags"},{"line":623,"address":[6471017],"length":1,"stats":{"Line":10},"fn_name":null},{"line":628,"address":[6471120],"length":1,"stats":{"Line":15},"fn_name":"set_flags"},{"line":629,"address":[6471144],"length":1,"stats":{"Line":13},"fn_name":null},{"line":630,"address":[6471184],"length":1,"stats":{"Line":16},"fn_name":null},{"line":631,"address":[6471219],"length":1,"stats":{"Line":20},"fn_name":null},{"line":632,"address":[6471239],"length":1,"stats":{"Line":18},"fn_name":null},{"line":633,"address":[6471316],"length":1,"stats":{"Line":20},"fn_name":null},{"line":636,"address":[6471360,6471456],"length":1,"stats":{"Line":9},"fn_name":"hir_literal"},{"line":637,"address":[6471471,6471519,6471819,6471386,6471709],"length":1,"stats":{"Line":19},"fn_name":null},{"line":638,"address":[6471821,6471497],"length":1,"stats":{"Line":12},"fn_name":null},{"line":639,"address":[6471737],"length":1,"stats":{"Line":9},"fn_name":null},{"line":641,"address":[6472078,6471764,6471929],"length":1,"stats":{"Line":30},"fn_name":null},{"line":642,"address":[6472024],"length":1,"stats":{"Line":12},"fn_name":null},{"line":644,"address":[6471961],"length":1,"stats":{"Line":9},"fn_name":null},{"line":656,"address":[6472112],"length":1,"stats":{"Line":9},"fn_name":"literal_to_char"},{"line":657,"address":[6472143],"length":1,"stats":{"Line":9},"fn_name":null},{"line":658,"address":[6472261],"length":1,"stats":{"Line":9},"fn_name":null},{"line":660,"address":[6472232,6472348],"length":1,"stats":{"Line":8},"fn_name":null},{"line":661,"address":[6472355,6472306],"length":1,"stats":{"Line":18},"fn_name":null},{"line":662,"address":[6472320],"length":1,"stats":{"Line":8},"fn_name":null},{"line":664,"address":[6472338],"length":1,"stats":{"Line":8},"fn_name":null},{"line":665,"address":[6472410],"length":1,"stats":{"Line":8},"fn_name":null},{"line":667,"address":[6472394,6472449],"length":1,"stats":{"Line":8},"fn_name":null},{"line":668,"address":[6472512],"length":1,"stats":{"Line":1},"fn_name":null},{"line":670,"address":[6472464],"length":1,"stats":{"Line":3},"fn_name":null},{"line":673,"address":[6472640],"length":1,"stats":{"Line":9},"fn_name":"hir_from_char"},{"line":674,"address":[6472670],"length":1,"stats":{"Line":9},"fn_name":null},{"line":675,"address":[6472865,6472958],"length":1,"stats":{"Line":2},"fn_name":null},{"line":677,"address":[6472823,6473004],"length":1,"stats":{"Line":19},"fn_name":null},{"line":680,"address":[6473056,6473182],"length":1,"stats":{"Line":11},"fn_name":"hir_from_char_case_insensitive"},{"line":685,"address":[6473197,6473081,6474480],"length":1,"stats":{"Line":32},"fn_name":null},{"line":687,"address":[6473251,6473374,6473428],"length":1,"stats":{"Line":16},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":689,"address":[6540321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":691,"address":[6473662],"length":1,"stats":{"Line":8},"fn_name":null},{"line":692,"address":[6473718],"length":1,"stats":{"Line":8},"fn_name":null},{"line":694,"address":[6473797,6475092,6473678],"length":1,"stats":{"Line":16},"fn_name":null},{"line":695,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":698,"address":[6473878,6474066],"length":1,"stats":{"Line":8},"fn_name":null},{"line":699,"address":[6540433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":701,"address":[6474314],"length":1,"stats":{"Line":8},"fn_name":null},{"line":703,"address":[6473228,6474490],"length":1,"stats":{"Line":24},"fn_name":null},{"line":704,"address":[6474518],"length":1,"stats":{"Line":0},"fn_name":null},{"line":707,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":708,"address":[6474496,6474663],"length":1,"stats":{"Line":18},"fn_name":null},{"line":709,"address":[6474690,6474816],"length":1,"stats":{"Line":24},"fn_name":null},{"line":711,"address":[6475153,6474776,6474821],"length":1,"stats":{"Line":16},"fn_name":null},{"line":712,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":713,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":715,"address":[6474902],"length":1,"stats":{"Line":8},"fn_name":null},{"line":716,"address":[6474921],"length":1,"stats":{"Line":10},"fn_name":null},{"line":720,"address":[6475344],"length":1,"stats":{"Line":23},"fn_name":"hir_dot"},{"line":721,"address":[6475367],"length":1,"stats":{"Line":23},"fn_name":null},{"line":722,"address":[6475462],"length":1,"stats":{"Line":23},"fn_name":null},{"line":723,"address":[6475591,6475684],"length":1,"stats":{"Line":2},"fn_name":null},{"line":725,"address":[6475816,6475533,6475725],"length":1,"stats":{"Line":56},"fn_name":null},{"line":726,"address":[6475789],"length":1,"stats":{"Line":10},"fn_name":null},{"line":728,"address":[6475756],"length":1,"stats":{"Line":23},"fn_name":null},{"line":732,"address":[6475872],"length":1,"stats":{"Line":25},"fn_name":"hir_assertion"},{"line":733,"address":[6475903],"length":1,"stats":{"Line":25},"fn_name":null},{"line":734,"address":[6475999],"length":1,"stats":{"Line":25},"fn_name":null},{"line":735,"address":[6476291,6476343,6476126,6476564,6476227,6476259,6476175],"length":1,"stats":{"Line":67},"fn_name":null},{"line":736,"address":[6476077,6476146,6476156,6476132],"length":1,"stats":{"Line":100},"fn_name":null},{"line":737,"address":[6476148],"length":1,"stats":{"Line":8},"fn_name":null},{"line":739,"address":[6476138],"length":1,"stats":{"Line":25},"fn_name":null},{"line":741,"address":[6476208,6476184,6476198],"length":1,"stats":{"Line":69},"fn_name":null},{"line":742,"address":[6476200],"length":1,"stats":{"Line":8},"fn_name":null},{"line":744,"address":[6476190],"length":1,"stats":{"Line":23},"fn_name":null},{"line":746,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":747,"address":[6476232],"length":1,"stats":{"Line":0},"fn_name":null},{"line":749,"address":[6476264],"length":1,"stats":{"Line":0},"fn_name":null},{"line":750,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":751,"address":[6476314,6476300,6476324],"length":1,"stats":{"Line":24},"fn_name":null},{"line":752,"address":[6476316],"length":1,"stats":{"Line":8},"fn_name":null},{"line":754,"address":[6476306],"length":1,"stats":{"Line":8},"fn_name":null},{"line":757,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":758,"address":[6476545,6476402,6476373,6476113],"length":1,"stats":{"Line":35},"fn_name":null},{"line":759,"address":[6476365],"length":1,"stats":{"Line":8},"fn_name":null},{"line":764,"address":[6476353,6476383],"length":1,"stats":{"Line":10},"fn_name":null},{"line":765,"address":[6476501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":766,"address":[6476412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":769,"address":[6476394],"length":1,"stats":{"Line":5},"fn_name":null},{"line":775,"address":[6476624,6476720],"length":1,"stats":{"Line":28},"fn_name":"hir_group"},{"line":776,"address":[6476650,6476777,6476743],"length":1,"stats":{"Line":46},"fn_name":null},{"line":777,"address":[6476666,6476755],"length":1,"stats":{"Line":36},"fn_name":null},{"line":778,"address":[6476765],"length":1,"stats":{"Line":8},"fn_name":null},{"line":780,"address":[6476784],"length":1,"stats":{"Line":27},"fn_name":null},{"line":782,"address":[6476801],"length":1,"stats":{"Line":27},"fn_name":null},{"line":783,"address":[6476834],"length":1,"stats":{"Line":27},"fn_name":null},{"line":786,"address":[6476735],"length":1,"stats":{"Line":10},"fn_name":null},{"line":788,"address":[6477023,6476879],"length":1,"stats":{"Line":56},"fn_name":null},{"line":791,"address":[6477321,6477200],"length":1,"stats":{"Line":26},"fn_name":"hir_repetition"},{"line":792,"address":[6477453,6477481,6477550,6477491,6477468,6477226],"length":1,"stats":{"Line":84},"fn_name":null},{"line":793,"address":[6477460,6477242],"length":1,"stats":{"Line":34},"fn_name":null},{"line":794,"address":[6477473],"length":1,"stats":{"Line":8},"fn_name":null},{"line":795,"address":[6477483],"length":1,"stats":{"Line":26},"fn_name":null},{"line":796,"address":[6477341,6477498],"length":1,"stats":{"Line":17},"fn_name":null},{"line":797,"address":[6477508],"length":1,"stats":{"Line":8},"fn_name":null},{"line":799,"address":[6477557],"length":1,"stats":{"Line":8},"fn_name":null},{"line":800,"address":[6477567],"length":1,"stats":{"Line":8},"fn_name":null},{"line":802,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":803,"address":[6477384],"length":1,"stats":{"Line":8},"fn_name":null},{"line":804,"address":[6477394],"length":1,"stats":{"Line":8},"fn_name":null},{"line":805,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":806,"address":[6477404],"length":1,"stats":{"Line":8},"fn_name":null},{"line":809,"address":[6477614],"length":1,"stats":{"Line":26},"fn_name":null},{"line":810,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":811,"address":[6477902],"length":1,"stats":{"Line":27},"fn_name":null},{"line":812,"address":[6477749],"length":1,"stats":{"Line":26},"fn_name":null},{"line":813,"address":[6477773],"length":1,"stats":{"Line":26},"fn_name":null},{"line":814,"address":[6477780],"length":1,"stats":{"Line":27},"fn_name":null},{"line":818,"address":[6478187,6478080],"length":1,"stats":{"Line":8},"fn_name":"hir_unicode_class"},{"line":824,"address":[6478202,6478114],"length":1,"stats":{"Line":16},"fn_name":null},{"line":825,"address":[6478377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":826,"address":[6478283],"length":1,"stats":{"Line":0},"fn_name":null},{"line":829,"address":[6478501,6478536,6478621],"length":1,"stats":{"Line":22},"fn_name":null},{"line":830,"address":[6478508,6478234],"length":1,"stats":{"Line":22},"fn_name":null},{"line":831,"address":[6478546],"length":1,"stats":{"Line":8},"fn_name":null},{"line":837,"address":[6478771],"length":1,"stats":{"Line":8},"fn_name":null},{"line":838,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":839,"address":[6478711],"length":1,"stats":{"Line":8},"fn_name":null},{"line":841,"address":[6478802,6479208],"length":1,"stats":{"Line":16},"fn_name":null},{"line":842,"address":[6478973,6478859],"length":1,"stats":{"Line":8},"fn_name":null},{"line":843,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":844,"address":[6478838],"length":1,"stats":{"Line":8},"fn_name":null},{"line":845,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":848,"address":[6479218],"length":1,"stats":{"Line":8},"fn_name":null},{"line":851,"address":[6479296,6479394],"length":1,"stats":{"Line":10},"fn_name":"hir_perl_unicode_class"},{"line":857,"address":[6479327,6479469,6479409],"length":1,"stats":{"Line":20},"fn_name":null},{"line":858,"address":[6479511],"length":1,"stats":{"Line":0},"fn_name":null},{"line":859,"address":[6479438,6479513],"length":1,"stats":{"Line":21},"fn_name":null},{"line":860,"address":[6479525],"length":1,"stats":{"Line":8},"fn_name":null},{"line":861,"address":[6479499],"length":1,"stats":{"Line":8},"fn_name":null},{"line":863,"address":[6479540,6479763,6479962],"length":1,"stats":{"Line":13},"fn_name":null},{"line":864,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":867,"address":[6480020,6479748],"length":1,"stats":{"Line":21},"fn_name":null},{"line":868,"address":[6480004],"length":1,"stats":{"Line":8},"fn_name":null},{"line":870,"address":[6480022],"length":1,"stats":{"Line":13},"fn_name":null},{"line":873,"address":[6480160,6480232],"length":1,"stats":{"Line":19},"fn_name":"hir_perl_byte_class"},{"line":879,"address":[6480308,6480244,6480182],"length":1,"stats":{"Line":36},"fn_name":null},{"line":880,"address":[6480395,6480357,6480376],"length":1,"stats":{"Line":16},"fn_name":null},{"line":881,"address":[6480359,6480275],"length":1,"stats":{"Line":25},"fn_name":null},{"line":882,"address":[6480378],"length":1,"stats":{"Line":8},"fn_name":null},{"line":883,"address":[6480338],"length":1,"stats":{"Line":19},"fn_name":null},{"line":887,"address":[6480426,6480404],"length":1,"stats":{"Line":30},"fn_name":null},{"line":888,"address":[6480410],"length":1,"stats":{"Line":8},"fn_name":null},{"line":890,"address":[6480444],"length":1,"stats":{"Line":17},"fn_name":null},{"line":897,"address":[6480496],"length":1,"stats":{"Line":8},"fn_name":"convert_unicode_class_error"},{"line":902,"address":[6480513],"length":1,"stats":{"Line":8},"fn_name":null},{"line":903,"address":[6540558],"length":1,"stats":{"Line":0},"fn_name":null},{"line":904,"address":[6540824,6540920,6540726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":905,"address":[6540589],"length":1,"stats":{"Line":0},"fn_name":null},{"line":906,"address":[6540733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":908,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":909,"address":[6540831],"length":1,"stats":{"Line":0},"fn_name":null},{"line":911,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":912,"address":[6540630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":918,"address":[6480893,6480608],"length":1,"stats":{"Line":8},"fn_name":"unicode_fold_and_negate"},{"line":928,"address":[6481140,6480651],"length":1,"stats":{"Line":17},"fn_name":null},{"line":929,"address":[6480761,6480924],"length":1,"stats":{"Line":9},"fn_name":null},{"line":930,"address":[6540961],"length":1,"stats":{"Line":0},"fn_name":null},{"line":933,"address":[6481163,6481146],"length":1,"stats":{"Line":16},"fn_name":null},{"line":934,"address":[6481157],"length":1,"stats":{"Line":8},"fn_name":null},{"line":936,"address":[6481170],"length":1,"stats":{"Line":8},"fn_name":null},{"line":939,"address":[6481200],"length":1,"stats":{"Line":12},"fn_name":"bytes_fold_and_negate"},{"line":949,"address":[6481254,6481367],"length":1,"stats":{"Line":26},"fn_name":null},{"line":950,"address":[6481361],"length":1,"stats":{"Line":8},"fn_name":null},{"line":952,"address":[6481390,6481373],"length":1,"stats":{"Line":15},"fn_name":null},{"line":953,"address":[6481384],"length":1,"stats":{"Line":3},"fn_name":null},{"line":955,"address":[6481397],"length":1,"stats":{"Line":14},"fn_name":null},{"line":956,"address":[6481490,6481523],"length":1,"stats":{"Line":0},"fn_name":null},{"line":958,"address":[6481484],"length":1,"stats":{"Line":12},"fn_name":null},{"line":963,"address":[6481600,6481696],"length":1,"stats":{"Line":10},"fn_name":"class_literal_byte"},{"line":964,"address":[6482167,6481759,6481946,6482018,6481711,6481994,6481626],"length":1,"stats":{"Line":39},"fn_name":null},{"line":965,"address":[6481996,6481737],"length":1,"stats":{"Line":14},"fn_name":null},{"line":966,"address":[6481972],"length":1,"stats":{"Line":12},"fn_name":null},{"line":967,"address":[6482122,6481983],"length":1,"stats":{"Line":23},"fn_name":null},{"line":968,"address":[6482116],"length":1,"stats":{"Line":14},"fn_name":null},{"line":973,"address":[6482028,6482129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":997,"address":[6482208],"length":1,"stats":{"Line":14},"fn_name":"from_ast"},{"line":998,"address":[6482225],"length":1,"stats":{"Line":16},"fn_name":null},{"line":999,"address":[6482260],"length":1,"stats":{"Line":14},"fn_name":null},{"line":1000,"address":[6482400,6482270,6482592,6482597],"length":1,"stats":{"Line":40},"fn_name":null},{"line":1001,"address":[6482572,6482532,6482512,6482485,6482492,6482552],"length":1,"stats":{"Line":53},"fn_name":null},{"line":1002,"address":[6482425],"length":1,"stats":{"Line":17},"fn_name":null},{"line":1003,"address":[6482487],"length":1,"stats":{"Line":19},"fn_name":null},{"line":1005,"address":[6482453],"length":1,"stats":{"Line":17},"fn_name":null},{"line":1006,"address":[6482494],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1008,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1009,"address":[6482514],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1011,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1012,"address":[6482534],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1014,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1015,"address":[6482554],"length":1,"stats":{"Line":11},"fn_name":null},{"line":1017,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1018,"address":[6482574],"length":1,"stats":{"Line":20},"fn_name":null},{"line":1020,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1023,"address":[6482353],"length":1,"stats":{"Line":17},"fn_name":null},{"line":1026,"address":[6482608],"length":1,"stats":{"Line":17},"fn_name":"merge"},{"line":1027,"address":[6482622],"length":1,"stats":{"Line":20},"fn_name":null},{"line":1028,"address":[6482663],"length":1,"stats":{"Line":17},"fn_name":null},{"line":1030,"address":[6482677],"length":1,"stats":{"Line":20},"fn_name":null},{"line":1031,"address":[6482711],"length":1,"stats":{"Line":17},"fn_name":null},{"line":1033,"address":[6482727],"length":1,"stats":{"Line":20},"fn_name":null},{"line":1034,"address":[6482761],"length":1,"stats":{"Line":18},"fn_name":null},{"line":1036,"address":[6482777],"length":1,"stats":{"Line":20},"fn_name":null},{"line":1037,"address":[6482811],"length":1,"stats":{"Line":18},"fn_name":null},{"line":1039,"address":[6482827],"length":1,"stats":{"Line":20},"fn_name":null},{"line":1040,"address":[6482861],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1044,"address":[6482880],"length":1,"stats":{"Line":9},"fn_name":"case_insensitive"},{"line":1045,"address":[6482891],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1048,"address":[6482928],"length":1,"stats":{"Line":25},"fn_name":"multi_line"},{"line":1049,"address":[6482939],"length":1,"stats":{"Line":25},"fn_name":null},{"line":1052,"address":[6482976],"length":1,"stats":{"Line":23},"fn_name":"dot_matches_new_line"},{"line":1053,"address":[6482987],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1056,"address":[6483024],"length":1,"stats":{"Line":26},"fn_name":"swap_greed"},{"line":1057,"address":[6483035],"length":1,"stats":{"Line":26},"fn_name":null},{"line":1060,"address":[6483072],"length":1,"stats":{"Line":10},"fn_name":"unicode"},{"line":1061,"address":[6483081],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1065,"address":[6483120],"length":1,"stats":{"Line":17},"fn_name":"hir_ascii_class_bytes"},{"line":1066,"address":[6483143],"length":1,"stats":{"Line":19},"fn_name":null},{"line":1069,"address":[6541040,6541057],"length":1,"stats":{"Line":36},"fn_name":"{{closure}}"},{"line":1071,"address":[6483263],"length":1,"stats":{"Line":21},"fn_name":null},{"line":1074,"address":[6483328],"length":1,"stats":{"Line":17},"fn_name":"ascii_class"},{"line":1076,"address":[6483493,6483571,6483643,6483666,6483712,6483620,6483415,6483441,6483545,6483689,6483597,6483467,6483519,6483387],"length":1,"stats":{"Line":67},"fn_name":null},{"line":1077,"address":[6483394,6483337],"length":1,"stats":{"Line":19},"fn_name":null},{"line":1078,"address":[6483420],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1079,"address":[6483446],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1080,"address":[6483472],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1081,"address":[6483498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1082,"address":[6483524],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1083,"address":[6483550],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1084,"address":[6483576],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1085,"address":[6483599],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1086,"address":[6483622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1087,"address":[6483645],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1095,"address":[6483668],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1096,"address":[6483691],"length":1,"stats":{"Line":17},"fn_name":null},{"line":1097,"address":[6483366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":353,"coverable":524},{"path":["/","usr","src","regex","regex-syntax","src","hir","visitor.rs"],"content":"use hir::{self, Hir, HirKind};\n\n/// A trait for visiting the high-level IR (HIR) in depth first order.\n///\n/// The principle aim of this trait is to enable callers to perform case\n/// analysis on a high-level intermediate representation of a regular\n/// expression without necessarily using recursion. In particular, this permits\n/// callers to do case analysis with constant stack usage, which can be\n/// important since the size of an HIR may be proportional to end user input.\n///\n/// Typical usage of this trait involves providing an implementation and then\n/// running it using the [`visit`](fn.visit.html) function.\npub trait Visitor {\n    /// The result of visiting an HIR.\n    type Output;\n    /// An error that visiting an HIR might return.\n    type Err;\n\n    /// All implementors of `Visitor` must provide a `finish` method, which\n    /// yields the result of visiting the HIR or an error.\n    fn finish(self) -> Result<Self::Output, Self::Err>;\n\n    /// This method is called before beginning traversal of the HIR.\n    fn start(&mut self) {}\n\n    /// This method is called on an `Hir` before descending into child `Hir`\n    /// nodes.\n    fn visit_pre(&mut self, _hir: &Hir) -> Result<(), Self::Err> {\n        Ok(())\n    }\n\n    /// This method is called on an `Hir` after descending all of its child\n    /// `Hir` nodes.\n    fn visit_post(&mut self, _hir: &Hir) -> Result<(), Self::Err> {\n        Ok(())\n    }\n\n    /// This method is called between child nodes of an alternation.\n    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {\n        Ok(())\n    }\n}\n\n/// Executes an implementation of `Visitor` in constant stack space.\n///\n/// This function will visit every node in the given `Hir` while calling\n/// appropriate methods provided by the\n/// [`Visitor`](trait.Visitor.html) trait.\n///\n/// The primary use case for this method is when one wants to perform case\n/// analysis over an `Hir` without using a stack size proportional to the depth\n/// of the `Hir`. Namely, this method will instead use constant stack space,\n/// but will use heap space proportional to the size of the `Hir`. This may be\n/// desirable in cases where the size of `Hir` is proportional to end user\n/// input.\n///\n/// If the visitor returns an error at any point, then visiting is stopped and\n/// the error is returned.\npub fn visit<V: Visitor>(hir: &Hir, visitor: V) -> Result<V::Output, V::Err> {\n    HeapVisitor::new().visit(hir, visitor)\n}\n\n/// HeapVisitor visits every item in an `Hir` recursively using constant stack\n/// size and a heap size proportional to the size of the `Hir`.\nstruct HeapVisitor<'a> {\n    /// A stack of `Hir` nodes. This is roughly analogous to the call stack\n    /// used in a typical recursive visitor.\n    stack: Vec<(&'a Hir, Frame<'a>)>,\n}\n\n/// Represents a single stack frame while performing structural induction over\n/// an `Hir`.\nenum Frame<'a> {\n    /// A stack frame allocated just before descending into a repetition\n    /// operator's child node.\n    Repetition(&'a hir::Repetition),\n    /// A stack frame allocated just before descending into a group's child\n    /// node.\n    Group(&'a hir::Group),\n    /// The stack frame used while visiting every child node of a concatenation\n    /// of expressions.\n    Concat {\n        /// The child node we are currently visiting.\n        head: &'a Hir,\n        /// The remaining child nodes to visit (which may be empty).\n        tail: &'a [Hir],\n    },\n    /// The stack frame used while visiting every child node of an alternation\n    /// of expressions.\n    Alternation {\n        /// The child node we are currently visiting.\n        head: &'a Hir,\n        /// The remaining child nodes to visit (which may be empty).\n        tail: &'a [Hir],\n    },\n}\n\nimpl<'a> HeapVisitor<'a> {\n    fn new() -> HeapVisitor<'a> {\n        HeapVisitor { stack: vec![] }\n    }\n\n    fn visit<V: Visitor>(\n        &mut self,\n        mut hir: &'a Hir,\n        mut visitor: V,\n    ) -> Result<V::Output, V::Err> {\n        self.stack.clear();\n\n        visitor.start();\n        loop {\n            visitor.visit_pre(hir)?;\n            if let Some(x) = self.induct(hir) {\n                let child = x.child();\n                self.stack.push((hir, x));\n                hir = child;\n                continue;\n            }\n            // No induction means we have a base case, so we can post visit\n            // it now.\n            visitor.visit_post(hir)?;\n\n            // At this point, we now try to pop our call stack until it is\n            // either empty or we hit another inductive case.\n            loop {\n                let (post_hir, frame) = match self.stack.pop() {\n                    None => return visitor.finish(),\n                    Some((post_hir, frame)) => (post_hir, frame),\n                };\n                // If this is a concat/alternate, then we might have additional\n                // inductive steps to process.\n                if let Some(x) = self.pop(frame) {\n                    if let Frame::Alternation { .. } = x {\n                        visitor.visit_alternation_in()?;\n                    }\n                    hir = x.child();\n                    self.stack.push((post_hir, x));\n                    break;\n                }\n                // Otherwise, we've finished visiting all the child nodes for\n                // this HIR, so we can post visit it now.\n                visitor.visit_post(post_hir)?;\n            }\n        }\n    }\n\n    /// Build a stack frame for the given HIR if one is needed (which occurs if\n    /// and only if there are child nodes in the HIR). Otherwise, return None.\n    fn induct(&mut self, hir: &'a Hir) -> Option<Frame<'a>> {\n        match *hir.kind() {\n            HirKind::Repetition(ref x) => Some(Frame::Repetition(x)),\n            HirKind::Group(ref x) => Some(Frame::Group(x)),\n            HirKind::Concat(ref x) if x.is_empty() => None,\n            HirKind::Concat(ref x) => {\n                Some(Frame::Concat { head: &x[0], tail: &x[1..] })\n            }\n            HirKind::Alternation(ref x) if x.is_empty() => None,\n            HirKind::Alternation(ref x) => {\n                Some(Frame::Alternation { head: &x[0], tail: &x[1..] })\n            }\n            _ => None,\n        }\n    }\n\n    /// Pops the given frame. If the frame has an additional inductive step,\n    /// then return it, otherwise return `None`.\n    fn pop(&self, induct: Frame<'a>) -> Option<Frame<'a>> {\n        match induct {\n            Frame::Repetition(_) => None,\n            Frame::Group(_) => None,\n            Frame::Concat { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(Frame::Concat { head: &tail[0], tail: &tail[1..] })\n                }\n            }\n            Frame::Alternation { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(Frame::Alternation {\n                        head: &tail[0],\n                        tail: &tail[1..],\n                    })\n                }\n            }\n        }\n    }\n}\n\nimpl<'a> Frame<'a> {\n    /// Perform the next inductive step on this frame and return the next\n    /// child HIR node to visit.\n    fn child(&self) -> &'a Hir {\n        match *self {\n            Frame::Repetition(rep) => &rep.hir,\n            Frame::Group(group) => &group.hir,\n            Frame::Concat { head, .. } => head,\n            Frame::Alternation { head, .. } => head,\n        }\n    }\n}\n","traces":[{"line":24,"address":[6920055,6920048,6920053],"length":1,"stats":{"Line":0},"fn_name":"start<regex_syntax::hir::print::Writer<&mut core::fmt::Formatter>>"},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[7381439,7381376],"length":1,"stats":{"Line":0},"fn_name":"visit<regex_syntax::hir::print::Writer<&mut core::fmt::Formatter>>"},{"line":60,"address":[7381395,7381451],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[7387120],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":100,"address":[7387136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[7381584,7381646],"length":1,"stats":{"Line":0},"fn_name":"visit<regex_syntax::hir::print::Writer<&mut core::fmt::Formatter>>"},{"line":108,"address":[7381614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[7381661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[7381677,7382962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[7381679],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[7381833,7381922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[7381948],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[7381985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[7382091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[7382096],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[7381894,7382105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[7383073,7382210],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[7382384,7382212,7382501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[7382503,7382236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[7382264],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[7382555,7382617,7382432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[7382681,7382825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[7382696],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[7382827],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[7382861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[7382589,7382971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[7387216],"length":1,"stats":{"Line":0},"fn_name":"induct"},{"line":150,"address":[7387327,7387513,7387593,7387785,7387247,7387417,7387865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[7387271,7387337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[7387427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[7387523],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[7387607],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[7387622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[7387795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[7387879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[7387894],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[7387320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[7388080],"length":1,"stats":{"Line":0},"fn_name":"pop"},{"line":168,"address":[7388484,7388202,7388233,7388690,7388216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[7388209,7388098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[7388226],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[7388243],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[7388267,7388342],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[7388335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[7388347,7388732,7388312,7388759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[7388147],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[7388171,7388493,7388538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[7388531],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[7388593],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[7388508,7388705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[7388543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[7388768],"length":1,"stats":{"Line":0},"fn_name":"child"},{"line":196,"address":[7388828,7388854,7388900,7388879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[7388837,7388777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[7388861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[7388886],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[7388814],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":64},{"path":["/","usr","src","regex","regex-syntax","src","lib.rs"],"content":"/*!\nThis crate provides a robust regular expression parser.\n\nThis crate defines two primary types:\n\n* [`Ast`](ast/enum.Ast.html) is the abstract syntax of a regular expression.\n  An abstract syntax corresponds to a *structured representation* of the\n  concrete syntax of a regular expression, where the concrete syntax is the\n  pattern string itself (e.g., `foo(bar)+`). Given some abstract syntax, it\n  can be converted back to the original concrete syntax (modulo some details,\n  like whitespace). To a first approximation, the abstract syntax is complex\n  and difficult to analyze.\n* [`Hir`](hir/struct.Hir.html) is the high-level intermediate representation\n  (\"HIR\" or \"high-level IR\" for short) of regular expression. It corresponds to\n  an intermediate state of a regular expression that sits between the abstract\n  syntax and the low level compiled opcodes that are eventually responsible for\n  executing a regular expression search. Given some high-level IR, it is not\n  possible to produce the original concrete syntax (although it is possible to\n  produce an equivalent concrete syntax, but it will likely scarcely resemble\n  the original pattern). To a first approximation, the high-level IR is simple\n  and easy to analyze.\n\nThese two types come with conversion routines:\n\n* An [`ast::parse::Parser`](ast/parse/struct.Parser.html) converts concrete\n  syntax (a `&str`) to an [`Ast`](ast/enum.Ast.html).\n* A [`hir::translate::Translator`](hir/translate/struct.Translator.html)\n  converts an [`Ast`](ast/enum.Ast.html) to a [`Hir`](hir/struct.Hir.html).\n\nAs a convenience, the above two conversion routines are combined into one via\nthe top-level [`Parser`](struct.Parser.html) type. This `Parser` will first\nconvert your pattern to an `Ast` and then convert the `Ast` to an `Hir`.\n\n\n# Example\n\nThis example shows how to parse a pattern string into its HIR:\n\n```\nuse regex_syntax::Parser;\nuse regex_syntax::hir::{self, Hir};\n\nlet hir = Parser::new().parse(\"a|b\").unwrap();\nassert_eq!(hir, Hir::alternation(vec![\n    Hir::literal(hir::Literal::Unicode('a')),\n    Hir::literal(hir::Literal::Unicode('b')),\n]));\n```\n\n\n# Concrete syntax supported\n\nThe concrete syntax is documented as part of the public API of the\n[`regex` crate](https://docs.rs/regex/%2A/regex/#syntax).\n\n\n# Input safety\n\nA key feature of this library is that it is safe to use with end user facing\ninput. This plays a significant role in the internal implementation. In\nparticular:\n\n1. Parsers provide a `nest_limit` option that permits callers to control how\n   deeply nested a regular expression is allowed to be. This makes it possible\n   to do case analysis over an `Ast` or an `Hir` using recursion without\n   worrying about stack overflow.\n2. Since relying on a particular stack size is brittle, this crate goes to\n   great lengths to ensure that all interactions with both the `Ast` and the\n   `Hir` do not use recursion. Namely, they use constant stack space and heap\n   space proportional to the size of the original pattern string (in bytes).\n   This includes the type's corresponding destructors. (One exception to this\n   is literal extraction, but this will eventually get fixed.)\n\n\n# Error reporting\n\nThe `Display` implementations on all `Error` types exposed in this library\nprovide nice human readable errors that are suitable for showing to end users\nin a monospace font.\n\n\n# Literal extraction\n\nThis crate provides limited support for\n[literal extraction from `Hir` values](hir/literal/struct.Literals.html).\nBe warned that literal extraction currently uses recursion, and therefore,\nstack size proportional to the size of the `Hir`.\n\nThe purpose of literal extraction is to speed up searches. That is, if you\nknow a regular expression must match a prefix or suffix literal, then it is\noften quicker to search for instances of that literal, and then confirm or deny\nthe match using the full regular expression engine. These optimizations are\ndone automatically in the `regex` crate.\n\n\n# Crate features\n\nAn important feature provided by this crate is its Unicode support. This\nincludes things like case folding, boolean properties, general categories,\nscripts and Unicode-aware support for the Perl classes `\\w`, `\\s` and `\\d`.\nHowever, a downside of this support is that it requires bundling several\nUnicode data tables that are substantial in size.\n\nA fair number of use cases do not require full Unicode support. For this\nreason, this crate exposes a number of features to control which Unicode\ndata is available.\n\nIf a regular expression attempts to use a Unicode feature that is not available\nbecause the corresponding crate feature was disabled, then translating that\nregular expression to an `Hir` will return an error. (It is still possible\nconstruct an `Ast` for such a regular expression, since Unicode data is not\nused until translation to an `Hir`.) Stated differently, enabling or disabling\nany of the features below can only add or subtract from the total set of valid\nregular expressions. Enabling or disabling a feature will never modify the\nmatch semantics of a regular expression.\n\nThe following features are available:\n\n* **unicode** -\n  Enables all Unicode features. This feature is enabled by default, and will\n  always cover all Unicode features, even if more are added in the future.\n* **unicode-age** -\n  Provide the data for the\n  [Unicode `Age` property](https://www.unicode.org/reports/tr44/tr44-24.html#Character_Age).\n  This makes it possible to use classes like `\\p{Age:6.0}` to refer to all\n  codepoints first introduced in Unicode 6.0\n* **unicode-bool** -\n  Provide the data for numerous Unicode boolean properties. The full list\n  is not included here, but contains properties like `Alphabetic`, `Emoji`,\n  `Lowercase`, `Math`, `Uppercase` and `White_Space`.\n* **unicode-case** -\n  Provide the data for case insensitive matching using\n  [Unicode's \"simple loose matches\" specification](https://www.unicode.org/reports/tr18/#Simple_Loose_Matches).\n* **unicode-gencat** -\n  Provide the data for\n  [Uncode general categories](https://www.unicode.org/reports/tr44/tr44-24.html#General_Category_Values).\n  This includes, but is not limited to, `Decimal_Number`, `Letter`,\n  `Math_Symbol`, `Number` and `Punctuation`.\n* **unicode-perl** -\n  Provide the data for supporting the Unicode-aware Perl character classes,\n  corresponding to `\\w`, `\\s` and `\\d`. This is also necessary for using\n  Unicode-aware word boundary assertions. Note that if this feature is\n  disabled, the `\\s` and `\\d` character classes are still available if the\n  `unicode-bool` and `unicode-gencat` features are enabled, respectively.\n* **unicode-script** -\n  Provide the data for\n  [Unicode scripts and script extensions](https://www.unicode.org/reports/tr24/).\n  This includes, but is not limited to, `Arabic`, `Cyrillic`, `Hebrew`,\n  `Latin` and `Thai`.\n* **unicode-segment** -\n  Provide the data necessary to provide the properties used to implement the\n  [Unicode text segmentation algorithms](https://www.unicode.org/reports/tr29/).\n  This enables using classes like `\\p{gcb=Extend}`, `\\p{wb=Katakana}` and\n  `\\p{sb=ATerm}`.\n*/\n\n#![deny(missing_docs)]\n#![forbid(unsafe_code)]\n\npub use error::{Error, Result};\npub use parser::{Parser, ParserBuilder};\npub use unicode::UnicodeWordError;\n\npub mod ast;\nmod either;\nmod error;\npub mod hir;\nmod parser;\nmod unicode;\nmod unicode_tables;\npub mod utf8;\n\n/// Escapes all regular expression meta characters in `text`.\n///\n/// The string returned may be safely used as a literal in a regular\n/// expression.\npub fn escape(text: &str) -> String {\n    let mut quoted = String::new();\n    escape_into(text, &mut quoted);\n    quoted\n}\n\n/// Escapes all meta characters in `text` and writes the result into `buf`.\n///\n/// This will append escape characters into the given buffer. The characters\n/// that are appended are safe to use as a literal in a regular expression.\npub fn escape_into(text: &str, buf: &mut String) {\n    buf.reserve(text.len());\n    for c in text.chars() {\n        if is_meta_character(c) {\n            buf.push('\\\\');\n        }\n        buf.push(c);\n    }\n}\n\n/// Returns true if the give character has significance in a regex.\n///\n/// These are the only characters that are allowed to be escaped, with one\n/// exception: an ASCII space character may be escaped when extended mode (with\n/// the `x` flag) is enabld. In particular, `is_meta_character(' ')` returns\n/// `false`.\n///\n/// Note that the set of characters for which this function returns `true` or\n/// `false` is fixed and won't change in a semver compatible release.\npub fn is_meta_character(c: char) -> bool {\n    match c {\n        '\\\\' | '.' | '+' | '*' | '?' | '(' | ')' | '|' | '[' | ']' | '{'\n        | '}' | '^' | '$' | '#' | '&' | '-' | '~' => true,\n        _ => false,\n    }\n}\n\n/// Returns true if and only if the given character is a Unicode word\n/// character.\n///\n/// A Unicode word character is defined by\n/// [UTS#18 Annex C](http://unicode.org/reports/tr18/#Compatibility_Properties).\n/// In particular, a character\n/// is considered a word character if it is in either of the `Alphabetic` or\n/// `Join_Control` properties, or is in one of the `Decimal_Number`, `Mark`\n/// or `Connector_Punctuation` general categories.\n///\n/// # Panics\n///\n/// If the `unicode-perl` feature is not enabled, then this function panics.\n/// For this reason, it is recommended that callers use\n/// [`try_is_word_character`](fn.try_is_word_character.html)\n/// instead.\npub fn is_word_character(c: char) -> bool {\n    try_is_word_character(c).expect(\"unicode-perl feature must be enabled\")\n}\n\n/// Returns true if and only if the given character is a Unicode word\n/// character.\n///\n/// A Unicode word character is defined by\n/// [UTS#18 Annex C](http://unicode.org/reports/tr18/#Compatibility_Properties).\n/// In particular, a character\n/// is considered a word character if it is in either of the `Alphabetic` or\n/// `Join_Control` properties, or is in one of the `Decimal_Number`, `Mark`\n/// or `Connector_Punctuation` general categories.\n///\n/// # Errors\n///\n/// If the `unicode-perl` feature is not enabled, then this function always\n/// returns an error.\npub fn try_is_word_character(\n    c: char,\n) -> std::result::Result<bool, UnicodeWordError> {\n    unicode::is_word_character(c)\n}\n\n/// Returns true if and only if the given character is an ASCII word character.\n///\n/// An ASCII word character is defined by the following character class:\n/// `[_0-9a-zA-Z]'.\npub fn is_word_byte(c: u8) -> bool {\n    match c {\n        b'_' | b'0'..=b'9' | b'a'..=b'z' | b'A'..=b'Z' => true,\n        _ => false,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn escape_meta() {\n        assert_eq!(\n            escape(r\"\\.+*?()|[]{}^$#&-~\"),\n            r\"\\\\\\.\\+\\*\\?\\(\\)\\|\\[\\]\\{\\}\\^\\$\\#\\&\\-\\~\".to_string()\n        );\n    }\n\n    #[test]\n    fn word_byte() {\n        assert!(is_word_byte(b'a'));\n        assert!(!is_word_byte(b'-'));\n    }\n\n    #[test]\n    #[cfg(feature = \"unicode-perl\")]\n    fn word_char() {\n        assert!(is_word_character('a'), \"ASCII\");\n        assert!(is_word_character('à'), \"Latin-1\");\n        assert!(is_word_character('β'), \"Greek\");\n        assert!(is_word_character('\\u{11011}'), \"Brahmi (Unicode 6.0)\");\n        assert!(is_word_character('\\u{11611}'), \"Modi (Unicode 7.0)\");\n        assert!(is_word_character('\\u{11711}'), \"Ahom (Unicode 8.0)\");\n        assert!(is_word_character('\\u{17828}'), \"Tangut (Unicode 9.0)\");\n        assert!(is_word_character('\\u{1B1B1}'), \"Nushu (Unicode 10.0)\");\n        assert!(is_word_character('\\u{16E40}'), \"Medefaidrin (Unicode 11.0)\");\n        assert!(!is_word_character('-'));\n        assert!(!is_word_character('☃'));\n    }\n\n    #[test]\n    #[should_panic]\n    #[cfg(not(feature = \"unicode-perl\"))]\n    fn word_char_disabled_panic() {\n        assert!(is_word_character('a'));\n    }\n\n    #[test]\n    #[cfg(not(feature = \"unicode-perl\"))]\n    fn word_char_disabled_error() {\n        assert!(try_is_word_character('a').is_err());\n    }\n}\n","traces":[{"line":177,"address":[6918624,6918675],"length":1,"stats":{"Line":0},"fn_name":"escape"},{"line":178,"address":[6918641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[6918687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[6918713],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[6918784],"length":1,"stats":{"Line":0},"fn_name":"escape_into"},{"line":188,"address":[6551413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[6919045,6918856,6918962,6919043],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[6551619,6551578],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[6551609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[6551630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[6551648],"length":1,"stats":{"Line":9},"fn_name":"is_meta_character"},{"line":207,"address":[6919103],"length":1,"stats":{"Line":8},"fn_name":null},{"line":208,"address":[6919064],"length":1,"stats":{"Line":9},"fn_name":null},{"line":209,"address":[6551697],"length":1,"stats":{"Line":9},"fn_name":null},{"line":210,"address":[6551690],"length":1,"stats":{"Line":8},"fn_name":null},{"line":230,"address":[6551728],"length":1,"stats":{"Line":8},"fn_name":"is_word_character"},{"line":231,"address":[6551733],"length":1,"stats":{"Line":8},"fn_name":null},{"line":248,"address":[6551808],"length":1,"stats":{"Line":8},"fn_name":"try_is_word_character"},{"line":251,"address":[6551813],"length":1,"stats":{"Line":8},"fn_name":null},{"line":258,"address":[6551840],"length":1,"stats":{"Line":8},"fn_name":"is_word_byte"},{"line":259,"address":[6551912],"length":1,"stats":{"Line":8},"fn_name":null},{"line":260,"address":[6551849,6551914],"length":1,"stats":{"Line":16},"fn_name":null},{"line":261,"address":[6551907],"length":1,"stats":{"Line":8},"fn_name":null}],"covered":13,"coverable":23},{"path":["/","usr","src","regex","regex-syntax","src","parser.rs"],"content":"use ast;\nuse hir;\n\nuse Result;\n\n/// A builder for a regular expression parser.\n///\n/// This builder permits modifying configuration options for the parser.\n///\n/// This type combines the builder options for both the\n/// [AST `ParserBuilder`](ast/parse/struct.ParserBuilder.html)\n/// and the\n/// [HIR `TranslatorBuilder`](hir/translate/struct.TranslatorBuilder.html).\n#[derive(Clone, Debug, Default)]\npub struct ParserBuilder {\n    ast: ast::parse::ParserBuilder,\n    hir: hir::translate::TranslatorBuilder,\n}\n\nimpl ParserBuilder {\n    /// Create a new parser builder with a default configuration.\n    pub fn new() -> ParserBuilder {\n        ParserBuilder::default()\n    }\n\n    /// Build a parser from this configuration with the given pattern.\n    pub fn build(&self) -> Parser {\n        Parser { ast: self.ast.build(), hir: self.hir.build() }\n    }\n\n    /// Set the nesting limit for this parser.\n    ///\n    /// The nesting limit controls how deep the abstract syntax tree is allowed\n    /// to be. If the AST exceeds the given limit (e.g., with too many nested\n    /// groups), then an error is returned by the parser.\n    ///\n    /// The purpose of this limit is to act as a heuristic to prevent stack\n    /// overflow for consumers that do structural induction on an `Ast` using\n    /// explicit recursion. While this crate never does this (instead using\n    /// constant stack space and moving the call stack to the heap), other\n    /// crates may.\n    ///\n    /// This limit is not checked until the entire Ast is parsed. Therefore,\n    /// if callers want to put a limit on the amount of heap space used, then\n    /// they should impose a limit on the length, in bytes, of the concrete\n    /// pattern string. In particular, this is viable since this parser\n    /// implementation will limit itself to heap space proportional to the\n    /// lenth of the pattern string.\n    ///\n    /// Note that a nest limit of `0` will return a nest limit error for most\n    /// patterns but not all. For example, a nest limit of `0` permits `a` but\n    /// not `ab`, since `ab` requires a concatenation, which results in a nest\n    /// depth of `1`. In general, a nest limit is not something that manifests\n    /// in an obvious way in the concrete syntax, therefore, it should not be\n    /// used in a granular way.\n    pub fn nest_limit(&mut self, limit: u32) -> &mut ParserBuilder {\n        self.ast.nest_limit(limit);\n        self\n    }\n\n    /// Whether to support octal syntax or not.\n    ///\n    /// Octal syntax is a little-known way of uttering Unicode codepoints in\n    /// a regular expression. For example, `a`, `\\x61`, `\\u0061` and\n    /// `\\141` are all equivalent regular expressions, where the last example\n    /// shows octal syntax.\n    ///\n    /// While supporting octal syntax isn't in and of itself a problem, it does\n    /// make good error messages harder. That is, in PCRE based regex engines,\n    /// syntax like `\\0` invokes a backreference, which is explicitly\n    /// unsupported in Rust's regex engine. However, many users expect it to\n    /// be supported. Therefore, when octal support is disabled, the error\n    /// message will explicitly mention that backreferences aren't supported.\n    ///\n    /// Octal syntax is disabled by default.\n    pub fn octal(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.ast.octal(yes);\n        self\n    }\n\n    /// When enabled, the parser will permit the construction of a regular\n    /// expression that may match invalid UTF-8.\n    ///\n    /// When disabled (the default), the parser is guaranteed to produce\n    /// an expression that will only ever match valid UTF-8 (otherwise, the\n    /// parser will return an error).\n    ///\n    /// Perhaps surprisingly, when invalid UTF-8 isn't allowed, a negated ASCII\n    /// word boundary (uttered as `(?-u:\\B)` in the concrete syntax) will cause\n    /// the parser to return an error. Namely, a negated ASCII word boundary\n    /// can result in matching positions that aren't valid UTF-8 boundaries.\n    pub fn allow_invalid_utf8(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.hir.allow_invalid_utf8(yes);\n        self\n    }\n\n    /// Enable verbose mode in the regular expression.\n    ///\n    /// When enabled, verbose mode permits insigificant whitespace in many\n    /// places in the regular expression, as well as comments. Comments are\n    /// started using `#` and continue until the end of the line.\n    ///\n    /// By default, this is disabled. It may be selectively enabled in the\n    /// regular expression by using the `x` flag regardless of this setting.\n    pub fn ignore_whitespace(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.ast.ignore_whitespace(yes);\n        self\n    }\n\n    /// Enable or disable the case insensitive flag by default.\n    ///\n    /// By default this is disabled. It may alternatively be selectively\n    /// enabled in the regular expression itself via the `i` flag.\n    pub fn case_insensitive(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.hir.case_insensitive(yes);\n        self\n    }\n\n    /// Enable or disable the multi-line matching flag by default.\n    ///\n    /// By default this is disabled. It may alternatively be selectively\n    /// enabled in the regular expression itself via the `m` flag.\n    pub fn multi_line(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.hir.multi_line(yes);\n        self\n    }\n\n    /// Enable or disable the \"dot matches any character\" flag by default.\n    ///\n    /// By default this is disabled. It may alternatively be selectively\n    /// enabled in the regular expression itself via the `s` flag.\n    pub fn dot_matches_new_line(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.hir.dot_matches_new_line(yes);\n        self\n    }\n\n    /// Enable or disable the \"swap greed\" flag by default.\n    ///\n    /// By default this is disabled. It may alternatively be selectively\n    /// enabled in the regular expression itself via the `U` flag.\n    pub fn swap_greed(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.hir.swap_greed(yes);\n        self\n    }\n\n    /// Enable or disable the Unicode flag (`u`) by default.\n    ///\n    /// By default this is **enabled**. It may alternatively be selectively\n    /// disabled in the regular expression itself via the `u` flag.\n    ///\n    /// Note that unless `allow_invalid_utf8` is enabled (it's disabled by\n    /// default), a regular expression will fail to parse if Unicode mode is\n    /// disabled and a sub-expression could possibly match invalid UTF-8.\n    pub fn unicode(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.hir.unicode(yes);\n        self\n    }\n}\n\n/// A convenience parser for regular expressions.\n///\n/// This parser takes as input a regular expression pattern string (the\n/// \"concrete syntax\") and returns a high-level intermediate representation\n/// (the HIR) suitable for most types of analysis. In particular, this parser\n/// hides the intermediate state of producing an AST (the \"abstract syntax\").\n/// The AST is itself far more complex than the HIR, so this parser serves as a\n/// convenience for never having to deal with it at all.\n///\n/// If callers have more fine grained use cases that need an AST, then please\n/// see the [`ast::parse`](ast/parse/index.html) module.\n///\n/// A `Parser` can be configured in more detail via a\n/// [`ParserBuilder`](struct.ParserBuilder.html).\n#[derive(Clone, Debug)]\npub struct Parser {\n    ast: ast::parse::Parser,\n    hir: hir::translate::Translator,\n}\n\nimpl Parser {\n    /// Create a new parser with a default configuration.\n    ///\n    /// The parser can be run with `parse` method. The parse method returns\n    /// a high level intermediate representation of the given regular\n    /// expression.\n    ///\n    /// To set configuration options on the parser, use\n    /// [`ParserBuilder`](struct.ParserBuilder.html).\n    pub fn new() -> Parser {\n        ParserBuilder::new().build()\n    }\n\n    /// Parse the regular expression into a high level intermediate\n    /// representation.\n    pub fn parse(&mut self, pattern: &str) -> Result<hir::Hir> {\n        let ast = self.ast.parse(pattern)?;\n        let hir = self.hir.translate(pattern, &ast)?;\n        Ok(hir)\n    }\n}\n","traces":[{"line":22,"address":[6595344],"length":1,"stats":{"Line":34},"fn_name":"new"},{"line":23,"address":[6962760],"length":1,"stats":{"Line":34},"fn_name":null},{"line":27,"address":[6595431,6595376],"length":1,"stats":{"Line":34},"fn_name":"build"},{"line":28,"address":[6595551,6595451,6595394],"length":1,"stats":{"Line":68},"fn_name":null},{"line":56,"address":[6595584],"length":1,"stats":{"Line":34},"fn_name":"nest_limit"},{"line":57,"address":[6595597],"length":1,"stats":{"Line":34},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[6595632],"length":1,"stats":{"Line":34},"fn_name":"octal"},{"line":77,"address":[6595650],"length":1,"stats":{"Line":34},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[6595696],"length":1,"stats":{"Line":34},"fn_name":"allow_invalid_utf8"},{"line":93,"address":[6595714],"length":1,"stats":{"Line":34},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[6963168],"length":1,"stats":{"Line":34},"fn_name":"ignore_whitespace"},{"line":106,"address":[6963186],"length":1,"stats":{"Line":34},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[6595824],"length":1,"stats":{"Line":34},"fn_name":"case_insensitive"},{"line":115,"address":[6595842],"length":1,"stats":{"Line":34},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[6595888],"length":1,"stats":{"Line":34},"fn_name":"multi_line"},{"line":124,"address":[6595906],"length":1,"stats":{"Line":34},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[6595952],"length":1,"stats":{"Line":34},"fn_name":"dot_matches_new_line"},{"line":133,"address":[6595970],"length":1,"stats":{"Line":34},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[6596016],"length":1,"stats":{"Line":34},"fn_name":"swap_greed"},{"line":142,"address":[6596034],"length":1,"stats":{"Line":34},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[6596080],"length":1,"stats":{"Line":34},"fn_name":"unicode"},{"line":155,"address":[6596098],"length":1,"stats":{"Line":34},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[6596144],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":190,"address":[6596151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[6596208,6596295],"length":1,"stats":{"Line":34},"fn_name":"parse"},{"line":196,"address":[6596521,6596310,6596819,6596242],"length":1,"stats":{"Line":70},"fn_name":null},{"line":197,"address":[6596455,6596867,6597113,6597343],"length":1,"stats":{"Line":37},"fn_name":null},{"line":198,"address":[6597007],"length":1,"stats":{"Line":10},"fn_name":null}],"covered":26,"coverable":37},{"path":["/","usr","src","regex","regex-syntax","src","unicode.rs"],"content":"use std::error;\nuse std::fmt;\nuse std::result;\n\nuse hir;\n\n/// A type alias for errors specific to Unicode handling of classes.\npub type Result<T> = result::Result<T, Error>;\n\n/// An inclusive range of codepoints from a generated file (hence the static\n/// lifetime).\ntype Range = &'static [(char, char)];\n\n/// An error that occurs when dealing with Unicode.\n///\n/// We don't impl the Error trait here because these always get converted\n/// into other public errors. (This error type isn't exported.)\n#[derive(Debug)]\npub enum Error {\n    PropertyNotFound,\n    PropertyValueNotFound,\n    // Not used when unicode-perl is enabled.\n    #[allow(dead_code)]\n    PerlClassNotFound,\n}\n\n/// A type alias for errors specific to Unicode case folding.\npub type FoldResult<T> = result::Result<T, CaseFoldError>;\n\n/// An error that occurs when Unicode-aware simple case folding fails.\n///\n/// This error can occur when the case mapping tables necessary for Unicode\n/// aware case folding are unavailable. This only occurs when the\n/// `unicode-case` feature is disabled. (The feature is enabled by default.)\n#[derive(Debug)]\npub struct CaseFoldError(());\n\nimpl error::Error for CaseFoldError {}\n\nimpl fmt::Display for CaseFoldError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            f,\n            \"Unicode-aware case folding is not available \\\n             (probably because the unicode-case feature is not enabled)\"\n        )\n    }\n}\n\n/// An error that occurs when the Unicode-aware `\\w` class is unavailable.\n///\n/// This error can occur when the data tables necessary for the Unicode aware\n/// Perl character class `\\w` are unavailable. This only occurs when the\n/// `unicode-perl` feature is disabled. (The feature is enabled by default.)\n#[derive(Debug)]\npub struct UnicodeWordError(());\n\nimpl error::Error for UnicodeWordError {}\n\nimpl fmt::Display for UnicodeWordError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            f,\n            \"Unicode-aware \\\\w class is not available \\\n             (probably because the unicode-perl feature is not enabled)\"\n        )\n    }\n}\n\n/// Return an iterator over the equivalence class of simple case mappings\n/// for the given codepoint. The equivalence class does not include the\n/// given codepoint.\n///\n/// If the equivalence class is empty, then this returns the next scalar\n/// value that has a non-empty equivalence class, if it exists. If no such\n/// scalar value exists, then `None` is returned. The point of this behavior\n/// is to permit callers to avoid calling `simple_fold` more than they need\n/// to, since there is some cost to fetching the equivalence class.\n///\n/// This returns an error if the Unicode case folding tables are not available.\npub fn simple_fold(\n    c: char,\n) -> FoldResult<result::Result<impl Iterator<Item = char>, Option<char>>> {\n    #[cfg(not(feature = \"unicode-case\"))]\n    fn imp(\n        _: char,\n    ) -> FoldResult<result::Result<impl Iterator<Item = char>, Option<char>>>\n    {\n        use std::option::IntoIter;\n        Err::<result::Result<IntoIter<char>, _>, _>(CaseFoldError(()))\n    }\n\n    #[cfg(feature = \"unicode-case\")]\n    fn imp(\n        c: char,\n    ) -> FoldResult<result::Result<impl Iterator<Item = char>, Option<char>>>\n    {\n        use unicode_tables::case_folding_simple::CASE_FOLDING_SIMPLE;\n\n        Ok(CASE_FOLDING_SIMPLE\n            .binary_search_by_key(&c, |&(c1, _)| c1)\n            .map(|i| CASE_FOLDING_SIMPLE[i].1.iter().map(|&c| c))\n            .map_err(|i| {\n                if i >= CASE_FOLDING_SIMPLE.len() {\n                    None\n                } else {\n                    Some(CASE_FOLDING_SIMPLE[i].0)\n                }\n            }))\n    }\n\n    imp(c)\n}\n\n/// Returns true if and only if the given (inclusive) range contains at least\n/// one Unicode scalar value that has a non-empty non-trivial simple case\n/// mapping.\n///\n/// This function panics if `end < start`.\n///\n/// This returns an error if the Unicode case folding tables are not available.\npub fn contains_simple_case_mapping(\n    start: char,\n    end: char,\n) -> FoldResult<bool> {\n    #[cfg(not(feature = \"unicode-case\"))]\n    fn imp(_: char, _: char) -> FoldResult<bool> {\n        Err(CaseFoldError(()))\n    }\n\n    #[cfg(feature = \"unicode-case\")]\n    fn imp(start: char, end: char) -> FoldResult<bool> {\n        use std::cmp::Ordering;\n        use unicode_tables::case_folding_simple::CASE_FOLDING_SIMPLE;\n\n        assert!(start <= end);\n        Ok(CASE_FOLDING_SIMPLE\n            .binary_search_by(|&(c, _)| {\n                if start <= c && c <= end {\n                    Ordering::Equal\n                } else if c > end {\n                    Ordering::Greater\n                } else {\n                    Ordering::Less\n                }\n            })\n            .is_ok())\n    }\n\n    imp(start, end)\n}\n\n/// A query for finding a character class defined by Unicode. This supports\n/// either use of a property name directly, or lookup by property value. The\n/// former generally refers to Binary properties (see UTS#44, Table 8), but\n/// as a special exception (see UTS#18, Section 1.2) both general categories\n/// (an enumeration) and scripts (a catalog) are supported as if each of their\n/// possible values were a binary property.\n///\n/// In all circumstances, property names and values are normalized and\n/// canonicalized. That is, `GC == gc == GeneralCategory == general_category`.\n///\n/// The lifetime `'a` refers to the shorter of the lifetimes of property name\n/// and property value.\n#[derive(Debug)]\npub enum ClassQuery<'a> {\n    /// Return a class corresponding to a Unicode binary property, named by\n    /// a single letter.\n    OneLetter(char),\n    /// Return a class corresponding to a Unicode binary property.\n    ///\n    /// Note that, by special exception (see UTS#18, Section 1.2), both\n    /// general category values and script values are permitted here as if\n    /// they were a binary property.\n    Binary(&'a str),\n    /// Return a class corresponding to all codepoints whose property\n    /// (identified by `property_name`) corresponds to the given value\n    /// (identified by `property_value`).\n    ByValue {\n        /// A property name.\n        property_name: &'a str,\n        /// A property value.\n        property_value: &'a str,\n    },\n}\n\nimpl<'a> ClassQuery<'a> {\n    fn canonicalize(&self) -> Result<CanonicalClassQuery> {\n        match *self {\n            ClassQuery::OneLetter(c) => self.canonical_binary(&c.to_string()),\n            ClassQuery::Binary(name) => self.canonical_binary(name),\n            ClassQuery::ByValue { property_name, property_value } => {\n                let property_name = symbolic_name_normalize(property_name);\n                let property_value = symbolic_name_normalize(property_value);\n\n                let canon_name = match canonical_prop(&property_name)? {\n                    None => return Err(Error::PropertyNotFound),\n                    Some(canon_name) => canon_name,\n                };\n                Ok(match canon_name {\n                    \"General_Category\" => {\n                        let canon = match canonical_gencat(&property_value)? {\n                            None => return Err(Error::PropertyValueNotFound),\n                            Some(canon) => canon,\n                        };\n                        CanonicalClassQuery::GeneralCategory(canon)\n                    }\n                    \"Script\" => {\n                        let canon = match canonical_script(&property_value)? {\n                            None => return Err(Error::PropertyValueNotFound),\n                            Some(canon) => canon,\n                        };\n                        CanonicalClassQuery::Script(canon)\n                    }\n                    _ => {\n                        let vals = match property_values(canon_name)? {\n                            None => return Err(Error::PropertyValueNotFound),\n                            Some(vals) => vals,\n                        };\n                        let canon_val =\n                            match canonical_value(vals, &property_value) {\n                                None => {\n                                    return Err(Error::PropertyValueNotFound)\n                                }\n                                Some(canon_val) => canon_val,\n                            };\n                        CanonicalClassQuery::ByValue {\n                            property_name: canon_name,\n                            property_value: canon_val,\n                        }\n                    }\n                })\n            }\n        }\n    }\n\n    fn canonical_binary(&self, name: &str) -> Result<CanonicalClassQuery> {\n        let norm = symbolic_name_normalize(name);\n\n        if let Some(canon) = canonical_prop(&norm)? {\n            return Ok(CanonicalClassQuery::Binary(canon));\n        }\n        if let Some(canon) = canonical_gencat(&norm)? {\n            return Ok(CanonicalClassQuery::GeneralCategory(canon));\n        }\n        if let Some(canon) = canonical_script(&norm)? {\n            return Ok(CanonicalClassQuery::Script(canon));\n        }\n        Err(Error::PropertyNotFound)\n    }\n}\n\n/// Like ClassQuery, but its parameters have been canonicalized. This also\n/// differentiates binary properties from flattened general categories and\n/// scripts.\n#[derive(Debug, Eq, PartialEq)]\nenum CanonicalClassQuery {\n    /// The canonical binary property name.\n    Binary(&'static str),\n    /// The canonical general category name.\n    GeneralCategory(&'static str),\n    /// The canonical script name.\n    Script(&'static str),\n    /// An arbitrary association between property and value, both of which\n    /// have been canonicalized.\n    ///\n    /// Note that by construction, the property name of ByValue will never\n    /// be General_Category or Script. Those two cases are subsumed by the\n    /// eponymous variants.\n    ByValue {\n        /// The canonical property name.\n        property_name: &'static str,\n        /// The canonical property value.\n        property_value: &'static str,\n    },\n}\n\n/// Looks up a Unicode class given a query. If one doesn't exist, then\n/// `None` is returned.\npub fn class(query: ClassQuery) -> Result<hir::ClassUnicode> {\n    use self::CanonicalClassQuery::*;\n\n    match query.canonicalize()? {\n        Binary(name) => bool_property(name),\n        GeneralCategory(name) => gencat(name),\n        Script(name) => script(name),\n        ByValue { property_name: \"Age\", property_value } => {\n            let mut class = hir::ClassUnicode::empty();\n            for set in ages(property_value)? {\n                class.union(&hir_class(set));\n            }\n            Ok(class)\n        }\n        ByValue { property_name: \"Script_Extensions\", property_value } => {\n            script_extension(property_value)\n        }\n        ByValue {\n            property_name: \"Grapheme_Cluster_Break\",\n            property_value,\n        } => gcb(property_value),\n        ByValue { property_name: \"Sentence_Break\", property_value } => {\n            sb(property_value)\n        }\n        ByValue { property_name: \"Word_Break\", property_value } => {\n            wb(property_value)\n        }\n        _ => {\n            // What else should we support?\n            Err(Error::PropertyNotFound)\n        }\n    }\n}\n\n/// Returns a Unicode aware class for \\w.\n///\n/// This returns an error if the data is not available for \\w.\npub fn perl_word() -> Result<hir::ClassUnicode> {\n    #[cfg(not(feature = \"unicode-perl\"))]\n    fn imp() -> Result<hir::ClassUnicode> {\n        Err(Error::PerlClassNotFound)\n    }\n\n    #[cfg(feature = \"unicode-perl\")]\n    fn imp() -> Result<hir::ClassUnicode> {\n        use unicode_tables::perl_word::PERL_WORD;\n        Ok(hir_class(PERL_WORD))\n    }\n\n    imp()\n}\n\n/// Returns a Unicode aware class for \\s.\n///\n/// This returns an error if the data is not available for \\s.\npub fn perl_space() -> Result<hir::ClassUnicode> {\n    #[cfg(not(any(feature = \"unicode-perl\", feature = \"unicode-bool\")))]\n    fn imp() -> Result<hir::ClassUnicode> {\n        Err(Error::PerlClassNotFound)\n    }\n\n    #[cfg(all(feature = \"unicode-perl\", not(feature = \"unicode-bool\")))]\n    fn imp() -> Result<hir::ClassUnicode> {\n        use unicode_tables::perl_space::WHITE_SPACE;\n        Ok(hir_class(WHITE_SPACE))\n    }\n\n    #[cfg(feature = \"unicode-bool\")]\n    fn imp() -> Result<hir::ClassUnicode> {\n        use unicode_tables::property_bool::WHITE_SPACE;\n        Ok(hir_class(WHITE_SPACE))\n    }\n\n    imp()\n}\n\n/// Returns a Unicode aware class for \\d.\n///\n/// This returns an error if the data is not available for \\d.\npub fn perl_digit() -> Result<hir::ClassUnicode> {\n    #[cfg(not(any(feature = \"unicode-perl\", feature = \"unicode-gencat\")))]\n    fn imp() -> Result<hir::ClassUnicode> {\n        Err(Error::PerlClassNotFound)\n    }\n\n    #[cfg(all(feature = \"unicode-perl\", not(feature = \"unicode-gencat\")))]\n    fn imp() -> Result<hir::ClassUnicode> {\n        use unicode_tables::perl_decimal::DECIMAL_NUMBER;\n        Ok(hir_class(DECIMAL_NUMBER))\n    }\n\n    #[cfg(feature = \"unicode-gencat\")]\n    fn imp() -> Result<hir::ClassUnicode> {\n        use unicode_tables::general_category::DECIMAL_NUMBER;\n        Ok(hir_class(DECIMAL_NUMBER))\n    }\n\n    imp()\n}\n\n/// Build a Unicode HIR class from a sequence of Unicode scalar value ranges.\npub fn hir_class(ranges: &[(char, char)]) -> hir::ClassUnicode {\n    let hir_ranges: Vec<hir::ClassUnicodeRange> = ranges\n        .iter()\n        .map(|&(s, e)| hir::ClassUnicodeRange::new(s, e))\n        .collect();\n    hir::ClassUnicode::new(hir_ranges)\n}\n\n/// Returns true only if the given codepoint is in the `\\w` character class.\n///\n/// If the `unicode-perl` feature is not enabled, then this returns an error.\npub fn is_word_character(c: char) -> result::Result<bool, UnicodeWordError> {\n    #[cfg(not(feature = \"unicode-perl\"))]\n    fn imp(_: char) -> result::Result<bool, UnicodeWordError> {\n        Err(UnicodeWordError(()))\n    }\n\n    #[cfg(feature = \"unicode-perl\")]\n    fn imp(c: char) -> result::Result<bool, UnicodeWordError> {\n        use is_word_byte;\n        use std::cmp::Ordering;\n        use unicode_tables::perl_word::PERL_WORD;\n\n        if c <= 0x7F as char && is_word_byte(c as u8) {\n            return Ok(true);\n        }\n        Ok(PERL_WORD\n            .binary_search_by(|&(start, end)| {\n                if start <= c && c <= end {\n                    Ordering::Equal\n                } else if start > c {\n                    Ordering::Greater\n                } else {\n                    Ordering::Less\n                }\n            })\n            .is_ok())\n    }\n\n    imp(c)\n}\n\n/// A mapping of property values for a specific property.\n///\n/// The first element of each tuple is a normalized property value while the\n/// second element of each tuple is the corresponding canonical property\n/// value.\ntype PropertyValues = &'static [(&'static str, &'static str)];\n\nfn canonical_gencat(normalized_value: &str) -> Result<Option<&'static str>> {\n    Ok(match normalized_value {\n        \"any\" => Some(\"Any\"),\n        \"assigned\" => Some(\"Assigned\"),\n        \"ascii\" => Some(\"ASCII\"),\n        _ => {\n            let gencats = property_values(\"General_Category\")?.unwrap();\n            canonical_value(gencats, normalized_value)\n        }\n    })\n}\n\nfn canonical_script(normalized_value: &str) -> Result<Option<&'static str>> {\n    let scripts = property_values(\"Script\")?.unwrap();\n    Ok(canonical_value(scripts, normalized_value))\n}\n\n/// Find the canonical property name for the given normalized property name.\n///\n/// If no such property exists, then `None` is returned.\n///\n/// The normalized property name must have been normalized according to\n/// UAX44 LM3, which can be done using `symbolic_name_normalize`.\n///\n/// If the property names data is not available, then an error is returned.\nfn canonical_prop(normalized_name: &str) -> Result<Option<&'static str>> {\n    #[cfg(not(any(\n        feature = \"unicode-age\",\n        feature = \"unicode-bool\",\n        feature = \"unicode-gencat\",\n        feature = \"unicode-perl\",\n        feature = \"unicode-script\",\n        feature = \"unicode-segment\",\n    )))]\n    fn imp(_: &str) -> Result<Option<&'static str>> {\n        Err(Error::PropertyNotFound)\n    }\n\n    #[cfg(any(\n        feature = \"unicode-age\",\n        feature = \"unicode-bool\",\n        feature = \"unicode-gencat\",\n        feature = \"unicode-perl\",\n        feature = \"unicode-script\",\n        feature = \"unicode-segment\",\n    ))]\n    fn imp(name: &str) -> Result<Option<&'static str>> {\n        use unicode_tables::property_names::PROPERTY_NAMES;\n\n        Ok(PROPERTY_NAMES\n            .binary_search_by_key(&name, |&(n, _)| n)\n            .ok()\n            .map(|i| PROPERTY_NAMES[i].1))\n    }\n\n    imp(normalized_name)\n}\n\n/// Find the canonical property value for the given normalized property\n/// value.\n///\n/// The given property values should correspond to the values for the property\n/// under question, which can be found using `property_values`.\n///\n/// If no such property value exists, then `None` is returned.\n///\n/// The normalized property value must have been normalized according to\n/// UAX44 LM3, which can be done using `symbolic_name_normalize`.\nfn canonical_value(\n    vals: PropertyValues,\n    normalized_value: &str,\n) -> Option<&'static str> {\n    vals.binary_search_by_key(&normalized_value, |&(n, _)| n)\n        .ok()\n        .map(|i| vals[i].1)\n}\n\n/// Return the table of property values for the given property name.\n///\n/// If the property values data is not available, then an error is returned.\nfn property_values(\n    canonical_property_name: &'static str,\n) -> Result<Option<PropertyValues>> {\n    #[cfg(not(any(\n        feature = \"unicode-age\",\n        feature = \"unicode-bool\",\n        feature = \"unicode-gencat\",\n        feature = \"unicode-perl\",\n        feature = \"unicode-script\",\n        feature = \"unicode-segment\",\n    )))]\n    fn imp(_: &'static str) -> Result<Option<PropertyValues>> {\n        Err(Error::PropertyValueNotFound)\n    }\n\n    #[cfg(any(\n        feature = \"unicode-age\",\n        feature = \"unicode-bool\",\n        feature = \"unicode-gencat\",\n        feature = \"unicode-perl\",\n        feature = \"unicode-script\",\n        feature = \"unicode-segment\",\n    ))]\n    fn imp(name: &'static str) -> Result<Option<PropertyValues>> {\n        use unicode_tables::property_values::PROPERTY_VALUES;\n\n        Ok(PROPERTY_VALUES\n            .binary_search_by_key(&name, |&(n, _)| n)\n            .ok()\n            .map(|i| PROPERTY_VALUES[i].1))\n    }\n\n    imp(canonical_property_name)\n}\n\n// This is only used in some cases, but small enough to just let it be dead\n// instead of figuring out (and maintaining) the right set of features.\n#[allow(dead_code)]\nfn property_set(\n    name_map: &'static [(&'static str, Range)],\n    canonical: &'static str,\n) -> Option<Range> {\n    name_map\n        .binary_search_by_key(&canonical, |x| x.0)\n        .ok()\n        .map(|i| name_map[i].1)\n}\n\n/// Returns an iterator over Unicode Age sets. Each item corresponds to a set\n/// of codepoints that were added in a particular revision of Unicode. The\n/// iterator yields items in chronological order.\n///\n/// If the given age value isn't valid or if the data isn't available, then an\n/// error is returned instead.\nfn ages(canonical_age: &str) -> Result<impl Iterator<Item = Range>> {\n    #[cfg(not(feature = \"unicode-age\"))]\n    fn imp(_: &str) -> Result<impl Iterator<Item = Range>> {\n        use std::option::IntoIter;\n        Err::<IntoIter<Range>, _>(Error::PropertyNotFound)\n    }\n\n    #[cfg(feature = \"unicode-age\")]\n    fn imp(canonical_age: &str) -> Result<impl Iterator<Item = Range>> {\n        use unicode_tables::age;\n\n        const AGES: &'static [(&'static str, Range)] = &[\n            (\"V1_1\", age::V1_1),\n            (\"V2_0\", age::V2_0),\n            (\"V2_1\", age::V2_1),\n            (\"V3_0\", age::V3_0),\n            (\"V3_1\", age::V3_1),\n            (\"V3_2\", age::V3_2),\n            (\"V4_0\", age::V4_0),\n            (\"V4_1\", age::V4_1),\n            (\"V5_0\", age::V5_0),\n            (\"V5_1\", age::V5_1),\n            (\"V5_2\", age::V5_2),\n            (\"V6_0\", age::V6_0),\n            (\"V6_1\", age::V6_1),\n            (\"V6_2\", age::V6_2),\n            (\"V6_3\", age::V6_3),\n            (\"V7_0\", age::V7_0),\n            (\"V8_0\", age::V8_0),\n            (\"V9_0\", age::V9_0),\n            (\"V10_0\", age::V10_0),\n            (\"V11_0\", age::V11_0),\n            (\"V12_0\", age::V12_0),\n            (\"V12_1\", age::V12_1),\n            (\"V13_0\", age::V13_0),\n        ];\n        assert_eq!(AGES.len(), age::BY_NAME.len(), \"ages are out of sync\");\n\n        let pos = AGES.iter().position(|&(age, _)| canonical_age == age);\n        match pos {\n            None => Err(Error::PropertyValueNotFound),\n            Some(i) => Ok(AGES[..i + 1].iter().map(|&(_, classes)| classes)),\n        }\n    }\n\n    imp(canonical_age)\n}\n\n/// Returns the Unicode HIR class corresponding to the given general category.\n///\n/// Name canonicalization is assumed to be performed by the caller.\n///\n/// If the given general category could not be found, or if the general\n/// category data is not available, then an error is returned.\nfn gencat(canonical_name: &'static str) -> Result<hir::ClassUnicode> {\n    #[cfg(not(feature = \"unicode-gencat\"))]\n    fn imp(_: &'static str) -> Result<hir::ClassUnicode> {\n        Err(Error::PropertyNotFound)\n    }\n\n    #[cfg(feature = \"unicode-gencat\")]\n    fn imp(name: &'static str) -> Result<hir::ClassUnicode> {\n        use unicode_tables::general_category::BY_NAME;\n        match name {\n            \"ASCII\" => Ok(hir_class(&[('\\0', '\\x7F')])),\n            \"Any\" => Ok(hir_class(&[('\\0', '\\u{10FFFF}')])),\n            \"Assigned\" => {\n                let mut cls = gencat(\"Unassigned\")?;\n                cls.negate();\n                Ok(cls)\n            }\n            name => property_set(BY_NAME, name)\n                .map(hir_class)\n                .ok_or(Error::PropertyValueNotFound),\n        }\n    }\n\n    match canonical_name {\n        \"Decimal_Number\" => perl_digit(),\n        name => imp(name),\n    }\n}\n\n/// Returns the Unicode HIR class corresponding to the given script.\n///\n/// Name canonicalization is assumed to be performed by the caller.\n///\n/// If the given script could not be found, or if the script data is not\n/// available, then an error is returned.\nfn script(canonical_name: &'static str) -> Result<hir::ClassUnicode> {\n    #[cfg(not(feature = \"unicode-script\"))]\n    fn imp(_: &'static str) -> Result<hir::ClassUnicode> {\n        Err(Error::PropertyNotFound)\n    }\n\n    #[cfg(feature = \"unicode-script\")]\n    fn imp(name: &'static str) -> Result<hir::ClassUnicode> {\n        use unicode_tables::script::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyValueNotFound)\n    }\n\n    imp(canonical_name)\n}\n\n/// Returns the Unicode HIR class corresponding to the given script extension.\n///\n/// Name canonicalization is assumed to be performed by the caller.\n///\n/// If the given script extension could not be found, or if the script data is\n/// not available, then an error is returned.\nfn script_extension(\n    canonical_name: &'static str,\n) -> Result<hir::ClassUnicode> {\n    #[cfg(not(feature = \"unicode-script\"))]\n    fn imp(_: &'static str) -> Result<hir::ClassUnicode> {\n        Err(Error::PropertyNotFound)\n    }\n\n    #[cfg(feature = \"unicode-script\")]\n    fn imp(name: &'static str) -> Result<hir::ClassUnicode> {\n        use unicode_tables::script_extension::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyValueNotFound)\n    }\n\n    imp(canonical_name)\n}\n\n/// Returns the Unicode HIR class corresponding to the given Unicode boolean\n/// property.\n///\n/// Name canonicalization is assumed to be performed by the caller.\n///\n/// If the given boolean property could not be found, or if the boolean\n/// property data is not available, then an error is returned.\nfn bool_property(canonical_name: &'static str) -> Result<hir::ClassUnicode> {\n    #[cfg(not(feature = \"unicode-bool\"))]\n    fn imp(_: &'static str) -> Result<hir::ClassUnicode> {\n        Err(Error::PropertyNotFound)\n    }\n\n    #[cfg(feature = \"unicode-bool\")]\n    fn imp(name: &'static str) -> Result<hir::ClassUnicode> {\n        use unicode_tables::property_bool::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyNotFound)\n    }\n\n    match canonical_name {\n        \"Decimal_Number\" => perl_digit(),\n        \"White_Space\" => perl_space(),\n        name => imp(name),\n    }\n}\n\n/// Returns the Unicode HIR class corresponding to the given grapheme cluster\n/// break property.\n///\n/// Name canonicalization is assumed to be performed by the caller.\n///\n/// If the given property could not be found, or if the corresponding data is\n/// not available, then an error is returned.\nfn gcb(canonical_name: &'static str) -> Result<hir::ClassUnicode> {\n    #[cfg(not(feature = \"unicode-segment\"))]\n    fn imp(_: &'static str) -> Result<hir::ClassUnicode> {\n        Err(Error::PropertyNotFound)\n    }\n\n    #[cfg(feature = \"unicode-segment\")]\n    fn imp(name: &'static str) -> Result<hir::ClassUnicode> {\n        use unicode_tables::grapheme_cluster_break::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyValueNotFound)\n    }\n\n    imp(canonical_name)\n}\n\n/// Returns the Unicode HIR class corresponding to the given word break\n/// property.\n///\n/// Name canonicalization is assumed to be performed by the caller.\n///\n/// If the given property could not be found, or if the corresponding data is\n/// not available, then an error is returned.\nfn wb(canonical_name: &'static str) -> Result<hir::ClassUnicode> {\n    #[cfg(not(feature = \"unicode-segment\"))]\n    fn imp(_: &'static str) -> Result<hir::ClassUnicode> {\n        Err(Error::PropertyNotFound)\n    }\n\n    #[cfg(feature = \"unicode-segment\")]\n    fn imp(name: &'static str) -> Result<hir::ClassUnicode> {\n        use unicode_tables::word_break::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyValueNotFound)\n    }\n\n    imp(canonical_name)\n}\n\n/// Returns the Unicode HIR class corresponding to the given sentence\n/// break property.\n///\n/// Name canonicalization is assumed to be performed by the caller.\n///\n/// If the given property could not be found, or if the corresponding data is\n/// not available, then an error is returned.\nfn sb(canonical_name: &'static str) -> Result<hir::ClassUnicode> {\n    #[cfg(not(feature = \"unicode-segment\"))]\n    fn imp(_: &'static str) -> Result<hir::ClassUnicode> {\n        Err(Error::PropertyNotFound)\n    }\n\n    #[cfg(feature = \"unicode-segment\")]\n    fn imp(name: &'static str) -> Result<hir::ClassUnicode> {\n        use unicode_tables::sentence_break::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyValueNotFound)\n    }\n\n    imp(canonical_name)\n}\n\n/// Like symbolic_name_normalize_bytes, but operates on a string.\nfn symbolic_name_normalize(x: &str) -> String {\n    let mut tmp = x.as_bytes().to_vec();\n    let len = symbolic_name_normalize_bytes(&mut tmp).len();\n    tmp.truncate(len);\n    // This should always succeed because `symbolic_name_normalize_bytes`\n    // guarantees that `&tmp[..len]` is always valid UTF-8.\n    //\n    // N.B. We could avoid the additional UTF-8 check here, but it's unlikely\n    // to be worth skipping the additional safety check. A benchmark must\n    // justify it first.\n    String::from_utf8(tmp).unwrap()\n}\n\n/// Normalize the given symbolic name in place according to UAX44-LM3.\n///\n/// A \"symbolic name\" typically corresponds to property names and property\n/// value aliases. Note, though, that it should not be applied to property\n/// string values.\n///\n/// The slice returned is guaranteed to be valid UTF-8 for all possible values\n/// of `slice`.\n///\n/// See: http://unicode.org/reports/tr44/#UAX44-LM3\nfn symbolic_name_normalize_bytes(slice: &mut [u8]) -> &mut [u8] {\n    // I couldn't find a place in the standard that specified that property\n    // names/aliases had a particular structure (unlike character names), but\n    // we assume that it's ASCII only and drop anything that isn't ASCII.\n    let mut start = 0;\n    let mut starts_with_is = false;\n    if slice.len() >= 2 {\n        // Ignore any \"is\" prefix.\n        starts_with_is = slice[0..2] == b\"is\"[..]\n            || slice[0..2] == b\"IS\"[..]\n            || slice[0..2] == b\"iS\"[..]\n            || slice[0..2] == b\"Is\"[..];\n        if starts_with_is {\n            start = 2;\n        }\n    }\n    let mut next_write = 0;\n    for i in start..slice.len() {\n        // VALIDITY ARGUMENT: To guarantee that the resulting slice is valid\n        // UTF-8, we ensure that the slice contains only ASCII bytes. In\n        // particular, we drop every non-ASCII byte from the normalized string.\n        let b = slice[i];\n        if b == b' ' || b == b'_' || b == b'-' {\n            continue;\n        } else if b'A' <= b && b <= b'Z' {\n            slice[next_write] = b + (b'a' - b'A');\n            next_write += 1;\n        } else if b <= 0x7F {\n            slice[next_write] = b;\n            next_write += 1;\n        }\n    }\n    // Special case: ISO_Comment has a 'isc' abbreviation. Since we generally\n    // ignore 'is' prefixes, the 'isc' abbreviation gets caught in the cross\n    // fire and ends up creating an alias for 'c' to 'ISO_Comment', but it\n    // is actually an alias for the 'Other' general category.\n    if starts_with_is && next_write == 1 && slice[0] == b'c' {\n        slice[0] = b'i';\n        slice[1] = b's';\n        slice[2] = b'c';\n        next_write = 3;\n    }\n    &mut slice[..next_write]\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{\n        contains_simple_case_mapping, simple_fold, symbolic_name_normalize,\n        symbolic_name_normalize_bytes,\n    };\n\n    #[cfg(feature = \"unicode-case\")]\n    fn simple_fold_ok(c: char) -> impl Iterator<Item = char> {\n        simple_fold(c).unwrap().unwrap()\n    }\n\n    #[cfg(feature = \"unicode-case\")]\n    fn simple_fold_err(c: char) -> Option<char> {\n        match simple_fold(c).unwrap() {\n            Ok(_) => unreachable!(\"simple_fold returned Ok iterator\"),\n            Err(next) => next,\n        }\n    }\n\n    #[cfg(feature = \"unicode-case\")]\n    fn contains_case_map(start: char, end: char) -> bool {\n        contains_simple_case_mapping(start, end).unwrap()\n    }\n\n    #[test]\n    #[cfg(feature = \"unicode-case\")]\n    fn simple_fold_k() {\n        let xs: Vec<char> = simple_fold_ok('k').collect();\n        assert_eq!(xs, vec!['K', 'K']);\n\n        let xs: Vec<char> = simple_fold_ok('K').collect();\n        assert_eq!(xs, vec!['k', 'K']);\n\n        let xs: Vec<char> = simple_fold_ok('K').collect();\n        assert_eq!(xs, vec!['K', 'k']);\n    }\n\n    #[test]\n    #[cfg(feature = \"unicode-case\")]\n    fn simple_fold_a() {\n        let xs: Vec<char> = simple_fold_ok('a').collect();\n        assert_eq!(xs, vec!['A']);\n\n        let xs: Vec<char> = simple_fold_ok('A').collect();\n        assert_eq!(xs, vec!['a']);\n    }\n\n    #[test]\n    #[cfg(feature = \"unicode-case\")]\n    fn simple_fold_empty() {\n        assert_eq!(Some('A'), simple_fold_err('?'));\n        assert_eq!(Some('A'), simple_fold_err('@'));\n        assert_eq!(Some('a'), simple_fold_err('['));\n        assert_eq!(Some('Ⰰ'), simple_fold_err('☃'));\n    }\n\n    #[test]\n    #[cfg(feature = \"unicode-case\")]\n    fn simple_fold_max() {\n        assert_eq!(None, simple_fold_err('\\u{10FFFE}'));\n        assert_eq!(None, simple_fold_err('\\u{10FFFF}'));\n    }\n\n    #[test]\n    #[cfg(not(feature = \"unicode-case\"))]\n    fn simple_fold_disabled() {\n        assert!(simple_fold('a').is_err());\n    }\n\n    #[test]\n    #[cfg(feature = \"unicode-case\")]\n    fn range_contains() {\n        assert!(contains_case_map('A', 'A'));\n        assert!(contains_case_map('Z', 'Z'));\n        assert!(contains_case_map('A', 'Z'));\n        assert!(contains_case_map('@', 'A'));\n        assert!(contains_case_map('Z', '['));\n        assert!(contains_case_map('☃', 'Ⰰ'));\n\n        assert!(!contains_case_map('[', '['));\n        assert!(!contains_case_map('[', '`'));\n\n        assert!(!contains_case_map('☃', '☃'));\n    }\n\n    #[test]\n    #[cfg(not(feature = \"unicode-case\"))]\n    fn range_contains_disabled() {\n        assert!(contains_simple_case_mapping('a', 'a').is_err());\n    }\n\n    #[test]\n    #[cfg(feature = \"unicode-gencat\")]\n    fn regression_466() {\n        use super::{CanonicalClassQuery, ClassQuery};\n\n        let q = ClassQuery::OneLetter('C');\n        assert_eq!(\n            q.canonicalize().unwrap(),\n            CanonicalClassQuery::GeneralCategory(\"Other\")\n        );\n    }\n\n    #[test]\n    fn sym_normalize() {\n        let sym_norm = symbolic_name_normalize;\n\n        assert_eq!(sym_norm(\"Line_Break\"), \"linebreak\");\n        assert_eq!(sym_norm(\"Line-break\"), \"linebreak\");\n        assert_eq!(sym_norm(\"linebreak\"), \"linebreak\");\n        assert_eq!(sym_norm(\"BA\"), \"ba\");\n        assert_eq!(sym_norm(\"ba\"), \"ba\");\n        assert_eq!(sym_norm(\"Greek\"), \"greek\");\n        assert_eq!(sym_norm(\"isGreek\"), \"greek\");\n        assert_eq!(sym_norm(\"IS_Greek\"), \"greek\");\n        assert_eq!(sym_norm(\"isc\"), \"isc\");\n        assert_eq!(sym_norm(\"is c\"), \"isc\");\n        assert_eq!(sym_norm(\"is_c\"), \"isc\");\n    }\n\n    #[test]\n    fn valid_utf8_symbolic() {\n        let mut x = b\"abc\\xFFxyz\".to_vec();\n        let y = symbolic_name_normalize_bytes(&mut x);\n        assert_eq!(y, b\"abcxyz\");\n    }\n}\n","traces":[{"line":41,"address":[7063824],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":42,"address":[7063850],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[7063936],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":62,"address":[7063962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[7064048],"length":1,"stats":{"Line":8},"fn_name":"simple_fold"},{"line":94,"address":[7064080],"length":1,"stats":{"Line":8},"fn_name":"imp"},{"line":100,"address":[7064091],"length":1,"stats":{"Line":8},"fn_name":null},{"line":101,"address":[6536477,6536464],"length":1,"stats":{"Line":16},"fn_name":"{{closure}}"},{"line":102,"address":[6536537,6536509,6536496,6536528],"length":1,"stats":{"Line":32},"fn_name":"{{closure}}"},{"line":103,"address":[6536688],"length":1,"stats":{"Line":8},"fn_name":"{{closure}}"},{"line":104,"address":[6536787,6536697],"length":1,"stats":{"Line":8},"fn_name":null},{"line":105,"address":[6536779],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[6536745,6536824,6536852,6536794],"length":1,"stats":{"Line":16},"fn_name":null},{"line":112,"address":[7064064],"length":1,"stats":{"Line":8},"fn_name":null},{"line":122,"address":[7064224],"length":1,"stats":{"Line":8},"fn_name":"contains_simple_case_mapping"},{"line":132,"address":[7064256],"length":1,"stats":{"Line":8},"fn_name":"imp"},{"line":136,"address":[7064268,7064352],"length":1,"stats":{"Line":8},"fn_name":null},{"line":137,"address":[7064287,7064321,7064382],"length":1,"stats":{"Line":24},"fn_name":null},{"line":138,"address":[6536878,6536864],"length":1,"stats":{"Line":24},"fn_name":"{{closure}}"},{"line":139,"address":[6536980,6536884,6536966],"length":1,"stats":{"Line":24},"fn_name":null},{"line":140,"address":[6536961],"length":1,"stats":{"Line":8},"fn_name":null},{"line":141,"address":[6536947,6536973],"length":1,"stats":{"Line":16},"fn_name":null},{"line":142,"address":[6536975],"length":1,"stats":{"Line":8},"fn_name":null},{"line":144,"address":[6536968],"length":1,"stats":{"Line":8},"fn_name":null},{"line":150,"address":[7064236],"length":1,"stats":{"Line":8},"fn_name":null},{"line":188,"address":[7064503,7064416],"length":1,"stats":{"Line":8},"fn_name":"canonicalize"},{"line":189,"address":[7064614,7064831,7064759,7066761],"length":1,"stats":{"Line":40},"fn_name":null},{"line":190,"address":[7064434,7064624],"length":1,"stats":{"Line":22},"fn_name":null},{"line":191,"address":[7064772],"length":1,"stats":{"Line":8},"fn_name":null},{"line":192,"address":[7064526],"length":1,"stats":{"Line":11},"fn_name":null},{"line":193,"address":[7064574],"length":1,"stats":{"Line":13},"fn_name":null},{"line":194,"address":[7064860],"length":1,"stats":{"Line":8},"fn_name":null},{"line":196,"address":[7065208,7065310,7064875,7064941,7064964,7065087,7065149],"length":1,"stats":{"Line":38},"fn_name":null},{"line":197,"address":[7065312,7065058],"length":1,"stats":{"Line":13},"fn_name":null},{"line":198,"address":[7065210],"length":1,"stats":{"Line":15},"fn_name":null},{"line":200,"address":[7065751,7066107,7066681,7066643],"length":1,"stats":{"Line":39},"fn_name":null},{"line":201,"address":[7065350,7065258],"length":1,"stats":{"Line":32},"fn_name":null},{"line":202,"address":[7065604,7065756,7065439],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[7065575,7065758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[7065675],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[7065723],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[7065356],"length":1,"stats":{"Line":17},"fn_name":null},{"line":209,"address":[7066112,7065797,7065962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[7065933,7066114],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[7066031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[7066079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[7066145,7066268,7065421,7066422],"length":1,"stats":{"Line":36},"fn_name":null},{"line":217,"address":[7066424,7066239],"length":1,"stats":{"Line":19},"fn_name":null},{"line":218,"address":[7066339],"length":1,"stats":{"Line":18},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[7066475,7066405,7066645],"length":1,"stats":{"Line":37},"fn_name":null},{"line":222,"address":[7066516],"length":1,"stats":{"Line":20},"fn_name":null},{"line":223,"address":[7066647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[7066541],"length":1,"stats":{"Line":18},"fn_name":null},{"line":227,"address":[7066594],"length":1,"stats":{"Line":21},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[7066897,7066832],"length":1,"stats":{"Line":8},"fn_name":"canonical_binary"},{"line":238,"address":[7066866],"length":1,"stats":{"Line":8},"fn_name":null},{"line":240,"address":[7067177,7066917,7066972,7067143,7067201],"length":1,"stats":{"Line":32},"fn_name":null},{"line":241,"address":[7067230],"length":1,"stats":{"Line":8},"fn_name":null},{"line":243,"address":[7067543,7067324,7067184],"length":1,"stats":{"Line":24},"fn_name":null},{"line":244,"address":[7067575],"length":1,"stats":{"Line":8},"fn_name":null},{"line":246,"address":[7067669,7067905,7067526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[7067937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[7067866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[7068086,7068048],"length":1,"stats":{"Line":8},"fn_name":"class"},{"line":283,"address":[7068058,7068279,7068658,7068705,7069237,7068752,7069494,7068332,7068611,7069444,7069541,7069588,7068101],"length":1,"stats":{"Line":70},"fn_name":null},{"line":284,"address":[7068616,7068235],"length":1,"stats":{"Line":16},"fn_name":null},{"line":285,"address":[7068663],"length":1,"stats":{"Line":8},"fn_name":null},{"line":286,"address":[7068710],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[7068757,7068352],"length":1,"stats":{"Line":21},"fn_name":null},{"line":288,"address":[7068786],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[7069394,7068881,7069032,7069242,7068828],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[7069316],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[7069145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[7068400,7069399],"length":1,"stats":{"Line":16},"fn_name":null},{"line":295,"address":[7069433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[7068448],"length":1,"stats":{"Line":21},"fn_name":null},{"line":299,"address":[7069449],"length":1,"stats":{"Line":17},"fn_name":null},{"line":300,"address":[7069483],"length":1,"stats":{"Line":22},"fn_name":null},{"line":301,"address":[7069496,7068496],"length":1,"stats":{"Line":21},"fn_name":null},{"line":302,"address":[7069530],"length":1,"stats":{"Line":12},"fn_name":null},{"line":304,"address":[7069543,7068544],"length":1,"stats":{"Line":18},"fn_name":null},{"line":305,"address":[7069577],"length":1,"stats":{"Line":9},"fn_name":null},{"line":309,"address":[7068585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[7069648],"length":1,"stats":{"Line":8},"fn_name":"perl_word"},{"line":324,"address":[7069680],"length":1,"stats":{"Line":9},"fn_name":"imp"},{"line":326,"address":[7069687],"length":1,"stats":{"Line":9},"fn_name":null},{"line":329,"address":[7069656],"length":1,"stats":{"Line":8},"fn_name":null},{"line":335,"address":[7069776],"length":1,"stats":{"Line":8},"fn_name":"perl_space"},{"line":348,"address":[7069808],"length":1,"stats":{"Line":8},"fn_name":"imp"},{"line":350,"address":[7069815],"length":1,"stats":{"Line":8},"fn_name":null},{"line":353,"address":[7069784],"length":1,"stats":{"Line":8},"fn_name":null},{"line":359,"address":[7069904],"length":1,"stats":{"Line":12},"fn_name":"perl_digit"},{"line":372,"address":[7069936],"length":1,"stats":{"Line":12},"fn_name":"imp"},{"line":374,"address":[7069943],"length":1,"stats":{"Line":13},"fn_name":null},{"line":377,"address":[7069912],"length":1,"stats":{"Line":12},"fn_name":null},{"line":381,"address":[7070032],"length":1,"stats":{"Line":8},"fn_name":"hir_class"},{"line":382,"address":[7070054],"length":1,"stats":{"Line":8},"fn_name":null},{"line":384,"address":[6536992,6537006],"length":1,"stats":{"Line":16},"fn_name":"{{closure}}"},{"line":386,"address":[7070128],"length":1,"stats":{"Line":8},"fn_name":null},{"line":392,"address":[7070192],"length":1,"stats":{"Line":8},"fn_name":"is_word_character"},{"line":399,"address":[7070224],"length":1,"stats":{"Line":8},"fn_name":"imp"},{"line":404,"address":[7070232],"length":1,"stats":{"Line":8},"fn_name":null},{"line":405,"address":[7070343],"length":1,"stats":{"Line":8},"fn_name":null},{"line":407,"address":[7070317,7070293,7070357],"length":1,"stats":{"Line":25},"fn_name":null},{"line":408,"address":[6537070,6537056],"length":1,"stats":{"Line":26},"fn_name":"{{closure}}"},{"line":409,"address":[6537083,6537179,6537165],"length":1,"stats":{"Line":28},"fn_name":null},{"line":410,"address":[6537160],"length":1,"stats":{"Line":10},"fn_name":null},{"line":411,"address":[6537172,6537147],"length":1,"stats":{"Line":19},"fn_name":null},{"line":412,"address":[6537174],"length":1,"stats":{"Line":9},"fn_name":null},{"line":414,"address":[6537167],"length":1,"stats":{"Line":9},"fn_name":null},{"line":420,"address":[7070197],"length":1,"stats":{"Line":8},"fn_name":null},{"line":430,"address":[7070384],"length":1,"stats":{"Line":8},"fn_name":"canonical_gencat"},{"line":431,"address":[7070867,7070606,7070632,7070658],"length":1,"stats":{"Line":8},"fn_name":null},{"line":432,"address":[7070592,7070422],"length":1,"stats":{"Line":8},"fn_name":null},{"line":433,"address":[7070618,7070487],"length":1,"stats":{"Line":8},"fn_name":null},{"line":434,"address":[7070644,7070531],"length":1,"stats":{"Line":8},"fn_name":null},{"line":436,"address":[7070663,7070821,7070565],"length":1,"stats":{"Line":16},"fn_name":null},{"line":437,"address":[7070852],"length":1,"stats":{"Line":8},"fn_name":null},{"line":442,"address":[7070912],"length":1,"stats":{"Line":0},"fn_name":"canonical_script"},{"line":443,"address":[7070945,7071147],"length":1,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[7071178],"length":1,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[7071232],"length":1,"stats":{"Line":8},"fn_name":"canonical_prop"},{"line":476,"address":[7071280],"length":1,"stats":{"Line":8},"fn_name":"imp"},{"line":479,"address":[7071297],"length":1,"stats":{"Line":8},"fn_name":null},{"line":480,"address":[6537200,6537213],"length":1,"stats":{"Line":16},"fn_name":"{{closure}}"},{"line":482,"address":[6537257,6537248],"length":1,"stats":{"Line":25},"fn_name":"{{closure}}"},{"line":485,"address":[7071253],"length":1,"stats":{"Line":8},"fn_name":null},{"line":498,"address":[7071440],"length":1,"stats":{"Line":8},"fn_name":"canonical_value"},{"line":502,"address":[6537360,6537373],"length":1,"stats":{"Line":32},"fn_name":"{{closure}}"},{"line":504,"address":[6537422,6537408],"length":1,"stats":{"Line":24},"fn_name":"{{closure}}"},{"line":510,"address":[7071584],"length":1,"stats":{"Line":8},"fn_name":"property_values"},{"line":533,"address":[7071632],"length":1,"stats":{"Line":8},"fn_name":"imp"},{"line":536,"address":[7071649],"length":1,"stats":{"Line":8},"fn_name":null},{"line":537,"address":[6537533,6537520],"length":1,"stats":{"Line":16},"fn_name":"{{closure}}"},{"line":539,"address":[6537568,6537577],"length":1,"stats":{"Line":16},"fn_name":"{{closure}}"},{"line":542,"address":[7071605],"length":1,"stats":{"Line":8},"fn_name":null},{"line":548,"address":[7071792],"length":1,"stats":{"Line":8},"fn_name":"property_set"},{"line":552,"address":[7071816,7071883],"length":1,"stats":{"Line":16},"fn_name":null},{"line":553,"address":[6537680,6537693],"length":1,"stats":{"Line":16},"fn_name":"{{closure}}"},{"line":555,"address":[6537712,6537726],"length":1,"stats":{"Line":24},"fn_name":"{{closure}}"},{"line":564,"address":[7071936],"length":1,"stats":{"Line":0},"fn_name":"ages"},{"line":572,"address":[7071984],"length":1,"stats":{"Line":0},"fn_name":"imp"},{"line":600,"address":[7072010,7072234],"length":1,"stats":{"Line":0},"fn_name":null},{"line":602,"address":[6537824,6537838],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":603,"address":[7072814,7072845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[7072734,7072816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[6537888,6537901],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":609,"address":[7071957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":618,"address":[7073024],"length":1,"stats":{"Line":8},"fn_name":"gencat"},{"line":625,"address":[7073246,7073168],"length":1,"stats":{"Line":8},"fn_name":"imp"},{"line":627,"address":[7073559,7073494,7073891,7073955],"length":1,"stats":{"Line":8},"fn_name":null},{"line":628,"address":[7073434,7073206,7073265],"length":1,"stats":{"Line":16},"fn_name":null},{"line":629,"address":[7073499,7073292],"length":1,"stats":{"Line":8},"fn_name":null},{"line":630,"address":[7073340],"length":1,"stats":{"Line":8},"fn_name":null},{"line":631,"address":[7073571,7073768,7073715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":632,"address":[7073699],"length":1,"stats":{"Line":0},"fn_name":null},{"line":633,"address":[7073805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":635,"address":[7073376,7073933,7073896],"length":1,"stats":{"Line":24},"fn_name":null},{"line":637,"address":[7073920],"length":1,"stats":{"Line":8},"fn_name":null},{"line":641,"address":[7073151],"length":1,"stats":{"Line":8},"fn_name":null},{"line":642,"address":[7073053,7073144],"length":1,"stats":{"Line":16},"fn_name":null},{"line":643,"address":[7073106],"length":1,"stats":{"Line":8},"fn_name":null},{"line":653,"address":[7074000],"length":1,"stats":{"Line":0},"fn_name":"script"},{"line":660,"address":[7074048],"length":1,"stats":{"Line":0},"fn_name":"imp"},{"line":662,"address":[7074065,7074164],"length":1,"stats":{"Line":0},"fn_name":null},{"line":664,"address":[7074154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[7074021],"length":1,"stats":{"Line":0},"fn_name":null},{"line":676,"address":[7074192],"length":1,"stats":{"Line":0},"fn_name":"script_extension"},{"line":685,"address":[7074240],"length":1,"stats":{"Line":0},"fn_name":"imp"},{"line":687,"address":[7074356,7074257],"length":1,"stats":{"Line":0},"fn_name":null},{"line":689,"address":[7074346],"length":1,"stats":{"Line":0},"fn_name":null},{"line":692,"address":[7074213],"length":1,"stats":{"Line":0},"fn_name":null},{"line":702,"address":[7074384],"length":1,"stats":{"Line":8},"fn_name":"bool_property"},{"line":709,"address":[7074592],"length":1,"stats":{"Line":8},"fn_name":"imp"},{"line":711,"address":[7074708,7074609],"length":1,"stats":{"Line":16},"fn_name":null},{"line":713,"address":[7074698],"length":1,"stats":{"Line":8},"fn_name":null},{"line":716,"address":[7074567],"length":1,"stats":{"Line":8},"fn_name":null},{"line":717,"address":[7074413,7074548],"length":1,"stats":{"Line":8},"fn_name":null},{"line":718,"address":[7074560,7074478],"length":1,"stats":{"Line":8},"fn_name":null},{"line":719,"address":[7074510],"length":1,"stats":{"Line":8},"fn_name":null},{"line":730,"address":[7074736],"length":1,"stats":{"Line":15},"fn_name":"gcb"},{"line":737,"address":[7074784],"length":1,"stats":{"Line":15},"fn_name":"imp"},{"line":739,"address":[7074801,7074900],"length":1,"stats":{"Line":34},"fn_name":null},{"line":741,"address":[7074890],"length":1,"stats":{"Line":11},"fn_name":null},{"line":744,"address":[7074757],"length":1,"stats":{"Line":22},"fn_name":null},{"line":754,"address":[7074928],"length":1,"stats":{"Line":9},"fn_name":"wb"},{"line":761,"address":[7074976],"length":1,"stats":{"Line":12},"fn_name":"imp"},{"line":763,"address":[7075092,7074993],"length":1,"stats":{"Line":25},"fn_name":null},{"line":765,"address":[7075082],"length":1,"stats":{"Line":13},"fn_name":null},{"line":768,"address":[7074949],"length":1,"stats":{"Line":10},"fn_name":null},{"line":778,"address":[7075120],"length":1,"stats":{"Line":13},"fn_name":"sb"},{"line":785,"address":[7075168],"length":1,"stats":{"Line":13},"fn_name":"imp"},{"line":787,"address":[7075185,7075284],"length":1,"stats":{"Line":26},"fn_name":null},{"line":789,"address":[7075274],"length":1,"stats":{"Line":13},"fn_name":null},{"line":792,"address":[7075141],"length":1,"stats":{"Line":13},"fn_name":null},{"line":796,"address":[7075416,7075312],"length":1,"stats":{"Line":8},"fn_name":"symbolic_name_normalize"},{"line":797,"address":[7075431,7075338,7075414],"length":1,"stats":{"Line":24},"fn_name":null},{"line":798,"address":[7075460],"length":1,"stats":{"Line":8},"fn_name":null},{"line":799,"address":[7075550],"length":1,"stats":{"Line":8},"fn_name":null},{"line":806,"address":[7075569],"length":1,"stats":{"Line":8},"fn_name":null},{"line":819,"address":[7075728],"length":1,"stats":{"Line":8},"fn_name":"symbolic_name_normalize_bytes"},{"line":823,"address":[7075751],"length":1,"stats":{"Line":8},"fn_name":null},{"line":824,"address":[7075763],"length":1,"stats":{"Line":8},"fn_name":null},{"line":825,"address":[7076683,7075787],"length":1,"stats":{"Line":16},"fn_name":null},{"line":827,"address":[7075819,7076262,7076143,7076005,7076472,7076658,7076574,7076040],"length":1,"stats":{"Line":56},"fn_name":null},{"line":828,"address":[7076390,7076182],"length":1,"stats":{"Line":16},"fn_name":null},{"line":829,"address":[7076492,7076060],"length":1,"stats":{"Line":16},"fn_name":null},{"line":830,"address":[7075922,7076594],"length":1,"stats":{"Line":16},"fn_name":null},{"line":831,"address":[7076021],"length":1,"stats":{"Line":8},"fn_name":null},{"line":832,"address":[7076671],"length":1,"stats":{"Line":0},"fn_name":null},{"line":835,"address":[7076685],"length":1,"stats":{"Line":8},"fn_name":null},{"line":836,"address":[7076697,7076890,7077379],"length":1,"stats":{"Line":16},"fn_name":null},{"line":840,"address":[7077722,7076932],"length":1,"stats":{"Line":8},"fn_name":null},{"line":841,"address":[7076976],"length":1,"stats":{"Line":8},"fn_name":null},{"line":842,"address":[7077083],"length":1,"stats":{"Line":8},"fn_name":null},{"line":843,"address":[7077271,7077088,7077071,7077377],"length":1,"stats":{"Line":32},"fn_name":null},{"line":844,"address":[7077149,7077753],"length":1,"stats":{"Line":8},"fn_name":null},{"line":845,"address":[7077224,7077814],"length":1,"stats":{"Line":8},"fn_name":null},{"line":846,"address":[7077132],"length":1,"stats":{"Line":8},"fn_name":null},{"line":847,"address":[7077273,7077844],"length":1,"stats":{"Line":8},"fn_name":null},{"line":848,"address":[7077330,7077875],"length":1,"stats":{"Line":8},"fn_name":null},{"line":855,"address":[7076871,7077384,7077905],"length":1,"stats":{"Line":8},"fn_name":null},{"line":856,"address":[7077935,7077521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":857,"address":[7077550,7077965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":858,"address":[7077996,7078027,7077593],"length":1,"stats":{"Line":0},"fn_name":null},{"line":859,"address":[7077636],"length":1,"stats":{"Line":0},"fn_name":null},{"line":861,"address":[7077648],"length":1,"stats":{"Line":8},"fn_name":null}],"covered":174,"coverable":233},{"path":["/","usr","src","regex","regex-syntax","src","utf8.rs"],"content":"/*!\nConverts ranges of Unicode scalar values to equivalent ranges of UTF-8 bytes.\n\nThis is sub-module is useful for constructing byte based automatons that need\nto embed UTF-8 decoding. The most common use of this module is in conjunction\nwith the [`hir::ClassUnicodeRange`](../hir/struct.ClassUnicodeRange.html) type.\n\nSee the documentation on the `Utf8Sequences` iterator for more details and\nan example.\n\n# Wait, what is this?\n\nThis is simplest to explain with an example. Let's say you wanted to test\nwhether a particular byte sequence was a Cyrillic character. One possible\nscalar value range is `[0400-04FF]`. The set of allowed bytes for this\nrange can be expressed as a sequence of byte ranges:\n\n```ignore\n[D0-D3][80-BF]\n```\n\nThis is simple enough: simply encode the boundaries, `0400` encodes to\n`D0 80` and `04FF` encodes to `D3 BF`, and create ranges from each\ncorresponding pair of bytes: `D0` to `D3` and `80` to `BF`.\n\nHowever, what if you wanted to add the Cyrillic Supplementary characters to\nyour range? Your range might then become `[0400-052F]`. The same procedure\nas above doesn't quite work because `052F` encodes to `D4 AF`. The byte ranges\nyou'd get from the previous transformation would be `[D0-D4][80-AF]`. However,\nthis isn't quite correct because this range doesn't capture many characters,\nfor example, `04FF` (because its last byte, `BF` isn't in the range `80-AF`).\n\nInstead, you need multiple sequences of byte ranges:\n\n```ignore\n[D0-D3][80-BF]  # matches codepoints 0400-04FF\n[D4][80-AF]     # matches codepoints 0500-052F\n```\n\nThis gets even more complicated if you want bigger ranges, particularly if\nthey naively contain surrogate codepoints. For example, the sequence of byte\nranges for the basic multilingual plane (`[0000-FFFF]`) look like this:\n\n```ignore\n[0-7F]\n[C2-DF][80-BF]\n[E0][A0-BF][80-BF]\n[E1-EC][80-BF][80-BF]\n[ED][80-9F][80-BF]\n[EE-EF][80-BF][80-BF]\n```\n\nNote that the byte ranges above will *not* match any erroneous encoding of\nUTF-8, including encodings of surrogate codepoints.\n\nAnd, of course, for all of Unicode (`[000000-10FFFF]`):\n\n```ignore\n[0-7F]\n[C2-DF][80-BF]\n[E0][A0-BF][80-BF]\n[E1-EC][80-BF][80-BF]\n[ED][80-9F][80-BF]\n[EE-EF][80-BF][80-BF]\n[F0][90-BF][80-BF][80-BF]\n[F1-F3][80-BF][80-BF][80-BF]\n[F4][80-8F][80-BF][80-BF]\n```\n\nThis module automates the process of creating these byte ranges from ranges of\nUnicode scalar values.\n\n# Lineage\n\nI got the idea and general implementation strategy from Russ Cox in his\n[article on regexps](https://web.archive.org/web/20160404141123/https://swtch.com/~rsc/regexp/regexp3.html) and RE2.\nRuss Cox got it from Ken Thompson's `grep` (no source, folk lore?).\nI also got the idea from\n[Lucene](https://github.com/apache/lucene-solr/blob/ae93f4e7ac6a3908046391de35d4f50a0d3c59ca/lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8.java),\nwhich uses it for executing automata on their term index.\n*/\n\n#![deny(missing_docs)]\n\nuse std::char;\nuse std::fmt;\nuse std::slice;\n\nconst MAX_UTF8_BYTES: usize = 4;\n\n/// Utf8Sequence represents a sequence of byte ranges.\n///\n/// To match a Utf8Sequence, a candidate byte sequence must match each\n/// successive range.\n///\n/// For example, if there are two ranges, `[C2-DF][80-BF]`, then the byte\n/// sequence `\\xDD\\x61` would not match because `0x61 < 0x80`.\n#[derive(Copy, Clone, Eq, PartialEq, PartialOrd, Ord)]\npub enum Utf8Sequence {\n    /// One byte range.\n    One(Utf8Range),\n    /// Two successive byte ranges.\n    Two([Utf8Range; 2]),\n    /// Three successive byte ranges.\n    Three([Utf8Range; 3]),\n    /// Four successive byte ranges.\n    Four([Utf8Range; 4]),\n}\n\nimpl Utf8Sequence {\n    /// Creates a new UTF-8 sequence from the encoded bytes of a scalar value\n    /// range.\n    ///\n    /// This assumes that `start` and `end` have the same length.\n    fn from_encoded_range(start: &[u8], end: &[u8]) -> Self {\n        assert_eq!(start.len(), end.len());\n        match start.len() {\n            2 => Utf8Sequence::Two([\n                Utf8Range::new(start[0], end[0]),\n                Utf8Range::new(start[1], end[1]),\n            ]),\n            3 => Utf8Sequence::Three([\n                Utf8Range::new(start[0], end[0]),\n                Utf8Range::new(start[1], end[1]),\n                Utf8Range::new(start[2], end[2]),\n            ]),\n            4 => Utf8Sequence::Four([\n                Utf8Range::new(start[0], end[0]),\n                Utf8Range::new(start[1], end[1]),\n                Utf8Range::new(start[2], end[2]),\n                Utf8Range::new(start[3], end[3]),\n            ]),\n            n => unreachable!(\"invalid encoded length: {}\", n),\n        }\n    }\n\n    /// Returns the underlying sequence of byte ranges as a slice.\n    pub fn as_slice(&self) -> &[Utf8Range] {\n        use self::Utf8Sequence::*;\n        match *self {\n            One(ref r) => slice::from_ref(r),\n            Two(ref r) => &r[..],\n            Three(ref r) => &r[..],\n            Four(ref r) => &r[..],\n        }\n    }\n\n    /// Returns the number of byte ranges in this sequence.\n    ///\n    /// The length is guaranteed to be in the closed interval `[1, 4]`.\n    pub fn len(&self) -> usize {\n        self.as_slice().len()\n    }\n\n    /// Reverses the ranges in this sequence.\n    ///\n    /// For example, if this corresponds to the following sequence:\n    ///\n    /// ```ignore\n    /// [D0-D3][80-BF]\n    /// ```\n    ///\n    /// Then after reversal, it will be\n    ///\n    /// ```ignore\n    /// [80-BF][D0-D3]\n    /// ```\n    ///\n    /// This is useful when one is constructing a UTF-8 automaton to match\n    /// character classes in reverse.\n    pub fn reverse(&mut self) {\n        match *self {\n            Utf8Sequence::One(_) => {}\n            Utf8Sequence::Two(ref mut x) => x.reverse(),\n            Utf8Sequence::Three(ref mut x) => x.reverse(),\n            Utf8Sequence::Four(ref mut x) => x.reverse(),\n        }\n    }\n\n    /// Returns true if and only if a prefix of `bytes` matches this sequence\n    /// of byte ranges.\n    pub fn matches(&self, bytes: &[u8]) -> bool {\n        if bytes.len() < self.len() {\n            return false;\n        }\n        for (&b, r) in bytes.iter().zip(self) {\n            if !r.matches(b) {\n                return false;\n            }\n        }\n        true\n    }\n}\n\nimpl<'a> IntoIterator for &'a Utf8Sequence {\n    type IntoIter = slice::Iter<'a, Utf8Range>;\n    type Item = &'a Utf8Range;\n\n    fn into_iter(self) -> Self::IntoIter {\n        self.as_slice().into_iter()\n    }\n}\n\nimpl fmt::Debug for Utf8Sequence {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        use self::Utf8Sequence::*;\n        match *self {\n            One(ref r) => write!(f, \"{:?}\", r),\n            Two(ref r) => write!(f, \"{:?}{:?}\", r[0], r[1]),\n            Three(ref r) => write!(f, \"{:?}{:?}{:?}\", r[0], r[1], r[2]),\n            Four(ref r) => {\n                write!(f, \"{:?}{:?}{:?}{:?}\", r[0], r[1], r[2], r[3])\n            }\n        }\n    }\n}\n\n/// A single inclusive range of UTF-8 bytes.\n#[derive(Clone, Copy, Eq, PartialEq, PartialOrd, Ord)]\npub struct Utf8Range {\n    /// Start of byte range (inclusive).\n    pub start: u8,\n    /// End of byte range (inclusive).\n    pub end: u8,\n}\n\nimpl Utf8Range {\n    fn new(start: u8, end: u8) -> Self {\n        Utf8Range { start, end }\n    }\n\n    /// Returns true if and only if the given byte is in this range.\n    pub fn matches(&self, b: u8) -> bool {\n        self.start <= b && b <= self.end\n    }\n}\n\nimpl fmt::Debug for Utf8Range {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        if self.start == self.end {\n            write!(f, \"[{:X}]\", self.start)\n        } else {\n            write!(f, \"[{:X}-{:X}]\", self.start, self.end)\n        }\n    }\n}\n\n/// An iterator over ranges of matching UTF-8 byte sequences.\n///\n/// The iteration represents an alternation of comprehensive byte sequences\n/// that match precisely the set of UTF-8 encoded scalar values.\n///\n/// A byte sequence corresponds to one of the scalar values in the range given\n/// if and only if it completely matches exactly one of the sequences of byte\n/// ranges produced by this iterator.\n///\n/// Each sequence of byte ranges matches a unique set of bytes. That is, no two\n/// sequences will match the same bytes.\n///\n/// # Example\n///\n/// This shows how to match an arbitrary byte sequence against a range of\n/// scalar values.\n///\n/// ```rust\n/// use regex_syntax::utf8::{Utf8Sequences, Utf8Sequence};\n///\n/// fn matches(seqs: &[Utf8Sequence], bytes: &[u8]) -> bool {\n///     for range in seqs {\n///         if range.matches(bytes) {\n///             return true;\n///         }\n///     }\n///     false\n/// }\n///\n/// // Test the basic multilingual plane.\n/// let seqs: Vec<_> = Utf8Sequences::new('\\u{0}', '\\u{FFFF}').collect();\n///\n/// // UTF-8 encoding of 'a'.\n/// assert!(matches(&seqs, &[0x61]));\n/// // UTF-8 encoding of '☃' (`\\u{2603}`).\n/// assert!(matches(&seqs, &[0xE2, 0x98, 0x83]));\n/// // UTF-8 encoding of `\\u{10348}` (outside the BMP).\n/// assert!(!matches(&seqs, &[0xF0, 0x90, 0x8D, 0x88]));\n/// // Tries to match against a UTF-8 encoding of a surrogate codepoint,\n/// // which is invalid UTF-8, and therefore fails, despite the fact that\n/// // the corresponding codepoint (0xD800) falls in the range given.\n/// assert!(!matches(&seqs, &[0xED, 0xA0, 0x80]));\n/// // And fails against plain old invalid UTF-8.\n/// assert!(!matches(&seqs, &[0xFF, 0xFF]));\n/// ```\n///\n/// If this example seems circuitous, that's because it is! It's meant to be\n/// illustrative. In practice, you could just try to decode your byte sequence\n/// and compare it with the scalar value range directly. However, this is not\n/// always possible (for example, in a byte based automaton).\npub struct Utf8Sequences {\n    range_stack: Vec<ScalarRange>,\n}\n\nimpl Utf8Sequences {\n    /// Create a new iterator over UTF-8 byte ranges for the scalar value range\n    /// given.\n    pub fn new(start: char, end: char) -> Self {\n        let mut it = Utf8Sequences { range_stack: vec![] };\n        it.push(start as u32, end as u32);\n        it\n    }\n\n    /// reset resets the scalar value range.\n    /// Any existing state is cleared, but resources may be reused.\n    ///\n    /// N.B. Benchmarks say that this method is dubious.\n    #[doc(hidden)]\n    pub fn reset(&mut self, start: char, end: char) {\n        self.range_stack.clear();\n        self.push(start as u32, end as u32);\n    }\n\n    fn push(&mut self, start: u32, end: u32) {\n        self.range_stack.push(ScalarRange { start, end });\n    }\n}\n\nstruct ScalarRange {\n    start: u32,\n    end: u32,\n}\n\nimpl fmt::Debug for ScalarRange {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"ScalarRange({:X}, {:X})\", self.start, self.end)\n    }\n}\n\nimpl Iterator for Utf8Sequences {\n    type Item = Utf8Sequence;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        'TOP: while let Some(mut r) = self.range_stack.pop() {\n            'INNER: loop {\n                if let Some((r1, r2)) = r.split() {\n                    self.push(r2.start, r2.end);\n                    r.start = r1.start;\n                    r.end = r1.end;\n                    continue 'INNER;\n                }\n                if !r.is_valid() {\n                    continue 'TOP;\n                }\n                for i in 1..MAX_UTF8_BYTES {\n                    let max = max_scalar_value(i);\n                    if r.start <= max && max < r.end {\n                        self.push(max + 1, r.end);\n                        r.end = max;\n                        continue 'INNER;\n                    }\n                }\n                if let Some(ascii_range) = r.as_ascii() {\n                    return Some(Utf8Sequence::One(ascii_range));\n                }\n                for i in 1..MAX_UTF8_BYTES {\n                    let m = (1 << (6 * i)) - 1;\n                    if (r.start & !m) != (r.end & !m) {\n                        if (r.start & m) != 0 {\n                            self.push((r.start | m) + 1, r.end);\n                            r.end = r.start | m;\n                            continue 'INNER;\n                        }\n                        if (r.end & m) != m {\n                            self.push(r.end & !m, r.end);\n                            r.end = (r.end & !m) - 1;\n                            continue 'INNER;\n                        }\n                    }\n                }\n                let mut start = [0; MAX_UTF8_BYTES];\n                let mut end = [0; MAX_UTF8_BYTES];\n                let n = r.encode(&mut start, &mut end);\n                return Some(Utf8Sequence::from_encoded_range(\n                    &start[0..n],\n                    &end[0..n],\n                ));\n            }\n        }\n        None\n    }\n}\n\nimpl ScalarRange {\n    /// split splits this range if it overlaps with a surrogate codepoint.\n    ///\n    /// Either or both ranges may be invalid.\n    fn split(&self) -> Option<(ScalarRange, ScalarRange)> {\n        if self.start < 0xE000 && self.end > 0xD7FF {\n            Some((\n                ScalarRange { start: self.start, end: 0xD7FF },\n                ScalarRange { start: 0xE000, end: self.end },\n            ))\n        } else {\n            None\n        }\n    }\n\n    /// is_valid returns true if and only if start <= end.\n    fn is_valid(&self) -> bool {\n        self.start <= self.end\n    }\n\n    /// as_ascii returns this range as a Utf8Range if and only if all scalar\n    /// values in this range can be encoded as a single byte.\n    fn as_ascii(&self) -> Option<Utf8Range> {\n        if self.is_ascii() {\n            Some(Utf8Range::new(self.start as u8, self.end as u8))\n        } else {\n            None\n        }\n    }\n\n    /// is_ascii returns true if the range is ASCII only (i.e., takes a single\n    /// byte to encode any scalar value).\n    fn is_ascii(&self) -> bool {\n        self.is_valid() && self.end <= 0x7f\n    }\n\n    /// encode writes the UTF-8 encoding of the start and end of this range\n    /// to the corresponding destination slices, and returns the number of\n    /// bytes written.\n    ///\n    /// The slices should have room for at least `MAX_UTF8_BYTES`.\n    fn encode(&self, start: &mut [u8], end: &mut [u8]) -> usize {\n        let cs = char::from_u32(self.start).unwrap();\n        let ce = char::from_u32(self.end).unwrap();\n        let ss = cs.encode_utf8(start);\n        let se = ce.encode_utf8(end);\n        assert_eq!(ss.len(), se.len());\n        ss.len()\n    }\n}\n\nfn max_scalar_value(nbytes: usize) -> u32 {\n    match nbytes {\n        1 => 0x007F,\n        2 => 0x07FF,\n        3 => 0xFFFF,\n        4 => 0x10FFFF,\n        _ => unreachable!(\"invalid UTF-8 byte sequence size\"),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::char;\n\n    use utf8::{Utf8Range, Utf8Sequences};\n\n    fn rutf8(s: u8, e: u8) -> Utf8Range {\n        Utf8Range::new(s, e)\n    }\n\n    fn never_accepts_surrogate_codepoints(start: char, end: char) {\n        for cp in 0xD800..0xE000 {\n            let buf = encode_surrogate(cp);\n            for r in Utf8Sequences::new(start, end) {\n                if r.matches(&buf) {\n                    panic!(\n                        \"Sequence ({:X}, {:X}) contains range {:?}, \\\n                         which matches surrogate code point {:X} \\\n                         with encoded bytes {:?}\",\n                        start as u32, end as u32, r, cp, buf,\n                    );\n                }\n            }\n        }\n    }\n\n    #[test]\n    fn codepoints_no_surrogates() {\n        never_accepts_surrogate_codepoints('\\u{0}', '\\u{FFFF}');\n        never_accepts_surrogate_codepoints('\\u{0}', '\\u{10FFFF}');\n        never_accepts_surrogate_codepoints('\\u{0}', '\\u{10FFFE}');\n        never_accepts_surrogate_codepoints('\\u{80}', '\\u{10FFFF}');\n        never_accepts_surrogate_codepoints('\\u{D7FF}', '\\u{E000}');\n    }\n\n    #[test]\n    fn single_codepoint_one_sequence() {\n        // Tests that every range of scalar values that contains a single\n        // scalar value is recognized by one sequence of byte ranges.\n        for i in 0x0..(0x10FFFF + 1) {\n            let c = match char::from_u32(i) {\n                None => continue,\n                Some(c) => c,\n            };\n            let seqs: Vec<_> = Utf8Sequences::new(c, c).collect();\n            assert_eq!(seqs.len(), 1);\n        }\n    }\n\n    #[test]\n    fn bmp() {\n        use utf8::Utf8Sequence::*;\n\n        let seqs = Utf8Sequences::new('\\u{0}', '\\u{FFFF}').collect::<Vec<_>>();\n        assert_eq!(\n            seqs,\n            vec![\n                One(rutf8(0x0, 0x7F)),\n                Two([rutf8(0xC2, 0xDF), rutf8(0x80, 0xBF)]),\n                Three([\n                    rutf8(0xE0, 0xE0),\n                    rutf8(0xA0, 0xBF),\n                    rutf8(0x80, 0xBF)\n                ]),\n                Three([\n                    rutf8(0xE1, 0xEC),\n                    rutf8(0x80, 0xBF),\n                    rutf8(0x80, 0xBF)\n                ]),\n                Three([\n                    rutf8(0xED, 0xED),\n                    rutf8(0x80, 0x9F),\n                    rutf8(0x80, 0xBF)\n                ]),\n                Three([\n                    rutf8(0xEE, 0xEF),\n                    rutf8(0x80, 0xBF),\n                    rutf8(0x80, 0xBF)\n                ]),\n            ]\n        );\n    }\n\n    #[test]\n    fn reverse() {\n        use utf8::Utf8Sequence::*;\n\n        let mut s = One(rutf8(0xA, 0xB));\n        s.reverse();\n        assert_eq!(s.as_slice(), &[rutf8(0xA, 0xB)]);\n\n        let mut s = Two([rutf8(0xA, 0xB), rutf8(0xB, 0xC)]);\n        s.reverse();\n        assert_eq!(s.as_slice(), &[rutf8(0xB, 0xC), rutf8(0xA, 0xB)]);\n\n        let mut s = Three([rutf8(0xA, 0xB), rutf8(0xB, 0xC), rutf8(0xC, 0xD)]);\n        s.reverse();\n        assert_eq!(\n            s.as_slice(),\n            &[rutf8(0xC, 0xD), rutf8(0xB, 0xC), rutf8(0xA, 0xB)]\n        );\n\n        let mut s = Four([\n            rutf8(0xA, 0xB),\n            rutf8(0xB, 0xC),\n            rutf8(0xC, 0xD),\n            rutf8(0xD, 0xE),\n        ]);\n        s.reverse();\n        assert_eq!(\n            s.as_slice(),\n            &[\n                rutf8(0xD, 0xE),\n                rutf8(0xC, 0xD),\n                rutf8(0xB, 0xC),\n                rutf8(0xA, 0xB)\n            ]\n        );\n    }\n\n    fn encode_surrogate(cp: u32) -> [u8; 3] {\n        const TAG_CONT: u8 = 0b1000_0000;\n        const TAG_THREE_B: u8 = 0b1110_0000;\n\n        assert!(0xD800 <= cp && cp < 0xE000);\n        let mut dst = [0; 3];\n        dst[0] = (cp >> 12 & 0x0F) as u8 | TAG_THREE_B;\n        dst[1] = (cp >> 6 & 0x3F) as u8 | TAG_CONT;\n        dst[2] = (cp & 0x3F) as u8 | TAG_CONT;\n        dst\n    }\n}\n","traces":[{"line":115,"address":[6551936],"length":1,"stats":{"Line":19},"fn_name":"from_encoded_range"},{"line":116,"address":[6552216,6551987],"length":1,"stats":{"Line":19},"fn_name":null},{"line":117,"address":[6552193,6552919,6553909,6553355],"length":1,"stats":{"Line":88},"fn_name":null},{"line":118,"address":[6552854,6552506],"length":1,"stats":{"Line":38},"fn_name":null},{"line":119,"address":[6554453,6552648],"length":1,"stats":{"Line":19},"fn_name":null},{"line":120,"address":[6554513,6552743],"length":1,"stats":{"Line":19},"fn_name":null},{"line":122,"address":[6553249],"length":1,"stats":{"Line":26},"fn_name":null},{"line":123,"address":[6552936,6554269],"length":1,"stats":{"Line":19},"fn_name":null},{"line":124,"address":[6553031,6554329],"length":1,"stats":{"Line":19},"fn_name":null},{"line":125,"address":[6554391,6553138],"length":1,"stats":{"Line":24},"fn_name":null},{"line":127,"address":[6553792],"length":1,"stats":{"Line":24},"fn_name":null},{"line":128,"address":[6554023,6553372],"length":1,"stats":{"Line":24},"fn_name":null},{"line":129,"address":[6554083,6553467],"length":1,"stats":{"Line":26},"fn_name":null},{"line":130,"address":[6554145,6553574],"length":1,"stats":{"Line":24},"fn_name":null},{"line":131,"address":[6554207,6553681],"length":1,"stats":{"Line":26},"fn_name":null},{"line":138,"address":[6554576],"length":1,"stats":{"Line":21},"fn_name":"as_slice"},{"line":140,"address":[6554729,6554854,6554669,6554794,6554876],"length":1,"stats":{"Line":92},"fn_name":null},{"line":141,"address":[6554588,6554676],"length":1,"stats":{"Line":42},"fn_name":null},{"line":142,"address":[6554739],"length":1,"stats":{"Line":26},"fn_name":null},{"line":143,"address":[6554801],"length":1,"stats":{"Line":24},"fn_name":null},{"line":144,"address":[6554861,6554629],"length":1,"stats":{"Line":50},"fn_name":null},{"line":151,"address":[6554896],"length":1,"stats":{"Line":0},"fn_name":"len"},{"line":152,"address":[6554905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[6554960],"length":1,"stats":{"Line":0},"fn_name":"reverse"},{"line":172,"address":[6555035,6555067,6555099],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[6554969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[6555042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[6555074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[6555008],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[6555120],"length":1,"stats":{"Line":0},"fn_name":"matches"},{"line":183,"address":[6555156],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[6555242],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[6555264,6555224,6555409,6555502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[6555476],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[6555507],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[6555399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[6555520],"length":1,"stats":{"Line":19},"fn_name":"into_iter"},{"line":200,"address":[6555529],"length":1,"stats":{"Line":19},"fn_name":null},{"line":205,"address":[6555584],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":207,"address":[6556105,6556801,6557081,6555885,6556428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[6555902,6555608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[6556125],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[6556448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[6555676],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[6556821,6555690],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[6557104],"length":1,"stats":{"Line":23},"fn_name":"new"},{"line":233,"address":[6557136],"length":1,"stats":{"Line":0},"fn_name":"matches"},{"line":234,"address":[6557150],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[6557216],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":240,"address":[6557239,6557692,6557532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[6557376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[6557263,6557549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[6557712,6557787],"length":1,"stats":{"Line":27},"fn_name":"new"},{"line":306,"address":[6557737,6557799],"length":1,"stats":{"Line":54},"fn_name":null},{"line":307,"address":[6557832],"length":1,"stats":{"Line":27},"fn_name":null},{"line":308,"address":[6557839],"length":1,"stats":{"Line":27},"fn_name":null},{"line":316,"address":[6557904],"length":1,"stats":{"Line":23},"fn_name":"reset"},{"line":317,"address":[6557921],"length":1,"stats":{"Line":21},"fn_name":null},{"line":318,"address":[6557959],"length":1,"stats":{"Line":23},"fn_name":null},{"line":321,"address":[6557984],"length":1,"stats":{"Line":27},"fn_name":"push"},{"line":322,"address":[6558001],"length":1,"stats":{"Line":27},"fn_name":null},{"line":332,"address":[6558032],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":333,"address":[6558062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[6558336],"length":1,"stats":{"Line":24},"fn_name":"next"},{"line":341,"address":[6558386,6558434],"length":1,"stats":{"Line":44},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[6558462,6558523],"length":1,"stats":{"Line":38},"fn_name":null},{"line":344,"address":[6558594],"length":1,"stats":{"Line":18},"fn_name":null},{"line":345,"address":[6558629],"length":1,"stats":{"Line":18},"fn_name":null},{"line":346,"address":[6558643],"length":1,"stats":{"Line":18},"fn_name":null},{"line":347,"address":[6558650],"length":1,"stats":{"Line":18},"fn_name":null},{"line":349,"address":[6558498,6558662],"length":1,"stats":{"Line":44},"fn_name":null},{"line":350,"address":[6558732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[6558668,6558888,6559001,6558745],"length":1,"stats":{"Line":67},"fn_name":null},{"line":353,"address":[6558922],"length":1,"stats":{"Line":24},"fn_name":null},{"line":354,"address":[6558945],"length":1,"stats":{"Line":20},"fn_name":null},{"line":355,"address":[6559010,6560061],"length":1,"stats":{"Line":18},"fn_name":null},{"line":356,"address":[6559057],"length":1,"stats":{"Line":18},"fn_name":null},{"line":357,"address":[6559064],"length":1,"stats":{"Line":18},"fn_name":null},{"line":360,"address":[6558827,6559069,6559147],"length":1,"stats":{"Line":69},"fn_name":null},{"line":361,"address":[6559175,6559244],"length":1,"stats":{"Line":46},"fn_name":null},{"line":363,"address":[6559251,6559454,6559089,6559845],"length":1,"stats":{"Line":57},"fn_name":null},{"line":364,"address":[6560091,6559488],"length":1,"stats":{"Line":19},"fn_name":null},{"line":365,"address":[6559607,6559757],"length":1,"stats":{"Line":38},"fn_name":null},{"line":366,"address":[6559647],"length":1,"stats":{"Line":19},"fn_name":null},{"line":367,"address":[6560181,6559684],"length":1,"stats":{"Line":19},"fn_name":null},{"line":368,"address":[6559738],"length":1,"stats":{"Line":19},"fn_name":null},{"line":369,"address":[6559752],"length":1,"stats":{"Line":19},"fn_name":null},{"line":371,"address":[6559663],"length":1,"stats":{"Line":19},"fn_name":null},{"line":372,"address":[6559759],"length":1,"stats":{"Line":26},"fn_name":null},{"line":373,"address":[6560211,6559797,6560241],"length":1,"stats":{"Line":24},"fn_name":null},{"line":374,"address":[6559843],"length":1,"stats":{"Line":26},"fn_name":null},{"line":378,"address":[6559343],"length":1,"stats":{"Line":19},"fn_name":null},{"line":379,"address":[6559395],"length":1,"stats":{"Line":19},"fn_name":null},{"line":380,"address":[6559410],"length":1,"stats":{"Line":19},"fn_name":null},{"line":381,"address":[6559995],"length":1,"stats":{"Line":19},"fn_name":null},{"line":382,"address":[6559850],"length":1,"stats":{"Line":19},"fn_name":null},{"line":383,"address":[6559923],"length":1,"stats":{"Line":19},"fn_name":null},{"line":387,"address":[6558426],"length":1,"stats":{"Line":19},"fn_name":null},{"line":395,"address":[6560256],"length":1,"stats":{"Line":24},"fn_name":"split"},{"line":396,"address":[6560340,6560268],"length":1,"stats":{"Line":41},"fn_name":null},{"line":397,"address":[6560376],"length":1,"stats":{"Line":18},"fn_name":null},{"line":398,"address":[6560347],"length":1,"stats":{"Line":18},"fn_name":null},{"line":399,"address":[6560361],"length":1,"stats":{"Line":18},"fn_name":null},{"line":402,"address":[6560334],"length":1,"stats":{"Line":23},"fn_name":null},{"line":407,"address":[6560448],"length":1,"stats":{"Line":21},"fn_name":"is_valid"},{"line":408,"address":[6560453],"length":1,"stats":{"Line":23},"fn_name":null},{"line":413,"address":[6560480],"length":1,"stats":{"Line":23},"fn_name":"as_ascii"},{"line":414,"address":[6560494,6560518],"length":1,"stats":{"Line":42},"fn_name":null},{"line":415,"address":[6560525],"length":1,"stats":{"Line":23},"fn_name":null},{"line":417,"address":[6560513],"length":1,"stats":{"Line":19},"fn_name":null},{"line":423,"address":[6560592],"length":1,"stats":{"Line":23},"fn_name":"is_ascii"},{"line":424,"address":[6560606,6560662,6560668],"length":1,"stats":{"Line":46},"fn_name":null},{"line":432,"address":[6560672],"length":1,"stats":{"Line":19},"fn_name":"encode"},{"line":433,"address":[6560719],"length":1,"stats":{"Line":19},"fn_name":null},{"line":434,"address":[6560811],"length":1,"stats":{"Line":19},"fn_name":null},{"line":435,"address":[6560874],"length":1,"stats":{"Line":19},"fn_name":null},{"line":436,"address":[6560925],"length":1,"stats":{"Line":19},"fn_name":null},{"line":437,"address":[6560966,6561128],"length":1,"stats":{"Line":19},"fn_name":null},{"line":438,"address":[6561106],"length":1,"stats":{"Line":19},"fn_name":null},{"line":442,"address":[6561424],"length":1,"stats":{"Line":20},"fn_name":"max_scalar_value"},{"line":443,"address":[6561568,6561558,6561578,6561548],"length":1,"stats":{"Line":71},"fn_name":null},{"line":444,"address":[6561540,6561436],"length":1,"stats":{"Line":44},"fn_name":null},{"line":445,"address":[6561550],"length":1,"stats":{"Line":22},"fn_name":null},{"line":446,"address":[6561560],"length":1,"stats":{"Line":23},"fn_name":null},{"line":447,"address":[6561570],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":93,"coverable":126},{"path":["/","usr","src","regex","src","backtrack.rs"],"content":"// This is the backtracking matching engine. It has the same exact capability\n// as the full NFA simulation, except it is artificially restricted to small\n// regexes on small inputs because of its memory requirements.\n//\n// In particular, this is a *bounded* backtracking engine. It retains worst\n// case linear time by keeping track of the states that it has visited (using a\n// bitmap). Namely, once a state is visited, it is never visited again. Since a\n// state is keyed by `(instruction index, input index)`, we have that its time\n// complexity is `O(mn)` (i.e., linear in the size of the search text).\n//\n// The backtracking engine can beat out the NFA simulation on small\n// regexes/inputs because it doesn't have to keep track of multiple copies of\n// the capture groups. In benchmarks, the backtracking engine is roughly twice\n// as fast as the full NFA simulation. Note though that its performance doesn't\n// scale, even if you're willing to live with the memory requirements. Namely,\n// the bitset has to be zeroed on each execution, which becomes quite expensive\n// on large bitsets.\n\nuse exec::ProgramCache;\nuse input::{Input, InputAt};\nuse prog::{InstPtr, Program};\nuse re_trait::Slot;\n\ntype Bits = u32;\n\nconst BIT_SIZE: usize = 32;\nconst MAX_SIZE_BYTES: usize = 256 * (1 << 10); // 256 KB\n\n/// Returns true iff the given regex and input should be executed by this\n/// engine with reasonable memory usage.\npub fn should_exec(num_insts: usize, text_len: usize) -> bool {\n    // Total memory usage in bytes is determined by:\n    //\n    //   ((len(insts) * (len(input) + 1) + bits - 1) / bits) * (size_of(u32))\n    //\n    // The actual limit picked is pretty much a heuristic.\n    // See: https://github.com/rust-lang/regex/issues/215\n    let size = ((num_insts * (text_len + 1) + BIT_SIZE - 1) / BIT_SIZE) * 4;\n    size <= MAX_SIZE_BYTES\n}\n\n/// A backtracking matching engine.\n#[derive(Debug)]\npub struct Bounded<'a, 'm, 'r, 's, I> {\n    prog: &'r Program,\n    input: I,\n    matches: &'m mut [bool],\n    slots: &'s mut [Slot],\n    m: &'a mut Cache,\n}\n\n/// Shared cached state between multiple invocations of a backtracking engine\n/// in the same thread.\n#[derive(Clone, Debug)]\npub struct Cache {\n    jobs: Vec<Job>,\n    visited: Vec<Bits>,\n}\n\nimpl Cache {\n    /// Create new empty cache for the backtracking engine.\n    pub fn new(_prog: &Program) -> Self {\n        Cache { jobs: vec![], visited: vec![] }\n    }\n}\n\n/// A job is an explicit unit of stack space in the backtracking engine.\n///\n/// The \"normal\" representation is a single state transition, which corresponds\n/// to an NFA state and a character in the input. However, the backtracking\n/// engine must keep track of old capture group values. We use the explicit\n/// stack to do it.\n#[derive(Clone, Copy, Debug)]\nenum Job {\n    Inst { ip: InstPtr, at: InputAt },\n    SaveRestore { slot: usize, old_pos: Option<usize> },\n}\n\nimpl<'a, 'm, 'r, 's, I: Input> Bounded<'a, 'm, 'r, 's, I> {\n    /// Execute the backtracking matching engine.\n    ///\n    /// If there's a match, `exec` returns `true` and populates the given\n    /// captures accordingly.\n    pub fn exec(\n        prog: &'r Program,\n        cache: &ProgramCache,\n        matches: &'m mut [bool],\n        slots: &'s mut [Slot],\n        input: I,\n        start: usize,\n        end: usize,\n    ) -> bool {\n        let mut cache = cache.borrow_mut();\n        let cache = &mut cache.backtrack;\n        let start = input.at(start);\n        let mut b = Bounded {\n            prog: prog,\n            input: input,\n            matches: matches,\n            slots: slots,\n            m: cache,\n        };\n        b.exec_(start, end)\n    }\n\n    /// Clears the cache such that the backtracking engine can be executed\n    /// on some input of fixed length.\n    fn clear(&mut self) {\n        // Reset the job memory so that we start fresh.\n        self.m.jobs.clear();\n\n        // Now we need to clear the bit state set.\n        // We do this by figuring out how much space we need to keep track\n        // of the states we've visited.\n        // Then we reset all existing allocated space to 0.\n        // Finally, we request more space if we need it.\n        //\n        // This is all a little circuitous, but doing this unsafely\n        // doesn't seem to have a measurable impact on performance.\n        // (Probably because backtracking is limited to such small\n        // inputs/regexes in the first place.)\n        let visited_len =\n            (self.prog.len() * (self.input.len() + 1) + BIT_SIZE - 1)\n                / BIT_SIZE;\n        self.m.visited.truncate(visited_len);\n        for v in &mut self.m.visited {\n            *v = 0;\n        }\n        if visited_len > self.m.visited.len() {\n            let len = self.m.visited.len();\n            self.m.visited.reserve_exact(visited_len - len);\n            for _ in 0..(visited_len - len) {\n                self.m.visited.push(0);\n            }\n        }\n    }\n\n    /// Start backtracking at the given position in the input, but also look\n    /// for literal prefixes.\n    fn exec_(&mut self, mut at: InputAt, end: usize) -> bool {\n        self.clear();\n        // If this is an anchored regex at the beginning of the input, then\n        // we're either already done or we only need to try backtracking once.\n        if self.prog.is_anchored_start {\n            return if !at.is_start() { false } else { self.backtrack(at) };\n        }\n        let mut matched = false;\n        loop {\n            if !self.prog.prefixes.is_empty() {\n                at = match self.input.prefix_at(&self.prog.prefixes, at) {\n                    None => break,\n                    Some(at) => at,\n                };\n            }\n            matched = self.backtrack(at) || matched;\n            if matched && self.prog.matches.len() == 1 {\n                return true;\n            }\n            if at.pos() >= end {\n                break;\n            }\n            at = self.input.at(at.next_pos());\n        }\n        matched\n    }\n\n    /// The main backtracking loop starting at the given input position.\n    fn backtrack(&mut self, start: InputAt) -> bool {\n        // N.B. We use an explicit stack to avoid recursion.\n        // To avoid excessive pushing and popping, most transitions are handled\n        // in the `step` helper function, which only pushes to the stack when\n        // there's a capture or a branch.\n        let mut matched = false;\n        self.m.jobs.push(Job::Inst { ip: 0, at: start });\n        while let Some(job) = self.m.jobs.pop() {\n            match job {\n                Job::Inst { ip, at } => {\n                    if self.step(ip, at) {\n                        // Only quit if we're matching one regex.\n                        // If we're matching a regex set, then mush on and\n                        // try to find other matches (if we want them).\n                        if self.prog.matches.len() == 1 {\n                            return true;\n                        }\n                        matched = true;\n                    }\n                }\n                Job::SaveRestore { slot, old_pos } => {\n                    if slot < self.slots.len() {\n                        self.slots[slot] = old_pos;\n                    }\n                }\n            }\n        }\n        matched\n    }\n\n    fn step(&mut self, mut ip: InstPtr, mut at: InputAt) -> bool {\n        use prog::Inst::*;\n        loop {\n            // This loop is an optimization to avoid constantly pushing/popping\n            // from the stack. Namely, if we're pushing a job only to run it\n            // next, avoid the push and just mutate `ip` (and possibly `at`)\n            // in place.\n            if self.has_visited(ip, at) {\n                return false;\n            }\n            match self.prog[ip] {\n                Match(slot) => {\n                    if slot < self.matches.len() {\n                        self.matches[slot] = true;\n                    }\n                    return true;\n                }\n                Save(ref inst) => {\n                    if let Some(&old_pos) = self.slots.get(inst.slot) {\n                        // If this path doesn't work out, then we save the old\n                        // capture index (if one exists) in an alternate\n                        // job. If the next path fails, then the alternate\n                        // job is popped and the old capture index is restored.\n                        self.m.jobs.push(Job::SaveRestore {\n                            slot: inst.slot,\n                            old_pos: old_pos,\n                        });\n                        self.slots[inst.slot] = Some(at.pos());\n                    }\n                    ip = inst.goto;\n                }\n                Split(ref inst) => {\n                    self.m.jobs.push(Job::Inst { ip: inst.goto2, at: at });\n                    ip = inst.goto1;\n                }\n                EmptyLook(ref inst) => {\n                    if self.input.is_empty_match(at, inst) {\n                        ip = inst.goto;\n                    } else {\n                        return false;\n                    }\n                }\n                Char(ref inst) => {\n                    if inst.c == at.char() {\n                        ip = inst.goto;\n                        at = self.input.at(at.next_pos());\n                    } else {\n                        return false;\n                    }\n                }\n                Ranges(ref inst) => {\n                    if inst.matches(at.char()) {\n                        ip = inst.goto;\n                        at = self.input.at(at.next_pos());\n                    } else {\n                        return false;\n                    }\n                }\n                Bytes(ref inst) => {\n                    if let Some(b) = at.byte() {\n                        if inst.matches(b) {\n                            ip = inst.goto;\n                            at = self.input.at(at.next_pos());\n                            continue;\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n    }\n\n    fn has_visited(&mut self, ip: InstPtr, at: InputAt) -> bool {\n        let k = ip * (self.input.len() + 1) + at.pos();\n        let k1 = k / BIT_SIZE;\n        let k2 = usize_to_u32(1 << (k & (BIT_SIZE - 1)));\n        if self.m.visited[k1] & k2 == 0 {\n            self.m.visited[k1] |= k2;\n            false\n        } else {\n            true\n        }\n    }\n}\n\nfn usize_to_u32(n: usize) -> u32 {\n    if (n as u64) > (::std::u32::MAX as u64) {\n        panic!(\"BUG: {} is too big to fit into u32\", n)\n    }\n    n as u32\n}\n","traces":[{"line":31,"address":[5892320],"length":1,"stats":{"Line":12},"fn_name":"should_exec"},{"line":38,"address":[5892334,5892516],"length":1,"stats":{"Line":12},"fn_name":null},{"line":39,"address":[5892494],"length":1,"stats":{"Line":12},"fn_name":null},{"line":62,"address":[5892672,5892730],"length":1,"stats":{"Line":25},"fn_name":"new"},{"line":63,"address":[5892693,5892751],"length":1,"stats":{"Line":48},"fn_name":null},{"line":84,"address":[4517049,4517627,4516880,4517472],"length":1,"stats":{"Line":25},"fn_name":"exec<regex::input::CharInput>"},{"line":93,"address":[4516978,4517551,4517647,4517069],"length":1,"stats":{"Line":48},"fn_name":null},{"line":94,"address":[4517667,4517092],"length":1,"stats":{"Line":23},"fn_name":null},{"line":95,"address":[4517146,4517721],"length":1,"stats":{"Line":25},"fn_name":null},{"line":103,"address":[4517280,4517889],"length":1,"stats":{"Line":23},"fn_name":null},{"line":108,"address":[4519120,4518080],"length":1,"stats":{"Line":25},"fn_name":"clear<regex::input::ByteInput>"},{"line":110,"address":[4518095,4519135],"length":1,"stats":{"Line":23},"fn_name":null},{"line":122,"address":[4519972,4519163,4518181,4518123,4518932,4519221],"length":1,"stats":{"Line":52},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[4518359,4519399],"length":1,"stats":{"Line":24},"fn_name":null},{"line":126,"address":[4519571,4518571,4519611,4519434,4518394,4518531],"length":1,"stats":{"Line":40},"fn_name":null},{"line":127,"address":[4518565,4519605],"length":1,"stats":{"Line":13},"fn_name":null},{"line":129,"address":[4519544,4519905,4518504,4518583,4518865,4519623],"length":1,"stats":{"Line":77},"fn_name":null},{"line":130,"address":[4518600,4519640],"length":1,"stats":{"Line":24},"fn_name":null},{"line":131,"address":[4520092,4518641,4519052,4519681],"length":1,"stats":{"Line":26},"fn_name":null},{"line":132,"address":[4519112,4519962,4518867,4520152,4519082,4518922,4518714,4520122,4519754,4519907],"length":1,"stats":{"Line":57},"fn_name":null},{"line":133,"address":[4518903,4519943],"length":1,"stats":{"Line":26},"fn_name":null},{"line":140,"address":[4520960,4520160],"length":1,"stats":{"Line":17},"fn_name":"exec_<regex::input::CharInput>"},{"line":141,"address":[4520198,4520998],"length":1,"stats":{"Line":23},"fn_name":null},{"line":144,"address":[4521008,4520208],"length":1,"stats":{"Line":25},"fn_name":null},{"line":145,"address":[4520232,4520264,4521032,4521064],"length":1,"stats":{"Line":25},"fn_name":null},{"line":147,"address":[4521020,4520220],"length":1,"stats":{"Line":17},"fn_name":null},{"line":148,"address":[4521760,4520225,4520955,4520960,4521025,4521755],"length":1,"stats":{"Line":28},"fn_name":"exec_<regex::input::ByteInput>"},{"line":149,"address":[4521404,4520604,4520352,4521152],"length":1,"stats":{"Line":23},"fn_name":null},{"line":150,"address":[4520387,4520606,4521406,4521373,4520573,4521187],"length":1,"stats":{"Line":12},"fn_name":null},{"line":151,"address":[4521265,4521408,4520465,4520608],"length":1,"stats":{"Line":10},"fn_name":null},{"line":152,"address":[4520486,4521286],"length":1,"stats":{"Line":6},"fn_name":null},{"line":155,"address":[4521418,4520618,4520732,4521532],"length":1,"stats":{"Line":35},"fn_name":null},{"line":156,"address":[4521538,4520738,4521519,4520719],"length":1,"stats":{"Line":32},"fn_name":null},{"line":157,"address":[4521631,4520831],"length":1,"stats":{"Line":14},"fn_name":null},{"line":159,"address":[4521651,4520851,4521619,4520819],"length":1,"stats":{"Line":26},"fn_name":null},{"line":160,"address":[4520888,4521688],"length":1,"stats":{"Line":13},"fn_name":null},{"line":162,"address":[4521693,4520893,4521661,4520861],"length":1,"stats":{"Line":20},"fn_name":null},{"line":164,"address":[4521135,4520335],"length":1,"stats":{"Line":13},"fn_name":null},{"line":168,"address":[4521760,4522464],"length":1,"stats":{"Line":24},"fn_name":"backtrack<regex::input::ByteInput>"},{"line":173,"address":[4521775,4522479],"length":1,"stats":{"Line":24},"fn_name":null},{"line":174,"address":[4521780,4522484],"length":1,"stats":{"Line":25},"fn_name":null},{"line":175,"address":[4522586,4522666,4522421,4521962,4521882,4523125],"length":1,"stats":{"Line":73},"fn_name":null},{"line":176,"address":[4522334,4522820,4522116,4523123,4522419,4523038],"length":1,"stats":{"Line":36},"fn_name":null},{"line":177,"address":[4522714,4522822,4522118,4522010],"length":1,"stats":{"Line":49},"fn_name":null},{"line":178,"address":[4522182,4522310,4522886,4523014],"length":1,"stats":{"Line":29},"fn_name":null},{"line":182,"address":[4522270,4522974],"length":1,"stats":{"Line":24},"fn_name":null},{"line":183,"address":[4522312,4523016],"length":1,"stats":{"Line":22},"fn_name":null},{"line":185,"address":[4522305,4523009],"length":1,"stats":{"Line":4},"fn_name":null},{"line":188,"address":[4522729,4522025],"length":1,"stats":{"Line":13},"fn_name":null},{"line":189,"address":[4522078,4522346,4523050,4522782],"length":1,"stats":{"Line":26},"fn_name":null},{"line":190,"address":[4522356,4523130,4522426,4523060,4523157,4522453],"length":1,"stats":{"Line":13},"fn_name":null},{"line":195,"address":[4521947,4522651],"length":1,"stats":{"Line":14},"fn_name":null},{"line":198,"address":[4525312,4523168],"length":1,"stats":{"Line":25},"fn_name":"step<regex::input::CharInput>"},{"line":200,"address":[4525196,4527340],"length":1,"stats":{"Line":24},"fn_name":null},{"line":205,"address":[4523207,4525351],"length":1,"stats":{"Line":24},"fn_name":null},{"line":206,"address":[4525495,4523351],"length":1,"stats":{"Line":5},"fn_name":null},{"line":208,"address":[4527126,4526478,4524753,4525451,4523349,4523307,4524982,4524124,4525201,4526268,4527345,4523379,4525692,4526646,4525523,4526897,4524502,4523548,4525493,4524334],"length":1,"stats":{"Line":155},"fn_name":null},{"line":209,"address":[4523558,4523427,4525571,4525702],"length":1,"stats":{"Line":41},"fn_name":null},{"line":210,"address":[4523596,4525740],"length":1,"stats":{"Line":18},"fn_name":null},{"line":211,"address":[4527410,4523655,4525300,4525266,4525799,4527444],"length":1,"stats":{"Line":24},"fn_name":null},{"line":213,"address":[4525861,4523717],"length":1,"stats":{"Line":22},"fn_name":null},{"line":215,"address":[4523738,4525882],"length":1,"stats":{"Line":24},"fn_name":null},{"line":216,"address":[4523782,4525926],"length":1,"stats":{"Line":25},"fn_name":null},{"line":221,"address":[4523886,4526046,4523902,4526030],"length":1,"stats":{"Line":48},"fn_name":null},{"line":222,"address":[4526042,4523898],"length":1,"stats":{"Line":25},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[4527379,4523962,4525235,4526106],"length":1,"stats":{"Line":25},"fn_name":null},{"line":227,"address":[4526257,4524113],"length":1,"stats":{"Line":24},"fn_name":null},{"line":229,"address":[4526281,4524137],"length":1,"stats":{"Line":18},"fn_name":null},{"line":230,"address":[4524181,4526325],"length":1,"stats":{"Line":19},"fn_name":null},{"line":231,"address":[4526467,4524323],"length":1,"stats":{"Line":18},"fn_name":null},{"line":233,"address":[4524347,4526491],"length":1,"stats":{"Line":20},"fn_name":null},{"line":234,"address":[4526532,4524388],"length":1,"stats":{"Line":19},"fn_name":null},{"line":235,"address":[4524491,4526635],"length":1,"stats":{"Line":20},"fn_name":null},{"line":237,"address":[4524473,4526617],"length":1,"stats":{"Line":12},"fn_name":null},{"line":240,"address":[4524515,4526659],"length":1,"stats":{"Line":9},"fn_name":null},{"line":241,"address":[4524548,4526692],"length":1,"stats":{"Line":9},"fn_name":null},{"line":242,"address":[4526782,4524638],"length":1,"stats":{"Line":9},"fn_name":null},{"line":243,"address":[4526801,4524657],"length":1,"stats":{"Line":9},"fn_name":null},{"line":245,"address":[4526764,4524620],"length":1,"stats":{"Line":8},"fn_name":null},{"line":248,"address":[4524766,4526910],"length":1,"stats":{"Line":13},"fn_name":null},{"line":249,"address":[4526956,4524812],"length":1,"stats":{"Line":13},"fn_name":null},{"line":250,"address":[4527011,4524867],"length":1,"stats":{"Line":9},"fn_name":null},{"line":251,"address":[4524886,4527030],"length":1,"stats":{"Line":9},"fn_name":null},{"line":253,"address":[4526993,4524849],"length":1,"stats":{"Line":15},"fn_name":null},{"line":256,"address":[4523483,4525627],"length":1,"stats":{"Line":10},"fn_name":null},{"line":257,"address":[4524987,4525055,4523524,4525668,4527131,4527199],"length":1,"stats":{"Line":28},"fn_name":null},{"line":258,"address":[4527177,4525033],"length":1,"stats":{"Line":9},"fn_name":null},{"line":259,"address":[4525065,4527209],"length":1,"stats":{"Line":11},"fn_name":null},{"line":260,"address":[4525084,4527228],"length":1,"stats":{"Line":10},"fn_name":null},{"line":261,"address":[4525178,4527322],"length":1,"stats":{"Line":12},"fn_name":null},{"line":264,"address":[4527327,4525183],"length":1,"stats":{"Line":9},"fn_name":null},{"line":270,"address":[4527456,4527984],"length":1,"stats":{"Line":25},"fn_name":"has_visited<regex::input::ByteInput>"},{"line":271,"address":[4527851,4528001,4527473,4528379],"length":1,"stats":{"Line":24},"fn_name":null},{"line":272,"address":[4527628,4528156],"length":1,"stats":{"Line":25},"fn_name":null},{"line":273,"address":[4527645,4527941,4528173,4528469,4528499,4527971],"length":1,"stats":{"Line":22},"fn_name":null},{"line":274,"address":[4527731,4528310,4527782,4528259],"length":1,"stats":{"Line":29},"fn_name":null},{"line":275,"address":[4527789,4528317],"length":1,"stats":{"Line":25},"fn_name":null},{"line":276,"address":[4528357,4527829],"length":1,"stats":{"Line":24},"fn_name":null},{"line":278,"address":[4528305,4527777],"length":1,"stats":{"Line":5},"fn_name":null},{"line":283,"address":[5892880],"length":1,"stats":{"Line":15},"fn_name":"usize_to_u32"},{"line":284,"address":[5892889],"length":1,"stats":{"Line":14},"fn_name":null},{"line":285,"address":[5892918],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[5892901],"length":1,"stats":{"Line":15},"fn_name":null}],"covered":102,"coverable":106},{"path":["/","usr","src","regex","src","cache.rs"],"content":"// This module defines a common API for caching internal runtime state.\n// The `thread_local` crate provides an extremely optimized version of this.\n// However, if the perf-cache feature is disabled, then we drop the\n// thread_local dependency and instead use a pretty naive caching mechanism\n// with a mutex.\n//\n// Strictly speaking, the CachedGuard isn't necessary for the much more\n// flexible thread_local API, but implementing thread_local's API doesn't\n// seem possible in purely safe code.\n\npub use self::imp::{Cached, CachedGuard};\n\n#[cfg(feature = \"perf-cache\")]\nmod imp {\n    use thread_local::CachedThreadLocal;\n\n    #[derive(Debug)]\n    pub struct Cached<T: Send>(CachedThreadLocal<T>);\n\n    #[derive(Debug)]\n    pub struct CachedGuard<'a, T: 'a>(&'a T);\n\n    impl<T: Send> Cached<T> {\n        pub fn new() -> Cached<T> {\n            Cached(CachedThreadLocal::new())\n        }\n\n        pub fn get_or(&self, create: impl FnOnce() -> T) -> CachedGuard<T> {\n            CachedGuard(self.0.get_or(|| create()))\n        }\n    }\n\n    impl<'a, T: Send> CachedGuard<'a, T> {\n        pub fn value(&self) -> &T {\n            self.0\n        }\n    }\n}\n\n#[cfg(not(feature = \"perf-cache\"))]\nmod imp {\n    use std::marker::PhantomData;\n    use std::panic::UnwindSafe;\n    use std::sync::Mutex;\n\n    #[derive(Debug)]\n    pub struct Cached<T: Send> {\n        stack: Mutex<Vec<T>>,\n        /// When perf-cache is enabled, the thread_local crate is used, and\n        /// its CachedThreadLocal impls Send, Sync and UnwindSafe, but NOT\n        /// RefUnwindSafe. However, a Mutex impls RefUnwindSafe. So in order\n        /// to keep the APIs consistent regardless of whether perf-cache is\n        /// enabled, we force this type to NOT impl RefUnwindSafe too.\n        ///\n        /// Ideally, we should always impl RefUnwindSafe, but it seems a little\n        /// tricky to do that right now.\n        ///\n        /// See also: https://github.com/rust-lang/regex/issues/576\n        _phantom: PhantomData<Box<dyn Send + Sync + UnwindSafe>>,\n    }\n\n    #[derive(Debug)]\n    pub struct CachedGuard<'a, T: 'a + Send> {\n        cache: &'a Cached<T>,\n        value: Option<T>,\n    }\n\n    impl<T: Send> Cached<T> {\n        pub fn new() -> Cached<T> {\n            Cached { stack: Mutex::new(vec![]), _phantom: PhantomData }\n        }\n\n        pub fn get_or(&self, create: impl FnOnce() -> T) -> CachedGuard<T> {\n            let mut stack = self.stack.lock().unwrap();\n            match stack.pop() {\n                None => CachedGuard { cache: self, value: Some(create()) },\n                Some(value) => CachedGuard { cache: self, value: Some(value) },\n            }\n        }\n\n        fn put(&self, value: T) {\n            let mut stack = self.stack.lock().unwrap();\n            stack.push(value);\n        }\n    }\n\n    impl<'a, T: Send> CachedGuard<'a, T> {\n        pub fn value(&self) -> &T {\n            self.value.as_ref().unwrap()\n        }\n    }\n\n    impl<'a, T: Send> Drop for CachedGuard<'a, T> {\n        fn drop(&mut self) {\n            if let Some(value) = self.value.take() {\n                self.cache.put(value);\n            }\n        }\n    }\n}\n","traces":[{"line":24,"address":[9698064],"length":1,"stats":{"Line":25},"fn_name":"new<core::cell::RefCell<regex::exec::ProgramCacheInner>>"},{"line":25,"address":[9055655],"length":1,"stats":{"Line":25},"fn_name":null},{"line":28,"address":[5174688],"length":1,"stats":{"Line":25},"fn_name":"get_or<core::cell::RefCell<regex::exec::ProgramCacheInner>,closure-0>"},{"line":29,"address":[9055797,9055824,9055841,9055742],"length":1,"stats":{"Line":96},"fn_name":"{{closure}}<core::cell::RefCell<regex::exec::ProgramCacheInner>,closure-0>"},{"line":34,"address":[9055872],"length":1,"stats":{"Line":17},"fn_name":"value<core::cell::RefCell<regex::exec::ProgramCacheInner>>"},{"line":35,"address":[9436389],"length":1,"stats":{"Line":19},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":6,"coverable":21},{"path":["/","usr","src","regex","src","compile.rs"],"content":"use std::collections::HashMap;\nuse std::iter;\nuse std::result;\nuse std::sync::Arc;\n\nuse syntax::hir::{self, Hir};\nuse syntax::is_word_byte;\nuse syntax::utf8::{Utf8Range, Utf8Sequence, Utf8Sequences};\n\nuse prog::{\n    EmptyLook, Inst, InstBytes, InstChar, InstEmptyLook, InstPtr, InstRanges,\n    InstSave, InstSplit, Program,\n};\n\nuse Error;\n\ntype Result = result::Result<Patch, Error>;\ntype ResultOrEmpty = result::Result<Option<Patch>, Error>;\n\n#[derive(Debug)]\nstruct Patch {\n    hole: Hole,\n    entry: InstPtr,\n}\n\n/// A compiler translates a regular expression AST to a sequence of\n/// instructions. The sequence of instructions represents an NFA.\npub struct Compiler {\n    insts: Vec<MaybeInst>,\n    compiled: Program,\n    capture_name_idx: HashMap<String, usize>,\n    num_exprs: usize,\n    size_limit: usize,\n    suffix_cache: SuffixCache,\n    utf8_seqs: Option<Utf8Sequences>,\n    byte_classes: ByteClassSet,\n}\n\nimpl Compiler {\n    /// Create a new regular expression compiler.\n    ///\n    /// Various options can be set before calling `compile` on an expression.\n    pub fn new() -> Self {\n        Compiler {\n            insts: vec![],\n            compiled: Program::new(),\n            capture_name_idx: HashMap::new(),\n            num_exprs: 0,\n            size_limit: 10 * (1 << 20),\n            suffix_cache: SuffixCache::new(1000),\n            utf8_seqs: Some(Utf8Sequences::new('\\x00', '\\x00')),\n            byte_classes: ByteClassSet::new(),\n        }\n    }\n\n    /// The size of the resulting program is limited by size_limit. If\n    /// the program approximately exceeds the given size (in bytes), then\n    /// compilation will stop and return an error.\n    pub fn size_limit(mut self, size_limit: usize) -> Self {\n        self.size_limit = size_limit;\n        self\n    }\n\n    /// If bytes is true, then the program is compiled as a byte based\n    /// automaton, which incorporates UTF-8 decoding into the machine. If it's\n    /// false, then the automaton is Unicode scalar value based, e.g., an\n    /// engine utilizing such an automaton is responsible for UTF-8 decoding.\n    ///\n    /// The specific invariant is that when returning a byte based machine,\n    /// the neither the `Char` nor `Ranges` instructions are produced.\n    /// Conversely, when producing a Unicode scalar value machine, the `Bytes`\n    /// instruction is never produced.\n    ///\n    /// Note that `dfa(true)` implies `bytes(true)`.\n    pub fn bytes(mut self, yes: bool) -> Self {\n        self.compiled.is_bytes = yes;\n        self\n    }\n\n    /// When disabled, the program compiled may match arbitrary bytes.\n    ///\n    /// When enabled (the default), all compiled programs exclusively match\n    /// valid UTF-8 bytes.\n    pub fn only_utf8(mut self, yes: bool) -> Self {\n        self.compiled.only_utf8 = yes;\n        self\n    }\n\n    /// When set, the machine returned is suitable for use in the DFA matching\n    /// engine.\n    ///\n    /// In particular, this ensures that if the regex is not anchored in the\n    /// beginning, then a preceding `.*?` is included in the program. (The NFA\n    /// based engines handle the preceding `.*?` explicitly, which is difficult\n    /// or impossible in the DFA engine.)\n    pub fn dfa(mut self, yes: bool) -> Self {\n        self.compiled.is_dfa = yes;\n        self\n    }\n\n    /// When set, the machine returned is suitable for matching text in\n    /// reverse. In particular, all concatenations are flipped.\n    pub fn reverse(mut self, yes: bool) -> Self {\n        self.compiled.is_reverse = yes;\n        self\n    }\n\n    /// Compile a regular expression given its AST.\n    ///\n    /// The compiler is guaranteed to succeed unless the program exceeds the\n    /// specified size limit. If the size limit is exceeded, then compilation\n    /// stops and returns an error.\n    pub fn compile(mut self, exprs: &[Hir]) -> result::Result<Program, Error> {\n        debug_assert!(!exprs.is_empty());\n        self.num_exprs = exprs.len();\n        if exprs.len() == 1 {\n            self.compile_one(&exprs[0])\n        } else {\n            self.compile_many(exprs)\n        }\n    }\n\n    fn compile_one(mut self, expr: &Hir) -> result::Result<Program, Error> {\n        // If we're compiling a forward DFA and we aren't anchored, then\n        // add a `.*?` before the first capture group.\n        // Other matching engines handle this by baking the logic into the\n        // matching engine itself.\n        let mut dotstar_patch = Patch { hole: Hole::None, entry: 0 };\n        self.compiled.is_anchored_start = expr.is_anchored_start();\n        self.compiled.is_anchored_end = expr.is_anchored_end();\n        if self.compiled.needs_dotstar() {\n            dotstar_patch = self.c_dotstar()?;\n            self.compiled.start = dotstar_patch.entry;\n        }\n        self.compiled.captures = vec![None];\n        let patch = self.c_capture(0, expr)?.unwrap_or(self.next_inst());\n        if self.compiled.needs_dotstar() {\n            self.fill(dotstar_patch.hole, patch.entry);\n        } else {\n            self.compiled.start = patch.entry;\n        }\n        self.fill_to_next(patch.hole);\n        self.compiled.matches = vec![self.insts.len()];\n        self.push_compiled(Inst::Match(0));\n        self.compile_finish()\n    }\n\n    fn compile_many(\n        mut self,\n        exprs: &[Hir],\n    ) -> result::Result<Program, Error> {\n        debug_assert!(exprs.len() > 1);\n\n        self.compiled.is_anchored_start =\n            exprs.iter().all(|e| e.is_anchored_start());\n        self.compiled.is_anchored_end =\n            exprs.iter().all(|e| e.is_anchored_end());\n        let mut dotstar_patch = Patch { hole: Hole::None, entry: 0 };\n        if self.compiled.needs_dotstar() {\n            dotstar_patch = self.c_dotstar()?;\n            self.compiled.start = dotstar_patch.entry;\n        } else {\n            self.compiled.start = 0; // first instruction is always split\n        }\n        self.fill_to_next(dotstar_patch.hole);\n\n        let mut prev_hole = Hole::None;\n        for (i, expr) in exprs[0..exprs.len() - 1].iter().enumerate() {\n            self.fill_to_next(prev_hole);\n            let split = self.push_split_hole();\n            let Patch { hole, entry } =\n                self.c_capture(0, expr)?.unwrap_or(self.next_inst());\n            self.fill_to_next(hole);\n            self.compiled.matches.push(self.insts.len());\n            self.push_compiled(Inst::Match(i));\n            prev_hole = self.fill_split(split, Some(entry), None);\n        }\n        let i = exprs.len() - 1;\n        let Patch { hole, entry } =\n            self.c_capture(0, &exprs[i])?.unwrap_or(self.next_inst());\n        self.fill(prev_hole, entry);\n        self.fill_to_next(hole);\n        self.compiled.matches.push(self.insts.len());\n        self.push_compiled(Inst::Match(i));\n        self.compile_finish()\n    }\n\n    fn compile_finish(mut self) -> result::Result<Program, Error> {\n        self.compiled.insts =\n            self.insts.into_iter().map(|inst| inst.unwrap()).collect();\n        self.compiled.byte_classes = self.byte_classes.byte_classes();\n        self.compiled.capture_name_idx = Arc::new(self.capture_name_idx);\n        Ok(self.compiled)\n    }\n\n    /// Compile expr into self.insts, returning a patch on success,\n    /// or an error if we run out of memory.\n    ///\n    /// All of the c_* methods of the compiler share the contract outlined\n    /// here.\n    ///\n    /// The main thing that a c_* method does is mutate `self.insts`\n    /// to add a list of mostly compiled instructions required to execute\n    /// the given expression. `self.insts` contains MaybeInsts rather than\n    /// Insts because there is some backpatching required.\n    ///\n    /// The `Patch` value returned by each c_* method provides metadata\n    /// about the compiled instructions emitted to `self.insts`. The\n    /// `entry` member of the patch refers to the first instruction\n    /// (the entry point), while the `hole` member contains zero or\n    /// more offsets to partial instructions that need to be backpatched.\n    /// The c_* routine can't know where its list of instructions are going to\n    /// jump to after execution, so it is up to the caller to patch\n    /// these jumps to point to the right place. So compiling some\n    /// expression, e, we would end up with a situation that looked like:\n    ///\n    /// ```text\n    /// self.insts = [ ..., i1, i2, ..., iexit1, ..., iexitn, ...]\n    ///                     ^              ^             ^\n    ///                     |                \\         /\n    ///                   entry                \\     /\n    ///                                         hole\n    /// ```\n    ///\n    /// To compile two expressions, e1 and e2, concatinated together we\n    /// would do:\n    ///\n    /// ```ignore\n    /// let patch1 = self.c(e1);\n    /// let patch2 = self.c(e2);\n    /// ```\n    ///\n    /// while leaves us with a situation that looks like\n    ///\n    /// ```text\n    /// self.insts = [ ..., i1, ..., iexit1, ..., i2, ..., iexit2 ]\n    ///                     ^        ^            ^        ^\n    ///                     |        |            |        |\n    ///                entry1        hole1   entry2        hole2\n    /// ```\n    ///\n    /// Then to merge the two patches together into one we would backpatch\n    /// hole1 with entry2 and return a new patch that enters at entry1\n    /// and has hole2 for a hole. In fact, if you look at the c_concat\n    /// method you will see that it does exactly this, though it handles\n    /// a list of expressions rather than just the two that we use for\n    /// an example.\n    ///\n    /// Ok(None) is returned when an expression is compiled to no\n    /// instruction, and so no patch.entry value makes sense.\n    fn c(&mut self, expr: &Hir) -> ResultOrEmpty {\n        use prog;\n        use syntax::hir::HirKind::*;\n\n        self.check_size()?;\n        match *expr.kind() {\n            Empty => Ok(None),\n            Literal(hir::Literal::Unicode(c)) => self.c_char(c),\n            Literal(hir::Literal::Byte(b)) => {\n                assert!(self.compiled.uses_bytes());\n                self.c_byte(b)\n            }\n            Class(hir::Class::Unicode(ref cls)) => self.c_class(cls.ranges()),\n            Class(hir::Class::Bytes(ref cls)) => {\n                if self.compiled.uses_bytes() {\n                    self.c_class_bytes(cls.ranges())\n                } else {\n                    assert!(cls.is_all_ascii());\n                    let mut char_ranges = vec![];\n                    for r in cls.iter() {\n                        let (s, e) = (r.start() as char, r.end() as char);\n                        char_ranges.push(hir::ClassUnicodeRange::new(s, e));\n                    }\n                    self.c_class(&char_ranges)\n                }\n            }\n            Anchor(hir::Anchor::StartLine) if self.compiled.is_reverse => {\n                self.byte_classes.set_range(b'\\n', b'\\n');\n                self.c_empty_look(prog::EmptyLook::EndLine)\n            }\n            Anchor(hir::Anchor::StartLine) => {\n                self.byte_classes.set_range(b'\\n', b'\\n');\n                self.c_empty_look(prog::EmptyLook::StartLine)\n            }\n            Anchor(hir::Anchor::EndLine) if self.compiled.is_reverse => {\n                self.byte_classes.set_range(b'\\n', b'\\n');\n                self.c_empty_look(prog::EmptyLook::StartLine)\n            }\n            Anchor(hir::Anchor::EndLine) => {\n                self.byte_classes.set_range(b'\\n', b'\\n');\n                self.c_empty_look(prog::EmptyLook::EndLine)\n            }\n            Anchor(hir::Anchor::StartText) if self.compiled.is_reverse => {\n                self.c_empty_look(prog::EmptyLook::EndText)\n            }\n            Anchor(hir::Anchor::StartText) => {\n                self.c_empty_look(prog::EmptyLook::StartText)\n            }\n            Anchor(hir::Anchor::EndText) if self.compiled.is_reverse => {\n                self.c_empty_look(prog::EmptyLook::StartText)\n            }\n            Anchor(hir::Anchor::EndText) => {\n                self.c_empty_look(prog::EmptyLook::EndText)\n            }\n            WordBoundary(hir::WordBoundary::Unicode) => {\n                if !cfg!(feature = \"unicode-perl\") {\n                    return Err(Error::Syntax(\n                        \"Unicode word boundaries are unavailable when \\\n                         the unicode-perl feature is disabled\"\n                            .to_string(),\n                    ));\n                }\n                self.compiled.has_unicode_word_boundary = true;\n                self.byte_classes.set_word_boundary();\n                self.c_empty_look(prog::EmptyLook::WordBoundary)\n            }\n            WordBoundary(hir::WordBoundary::UnicodeNegate) => {\n                if !cfg!(feature = \"unicode-perl\") {\n                    return Err(Error::Syntax(\n                        \"Unicode word boundaries are unavailable when \\\n                         the unicode-perl feature is disabled\"\n                            .to_string(),\n                    ));\n                }\n                self.compiled.has_unicode_word_boundary = true;\n                self.byte_classes.set_word_boundary();\n                self.c_empty_look(prog::EmptyLook::NotWordBoundary)\n            }\n            WordBoundary(hir::WordBoundary::Ascii) => {\n                self.byte_classes.set_word_boundary();\n                self.c_empty_look(prog::EmptyLook::WordBoundaryAscii)\n            }\n            WordBoundary(hir::WordBoundary::AsciiNegate) => {\n                self.byte_classes.set_word_boundary();\n                self.c_empty_look(prog::EmptyLook::NotWordBoundaryAscii)\n            }\n            Group(ref g) => match g.kind {\n                hir::GroupKind::NonCapturing => self.c(&g.hir),\n                hir::GroupKind::CaptureIndex(index) => {\n                    if index as usize >= self.compiled.captures.len() {\n                        self.compiled.captures.push(None);\n                    }\n                    self.c_capture(2 * index as usize, &g.hir)\n                }\n                hir::GroupKind::CaptureName { index, ref name } => {\n                    if index as usize >= self.compiled.captures.len() {\n                        let n = name.to_string();\n                        self.compiled.captures.push(Some(n.clone()));\n                        self.capture_name_idx.insert(n, index as usize);\n                    }\n                    self.c_capture(2 * index as usize, &g.hir)\n                }\n            },\n            Concat(ref es) => {\n                if self.compiled.is_reverse {\n                    self.c_concat(es.iter().rev())\n                } else {\n                    self.c_concat(es)\n                }\n            }\n            Alternation(ref es) => self.c_alternate(&**es),\n            Repetition(ref rep) => self.c_repeat(rep),\n        }\n    }\n\n    fn c_capture(&mut self, first_slot: usize, expr: &Hir) -> ResultOrEmpty {\n        if self.num_exprs > 1 || self.compiled.is_dfa {\n            // Don't ever compile Save instructions for regex sets because\n            // they are never used. They are also never used in DFA programs\n            // because DFAs can't handle captures.\n            self.c(expr)\n        } else {\n            let entry = self.insts.len();\n            let hole = self.push_hole(InstHole::Save { slot: first_slot });\n            let patch = self.c(expr)?.unwrap_or(self.next_inst());\n            self.fill(hole, patch.entry);\n            self.fill_to_next(patch.hole);\n            let hole = self.push_hole(InstHole::Save { slot: first_slot + 1 });\n            Ok(Some(Patch { hole: hole, entry: entry }))\n        }\n    }\n\n    fn c_dotstar(&mut self) -> Result {\n        Ok(if !self.compiled.only_utf8() {\n            self.c(&Hir::repetition(hir::Repetition {\n                kind: hir::RepetitionKind::ZeroOrMore,\n                greedy: false,\n                hir: Box::new(Hir::any(true)),\n            }))?\n            .unwrap()\n        } else {\n            self.c(&Hir::repetition(hir::Repetition {\n                kind: hir::RepetitionKind::ZeroOrMore,\n                greedy: false,\n                hir: Box::new(Hir::any(false)),\n            }))?\n            .unwrap()\n        })\n    }\n\n    fn c_char(&mut self, c: char) -> ResultOrEmpty {\n        if self.compiled.uses_bytes() {\n            if c.is_ascii() {\n                let b = c as u8;\n                let hole =\n                    self.push_hole(InstHole::Bytes { start: b, end: b });\n                self.byte_classes.set_range(b, b);\n                Ok(Some(Patch { hole, entry: self.insts.len() - 1 }))\n            } else {\n                self.c_class(&[hir::ClassUnicodeRange::new(c, c)])\n            }\n        } else {\n            let hole = self.push_hole(InstHole::Char { c: c });\n            Ok(Some(Patch { hole, entry: self.insts.len() - 1 }))\n        }\n    }\n\n    fn c_class(&mut self, ranges: &[hir::ClassUnicodeRange]) -> ResultOrEmpty {\n        assert!(!ranges.is_empty());\n        if self.compiled.uses_bytes() {\n            Ok(Some(CompileClass { c: self, ranges: ranges }.compile()?))\n        } else {\n            let ranges: Vec<(char, char)> =\n                ranges.iter().map(|r| (r.start(), r.end())).collect();\n            let hole = if ranges.len() == 1 && ranges[0].0 == ranges[0].1 {\n                self.push_hole(InstHole::Char { c: ranges[0].0 })\n            } else {\n                self.push_hole(InstHole::Ranges { ranges: ranges })\n            };\n            Ok(Some(Patch { hole: hole, entry: self.insts.len() - 1 }))\n        }\n    }\n\n    fn c_byte(&mut self, b: u8) -> ResultOrEmpty {\n        self.c_class_bytes(&[hir::ClassBytesRange::new(b, b)])\n    }\n\n    fn c_class_bytes(\n        &mut self,\n        ranges: &[hir::ClassBytesRange],\n    ) -> ResultOrEmpty {\n        debug_assert!(!ranges.is_empty());\n\n        let first_split_entry = self.insts.len();\n        let mut holes = vec![];\n        let mut prev_hole = Hole::None;\n        for r in &ranges[0..ranges.len() - 1] {\n            self.fill_to_next(prev_hole);\n            let split = self.push_split_hole();\n            let next = self.insts.len();\n            self.byte_classes.set_range(r.start(), r.end());\n            holes.push(self.push_hole(InstHole::Bytes {\n                start: r.start(),\n                end: r.end(),\n            }));\n            prev_hole = self.fill_split(split, Some(next), None);\n        }\n        let next = self.insts.len();\n        let r = &ranges[ranges.len() - 1];\n        self.byte_classes.set_range(r.start(), r.end());\n        holes.push(\n            self.push_hole(InstHole::Bytes { start: r.start(), end: r.end() }),\n        );\n        self.fill(prev_hole, next);\n        Ok(Some(Patch { hole: Hole::Many(holes), entry: first_split_entry }))\n    }\n\n    fn c_empty_look(&mut self, look: EmptyLook) -> ResultOrEmpty {\n        let hole = self.push_hole(InstHole::EmptyLook { look: look });\n        Ok(Some(Patch { hole: hole, entry: self.insts.len() - 1 }))\n    }\n\n    fn c_concat<'a, I>(&mut self, exprs: I) -> ResultOrEmpty\n    where\n        I: IntoIterator<Item = &'a Hir>,\n    {\n        let mut exprs = exprs.into_iter();\n        let Patch { mut hole, entry } = loop {\n            match exprs.next() {\n                None => return Ok(None),\n                Some(e) => {\n                    if let Some(p) = self.c(e)? {\n                        break p;\n                    }\n                }\n            }\n        };\n        for e in exprs {\n            if let Some(p) = self.c(e)? {\n                self.fill(hole, p.entry);\n                hole = p.hole;\n            }\n        }\n        Ok(Some(Patch { hole: hole, entry: entry }))\n    }\n\n    fn c_alternate(&mut self, exprs: &[Hir]) -> ResultOrEmpty {\n        debug_assert!(\n            exprs.len() >= 2,\n            \"alternates must have at least 2 exprs\"\n        );\n\n        // Initial entry point is always the first split.\n        let first_split_entry = self.insts.len();\n\n        // Save up all of the holes from each alternate. They will all get\n        // patched to point to the same location.\n        let mut holes = vec![];\n\n        // true indicates that the hole is a split where we want to fill\n        // the second branch.\n        let mut prev_hole = (Hole::None, false);\n        for e in &exprs[0..exprs.len() - 1] {\n            if prev_hole.1 {\n                let next = self.insts.len();\n                self.fill_split(prev_hole.0, None, Some(next));\n            } else {\n                self.fill_to_next(prev_hole.0);\n            }\n            let split = self.push_split_hole();\n            if let Some(Patch { hole, entry }) = self.c(e)? {\n                holes.push(hole);\n                prev_hole = (self.fill_split(split, Some(entry), None), false);\n            } else {\n                let (split1, split2) = split.dup_one();\n                holes.push(split1);\n                prev_hole = (split2, true);\n            }\n        }\n        if let Some(Patch { hole, entry }) = self.c(&exprs[exprs.len() - 1])? {\n            holes.push(hole);\n            if prev_hole.1 {\n                self.fill_split(prev_hole.0, None, Some(entry));\n            } else {\n                self.fill(prev_hole.0, entry);\n            }\n        } else {\n            // We ignore prev_hole.1. When it's true, it means we have two\n            // empty branches both pushing prev_hole.0 into holes, so both\n            // branches will go to the same place anyway.\n            holes.push(prev_hole.0);\n        }\n        Ok(Some(Patch { hole: Hole::Many(holes), entry: first_split_entry }))\n    }\n\n    fn c_repeat(&mut self, rep: &hir::Repetition) -> ResultOrEmpty {\n        use syntax::hir::RepetitionKind::*;\n        match rep.kind {\n            ZeroOrOne => self.c_repeat_zero_or_one(&rep.hir, rep.greedy),\n            ZeroOrMore => self.c_repeat_zero_or_more(&rep.hir, rep.greedy),\n            OneOrMore => self.c_repeat_one_or_more(&rep.hir, rep.greedy),\n            Range(hir::RepetitionRange::Exactly(min_max)) => {\n                self.c_repeat_range(&rep.hir, rep.greedy, min_max, min_max)\n            }\n            Range(hir::RepetitionRange::AtLeast(min)) => {\n                self.c_repeat_range_min_or_more(&rep.hir, rep.greedy, min)\n            }\n            Range(hir::RepetitionRange::Bounded(min, max)) => {\n                self.c_repeat_range(&rep.hir, rep.greedy, min, max)\n            }\n        }\n    }\n\n    fn c_repeat_zero_or_one(\n        &mut self,\n        expr: &Hir,\n        greedy: bool,\n    ) -> ResultOrEmpty {\n        let split_entry = self.insts.len();\n        let split = self.push_split_hole();\n        let Patch { hole: hole_rep, entry: entry_rep } = match self.c(expr)? {\n            Some(p) => p,\n            None => return self.pop_split_hole(),\n        };\n        let split_hole = if greedy {\n            self.fill_split(split, Some(entry_rep), None)\n        } else {\n            self.fill_split(split, None, Some(entry_rep))\n        };\n        let holes = vec![hole_rep, split_hole];\n        Ok(Some(Patch { hole: Hole::Many(holes), entry: split_entry }))\n    }\n\n    fn c_repeat_zero_or_more(\n        &mut self,\n        expr: &Hir,\n        greedy: bool,\n    ) -> ResultOrEmpty {\n        let split_entry = self.insts.len();\n        let split = self.push_split_hole();\n        let Patch { hole: hole_rep, entry: entry_rep } = match self.c(expr)? {\n            Some(p) => p,\n            None => return self.pop_split_hole(),\n        };\n\n        self.fill(hole_rep, split_entry);\n        let split_hole = if greedy {\n            self.fill_split(split, Some(entry_rep), None)\n        } else {\n            self.fill_split(split, None, Some(entry_rep))\n        };\n        Ok(Some(Patch { hole: split_hole, entry: split_entry }))\n    }\n\n    fn c_repeat_one_or_more(\n        &mut self,\n        expr: &Hir,\n        greedy: bool,\n    ) -> ResultOrEmpty {\n        let Patch { hole: hole_rep, entry: entry_rep } = match self.c(expr)? {\n            Some(p) => p,\n            None => return Ok(None),\n        };\n        self.fill_to_next(hole_rep);\n        let split = self.push_split_hole();\n\n        let split_hole = if greedy {\n            self.fill_split(split, Some(entry_rep), None)\n        } else {\n            self.fill_split(split, None, Some(entry_rep))\n        };\n        Ok(Some(Patch { hole: split_hole, entry: entry_rep }))\n    }\n\n    fn c_repeat_range_min_or_more(\n        &mut self,\n        expr: &Hir,\n        greedy: bool,\n        min: u32,\n    ) -> ResultOrEmpty {\n        let min = u32_to_usize(min);\n        // Using next_inst() is ok, because we can't return it (concat would\n        // have to return Some(_) while c_repeat_range_min_or_more returns\n        // None).\n        let patch_concat = self\n            .c_concat(iter::repeat(expr).take(min))?\n            .unwrap_or(self.next_inst());\n        if let Some(patch_rep) = self.c_repeat_zero_or_more(expr, greedy)? {\n            self.fill(patch_concat.hole, patch_rep.entry);\n            Ok(Some(Patch { hole: patch_rep.hole, entry: patch_concat.entry }))\n        } else {\n            Ok(None)\n        }\n    }\n\n    fn c_repeat_range(\n        &mut self,\n        expr: &Hir,\n        greedy: bool,\n        min: u32,\n        max: u32,\n    ) -> ResultOrEmpty {\n        let (min, max) = (u32_to_usize(min), u32_to_usize(max));\n        debug_assert!(min <= max);\n        let patch_concat = self.c_concat(iter::repeat(expr).take(min))?;\n        if min == max {\n            return Ok(patch_concat);\n        }\n        // Same reasoning as in c_repeat_range_min_or_more (we know that min <\n        // max at this point).\n        let patch_concat = patch_concat.unwrap_or(self.next_inst());\n        let initial_entry = patch_concat.entry;\n        // It is much simpler to compile, e.g., `a{2,5}` as:\n        //\n        //     aaa?a?a?\n        //\n        // But you end up with a sequence of instructions like this:\n        //\n        //     0: 'a'\n        //     1: 'a',\n        //     2: split(3, 4)\n        //     3: 'a'\n        //     4: split(5, 6)\n        //     5: 'a'\n        //     6: split(7, 8)\n        //     7: 'a'\n        //     8: MATCH\n        //\n        // This is *incredibly* inefficient because the splits end\n        // up forming a chain, which has to be resolved everything a\n        // transition is followed.\n        let mut holes = vec![];\n        let mut prev_hole = patch_concat.hole;\n        for _ in min..max {\n            self.fill_to_next(prev_hole);\n            let split = self.push_split_hole();\n            let Patch { hole, entry } = match self.c(expr)? {\n                Some(p) => p,\n                None => return self.pop_split_hole(),\n            };\n            prev_hole = hole;\n            if greedy {\n                holes.push(self.fill_split(split, Some(entry), None));\n            } else {\n                holes.push(self.fill_split(split, None, Some(entry)));\n            }\n        }\n        holes.push(prev_hole);\n        Ok(Some(Patch { hole: Hole::Many(holes), entry: initial_entry }))\n    }\n\n    /// Can be used as a default value for the c_* functions when the call to\n    /// c_function is followed by inserting at least one instruction that is\n    /// always executed after the ones written by the c* function.\n    fn next_inst(&self) -> Patch {\n        Patch { hole: Hole::None, entry: self.insts.len() }\n    }\n\n    fn fill(&mut self, hole: Hole, goto: InstPtr) {\n        match hole {\n            Hole::None => {}\n            Hole::One(pc) => {\n                self.insts[pc].fill(goto);\n            }\n            Hole::Many(holes) => {\n                for hole in holes {\n                    self.fill(hole, goto);\n                }\n            }\n        }\n    }\n\n    fn fill_to_next(&mut self, hole: Hole) {\n        let next = self.insts.len();\n        self.fill(hole, next);\n    }\n\n    fn fill_split(\n        &mut self,\n        hole: Hole,\n        goto1: Option<InstPtr>,\n        goto2: Option<InstPtr>,\n    ) -> Hole {\n        match hole {\n            Hole::None => Hole::None,\n            Hole::One(pc) => match (goto1, goto2) {\n                (Some(goto1), Some(goto2)) => {\n                    self.insts[pc].fill_split(goto1, goto2);\n                    Hole::None\n                }\n                (Some(goto1), None) => {\n                    self.insts[pc].half_fill_split_goto1(goto1);\n                    Hole::One(pc)\n                }\n                (None, Some(goto2)) => {\n                    self.insts[pc].half_fill_split_goto2(goto2);\n                    Hole::One(pc)\n                }\n                (None, None) => unreachable!(\n                    \"at least one of the split \\\n                     holes must be filled\"\n                ),\n            },\n            Hole::Many(holes) => {\n                let mut new_holes = vec![];\n                for hole in holes {\n                    new_holes.push(self.fill_split(hole, goto1, goto2));\n                }\n                if new_holes.is_empty() {\n                    Hole::None\n                } else if new_holes.len() == 1 {\n                    new_holes.pop().unwrap()\n                } else {\n                    Hole::Many(new_holes)\n                }\n            }\n        }\n    }\n\n    fn push_compiled(&mut self, inst: Inst) {\n        self.insts.push(MaybeInst::Compiled(inst));\n    }\n\n    fn push_hole(&mut self, inst: InstHole) -> Hole {\n        let hole = self.insts.len();\n        self.insts.push(MaybeInst::Uncompiled(inst));\n        Hole::One(hole)\n    }\n\n    fn push_split_hole(&mut self) -> Hole {\n        let hole = self.insts.len();\n        self.insts.push(MaybeInst::Split);\n        Hole::One(hole)\n    }\n\n    fn pop_split_hole(&mut self) -> ResultOrEmpty {\n        self.insts.pop();\n        Ok(None)\n    }\n\n    fn check_size(&self) -> result::Result<(), Error> {\n        use std::mem::size_of;\n\n        if self.insts.len() * size_of::<Inst>() > self.size_limit {\n            Err(Error::CompiledTooBig(self.size_limit))\n        } else {\n            Ok(())\n        }\n    }\n}\n\n#[derive(Debug)]\nenum Hole {\n    None,\n    One(InstPtr),\n    Many(Vec<Hole>),\n}\n\nimpl Hole {\n    fn dup_one(self) -> (Self, Self) {\n        match self {\n            Hole::One(pc) => (Hole::One(pc), Hole::One(pc)),\n            Hole::None | Hole::Many(_) => {\n                unreachable!(\"must be called on single hole\")\n            }\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\nenum MaybeInst {\n    Compiled(Inst),\n    Uncompiled(InstHole),\n    Split,\n    Split1(InstPtr),\n    Split2(InstPtr),\n}\n\nimpl MaybeInst {\n    fn fill(&mut self, goto: InstPtr) {\n        let maybeinst = match *self {\n            MaybeInst::Split => MaybeInst::Split1(goto),\n            MaybeInst::Uncompiled(ref inst) => {\n                MaybeInst::Compiled(inst.fill(goto))\n            }\n            MaybeInst::Split1(goto1) => {\n                MaybeInst::Compiled(Inst::Split(InstSplit {\n                    goto1: goto1,\n                    goto2: goto,\n                }))\n            }\n            MaybeInst::Split2(goto2) => {\n                MaybeInst::Compiled(Inst::Split(InstSplit {\n                    goto1: goto,\n                    goto2: goto2,\n                }))\n            }\n            _ => unreachable!(\n                \"not all instructions were compiled! \\\n                 found uncompiled instruction: {:?}\",\n                self\n            ),\n        };\n        *self = maybeinst;\n    }\n\n    fn fill_split(&mut self, goto1: InstPtr, goto2: InstPtr) {\n        let filled = match *self {\n            MaybeInst::Split => {\n                Inst::Split(InstSplit { goto1: goto1, goto2: goto2 })\n            }\n            _ => unreachable!(\n                \"must be called on Split instruction, \\\n                 instead it was called on: {:?}\",\n                self\n            ),\n        };\n        *self = MaybeInst::Compiled(filled);\n    }\n\n    fn half_fill_split_goto1(&mut self, goto1: InstPtr) {\n        let half_filled = match *self {\n            MaybeInst::Split => goto1,\n            _ => unreachable!(\n                \"must be called on Split instruction, \\\n                 instead it was called on: {:?}\",\n                self\n            ),\n        };\n        *self = MaybeInst::Split1(half_filled);\n    }\n\n    fn half_fill_split_goto2(&mut self, goto2: InstPtr) {\n        let half_filled = match *self {\n            MaybeInst::Split => goto2,\n            _ => unreachable!(\n                \"must be called on Split instruction, \\\n                 instead it was called on: {:?}\",\n                self\n            ),\n        };\n        *self = MaybeInst::Split2(half_filled);\n    }\n\n    fn unwrap(self) -> Inst {\n        match self {\n            MaybeInst::Compiled(inst) => inst,\n            _ => unreachable!(\n                \"must be called on a compiled instruction, \\\n                 instead it was called on: {:?}\",\n                self\n            ),\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\nenum InstHole {\n    Save { slot: usize },\n    EmptyLook { look: EmptyLook },\n    Char { c: char },\n    Ranges { ranges: Vec<(char, char)> },\n    Bytes { start: u8, end: u8 },\n}\n\nimpl InstHole {\n    fn fill(&self, goto: InstPtr) -> Inst {\n        match *self {\n            InstHole::Save { slot } => {\n                Inst::Save(InstSave { goto: goto, slot: slot })\n            }\n            InstHole::EmptyLook { look } => {\n                Inst::EmptyLook(InstEmptyLook { goto: goto, look: look })\n            }\n            InstHole::Char { c } => Inst::Char(InstChar { goto: goto, c: c }),\n            InstHole::Ranges { ref ranges } => {\n                Inst::Ranges(InstRanges { goto: goto, ranges: ranges.clone() })\n            }\n            InstHole::Bytes { start, end } => {\n                Inst::Bytes(InstBytes { goto: goto, start: start, end: end })\n            }\n        }\n    }\n}\n\nstruct CompileClass<'a, 'b> {\n    c: &'a mut Compiler,\n    ranges: &'b [hir::ClassUnicodeRange],\n}\n\nimpl<'a, 'b> CompileClass<'a, 'b> {\n    fn compile(mut self) -> Result {\n        let mut holes = vec![];\n        let mut initial_entry = None;\n        let mut last_split = Hole::None;\n        let mut utf8_seqs = self.c.utf8_seqs.take().unwrap();\n        self.c.suffix_cache.clear();\n\n        for (i, range) in self.ranges.iter().enumerate() {\n            let is_last_range = i + 1 == self.ranges.len();\n            utf8_seqs.reset(range.start(), range.end());\n            let mut it = (&mut utf8_seqs).peekable();\n            loop {\n                let utf8_seq = match it.next() {\n                    None => break,\n                    Some(utf8_seq) => utf8_seq,\n                };\n                if is_last_range && it.peek().is_none() {\n                    let Patch { hole, entry } = self.c_utf8_seq(&utf8_seq)?;\n                    holes.push(hole);\n                    self.c.fill(last_split, entry);\n                    last_split = Hole::None;\n                    if initial_entry.is_none() {\n                        initial_entry = Some(entry);\n                    }\n                } else {\n                    if initial_entry.is_none() {\n                        initial_entry = Some(self.c.insts.len());\n                    }\n                    self.c.fill_to_next(last_split);\n                    last_split = self.c.push_split_hole();\n                    let Patch { hole, entry } = self.c_utf8_seq(&utf8_seq)?;\n                    holes.push(hole);\n                    last_split =\n                        self.c.fill_split(last_split, Some(entry), None);\n                }\n            }\n        }\n        self.c.utf8_seqs = Some(utf8_seqs);\n        Ok(Patch { hole: Hole::Many(holes), entry: initial_entry.unwrap() })\n    }\n\n    fn c_utf8_seq(&mut self, seq: &Utf8Sequence) -> Result {\n        if self.c.compiled.is_reverse {\n            self.c_utf8_seq_(seq)\n        } else {\n            self.c_utf8_seq_(seq.into_iter().rev())\n        }\n    }\n\n    fn c_utf8_seq_<'r, I>(&mut self, seq: I) -> Result\n    where\n        I: IntoIterator<Item = &'r Utf8Range>,\n    {\n        // The initial instruction for each UTF-8 sequence should be the same.\n        let mut from_inst = ::std::usize::MAX;\n        let mut last_hole = Hole::None;\n        for byte_range in seq {\n            let key = SuffixCacheKey {\n                from_inst: from_inst,\n                start: byte_range.start,\n                end: byte_range.end,\n            };\n            {\n                let pc = self.c.insts.len();\n                if let Some(cached_pc) = self.c.suffix_cache.get(key, pc) {\n                    from_inst = cached_pc;\n                    continue;\n                }\n            }\n            self.c.byte_classes.set_range(byte_range.start, byte_range.end);\n            if from_inst == ::std::usize::MAX {\n                last_hole = self.c.push_hole(InstHole::Bytes {\n                    start: byte_range.start,\n                    end: byte_range.end,\n                });\n            } else {\n                self.c.push_compiled(Inst::Bytes(InstBytes {\n                    goto: from_inst,\n                    start: byte_range.start,\n                    end: byte_range.end,\n                }));\n            }\n            from_inst = self.c.insts.len().checked_sub(1).unwrap();\n            debug_assert!(from_inst < ::std::usize::MAX);\n        }\n        debug_assert!(from_inst < ::std::usize::MAX);\n        Ok(Patch { hole: last_hole, entry: from_inst })\n    }\n}\n\n/// `SuffixCache` is a simple bounded hash map for caching suffix entries in\n/// UTF-8 automata. For example, consider the Unicode range \\u{0}-\\u{FFFF}.\n/// The set of byte ranges looks like this:\n///\n/// [0-7F]\n/// [C2-DF][80-BF]\n/// [E0][A0-BF][80-BF]\n/// [E1-EC][80-BF][80-BF]\n/// [ED][80-9F][80-BF]\n/// [EE-EF][80-BF][80-BF]\n///\n/// Each line above translates to one alternate in the compiled regex program.\n/// However, all but one of the alternates end in the same suffix, which is\n/// a waste of an instruction. The suffix cache facilitates reusing them across\n/// alternates.\n///\n/// Note that a HashMap could be trivially used for this, but we don't need its\n/// overhead. Some small bounded space (LRU style) is more than enough.\n///\n/// This uses similar idea to [`SparseSet`](../sparse/struct.SparseSet.html),\n/// except it uses hashes as original indices and then compares full keys for\n/// validation against `dense` array.\nstruct SuffixCache {\n    sparse: Box<[usize]>,\n    dense: Vec<SuffixCacheEntry>,\n}\n\n#[derive(Clone, Copy, Debug, Default, Eq, Hash, PartialEq)]\nstruct SuffixCacheEntry {\n    key: SuffixCacheKey,\n    pc: InstPtr,\n}\n\n#[derive(Clone, Copy, Debug, Default, Eq, Hash, PartialEq)]\nstruct SuffixCacheKey {\n    from_inst: InstPtr,\n    start: u8,\n    end: u8,\n}\n\nimpl SuffixCache {\n    fn new(size: usize) -> Self {\n        SuffixCache {\n            sparse: vec![0usize; size].into(),\n            dense: Vec::with_capacity(size),\n        }\n    }\n\n    fn get(&mut self, key: SuffixCacheKey, pc: InstPtr) -> Option<InstPtr> {\n        let hash = self.hash(&key);\n        let pos = &mut self.sparse[hash];\n        if let Some(entry) = self.dense.get(*pos) {\n            if entry.key == key {\n                return Some(entry.pc);\n            }\n        }\n        *pos = self.dense.len();\n        self.dense.push(SuffixCacheEntry { key: key, pc: pc });\n        None\n    }\n\n    fn clear(&mut self) {\n        self.dense.clear();\n    }\n\n    fn hash(&self, suffix: &SuffixCacheKey) -> usize {\n        // Basic FNV-1a hash as described:\n        // https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function\n        const FNV_PRIME: u64 = 1099511628211;\n        let mut h = 14695981039346656037;\n        h = (h ^ (suffix.from_inst as u64)).wrapping_mul(FNV_PRIME);\n        h = (h ^ (suffix.start as u64)).wrapping_mul(FNV_PRIME);\n        h = (h ^ (suffix.end as u64)).wrapping_mul(FNV_PRIME);\n        (h as usize) % self.sparse.len()\n    }\n}\n\nstruct ByteClassSet([bool; 256]);\n\nimpl ByteClassSet {\n    fn new() -> Self {\n        ByteClassSet([false; 256])\n    }\n\n    fn set_range(&mut self, start: u8, end: u8) {\n        debug_assert!(start <= end);\n        if start > 0 {\n            self.0[start as usize - 1] = true;\n        }\n        self.0[end as usize] = true;\n    }\n\n    fn set_word_boundary(&mut self) {\n        // We need to mark all ranges of bytes whose pairs result in\n        // evaluating \\b differently.\n        let iswb = is_word_byte;\n        let mut b1: u16 = 0;\n        let mut b2: u16;\n        while b1 <= 255 {\n            b2 = b1 + 1;\n            while b2 <= 255 && iswb(b1 as u8) == iswb(b2 as u8) {\n                b2 += 1;\n            }\n            self.set_range(b1 as u8, (b2 - 1) as u8);\n            b1 = b2;\n        }\n    }\n\n    fn byte_classes(&self) -> Vec<u8> {\n        // N.B. If you're debugging the DFA, it's useful to simply return\n        // `(0..256).collect()`, which effectively removes the byte classes\n        // and makes the transitions easier to read.\n        // (0usize..256).map(|x| x as u8).collect()\n        let mut byte_classes = vec![0; 256];\n        let mut class = 0u8;\n        let mut i = 0;\n        loop {\n            byte_classes[i] = class as u8;\n            if i >= 255 {\n                break;\n            }\n            if self.0[i] {\n                class = class.checked_add(1).unwrap();\n            }\n            i += 1;\n        }\n        byte_classes\n    }\n}\n\nfn u32_to_usize(n: u32) -> usize {\n    // In case usize is less than 32 bits, we need to guard against overflow.\n    // On most platforms this compiles to nothing.\n    // TODO Use `std::convert::TryFrom` once it's stable.\n    if (n as u64) > (::std::usize::MAX as u64) {\n        panic!(\"BUG: {} is too big to be pointer sized\", n)\n    }\n    n as usize\n}\n\n#[cfg(test)]\nmod tests {\n    use super::ByteClassSet;\n\n    #[test]\n    fn byte_classes() {\n        let mut set = ByteClassSet::new();\n        set.set_range(b'a', b'z');\n        let classes = set.byte_classes();\n        assert_eq!(classes[0], 0);\n        assert_eq!(classes[1], 0);\n        assert_eq!(classes[2], 0);\n        assert_eq!(classes[b'a' as usize - 1], 0);\n        assert_eq!(classes[b'a' as usize], 1);\n        assert_eq!(classes[b'm' as usize], 1);\n        assert_eq!(classes[b'z' as usize], 1);\n        assert_eq!(classes[b'z' as usize + 1], 2);\n        assert_eq!(classes[254], 2);\n        assert_eq!(classes[255], 2);\n\n        let mut set = ByteClassSet::new();\n        set.set_range(0, 2);\n        set.set_range(4, 6);\n        let classes = set.byte_classes();\n        assert_eq!(classes[0], 0);\n        assert_eq!(classes[1], 0);\n        assert_eq!(classes[2], 0);\n        assert_eq!(classes[3], 1);\n        assert_eq!(classes[4], 2);\n        assert_eq!(classes[5], 2);\n        assert_eq!(classes[6], 2);\n        assert_eq!(classes[7], 3);\n        assert_eq!(classes[255], 3);\n    }\n\n    #[test]\n    fn full_byte_classes() {\n        let mut set = ByteClassSet::new();\n        for i in 0..256u16 {\n            set.set_range(i as u8, i as u8);\n        }\n        assert_eq!(set.byte_classes().len(), 256);\n    }\n}\n","traces":[{"line":43,"address":[5749184,5749248],"length":1,"stats":{"Line":27},"fn_name":"new"},{"line":45,"address":[5749211],"length":1,"stats":{"Line":27},"fn_name":null},{"line":46,"address":[5749268],"length":1,"stats":{"Line":27},"fn_name":null},{"line":47,"address":[5749295],"length":1,"stats":{"Line":27},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[5749315],"length":1,"stats":{"Line":27},"fn_name":null},{"line":51,"address":[5749349],"length":1,"stats":{"Line":27},"fn_name":null},{"line":52,"address":[5749414],"length":1,"stats":{"Line":27},"fn_name":null},{"line":59,"address":[5749808],"length":1,"stats":{"Line":27},"fn_name":"size_limit"},{"line":60,"address":[5749820],"length":1,"stats":{"Line":27},"fn_name":null},{"line":61,"address":[5749827],"length":1,"stats":{"Line":27},"fn_name":null},{"line":75,"address":[5749856],"length":1,"stats":{"Line":27},"fn_name":"bytes"},{"line":76,"address":[5749872],"length":1,"stats":{"Line":27},"fn_name":null},{"line":77,"address":[5749881],"length":1,"stats":{"Line":27},"fn_name":null},{"line":84,"address":[5749920],"length":1,"stats":{"Line":27},"fn_name":"only_utf8"},{"line":85,"address":[5749936],"length":1,"stats":{"Line":27},"fn_name":null},{"line":86,"address":[5749945],"length":1,"stats":{"Line":27},"fn_name":null},{"line":96,"address":[5749984],"length":1,"stats":{"Line":27},"fn_name":"dfa"},{"line":97,"address":[5750000],"length":1,"stats":{"Line":27},"fn_name":null},{"line":98,"address":[5750009],"length":1,"stats":{"Line":27},"fn_name":null},{"line":103,"address":[5750048],"length":1,"stats":{"Line":19},"fn_name":"reverse"},{"line":104,"address":[5750064],"length":1,"stats":{"Line":19},"fn_name":null},{"line":105,"address":[5750073],"length":1,"stats":{"Line":19},"fn_name":null},{"line":113,"address":[5750112,5750742],"length":1,"stats":{"Line":27},"fn_name":"compile"},{"line":114,"address":[5750146,5750255],"length":1,"stats":{"Line":27},"fn_name":null},{"line":115,"address":[5750229,5750298],"length":1,"stats":{"Line":54},"fn_name":null},{"line":116,"address":[5750531,5750305],"length":1,"stats":{"Line":49},"fn_name":null},{"line":117,"address":[5750776,5750710,5750421],"length":1,"stats":{"Line":27},"fn_name":null},{"line":119,"address":[5750342],"length":1,"stats":{"Line":10},"fn_name":null},{"line":123,"address":[5751039,5750832],"length":1,"stats":{"Line":27},"fn_name":"compile_one"},{"line":128,"address":[5750858],"length":1,"stats":{"Line":27},"fn_name":null},{"line":129,"address":[5751077,5751001],"length":1,"stats":{"Line":54},"fn_name":null},{"line":130,"address":[5751090],"length":1,"stats":{"Line":27},"fn_name":null},{"line":131,"address":[5752922,5751127],"length":1,"stats":{"Line":36},"fn_name":null},{"line":132,"address":[5752826,5751167,5751450],"length":1,"stats":{"Line":8},"fn_name":null},{"line":133,"address":[5752905],"length":1,"stats":{"Line":9},"fn_name":null},{"line":135,"address":[5751539,5752927],"length":1,"stats":{"Line":27},"fn_name":null},{"line":136,"address":[5751934,5753043,5751650],"length":1,"stats":{"Line":45},"fn_name":null},{"line":137,"address":[5752033,5752123,5752059,5751999],"length":1,"stats":{"Line":38},"fn_name":null},{"line":138,"address":[5752061],"length":1,"stats":{"Line":8},"fn_name":null},{"line":140,"address":[5752039],"length":1,"stats":{"Line":10},"fn_name":null},{"line":142,"address":[5752125],"length":1,"stats":{"Line":10},"fn_name":null},{"line":143,"address":[5752190,5753131],"length":1,"stats":{"Line":10},"fn_name":null},{"line":144,"address":[5753255],"length":1,"stats":{"Line":10},"fn_name":null},{"line":145,"address":[5752319],"length":1,"stats":{"Line":10},"fn_name":null},{"line":148,"address":[5753536,5753724],"length":1,"stats":{"Line":12},"fn_name":"compile_many"},{"line":152,"address":[5753747,5753805,5753570],"length":1,"stats":{"Line":26},"fn_name":null},{"line":154,"address":[5753899],"length":1,"stats":{"Line":17},"fn_name":null},{"line":155,"address":[5623504,5623518],"length":1,"stats":{"Line":57},"fn_name":"{{closure}}"},{"line":156,"address":[5754019],"length":1,"stats":{"Line":19},"fn_name":null},{"line":157,"address":[5623566,5623552],"length":1,"stats":{"Line":51},"fn_name":"{{closure}}"},{"line":158,"address":[5754035],"length":1,"stats":{"Line":18},"fn_name":null},{"line":159,"address":[5754167,5754099,5757586],"length":1,"stats":{"Line":57},"fn_name":null},{"line":160,"address":[5754477,5754188,5757478],"length":1,"stats":{"Line":19},"fn_name":null},{"line":161,"address":[5757563],"length":1,"stats":{"Line":20},"fn_name":null},{"line":163,"address":[5754156],"length":1,"stats":{"Line":18},"fn_name":null},{"line":165,"address":[5754489],"length":1,"stats":{"Line":18},"fn_name":null},{"line":167,"address":[5754552],"length":1,"stats":{"Line":19},"fn_name":null},{"line":168,"address":[5754572,5756085,5754994,5757941],"length":1,"stats":{"Line":40},"fn_name":null},{"line":169,"address":[5755060],"length":1,"stats":{"Line":19},"fn_name":null},{"line":170,"address":[5755149],"length":1,"stats":{"Line":20},"fn_name":null},{"line":171,"address":[5757708,5755525,5755189,5755538],"length":1,"stats":{"Line":19},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[5755646],"length":1,"stats":{"Line":20},"fn_name":null},{"line":174,"address":[5755741],"length":1,"stats":{"Line":19},"fn_name":null},{"line":175,"address":[5755808],"length":1,"stats":{"Line":20},"fn_name":null},{"line":176,"address":[5755851],"length":1,"stats":{"Line":19},"fn_name":null},{"line":178,"address":[5754959,5756095,5758051],"length":1,"stats":{"Line":39},"fn_name":null},{"line":179,"address":[5756562],"length":1,"stats":{"Line":19},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[5756618],"length":1,"stats":{"Line":20},"fn_name":null},{"line":182,"address":[5756703],"length":1,"stats":{"Line":19},"fn_name":null},{"line":183,"address":[5756774],"length":1,"stats":{"Line":20},"fn_name":null},{"line":184,"address":[5756841],"length":1,"stats":{"Line":19},"fn_name":null},{"line":185,"address":[5756884],"length":1,"stats":{"Line":20},"fn_name":null},{"line":188,"address":[5758192,5758300],"length":1,"stats":{"Line":22},"fn_name":"compile_finish"},{"line":189,"address":[5758527,5758357],"length":1,"stats":{"Line":22},"fn_name":null},{"line":190,"address":[5623612,5623600],"length":1,"stats":{"Line":92},"fn_name":"{{closure}}"},{"line":191,"address":[5758381,5758599],"length":1,"stats":{"Line":46},"fn_name":null},{"line":192,"address":[5758409,5758717],"length":1,"stats":{"Line":46},"fn_name":null},{"line":193,"address":[5758872],"length":1,"stats":{"Line":24},"fn_name":null},{"line":251,"address":[5759136,5759220],"length":1,"stats":{"Line":27},"fn_name":"c"},{"line":255,"address":[5759162,5759423,5759235],"length":1,"stats":{"Line":62},"fn_name":null},{"line":256,"address":[5762629,5761160,5761640,5762557,5759813,5760037,5760826,5761576,5759942,5759529,5760951,5760993,5761512,5759440,5761365,5761260,5762372,5759767,5761441,5761118],"length":1,"stats":{"Line":251},"fn_name":null},{"line":257,"address":[5759462,5759702],"length":1,"stats":{"Line":37},"fn_name":null},{"line":258,"address":[5759780,5759507],"length":1,"stats":{"Line":18},"fn_name":null},{"line":259,"address":[5759826],"length":1,"stats":{"Line":4},"fn_name":null},{"line":260,"address":[5759844,5759912],"length":1,"stats":{"Line":4},"fn_name":null},{"line":261,"address":[5759902],"length":1,"stats":{"Line":4},"fn_name":null},{"line":263,"address":[5759539,5759955],"length":1,"stats":{"Line":16},"fn_name":null},{"line":264,"address":[5760050],"length":1,"stats":{"Line":12},"fn_name":null},{"line":265,"address":[5760078,5760824,5760204],"length":1,"stats":{"Line":35},"fn_name":null},{"line":266,"address":[5760145],"length":1,"stats":{"Line":12},"fn_name":null},{"line":268,"address":[5760122,5760259,5760216],"length":1,"stats":{"Line":22},"fn_name":null},{"line":269,"address":[5760226],"length":1,"stats":{"Line":11},"fn_name":null},{"line":270,"address":[5760766,5760394,5760524,5760289],"length":1,"stats":{"Line":33},"fn_name":null},{"line":271,"address":[5760558],"length":1,"stats":{"Line":11},"fn_name":null},{"line":272,"address":[5760689],"length":1,"stats":{"Line":11},"fn_name":null},{"line":274,"address":[5760803,5760486],"length":1,"stats":{"Line":22},"fn_name":null},{"line":277,"address":[5760839,5759567],"length":1,"stats":{"Line":33},"fn_name":null},{"line":278,"address":[5760856],"length":1,"stats":{"Line":8},"fn_name":null},{"line":279,"address":[5760914],"length":1,"stats":{"Line":8},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[5760889],"length":1,"stats":{"Line":8},"fn_name":null},{"line":283,"address":[5760956],"length":1,"stats":{"Line":8},"fn_name":null},{"line":285,"address":[5761006],"length":1,"stats":{"Line":8},"fn_name":null},{"line":286,"address":[5761023],"length":1,"stats":{"Line":8},"fn_name":null},{"line":287,"address":[5761081],"length":1,"stats":{"Line":8},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[5761056],"length":1,"stats":{"Line":8},"fn_name":null},{"line":291,"address":[5761123],"length":1,"stats":{"Line":8},"fn_name":null},{"line":293,"address":[5761173],"length":1,"stats":{"Line":25},"fn_name":null},{"line":294,"address":[5761182],"length":1,"stats":{"Line":25},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[5761221],"length":1,"stats":{"Line":25},"fn_name":null},{"line":299,"address":[5761278],"length":1,"stats":{"Line":23},"fn_name":null},{"line":300,"address":[5761287],"length":1,"stats":{"Line":23},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[5761326],"length":1,"stats":{"Line":23},"fn_name":null},{"line":305,"address":[5759613],"length":1,"stats":{"Line":8},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[5761383],"length":1,"stats":{"Line":8},"fn_name":null},{"line":314,"address":[5761390],"length":1,"stats":{"Line":8},"fn_name":null},{"line":315,"address":[5761404],"length":1,"stats":{"Line":8},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[5761454],"length":1,"stats":{"Line":9},"fn_name":null},{"line":326,"address":[5761461],"length":1,"stats":{"Line":10},"fn_name":null},{"line":327,"address":[5761475],"length":1,"stats":{"Line":10},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[5761525],"length":1,"stats":{"Line":8},"fn_name":null},{"line":331,"address":[5761539],"length":1,"stats":{"Line":8},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[5761589],"length":1,"stats":{"Line":5},"fn_name":null},{"line":335,"address":[5761603],"length":1,"stats":{"Line":5},"fn_name":null},{"line":337,"address":[5761653,5762043,5761812,5761847,5762370],"length":1,"stats":{"Line":46},"fn_name":null},{"line":338,"address":[5761673,5761822],"length":1,"stats":{"Line":18},"fn_name":null},{"line":339,"address":[5761860],"length":1,"stats":{"Line":8},"fn_name":null},{"line":340,"address":[5761965,5761870],"length":1,"stats":{"Line":16},"fn_name":null},{"line":341,"address":[5761931],"length":1,"stats":{"Line":8},"fn_name":null},{"line":343,"address":[5762747,5761971],"length":1,"stats":{"Line":8},"fn_name":null},{"line":345,"address":[5761731],"length":1,"stats":{"Line":8},"fn_name":null},{"line":346,"address":[5762061,5761755],"length":1,"stats":{"Line":16},"fn_name":null},{"line":347,"address":[5762070],"length":1,"stats":{"Line":8},"fn_name":null},{"line":348,"address":[5762107],"length":1,"stats":{"Line":8},"fn_name":null},{"line":349,"address":[5762205],"length":1,"stats":{"Line":8},"fn_name":null},{"line":351,"address":[5762717,5762298],"length":1,"stats":{"Line":8},"fn_name":null},{"line":354,"address":[5762385],"length":1,"stats":{"Line":25},"fn_name":null},{"line":355,"address":[5762553,5762407],"length":1,"stats":{"Line":50},"fn_name":null},{"line":356,"address":[5762454],"length":1,"stats":{"Line":25},"fn_name":null},{"line":358,"address":[5762442],"length":1,"stats":{"Line":25},"fn_name":null},{"line":361,"address":[5762567],"length":1,"stats":{"Line":8},"fn_name":null},{"line":362,"address":[5759659],"length":1,"stats":{"Line":8},"fn_name":null},{"line":366,"address":[5762932,5762800],"length":1,"stats":{"Line":27},"fn_name":"c_capture"},{"line":367,"address":[5762834,5763001],"length":1,"stats":{"Line":46},"fn_name":null},{"line":371,"address":[5762996],"length":1,"stats":{"Line":25},"fn_name":null},{"line":373,"address":[5762952],"length":1,"stats":{"Line":27},"fn_name":null},{"line":374,"address":[5763011],"length":1,"stats":{"Line":27},"fn_name":null},{"line":375,"address":[5763070,5763367,5763416,5763977],"length":1,"stats":{"Line":43},"fn_name":null},{"line":376,"address":[5763473],"length":1,"stats":{"Line":22},"fn_name":null},{"line":377,"address":[5763554],"length":1,"stats":{"Line":22},"fn_name":null},{"line":378,"address":[5764118,5763619],"length":1,"stats":{"Line":21},"fn_name":null},{"line":379,"address":[5763691],"length":1,"stats":{"Line":24},"fn_name":null},{"line":383,"address":[5764160,5764210],"length":1,"stats":{"Line":8},"fn_name":"c_dotstar"},{"line":384,"address":[5764178,5764229,5765262,5764777],"length":1,"stats":{"Line":33},"fn_name":null},{"line":385,"address":[5764506,5764480,5764344],"length":1,"stats":{"Line":24},"fn_name":null},{"line":386,"address":[5764267],"length":1,"stats":{"Line":8},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[5764278],"length":1,"stats":{"Line":8},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[5764965,5764994,5764829],"length":1,"stats":{"Line":26},"fn_name":null},{"line":393,"address":[5764237],"length":1,"stats":{"Line":8},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[5764248],"length":1,"stats":{"Line":8},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[5765470,5765408],"length":1,"stats":{"Line":9},"fn_name":"c_char"},{"line":402,"address":[5765489,5766034,5765430],"length":1,"stats":{"Line":29},"fn_name":null},{"line":403,"address":[5765976,5766032,5765545],"length":1,"stats":{"Line":26},"fn_name":null},{"line":404,"address":[5765596],"length":1,"stats":{"Line":9},"fn_name":null},{"line":405,"address":[5765607],"length":1,"stats":{"Line":9},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[5765669],"length":1,"stats":{"Line":9},"fn_name":null},{"line":408,"address":[5766394,5765694],"length":1,"stats":{"Line":9},"fn_name":null},{"line":410,"address":[5765569,5765982],"length":1,"stats":{"Line":16},"fn_name":null},{"line":413,"address":[5765495],"length":1,"stats":{"Line":9},"fn_name":null},{"line":414,"address":[5766476,5766039,5766446],"length":1,"stats":{"Line":9},"fn_name":null},{"line":418,"address":[5766480,5766582],"length":1,"stats":{"Line":8},"fn_name":"c_class"},{"line":419,"address":[5766604,5766637,5766514],"length":1,"stats":{"Line":16},"fn_name":null},{"line":420,"address":[5766674,5767013,5766620],"length":1,"stats":{"Line":47},"fn_name":null},{"line":421,"address":[5766728,5767139,5767018,5766835],"length":1,"stats":{"Line":39},"fn_name":null},{"line":423,"address":[5623680,5623694],"length":1,"stats":{"Line":84},"fn_name":"{{closure}}"},{"line":424,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[5767539,5767215],"length":1,"stats":{"Line":26},"fn_name":null},{"line":426,"address":[5767474],"length":1,"stats":{"Line":6},"fn_name":null},{"line":428,"address":[5767351],"length":1,"stats":{"Line":22},"fn_name":null},{"line":430,"address":[5767543,5767963],"length":1,"stats":{"Line":20},"fn_name":null},{"line":434,"address":[5768000],"length":1,"stats":{"Line":4},"fn_name":"c_byte"},{"line":435,"address":[5768016],"length":1,"stats":{"Line":4},"fn_name":null},{"line":438,"address":[5768222,5768112],"length":1,"stats":{"Line":12},"fn_name":"c_class_bytes"},{"line":442,"address":[5768244,5768292,5768146],"length":1,"stats":{"Line":24},"fn_name":null},{"line":444,"address":[5768260],"length":1,"stats":{"Line":12},"fn_name":null},{"line":445,"address":[5768326],"length":1,"stats":{"Line":12},"fn_name":null},{"line":446,"address":[5768356],"length":1,"stats":{"Line":12},"fn_name":null},{"line":447,"address":[5768707,5768465,5769318,5768376,5770139],"length":1,"stats":{"Line":38},"fn_name":null},{"line":448,"address":[5768741],"length":1,"stats":{"Line":14},"fn_name":null},{"line":449,"address":[5768825],"length":1,"stats":{"Line":13},"fn_name":null},{"line":450,"address":[5768848],"length":1,"stats":{"Line":14},"fn_name":null},{"line":451,"address":[5768890],"length":1,"stats":{"Line":13},"fn_name":null},{"line":452,"address":[5769012],"length":1,"stats":{"Line":14},"fn_name":null},{"line":453,"address":[5768968],"length":1,"stats":{"Line":14},"fn_name":null},{"line":454,"address":[5768988],"length":1,"stats":{"Line":13},"fn_name":null},{"line":456,"address":[5769092],"length":1,"stats":{"Line":13},"fn_name":null},{"line":458,"address":[5769328,5768683],"length":1,"stats":{"Line":24},"fn_name":null},{"line":459,"address":[5770188,5769336],"length":1,"stats":{"Line":12},"fn_name":null},{"line":460,"address":[5769458],"length":1,"stats":{"Line":12},"fn_name":null},{"line":461,"address":[5769667],"length":1,"stats":{"Line":12},"fn_name":null},{"line":462,"address":[5769550],"length":1,"stats":{"Line":12},"fn_name":null},{"line":464,"address":[5769674],"length":1,"stats":{"Line":12},"fn_name":null},{"line":465,"address":[5769742],"length":1,"stats":{"Line":12},"fn_name":null},{"line":468,"address":[5770256,5770325],"length":1,"stats":{"Line":25},"fn_name":"c_empty_look"},{"line":469,"address":[5770281],"length":1,"stats":{"Line":25},"fn_name":null},{"line":470,"address":[5770633,5770340],"length":1,"stats":{"Line":25},"fn_name":null},{"line":473,"address":[5625936,5628112,5628219,5623760,5626031,5623862],"length":1,"stats":{"Line":58},"fn_name":"c_concat<core::iter::adapters::Take<core::iter::sources::Repeat<&regex_syntax::hir::Hir>>>"},{"line":477,"address":[5625962,5628146,5626046,5623794,5623877,5628234],"length":1,"stats":{"Line":118},"fn_name":null},{"line":478,"address":[5626652,5625687,5628840,5627868,5630056,5624479],"length":1,"stats":{"Line":77},"fn_name":null},{"line":479,"address":[5623893,5623980,5626054,5626153,5628242,5628341],"length":1,"stats":{"Line":61},"fn_name":null},{"line":480,"address":[5628279,5626091,5628343,5623918,5623982,5626155,5626229,5628417,5624056],"length":1,"stats":{"Line":108},"fn_name":null},{"line":481,"address":[5628302,5623941,5626114],"length":1,"stats":{"Line":61},"fn_name":null},{"line":482,"address":[5624087,5626556,5628744,5624123,5628331,5626143,5626260,5626296,5623970,5624383,5628448,5628484],"length":1,"stats":{"Line":242},"fn_name":null},{"line":483,"address":[5624431,5626604,5628792],"length":1,"stats":{"Line":60},"fn_name":null},{"line":488,"address":[5626834,5626708,5624605,5627904,5626782,5625723,5626872,5624653,5629060,5630092,5624691,5628970,5628896,5624535,5629022],"length":1,"stats":{"Line":239},"fn_name":null},{"line":489,"address":[5626919,5624800,5629456,5625087,5626981,5629107,5629169,5627268,5624738],"length":1,"stats":{"Line":123},"fn_name":null},{"line":490,"address":[5627329,5629517,5625148],"length":1,"stats":{"Line":57},"fn_name":null},{"line":491,"address":[5625216,5627397,5629585],"length":1,"stats":{"Line":58},"fn_name":null},{"line":494,"address":[5625377,5627558,5629746],"length":1,"stats":{"Line":59},"fn_name":null},{"line":497,"address":[5770672,5770824],"length":1,"stats":{"Line":8},"fn_name":"c_alternate"},{"line":498,"address":[5770854,5770902,5770706],"length":1,"stats":{"Line":16},"fn_name":null},{"line":499,"address":[5770770,5770847],"length":1,"stats":{"Line":16},"fn_name":null},{"line":504,"address":[5770870],"length":1,"stats":{"Line":8},"fn_name":null},{"line":508,"address":[5770936],"length":1,"stats":{"Line":8},"fn_name":null},{"line":512,"address":[5770974],"length":1,"stats":{"Line":8},"fn_name":null},{"line":513,"address":[5771096,5771034,5771377,5774236,5774780],"length":1,"stats":{"Line":24},"fn_name":null},{"line":514,"address":[5771411,5771690],"length":1,"stats":{"Line":18},"fn_name":null},{"line":515,"address":[5771500],"length":1,"stats":{"Line":9},"fn_name":null},{"line":516,"address":[5771534],"length":1,"stats":{"Line":10},"fn_name":null},{"line":518,"address":[5771426],"length":1,"stats":{"Line":8},"fn_name":null},{"line":520,"address":[5771710],"length":1,"stats":{"Line":8},"fn_name":null},{"line":521,"address":[5773029,5772173,5772241,5771854,5771746,5771802,5772160,5772662,5772114],"length":1,"stats":{"Line":53},"fn_name":null},{"line":522,"address":[5772297],"length":1,"stats":{"Line":8},"fn_name":null},{"line":523,"address":[5772550,5772357],"length":1,"stats":{"Line":16},"fn_name":null},{"line":525,"address":[5772175,5772667],"length":1,"stats":{"Line":18},"fn_name":null},{"line":526,"address":[5772747],"length":1,"stats":{"Line":11},"fn_name":null},{"line":527,"address":[5772829],"length":1,"stats":{"Line":12},"fn_name":null},{"line":530,"address":[5773257,5773513,5774912,5771342,5773110,5773584,5773946],"length":1,"stats":{"Line":40},"fn_name":null},{"line":531,"address":[5773640],"length":1,"stats":{"Line":8},"fn_name":null},{"line":532,"address":[5773942,5773700],"length":1,"stats":{"Line":21},"fn_name":null},{"line":533,"address":[5773781],"length":1,"stats":{"Line":13},"fn_name":null},{"line":535,"address":[5773710],"length":1,"stats":{"Line":8},"fn_name":null},{"line":541,"address":[5773518],"length":1,"stats":{"Line":8},"fn_name":null},{"line":543,"address":[5774368],"length":1,"stats":{"Line":8},"fn_name":null},{"line":546,"address":[5775040],"length":1,"stats":{"Line":8},"fn_name":"c_repeat"},{"line":548,"address":[5775315,5775537,5775352,5775281,5775467,5775389],"length":1,"stats":{"Line":53},"fn_name":null},{"line":549,"address":[5775288,5775059],"length":1,"stats":{"Line":16},"fn_name":null},{"line":550,"address":[5775325],"length":1,"stats":{"Line":8},"fn_name":null},{"line":551,"address":[5775362],"length":1,"stats":{"Line":8},"fn_name":null},{"line":552,"address":[5775136,5775399],"length":1,"stats":{"Line":18},"fn_name":null},{"line":553,"address":[5775406],"length":1,"stats":{"Line":8},"fn_name":null},{"line":555,"address":[5775474],"length":1,"stats":{"Line":8},"fn_name":null},{"line":556,"address":[5775481],"length":1,"stats":{"Line":8},"fn_name":null},{"line":558,"address":[5775179],"length":1,"stats":{"Line":8},"fn_name":null},{"line":559,"address":[5775193],"length":1,"stats":{"Line":8},"fn_name":null},{"line":564,"address":[5775568,5775682],"length":1,"stats":{"Line":8},"fn_name":"c_repeat_zero_or_one"},{"line":569,"address":[5775609],"length":1,"stats":{"Line":8},"fn_name":null},{"line":570,"address":[5775697],"length":1,"stats":{"Line":8},"fn_name":null},{"line":571,"address":[5775793,5776070,5776171,5775738,5776037,5776092,5775922],"length":1,"stats":{"Line":32},"fn_name":null},{"line":572,"address":[5775889,5776094],"length":1,"stats":{"Line":16},"fn_name":null},{"line":573,"address":[5777104,5776082],"length":1,"stats":{"Line":16},"fn_name":null},{"line":575,"address":[5776613,5776264],"length":1,"stats":{"Line":16},"fn_name":null},{"line":576,"address":[5776476],"length":1,"stats":{"Line":8},"fn_name":null},{"line":578,"address":[5776336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[5776627],"length":1,"stats":{"Line":8},"fn_name":null},{"line":581,"address":[5776774],"length":1,"stats":{"Line":8},"fn_name":null},{"line":584,"address":[5777330,5777216],"length":1,"stats":{"Line":8},"fn_name":"c_repeat_zero_or_more"},{"line":589,"address":[5777257],"length":1,"stats":{"Line":8},"fn_name":null},{"line":590,"address":[5777345],"length":1,"stats":{"Line":8},"fn_name":null},{"line":591,"address":[5777838,5777740,5777718,5777570,5777386,5777441,5777685],"length":1,"stats":{"Line":34},"fn_name":null},{"line":592,"address":[5777537,5777742],"length":1,"stats":{"Line":18},"fn_name":null},{"line":593,"address":[5777730,5778594],"length":1,"stats":{"Line":16},"fn_name":null},{"line":596,"address":[5777891],"length":1,"stats":{"Line":9},"fn_name":null},{"line":597,"address":[5778017,5778304],"length":1,"stats":{"Line":23},"fn_name":null},{"line":598,"address":[5778167],"length":1,"stats":{"Line":13},"fn_name":null},{"line":600,"address":[5778027],"length":1,"stats":{"Line":9},"fn_name":null},{"line":602,"address":[5778308],"length":1,"stats":{"Line":9},"fn_name":null},{"line":605,"address":[5778704,5778790],"length":1,"stats":{"Line":8},"fn_name":"c_repeat_one_or_more"},{"line":610,"address":[5778848,5778977,5779179,5779092,5778745,5778805,5779271],"length":1,"stats":{"Line":70},"fn_name":null},{"line":611,"address":[5779181,5778944],"length":1,"stats":{"Line":42},"fn_name":null},{"line":612,"address":[5779374,5779101],"length":1,"stats":{"Line":20},"fn_name":null},{"line":614,"address":[5779315],"length":1,"stats":{"Line":22},"fn_name":null},{"line":615,"address":[5779411],"length":1,"stats":{"Line":20},"fn_name":null},{"line":617,"address":[5779422,5779705],"length":1,"stats":{"Line":42},"fn_name":null},{"line":618,"address":[5779570],"length":1,"stats":{"Line":20},"fn_name":null},{"line":620,"address":[5779432],"length":1,"stats":{"Line":8},"fn_name":null},{"line":622,"address":[5779709],"length":1,"stats":{"Line":22},"fn_name":null},{"line":625,"address":[5780016,5780136],"length":1,"stats":{"Line":8},"fn_name":"c_repeat_range_min_or_more"},{"line":631,"address":[5780065],"length":1,"stats":{"Line":8},"fn_name":null},{"line":635,"address":[5780529,5780262,5780389,5780191],"length":1,"stats":{"Line":24},"fn_name":null},{"line":636,"address":[5780391,5780240,5780504,5780527,5780156],"length":1,"stats":{"Line":16},"fn_name":null},{"line":637,"address":[5781497,5780260,5780379,5780511,5780565],"length":1,"stats":{"Line":16},"fn_name":null},{"line":638,"address":[5780655,5780585,5780995,5780711,5781059,5781421],"length":1,"stats":{"Line":32},"fn_name":null},{"line":639,"address":[5781120],"length":1,"stats":{"Line":8},"fn_name":null},{"line":640,"address":[5781185],"length":1,"stats":{"Line":8},"fn_name":null},{"line":642,"address":[5781000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":646,"address":[5782010,5781840],"length":1,"stats":{"Line":10},"fn_name":"c_repeat_range"},{"line":653,"address":[5781897,5782032],"length":1,"stats":{"Line":20},"fn_name":null},{"line":654,"address":[5782165,5782109],"length":1,"stats":{"Line":10},"fn_name":null},{"line":655,"address":[5782150,5782572,5782436,5782211,5782557],"length":1,"stats":{"Line":36},"fn_name":null},{"line":656,"address":[5782422],"length":1,"stats":{"Line":8},"fn_name":null},{"line":657,"address":[5782680,5782794],"length":1,"stats":{"Line":16},"fn_name":null},{"line":661,"address":[5782799,5782593,5784862],"length":1,"stats":{"Line":16},"fn_name":null},{"line":662,"address":[5782854],"length":1,"stats":{"Line":8},"fn_name":null},{"line":682,"address":[5782879],"length":1,"stats":{"Line":8},"fn_name":null},{"line":683,"address":[5782939],"length":1,"stats":{"Line":8},"fn_name":null},{"line":684,"address":[5783240,5783102,5784525,5782995],"length":1,"stats":{"Line":24},"fn_name":null},{"line":685,"address":[5783266],"length":1,"stats":{"Line":8},"fn_name":null},{"line":686,"address":[5783345],"length":1,"stats":{"Line":8},"fn_name":null},{"line":687,"address":[5783384,5783568,5783742,5783773,5783439,5783852],"length":1,"stats":{"Line":24},"fn_name":null},{"line":688,"address":[5783535,5783775],"length":1,"stats":{"Line":16},"fn_name":null},{"line":689,"address":[5783763,5785008],"length":1,"stats":{"Line":0},"fn_name":null},{"line":691,"address":[5783940],"length":1,"stats":{"Line":8},"fn_name":null},{"line":692,"address":[5784507,5784092,5784482],"length":1,"stats":{"Line":24},"fn_name":null},{"line":693,"address":[5784313],"length":1,"stats":{"Line":8},"fn_name":null},{"line":695,"address":[5784500,5784164],"length":1,"stats":{"Line":16},"fn_name":null},{"line":698,"address":[5783174],"length":1,"stats":{"Line":8},"fn_name":null},{"line":699,"address":[5784530],"length":1,"stats":{"Line":8},"fn_name":null},{"line":705,"address":[5785200,5785253],"length":1,"stats":{"Line":24},"fn_name":"next_inst"},{"line":706,"address":[5785212,5785265,5785324],"length":1,"stats":{"Line":46},"fn_name":null},{"line":709,"address":[5785950,5785360],"length":1,"stats":{"Line":25},"fn_name":"fill"},{"line":710,"address":[5785501,5785567],"length":1,"stats":{"Line":24},"fn_name":null},{"line":711,"address":[5785383],"length":1,"stats":{"Line":27},"fn_name":null},{"line":712,"address":[5785508],"length":1,"stats":{"Line":21},"fn_name":null},{"line":713,"address":[5785525],"length":1,"stats":{"Line":23},"fn_name":null},{"line":715,"address":[5785443],"length":1,"stats":{"Line":13},"fn_name":null},{"line":716,"address":[5785572,5785461,5785943,5785665],"length":1,"stats":{"Line":53},"fn_name":null},{"line":717,"address":[5785855],"length":1,"stats":{"Line":13},"fn_name":null},{"line":723,"address":[5786101,5786048],"length":1,"stats":{"Line":26},"fn_name":"fill_to_next"},{"line":724,"address":[5786118,5786057],"length":1,"stats":{"Line":54},"fn_name":null},{"line":725,"address":[5786123],"length":1,"stats":{"Line":28},"fn_name":null},{"line":728,"address":[5786224,5787994],"length":1,"stats":{"Line":26},"fn_name":"fill_split"},{"line":734,"address":[5786509,5787155,5786492],"length":1,"stats":{"Line":26},"fn_name":null},{"line":735,"address":[5786282,5786502],"length":1,"stats":{"Line":24},"fn_name":null},{"line":736,"address":[5786953,5786522,5787055,5786851,5786720],"length":1,"stats":{"Line":59},"fn_name":null},{"line":737,"address":[5786598,5786722],"length":1,"stats":{"Line":50},"fn_name":null},{"line":738,"address":[5786777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":739,"address":[5786844],"length":1,"stats":{"Line":0},"fn_name":null},{"line":741,"address":[5786856],"length":1,"stats":{"Line":24},"fn_name":null},{"line":742,"address":[5786880],"length":1,"stats":{"Line":26},"fn_name":null},{"line":743,"address":[5786942],"length":1,"stats":{"Line":26},"fn_name":null},{"line":745,"address":[5786958,5786620],"length":1,"stats":{"Line":18},"fn_name":null},{"line":746,"address":[5786982],"length":1,"stats":{"Line":9},"fn_name":null},{"line":747,"address":[5787044],"length":1,"stats":{"Line":9},"fn_name":null},{"line":754,"address":[5786404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":755,"address":[5787179,5786453],"length":1,"stats":{"Line":0},"fn_name":null},{"line":756,"address":[5787358,5787187,5787725,5787380],"length":1,"stats":{"Line":0},"fn_name":null},{"line":757,"address":[5787710,5787570],"length":1,"stats":{"Line":0},"fn_name":null},{"line":759,"address":[5787974,5787738,5787794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":760,"address":[5787787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":761,"address":[5787972,5787804,5787767,5787917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":762,"address":[5787935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":764,"address":[5787810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":770,"address":[5788208],"length":1,"stats":{"Line":10},"fn_name":"push_compiled"},{"line":771,"address":[5788223],"length":1,"stats":{"Line":10},"fn_name":null},{"line":774,"address":[5788431,5788352],"length":1,"stats":{"Line":27},"fn_name":"push_hole"},{"line":775,"address":[5788370,5788451],"length":1,"stats":{"Line":54},"fn_name":null},{"line":776,"address":[5788464],"length":1,"stats":{"Line":27},"fn_name":null},{"line":777,"address":[5788555],"length":1,"stats":{"Line":27},"fn_name":null},{"line":780,"address":[5788640],"length":1,"stats":{"Line":26},"fn_name":"push_split_hole"},{"line":781,"address":[5788652],"length":1,"stats":{"Line":24},"fn_name":null},{"line":782,"address":[5788700],"length":1,"stats":{"Line":26},"fn_name":null},{"line":783,"address":[5788738],"length":1,"stats":{"Line":24},"fn_name":null},{"line":786,"address":[5788768],"length":1,"stats":{"Line":8},"fn_name":"pop_split_hole"},{"line":787,"address":[5788780],"length":1,"stats":{"Line":8},"fn_name":null},{"line":788,"address":[5788820],"length":1,"stats":{"Line":8},"fn_name":null},{"line":791,"address":[5788896],"length":1,"stats":{"Line":27},"fn_name":"check_size"},{"line":794,"address":[5789024,5788975,5788908,5789132,5789102],"length":1,"stats":{"Line":81},"fn_name":null},{"line":795,"address":[5789031],"length":1,"stats":{"Line":8},"fn_name":null},{"line":797,"address":[5789017],"length":1,"stats":{"Line":27},"fn_name":null},{"line":810,"address":[5789198,5789136],"length":1,"stats":{"Line":9},"fn_name":"dup_one"},{"line":811,"address":[5789213],"length":1,"stats":{"Line":0},"fn_name":null},{"line":812,"address":[5789146,5789220],"length":1,"stats":{"Line":18},"fn_name":null},{"line":830,"address":[5789584,5790282],"length":1,"stats":{"Line":22},"fn_name":"fill"},{"line":831,"address":[5790092,5789829,5789961,5789746],"length":1,"stats":{"Line":61},"fn_name":null},{"line":832,"address":[5789732,5789604],"length":1,"stats":{"Line":32},"fn_name":null},{"line":833,"address":[5789751],"length":1,"stats":{"Line":22},"fn_name":null},{"line":834,"address":[5789770],"length":1,"stats":{"Line":24},"fn_name":null},{"line":836,"address":[5789834],"length":1,"stats":{"Line":22},"fn_name":null},{"line":837,"address":[5789851],"length":1,"stats":{"Line":20},"fn_name":null},{"line":838,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":839,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":842,"address":[5789966],"length":1,"stats":{"Line":8},"fn_name":null},{"line":843,"address":[5789988],"length":1,"stats":{"Line":8},"fn_name":null},{"line":844,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":845,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":854,"address":[5790191,5790297],"length":1,"stats":{"Line":46},"fn_name":null},{"line":857,"address":[5790352,5790766],"length":1,"stats":{"Line":0},"fn_name":"fill_split"},{"line":858,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":859,"address":[5790380],"length":1,"stats":{"Line":0},"fn_name":null},{"line":860,"address":[5790477],"length":1,"stats":{"Line":0},"fn_name":null},{"line":868,"address":[5790781,5790521,5790726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":871,"address":[5791116,5790848],"length":1,"stats":{"Line":24},"fn_name":"half_fill_split_goto1"},{"line":872,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":873,"address":[5790868,5790951],"length":1,"stats":{"Line":50},"fn_name":null},{"line":880,"address":[5791131,5790959,5791076],"length":1,"stats":{"Line":50},"fn_name":null},{"line":883,"address":[5791468,5791200],"length":1,"stats":{"Line":9},"fn_name":"half_fill_split_goto2"},{"line":884,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":885,"address":[5791220,5791303],"length":1,"stats":{"Line":18},"fn_name":null},{"line":892,"address":[5791311,5791428,5791483],"length":1,"stats":{"Line":18},"fn_name":null},{"line":895,"address":[5791552,5791585],"length":1,"stats":{"Line":24},"fn_name":"unwrap"},{"line":896,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":897,"address":[5791676,5791562],"length":1,"stats":{"Line":46},"fn_name":null},{"line":917,"address":[5791920],"length":1,"stats":{"Line":22},"fn_name":"fill"},{"line":918,"address":[5792155,5792279,5792217,5792086],"length":1,"stats":{"Line":75},"fn_name":null},{"line":919,"address":[5791946,5792098],"length":1,"stats":{"Line":48},"fn_name":null},{"line":920,"address":[5792115],"length":1,"stats":{"Line":22},"fn_name":null},{"line":922,"address":[5792165],"length":1,"stats":{"Line":25},"fn_name":null},{"line":923,"address":[5792180],"length":1,"stats":{"Line":25},"fn_name":null},{"line":925,"address":[5792227],"length":1,"stats":{"Line":9},"fn_name":null},{"line":926,"address":[5792289],"length":1,"stats":{"Line":20},"fn_name":null},{"line":927,"address":[5792303],"length":1,"stats":{"Line":22},"fn_name":null},{"line":929,"address":[5792003],"length":1,"stats":{"Line":17},"fn_name":null},{"line":930,"address":[5792028],"length":1,"stats":{"Line":15},"fn_name":null},{"line":942,"address":[5792432,5792548],"length":1,"stats":{"Line":21},"fn_name":"compile"},{"line":943,"address":[5792563,5792446],"length":1,"stats":{"Line":44},"fn_name":null},{"line":944,"address":[5792571],"length":1,"stats":{"Line":23},"fn_name":null},{"line":945,"address":[5792583],"length":1,"stats":{"Line":21},"fn_name":null},{"line":946,"address":[5792688,5792611],"length":1,"stats":{"Line":44},"fn_name":null},{"line":947,"address":[5792704],"length":1,"stats":{"Line":23},"fn_name":null},{"line":949,"address":[5793050,5793418,5792732],"length":1,"stats":{"Line":40},"fn_name":null},{"line":950,"address":[5793116,5795818],"length":1,"stats":{"Line":23},"fn_name":null},{"line":951,"address":[5793200],"length":1,"stats":{"Line":21},"fn_name":null},{"line":952,"address":[5793292],"length":1,"stats":{"Line":21},"fn_name":null},{"line":953,"address":[5795217,5793299],"length":1,"stats":{"Line":45},"fn_name":null},{"line":954,"address":[5793416,5793317],"length":1,"stats":{"Line":21},"fn_name":null},{"line":955,"address":[5793324],"length":1,"stats":{"Line":23},"fn_name":null},{"line":956,"address":[5793345],"length":1,"stats":{"Line":23},"fn_name":null},{"line":958,"address":[5793409,5793423,5794313],"length":1,"stats":{"Line":51},"fn_name":null},{"line":959,"address":[5794068,5793845,5793966,5793567],"length":1,"stats":{"Line":16},"fn_name":null},{"line":960,"address":[5793774],"length":1,"stats":{"Line":14},"fn_name":null},{"line":961,"address":[5794100],"length":1,"stats":{"Line":16},"fn_name":null},{"line":962,"address":[5794163],"length":1,"stats":{"Line":14},"fn_name":null},{"line":963,"address":[5794215],"length":1,"stats":{"Line":16},"fn_name":null},{"line":964,"address":[5794253],"length":1,"stats":{"Line":8},"fn_name":null},{"line":967,"address":[5794322,5793517],"length":1,"stats":{"Line":46},"fn_name":null},{"line":968,"address":[5794336],"length":1,"stats":{"Line":23},"fn_name":null},{"line":970,"address":[5794426],"length":1,"stats":{"Line":23},"fn_name":null},{"line":971,"address":[5794492],"length":1,"stats":{"Line":23},"fn_name":null},{"line":972,"address":[5794574,5794852],"length":1,"stats":{"Line":23},"fn_name":null},{"line":973,"address":[5794781],"length":1,"stats":{"Line":24},"fn_name":null},{"line":974,"address":[5795137],"length":1,"stats":{"Line":24},"fn_name":null},{"line":975,"address":[5794996],"length":1,"stats":{"Line":26},"fn_name":null},{"line":979,"address":[5792947,5795561],"length":1,"stats":{"Line":16},"fn_name":null},{"line":980,"address":[5795652,5795222],"length":1,"stats":{"Line":14},"fn_name":null},{"line":983,"address":[5796000],"length":1,"stats":{"Line":19},"fn_name":"c_utf8_seq"},{"line":984,"address":[5796017,5796144,5796092],"length":1,"stats":{"Line":62},"fn_name":null},{"line":985,"address":[5796087],"length":1,"stats":{"Line":12},"fn_name":null},{"line":987,"address":[5796054,5796104],"length":1,"stats":{"Line":40},"fn_name":null},{"line":991,"address":[5630304,5630428,5631765,5631648],"length":1,"stats":{"Line":33},"fn_name":"c_utf8_seq_<core::iter::adapters::Rev<core::slice::Iter<regex_syntax::utf8::Utf8Range>>>"},{"line":996,"address":[5630338,5631674],"length":1,"stats":{"Line":40},"fn_name":null},{"line":997,"address":[5631686,5630350],"length":1,"stats":{"Line":43},"fn_name":null},{"line":998,"address":[5630523,5631142,5630367,5631860,5632479,5631803,5630485,5631822,5630466,5631698],"length":1,"stats":{"Line":171},"fn_name":null},{"line":1001,"address":[5630565,5631902],"length":1,"stats":{"Line":43},"fn_name":null},{"line":1002,"address":[5631904,5630567],"length":1,"stats":{"Line":43},"fn_name":null},{"line":1005,"address":[5630599,5631936],"length":1,"stats":{"Line":43},"fn_name":null},{"line":1006,"address":[5632136,5630644,5630799,5631981],"length":1,"stats":{"Line":77},"fn_name":null},{"line":1007,"address":[5630815,5632152],"length":1,"stats":{"Line":32},"fn_name":null},{"line":1008,"address":[5630823,5632160],"length":1,"stats":{"Line":34},"fn_name":null},{"line":1011,"address":[5632080,5630743],"length":1,"stats":{"Line":42},"fn_name":null},{"line":1012,"address":[5632909,5630828,5632354,5631017,5631572,5632165],"length":1,"stats":{"Line":133},"fn_name":null},{"line":1013,"address":[5630939,5631439,5632276,5632290,5632776,5630953],"length":1,"stats":{"Line":86},"fn_name":null},{"line":1014,"address":[5632284,5630947],"length":1,"stats":{"Line":42},"fn_name":null},{"line":1015,"address":[5630949,5632286],"length":1,"stats":{"Line":44},"fn_name":null},{"line":1018,"address":[5630867,5630844,5632204,5632181],"length":1,"stats":{"Line":98},"fn_name":null},{"line":1019,"address":[5632184,5630847],"length":1,"stats":{"Line":47},"fn_name":null},{"line":1020,"address":[5632197,5630860],"length":1,"stats":{"Line":49},"fn_name":null},{"line":1021,"address":[5630863,5632200],"length":1,"stats":{"Line":47},"fn_name":null},{"line":1024,"address":[5632361,5631024],"length":1,"stats":{"Line":42},"fn_name":null},{"line":1025,"address":[5632459,5632484,5631147,5631122],"length":1,"stats":{"Line":44},"fn_name":null},{"line":1027,"address":[5631406,5632743,5631180,5632517],"length":1,"stats":{"Line":44},"fn_name":null},{"line":1028,"address":[5631202,5632539],"length":1,"stats":{"Line":42},"fn_name":null},{"line":1073,"address":[5796214,5796160],"length":1,"stats":{"Line":27},"fn_name":"new"},{"line":1075,"address":[5796231,5796176],"length":1,"stats":{"Line":54},"fn_name":null},{"line":1076,"address":[5796256],"length":1,"stats":{"Line":27},"fn_name":null},{"line":1080,"address":[5796352],"length":1,"stats":{"Line":26},"fn_name":"get"},{"line":1081,"address":[5796390],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1082,"address":[5796818,5796413,5796790],"length":1,"stats":{"Line":25},"fn_name":null},{"line":1083,"address":[5796601,5796470],"length":1,"stats":{"Line":48},"fn_name":null},{"line":1084,"address":[5796566],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1085,"address":[5796608],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1088,"address":[5796649],"length":1,"stats":{"Line":25},"fn_name":null},{"line":1089,"address":[5796686],"length":1,"stats":{"Line":25},"fn_name":null},{"line":1090,"address":[5796776],"length":1,"stats":{"Line":25},"fn_name":null},{"line":1093,"address":[5796832],"length":1,"stats":{"Line":21},"fn_name":"clear"},{"line":1094,"address":[5796837],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1097,"address":[5796864],"length":1,"stats":{"Line":26},"fn_name":"hash"},{"line":1101,"address":[5796878],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1102,"address":[5796893],"length":1,"stats":{"Line":25},"fn_name":null},{"line":1103,"address":[5796947],"length":1,"stats":{"Line":25},"fn_name":null},{"line":1104,"address":[5796999],"length":1,"stats":{"Line":25},"fn_name":null},{"line":1105,"address":[5797126,5797051,5797156],"length":1,"stats":{"Line":25},"fn_name":null},{"line":1112,"address":[5797168],"length":1,"stats":{"Line":26},"fn_name":"new"},{"line":1113,"address":[5797190],"length":1,"stats":{"Line":27},"fn_name":null},{"line":1116,"address":[5797264],"length":1,"stats":{"Line":20},"fn_name":"set_range"},{"line":1117,"address":[5797318,5797282],"length":1,"stats":{"Line":20},"fn_name":null},{"line":1118,"address":[5797312],"length":1,"stats":{"Line":20},"fn_name":null},{"line":1119,"address":[5797352,5797466],"length":1,"stats":{"Line":14},"fn_name":null},{"line":1121,"address":[5797418,5797524,5797552],"length":1,"stats":{"Line":29},"fn_name":"set_word_boundary"},{"line":1124,"address":[5797552],"length":1,"stats":{"Line":0},"fn_name":"set_word_boundary"},{"line":1127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1128,"address":[5797561],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1130,"address":[5797573,5797823],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1131,"address":[5797828,5797587],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1132,"address":[5797623,5797783],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1133,"address":[5797858,5797751],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1135,"address":[5797714,5797802,5797918,5797888],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1136,"address":[5797813],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1140,"address":[5797920,5797978],"length":1,"stats":{"Line":21},"fn_name":"byte_classes"},{"line":1145,"address":[5797940],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1146,"address":[5797993],"length":1,"stats":{"Line":21},"fn_name":null},{"line":1147,"address":[5797998],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1148,"address":[5798280],"length":1,"stats":{"Line":22},"fn_name":null},{"line":1149,"address":[5798007,5798059],"length":1,"stats":{"Line":45},"fn_name":null},{"line":1150,"address":[5798061],"length":1,"stats":{"Line":22},"fn_name":null},{"line":1151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1153,"address":[5798072,5798305,5798155],"length":1,"stats":{"Line":46},"fn_name":null},{"line":1154,"address":[5798161],"length":1,"stats":{"Line":14},"fn_name":null},{"line":1156,"address":[5798246,5798335,5798365],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1158,"address":[5798101],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1162,"address":[5798368],"length":1,"stats":{"Line":11},"fn_name":"u32_to_usize"},{"line":1166,"address":[5798376],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1167,"address":[5798404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1169,"address":[5798388],"length":1,"stats":{"Line":11},"fn_name":null},{"line":1177,"address":[5600800,5600828],"length":1,"stats":{"Line":3},"fn_name":"byte_classes"},{"line":1178,"address":[5600813],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1179,"address":[5600843],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1180,"address":[5600866],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1181,"address":[5601065,5600899],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1182,"address":[5601047,5601555,5601425],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1183,"address":[5602045,5601537,5601915],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1184,"address":[5602405,5602027,5602535],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1185,"address":[5603025,5602895,5602517],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1186,"address":[5603385,5603515,5603007],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1187,"address":[5603875,5604005,5603497],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1188,"address":[5604365,5604495,5603987],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1189,"address":[5604985,5604855,5604477],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1190,"address":[5604967,5605345,5605462],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1192,"address":[5605452],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1193,"address":[5605837],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1194,"address":[5605862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1195,"address":[5605885],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1196,"address":[5605904,5606070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1197,"address":[5606052,5606430,5606560],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1198,"address":[5606920,5606542,5607050],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1199,"address":[5607032,5607410,5607540],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1200,"address":[5608030,5607522,5607900],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1201,"address":[5608390,5608520,5608012],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1202,"address":[5608502,5608880,5609010],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1203,"address":[5609500,5609370,5608992],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1204,"address":[5609824,5609939,5609482],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1208,"address":[5610304,5610323],"length":1,"stats":{"Line":3},"fn_name":"full_byte_classes"},{"line":1209,"address":[5610311],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1210,"address":[5610486,5610338,5610538],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1211,"address":[5610520],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1213,"address":[5610466,5610540],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":523,"coverable":581},{"path":["/","usr","src","regex","src","dfa.rs"],"content":"/*!\nThe DFA matching engine.\n\nA DFA provides faster matching because the engine is in exactly one state at\nany point in time. In the NFA, there may be multiple active states, and\nconsiderable CPU cycles are spent shuffling them around. In finite automata\nspeak, the DFA follows epsilon transitions in the regex far less than the NFA.\n\nA DFA is a classic trade off between time and space. The NFA is slower, but\nits memory requirements are typically small and predictable. The DFA is faster,\nbut given the right regex and the right input, the number of states in the\nDFA can grow exponentially. To mitigate this space problem, we do two things:\n\n1. We implement an *online* DFA. That is, the DFA is constructed from the NFA\n   during a search. When a new state is computed, it is stored in a cache so\n   that it may be reused. An important consequence of this implementation\n   is that states that are never reached for a particular input are never\n   computed. (This is impossible in an \"offline\" DFA which needs to compute\n   all possible states up front.)\n2. If the cache gets too big, we wipe it and continue matching.\n\nIn pathological cases, a new state can be created for every byte of input.\n(e.g., The regex `(a|b)*a(a|b){20}` on a long sequence of a's and b's.)\nIn this case, performance regresses to slightly slower than the full NFA\nsimulation, in large part because the cache becomes useless. If the cache\nis wiped too frequently, the DFA quits and control falls back to one of the\nNFA simulations.\n\nBecause of the \"lazy\" nature of this DFA, the inner matching loop is\nconsiderably more complex than one might expect out of a DFA. A number of\ntricks are employed to make it fast. Tread carefully.\n\nN.B. While this implementation is heavily commented, Russ Cox's series of\narticles on regexes is strongly recommended: https://swtch.com/~rsc/regexp/\n(As is the DFA implementation in RE2, which heavily influenced this\nimplementation.)\n*/\n\nuse std::collections::HashMap;\nuse std::fmt;\nuse std::iter::repeat;\nuse std::mem;\nuse std::sync::Arc;\n\nuse exec::ProgramCache;\nuse prog::{Inst, Program};\nuse sparse::SparseSet;\n\n/// Return true if and only if the given program can be executed by a DFA.\n///\n/// Generally, a DFA is always possible. A pathological case where it is not\n/// possible is if the number of NFA states exceeds `u32::MAX`, in which case,\n/// this function will return false.\n///\n/// This function will also return false if the given program has any Unicode\n/// instructions (Char or Ranges) since the DFA operates on bytes only.\npub fn can_exec(insts: &Program) -> bool {\n    use prog::Inst::*;\n    // If for some reason we manage to allocate a regex program with more\n    // than i32::MAX instructions, then we can't execute the DFA because we\n    // use 32 bit instruction pointer deltas for memory savings.\n    // If i32::MAX is the largest positive delta,\n    // then -i32::MAX == i32::MIN + 1 is the largest negative delta,\n    // and we are OK to use 32 bits.\n    if insts.dfa_size_limit == 0 || insts.len() > ::std::i32::MAX as usize {\n        return false;\n    }\n    for inst in insts {\n        match *inst {\n            Char(_) | Ranges(_) => return false,\n            EmptyLook(_) | Match(_) | Save(_) | Split(_) | Bytes(_) => {}\n        }\n    }\n    true\n}\n\n/// A reusable cache of DFA states.\n///\n/// This cache is reused between multiple invocations of the same regex\n/// program. (It is not shared simultaneously between threads. If there is\n/// contention, then new caches are created.)\n#[derive(Debug)]\npub struct Cache {\n    /// Group persistent DFA related cache state together. The sparse sets\n    /// listed below are used as scratch space while computing uncached states.\n    inner: CacheInner,\n    /// qcur and qnext are ordered sets with constant time\n    /// addition/membership/clearing-whole-set and linear time iteration. They\n    /// are used to manage the sets of NFA states in DFA states when computing\n    /// cached DFA states. In particular, the order of the NFA states matters\n    /// for leftmost-first style matching. Namely, when computing a cached\n    /// state, the set of NFA states stops growing as soon as the first Match\n    /// instruction is observed.\n    qcur: SparseSet,\n    qnext: SparseSet,\n}\n\n/// `CacheInner` is logically just a part of Cache, but groups together fields\n/// that aren't passed as function parameters throughout search. (This split\n/// is mostly an artifact of the borrow checker. It is happily paid.)\n#[derive(Debug)]\nstruct CacheInner {\n    /// A cache of pre-compiled DFA states, keyed by the set of NFA states\n    /// and the set of empty-width flags set at the byte in the input when the\n    /// state was observed.\n    ///\n    /// A StatePtr is effectively a `*State`, but to avoid various inconvenient\n    /// things, we just pass indexes around manually. The performance impact of\n    /// this is probably an instruction or two in the inner loop. However, on\n    /// 64 bit, each StatePtr is half the size of a *State.\n    compiled: StateMap,\n    /// The transition table.\n    ///\n    /// The transition table is laid out in row-major order, where states are\n    /// rows and the transitions for each state are columns. At a high level,\n    /// given state `s` and byte `b`, the next state can be found at index\n    /// `s * 256 + b`.\n    ///\n    /// This is, of course, a lie. A StatePtr is actually a pointer to the\n    /// *start* of a row in this table. When indexing in the DFA's inner loop,\n    /// this removes the need to multiply the StatePtr by the stride. Yes, it\n    /// matters. This reduces the number of states we can store, but: the\n    /// stride is rarely 256 since we define transitions in terms of\n    /// *equivalence classes* of bytes. Each class corresponds to a set of\n    /// bytes that never discriminate a distinct path through the DFA from each\n    /// other.\n    trans: Transitions,\n    /// A set of cached start states, which are limited to the number of\n    /// permutations of flags set just before the initial byte of input. (The\n    /// index into this vec is a `EmptyFlags`.)\n    ///\n    /// N.B. A start state can be \"dead\" (i.e., no possible match), so we\n    /// represent it with a StatePtr.\n    start_states: Vec<StatePtr>,\n    /// Stack scratch space used to follow epsilon transitions in the NFA.\n    /// (This permits us to avoid recursion.)\n    ///\n    /// The maximum stack size is the number of NFA states.\n    stack: Vec<InstPtr>,\n    /// The total number of times this cache has been flushed by the DFA\n    /// because of space constraints.\n    flush_count: u64,\n    /// The total heap size of the DFA's cache. We use this to determine when\n    /// we should flush the cache.\n    size: usize,\n    /// Scratch space used when building instruction pointer lists for new\n    /// states. This helps amortize allocation.\n    insts_scratch_space: Vec<u8>,\n}\n\n/// The transition table.\n///\n/// It is laid out in row-major order, with states as rows and byte class\n/// transitions as columns.\n///\n/// The transition table is responsible for producing valid `StatePtrs`. A\n/// `StatePtr` points to the start of a particular row in this table. When\n/// indexing to find the next state this allows us to avoid a multiplication\n/// when computing an index into the table.\n#[derive(Clone)]\nstruct Transitions {\n    /// The table.\n    table: Vec<StatePtr>,\n    /// The stride.\n    num_byte_classes: usize,\n}\n\n/// Fsm encapsulates the actual execution of the DFA.\n#[derive(Debug)]\npub struct Fsm<'a> {\n    /// prog contains the NFA instruction opcodes. DFA execution uses either\n    /// the `dfa` instructions or the `dfa_reverse` instructions from\n    /// `exec::ExecReadOnly`. (It never uses `ExecReadOnly.nfa`, which may have\n    /// Unicode opcodes that cannot be executed by the DFA.)\n    prog: &'a Program,\n    /// The start state. We record it here because the pointer may change\n    /// when the cache is wiped.\n    start: StatePtr,\n    /// The current position in the input.\n    at: usize,\n    /// Should we quit after seeing the first match? e.g., When the caller\n    /// uses `is_match` or `shortest_match`.\n    quit_after_match: bool,\n    /// The last state that matched.\n    ///\n    /// When no match has occurred, this is set to STATE_UNKNOWN.\n    ///\n    /// This is only useful when matching regex sets. The last match state\n    /// is useful because it contains all of the match instructions seen,\n    /// thereby allowing us to enumerate which regexes in the set matched.\n    last_match_si: StatePtr,\n    /// The input position of the last cache flush. We use this to determine\n    /// if we're thrashing in the cache too often. If so, the DFA quits so\n    /// that we can fall back to the NFA algorithm.\n    last_cache_flush: usize,\n    /// All cached DFA information that is persisted between searches.\n    cache: &'a mut CacheInner,\n}\n\n/// The result of running the DFA.\n///\n/// Generally, the result is either a match or not a match, but sometimes the\n/// DFA runs too slowly because the cache size is too small. In that case, it\n/// gives up with the intent of falling back to the NFA algorithm.\n///\n/// The DFA can also give up if it runs out of room to create new states, or if\n/// it sees non-ASCII bytes in the presence of a Unicode word boundary.\n#[derive(Clone, Debug)]\npub enum Result<T> {\n    Match(T),\n    NoMatch(usize),\n    Quit,\n}\n\nimpl<T> Result<T> {\n    /// Returns true if this result corresponds to a match.\n    pub fn is_match(&self) -> bool {\n        match *self {\n            Result::Match(_) => true,\n            Result::NoMatch(_) | Result::Quit => false,\n        }\n    }\n\n    /// Maps the given function onto T and returns the result.\n    ///\n    /// If this isn't a match, then this is a no-op.\n    #[cfg(feature = \"perf-literal\")]\n    pub fn map<U, F: FnMut(T) -> U>(self, mut f: F) -> Result<U> {\n        match self {\n            Result::Match(t) => Result::Match(f(t)),\n            Result::NoMatch(x) => Result::NoMatch(x),\n            Result::Quit => Result::Quit,\n        }\n    }\n\n    /// Sets the non-match position.\n    ///\n    /// If this isn't a non-match, then this is a no-op.\n    fn set_non_match(self, at: usize) -> Result<T> {\n        match self {\n            Result::NoMatch(_) => Result::NoMatch(at),\n            r => r,\n        }\n    }\n}\n\n/// `State` is a DFA state. It contains an ordered set of NFA states (not\n/// necessarily complete) and a smattering of flags.\n///\n/// The flags are packed into the first byte of data.\n///\n/// States don't carry their transitions. Instead, transitions are stored in\n/// a single row-major table.\n///\n/// Delta encoding is used to store the instruction pointers.\n/// The first instruction pointer is stored directly starting\n/// at data[1], and each following pointer is stored as an offset\n/// to the previous one. If a delta is in the range -127..127,\n/// it is packed into a single byte; Otherwise the byte 128 (-128 as an i8)\n/// is coded as a flag, followed by 4 bytes encoding the delta.\n#[derive(Clone, Eq, Hash, PartialEq)]\nstruct State {\n    data: Arc<[u8]>,\n}\n\n/// `InstPtr` is a 32 bit pointer into a sequence of opcodes (i.e., it indexes\n/// an NFA state).\n///\n/// Throughout this library, this is usually set to `usize`, but we force a\n/// `u32` here for the DFA to save on space.\ntype InstPtr = u32;\n\n/// Adds ip to data using delta encoding with respect to prev.\n///\n/// After completion, `data` will contain `ip` and `prev` will be set to `ip`.\nfn push_inst_ptr(data: &mut Vec<u8>, prev: &mut InstPtr, ip: InstPtr) {\n    let delta = (ip as i32) - (*prev as i32);\n    write_vari32(data, delta);\n    *prev = ip;\n}\n\nstruct InstPtrs<'a> {\n    base: usize,\n    data: &'a [u8],\n}\n\nimpl<'a> Iterator for InstPtrs<'a> {\n    type Item = usize;\n\n    fn next(&mut self) -> Option<usize> {\n        if self.data.is_empty() {\n            return None;\n        }\n        let (delta, nread) = read_vari32(self.data);\n        let base = self.base as i32 + delta;\n        debug_assert!(base >= 0);\n        debug_assert!(nread > 0);\n        self.data = &self.data[nread..];\n        self.base = base as usize;\n        Some(self.base)\n    }\n}\n\nimpl State {\n    fn flags(&self) -> StateFlags {\n        StateFlags(self.data[0])\n    }\n\n    fn inst_ptrs(&self) -> InstPtrs {\n        InstPtrs { base: 0, data: &self.data[1..] }\n    }\n}\n\n/// `StatePtr` is a 32 bit pointer to the start of a row in the transition\n/// table.\n///\n/// It has many special values. There are two types of special values:\n/// sentinels and flags.\n///\n/// Sentinels corresponds to special states that carry some kind of\n/// significance. There are three such states: unknown, dead and quit states.\n///\n/// Unknown states are states that haven't been computed yet. They indicate\n/// that a transition should be filled in that points to either an existing\n/// cached state or a new state altogether. In general, an unknown state means\n/// \"follow the NFA's epsilon transitions.\"\n///\n/// Dead states are states that can never lead to a match, no matter what\n/// subsequent input is observed. This means that the DFA should quit\n/// immediately and return the longest match it has found thus far.\n///\n/// Quit states are states that imply the DFA is not capable of matching the\n/// regex correctly. Currently, this is only used when a Unicode word boundary\n/// exists in the regex *and* a non-ASCII byte is observed.\n///\n/// The other type of state pointer is a state pointer with special flag bits.\n/// There are two flags: a start flag and a match flag. The lower bits of both\n/// kinds always contain a \"valid\" `StatePtr` (indicated by the `STATE_MAX`\n/// mask).\n///\n/// The start flag means that the state is a start state, and therefore may be\n/// subject to special prefix scanning optimizations.\n///\n/// The match flag means that the state is a match state, and therefore the\n/// current position in the input (while searching) should be recorded.\n///\n/// The above exists mostly in the service of making the inner loop fast.\n/// In particular, the inner *inner* loop looks something like this:\n///\n/// ```ignore\n/// while state <= STATE_MAX and i < len(text):\n///     state = state.next[i]\n/// ```\n///\n/// This is nice because it lets us execute a lazy DFA as if it were an\n/// entirely offline DFA (i.e., with very few instructions). The loop will\n/// quit only when we need to examine a case that needs special attention.\ntype StatePtr = u32;\n\n/// An unknown state means that the state has not been computed yet, and that\n/// the only way to progress is to compute it.\nconst STATE_UNKNOWN: StatePtr = 1 << 31;\n\n/// A dead state means that the state has been computed and it is known that\n/// once it is entered, no future match can ever occur.\nconst STATE_DEAD: StatePtr = STATE_UNKNOWN + 1;\n\n/// A quit state means that the DFA came across some input that it doesn't\n/// know how to process correctly. The DFA should quit and another matching\n/// engine should be run in its place.\nconst STATE_QUIT: StatePtr = STATE_DEAD + 1;\n\n/// A start state is a state that the DFA can start in.\n///\n/// Note that start states have their lower bits set to a state pointer.\nconst STATE_START: StatePtr = 1 << 30;\n\n/// A match state means that the regex has successfully matched.\n///\n/// Note that match states have their lower bits set to a state pointer.\nconst STATE_MATCH: StatePtr = 1 << 29;\n\n/// The maximum state pointer. This is useful to mask out the \"valid\" state\n/// pointer from a state with the \"start\" or \"match\" bits set.\n///\n/// It doesn't make sense to use this with unknown, dead or quit state\n/// pointers, since those pointers are sentinels and never have their lower\n/// bits set to anything meaningful.\nconst STATE_MAX: StatePtr = STATE_MATCH - 1;\n\n/// Byte is a u8 in spirit, but a u16 in practice so that we can represent the\n/// special EOF sentinel value.\n#[derive(Copy, Clone, Debug)]\nstruct Byte(u16);\n\n/// A set of flags for zero-width assertions.\n#[derive(Clone, Copy, Eq, Debug, Default, Hash, PartialEq)]\nstruct EmptyFlags {\n    start: bool,\n    end: bool,\n    start_line: bool,\n    end_line: bool,\n    word_boundary: bool,\n    not_word_boundary: bool,\n}\n\n/// A set of flags describing various configurations of a DFA state. This is\n/// represented by a `u8` so that it is compact.\n#[derive(Clone, Copy, Eq, Default, Hash, PartialEq)]\nstruct StateFlags(u8);\n\nimpl Cache {\n    /// Create new empty cache for the DFA engine.\n    pub fn new(prog: &Program) -> Self {\n        // We add 1 to account for the special EOF byte.\n        let num_byte_classes = (prog.byte_classes[255] as usize + 1) + 1;\n        let starts = vec![STATE_UNKNOWN; 256];\n        let mut cache = Cache {\n            inner: CacheInner {\n                compiled: StateMap::new(num_byte_classes),\n                trans: Transitions::new(num_byte_classes),\n                start_states: starts,\n                stack: vec![],\n                flush_count: 0,\n                size: 0,\n                insts_scratch_space: vec![],\n            },\n            qcur: SparseSet::new(prog.insts.len()),\n            qnext: SparseSet::new(prog.insts.len()),\n        };\n        cache.inner.reset_size();\n        cache\n    }\n}\n\nimpl CacheInner {\n    /// Resets the cache size to account for fixed costs, such as the program\n    /// and stack sizes.\n    fn reset_size(&mut self) {\n        self.size = (self.start_states.len() * mem::size_of::<StatePtr>())\n            + (self.stack.len() * mem::size_of::<InstPtr>());\n    }\n}\n\nimpl<'a> Fsm<'a> {\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub fn forward(\n        prog: &'a Program,\n        cache: &ProgramCache,\n        quit_after_match: bool,\n        text: &[u8],\n        at: usize,\n    ) -> Result<usize> {\n        let mut cache = cache.borrow_mut();\n        let cache = &mut cache.dfa;\n        let mut dfa = Fsm {\n            prog: prog,\n            start: 0, // filled in below\n            at: at,\n            quit_after_match: quit_after_match,\n            last_match_si: STATE_UNKNOWN,\n            last_cache_flush: at,\n            cache: &mut cache.inner,\n        };\n        let (empty_flags, state_flags) = dfa.start_flags(text, at);\n        dfa.start =\n            match dfa.start_state(&mut cache.qcur, empty_flags, state_flags) {\n                None => return Result::Quit,\n                Some(STATE_DEAD) => return Result::NoMatch(at),\n                Some(si) => si,\n            };\n        debug_assert!(dfa.start != STATE_UNKNOWN);\n        dfa.exec_at(&mut cache.qcur, &mut cache.qnext, text)\n    }\n\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub fn reverse(\n        prog: &'a Program,\n        cache: &ProgramCache,\n        quit_after_match: bool,\n        text: &[u8],\n        at: usize,\n    ) -> Result<usize> {\n        let mut cache = cache.borrow_mut();\n        let cache = &mut cache.dfa_reverse;\n        let mut dfa = Fsm {\n            prog: prog,\n            start: 0, // filled in below\n            at: at,\n            quit_after_match: quit_after_match,\n            last_match_si: STATE_UNKNOWN,\n            last_cache_flush: at,\n            cache: &mut cache.inner,\n        };\n        let (empty_flags, state_flags) = dfa.start_flags_reverse(text, at);\n        dfa.start =\n            match dfa.start_state(&mut cache.qcur, empty_flags, state_flags) {\n                None => return Result::Quit,\n                Some(STATE_DEAD) => return Result::NoMatch(at),\n                Some(si) => si,\n            };\n        debug_assert!(dfa.start != STATE_UNKNOWN);\n        dfa.exec_at_reverse(&mut cache.qcur, &mut cache.qnext, text)\n    }\n\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub fn forward_many(\n        prog: &'a Program,\n        cache: &ProgramCache,\n        matches: &mut [bool],\n        text: &[u8],\n        at: usize,\n    ) -> Result<usize> {\n        debug_assert!(matches.len() == prog.matches.len());\n        let mut cache = cache.borrow_mut();\n        let cache = &mut cache.dfa;\n        let mut dfa = Fsm {\n            prog: prog,\n            start: 0, // filled in below\n            at: at,\n            quit_after_match: false,\n            last_match_si: STATE_UNKNOWN,\n            last_cache_flush: at,\n            cache: &mut cache.inner,\n        };\n        let (empty_flags, state_flags) = dfa.start_flags(text, at);\n        dfa.start =\n            match dfa.start_state(&mut cache.qcur, empty_flags, state_flags) {\n                None => return Result::Quit,\n                Some(STATE_DEAD) => return Result::NoMatch(at),\n                Some(si) => si,\n            };\n        debug_assert!(dfa.start != STATE_UNKNOWN);\n        let result = dfa.exec_at(&mut cache.qcur, &mut cache.qnext, text);\n        if result.is_match() {\n            if matches.len() == 1 {\n                matches[0] = true;\n            } else {\n                debug_assert!(dfa.last_match_si != STATE_UNKNOWN);\n                debug_assert!(dfa.last_match_si != STATE_DEAD);\n                for ip in dfa.state(dfa.last_match_si).inst_ptrs() {\n                    if let Inst::Match(slot) = dfa.prog[ip] {\n                        matches[slot] = true;\n                    }\n                }\n            }\n        }\n        result\n    }\n\n    /// Executes the DFA on a forward NFA.\n    ///\n    /// {qcur,qnext} are scratch ordered sets which may be non-empty.\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn exec_at(\n        &mut self,\n        qcur: &mut SparseSet,\n        qnext: &mut SparseSet,\n        text: &[u8],\n    ) -> Result<usize> {\n        // For the most part, the DFA is basically:\n        //\n        //   last_match = null\n        //   while current_byte != EOF:\n        //     si = current_state.next[current_byte]\n        //     if si is match\n        //       last_match = si\n        //   return last_match\n        //\n        // However, we need to deal with a few things:\n        //\n        //   1. This is an *online* DFA, so the current state's next list\n        //      may not point to anywhere yet, so we must go out and compute\n        //      them. (They are then cached into the current state's next list\n        //      to avoid re-computation.)\n        //   2. If we come across a state that is known to be dead (i.e., never\n        //      leads to a match), then we can quit early.\n        //   3. If the caller just wants to know if a match occurs, then we\n        //      can quit as soon as we know we have a match. (Full leftmost\n        //      first semantics require continuing on.)\n        //   4. If we're in the start state, then we can use a pre-computed set\n        //      of prefix literals to skip quickly along the input.\n        //   5. After the input is exhausted, we run the DFA on one symbol\n        //      that stands for EOF. This is useful for handling empty width\n        //      assertions.\n        //   6. We can't actually do state.next[byte]. Instead, we have to do\n        //      state.next[byte_classes[byte]], which permits us to keep the\n        //      'next' list very small.\n        //\n        // Since there's a bunch of extra stuff we need to consider, we do some\n        // pretty hairy tricks to get the inner loop to run as fast as\n        // possible.\n        debug_assert!(!self.prog.is_reverse);\n\n        // The last match is the currently known ending match position. It is\n        // reported as an index to the most recent byte that resulted in a\n        // transition to a match state and is always stored in capture slot `1`\n        // when searching forwards. Its maximum value is `text.len()`.\n        let mut result = Result::NoMatch(self.at);\n        let (mut prev_si, mut next_si) = (self.start, self.start);\n        let mut at = self.at;\n        while at < text.len() {\n            // This is the real inner loop. We take advantage of special bits\n            // set in the state pointer to determine whether a state is in the\n            // \"common\" case or not. Specifically, the common case is a\n            // non-match non-start non-dead state that has already been\n            // computed. So long as we remain in the common case, this inner\n            // loop will chew through the input.\n            //\n            // We also unroll the loop 4 times to amortize the cost of checking\n            // whether we've consumed the entire input. We are also careful\n            // to make sure that `prev_si` always represents the previous state\n            // and `next_si` always represents the next state after the loop\n            // exits, even if it isn't always true inside the loop.\n            while next_si <= STATE_MAX && at < text.len() {\n                // Argument for safety is in the definition of next_si.\n                prev_si = unsafe { self.next_si(next_si, text, at) };\n                at += 1;\n                if prev_si > STATE_MAX || at + 2 >= text.len() {\n                    mem::swap(&mut prev_si, &mut next_si);\n                    break;\n                }\n                next_si = unsafe { self.next_si(prev_si, text, at) };\n                at += 1;\n                if next_si > STATE_MAX {\n                    break;\n                }\n                prev_si = unsafe { self.next_si(next_si, text, at) };\n                at += 1;\n                if prev_si > STATE_MAX {\n                    mem::swap(&mut prev_si, &mut next_si);\n                    break;\n                }\n                next_si = unsafe { self.next_si(prev_si, text, at) };\n                at += 1;\n            }\n            if next_si & STATE_MATCH > 0 {\n                // A match state is outside of the common case because it needs\n                // special case analysis. In particular, we need to record the\n                // last position as having matched and possibly quit the DFA if\n                // we don't need to keep matching.\n                next_si &= !STATE_MATCH;\n                result = Result::Match(at - 1);\n                if self.quit_after_match {\n                    return result;\n                }\n                self.last_match_si = next_si;\n                prev_si = next_si;\n\n                // This permits short-circuiting when matching a regex set.\n                // In particular, if this DFA state contains only match states,\n                // then it's impossible to extend the set of matches since\n                // match states are final. Therefore, we can quit.\n                if self.prog.matches.len() > 1 {\n                    let state = self.state(next_si);\n                    let just_matches =\n                        state.inst_ptrs().all(|ip| self.prog[ip].is_match());\n                    if just_matches {\n                        return result;\n                    }\n                }\n\n                // Another inner loop! If the DFA stays in this particular\n                // match state, then we can rip through all of the input\n                // very quickly, and only recording the match location once\n                // we've left this particular state.\n                let cur = at;\n                while (next_si & !STATE_MATCH) == prev_si\n                    && at + 2 < text.len()\n                {\n                    // Argument for safety is in the definition of next_si.\n                    next_si = unsafe {\n                        self.next_si(next_si & !STATE_MATCH, text, at)\n                    };\n                    at += 1;\n                }\n                if at > cur {\n                    result = Result::Match(at - 2);\n                }\n            } else if next_si & STATE_START > 0 {\n                // A start state isn't in the common case because we may\n                // what to do quick prefix scanning. If the program doesn't\n                // have a detected prefix, then start states are actually\n                // considered common and this case is never reached.\n                debug_assert!(self.has_prefix());\n                next_si &= !STATE_START;\n                prev_si = next_si;\n                at = match self.prefix_at(text, at) {\n                    None => return Result::NoMatch(text.len()),\n                    Some(i) => i,\n                };\n            } else if next_si >= STATE_UNKNOWN {\n                if next_si == STATE_QUIT {\n                    return Result::Quit;\n                }\n                // Finally, this corresponds to the case where the transition\n                // entered a state that can never lead to a match or a state\n                // that hasn't been computed yet. The latter being the \"slow\"\n                // path.\n                let byte = Byte::byte(text[at - 1]);\n                // We no longer care about the special bits in the state\n                // pointer.\n                prev_si &= STATE_MAX;\n                // Record where we are. This is used to track progress for\n                // determining whether we should quit if we've flushed the\n                // cache too much.\n                self.at = at;\n                next_si = match self.next_state(qcur, qnext, prev_si, byte) {\n                    None => return Result::Quit,\n                    Some(STATE_DEAD) => return result.set_non_match(at),\n                    Some(si) => si,\n                };\n                debug_assert!(next_si != STATE_UNKNOWN);\n                if next_si & STATE_MATCH > 0 {\n                    next_si &= !STATE_MATCH;\n                    result = Result::Match(at - 1);\n                    if self.quit_after_match {\n                        return result;\n                    }\n                    self.last_match_si = next_si;\n                }\n                prev_si = next_si;\n            } else {\n                prev_si = next_si;\n            }\n        }\n\n        // Run the DFA once more on the special EOF senitnel value.\n        // We don't care about the special bits in the state pointer any more,\n        // so get rid of them.\n        prev_si &= STATE_MAX;\n        prev_si = match self.next_state(qcur, qnext, prev_si, Byte::eof()) {\n            None => return Result::Quit,\n            Some(STATE_DEAD) => return result.set_non_match(text.len()),\n            Some(si) => si & !STATE_START,\n        };\n        debug_assert!(prev_si != STATE_UNKNOWN);\n        if prev_si & STATE_MATCH > 0 {\n            prev_si &= !STATE_MATCH;\n            self.last_match_si = prev_si;\n            result = Result::Match(text.len());\n        }\n        result\n    }\n\n    /// Executes the DFA on a reverse NFA.\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn exec_at_reverse(\n        &mut self,\n        qcur: &mut SparseSet,\n        qnext: &mut SparseSet,\n        text: &[u8],\n    ) -> Result<usize> {\n        // The comments in `exec_at` above mostly apply here too. The main\n        // difference is that we move backwards over the input and we look for\n        // the longest possible match instead of the leftmost-first match.\n        //\n        // N.B. The code duplication here is regrettable. Efforts to improve\n        // it without sacrificing performance are welcome. ---AG\n        debug_assert!(self.prog.is_reverse);\n        let mut result = Result::NoMatch(self.at);\n        let (mut prev_si, mut next_si) = (self.start, self.start);\n        let mut at = self.at;\n        while at > 0 {\n            while next_si <= STATE_MAX && at > 0 {\n                // Argument for safety is in the definition of next_si.\n                at -= 1;\n                prev_si = unsafe { self.next_si(next_si, text, at) };\n                if prev_si > STATE_MAX || at <= 4 {\n                    mem::swap(&mut prev_si, &mut next_si);\n                    break;\n                }\n                at -= 1;\n                next_si = unsafe { self.next_si(prev_si, text, at) };\n                if next_si > STATE_MAX {\n                    break;\n                }\n                at -= 1;\n                prev_si = unsafe { self.next_si(next_si, text, at) };\n                if prev_si > STATE_MAX {\n                    mem::swap(&mut prev_si, &mut next_si);\n                    break;\n                }\n                at -= 1;\n                next_si = unsafe { self.next_si(prev_si, text, at) };\n            }\n            if next_si & STATE_MATCH > 0 {\n                next_si &= !STATE_MATCH;\n                result = Result::Match(at + 1);\n                if self.quit_after_match {\n                    return result;\n                }\n                self.last_match_si = next_si;\n                prev_si = next_si;\n                let cur = at;\n                while (next_si & !STATE_MATCH) == prev_si && at >= 2 {\n                    // Argument for safety is in the definition of next_si.\n                    at -= 1;\n                    next_si = unsafe {\n                        self.next_si(next_si & !STATE_MATCH, text, at)\n                    };\n                }\n                if at < cur {\n                    result = Result::Match(at + 2);\n                }\n            } else if next_si >= STATE_UNKNOWN {\n                if next_si == STATE_QUIT {\n                    return Result::Quit;\n                }\n                let byte = Byte::byte(text[at]);\n                prev_si &= STATE_MAX;\n                self.at = at;\n                next_si = match self.next_state(qcur, qnext, prev_si, byte) {\n                    None => return Result::Quit,\n                    Some(STATE_DEAD) => return result.set_non_match(at),\n                    Some(si) => si,\n                };\n                debug_assert!(next_si != STATE_UNKNOWN);\n                if next_si & STATE_MATCH > 0 {\n                    next_si &= !STATE_MATCH;\n                    result = Result::Match(at + 1);\n                    if self.quit_after_match {\n                        return result;\n                    }\n                    self.last_match_si = next_si;\n                }\n                prev_si = next_si;\n            } else {\n                prev_si = next_si;\n            }\n        }\n\n        // Run the DFA once more on the special EOF senitnel value.\n        prev_si = match self.next_state(qcur, qnext, prev_si, Byte::eof()) {\n            None => return Result::Quit,\n            Some(STATE_DEAD) => return result.set_non_match(0),\n            Some(si) => si,\n        };\n        debug_assert!(prev_si != STATE_UNKNOWN);\n        if prev_si & STATE_MATCH > 0 {\n            prev_si &= !STATE_MATCH;\n            self.last_match_si = prev_si;\n            result = Result::Match(0);\n        }\n        result\n    }\n\n    /// next_si transitions to the next state, where the transition input\n    /// corresponds to text[i].\n    ///\n    /// This elides bounds checks, and is therefore unsafe.\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    unsafe fn next_si(&self, si: StatePtr, text: &[u8], i: usize) -> StatePtr {\n        // What is the argument for safety here?\n        // We have three unchecked accesses that could possibly violate safety:\n        //\n        //   1. The given byte of input (`text[i]`).\n        //   2. The class of the byte of input (`classes[text[i]]`).\n        //   3. The transition for the class (`trans[si + cls]`).\n        //\n        // (1) is only safe when calling next_si is guarded by\n        // `i < text.len()`.\n        //\n        // (2) is the easiest case to guarantee since `text[i]` is always a\n        // `u8` and `self.prog.byte_classes` always has length `u8::MAX`.\n        // (See `ByteClassSet.byte_classes` in `compile.rs`.)\n        //\n        // (3) is only safe if (1)+(2) are safe. Namely, the transitions\n        // of every state are defined to have length equal to the number of\n        // byte classes in the program. Therefore, a valid class leads to a\n        // valid transition. (All possible transitions are valid lookups, even\n        // if it points to a state that hasn't been computed yet.) (3) also\n        // relies on `si` being correct, but StatePtrs should only ever be\n        // retrieved from the transition table, which ensures they are correct.\n        debug_assert!(i < text.len());\n        let b = *text.get_unchecked(i);\n        debug_assert!((b as usize) < self.prog.byte_classes.len());\n        let cls = *self.prog.byte_classes.get_unchecked(b as usize);\n        self.cache.trans.next_unchecked(si, cls as usize)\n    }\n\n    /// Computes the next state given the current state and the current input\n    /// byte (which may be EOF).\n    ///\n    /// If STATE_DEAD is returned, then there is no valid state transition.\n    /// This implies that no permutation of future input can lead to a match\n    /// state.\n    ///\n    /// STATE_UNKNOWN can never be returned.\n    fn exec_byte(\n        &mut self,\n        qcur: &mut SparseSet,\n        qnext: &mut SparseSet,\n        mut si: StatePtr,\n        b: Byte,\n    ) -> Option<StatePtr> {\n        use prog::Inst::*;\n\n        // Initialize a queue with the current DFA state's NFA states.\n        qcur.clear();\n        for ip in self.state(si).inst_ptrs() {\n            qcur.insert(ip);\n        }\n\n        // Before inspecting the current byte, we may need to also inspect\n        // whether the position immediately preceding the current byte\n        // satisfies the empty assertions found in the current state.\n        //\n        // We only need to do this step if there are any empty assertions in\n        // the current state.\n        let is_word_last = self.state(si).flags().is_word();\n        let is_word = b.is_ascii_word();\n        if self.state(si).flags().has_empty() {\n            // Compute the flags immediately preceding the current byte.\n            // This means we only care about the \"end\" or \"end line\" flags.\n            // (The \"start\" flags are computed immediately proceding the\n            // current byte and is handled below.)\n            let mut flags = EmptyFlags::default();\n            if b.is_eof() {\n                flags.end = true;\n                flags.end_line = true;\n            } else if b.as_byte().map_or(false, |b| b == b'\\n') {\n                flags.end_line = true;\n            }\n            if is_word_last == is_word {\n                flags.not_word_boundary = true;\n            } else {\n                flags.word_boundary = true;\n            }\n            // Now follow epsilon transitions from every NFA state, but make\n            // sure we only follow transitions that satisfy our flags.\n            qnext.clear();\n            for &ip in &*qcur {\n                self.follow_epsilons(usize_to_u32(ip), qnext, flags);\n            }\n            mem::swap(qcur, qnext);\n        }\n\n        // Now we set flags for immediately after the current byte. Since start\n        // states are processed separately, and are the only states that can\n        // have the StartText flag set, we therefore only need to worry about\n        // the StartLine flag here.\n        //\n        // We do also keep track of whether this DFA state contains a NFA state\n        // that is a matching state. This is precisely how we delay the DFA\n        // matching by one byte in order to process the special EOF sentinel\n        // byte. Namely, if this DFA state containing a matching NFA state,\n        // then it is the *next* DFA state that is marked as a match.\n        let mut empty_flags = EmptyFlags::default();\n        let mut state_flags = StateFlags::default();\n        empty_flags.start_line = b.as_byte().map_or(false, |b| b == b'\\n');\n        if b.is_ascii_word() {\n            state_flags.set_word();\n        }\n        // Now follow all epsilon transitions again, but only after consuming\n        // the current byte.\n        qnext.clear();\n        for &ip in &*qcur {\n            match self.prog[ip as usize] {\n                // These states never happen in a byte-based program.\n                Char(_) | Ranges(_) => unreachable!(),\n                // These states are handled when following epsilon transitions.\n                Save(_) | Split(_) | EmptyLook(_) => {}\n                Match(_) => {\n                    state_flags.set_match();\n                    if !self.continue_past_first_match() {\n                        break;\n                    } else if self.prog.matches.len() > 1\n                        && !qnext.contains(ip as usize)\n                    {\n                        // If we are continuing on to find other matches,\n                        // then keep a record of the match states we've seen.\n                        qnext.insert(ip);\n                    }\n                }\n                Bytes(ref inst) => {\n                    if b.as_byte().map_or(false, |b| inst.matches(b)) {\n                        self.follow_epsilons(\n                            inst.goto as InstPtr,\n                            qnext,\n                            empty_flags,\n                        );\n                    }\n                }\n            }\n        }\n\n        let cache = if b.is_eof() && self.prog.matches.len() > 1 {\n            // If we're processing the last byte of the input and we're\n            // matching a regex set, then make the next state contain the\n            // previous states transitions. We do this so that the main\n            // matching loop can extract all of the match instructions.\n            mem::swap(qcur, qnext);\n            // And don't cache this state because it's totally bunk.\n            false\n        } else {\n            true\n        };\n\n        // We've now built up the set of NFA states that ought to comprise the\n        // next DFA state, so try to find it in the cache, and if it doesn't\n        // exist, cache it.\n        //\n        // N.B. We pass `&mut si` here because the cache may clear itself if\n        // it has gotten too full. When that happens, the location of the\n        // current state may change.\n        let mut next =\n            match self.cached_state(qnext, state_flags, Some(&mut si)) {\n                None => return None,\n                Some(next) => next,\n            };\n        if (self.start & !STATE_START) == next {\n            // Start states can never be match states since all matches are\n            // delayed by one byte.\n            debug_assert!(!self.state(next).flags().is_match());\n            next = self.start_ptr(next);\n        }\n        if next <= STATE_MAX && self.state(next).flags().is_match() {\n            next |= STATE_MATCH;\n        }\n        debug_assert!(next != STATE_UNKNOWN);\n        // And now store our state in the current state's next list.\n        if cache {\n            let cls = self.byte_class(b);\n            self.cache.trans.set_next(si, cls, next);\n        }\n        Some(next)\n    }\n\n    /// Follows the epsilon transitions starting at (and including) `ip`. The\n    /// resulting states are inserted into the ordered set `q`.\n    ///\n    /// Conditional epsilon transitions (i.e., empty width assertions) are only\n    /// followed if they are satisfied by the given flags, which should\n    /// represent the flags set at the current location in the input.\n    ///\n    /// If the current location corresponds to the empty string, then only the\n    /// end line and/or end text flags may be set. If the current location\n    /// corresponds to a real byte in the input, then only the start line\n    /// and/or start text flags may be set.\n    ///\n    /// As an exception to the above, when finding the initial state, any of\n    /// the above flags may be set:\n    ///\n    /// If matching starts at the beginning of the input, then start text and\n    /// start line should be set. If the input is empty, then end text and end\n    /// line should also be set.\n    ///\n    /// If matching starts after the beginning of the input, then only start\n    /// line should be set if the preceding byte is `\\n`. End line should never\n    /// be set in this case. (Even if the proceding byte is a `\\n`, it will\n    /// be handled in a subsequent DFA state.)\n    fn follow_epsilons(\n        &mut self,\n        ip: InstPtr,\n        q: &mut SparseSet,\n        flags: EmptyFlags,\n    ) {\n        use prog::EmptyLook::*;\n        use prog::Inst::*;\n\n        // We need to traverse the NFA to follow epsilon transitions, so avoid\n        // recursion with an explicit stack.\n        self.cache.stack.push(ip);\n        while let Some(mut ip) = self.cache.stack.pop() {\n            // Try to munch through as many states as possible without\n            // pushes/pops to the stack.\n            loop {\n                // Don't visit states we've already added.\n                if q.contains(ip as usize) {\n                    break;\n                }\n                q.insert(ip as usize);\n                match self.prog[ip as usize] {\n                    Char(_) | Ranges(_) => unreachable!(),\n                    Match(_) | Bytes(_) => {\n                        break;\n                    }\n                    EmptyLook(ref inst) => {\n                        // Only follow empty assertion states if our flags\n                        // satisfy the assertion.\n                        match inst.look {\n                            StartLine if flags.start_line => {\n                                ip = inst.goto as InstPtr;\n                            }\n                            EndLine if flags.end_line => {\n                                ip = inst.goto as InstPtr;\n                            }\n                            StartText if flags.start => {\n                                ip = inst.goto as InstPtr;\n                            }\n                            EndText if flags.end => {\n                                ip = inst.goto as InstPtr;\n                            }\n                            WordBoundaryAscii if flags.word_boundary => {\n                                ip = inst.goto as InstPtr;\n                            }\n                            NotWordBoundaryAscii\n                                if flags.not_word_boundary =>\n                            {\n                                ip = inst.goto as InstPtr;\n                            }\n                            WordBoundary if flags.word_boundary => {\n                                ip = inst.goto as InstPtr;\n                            }\n                            NotWordBoundary if flags.not_word_boundary => {\n                                ip = inst.goto as InstPtr;\n                            }\n                            StartLine | EndLine | StartText | EndText\n                            | WordBoundaryAscii | NotWordBoundaryAscii\n                            | WordBoundary | NotWordBoundary => {\n                                break;\n                            }\n                        }\n                    }\n                    Save(ref inst) => {\n                        ip = inst.goto as InstPtr;\n                    }\n                    Split(ref inst) => {\n                        self.cache.stack.push(inst.goto2 as InstPtr);\n                        ip = inst.goto1 as InstPtr;\n                    }\n                }\n            }\n        }\n    }\n\n    /// Find a previously computed state matching the given set of instructions\n    /// and is_match bool.\n    ///\n    /// The given set of instructions should represent a single state in the\n    /// NFA along with all states reachable without consuming any input.\n    ///\n    /// The is_match bool should be true if and only if the preceding DFA state\n    /// contains an NFA matching state. The cached state produced here will\n    /// then signify a match. (This enables us to delay a match by one byte,\n    /// in order to account for the EOF sentinel byte.)\n    ///\n    /// If the cache is full, then it is wiped before caching a new state.\n    ///\n    /// The current state should be specified if it exists, since it will need\n    /// to be preserved if the cache clears itself. (Start states are\n    /// always saved, so they should not be passed here.) It takes a mutable\n    /// pointer to the index because if the cache is cleared, the state's\n    /// location may change.\n    fn cached_state(\n        &mut self,\n        q: &SparseSet,\n        mut state_flags: StateFlags,\n        current_state: Option<&mut StatePtr>,\n    ) -> Option<StatePtr> {\n        // If we couldn't come up with a non-empty key to represent this state,\n        // then it is dead and can never lead to a match.\n        //\n        // Note that inst_flags represent the set of empty width assertions\n        // in q. We use this as an optimization in exec_byte to determine when\n        // we should follow epsilon transitions at the empty string preceding\n        // the current byte.\n        let key = match self.cached_state_key(q, &mut state_flags) {\n            None => return Some(STATE_DEAD),\n            Some(v) => v,\n        };\n        // In the cache? Cool. Done.\n        if let Some(si) = self.cache.compiled.get_ptr(&key) {\n            return Some(si);\n        }\n        // If the cache has gotten too big, wipe it.\n        if self.approximate_size() > self.prog.dfa_size_limit\n            && !self.clear_cache_and_save(current_state)\n        {\n            // Ooops. DFA is giving up.\n            return None;\n        }\n        // Allocate room for our state and add it.\n        self.add_state(key)\n    }\n\n    /// Produces a key suitable for describing a state in the DFA cache.\n    ///\n    /// The key invariant here is that equivalent keys are produced for any two\n    /// sets of ordered NFA states (and toggling of whether the previous NFA\n    /// states contain a match state) that do not discriminate a match for any\n    /// input.\n    ///\n    /// Specifically, q should be an ordered set of NFA states and is_match\n    /// should be true if and only if the previous NFA states contained a match\n    /// state.\n    fn cached_state_key(\n        &mut self,\n        q: &SparseSet,\n        state_flags: &mut StateFlags,\n    ) -> Option<State> {\n        use prog::Inst::*;\n\n        // We need to build up enough information to recognize pre-built states\n        // in the DFA. Generally speaking, this includes every instruction\n        // except for those which are purely epsilon transitions, e.g., the\n        // Save and Split instructions.\n        //\n        // Empty width assertions are also epsilon transitions, but since they\n        // are conditional, we need to make them part of a state's key in the\n        // cache.\n\n        let mut insts =\n            mem::replace(&mut self.cache.insts_scratch_space, vec![]);\n        insts.clear();\n        // Reserve 1 byte for flags.\n        insts.push(0);\n\n        let mut prev = 0;\n        for &ip in q {\n            let ip = usize_to_u32(ip);\n            match self.prog[ip as usize] {\n                Char(_) | Ranges(_) => unreachable!(),\n                Save(_) | Split(_) => {}\n                Bytes(_) => push_inst_ptr(&mut insts, &mut prev, ip),\n                EmptyLook(_) => {\n                    state_flags.set_empty();\n                    push_inst_ptr(&mut insts, &mut prev, ip)\n                }\n                Match(_) => {\n                    push_inst_ptr(&mut insts, &mut prev, ip);\n                    if !self.continue_past_first_match() {\n                        break;\n                    }\n                }\n            }\n        }\n        // If we couldn't transition to any other instructions and we didn't\n        // see a match when expanding NFA states previously, then this is a\n        // dead state and no amount of additional input can transition out\n        // of this state.\n        let opt_state = if insts.len() == 1 && !state_flags.is_match() {\n            None\n        } else {\n            let StateFlags(f) = *state_flags;\n            insts[0] = f;\n            Some(State { data: Arc::from(&*insts) })\n        };\n        self.cache.insts_scratch_space = insts;\n        opt_state\n    }\n\n    /// Clears the cache, but saves and restores current_state if it is not\n    /// none.\n    ///\n    /// The current state must be provided here in case its location in the\n    /// cache changes.\n    ///\n    /// This returns false if the cache is not cleared and the DFA should\n    /// give up.\n    fn clear_cache_and_save(\n        &mut self,\n        current_state: Option<&mut StatePtr>,\n    ) -> bool {\n        if self.cache.compiled.is_empty() {\n            // Nothing to clear...\n            return true;\n        }\n        match current_state {\n            None => self.clear_cache(),\n            Some(si) => {\n                let cur = self.state(*si).clone();\n                if !self.clear_cache() {\n                    return false;\n                }\n                // The unwrap is OK because we just cleared the cache and\n                // therefore know that the next state pointer won't exceed\n                // STATE_MAX.\n                *si = self.restore_state(cur).unwrap();\n                true\n            }\n        }\n    }\n\n    /// Wipes the state cache, but saves and restores the current start state.\n    ///\n    /// This returns false if the cache is not cleared and the DFA should\n    /// give up.\n    fn clear_cache(&mut self) -> bool {\n        // Bail out of the DFA if we're moving too \"slowly.\"\n        // A heuristic from RE2: assume the DFA is too slow if it is processing\n        // 10 or fewer bytes per state.\n        // Additionally, we permit the cache to be flushed a few times before\n        // caling it quits.\n        let nstates = self.cache.compiled.len();\n        if self.cache.flush_count >= 3\n            && self.at >= self.last_cache_flush\n            && (self.at - self.last_cache_flush) <= 10 * nstates\n        {\n            return false;\n        }\n        // Update statistics tracking cache flushes.\n        self.last_cache_flush = self.at;\n        self.cache.flush_count += 1;\n\n        // OK, actually flush the cache.\n        let start = self.state(self.start & !STATE_START).clone();\n        let last_match = if self.last_match_si <= STATE_MAX {\n            Some(self.state(self.last_match_si).clone())\n        } else {\n            None\n        };\n        self.cache.reset_size();\n        self.cache.trans.clear();\n        self.cache.compiled.clear();\n        for s in &mut self.cache.start_states {\n            *s = STATE_UNKNOWN;\n        }\n        // The unwraps are OK because we just cleared the cache and therefore\n        // know that the next state pointer won't exceed STATE_MAX.\n        let start_ptr = self.restore_state(start).unwrap();\n        self.start = self.start_ptr(start_ptr);\n        if let Some(last_match) = last_match {\n            self.last_match_si = self.restore_state(last_match).unwrap();\n        }\n        true\n    }\n\n    /// Restores the given state back into the cache, and returns a pointer\n    /// to it.\n    fn restore_state(&mut self, state: State) -> Option<StatePtr> {\n        // If we've already stored this state, just return a pointer to it.\n        // None will be the wiser.\n        if let Some(si) = self.cache.compiled.get_ptr(&state) {\n            return Some(si);\n        }\n        self.add_state(state)\n    }\n\n    /// Returns the next state given the current state si and current byte\n    /// b. {qcur,qnext} are used as scratch space for storing ordered NFA\n    /// states.\n    ///\n    /// This tries to fetch the next state from the cache, but if that fails,\n    /// it computes the next state, caches it and returns a pointer to it.\n    ///\n    /// The pointer can be to a real state, or it can be STATE_DEAD.\n    /// STATE_UNKNOWN cannot be returned.\n    ///\n    /// None is returned if a new state could not be allocated (i.e., the DFA\n    /// ran out of space and thinks it's running too slowly).\n    fn next_state(\n        &mut self,\n        qcur: &mut SparseSet,\n        qnext: &mut SparseSet,\n        si: StatePtr,\n        b: Byte,\n    ) -> Option<StatePtr> {\n        if si == STATE_DEAD {\n            return Some(STATE_DEAD);\n        }\n        match self.cache.trans.next(si, self.byte_class(b)) {\n            STATE_UNKNOWN => self.exec_byte(qcur, qnext, si, b),\n            STATE_QUIT => None,\n            STATE_DEAD => Some(STATE_DEAD),\n            nsi => Some(nsi),\n        }\n    }\n\n    /// Computes and returns the start state, where searching begins at\n    /// position `at` in `text`. If the state has already been computed,\n    /// then it is pulled from the cache. If the state hasn't been cached,\n    /// then it is computed, cached and a pointer to it is returned.\n    ///\n    /// This may return STATE_DEAD but never STATE_UNKNOWN.\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn start_state(\n        &mut self,\n        q: &mut SparseSet,\n        empty_flags: EmptyFlags,\n        state_flags: StateFlags,\n    ) -> Option<StatePtr> {\n        // Compute an index into our cache of start states based on the set\n        // of empty/state flags set at the current position in the input. We\n        // don't use every flag since not all flags matter. For example, since\n        // matches are delayed by one byte, start states can never be match\n        // states.\n        let flagi = {\n            (((empty_flags.start as u8) << 0)\n                | ((empty_flags.end as u8) << 1)\n                | ((empty_flags.start_line as u8) << 2)\n                | ((empty_flags.end_line as u8) << 3)\n                | ((empty_flags.word_boundary as u8) << 4)\n                | ((empty_flags.not_word_boundary as u8) << 5)\n                | ((state_flags.is_word() as u8) << 6)) as usize\n        };\n        match self.cache.start_states[flagi] {\n            STATE_UNKNOWN => {}\n            STATE_DEAD => return Some(STATE_DEAD),\n            si => return Some(si),\n        }\n        q.clear();\n        let start = usize_to_u32(self.prog.start);\n        self.follow_epsilons(start, q, empty_flags);\n        // Start states can never be match states because we delay every match\n        // by one byte. Given an empty string and an empty match, the match\n        // won't actually occur until the DFA processes the special EOF\n        // sentinel byte.\n        let sp = match self.cached_state(q, state_flags, None) {\n            None => return None,\n            Some(sp) => self.start_ptr(sp),\n        };\n        self.cache.start_states[flagi] = sp;\n        Some(sp)\n    }\n\n    /// Computes the set of starting flags for the given position in text.\n    ///\n    /// This should only be used when executing the DFA forwards over the\n    /// input.\n    fn start_flags(&self, text: &[u8], at: usize) -> (EmptyFlags, StateFlags) {\n        let mut empty_flags = EmptyFlags::default();\n        let mut state_flags = StateFlags::default();\n        empty_flags.start = at == 0;\n        empty_flags.end = text.is_empty();\n        empty_flags.start_line = at == 0 || text[at - 1] == b'\\n';\n        empty_flags.end_line = text.is_empty();\n\n        let is_word_last = at > 0 && Byte::byte(text[at - 1]).is_ascii_word();\n        let is_word = at < text.len() && Byte::byte(text[at]).is_ascii_word();\n        if is_word_last {\n            state_flags.set_word();\n        }\n        if is_word == is_word_last {\n            empty_flags.not_word_boundary = true;\n        } else {\n            empty_flags.word_boundary = true;\n        }\n        (empty_flags, state_flags)\n    }\n\n    /// Computes the set of starting flags for the given position in text.\n    ///\n    /// This should only be used when executing the DFA in reverse over the\n    /// input.\n    fn start_flags_reverse(\n        &self,\n        text: &[u8],\n        at: usize,\n    ) -> (EmptyFlags, StateFlags) {\n        let mut empty_flags = EmptyFlags::default();\n        let mut state_flags = StateFlags::default();\n        empty_flags.start = at == text.len();\n        empty_flags.end = text.is_empty();\n        empty_flags.start_line = at == text.len() || text[at] == b'\\n';\n        empty_flags.end_line = text.is_empty();\n\n        let is_word_last =\n            at < text.len() && Byte::byte(text[at]).is_ascii_word();\n        let is_word = at > 0 && Byte::byte(text[at - 1]).is_ascii_word();\n        if is_word_last {\n            state_flags.set_word();\n        }\n        if is_word == is_word_last {\n            empty_flags.not_word_boundary = true;\n        } else {\n            empty_flags.word_boundary = true;\n        }\n        (empty_flags, state_flags)\n    }\n\n    /// Returns a reference to a State given a pointer to it.\n    fn state(&self, si: StatePtr) -> &State {\n        self.cache.compiled.get_state(si).unwrap()\n    }\n\n    /// Adds the given state to the DFA.\n    ///\n    /// This allocates room for transitions out of this state in\n    /// self.cache.trans. The transitions can be set with the returned\n    /// StatePtr.\n    ///\n    /// If None is returned, then the state limit was reached and the DFA\n    /// should quit.\n    fn add_state(&mut self, state: State) -> Option<StatePtr> {\n        // This will fail if the next state pointer exceeds STATE_PTR. In\n        // practice, the cache limit will prevent us from ever getting here,\n        // but maybe callers will set the cache size to something ridiculous...\n        let si = match self.cache.trans.add() {\n            None => return None,\n            Some(si) => si,\n        };\n        // If the program has a Unicode word boundary, then set any transitions\n        // for non-ASCII bytes to STATE_QUIT. If the DFA stumbles over such a\n        // transition, then it will quit and an alternative matching engine\n        // will take over.\n        if self.prog.has_unicode_word_boundary {\n            for b in 128..256 {\n                let cls = self.byte_class(Byte::byte(b as u8));\n                self.cache.trans.set_next(si, cls, STATE_QUIT);\n            }\n        }\n        // Finally, put our actual state on to our heap of states and index it\n        // so we can find it later.\n        self.cache.size += self.cache.trans.state_heap_size()\n            + state.data.len()\n            + (2 * mem::size_of::<State>())\n            + mem::size_of::<StatePtr>();\n        self.cache.compiled.insert(state, si);\n        // Transition table and set of states and map should all be in sync.\n        debug_assert!(\n            self.cache.compiled.len() == self.cache.trans.num_states()\n        );\n        Some(si)\n    }\n\n    /// Quickly finds the next occurrence of any literal prefixes in the regex.\n    /// If there are no literal prefixes, then the current position is\n    /// returned. If there are literal prefixes and one could not be found,\n    /// then None is returned.\n    ///\n    /// This should only be called when the DFA is in a start state.\n    fn prefix_at(&self, text: &[u8], at: usize) -> Option<usize> {\n        self.prog.prefixes.find(&text[at..]).map(|(s, _)| at + s)\n    }\n\n    /// Returns the number of byte classes required to discriminate transitions\n    /// in each state.\n    ///\n    /// invariant: num_byte_classes() == len(State.next)\n    fn num_byte_classes(&self) -> usize {\n        // We add 1 to account for the special EOF byte.\n        (self.prog.byte_classes[255] as usize + 1) + 1\n    }\n\n    /// Given an input byte or the special EOF sentinel, return its\n    /// corresponding byte class.\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn byte_class(&self, b: Byte) -> usize {\n        match b.as_byte() {\n            None => self.num_byte_classes() - 1,\n            Some(b) => self.u8_class(b),\n        }\n    }\n\n    /// Like byte_class, but explicitly for u8s.\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn u8_class(&self, b: u8) -> usize {\n        self.prog.byte_classes[b as usize] as usize\n    }\n\n    /// Returns true if the DFA should continue searching past the first match.\n    ///\n    /// Leftmost first semantics in the DFA are preserved by not following NFA\n    /// transitions after the first match is seen.\n    ///\n    /// On occasion, we want to avoid leftmost first semantics to find either\n    /// the longest match (for reverse search) or all possible matches (for\n    /// regex sets).\n    fn continue_past_first_match(&self) -> bool {\n        self.prog.is_reverse || self.prog.matches.len() > 1\n    }\n\n    /// Returns true if there is a prefix we can quickly search for.\n    fn has_prefix(&self) -> bool {\n        !self.prog.is_reverse\n            && !self.prog.prefixes.is_empty()\n            && !self.prog.is_anchored_start\n    }\n\n    /// Sets the STATE_START bit in the given state pointer if and only if\n    /// we have a prefix to scan for.\n    ///\n    /// If there's no prefix, then it's a waste to treat the start state\n    /// specially.\n    fn start_ptr(&self, si: StatePtr) -> StatePtr {\n        if self.has_prefix() {\n            si | STATE_START\n        } else {\n            si\n        }\n    }\n\n    /// Approximate size returns the approximate heap space currently used by\n    /// the DFA. It is used to determine whether the DFA's state cache needs to\n    /// be wiped. Namely, it is possible that for certain regexes on certain\n    /// inputs, a new state could be created for every byte of input. (This is\n    /// bad for memory use, so we bound it with a cache.)\n    fn approximate_size(&self) -> usize {\n        self.cache.size + self.prog.approximate_size()\n    }\n}\n\n/// An abstraction for representing a map of states. The map supports two\n/// different ways of state lookup. One is fast constant time access via a\n/// state pointer. The other is a hashmap lookup based on the DFA's\n/// constituent NFA states.\n///\n/// A DFA state internally uses an Arc such that we only need to store the\n/// set of NFA states on the heap once, even though we support looking up\n/// states by two different means. A more natural way to express this might\n/// use raw pointers, but an Arc is safe and effectively achieves the same\n/// thing.\n#[derive(Debug)]\nstruct StateMap {\n    /// The keys are not actually static but rely on always pointing to a\n    /// buffer in `states` which will never be moved except when clearing\n    /// the map or on drop, in which case the keys of this map will be\n    /// removed before\n    map: HashMap<State, StatePtr>,\n    /// Our set of states. Note that `StatePtr / num_byte_classes` indexes\n    /// this Vec rather than just a `StatePtr`.\n    states: Vec<State>,\n    /// The number of byte classes in the DFA. Used to index `states`.\n    num_byte_classes: usize,\n}\n\nimpl StateMap {\n    fn new(num_byte_classes: usize) -> StateMap {\n        StateMap {\n            map: HashMap::new(),\n            states: vec![],\n            num_byte_classes: num_byte_classes,\n        }\n    }\n\n    fn len(&self) -> usize {\n        self.states.len()\n    }\n\n    fn is_empty(&self) -> bool {\n        self.states.is_empty()\n    }\n\n    fn get_ptr(&self, state: &State) -> Option<StatePtr> {\n        self.map.get(state).cloned()\n    }\n\n    fn get_state(&self, si: StatePtr) -> Option<&State> {\n        self.states.get(si as usize / self.num_byte_classes)\n    }\n\n    fn insert(&mut self, state: State, si: StatePtr) {\n        self.map.insert(state.clone(), si);\n        self.states.push(state);\n    }\n\n    fn clear(&mut self) {\n        self.map.clear();\n        self.states.clear();\n    }\n}\n\nimpl Transitions {\n    /// Create a new transition table.\n    ///\n    /// The number of byte classes corresponds to the stride. Every state will\n    /// have `num_byte_classes` slots for transitions.\n    fn new(num_byte_classes: usize) -> Transitions {\n        Transitions { table: vec![], num_byte_classes: num_byte_classes }\n    }\n\n    /// Returns the total number of states currently in this table.\n    fn num_states(&self) -> usize {\n        self.table.len() / self.num_byte_classes\n    }\n\n    /// Allocates room for one additional state and returns a pointer to it.\n    ///\n    /// If there's no more room, None is returned.\n    fn add(&mut self) -> Option<StatePtr> {\n        let si = self.table.len();\n        if si > STATE_MAX as usize {\n            return None;\n        }\n        self.table.extend(repeat(STATE_UNKNOWN).take(self.num_byte_classes));\n        Some(usize_to_u32(si))\n    }\n\n    /// Clears the table of all states.\n    fn clear(&mut self) {\n        self.table.clear();\n    }\n\n    /// Sets the transition from (si, cls) to next.\n    fn set_next(&mut self, si: StatePtr, cls: usize, next: StatePtr) {\n        self.table[si as usize + cls] = next;\n    }\n\n    /// Returns the transition corresponding to (si, cls).\n    fn next(&self, si: StatePtr, cls: usize) -> StatePtr {\n        self.table[si as usize + cls]\n    }\n\n    /// The heap size, in bytes, of a single state in the transition table.\n    fn state_heap_size(&self) -> usize {\n        self.num_byte_classes * mem::size_of::<StatePtr>()\n    }\n\n    /// Like `next`, but uses unchecked access and is therefore unsafe.\n    unsafe fn next_unchecked(&self, si: StatePtr, cls: usize) -> StatePtr {\n        debug_assert!((si as usize) < self.table.len());\n        debug_assert!(cls < self.num_byte_classes);\n        *self.table.get_unchecked(si as usize + cls)\n    }\n}\n\nimpl StateFlags {\n    fn is_match(&self) -> bool {\n        self.0 & 0b0000000_1 > 0\n    }\n\n    fn set_match(&mut self) {\n        self.0 |= 0b0000000_1;\n    }\n\n    fn is_word(&self) -> bool {\n        self.0 & 0b000000_1_0 > 0\n    }\n\n    fn set_word(&mut self) {\n        self.0 |= 0b000000_1_0;\n    }\n\n    fn has_empty(&self) -> bool {\n        self.0 & 0b00000_1_00 > 0\n    }\n\n    fn set_empty(&mut self) {\n        self.0 |= 0b00000_1_00;\n    }\n}\n\nimpl Byte {\n    fn byte(b: u8) -> Self {\n        Byte(b as u16)\n    }\n    fn eof() -> Self {\n        Byte(256)\n    }\n    fn is_eof(&self) -> bool {\n        self.0 == 256\n    }\n\n    fn is_ascii_word(&self) -> bool {\n        let b = match self.as_byte() {\n            None => return false,\n            Some(b) => b,\n        };\n        match b {\n            b'A'..=b'Z' | b'a'..=b'z' | b'0'..=b'9' | b'_' => true,\n            _ => false,\n        }\n    }\n\n    fn as_byte(&self) -> Option<u8> {\n        if self.is_eof() {\n            None\n        } else {\n            Some(self.0 as u8)\n        }\n    }\n}\n\nimpl fmt::Debug for State {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let ips: Vec<usize> = self.inst_ptrs().collect();\n        f.debug_struct(\"State\")\n            .field(\"flags\", &self.flags())\n            .field(\"insts\", &ips)\n            .finish()\n    }\n}\n\nimpl fmt::Debug for Transitions {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let mut fmtd = f.debug_map();\n        for si in 0..self.num_states() {\n            let s = si * self.num_byte_classes;\n            let e = s + self.num_byte_classes;\n            fmtd.entry(&si.to_string(), &TransitionsRow(&self.table[s..e]));\n        }\n        fmtd.finish()\n    }\n}\n\nstruct TransitionsRow<'a>(&'a [StatePtr]);\n\nimpl<'a> fmt::Debug for TransitionsRow<'a> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let mut fmtd = f.debug_map();\n        for (b, si) in self.0.iter().enumerate() {\n            match *si {\n                STATE_UNKNOWN => {}\n                STATE_DEAD => {\n                    fmtd.entry(&vb(b as usize), &\"DEAD\");\n                }\n                si => {\n                    fmtd.entry(&vb(b as usize), &si.to_string());\n                }\n            }\n        }\n        fmtd.finish()\n    }\n}\n\nimpl fmt::Debug for StateFlags {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"StateFlags\")\n            .field(\"is_match\", &self.is_match())\n            .field(\"is_word\", &self.is_word())\n            .field(\"has_empty\", &self.has_empty())\n            .finish()\n    }\n}\n\n/// Helper function for formatting a byte as a nice-to-read escaped string.\nfn vb(b: usize) -> String {\n    use std::ascii::escape_default;\n\n    if b > ::std::u8::MAX as usize {\n        \"EOF\".to_owned()\n    } else {\n        let escaped = escape_default(b as u8).collect::<Vec<u8>>();\n        String::from_utf8_lossy(&escaped).into_owned()\n    }\n}\n\nfn usize_to_u32(n: usize) -> u32 {\n    if (n as u64) > (::std::u32::MAX as u64) {\n        panic!(\"BUG: {} is too big to fit into u32\", n)\n    }\n    n as u32\n}\n\n#[allow(dead_code)] // useful for debugging\nfn show_state_ptr(si: StatePtr) -> String {\n    let mut s = format!(\"{:?}\", si & STATE_MAX);\n    if si == STATE_UNKNOWN {\n        s = format!(\"{} (unknown)\", s);\n    }\n    if si == STATE_DEAD {\n        s = format!(\"{} (dead)\", s);\n    }\n    if si == STATE_QUIT {\n        s = format!(\"{} (quit)\", s);\n    }\n    if si & STATE_START > 0 {\n        s = format!(\"{} (start)\", s);\n    }\n    if si & STATE_MATCH > 0 {\n        s = format!(\"{} (match)\", s);\n    }\n    s\n}\n\n/// https://developers.google.com/protocol-buffers/docs/encoding#varints\nfn write_vari32(data: &mut Vec<u8>, n: i32) {\n    let mut un = (n as u32) << 1;\n    if n < 0 {\n        un = !un;\n    }\n    write_varu32(data, un)\n}\n\n/// https://developers.google.com/protocol-buffers/docs/encoding#varints\nfn read_vari32(data: &[u8]) -> (i32, usize) {\n    let (un, i) = read_varu32(data);\n    let mut n = (un >> 1) as i32;\n    if un & 1 != 0 {\n        n = !n;\n    }\n    (n, i)\n}\n\n/// https://developers.google.com/protocol-buffers/docs/encoding#varints\nfn write_varu32(data: &mut Vec<u8>, mut n: u32) {\n    while n >= 0b1000_0000 {\n        data.push((n as u8) | 0b1000_0000);\n        n >>= 7;\n    }\n    data.push(n as u8);\n}\n\n/// https://developers.google.com/protocol-buffers/docs/encoding#varints\nfn read_varu32(data: &[u8]) -> (u32, usize) {\n    let mut n: u32 = 0;\n    let mut shift: u32 = 0;\n    for (i, &b) in data.iter().enumerate() {\n        if b < 0b1000_0000 {\n            return (n | ((b as u32) << shift), i + 1);\n        }\n        n |= ((b as u32) & 0b0111_1111) << shift;\n        shift += 7;\n    }\n    (0, 0)\n}\n\n#[cfg(test)]\nmod tests {\n    extern crate rand;\n\n    use super::{\n        push_inst_ptr, read_vari32, read_varu32, write_vari32, write_varu32,\n        State, StateFlags,\n    };\n    use quickcheck::{quickcheck, QuickCheck, StdGen};\n    use std::sync::Arc;\n\n    #[test]\n    fn prop_state_encode_decode() {\n        fn p(ips: Vec<u32>, flags: u8) -> bool {\n            let mut data = vec![flags];\n            let mut prev = 0;\n            for &ip in ips.iter() {\n                push_inst_ptr(&mut data, &mut prev, ip);\n            }\n            let state = State { data: Arc::from(&data[..]) };\n\n            let expected: Vec<usize> =\n                ips.into_iter().map(|ip| ip as usize).collect();\n            let got: Vec<usize> = state.inst_ptrs().collect();\n            expected == got && state.flags() == StateFlags(flags)\n        }\n        QuickCheck::new()\n            .gen(StdGen::new(self::rand::thread_rng(), 10_000))\n            .quickcheck(p as fn(Vec<u32>, u8) -> bool);\n    }\n\n    #[test]\n    fn prop_read_write_u32() {\n        fn p(n: u32) -> bool {\n            let mut buf = vec![];\n            write_varu32(&mut buf, n);\n            let (got, nread) = read_varu32(&buf);\n            nread == buf.len() && got == n\n        }\n        quickcheck(p as fn(u32) -> bool);\n    }\n\n    #[test]\n    fn prop_read_write_i32() {\n        fn p(n: i32) -> bool {\n            let mut buf = vec![];\n            write_vari32(&mut buf, n);\n            let (got, nread) = read_vari32(&buf);\n            nread == buf.len() && got == n\n        }\n        quickcheck(p as fn(i32) -> bool);\n    }\n}\n","traces":[{"line":57,"address":[5860064],"length":1,"stats":{"Line":12},"fn_name":"can_exec"},{"line":65,"address":[5860142,5860076],"length":1,"stats":{"Line":25},"fn_name":null},{"line":66,"address":[5860210],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[5860370,5860193,5860368,5860237,5860296],"length":1,"stats":{"Line":39},"fn_name":null},{"line":69,"address":[5860356],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[5860358,5860318],"length":1,"stats":{"Line":13},"fn_name":null},{"line":74,"address":[5860289],"length":1,"stats":{"Line":13},"fn_name":null},{"line":217,"address":[4404720],"length":1,"stats":{"Line":2},"fn_name":"is_match<usize>"},{"line":218,"address":[4404748,4404741],"length":1,"stats":{"Line":3},"fn_name":null},{"line":219,"address":[4404729,4404743],"length":1,"stats":{"Line":5},"fn_name":null},{"line":220,"address":[4404750],"length":1,"stats":{"Line":2},"fn_name":null},{"line":228,"address":[4404784,4404893],"length":1,"stats":{"Line":2},"fn_name":"map<(usize, usize),usize,closure-0>"},{"line":229,"address":[4404830,4404925],"length":1,"stats":{"Line":2},"fn_name":null},{"line":230,"address":[4404839,4404788,4404911],"length":1,"stats":{"Line":6},"fn_name":null},{"line":231,"address":[4404932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[4404821],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[4404992],"length":1,"stats":{"Line":2},"fn_name":"set_non_match<usize>"},{"line":240,"address":[4405088,4405068],"length":1,"stats":{"Line":4},"fn_name":null},{"line":241,"address":[4405011,4405074],"length":1,"stats":{"Line":4},"fn_name":null},{"line":242,"address":[4405033],"length":1,"stats":{"Line":2},"fn_name":null},{"line":276,"address":[5860384],"length":1,"stats":{"Line":9},"fn_name":"push_inst_ptr"},{"line":277,"address":[5860498,5860468,5860402],"length":1,"stats":{"Line":9},"fn_name":null},{"line":278,"address":[5860445],"length":1,"stats":{"Line":9},"fn_name":null},{"line":279,"address":[5860461],"length":1,"stats":{"Line":9},"fn_name":null},{"line":290,"address":[5860512],"length":1,"stats":{"Line":9},"fn_name":"next"},{"line":291,"address":[5860521],"length":1,"stats":{"Line":9},"fn_name":null},{"line":292,"address":[5860586],"length":1,"stats":{"Line":9},"fn_name":null},{"line":294,"address":[5860562,5860614],"length":1,"stats":{"Line":18},"fn_name":null},{"line":295,"address":[5860633,5860859,5860889],"length":1,"stats":{"Line":9},"fn_name":null},{"line":296,"address":[5860700,5860664],"length":1,"stats":{"Line":9},"fn_name":null},{"line":297,"address":[5860775,5860683],"length":1,"stats":{"Line":9},"fn_name":null},{"line":298,"address":[5860735,5860815],"length":1,"stats":{"Line":18},"fn_name":null},{"line":299,"address":[5860831],"length":1,"stats":{"Line":9},"fn_name":null},{"line":300,"address":[5860837],"length":1,"stats":{"Line":9},"fn_name":null},{"line":305,"address":[5860896],"length":1,"stats":{"Line":9},"fn_name":"flags"},{"line":306,"address":[5860991,5860905,5860964],"length":1,"stats":{"Line":18},"fn_name":null},{"line":309,"address":[5860992],"length":1,"stats":{"Line":1},"fn_name":"inst_ptrs"},{"line":310,"address":[5861009],"length":1,"stats":{"Line":9},"fn_name":null},{"line":414,"address":[5861194,5861120],"length":1,"stats":{"Line":25},"fn_name":"new"},{"line":416,"address":[5861138,5861214,5862192],"length":1,"stats":{"Line":48},"fn_name":null},{"line":417,"address":[5861286],"length":1,"stats":{"Line":23},"fn_name":null},{"line":419,"address":[5861565],"length":1,"stats":{"Line":23},"fn_name":null},{"line":428,"address":[5861870,5861818],"length":1,"stats":{"Line":48},"fn_name":null},{"line":429,"address":[5861882],"length":1,"stats":{"Line":25},"fn_name":null},{"line":431,"address":[5862081],"length":1,"stats":{"Line":23},"fn_name":null},{"line":432,"address":[5862093],"length":1,"stats":{"Line":25},"fn_name":null},{"line":439,"address":[5862400],"length":1,"stats":{"Line":25},"fn_name":"reset_size"},{"line":440,"address":[5862409,5862566,5862602,5862662,5862692,5862466],"length":1,"stats":{"Line":71},"fn_name":null},{"line":441,"address":[5862538,5862489,5862632],"length":1,"stats":{"Line":48},"fn_name":null},{"line":447,"address":[4458523,4432763],"length":1,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[4450399,4424549],"length":1,"stats":{"Line":32},"fn_name":null},{"line":455,"address":[4450431,4424581],"length":1,"stats":{"Line":32},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[4424736,4450586],"length":1,"stats":{"Line":32},"fn_name":null},{"line":466,"address":[4425804,4451654],"length":1,"stats":{"Line":31},"fn_name":null},{"line":467,"address":[4424887,4425747,4451597,4451689,4425839,4450737],"length":1,"stats":{"Line":63},"fn_name":null},{"line":468,"address":[4451611,4451691,4451716,4425761,4425866,4425841],"length":1,"stats":{"Line":33},"fn_name":null},{"line":469,"address":[4451729,4425777,4451627,4425879],"length":1,"stats":{"Line":31},"fn_name":null},{"line":470,"address":[4451640,4425790],"length":1,"stats":{"Line":33},"fn_name":null},{"line":472,"address":[4432705,4458465,4425811,4451661],"length":1,"stats":{"Line":33},"fn_name":null},{"line":473,"address":[4451759,4432674,4425909,4458434],"length":1,"stats":{"Line":63},"fn_name":null},{"line":477,"address":[4449416,4440137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[4442503,4433216],"length":1,"stats":{"Line":29},"fn_name":null},{"line":485,"address":[4442535,4433256],"length":1,"stats":{"Line":29},"fn_name":null},{"line":493,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[4433411,4442690],"length":1,"stats":{"Line":29},"fn_name":null},{"line":496,"address":[4434479,4443758],"length":1,"stats":{"Line":35},"fn_name":null},{"line":497,"address":[4433562,4434514,4434422,4442841,4443701,4443793],"length":1,"stats":{"Line":64},"fn_name":null},{"line":498,"address":[4443715,4443820,4434436,4434516,4434541,4443795],"length":1,"stats":{"Line":33},"fn_name":null},{"line":499,"address":[4443731,4434452,4434554,4443833],"length":1,"stats":{"Line":35},"fn_name":null},{"line":500,"address":[4434465,4443744],"length":1,"stats":{"Line":33},"fn_name":null},{"line":502,"address":[4434486,4449358,4443765,4440079],"length":1,"stats":{"Line":33},"fn_name":null},{"line":503,"address":[4440048,4443863,4434584,4449327],"length":1,"stats":{"Line":66},"fn_name":null},{"line":507,"address":[5403962,5394312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[5385253,5394918,5385371,5395036],"length":1,"stats":{"Line":2},"fn_name":null},{"line":515,"address":[5394992,5385327],"length":1,"stats":{"Line":2},"fn_name":null},{"line":516,"address":[5395021,5395074,5385356,5385409],"length":1,"stats":{"Line":4},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[5385541,5395206],"length":1,"stats":{"Line":2},"fn_name":null},{"line":527,"address":[5396274,5386609],"length":1,"stats":{"Line":2},"fn_name":null},{"line":528,"address":[5386552,5396217,5395357,5386644,5396309,5385692],"length":1,"stats":{"Line":4},"fn_name":null},{"line":529,"address":[5396311,5386646,5396336,5396231,5386566,5386671],"length":1,"stats":{"Line":2},"fn_name":null},{"line":530,"address":[5396349,5386582,5396247,5386684],"length":1,"stats":{"Line":2},"fn_name":null},{"line":531,"address":[5396260,5386595],"length":1,"stats":{"Line":2},"fn_name":null},{"line":533,"address":[5396281,5393517,5403182,5386616],"length":1,"stats":{"Line":3},"fn_name":null},{"line":534,"address":[5393479,5396379,5403144,5386714],"length":1,"stats":{"Line":5},"fn_name":null},{"line":535,"address":[5394232,5403222,5403882,5403168,5393503,5393557],"length":1,"stats":{"Line":9},"fn_name":null},{"line":536,"address":[5393975,5403640,5403231,5403343,5393566,5393678],"length":1,"stats":{"Line":11},"fn_name":null},{"line":537,"address":[5394335,5403314,5393649,5403985],"length":1,"stats":{"Line":2},"fn_name":null},{"line":539,"address":[5403280,5393705,5403370,5393615],"length":1,"stats":{"Line":3},"fn_name":null},{"line":540,"address":[5403433,5393683,5403348,5393768],"length":1,"stats":{"Line":3},"fn_name":null},{"line":541,"address":[5403645,5394227,5403403,5393738,5403482,5403877,5393980,5393817],"length":1,"stats":{"Line":9},"fn_name":null},{"line":542,"address":[5394365,5403679,5404015,5394087,5394014,5403749],"length":1,"stats":{"Line":10},"fn_name":null},{"line":543,"address":[5404049,5403837,5394399,5394181],"length":1,"stats":{"Line":4},"fn_name":null},{"line":548,"address":[5394234,5403884],"length":1,"stats":{"Line":2},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":593,"address":[4426152,4452002,4425994,4451844],"length":1,"stats":{"Line":37},"fn_name":null},{"line":599,"address":[4426034,4451884],"length":1,"stats":{"Line":35},"fn_name":null},{"line":600,"address":[4451916,4426066],"length":1,"stats":{"Line":37},"fn_name":null},{"line":601,"address":[4451980,4426130],"length":1,"stats":{"Line":35},"fn_name":null},{"line":602,"address":[4431799,4426184,4452034,4452000,4457598,4426150],"length":1,"stats":{"Line":107},"fn_name":null},{"line":615,"address":[4452294,4426444,4429352,4455202],"length":1,"stats":{"Line":62},"fn_name":null},{"line":617,"address":[4426569,4452988,4427138,4452419],"length":1,"stats":{"Line":68},"fn_name":null},{"line":618,"address":[4432270,4458033,4427145,4452995],"length":1,"stats":{"Line":34},"fn_name":null},{"line":619,"address":[4432302,4453046,4427196,4458065],"length":1,"stats":{"Line":34},"fn_name":null},{"line":620,"address":[4427952,4453802],"length":1,"stats":{"Line":32},"fn_name":null},{"line":621,"address":[4453829,4427979],"length":1,"stats":{"Line":32},"fn_name":null},{"line":623,"address":[4427908,4453758,4427339,4453189],"length":1,"stats":{"Line":47},"fn_name":null},{"line":624,"address":[4432334,4453765,4427915,4453865,4428015,4458097],"length":1,"stats":{"Line":51},"fn_name":null},{"line":625,"address":[4453873,4428023],"length":1,"stats":{"Line":26},"fn_name":null},{"line":626,"address":[4454503,4428653],"length":1,"stats":{"Line":10},"fn_name":null},{"line":628,"address":[4454459,4428040,4453890,4428609],"length":1,"stats":{"Line":48},"fn_name":null},{"line":629,"address":[4454466,4458129,4454516,4428666,4432366,4428616],"length":1,"stats":{"Line":49},"fn_name":null},{"line":630,"address":[4428674,4454524],"length":1,"stats":{"Line":25},"fn_name":null},{"line":631,"address":[4455154,4429304],"length":1,"stats":{"Line":6},"fn_name":null},{"line":632,"address":[4429331,4455181],"length":1,"stats":{"Line":7},"fn_name":null},{"line":634,"address":[4454541,4429260,4455110,4428691],"length":1,"stats":{"Line":47},"fn_name":null},{"line":635,"address":[4455117,4458161,4455194,4429344,4429267,4432398],"length":1,"stats":{"Line":49},"fn_name":null},{"line":637,"address":[4427981,4430749,4431797,4453831,4456599,4457596],"length":1,"stats":{"Line":85},"fn_name":null},{"line":642,"address":[4429383,4455233],"length":1,"stats":{"Line":20},"fn_name":null},{"line":643,"address":[4458193,4432430,4455252,4429402],"length":1,"stats":{"Line":20},"fn_name":null},{"line":644,"address":[4429497,4455347],"length":1,"stats":{"Line":20},"fn_name":null},{"line":645,"address":[4455452,4429602],"length":1,"stats":{"Line":6},"fn_name":null},{"line":647,"address":[4429511,4455361],"length":1,"stats":{"Line":14},"fn_name":null},{"line":648,"address":[4429529,4455379],"length":1,"stats":{"Line":14},"fn_name":null},{"line":654,"address":[4429778,4455628,4455393,4429543],"length":1,"stats":{"Line":17},"fn_name":null},{"line":655,"address":[4429641,4455491],"length":1,"stats":{"Line":2},"fn_name":null},{"line":656,"address":[4405203,4405136,4405150],"length":1,"stats":{"Line":11},"fn_name":"{{closure}}"},{"line":657,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[4455624,4429774],"length":1,"stats":{"Line":3},"fn_name":null},{"line":659,"address":[4429780,4455630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[4455667,4429817],"length":1,"stats":{"Line":15},"fn_name":null},{"line":668,"address":[4429920,4429986,4430650,4455691,4429841,4455836,4456500,4455770],"length":1,"stats":{"Line":61},"fn_name":null},{"line":669,"address":[4429884,4432462,4455734,4455782,4458225,4429932],"length":1,"stats":{"Line":33},"fn_name":null},{"line":672,"address":[4430592,4456442],"length":1,"stats":{"Line":10},"fn_name":null},{"line":673,"address":[4430017,4455867],"length":1,"stats":{"Line":10},"fn_name":null},{"line":675,"address":[4456449,4458257,4432494,4430599],"length":1,"stats":{"Line":11},"fn_name":null},{"line":677,"address":[4429998,4455848],"length":1,"stats":{"Line":17},"fn_name":null},{"line":678,"address":[4456505,4458289,4432526,4430655],"length":1,"stats":{"Line":11},"fn_name":null},{"line":680,"address":[4456855,4455207,4457594,4431795,4429357,4431005],"length":1,"stats":{"Line":93},"fn_name":null},{"line":685,"address":[4430949,4456626,4430776,4456799],"length":1,"stats":{"Line":24},"fn_name":null},{"line":686,"address":[4430815,4456665],"length":1,"stats":{"Line":24},"fn_name":null},{"line":687,"address":[4430831,4456681],"length":1,"stats":{"Line":26},"fn_name":null},{"line":688,"address":[4456847,4456860,4430845,4430997,4456695,4431010],"length":1,"stats":{"Line":51},"fn_name":null},{"line":689,"address":[4456862,4431012,4430932,4456782],"length":1,"stats":{"Line":38},"fn_name":null},{"line":690,"address":[4456831,4430981],"length":1,"stats":{"Line":25},"fn_name":null},{"line":692,"address":[4431094,4430754,4456938,4456604],"length":1,"stats":{"Line":57},"fn_name":null},{"line":693,"address":[4456943,4431099],"length":1,"stats":{"Line":32},"fn_name":null},{"line":694,"address":[4431148,4456989],"length":1,"stats":{"Line":14},"fn_name":null},{"line":700,"address":[4431112,4456956,4432558,4457016,4458321,4431178],"length":1,"stats":{"Line":63},"fn_name":null},{"line":703,"address":[4431245,4457074],"length":1,"stats":{"Line":32},"fn_name":null},{"line":707,"address":[4431262,4457091],"length":1,"stats":{"Line":32},"fn_name":null},{"line":708,"address":[4457257,4431282,4431440,4457111,4457226,4431409],"length":1,"stats":{"Line":62},"fn_name":null},{"line":709,"address":[4431366,4457259,4457183,4431442],"length":1,"stats":{"Line":32},"fn_name":null},{"line":710,"address":[4431382,4457199,4431461,4457278],"length":1,"stats":{"Line":49},"fn_name":null},{"line":711,"address":[4457212,4431395],"length":1,"stats":{"Line":30},"fn_name":null},{"line":713,"address":[4431416,4457369,4431564,4457233],"length":1,"stats":{"Line":30},"fn_name":null},{"line":714,"address":[4457347,4431542,4431742,4457541],"length":1,"stats":{"Line":46},"fn_name":null},{"line":715,"address":[4457401,4431596],"length":1,"stats":{"Line":22},"fn_name":null},{"line":716,"address":[4432626,4431615,4457420,4458386],"length":1,"stats":{"Line":22},"fn_name":null},{"line":717,"address":[4431710,4457509],"length":1,"stats":{"Line":22},"fn_name":null},{"line":718,"address":[4457543,4431744],"length":1,"stats":{"Line":6},"fn_name":null},{"line":720,"address":[4457523,4431724],"length":1,"stats":{"Line":16},"fn_name":null},{"line":722,"address":[4457580,4431781],"length":1,"stats":{"Line":30},"fn_name":null},{"line":724,"address":[4456924,4431080],"length":1,"stats":{"Line":23},"fn_name":null},{"line":731,"address":[4426260,4452110],"length":1,"stats":{"Line":26},"fn_name":null},{"line":732,"address":[4457673,4431874,4431836,4457635,4452126,4426276],"length":1,"stats":{"Line":52},"fn_name":null},{"line":733,"address":[4452269,4431876,4457675,4426419],"length":1,"stats":{"Line":27},"fn_name":null},{"line":734,"address":[4431893,4431804,4457692,4457603],"length":1,"stats":{"Line":43},"fn_name":null},{"line":735,"address":[4431817,4457616],"length":1,"stats":{"Line":25},"fn_name":null},{"line":737,"address":[4457642,4457841,4432072,4431843],"length":1,"stats":{"Line":25},"fn_name":null},{"line":738,"address":[4432050,4457819],"length":1,"stats":{"Line":25},"fn_name":null},{"line":739,"address":[4432104,4457873],"length":1,"stats":{"Line":23},"fn_name":null},{"line":740,"address":[4457889,4432120],"length":1,"stats":{"Line":23},"fn_name":null},{"line":741,"address":[4457907,4432138],"length":1,"stats":{"Line":26},"fn_name":null},{"line":743,"address":[4457996,4432233],"length":1,"stats":{"Line":25},"fn_name":null},{"line":748,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":760,"address":[4443948,4434669,4444091,4434812],"length":1,"stats":{"Line":33},"fn_name":null},{"line":761,"address":[4443989,4434710],"length":1,"stats":{"Line":35},"fn_name":null},{"line":762,"address":[4434738,4444017],"length":1,"stats":{"Line":33},"fn_name":null},{"line":763,"address":[4434794,4444073],"length":1,"stats":{"Line":35},"fn_name":null},{"line":764,"address":[4444089,4434844,4439404,4444123,4448683,4434810],"length":1,"stats":{"Line":98},"fn_name":null},{"line":765,"address":[4437659,4435011,4444290,4446938],"length":1,"stats":{"Line":53},"fn_name":null},{"line":767,"address":[4444354,4435075,4449019,4439740],"length":1,"stats":{"Line":34},"fn_name":null},{"line":768,"address":[4435125,4435669,4444948,4444404],"length":1,"stats":{"Line":62},"fn_name":null},{"line":769,"address":[4435676,4444955],"length":1,"stats":{"Line":34},"fn_name":null},{"line":770,"address":[4445047,4435768],"length":1,"stats":{"Line":31},"fn_name":null},{"line":771,"address":[4435795,4445074],"length":1,"stats":{"Line":34},"fn_name":null},{"line":773,"address":[4449051,4445011,4439772,4435732,4445110,4435831],"length":1,"stats":{"Line":44},"fn_name":null},{"line":774,"address":[4436383,4445118,4435839,4445662],"length":1,"stats":{"Line":44},"fn_name":null},{"line":775,"address":[4445669,4436390],"length":1,"stats":{"Line":22},"fn_name":null},{"line":776,"address":[4445718,4436439],"length":1,"stats":{"Line":6},"fn_name":null},{"line":778,"address":[4439804,4436403,4449083,4445682,4445731,4436452],"length":1,"stats":{"Line":41},"fn_name":null},{"line":779,"address":[4436460,4437004,4445739,4446283],"length":1,"stats":{"Line":43},"fn_name":null},{"line":780,"address":[4446290,4437011],"length":1,"stats":{"Line":22},"fn_name":null},{"line":781,"address":[4437060,4446339],"length":1,"stats":{"Line":4},"fn_name":null},{"line":782,"address":[4437087,4446366],"length":1,"stats":{"Line":5},"fn_name":null},{"line":784,"address":[4439836,4437100,4446379,4449115,4446303,4437024],"length":1,"stats":{"Line":44},"fn_name":null},{"line":785,"address":[4437108,4446931,4437652,4446387],"length":1,"stats":{"Line":44},"fn_name":null},{"line":787,"address":[4445076,4448681,4447981,4439402,4435797,4438702],"length":1,"stats":{"Line":75},"fn_name":null},{"line":788,"address":[4446965,4437686],"length":1,"stats":{"Line":19},"fn_name":null},{"line":789,"address":[4439868,4437705,4449147,4446984],"length":1,"stats":{"Line":19},"fn_name":null},{"line":790,"address":[4447079,4437800],"length":1,"stats":{"Line":20},"fn_name":null},{"line":791,"address":[4447143,4437864],"length":1,"stats":{"Line":2},"fn_name":null},{"line":793,"address":[4437810,4447089],"length":1,"stats":{"Line":18},"fn_name":null},{"line":794,"address":[4437824,4447103],"length":1,"stats":{"Line":18},"fn_name":null},{"line":795,"address":[4447117,4437838],"length":1,"stats":{"Line":18},"fn_name":null},{"line":796,"address":[4447141,4447882,4437862,4437903,4447182,4438603],"length":1,"stats":{"Line":55},"fn_name":null},{"line":798,"address":[4447275,4439900,4449179,4437996],"length":1,"stats":{"Line":18},"fn_name":null},{"line":799,"address":[4438596,4447875],"length":1,"stats":{"Line":19},"fn_name":null},{"line":800,"address":[4438046,4447325],"length":1,"stats":{"Line":18},"fn_name":null},{"line":803,"address":[4437977,4447256],"length":1,"stats":{"Line":16},"fn_name":null},{"line":804,"address":[4438608,4447887,4439932,4449211],"length":1,"stats":{"Line":19},"fn_name":null},{"line":806,"address":[4438721,4446943,4437664,4448000],"length":1,"stats":{"Line":58},"fn_name":null},{"line":807,"address":[4438726,4448005],"length":1,"stats":{"Line":31},"fn_name":null},{"line":808,"address":[4448058,4438779],"length":1,"stats":{"Line":0},"fn_name":null},{"line":810,"address":[4448018,4438812,4439964,4438739,4448091,4449243],"length":1,"stats":{"Line":65},"fn_name":null},{"line":811,"address":[4448126,4438847],"length":1,"stats":{"Line":34},"fn_name":null},{"line":812,"address":[4438864,4448143],"length":1,"stats":{"Line":31},"fn_name":null},{"line":813,"address":[4438880,4448159,4439055,4448334,4439024,4448303],"length":1,"stats":{"Line":65},"fn_name":null},{"line":814,"address":[4438981,4439057,4448336,4448260],"length":1,"stats":{"Line":30},"fn_name":null},{"line":815,"address":[4448276,4448355,4438997,4439076],"length":1,"stats":{"Line":53},"fn_name":null},{"line":816,"address":[4439010,4448289],"length":1,"stats":{"Line":29},"fn_name":null},{"line":818,"address":[4439031,4439179,4448310,4448458],"length":1,"stats":{"Line":29},"fn_name":null},{"line":819,"address":[4439157,4448436,4439349,4448628],"length":1,"stats":{"Line":57},"fn_name":null},{"line":820,"address":[4439211,4448490],"length":1,"stats":{"Line":26},"fn_name":null},{"line":821,"address":[4439230,4448509,4449279,4440000],"length":1,"stats":{"Line":29},"fn_name":null},{"line":822,"address":[4448604,4439325],"length":1,"stats":{"Line":27},"fn_name":null},{"line":823,"address":[4439351,4448630],"length":1,"stats":{"Line":2},"fn_name":null},{"line":825,"address":[4439335,4448614],"length":1,"stats":{"Line":27},"fn_name":null},{"line":827,"address":[4439388,4448667],"length":1,"stats":{"Line":29},"fn_name":null},{"line":829,"address":[4447986,4438707],"length":1,"stats":{"Line":24},"fn_name":null},{"line":834,"address":[4448715,4439467,4444138,4434859,4448746,4439436],"length":1,"stats":{"Line":58},"fn_name":null},{"line":835,"address":[4444265,4448748,4434986,4439469],"length":1,"stats":{"Line":31},"fn_name":null},{"line":836,"address":[4448765,4439486,4439409,4448688],"length":1,"stats":{"Line":49},"fn_name":null},{"line":837,"address":[4439422,4448701],"length":1,"stats":{"Line":31},"fn_name":null},{"line":839,"address":[4439443,4439582,4448722,4448861],"length":1,"stats":{"Line":31},"fn_name":null},{"line":840,"address":[4439563,4448842],"length":1,"stats":{"Line":29},"fn_name":null},{"line":841,"address":[4448893,4439614],"length":1,"stats":{"Line":31},"fn_name":null},{"line":842,"address":[4448912,4439633],"length":1,"stats":{"Line":29},"fn_name":null},{"line":843,"address":[4448926,4439647],"length":1,"stats":{"Line":31},"fn_name":null},{"line":845,"address":[4439703,4448982],"length":1,"stats":{"Line":29},"fn_name":null},{"line":853,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":875,"address":[4445196,4438130,4452738,4437186,4447409,4428118,4438357,4430342,4445423,4426647,4426888,4446044,4444482,4428769,4453508,4454619,4456192,4436144,4435430,4427658,4427417,4436765,4453267,4454209,4454860,4455951,4435917,4446465,4452497,4453968,4436538,4447636,4446692,4445817,4430101,4437413,4428359,4444709,4435203,4429010],"length":1,"stats":{"Line":231},"fn_name":null},{"line":876,"address":[4446545,4435283,4445897,4436618,4444562,4426735,4430189,4453355,4445276,4435997,4428206,4452585,4454056,4454707,4447489,4456039,4428857,4438210,4427505,4437266],"length":1,"stats":{"Line":228},"fn_name":null},{"line":877,"address":[4427690,4428917,4447549,4452770,4428391,4435462,4454892,4437445,4436057,4430249,4444622,4436678,4428266,4447668,4446076,4437326,4453415,4430374,4435343,4438270,4426795,4436797,4454241,4427565,4444741,4452645,4456099,4456224,4445957,4426920,4436176,4454116,4446605,4438389,4454767,4429042,4446724,4453540,4445336,4445455],"length":1,"stats":{"Line":236},"fn_name":null},{"line":878,"address":[4436829,4453580,4435494,4445487,4429082,4427730,4428431,4454281,4446756,4438421,4447700,4456264,4444773,4430414,4436208,4454932,4426960,4452810,4446108,4437477],"length":1,"stats":{"Line":231},"fn_name":null},{"line":879,"address":[4446891,4453719,4430553,4427099,4437612,4455071,4456403,4427869,4429221,4435629,4428570,4436964,4438556,4444908,4436343,4446243,4445622,4447835,4454420,4452949],"length":1,"stats":{"Line":238},"fn_name":null},{"line":890,"address":[5862704],"length":1,"stats":{"Line":8},"fn_name":"exec_byte"},{"line":900,"address":[5862759],"length":1,"stats":{"Line":8},"fn_name":null},{"line":901,"address":[5862783,5863027,5862977],"length":1,"stats":{"Line":16},"fn_name":null},{"line":902,"address":[5863019],"length":1,"stats":{"Line":8},"fn_name":null},{"line":911,"address":[5863037,5862947],"length":1,"stats":{"Line":16},"fn_name":null},{"line":912,"address":[5863081],"length":1,"stats":{"Line":8},"fn_name":null},{"line":913,"address":[5863759,5863113],"length":1,"stats":{"Line":16},"fn_name":null},{"line":918,"address":[5863197],"length":1,"stats":{"Line":8},"fn_name":null},{"line":919,"address":[5863331,5863253,5863407],"length":1,"stats":{"Line":18},"fn_name":null},{"line":920,"address":[5863315],"length":1,"stats":{"Line":2},"fn_name":null},{"line":921,"address":[5863323],"length":1,"stats":{"Line":2},"fn_name":null},{"line":922,"address":[4405302,4405296],"length":1,"stats":{"Line":32},"fn_name":"{{closure}}"},{"line":923,"address":[5863399],"length":1,"stats":{"Line":3},"fn_name":null},{"line":925,"address":[5863416,5863442],"length":1,"stats":{"Line":16},"fn_name":null},{"line":926,"address":[5863444],"length":1,"stats":{"Line":2},"fn_name":null},{"line":928,"address":[5863434],"length":1,"stats":{"Line":8},"fn_name":null},{"line":932,"address":[5863460],"length":1,"stats":{"Line":8},"fn_name":null},{"line":933,"address":[5863473,5863599,5863754],"length":1,"stats":{"Line":16},"fn_name":null},{"line":934,"address":[5863636],"length":1,"stats":{"Line":8},"fn_name":null},{"line":936,"address":[5863589],"length":1,"stats":{"Line":8},"fn_name":null},{"line":949,"address":[5863761],"length":1,"stats":{"Line":8},"fn_name":null},{"line":950,"address":[5863817],"length":1,"stats":{"Line":8},"fn_name":null},{"line":951,"address":[4405328,4405334],"length":1,"stats":{"Line":24},"fn_name":"{{closure}}"},{"line":952,"address":[5863925,5863971],"length":1,"stats":{"Line":16},"fn_name":null},{"line":953,"address":[5863958],"length":1,"stats":{"Line":8},"fn_name":null},{"line":957,"address":[5863981],"length":1,"stats":{"Line":8},"fn_name":null},{"line":958,"address":[5864716,5863994],"length":1,"stats":{"Line":16},"fn_name":null},{"line":959,"address":[5864182,5865702,5864216,5864337,5864714,5864141,5864549,5865730],"length":1,"stats":{"Line":34},"fn_name":null},{"line":963,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":964,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":965,"address":[5864369],"length":1,"stats":{"Line":2},"fn_name":null},{"line":966,"address":[5864390],"length":1,"stats":{"Line":2},"fn_name":null},{"line":967,"address":[5864443],"length":1,"stats":{"Line":2},"fn_name":null},{"line":968,"address":[5864492,5864547,5864417,5864448,5864523],"length":1,"stats":{"Line":10},"fn_name":null},{"line":969,"address":[5864521,5864481],"length":1,"stats":{"Line":4},"fn_name":null},{"line":973,"address":[5864542],"length":1,"stats":{"Line":2},"fn_name":null},{"line":976,"address":[5864281],"length":1,"stats":{"Line":8},"fn_name":null},{"line":977,"address":[4405360,4405374],"length":1,"stats":{"Line":40},"fn_name":"{{closure}}"},{"line":978,"address":[5864662],"length":1,"stats":{"Line":8},"fn_name":null},{"line":979,"address":[5864622],"length":1,"stats":{"Line":8},"fn_name":null},{"line":980,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":981,"address":[5864632],"length":1,"stats":{"Line":8},"fn_name":null},{"line":988,"address":[5864721,5864818,5864184],"length":1,"stats":{"Line":18},"fn_name":null},{"line":993,"address":[5864836],"length":1,"stats":{"Line":2},"fn_name":null},{"line":995,"address":[5864841],"length":1,"stats":{"Line":2},"fn_name":null},{"line":997,"address":[5864810],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1007,"address":[5864849,5864983],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1008,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1009,"address":[5864916,5864985],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1010,"address":[5864932],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1012,"address":[5864961],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1015,"address":[5865018,5865115],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1016,"address":[5865149,5865089],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1018,"address":[5865156],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1019,"address":[5865274],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1021,"address":[5865328,5865293],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1023,"address":[5865313,5865670],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1024,"address":[5865596,5865358],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1025,"address":[5865617],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1027,"address":[5865672],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1053,"address":[5865744],"length":1,"stats":{"Line":8},"fn_name":"follow_epsilons"},{"line":1064,"address":[5865801],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1065,"address":[5865884,5865830,5865894],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1068,"address":[5865892,5866505],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1070,"address":[5865896],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1071,"address":[5865944],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1073,"address":[5865926],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1074,"address":[5865951,5866443,5866510,5866538,5866491,5866140,5865987],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1076,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1077,"address":[5866172],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1079,"address":[5866182],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1082,"address":[5866411,5866388,5866365,5866261,5866290,5866240,5866434,5866342,5866319],"length":1,"stats":{"Line":21},"fn_name":null},{"line":1083,"address":[5866204,5866242,5866266],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1084,"address":[5866254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1086,"address":[5866295,5866271],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1087,"address":[5866283],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1089,"address":[5866300,5866321],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1090,"address":[5866312],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1092,"address":[5866344,5866323],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1093,"address":[5866335],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1095,"address":[5866367,5866346],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1096,"address":[5866358],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1098,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1099,"address":[5866369,5866390],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1101,"address":[5866381],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1103,"address":[5866413,5866392],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1104,"address":[5866404],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1106,"address":[5866415,5866436],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1107,"address":[5866427],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1112,"address":[5866438],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1116,"address":[5866450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1117,"address":[5866483],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1119,"address":[5866070],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1120,"address":[5866108],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1121,"address":[5866498],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1146,"address":[5866544,5866613],"length":1,"stats":{"Line":8},"fn_name":"cached_state"},{"line":1159,"address":[5866576,5866718],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1160,"address":[5866628,5866720,5866769],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1161,"address":[5866648],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1164,"address":[5866791,5866832,5866694],"length":1,"stats":{"Line":18},"fn_name":null},{"line":1165,"address":[5866843,5866875],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1168,"address":[5866880,5866820,5866954,5866915],"length":1,"stats":{"Line":18},"fn_name":null},{"line":1169,"address":[5866952,5866904],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1172,"address":[5866995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1175,"address":[5866960,5867012],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1188,"address":[5867088,5867215],"length":1,"stats":{"Line":8},"fn_name":"cached_state_key"},{"line":1204,"address":[5867123],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1206,"address":[5867267],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1208,"address":[5867286],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1210,"address":[5867307],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1211,"address":[5867326,5867819],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1212,"address":[5867515,5867470],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1213,"address":[5867812,5867572,5867530,5867781,5868365,5867737,5867675],"length":1,"stats":{"Line":34},"fn_name":null},{"line":1215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1216,"address":[5867730],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1218,"address":[5867747],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1219,"address":[5867774],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1222,"address":[5867668],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1223,"address":[5867791],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1224,"address":[5867814],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1233,"address":[5867824,5867484,5867957],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1234,"address":[5867945],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1236,"address":[5867908],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1237,"address":[5867933,5867968],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1238,"address":[5867970],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1240,"address":[5868207,5868279,5868084],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1241,"address":[5868313],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1252,"address":[5868416,5868458],"length":1,"stats":{"Line":2},"fn_name":"clear_cache_and_save"},{"line":1256,"address":[5868430,5868474],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1258,"address":[5868502],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1260,"address":[5868555,5868573,5868740],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1261,"address":[5868562,5868480],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1262,"address":[5868521],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1263,"address":[5868531,5868575],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1264,"address":[5868605],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1265,"address":[5868686,5868661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1270,"address":[5868626,5868691],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1271,"address":[5868730],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1280,"address":[5868863,5868800],"length":1,"stats":{"Line":2},"fn_name":"clear_cache"},{"line":1286,"address":[5868815],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1287,"address":[5869000,5868883,5869061,5868951],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1288,"address":[5868992],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1289,"address":[5868924,5869021,5870010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1291,"address":[5869122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1294,"address":[5869077],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1295,"address":[5869085,5869155,5870070],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1298,"address":[5869171],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1299,"address":[5869261,5869232],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1300,"address":[5869268],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1302,"address":[5869241],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1304,"address":[5869347],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1305,"address":[5869363],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1306,"address":[5869386],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1307,"address":[5869402,5869562,5869602],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1308,"address":[5869596],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1312,"address":[5869518,5869607],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1313,"address":[5869653],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1314,"address":[5869682],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1315,"address":[5869751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1317,"address":[5869818],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1322,"address":[5870144,5870205],"length":1,"stats":{"Line":2},"fn_name":"restore_state"},{"line":1325,"address":[5870221,5870280,5870163],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1326,"address":[5870288],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1328,"address":[5870245,5870332],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1343,"address":[5870400],"length":1,"stats":{"Line":8},"fn_name":"next_state"},{"line":1350,"address":[5870432],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1351,"address":[5870700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1353,"address":[5870814,5870698,5870873,5870746,5870863,5870474],"length":1,"stats":{"Line":36},"fn_name":null},{"line":1354,"address":[5870759,5870821],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1355,"address":[5870865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1356,"address":[5870875],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1357,"address":[5870798],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1380,"address":[4450913,4450937,4425039,4443029,4450873,4450995,4450925,4450901,4425075,4425023,4425063,4433750,4425087,4433714,4425145,4442977,4442993,4443005,4443041,4425051,4433698,4433762,4443099,4433738,4443017,4433820,4450889,4433726],"length":1,"stats":{"Line":467},"fn_name":null},{"line":1381,"address":[4433705,4425030,4450880,4442984],"length":1,"stats":{"Line":64},"fn_name":null},{"line":1382,"address":[4450891,4425041,4442995,4433716],"length":1,"stats":{"Line":65},"fn_name":null},{"line":1383,"address":[4443007,4433728,4425053,4450903],"length":1,"stats":{"Line":66},"fn_name":null},{"line":1384,"address":[4433740,4425065,4443019,4450915],"length":1,"stats":{"Line":68},"fn_name":null},{"line":1385,"address":[4425077,4433752,4443031,4450927],"length":1,"stats":{"Line":68},"fn_name":null},{"line":1386,"address":[4450962,4433787,4443066,4425112],"length":1,"stats":{"Line":70},"fn_name":null},{"line":1388,"address":[4425160,4433835,4443114,4451010],"length":1,"stats":{"Line":70},"fn_name":null},{"line":1389,"address":[4443162,4451058,4425208,4433883],"length":1,"stats":{"Line":68},"fn_name":null},{"line":1390,"address":[4425559,4443513,4434234,4451409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1391,"address":[4443211,4451107,4425257,4433932],"length":1,"stats":{"Line":40},"fn_name":null},{"line":1393,"address":[4433972,4451147,4443251,4425297],"length":1,"stats":{"Line":60},"fn_name":null},{"line":1394,"address":[4443258,4425304,4433979,4451154],"length":1,"stats":{"Line":60},"fn_name":null},{"line":1395,"address":[4425347,4443301,4434022,4451197],"length":1,"stats":{"Line":60},"fn_name":null},{"line":1400,"address":[4434119,4443398,4451294,4443669,4425715,4434390,4451565,4425444],"length":1,"stats":{"Line":61},"fn_name":null},{"line":1401,"address":[4451567,4425537,4443491,4434392,4443671,4425717,4434212,4451387],"length":1,"stats":{"Line":60},"fn_name":null},{"line":1402,"address":[4434263,4443542,4451438,4425588],"length":1,"stats":{"Line":60},"fn_name":null},{"line":1404,"address":[4451490,4434315,4443594,4425640],"length":1,"stats":{"Line":60},"fn_name":null},{"line":1405,"address":[4443649,4434370,4425695,4451545],"length":1,"stats":{"Line":60},"fn_name":null},{"line":1412,"address":[5870896],"length":1,"stats":{"Line":8},"fn_name":"start_flags"},{"line":1413,"address":[5870944],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1414,"address":[5870998],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1415,"address":[5871012],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1416,"address":[5871036],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1417,"address":[5871153,5871599,5871061],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1418,"address":[5871131,5871191],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1420,"address":[5871290,5871202,5871657],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1421,"address":[5871420,5871361,5871715,5871743,5871264],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1422,"address":[5871401,5871485],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1423,"address":[5871475],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1425,"address":[5871487,5871506],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1426,"address":[5871508],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1428,"address":[5871501],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1430,"address":[5871513],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1437,"address":[5871744],"length":1,"stats":{"Line":2},"fn_name":"start_flags_reverse"},{"line":1442,"address":[5871798],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1443,"address":[5871852],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1444,"address":[5871871],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1445,"address":[5871915],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1446,"address":[5871945,5872040,5872467],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1447,"address":[5872018,5872069],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1449,"address":[5872161,5872495,5872085],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1450,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1451,"address":[5872279,5872523,5872143,5872216],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1452,"address":[5872260,5872353],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1453,"address":[5872343],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1455,"address":[5872355,5872374],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1456,"address":[5872376],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1458,"address":[5872369],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1460,"address":[5872381],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1464,"address":[5872592],"length":1,"stats":{"Line":8},"fn_name":"state"},{"line":1465,"address":[5872605],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1476,"address":[5872759,5872672],"length":1,"stats":{"Line":8},"fn_name":"add_state"},{"line":1480,"address":[5872871,5872703,5872781],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1481,"address":[5872873,5872802],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1482,"address":[5872818],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1488,"address":[5873095,5872847],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1489,"address":[5872927,5873100,5873529],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1490,"address":[5873130,5873464],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1491,"address":[5873480],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1496,"address":[5873713,5874154,5873768,5873542,5873626,5874092],"length":1,"stats":{"Line":32},"fn_name":null},{"line":1497,"address":[5873573],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1498,"address":[5873676,5874124],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1499,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1500,"address":[5873855],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1502,"address":[5874004,5873966],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1503,"address":[5873905],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1505,"address":[5873981],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1514,"address":[5874256],"length":1,"stats":{"Line":2},"fn_name":"prefix_at"},{"line":1515,"address":[4405427,4405408],"length":1,"stats":{"Line":8},"fn_name":"{{closure}}"},{"line":1522,"address":[5876576],"length":1,"stats":{"Line":2},"fn_name":"num_byte_classes"},{"line":1524,"address":[5876585,5876678,5876738],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1530,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1531,"address":[5865398,5865556,5870510,5873187,5873345,5865507,5870656,5870613,5873412],"length":1,"stats":{"Line":52},"fn_name":null},{"line":1532,"address":[5865558,5873414,5870622,5865417,5873236,5870658,5870529,5873357,5865519],"length":1,"stats":{"Line":28},"fn_name":null},{"line":1533,"address":[5865434,5870546,5870608,5873337,5873254,5865499],"length":1,"stats":{"Line":48},"fn_name":null},{"line":1539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1540,"address":[5865471,5870580,5873296],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1551,"address":[5876752],"length":1,"stats":{"Line":2},"fn_name":"continue_past_first_match"},{"line":1552,"address":[5876842,5876761],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1556,"address":[5876864],"length":1,"stats":{"Line":8},"fn_name":"has_prefix"},{"line":1557,"address":[5876949,5877006,5876928,5876985,5877000,5876873],"length":1,"stats":{"Line":28},"fn_name":null},{"line":1558,"address":[5876998,5876968],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1559,"address":[5876916],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1567,"address":[5877008],"length":1,"stats":{"Line":8},"fn_name":"start_ptr"},{"line":1568,"address":[5877052,5877025],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1569,"address":[5877058],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1571,"address":[5877048],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1580,"address":[5877088],"length":1,"stats":{"Line":8},"fn_name":"approximate_size"},{"line":1581,"address":[5877162,5877192,5877097],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1610,"address":[5877200,5877245],"length":1,"stats":{"Line":25},"fn_name":"new"},{"line":1612,"address":[5877215],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1613,"address":[5877266],"length":1,"stats":{"Line":25},"fn_name":null},{"line":1618,"address":[5877408],"length":1,"stats":{"Line":8},"fn_name":"len"},{"line":1619,"address":[5877417],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1622,"address":[5877456],"length":1,"stats":{"Line":2},"fn_name":"is_empty"},{"line":1623,"address":[5877465],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1626,"address":[5877504],"length":1,"stats":{"Line":8},"fn_name":"get_ptr"},{"line":1627,"address":[5877518],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1630,"address":[5877568],"length":1,"stats":{"Line":8},"fn_name":"get_state"},{"line":1631,"address":[5877706,5877581,5877736],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1634,"address":[5877744,5877819],"length":1,"stats":{"Line":8},"fn_name":"insert"},{"line":1635,"address":[5877850,5877767],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1636,"address":[5877862],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1639,"address":[5877936],"length":1,"stats":{"Line":2},"fn_name":"clear"},{"line":1640,"address":[5877945],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1641,"address":[5877966],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1650,"address":[5878000],"length":1,"stats":{"Line":23},"fn_name":"new"},{"line":1651,"address":[5878021],"length":1,"stats":{"Line":25},"fn_name":null},{"line":1655,"address":[5878128],"length":1,"stats":{"Line":8},"fn_name":"num_states"},{"line":1656,"address":[5878207,5878237,5878137],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1662,"address":[5878240],"length":1,"stats":{"Line":8},"fn_name":"add"},{"line":1663,"address":[5878249],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1664,"address":[5878281],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1665,"address":[5878315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1667,"address":[5878341,5878294],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1668,"address":[5878387],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1672,"address":[5878416],"length":1,"stats":{"Line":2},"fn_name":"clear"},{"line":1673,"address":[5878421],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1677,"address":[5878432],"length":1,"stats":{"Line":8},"fn_name":"set_next"},{"line":1678,"address":[5878552,5878454,5878522],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1682,"address":[5878560],"length":1,"stats":{"Line":8},"fn_name":"next"},{"line":1683,"address":[5878640,5878578,5878670],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1687,"address":[5878672],"length":1,"stats":{"Line":8},"fn_name":"state_heap_size"},{"line":1688,"address":[5878681,5878775,5878719,5878745],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1692,"address":[5878784],"length":1,"stats":{"Line":8},"fn_name":"next_unchecked"},{"line":1693,"address":[5878893,5878802],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1694,"address":[5878949,5878876],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1695,"address":[5879050,5879080,5878928,5878983],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1700,"address":[5879088],"length":1,"stats":{"Line":8},"fn_name":"is_match"},{"line":1701,"address":[5879093],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1704,"address":[5879120],"length":1,"stats":{"Line":2},"fn_name":"set_match"},{"line":1705,"address":[5879125],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1708,"address":[5879136],"length":1,"stats":{"Line":8},"fn_name":"is_word"},{"line":1709,"address":[5879141],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1712,"address":[5879168],"length":1,"stats":{"Line":8},"fn_name":"set_word"},{"line":1713,"address":[5879173],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1716,"address":[5879184],"length":1,"stats":{"Line":8},"fn_name":"has_empty"},{"line":1717,"address":[5879189],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1720,"address":[5879216],"length":1,"stats":{"Line":8},"fn_name":"set_empty"},{"line":1721,"address":[5879221],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1726,"address":[5879232],"length":1,"stats":{"Line":8},"fn_name":"byte"},{"line":1727,"address":[5879241],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1729,"address":[5879264],"length":1,"stats":{"Line":2},"fn_name":"eof"},{"line":1732,"address":[5879280],"length":1,"stats":{"Line":8},"fn_name":"is_eof"},{"line":1733,"address":[5879285],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1736,"address":[5879312],"length":1,"stats":{"Line":8},"fn_name":"is_ascii_word"},{"line":1737,"address":[5879321,5879372],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1738,"address":[5879374,5879334],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1739,"address":[5879348],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1741,"address":[5879450],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1742,"address":[5879397,5879360,5879452],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1743,"address":[5879445],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1747,"address":[5879472],"length":1,"stats":{"Line":8},"fn_name":"as_byte"},{"line":1748,"address":[5879486,5879522],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1749,"address":[5879524],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1751,"address":[5879510],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1757,"address":[5879608,5879552],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":1758,"address":[5879623,5879575],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1759,"address":[5879638,5879711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1760,"address":[5879676,5879704],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1761,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1767,"address":[5879932,5879888],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":1768,"address":[5879911],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1769,"address":[5880462,5880109,5879952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1770,"address":[5880143,5880484],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1771,"address":[5880197,5880514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1772,"address":[5880231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1774,"address":[5880089],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1781,"address":[5880576,5880620],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":1782,"address":[5880599],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1783,"address":[5880811,5881231,5880640],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1784,"address":[5881229,5881054],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1785,"address":[5880877],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1786,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1787,"address":[5880956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1789,"address":[5880927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1790,"address":[5881088,5880936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1794,"address":[5880791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1799,"address":[5881312],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":1800,"address":[5881339,5881401,5881491,5881576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1801,"address":[5881371],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1802,"address":[5881456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1803,"address":[5881541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1809,"address":[5881664,5881708],"length":1,"stats":{"Line":0},"fn_name":"vb"},{"line":1812,"address":[5881887,5881682,5881769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1813,"address":[5881756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1815,"address":[5881771,5881728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1816,"address":[5881855,5881787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1820,"address":[5881920],"length":1,"stats":{"Line":8},"fn_name":"usize_to_u32"},{"line":1821,"address":[5881929],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1822,"address":[5881958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1824,"address":[5881941],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1828,"address":[5882235,5882096],"length":1,"stats":{"Line":0},"fn_name":"show_state_ptr"},{"line":1829,"address":[5882258,5882113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1830,"address":[5883794,5882407],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1831,"address":[5882581,5882419,5883693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1833,"address":[5883900,5882669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1834,"address":[5883799,5882680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1836,"address":[5882911,5884006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1837,"address":[5883905,5882922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1839,"address":[5883153,5884112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1840,"address":[5883167,5884011],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1842,"address":[5884218,5883398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1843,"address":[5884117,5883412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1845,"address":[5883634],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1849,"address":[5884352],"length":1,"stats":{"Line":9},"fn_name":"write_vari32"},{"line":1850,"address":[5884365],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1851,"address":[5884393],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1852,"address":[5884398],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1854,"address":[5884409],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1858,"address":[5884432],"length":1,"stats":{"Line":9},"fn_name":"read_vari32"},{"line":1859,"address":[5884446],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1860,"address":[5884478],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1861,"address":[5884497],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1862,"address":[5884505],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1864,"address":[5884516],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1868,"address":[5884560],"length":1,"stats":{"Line":9},"fn_name":"write_varu32"},{"line":1869,"address":[5884578,5884647],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1870,"address":[5884608],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1871,"address":[5884628],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1873,"address":[5884588],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1877,"address":[5884656],"length":1,"stats":{"Line":9},"fn_name":"read_varu32"},{"line":1878,"address":[5884679],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1879,"address":[5884687],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1880,"address":[5885175,5884695,5884867],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1881,"address":[5884934],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1882,"address":[5885008,5885180,5885083],"length":1,"stats":{"Line":20},"fn_name":null},{"line":1884,"address":[5885240,5884952,5885140],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1885,"address":[5885148,5885300,5885270],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1887,"address":[5884845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1902,"address":[4323504],"length":1,"stats":{"Line":3},"fn_name":"prop_state_encode_decode"},{"line":1903,"address":[4323712,4323600],"length":1,"stats":{"Line":1},"fn_name":"p"},{"line":1904,"address":[4323615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1905,"address":[4323743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1906,"address":[4323978,4323754,4323830,4324038],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1907,"address":[4324029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1909,"address":[4324053,4323949],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1911,"address":[4324233,4324096],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1913,"address":[4324256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1914,"address":[4324424,4324302,4324395],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1916,"address":[4323554,4323508],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1917,"address":[4323519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1922,"address":[4324688],"length":1,"stats":{"Line":3},"fn_name":"prop_read_write_u32"},{"line":1923,"address":[4324704,4324754],"length":1,"stats":{"Line":1},"fn_name":"p"},{"line":1924,"address":[4324723],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1925,"address":[4324775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1926,"address":[4324831,4324782],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1927,"address":[4324877,4324970],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1929,"address":[4324689],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1933,"address":[4325008],"length":1,"stats":{"Line":3},"fn_name":"prop_read_write_i32"},{"line":1934,"address":[4325024,4325074],"length":1,"stats":{"Line":1},"fn_name":"p"},{"line":1935,"address":[4325043],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1936,"address":[4325095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1937,"address":[4325102,4325151],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1938,"address":[4325197,4325290],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1940,"address":[4325009],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":590,"coverable":685},{"path":["/","usr","src","regex","src","error.rs"],"content":"use std::fmt;\nuse std::iter::repeat;\n\n/// An error that occurred during parsing or compiling a regular expression.\n#[derive(Clone, PartialEq)]\npub enum Error {\n    /// A syntax error.\n    Syntax(String),\n    /// The compiled program exceeded the set size limit.\n    /// The argument is the size limit imposed.\n    CompiledTooBig(usize),\n    /// Hints that destructuring should not be exhaustive.\n    ///\n    /// This enum may grow additional variants, so this makes sure clients\n    /// don't count on exhaustive matching. (Otherwise, adding a new variant\n    /// could break existing code.)\n    #[doc(hidden)]\n    __Nonexhaustive,\n}\n\nimpl ::std::error::Error for Error {\n    // TODO: Remove this method entirely on the next breaking semver release.\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        match *self {\n            Error::Syntax(ref err) => err,\n            Error::CompiledTooBig(_) => \"compiled program too big\",\n            Error::__Nonexhaustive => unreachable!(),\n        }\n    }\n}\n\nimpl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            Error::Syntax(ref err) => err.fmt(f),\n            Error::CompiledTooBig(limit) => write!(\n                f,\n                \"Compiled regex exceeds size limit of {} bytes.\",\n                limit\n            ),\n            Error::__Nonexhaustive => unreachable!(),\n        }\n    }\n}\n\n// We implement our own Debug implementation so that we show nicer syntax\n// errors when people use `Regex::new(...).unwrap()`. It's a little weird,\n// but the `Syntax` variant is already storing a `String` anyway, so we might\n// as well format it nicely.\nimpl fmt::Debug for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            Error::Syntax(ref err) => {\n                let hr: String = repeat('~').take(79).collect();\n                writeln!(f, \"Syntax(\")?;\n                writeln!(f, \"{}\", hr)?;\n                writeln!(f, \"{}\", err)?;\n                writeln!(f, \"{}\", hr)?;\n                write!(f, \")\")?;\n                Ok(())\n            }\n            Error::CompiledTooBig(limit) => {\n                f.debug_tuple(\"CompiledTooBig\").field(&limit).finish()\n            }\n            Error::__Nonexhaustive => {\n                f.debug_tuple(\"__Nonexhaustive\").finish()\n            }\n        }\n    }\n}\n","traces":[{"line":24,"address":[6020208],"length":1,"stats":{"Line":0},"fn_name":"description"},{"line":25,"address":[5606448,5606392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[5606399,5606329],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[5606457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[5606496],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":35,"address":[5606627,5606587,5606809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[5606594,5606519],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[5606660,5606644],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[6020720,6020799],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":53,"address":[6022331,6022359,6022209,6020856],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[6020743,6020866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[6020880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[6020948,6021249,6021041,6021207,6021174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[6021096,6021256,6021484],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[6021406,6021535,6021763],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[5607926,5607797,5608115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[6022163,6022049,6021964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[6022139],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[6022229],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[6022241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[6022336,6020821],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":24},{"path":["/","usr","src","regex","src","exec.rs"],"content":"use std::cell::RefCell;\nuse std::collections::HashMap;\nuse std::sync::Arc;\n\n#[cfg(feature = \"perf-literal\")]\nuse aho_corasick::{AhoCorasick, AhoCorasickBuilder, MatchKind};\nuse syntax::hir::literal::Literals;\nuse syntax::hir::Hir;\nuse syntax::ParserBuilder;\n\nuse backtrack;\nuse cache::{Cached, CachedGuard};\nuse compile::Compiler;\n#[cfg(feature = \"perf-dfa\")]\nuse dfa;\nuse error::Error;\nuse input::{ByteInput, CharInput};\nuse literal::LiteralSearcher;\nuse pikevm;\nuse prog::Program;\nuse re_builder::RegexOptions;\nuse re_bytes;\nuse re_set;\nuse re_trait::{Locations, RegularExpression, Slot};\nuse re_unicode;\nuse utf8::next_utf8;\n\n/// `Exec` manages the execution of a regular expression.\n///\n/// In particular, this manages the various compiled forms of a single regular\n/// expression and the choice of which matching engine to use to execute a\n/// regular expression.\npub struct Exec {\n    /// All read only state.\n    ro: Arc<ExecReadOnly>,\n    /// Caches for the various matching engines.\n    cache: Cached<ProgramCache>,\n}\n\n/// `ExecNoSync` is like `Exec`, except it embeds a reference to a cache. This\n/// means it is no longer Sync, but we can now avoid the overhead of\n/// synchronization to fetch the cache.\n#[derive(Debug)]\npub struct ExecNoSync<'c> {\n    /// All read only state.\n    ro: &'c Arc<ExecReadOnly>,\n    /// Caches for the various matching engines.\n    cache: CachedGuard<'c, ProgramCache>,\n}\n\n/// `ExecNoSyncStr` is like `ExecNoSync`, but matches on &str instead of &[u8].\npub struct ExecNoSyncStr<'c>(ExecNoSync<'c>);\n\n/// `ExecReadOnly` comprises all read only state for a regex. Namely, all such\n/// state is determined at compile time and never changes during search.\n#[derive(Debug)]\nstruct ExecReadOnly {\n    /// The original regular expressions given by the caller to compile.\n    res: Vec<String>,\n    /// A compiled program that is used in the NFA simulation and backtracking.\n    /// It can be byte-based or Unicode codepoint based.\n    ///\n    /// N.B. It is not possibly to make this byte-based from the public API.\n    /// It is only used for testing byte based programs in the NFA simulations.\n    nfa: Program,\n    /// A compiled byte based program for DFA execution. This is only used\n    /// if a DFA can be executed. (Currently, only word boundary assertions are\n    /// not supported.) Note that this program contains an embedded `.*?`\n    /// preceding the first capture group, unless the regex is anchored at the\n    /// beginning.\n    dfa: Program,\n    /// The same as above, except the program is reversed (and there is no\n    /// preceding `.*?`). This is used by the DFA to find the starting location\n    /// of matches.\n    dfa_reverse: Program,\n    /// A set of suffix literals extracted from the regex.\n    ///\n    /// Prefix literals are stored on the `Program`, since they are used inside\n    /// the matching engines.\n    suffixes: LiteralSearcher,\n    /// An Aho-Corasick automaton with leftmost-first match semantics.\n    ///\n    /// This is only set when the entire regex is a simple unanchored\n    /// alternation of literals. We could probably use it more circumstances,\n    /// but this is already hacky enough in this architecture.\n    ///\n    /// N.B. We use u32 as a state ID representation under the assumption that\n    /// if we were to exhaust the ID space, we probably would have long\n    /// surpassed the compilation size limit.\n    #[cfg(feature = \"perf-literal\")]\n    ac: Option<AhoCorasick<u32>>,\n    /// match_type encodes as much upfront knowledge about how we're going to\n    /// execute a search as possible.\n    match_type: MatchType,\n}\n\n/// Facilitates the construction of an executor by exposing various knobs\n/// to control how a regex is executed and what kinds of resources it's\n/// permitted to use.\npub struct ExecBuilder {\n    options: RegexOptions,\n    match_type: Option<MatchType>,\n    bytes: bool,\n    only_utf8: bool,\n}\n\n/// Parsed represents a set of parsed regular expressions and their detected\n/// literals.\nstruct Parsed {\n    exprs: Vec<Hir>,\n    prefixes: Literals,\n    suffixes: Literals,\n    bytes: bool,\n}\n\nimpl ExecBuilder {\n    /// Create a regex execution builder.\n    ///\n    /// This uses default settings for everything except the regex itself,\n    /// which must be provided. Further knobs can be set by calling methods,\n    /// and then finally, `build` to actually create the executor.\n    pub fn new(re: &str) -> Self {\n        Self::new_many(&[re])\n    }\n\n    /// Like new, but compiles the union of the given regular expressions.\n    ///\n    /// Note that when compiling 2 or more regular expressions, capture groups\n    /// are completely unsupported. (This means both `find` and `captures`\n    /// wont work.)\n    pub fn new_many<I, S>(res: I) -> Self\n    where\n        S: AsRef<str>,\n        I: IntoIterator<Item = S>,\n    {\n        let mut opts = RegexOptions::default();\n        opts.pats = res.into_iter().map(|s| s.as_ref().to_owned()).collect();\n        Self::new_options(opts)\n    }\n\n    /// Create a regex execution builder.\n    pub fn new_options(opts: RegexOptions) -> Self {\n        ExecBuilder {\n            options: opts,\n            match_type: None,\n            bytes: false,\n            only_utf8: true,\n        }\n    }\n\n    /// Set the matching engine to be automatically determined.\n    ///\n    /// This is the default state and will apply whatever optimizations are\n    /// possible, such as running a DFA.\n    ///\n    /// This overrides whatever was previously set via the `nfa` or\n    /// `bounded_backtracking` methods.\n    pub fn automatic(mut self) -> Self {\n        self.match_type = None;\n        self\n    }\n\n    /// Sets the matching engine to use the NFA algorithm no matter what\n    /// optimizations are possible.\n    ///\n    /// This overrides whatever was previously set via the `automatic` or\n    /// `bounded_backtracking` methods.\n    pub fn nfa(mut self) -> Self {\n        self.match_type = Some(MatchType::Nfa(MatchNfaType::PikeVM));\n        self\n    }\n\n    /// Sets the matching engine to use a bounded backtracking engine no\n    /// matter what optimizations are possible.\n    ///\n    /// One must use this with care, since the bounded backtracking engine\n    /// uses memory proportion to `len(regex) * len(text)`.\n    ///\n    /// This overrides whatever was previously set via the `automatic` or\n    /// `nfa` methods.\n    pub fn bounded_backtracking(mut self) -> Self {\n        self.match_type = Some(MatchType::Nfa(MatchNfaType::Backtrack));\n        self\n    }\n\n    /// Compiles byte based programs for use with the NFA matching engines.\n    ///\n    /// By default, the NFA engines match on Unicode scalar values. They can\n    /// be made to use byte based programs instead. In general, the byte based\n    /// programs are slower because of a less efficient encoding of character\n    /// classes.\n    ///\n    /// Note that this does not impact DFA matching engines, which always\n    /// execute on bytes.\n    pub fn bytes(mut self, yes: bool) -> Self {\n        self.bytes = yes;\n        self\n    }\n\n    /// When disabled, the program compiled may match arbitrary bytes.\n    ///\n    /// When enabled (the default), all compiled programs exclusively match\n    /// valid UTF-8 bytes.\n    pub fn only_utf8(mut self, yes: bool) -> Self {\n        self.only_utf8 = yes;\n        self\n    }\n\n    /// Set the Unicode flag.\n    pub fn unicode(mut self, yes: bool) -> Self {\n        self.options.unicode = yes;\n        self\n    }\n\n    /// Parse the current set of patterns into their AST and extract literals.\n    fn parse(&self) -> Result<Parsed, Error> {\n        let mut exprs = Vec::with_capacity(self.options.pats.len());\n        let mut prefixes = Some(Literals::empty());\n        let mut suffixes = Some(Literals::empty());\n        let mut bytes = false;\n        let is_set = self.options.pats.len() > 1;\n        // If we're compiling a regex set and that set has any anchored\n        // expressions, then disable all literal optimizations.\n        for pat in &self.options.pats {\n            let mut parser = ParserBuilder::new()\n                .octal(self.options.octal)\n                .case_insensitive(self.options.case_insensitive)\n                .multi_line(self.options.multi_line)\n                .dot_matches_new_line(self.options.dot_matches_new_line)\n                .swap_greed(self.options.swap_greed)\n                .ignore_whitespace(self.options.ignore_whitespace)\n                .unicode(self.options.unicode)\n                .allow_invalid_utf8(!self.only_utf8)\n                .nest_limit(self.options.nest_limit)\n                .build();\n            let expr =\n                parser.parse(pat).map_err(|e| Error::Syntax(e.to_string()))?;\n            bytes = bytes || !expr.is_always_utf8();\n\n            if cfg!(feature = \"perf-literal\") {\n                if !expr.is_anchored_start() && expr.is_any_anchored_start() {\n                    // Partial anchors unfortunately make it hard to use\n                    // prefixes, so disable them.\n                    prefixes = None;\n                } else if is_set && expr.is_anchored_start() {\n                    // Regex sets with anchors do not go well with literal\n                    // optimizations.\n                    prefixes = None;\n                }\n                prefixes = prefixes.and_then(|mut prefixes| {\n                    if !prefixes.union_prefixes(&expr) {\n                        None\n                    } else {\n                        Some(prefixes)\n                    }\n                });\n\n                if !expr.is_anchored_end() && expr.is_any_anchored_end() {\n                    // Partial anchors unfortunately make it hard to use\n                    // suffixes, so disable them.\n                    suffixes = None;\n                } else if is_set && expr.is_anchored_end() {\n                    // Regex sets with anchors do not go well with literal\n                    // optimizations.\n                    suffixes = None;\n                }\n                suffixes = suffixes.and_then(|mut suffixes| {\n                    if !suffixes.union_suffixes(&expr) {\n                        None\n                    } else {\n                        Some(suffixes)\n                    }\n                });\n            }\n            exprs.push(expr);\n        }\n        Ok(Parsed {\n            exprs: exprs,\n            prefixes: prefixes.unwrap_or_else(Literals::empty),\n            suffixes: suffixes.unwrap_or_else(Literals::empty),\n            bytes: bytes,\n        })\n    }\n\n    /// Build an executor that can run a regular expression.\n    pub fn build(self) -> Result<Exec, Error> {\n        // Special case when we have no patterns to compile.\n        // This can happen when compiling a regex set.\n        if self.options.pats.is_empty() {\n            let ro = Arc::new(ExecReadOnly {\n                res: vec![],\n                nfa: Program::new(),\n                dfa: Program::new(),\n                dfa_reverse: Program::new(),\n                suffixes: LiteralSearcher::empty(),\n                #[cfg(feature = \"perf-literal\")]\n                ac: None,\n                match_type: MatchType::Nothing,\n            });\n            return Ok(Exec { ro: ro, cache: Cached::new() });\n        }\n        let parsed = self.parse()?;\n        let mut nfa = Compiler::new()\n            .size_limit(self.options.size_limit)\n            .bytes(self.bytes || parsed.bytes)\n            .only_utf8(self.only_utf8)\n            .compile(&parsed.exprs)?;\n        let mut dfa = Compiler::new()\n            .size_limit(self.options.size_limit)\n            .dfa(true)\n            .only_utf8(self.only_utf8)\n            .compile(&parsed.exprs)?;\n        let mut dfa_reverse = Compiler::new()\n            .size_limit(self.options.size_limit)\n            .dfa(true)\n            .only_utf8(self.only_utf8)\n            .reverse(true)\n            .compile(&parsed.exprs)?;\n\n        #[cfg(feature = \"perf-literal\")]\n        let ac = self.build_aho_corasick(&parsed);\n        nfa.prefixes = LiteralSearcher::prefixes(parsed.prefixes);\n        dfa.prefixes = nfa.prefixes.clone();\n        dfa.dfa_size_limit = self.options.dfa_size_limit;\n        dfa_reverse.dfa_size_limit = self.options.dfa_size_limit;\n\n        let mut ro = ExecReadOnly {\n            res: self.options.pats,\n            nfa: nfa,\n            dfa: dfa,\n            dfa_reverse: dfa_reverse,\n            suffixes: LiteralSearcher::suffixes(parsed.suffixes),\n            #[cfg(feature = \"perf-literal\")]\n            ac: ac,\n            match_type: MatchType::Nothing,\n        };\n        ro.match_type = ro.choose_match_type(self.match_type);\n\n        let ro = Arc::new(ro);\n        Ok(Exec { ro: ro, cache: Cached::new() })\n    }\n\n    #[cfg(feature = \"perf-literal\")]\n    fn build_aho_corasick(&self, parsed: &Parsed) -> Option<AhoCorasick<u32>> {\n        if parsed.exprs.len() != 1 {\n            return None;\n        }\n        let lits = match alternation_literals(&parsed.exprs[0]) {\n            None => return None,\n            Some(lits) => lits,\n        };\n        // If we have a small number of literals, then let Teddy handle\n        // things (see literal/mod.rs).\n        if lits.len() <= 32 {\n            return None;\n        }\n        Some(\n            AhoCorasickBuilder::new()\n                .match_kind(MatchKind::LeftmostFirst)\n                .auto_configure(&lits)\n                // We always want this to reduce size, regardless\n                // of what auto-configure does.\n                .byte_classes(true)\n                .build_with_size::<u32, _, _>(&lits)\n                // This should never happen because we'd long exceed the\n                // compilation limit for regexes first.\n                .expect(\"AC automaton too big\"),\n        )\n    }\n}\n\nimpl<'c> RegularExpression for ExecNoSyncStr<'c> {\n    type Text = str;\n\n    fn slots_len(&self) -> usize {\n        self.0.slots_len()\n    }\n\n    fn next_after_empty(&self, text: &str, i: usize) -> usize {\n        next_utf8(text.as_bytes(), i)\n    }\n\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn shortest_match_at(&self, text: &str, start: usize) -> Option<usize> {\n        self.0.shortest_match_at(text.as_bytes(), start)\n    }\n\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn is_match_at(&self, text: &str, start: usize) -> bool {\n        self.0.is_match_at(text.as_bytes(), start)\n    }\n\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn find_at(&self, text: &str, start: usize) -> Option<(usize, usize)> {\n        self.0.find_at(text.as_bytes(), start)\n    }\n\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn captures_read_at(\n        &self,\n        locs: &mut Locations,\n        text: &str,\n        start: usize,\n    ) -> Option<(usize, usize)> {\n        self.0.captures_read_at(locs, text.as_bytes(), start)\n    }\n}\n\nimpl<'c> RegularExpression for ExecNoSync<'c> {\n    type Text = [u8];\n\n    /// Returns the number of capture slots in the regular expression. (There\n    /// are two slots for every capture group, corresponding to possibly empty\n    /// start and end locations of the capture.)\n    fn slots_len(&self) -> usize {\n        self.ro.nfa.captures.len() * 2\n    }\n\n    fn next_after_empty(&self, _text: &[u8], i: usize) -> usize {\n        i + 1\n    }\n\n    /// Returns the end of a match location, possibly occurring before the\n    /// end location of the correct leftmost-first match.\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn shortest_match_at(&self, text: &[u8], start: usize) -> Option<usize> {\n        if !self.is_anchor_end_match(text) {\n            return None;\n        }\n        match self.ro.match_type {\n            #[cfg(feature = \"perf-literal\")]\n            MatchType::Literal(ty) => {\n                self.find_literals(ty, text, start).map(|(_, e)| e)\n            }\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::Dfa | MatchType::DfaMany => {\n                match self.shortest_dfa(text, start) {\n                    dfa::Result::Match(end) => Some(end),\n                    dfa::Result::NoMatch(_) => None,\n                    dfa::Result::Quit => self.shortest_nfa(text, start),\n                }\n            }\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::DfaAnchoredReverse => {\n                match dfa::Fsm::reverse(\n                    &self.ro.dfa_reverse,\n                    self.cache.value(),\n                    true,\n                    &text[start..],\n                    text.len(),\n                ) {\n                    dfa::Result::Match(_) => Some(text.len()),\n                    dfa::Result::NoMatch(_) => None,\n                    dfa::Result::Quit => self.shortest_nfa(text, start),\n                }\n            }\n            #[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\n            MatchType::DfaSuffix => {\n                match self.shortest_dfa_reverse_suffix(text, start) {\n                    dfa::Result::Match(e) => Some(e),\n                    dfa::Result::NoMatch(_) => None,\n                    dfa::Result::Quit => self.shortest_nfa(text, start),\n                }\n            }\n            MatchType::Nfa(ty) => self.shortest_nfa_type(ty, text, start),\n            MatchType::Nothing => None,\n        }\n    }\n\n    /// Returns true if and only if the regex matches text.\n    ///\n    /// For single regular expressions, this is equivalent to calling\n    /// shortest_match(...).is_some().\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn is_match_at(&self, text: &[u8], start: usize) -> bool {\n        if !self.is_anchor_end_match(text) {\n            return false;\n        }\n        // We need to do this dance because shortest_match relies on the NFA\n        // filling in captures[1], but a RegexSet has no captures. In other\n        // words, a RegexSet can't (currently) use shortest_match. ---AG\n        match self.ro.match_type {\n            #[cfg(feature = \"perf-literal\")]\n            MatchType::Literal(ty) => {\n                self.find_literals(ty, text, start).is_some()\n            }\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::Dfa | MatchType::DfaMany => {\n                match self.shortest_dfa(text, start) {\n                    dfa::Result::Match(_) => true,\n                    dfa::Result::NoMatch(_) => false,\n                    dfa::Result::Quit => self.match_nfa(text, start),\n                }\n            }\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::DfaAnchoredReverse => {\n                match dfa::Fsm::reverse(\n                    &self.ro.dfa_reverse,\n                    self.cache.value(),\n                    true,\n                    &text[start..],\n                    text.len(),\n                ) {\n                    dfa::Result::Match(_) => true,\n                    dfa::Result::NoMatch(_) => false,\n                    dfa::Result::Quit => self.match_nfa(text, start),\n                }\n            }\n            #[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\n            MatchType::DfaSuffix => {\n                match self.shortest_dfa_reverse_suffix(text, start) {\n                    dfa::Result::Match(_) => true,\n                    dfa::Result::NoMatch(_) => false,\n                    dfa::Result::Quit => self.match_nfa(text, start),\n                }\n            }\n            MatchType::Nfa(ty) => self.match_nfa_type(ty, text, start),\n            MatchType::Nothing => false,\n        }\n    }\n\n    /// Finds the start and end location of the leftmost-first match, starting\n    /// at the given location.\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn find_at(&self, text: &[u8], start: usize) -> Option<(usize, usize)> {\n        if !self.is_anchor_end_match(text) {\n            return None;\n        }\n        match self.ro.match_type {\n            #[cfg(feature = \"perf-literal\")]\n            MatchType::Literal(ty) => self.find_literals(ty, text, start),\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::Dfa => match self.find_dfa_forward(text, start) {\n                dfa::Result::Match((s, e)) => Some((s, e)),\n                dfa::Result::NoMatch(_) => None,\n                dfa::Result::Quit => {\n                    self.find_nfa(MatchNfaType::Auto, text, start)\n                }\n            },\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::DfaAnchoredReverse => {\n                match self.find_dfa_anchored_reverse(text, start) {\n                    dfa::Result::Match((s, e)) => Some((s, e)),\n                    dfa::Result::NoMatch(_) => None,\n                    dfa::Result::Quit => {\n                        self.find_nfa(MatchNfaType::Auto, text, start)\n                    }\n                }\n            }\n            #[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\n            MatchType::DfaSuffix => {\n                match self.find_dfa_reverse_suffix(text, start) {\n                    dfa::Result::Match((s, e)) => Some((s, e)),\n                    dfa::Result::NoMatch(_) => None,\n                    dfa::Result::Quit => {\n                        self.find_nfa(MatchNfaType::Auto, text, start)\n                    }\n                }\n            }\n            MatchType::Nfa(ty) => self.find_nfa(ty, text, start),\n            MatchType::Nothing => None,\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::DfaMany => {\n                unreachable!(\"BUG: RegexSet cannot be used with find\")\n            }\n        }\n    }\n\n    /// Finds the start and end location of the leftmost-first match and also\n    /// fills in all matching capture groups.\n    ///\n    /// The number of capture slots given should be equal to the total number\n    /// of capture slots in the compiled program.\n    ///\n    /// Note that the first two slots always correspond to the start and end\n    /// locations of the overall match.\n    fn captures_read_at(\n        &self,\n        locs: &mut Locations,\n        text: &[u8],\n        start: usize,\n    ) -> Option<(usize, usize)> {\n        let slots = locs.as_slots();\n        for slot in slots.iter_mut() {\n            *slot = None;\n        }\n        // If the caller unnecessarily uses this, then we try to save them\n        // from themselves.\n        match slots.len() {\n            0 => return self.find_at(text, start),\n            2 => {\n                return self.find_at(text, start).map(|(s, e)| {\n                    slots[0] = Some(s);\n                    slots[1] = Some(e);\n                    (s, e)\n                });\n            }\n            _ => {} // fallthrough\n        }\n        if !self.is_anchor_end_match(text) {\n            return None;\n        }\n        match self.ro.match_type {\n            #[cfg(feature = \"perf-literal\")]\n            MatchType::Literal(ty) => {\n                self.find_literals(ty, text, start).and_then(|(s, e)| {\n                    self.captures_nfa_type(\n                        MatchNfaType::Auto,\n                        slots,\n                        text,\n                        s,\n                        e,\n                    )\n                })\n            }\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::Dfa => {\n                if self.ro.nfa.is_anchored_start {\n                    self.captures_nfa(slots, text, start)\n                } else {\n                    match self.find_dfa_forward(text, start) {\n                        dfa::Result::Match((s, e)) => self.captures_nfa_type(\n                            MatchNfaType::Auto,\n                            slots,\n                            text,\n                            s,\n                            e,\n                        ),\n                        dfa::Result::NoMatch(_) => None,\n                        dfa::Result::Quit => {\n                            self.captures_nfa(slots, text, start)\n                        }\n                    }\n                }\n            }\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::DfaAnchoredReverse => {\n                match self.find_dfa_anchored_reverse(text, start) {\n                    dfa::Result::Match((s, e)) => self.captures_nfa_type(\n                        MatchNfaType::Auto,\n                        slots,\n                        text,\n                        s,\n                        e,\n                    ),\n                    dfa::Result::NoMatch(_) => None,\n                    dfa::Result::Quit => self.captures_nfa(slots, text, start),\n                }\n            }\n            #[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\n            MatchType::DfaSuffix => {\n                match self.find_dfa_reverse_suffix(text, start) {\n                    dfa::Result::Match((s, e)) => self.captures_nfa_type(\n                        MatchNfaType::Auto,\n                        slots,\n                        text,\n                        s,\n                        e,\n                    ),\n                    dfa::Result::NoMatch(_) => None,\n                    dfa::Result::Quit => self.captures_nfa(slots, text, start),\n                }\n            }\n            MatchType::Nfa(ty) => {\n                self.captures_nfa_type(ty, slots, text, start, text.len())\n            }\n            MatchType::Nothing => None,\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::DfaMany => {\n                unreachable!(\"BUG: RegexSet cannot be used with captures\")\n            }\n        }\n    }\n}\n\nimpl<'c> ExecNoSync<'c> {\n    /// Finds the leftmost-first match using only literal search.\n    #[cfg(feature = \"perf-literal\")]\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn find_literals(\n        &self,\n        ty: MatchLiteralType,\n        text: &[u8],\n        start: usize,\n    ) -> Option<(usize, usize)> {\n        use self::MatchLiteralType::*;\n        match ty {\n            Unanchored => {\n                let lits = &self.ro.nfa.prefixes;\n                lits.find(&text[start..]).map(|(s, e)| (start + s, start + e))\n            }\n            AnchoredStart => {\n                let lits = &self.ro.nfa.prefixes;\n                if start == 0 || !self.ro.nfa.is_anchored_start {\n                    lits.find_start(&text[start..])\n                        .map(|(s, e)| (start + s, start + e))\n                } else {\n                    None\n                }\n            }\n            AnchoredEnd => {\n                let lits = &self.ro.suffixes;\n                lits.find_end(&text[start..])\n                    .map(|(s, e)| (start + s, start + e))\n            }\n            AhoCorasick => self\n                .ro\n                .ac\n                .as_ref()\n                .unwrap()\n                .find(&text[start..])\n                .map(|m| (start + m.start(), start + m.end())),\n        }\n    }\n\n    /// Finds the leftmost-first match (start and end) using only the DFA.\n    ///\n    /// If the result returned indicates that the DFA quit, then another\n    /// matching engine should be used.\n    #[cfg(feature = \"perf-dfa\")]\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn find_dfa_forward(\n        &self,\n        text: &[u8],\n        start: usize,\n    ) -> dfa::Result<(usize, usize)> {\n        use dfa::Result::*;\n        let end = match dfa::Fsm::forward(\n            &self.ro.dfa,\n            self.cache.value(),\n            false,\n            text,\n            start,\n        ) {\n            NoMatch(i) => return NoMatch(i),\n            Quit => return Quit,\n            Match(end) if start == end => return Match((start, start)),\n            Match(end) => end,\n        };\n        // Now run the DFA in reverse to find the start of the match.\n        match dfa::Fsm::reverse(\n            &self.ro.dfa_reverse,\n            self.cache.value(),\n            false,\n            &text[start..],\n            end - start,\n        ) {\n            Match(s) => Match((start + s, end)),\n            NoMatch(i) => NoMatch(i),\n            Quit => Quit,\n        }\n    }\n\n    /// Finds the leftmost-first match (start and end) using only the DFA,\n    /// but assumes the regex is anchored at the end and therefore starts at\n    /// the end of the regex and matches in reverse.\n    ///\n    /// If the result returned indicates that the DFA quit, then another\n    /// matching engine should be used.\n    #[cfg(feature = \"perf-dfa\")]\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn find_dfa_anchored_reverse(\n        &self,\n        text: &[u8],\n        start: usize,\n    ) -> dfa::Result<(usize, usize)> {\n        use dfa::Result::*;\n        match dfa::Fsm::reverse(\n            &self.ro.dfa_reverse,\n            self.cache.value(),\n            false,\n            &text[start..],\n            text.len() - start,\n        ) {\n            Match(s) => Match((start + s, text.len())),\n            NoMatch(i) => NoMatch(i),\n            Quit => Quit,\n        }\n    }\n\n    /// Finds the end of the shortest match using only the DFA.\n    #[cfg(feature = \"perf-dfa\")]\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn shortest_dfa(&self, text: &[u8], start: usize) -> dfa::Result<usize> {\n        dfa::Fsm::forward(&self.ro.dfa, self.cache.value(), true, text, start)\n    }\n\n    /// Finds the end of the shortest match using only the DFA by scanning for\n    /// suffix literals.\n    #[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn shortest_dfa_reverse_suffix(\n        &self,\n        text: &[u8],\n        start: usize,\n    ) -> dfa::Result<usize> {\n        match self.exec_dfa_reverse_suffix(text, start) {\n            None => self.shortest_dfa(text, start),\n            Some(r) => r.map(|(_, end)| end),\n        }\n    }\n\n    /// Finds the end of the shortest match using only the DFA by scanning for\n    /// suffix literals. It also reports the start of the match.\n    ///\n    /// Note that if None is returned, then the optimization gave up to avoid\n    /// worst case quadratic behavior. A forward scanning DFA should be tried\n    /// next.\n    ///\n    /// If a match is returned and the full leftmost-first match is desired,\n    /// then a forward scan starting from the beginning of the match must be\n    /// done.\n    ///\n    /// If the result returned indicates that the DFA quit, then another\n    /// matching engine should be used.\n    #[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn exec_dfa_reverse_suffix(\n        &self,\n        text: &[u8],\n        original_start: usize,\n    ) -> Option<dfa::Result<(usize, usize)>> {\n        use dfa::Result::*;\n\n        let lcs = self.ro.suffixes.lcs();\n        debug_assert!(lcs.len() >= 1);\n        let mut start = original_start;\n        let mut end = start;\n        let mut last_literal = start;\n        while end <= text.len() {\n            last_literal += match lcs.find(&text[last_literal..]) {\n                None => return Some(NoMatch(text.len())),\n                Some(i) => i,\n            };\n            end = last_literal + lcs.len();\n            match dfa::Fsm::reverse(\n                &self.ro.dfa_reverse,\n                self.cache.value(),\n                false,\n                &text[start..end],\n                end - start,\n            ) {\n                Match(0) | NoMatch(0) => return None,\n                Match(i) => return Some(Match((start + i, end))),\n                NoMatch(i) => {\n                    start += i;\n                    last_literal += 1;\n                    continue;\n                }\n                Quit => return Some(Quit),\n            };\n        }\n        Some(NoMatch(text.len()))\n    }\n\n    /// Finds the leftmost-first match (start and end) using only the DFA\n    /// by scanning for suffix literals.\n    ///\n    /// If the result returned indicates that the DFA quit, then another\n    /// matching engine should be used.\n    #[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn find_dfa_reverse_suffix(\n        &self,\n        text: &[u8],\n        start: usize,\n    ) -> dfa::Result<(usize, usize)> {\n        use dfa::Result::*;\n\n        let match_start = match self.exec_dfa_reverse_suffix(text, start) {\n            None => return self.find_dfa_forward(text, start),\n            Some(Match((start, _))) => start,\n            Some(r) => return r,\n        };\n        // At this point, we've found a match. The only way to quit now\n        // without a match is if the DFA gives up (seems unlikely).\n        //\n        // Now run the DFA forwards to find the proper end of the match.\n        // (The suffix literal match can only indicate the earliest\n        // possible end location, which may appear before the end of the\n        // leftmost-first match.)\n        match dfa::Fsm::forward(\n            &self.ro.dfa,\n            self.cache.value(),\n            false,\n            text,\n            match_start,\n        ) {\n            NoMatch(_) => panic!(\"BUG: reverse match implies forward match\"),\n            Quit => Quit,\n            Match(e) => Match((match_start, e)),\n        }\n    }\n\n    /// Executes the NFA engine to return whether there is a match or not.\n    ///\n    /// Ideally, we could use shortest_nfa(...).is_some() and get the same\n    /// performance characteristics, but regex sets don't have captures, which\n    /// shortest_nfa depends on.\n    #[cfg(feature = \"perf-dfa\")]\n    fn match_nfa(&self, text: &[u8], start: usize) -> bool {\n        self.match_nfa_type(MatchNfaType::Auto, text, start)\n    }\n\n    /// Like match_nfa, but allows specification of the type of NFA engine.\n    fn match_nfa_type(\n        &self,\n        ty: MatchNfaType,\n        text: &[u8],\n        start: usize,\n    ) -> bool {\n        self.exec_nfa(\n            ty,\n            &mut [false],\n            &mut [],\n            true,\n            false,\n            text,\n            start,\n            text.len(),\n        )\n    }\n\n    /// Finds the shortest match using an NFA.\n    #[cfg(feature = \"perf-dfa\")]\n    fn shortest_nfa(&self, text: &[u8], start: usize) -> Option<usize> {\n        self.shortest_nfa_type(MatchNfaType::Auto, text, start)\n    }\n\n    /// Like shortest_nfa, but allows specification of the type of NFA engine.\n    fn shortest_nfa_type(\n        &self,\n        ty: MatchNfaType,\n        text: &[u8],\n        start: usize,\n    ) -> Option<usize> {\n        let mut slots = [None, None];\n        if self.exec_nfa(\n            ty,\n            &mut [false],\n            &mut slots,\n            true,\n            true,\n            text,\n            start,\n            text.len(),\n        ) {\n            slots[1]\n        } else {\n            None\n        }\n    }\n\n    /// Like find, but executes an NFA engine.\n    fn find_nfa(\n        &self,\n        ty: MatchNfaType,\n        text: &[u8],\n        start: usize,\n    ) -> Option<(usize, usize)> {\n        let mut slots = [None, None];\n        if self.exec_nfa(\n            ty,\n            &mut [false],\n            &mut slots,\n            false,\n            false,\n            text,\n            start,\n            text.len(),\n        ) {\n            match (slots[0], slots[1]) {\n                (Some(s), Some(e)) => Some((s, e)),\n                _ => None,\n            }\n        } else {\n            None\n        }\n    }\n\n    /// Like find_nfa, but fills in captures.\n    ///\n    /// `slots` should have length equal to `2 * nfa.captures.len()`.\n    #[cfg(feature = \"perf-dfa\")]\n    fn captures_nfa(\n        &self,\n        slots: &mut [Slot],\n        text: &[u8],\n        start: usize,\n    ) -> Option<(usize, usize)> {\n        self.captures_nfa_type(\n            MatchNfaType::Auto,\n            slots,\n            text,\n            start,\n            text.len(),\n        )\n    }\n\n    /// Like captures_nfa, but allows specification of type of NFA engine.\n    fn captures_nfa_type(\n        &self,\n        ty: MatchNfaType,\n        slots: &mut [Slot],\n        text: &[u8],\n        start: usize,\n        end: usize,\n    ) -> Option<(usize, usize)> {\n        if self.exec_nfa(\n            ty,\n            &mut [false],\n            slots,\n            false,\n            false,\n            text,\n            start,\n            end,\n        ) {\n            match (slots[0], slots[1]) {\n                (Some(s), Some(e)) => Some((s, e)),\n                _ => None,\n            }\n        } else {\n            None\n        }\n    }\n\n    fn exec_nfa(\n        &self,\n        mut ty: MatchNfaType,\n        matches: &mut [bool],\n        slots: &mut [Slot],\n        quit_after_match: bool,\n        quit_after_match_with_pos: bool,\n        text: &[u8],\n        start: usize,\n        end: usize,\n    ) -> bool {\n        use self::MatchNfaType::*;\n        if let Auto = ty {\n            if backtrack::should_exec(self.ro.nfa.len(), text.len()) {\n                ty = Backtrack;\n            } else {\n                ty = PikeVM;\n            }\n        }\n        // The backtracker can't return the shortest match position as it is\n        // implemented today. So if someone calls `shortest_match` and we need\n        // to run an NFA, then use the PikeVM.\n        if quit_after_match_with_pos || ty == PikeVM {\n            self.exec_pikevm(\n                matches,\n                slots,\n                quit_after_match,\n                text,\n                start,\n                end,\n            )\n        } else {\n            self.exec_backtrack(matches, slots, text, start, end)\n        }\n    }\n\n    /// Always run the NFA algorithm.\n    fn exec_pikevm(\n        &self,\n        matches: &mut [bool],\n        slots: &mut [Slot],\n        quit_after_match: bool,\n        text: &[u8],\n        start: usize,\n        end: usize,\n    ) -> bool {\n        if self.ro.nfa.uses_bytes() {\n            pikevm::Fsm::exec(\n                &self.ro.nfa,\n                self.cache.value(),\n                matches,\n                slots,\n                quit_after_match,\n                ByteInput::new(text, self.ro.nfa.only_utf8),\n                start,\n                end,\n            )\n        } else {\n            pikevm::Fsm::exec(\n                &self.ro.nfa,\n                self.cache.value(),\n                matches,\n                slots,\n                quit_after_match,\n                CharInput::new(text),\n                start,\n                end,\n            )\n        }\n    }\n\n    /// Always runs the NFA using bounded backtracking.\n    fn exec_backtrack(\n        &self,\n        matches: &mut [bool],\n        slots: &mut [Slot],\n        text: &[u8],\n        start: usize,\n        end: usize,\n    ) -> bool {\n        if self.ro.nfa.uses_bytes() {\n            backtrack::Bounded::exec(\n                &self.ro.nfa,\n                self.cache.value(),\n                matches,\n                slots,\n                ByteInput::new(text, self.ro.nfa.only_utf8),\n                start,\n                end,\n            )\n        } else {\n            backtrack::Bounded::exec(\n                &self.ro.nfa,\n                self.cache.value(),\n                matches,\n                slots,\n                CharInput::new(text),\n                start,\n                end,\n            )\n        }\n    }\n\n    /// Finds which regular expressions match the given text.\n    ///\n    /// `matches` should have length equal to the number of regexes being\n    /// searched.\n    ///\n    /// This is only useful when one wants to know which regexes in a set\n    /// match some text.\n    pub fn many_matches_at(\n        &self,\n        matches: &mut [bool],\n        text: &[u8],\n        start: usize,\n    ) -> bool {\n        use self::MatchType::*;\n        if !self.is_anchor_end_match(text) {\n            return false;\n        }\n        match self.ro.match_type {\n            #[cfg(feature = \"perf-literal\")]\n            Literal(ty) => {\n                debug_assert_eq!(matches.len(), 1);\n                matches[0] = self.find_literals(ty, text, start).is_some();\n                matches[0]\n            }\n            #[cfg(feature = \"perf-dfa\")]\n            Dfa | DfaAnchoredReverse | DfaMany => {\n                match dfa::Fsm::forward_many(\n                    &self.ro.dfa,\n                    self.cache.value(),\n                    matches,\n                    text,\n                    start,\n                ) {\n                    dfa::Result::Match(_) => true,\n                    dfa::Result::NoMatch(_) => false,\n                    dfa::Result::Quit => self.exec_nfa(\n                        MatchNfaType::Auto,\n                        matches,\n                        &mut [],\n                        false,\n                        false,\n                        text,\n                        start,\n                        text.len(),\n                    ),\n                }\n            }\n            #[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\n            DfaSuffix => {\n                match dfa::Fsm::forward_many(\n                    &self.ro.dfa,\n                    self.cache.value(),\n                    matches,\n                    text,\n                    start,\n                ) {\n                    dfa::Result::Match(_) => true,\n                    dfa::Result::NoMatch(_) => false,\n                    dfa::Result::Quit => self.exec_nfa(\n                        MatchNfaType::Auto,\n                        matches,\n                        &mut [],\n                        false,\n                        false,\n                        text,\n                        start,\n                        text.len(),\n                    ),\n                }\n            }\n            Nfa(ty) => self.exec_nfa(\n                ty,\n                matches,\n                &mut [],\n                false,\n                false,\n                text,\n                start,\n                text.len(),\n            ),\n            Nothing => false,\n        }\n    }\n\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn is_anchor_end_match(&self, text: &[u8]) -> bool {\n        #[cfg(not(feature = \"perf-literal\"))]\n        fn imp(_: &ExecReadOnly, _: &[u8]) -> bool {\n            true\n        }\n\n        #[cfg(feature = \"perf-literal\")]\n        fn imp(ro: &ExecReadOnly, text: &[u8]) -> bool {\n            // Only do this check if the haystack is big (>1MB).\n            if text.len() > (1 << 20) && ro.nfa.is_anchored_end {\n                let lcs = ro.suffixes.lcs();\n                if lcs.len() >= 1 && !lcs.is_suffix(text) {\n                    return false;\n                }\n            }\n            true\n        }\n\n        imp(&self.ro, text)\n    }\n\n    pub fn capture_name_idx(&self) -> &Arc<HashMap<String, usize>> {\n        &self.ro.nfa.capture_name_idx\n    }\n}\n\nimpl<'c> ExecNoSyncStr<'c> {\n    pub fn capture_name_idx(&self) -> &Arc<HashMap<String, usize>> {\n        self.0.capture_name_idx()\n    }\n}\n\nimpl Exec {\n    /// Get a searcher that isn't Sync.\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub fn searcher(&self) -> ExecNoSync {\n        let create = || RefCell::new(ProgramCacheInner::new(&self.ro));\n        ExecNoSync {\n            ro: &self.ro, // a clone is too expensive here! (and not needed)\n            cache: self.cache.get_or(create),\n        }\n    }\n\n    /// Get a searcher that isn't Sync and can match on &str.\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub fn searcher_str(&self) -> ExecNoSyncStr {\n        ExecNoSyncStr(self.searcher())\n    }\n\n    /// Build a Regex from this executor.\n    pub fn into_regex(self) -> re_unicode::Regex {\n        re_unicode::Regex::from(self)\n    }\n\n    /// Build a RegexSet from this executor.\n    pub fn into_regex_set(self) -> re_set::unicode::RegexSet {\n        re_set::unicode::RegexSet::from(self)\n    }\n\n    /// Build a Regex from this executor that can match arbitrary bytes.\n    pub fn into_byte_regex(self) -> re_bytes::Regex {\n        re_bytes::Regex::from(self)\n    }\n\n    /// Build a RegexSet from this executor that can match arbitrary bytes.\n    pub fn into_byte_regex_set(self) -> re_set::bytes::RegexSet {\n        re_set::bytes::RegexSet::from(self)\n    }\n\n    /// The original regular expressions given by the caller that were\n    /// compiled.\n    pub fn regex_strings(&self) -> &[String] {\n        &self.ro.res\n    }\n\n    /// Return a slice of capture names.\n    ///\n    /// Any capture that isn't named is None.\n    pub fn capture_names(&self) -> &[Option<String>] {\n        &self.ro.nfa.captures\n    }\n\n    /// Return a reference to named groups mapping (from group name to\n    /// group position).\n    pub fn capture_name_idx(&self) -> &Arc<HashMap<String, usize>> {\n        &self.ro.nfa.capture_name_idx\n    }\n}\n\nimpl Clone for Exec {\n    fn clone(&self) -> Exec {\n        Exec { ro: self.ro.clone(), cache: Cached::new() }\n    }\n}\n\nimpl ExecReadOnly {\n    fn choose_match_type(&self, hint: Option<MatchType>) -> MatchType {\n        if let Some(MatchType::Nfa(_)) = hint {\n            return hint.unwrap();\n        }\n        // If the NFA is empty, then we'll never match anything.\n        if self.nfa.insts.is_empty() {\n            return MatchType::Nothing;\n        }\n        if let Some(literalty) = self.choose_literal_match_type() {\n            return literalty;\n        }\n        if let Some(dfaty) = self.choose_dfa_match_type() {\n            return dfaty;\n        }\n        // We're so totally hosed.\n        MatchType::Nfa(MatchNfaType::Auto)\n    }\n\n    /// If a plain literal scan can be used, then a corresponding literal\n    /// search type is returned.\n    fn choose_literal_match_type(&self) -> Option<MatchType> {\n        #[cfg(not(feature = \"perf-literal\"))]\n        fn imp(_: &ExecReadOnly) -> Option<MatchType> {\n            None\n        }\n\n        #[cfg(feature = \"perf-literal\")]\n        fn imp(ro: &ExecReadOnly) -> Option<MatchType> {\n            // If our set of prefixes is complete, then we can use it to find\n            // a match in lieu of a regex engine. This doesn't quite work well\n            // in the presence of multiple regexes, so only do it when there's\n            // one.\n            //\n            // TODO(burntsushi): Also, don't try to match literals if the regex\n            // is partially anchored. We could technically do it, but we'd need\n            // to create two sets of literals: all of them and then the subset\n            // that aren't anchored. We would then only search for all of them\n            // when at the beginning of the input and use the subset in all\n            // other cases.\n            if ro.res.len() != 1 {\n                return None;\n            }\n            if ro.ac.is_some() {\n                return Some(MatchType::Literal(\n                    MatchLiteralType::AhoCorasick,\n                ));\n            }\n            if ro.nfa.prefixes.complete() {\n                return if ro.nfa.is_anchored_start {\n                    Some(MatchType::Literal(MatchLiteralType::AnchoredStart))\n                } else {\n                    Some(MatchType::Literal(MatchLiteralType::Unanchored))\n                };\n            }\n            if ro.suffixes.complete() {\n                return if ro.nfa.is_anchored_end {\n                    Some(MatchType::Literal(MatchLiteralType::AnchoredEnd))\n                } else {\n                    // This case shouldn't happen. When the regex isn't\n                    // anchored, then complete prefixes should imply complete\n                    // suffixes.\n                    Some(MatchType::Literal(MatchLiteralType::Unanchored))\n                };\n            }\n            None\n        }\n\n        imp(self)\n    }\n\n    /// If a DFA scan can be used, then choose the appropriate DFA strategy.\n    fn choose_dfa_match_type(&self) -> Option<MatchType> {\n        #[cfg(not(feature = \"perf-dfa\"))]\n        fn imp(_: &ExecReadOnly) -> Option<MatchType> {\n            None\n        }\n\n        #[cfg(feature = \"perf-dfa\")]\n        fn imp(ro: &ExecReadOnly) -> Option<MatchType> {\n            if !dfa::can_exec(&ro.dfa) {\n                return None;\n            }\n            // Regex sets require a slightly specialized path.\n            if ro.res.len() >= 2 {\n                return Some(MatchType::DfaMany);\n            }\n            // If the regex is anchored at the end but not the start, then\n            // just match in reverse from the end of the haystack.\n            if !ro.nfa.is_anchored_start && ro.nfa.is_anchored_end {\n                return Some(MatchType::DfaAnchoredReverse);\n            }\n            #[cfg(feature = \"perf-literal\")]\n            {\n                // If there's a longish suffix literal, then it might be faster\n                // to look for that first.\n                if ro.should_suffix_scan() {\n                    return Some(MatchType::DfaSuffix);\n                }\n            }\n            // Fall back to your garden variety forward searching lazy DFA.\n            Some(MatchType::Dfa)\n        }\n\n        imp(self)\n    }\n\n    /// Returns true if the program is amenable to suffix scanning.\n    ///\n    /// When this is true, as a heuristic, we assume it is OK to quickly scan\n    /// for suffix literals and then do a *reverse* DFA match from any matches\n    /// produced by the literal scan. (And then followed by a forward DFA\n    /// search, since the previously found suffix literal maybe not actually be\n    /// the end of a match.)\n    ///\n    /// This is a bit of a specialized optimization, but can result in pretty\n    /// big performance wins if 1) there are no prefix literals and 2) the\n    /// suffix literals are pretty rare in the text. (1) is obviously easy to\n    /// account for but (2) is harder. As a proxy, we assume that longer\n    /// strings are generally rarer, so we only enable this optimization when\n    /// we have a meaty suffix.\n    #[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\n    fn should_suffix_scan(&self) -> bool {\n        if self.suffixes.is_empty() {\n            return false;\n        }\n        let lcs_len = self.suffixes.lcs().char_len();\n        lcs_len >= 3 && lcs_len > self.dfa.prefixes.lcp().char_len()\n    }\n}\n\n#[derive(Clone, Copy, Debug)]\nenum MatchType {\n    /// A single or multiple literal search. This is only used when the regex\n    /// can be decomposed into a literal search.\n    #[cfg(feature = \"perf-literal\")]\n    Literal(MatchLiteralType),\n    /// A normal DFA search.\n    #[cfg(feature = \"perf-dfa\")]\n    Dfa,\n    /// A reverse DFA search starting from the end of a haystack.\n    #[cfg(feature = \"perf-dfa\")]\n    DfaAnchoredReverse,\n    /// A reverse DFA search with suffix literal scanning.\n    #[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\n    DfaSuffix,\n    /// Use the DFA on two or more regular expressions.\n    #[cfg(feature = \"perf-dfa\")]\n    DfaMany,\n    /// An NFA variant.\n    Nfa(MatchNfaType),\n    /// No match is ever possible, so don't ever try to search.\n    Nothing,\n}\n\n#[derive(Clone, Copy, Debug)]\n#[cfg(feature = \"perf-literal\")]\nenum MatchLiteralType {\n    /// Match literals anywhere in text.\n    Unanchored,\n    /// Match literals only at the start of text.\n    AnchoredStart,\n    /// Match literals only at the end of text.\n    AnchoredEnd,\n    /// Use an Aho-Corasick automaton. This requires `ac` to be Some on\n    /// ExecReadOnly.\n    AhoCorasick,\n}\n\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\nenum MatchNfaType {\n    /// Choose between Backtrack and PikeVM.\n    Auto,\n    /// NFA bounded backtracking.\n    ///\n    /// (This is only set by tests, since it never makes sense to always want\n    /// backtracking.)\n    Backtrack,\n    /// The Pike VM.\n    ///\n    /// (This is only set by tests, since it never makes sense to always want\n    /// the Pike VM.)\n    PikeVM,\n}\n\n/// `ProgramCache` maintains reusable allocations for each matching engine\n/// available to a particular program.\npub type ProgramCache = RefCell<ProgramCacheInner>;\n\n#[derive(Debug)]\npub struct ProgramCacheInner {\n    pub pikevm: pikevm::Cache,\n    pub backtrack: backtrack::Cache,\n    #[cfg(feature = \"perf-dfa\")]\n    pub dfa: dfa::Cache,\n    #[cfg(feature = \"perf-dfa\")]\n    pub dfa_reverse: dfa::Cache,\n}\n\nimpl ProgramCacheInner {\n    fn new(ro: &ExecReadOnly) -> Self {\n        ProgramCacheInner {\n            pikevm: pikevm::Cache::new(&ro.nfa),\n            backtrack: backtrack::Cache::new(&ro.nfa),\n            #[cfg(feature = \"perf-dfa\")]\n            dfa: dfa::Cache::new(&ro.dfa),\n            #[cfg(feature = \"perf-dfa\")]\n            dfa_reverse: dfa::Cache::new(&ro.dfa_reverse),\n        }\n    }\n}\n\n/// Alternation literals checks if the given HIR is a simple alternation of\n/// literals, and if so, returns them. Otherwise, this returns None.\n#[cfg(feature = \"perf-literal\")]\nfn alternation_literals(expr: &Hir) -> Option<Vec<Vec<u8>>> {\n    use syntax::hir::{HirKind, Literal};\n\n    // This is pretty hacky, but basically, if `is_alternation_literal` is\n    // true, then we can make several assumptions about the structure of our\n    // HIR. This is what justifies the `unreachable!` statements below.\n    //\n    // This code should be refactored once we overhaul this crate's\n    // optimization pipeline, because this is a terribly inflexible way to go\n    // about things.\n\n    if !expr.is_alternation_literal() {\n        return None;\n    }\n    let alts = match *expr.kind() {\n        HirKind::Alternation(ref alts) => alts,\n        _ => return None, // one literal isn't worth it\n    };\n\n    let extendlit = |lit: &Literal, dst: &mut Vec<u8>| match *lit {\n        Literal::Unicode(c) => {\n            let mut buf = [0; 4];\n            dst.extend_from_slice(c.encode_utf8(&mut buf).as_bytes());\n        }\n        Literal::Byte(b) => {\n            dst.push(b);\n        }\n    };\n\n    let mut lits = vec![];\n    for alt in alts {\n        let mut lit = vec![];\n        match *alt.kind() {\n            HirKind::Literal(ref x) => extendlit(x, &mut lit),\n            HirKind::Concat(ref exprs) => {\n                for e in exprs {\n                    match *e.kind() {\n                        HirKind::Literal(ref x) => extendlit(x, &mut lit),\n                        _ => unreachable!(\"expected literal, got {:?}\", e),\n                    }\n                }\n            }\n            _ => unreachable!(\"expected literal or concat, got {:?}\", alt),\n        }\n        lits.push(lit);\n    }\n    Some(lits)\n}\n\n#[cfg(test)]\nmod test {\n    #[test]\n    fn uppercut_s_backtracking_bytes_default_bytes_mismatch() {\n        use internal::ExecBuilder;\n\n        let backtrack_bytes_re = ExecBuilder::new(\"^S\")\n            .bounded_backtracking()\n            .only_utf8(false)\n            .build()\n            .map(|exec| exec.into_byte_regex())\n            .map_err(|err| format!(\"{}\", err))\n            .unwrap();\n\n        let default_bytes_re = ExecBuilder::new(\"^S\")\n            .only_utf8(false)\n            .build()\n            .map(|exec| exec.into_byte_regex())\n            .map_err(|err| format!(\"{}\", err))\n            .unwrap();\n\n        let input = vec![83, 83];\n\n        let s1 = backtrack_bytes_re.split(&input);\n        let s2 = default_bytes_re.split(&input);\n        for (chunk1, chunk2) in s1.zip(s2) {\n            assert_eq!(chunk1, chunk2);\n        }\n    }\n\n    #[test]\n    fn unicode_lit_star_backtracking_utf8bytes_default_utf8bytes_mismatch() {\n        use internal::ExecBuilder;\n\n        let backtrack_bytes_re = ExecBuilder::new(r\"^(?u:\\*)\")\n            .bounded_backtracking()\n            .bytes(true)\n            .build()\n            .map(|exec| exec.into_regex())\n            .map_err(|err| format!(\"{}\", err))\n            .unwrap();\n\n        let default_bytes_re = ExecBuilder::new(r\"^(?u:\\*)\")\n            .bytes(true)\n            .build()\n            .map(|exec| exec.into_regex())\n            .map_err(|err| format!(\"{}\", err))\n            .unwrap();\n\n        let input = \"**\";\n\n        let s1 = backtrack_bytes_re.split(input);\n        let s2 = default_bytes_re.split(input);\n        for (chunk1, chunk2) in s1.zip(s2) {\n            assert_eq!(chunk1, chunk2);\n        }\n    }\n}\n","traces":[{"line":122,"address":[5174960],"length":1,"stats":{"Line":12},"fn_name":"new"},{"line":123,"address":[5174977],"length":1,"stats":{"Line":16},"fn_name":null},{"line":131,"address":[4895616,4895688],"length":1,"stats":{"Line":27},"fn_name":"new_many<&[&str; 1],&&str>"},{"line":136,"address":[4895634],"length":1,"stats":{"Line":25},"fn_name":null},{"line":137,"address":[4895907,4896171,4896144,4895703],"length":1,"stats":{"Line":101},"fn_name":"{{closure}}<&[&str; 1],&&str>"},{"line":138,"address":[4895990],"length":1,"stats":{"Line":41},"fn_name":null},{"line":142,"address":[5175024],"length":1,"stats":{"Line":33},"fn_name":"new_options"},{"line":158,"address":[5175152],"length":1,"stats":{"Line":0},"fn_name":"automatic"},{"line":159,"address":[5175159],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[5175178],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[5175216],"length":1,"stats":{"Line":12},"fn_name":"nfa"},{"line":169,"address":[5175223],"length":1,"stats":{"Line":12},"fn_name":null},{"line":170,"address":[5175271],"length":1,"stats":{"Line":12},"fn_name":null},{"line":181,"address":[5175296],"length":1,"stats":{"Line":14},"fn_name":"bounded_backtracking"},{"line":182,"address":[5175303],"length":1,"stats":{"Line":14},"fn_name":null},{"line":183,"address":[5175351],"length":1,"stats":{"Line":14},"fn_name":null},{"line":195,"address":[5175376],"length":1,"stats":{"Line":9},"fn_name":"bytes"},{"line":196,"address":[5175392],"length":1,"stats":{"Line":9},"fn_name":null},{"line":197,"address":[5175398],"length":1,"stats":{"Line":9},"fn_name":null},{"line":204,"address":[5175424],"length":1,"stats":{"Line":21},"fn_name":"only_utf8"},{"line":205,"address":[5175440],"length":1,"stats":{"Line":21},"fn_name":null},{"line":206,"address":[5175446],"length":1,"stats":{"Line":21},"fn_name":null},{"line":210,"address":[5175472],"length":1,"stats":{"Line":0},"fn_name":"unicode"},{"line":211,"address":[5175488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[5175494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[5175616,5175520],"length":1,"stats":{"Line":34},"fn_name":"parse"},{"line":217,"address":[5175631,5175538],"length":1,"stats":{"Line":68},"fn_name":null},{"line":218,"address":[5175661],"length":1,"stats":{"Line":34},"fn_name":null},{"line":219,"address":[5175736],"length":1,"stats":{"Line":34},"fn_name":null},{"line":220,"address":[5175811],"length":1,"stats":{"Line":34},"fn_name":null},{"line":221,"address":[5175819,5175873],"length":1,"stats":{"Line":68},"fn_name":null},{"line":224,"address":[5178109,5175911,5176156],"length":1,"stats":{"Line":61},"fn_name":null},{"line":225,"address":[5176268,5176190,5176376,5176512,5176307,5176442,5176475,5176343,5176409,5176229],"length":1,"stats":{"Line":340},"fn_name":null},{"line":226,"address":[5176225],"length":1,"stats":{"Line":34},"fn_name":null},{"line":227,"address":[5176264],"length":1,"stats":{"Line":34},"fn_name":null},{"line":228,"address":[5176303],"length":1,"stats":{"Line":34},"fn_name":null},{"line":229,"address":[5176339],"length":1,"stats":{"Line":34},"fn_name":null},{"line":230,"address":[5176372],"length":1,"stats":{"Line":34},"fn_name":null},{"line":231,"address":[5176405],"length":1,"stats":{"Line":34},"fn_name":null},{"line":232,"address":[5176438],"length":1,"stats":{"Line":34},"fn_name":null},{"line":233,"address":[5176471],"length":1,"stats":{"Line":34},"fn_name":null},{"line":234,"address":[5176509],"length":1,"stats":{"Line":34},"fn_name":null},{"line":236,"address":[4896273,4896256],"length":1,"stats":{"Line":98},"fn_name":"{{closure}}"},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[5177168,5177084,5176794],"length":1,"stats":{"Line":31},"fn_name":null},{"line":241,"address":[5177176,5178683,5177407,5177141],"length":1,"stats":{"Line":35},"fn_name":null},{"line":244,"address":[5178598,5177266],"length":1,"stats":{"Line":8},"fn_name":null},{"line":245,"address":[5178773,5177304,5177260],"length":1,"stats":{"Line":25},"fn_name":null},{"line":248,"address":[5177369,5178688],"length":1,"stats":{"Line":8},"fn_name":null},{"line":250,"address":[4896400,4896455],"length":1,"stats":{"Line":18},"fn_name":"{{closure}}"},{"line":251,"address":[4896471,4896568,4896412],"length":1,"stats":{"Line":30},"fn_name":null},{"line":252,"address":[4896575],"length":1,"stats":{"Line":23},"fn_name":null},{"line":254,"address":[4896497],"length":1,"stats":{"Line":10},"fn_name":null},{"line":258,"address":[5177822,5178863,5177568],"length":1,"stats":{"Line":30},"fn_name":null},{"line":261,"address":[5177681,5178778],"length":1,"stats":{"Line":10},"fn_name":null},{"line":262,"address":[5177719,5178953,5177675],"length":1,"stats":{"Line":26},"fn_name":null},{"line":265,"address":[5178868,5177784],"length":1,"stats":{"Line":8},"fn_name":null},{"line":267,"address":[4896695,4896640],"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":268,"address":[4896652,4896808,4896711],"length":1,"stats":{"Line":44},"fn_name":null},{"line":269,"address":[4896815],"length":1,"stats":{"Line":23},"fn_name":null},{"line":271,"address":[4896737],"length":1,"stats":{"Line":10},"fn_name":null},{"line":275,"address":[5177983],"length":1,"stats":{"Line":24},"fn_name":null},{"line":277,"address":[5178235],"length":1,"stats":{"Line":27},"fn_name":null},{"line":278,"address":[5176034],"length":1,"stats":{"Line":27},"fn_name":null},{"line":279,"address":[5176074],"length":1,"stats":{"Line":27},"fn_name":null},{"line":280,"address":[5178114],"length":1,"stats":{"Line":27},"fn_name":null},{"line":281,"address":[5178228],"length":1,"stats":{"Line":27},"fn_name":null},{"line":286,"address":[5179377,5179200],"length":1,"stats":{"Line":34},"fn_name":"build"},{"line":289,"address":[5179224,5179399],"length":1,"stats":{"Line":68},"fn_name":null},{"line":290,"address":[5179615,5179967],"length":1,"stats":{"Line":16},"fn_name":null},{"line":291,"address":[5179440],"length":1,"stats":{"Line":8},"fn_name":null},{"line":292,"address":[5179494],"length":1,"stats":{"Line":8},"fn_name":null},{"line":293,"address":[5179528],"length":1,"stats":{"Line":8},"fn_name":null},{"line":294,"address":[5179543],"length":1,"stats":{"Line":8},"fn_name":null},{"line":295,"address":[5179573],"length":1,"stats":{"Line":8},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[5179595],"length":1,"stats":{"Line":8},"fn_name":null},{"line":298,"address":[5179607],"length":1,"stats":{"Line":8},"fn_name":null},{"line":300,"address":[5180011,5179975],"length":1,"stats":{"Line":16},"fn_name":null},{"line":302,"address":[5180192,5180482,5179421,5180610],"length":1,"stats":{"Line":80},"fn_name":null},{"line":303,"address":[5180898,5180665,5180777,5180718,5180472,5181083,5180827,5180930],"length":1,"stats":{"Line":179},"fn_name":null},{"line":304,"address":[5180645],"length":1,"stats":{"Line":27},"fn_name":null},{"line":305,"address":[5180680],"length":1,"stats":{"Line":27},"fn_name":null},{"line":306,"address":[5180784,5180757],"length":1,"stats":{"Line":54},"fn_name":null},{"line":307,"address":[5180792,5180905,5180874,5181085,5181258,5183638],"length":1,"stats":{"Line":91},"fn_name":null},{"line":308,"address":[5181423,5181494,5181373,5181073,5181526,5181310,5181679],"length":1,"stats":{"Line":143},"fn_name":null},{"line":309,"address":[5181290],"length":1,"stats":{"Line":22},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[5181380,5181353],"length":1,"stats":{"Line":54},"fn_name":null},{"line":312,"address":[5183898,5181501,5181470,5181854,5181681,5181388],"length":1,"stats":{"Line":65},"fn_name":null},{"line":313,"address":[5182150,5181906,5181969,5182047,5181669,5182311,5182118],"length":1,"stats":{"Line":96},"fn_name":null},{"line":314,"address":[5181886],"length":1,"stats":{"Line":19},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[5181949],"length":1,"stats":{"Line":19},"fn_name":null},{"line":317,"address":[5182004],"length":1,"stats":{"Line":19},"fn_name":null},{"line":318,"address":[5182094,5182125,5184158,5182313,5182478,5182012],"length":1,"stats":{"Line":39},"fn_name":null},{"line":321,"address":[5182502,5182301],"length":1,"stats":{"Line":26},"fn_name":null},{"line":322,"address":[5182510,5184412],"length":1,"stats":{"Line":20},"fn_name":null},{"line":323,"address":[5184569,5182615,5184518],"length":1,"stats":{"Line":50},"fn_name":null},{"line":324,"address":[5184670],"length":1,"stats":{"Line":25},"fn_name":null},{"line":325,"address":[5184682],"length":1,"stats":{"Line":25},"fn_name":null},{"line":328,"address":[5184694],"length":1,"stats":{"Line":25},"fn_name":null},{"line":332,"address":[5184867],"length":1,"stats":{"Line":25},"fn_name":null},{"line":337,"address":[5183030,5183145],"length":1,"stats":{"Line":49},"fn_name":null},{"line":339,"address":[5183166],"length":1,"stats":{"Line":25},"fn_name":null},{"line":340,"address":[5183489,5183261],"length":1,"stats":{"Line":25},"fn_name":null},{"line":344,"address":[5185724,5185664],"length":1,"stats":{"Line":10},"fn_name":"build_aho_corasick"},{"line":345,"address":[5185690,5185744],"length":1,"stats":{"Line":20},"fn_name":null},{"line":346,"address":[5185780],"length":1,"stats":{"Line":20},"fn_name":null},{"line":348,"address":[5185911,5185759,5185800],"length":1,"stats":{"Line":20},"fn_name":null},{"line":349,"address":[5185935,5185815,5185918],"length":1,"stats":{"Line":56},"fn_name":null},{"line":350,"address":[5185835],"length":1,"stats":{"Line":12},"fn_name":null},{"line":354,"address":[5185890,5185961],"length":1,"stats":{"Line":24},"fn_name":null},{"line":355,"address":[5185991,5186009],"length":1,"stats":{"Line":24},"fn_name":null},{"line":358,"address":[5186022,5185967,5186095],"length":1,"stats":{"Line":24},"fn_name":null},{"line":359,"address":[5186014],"length":1,"stats":{"Line":8},"fn_name":null},{"line":360,"address":[5186054],"length":1,"stats":{"Line":8},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[5186272],"length":1,"stats":{"Line":13},"fn_name":"slots_len"},{"line":376,"address":[5186281],"length":1,"stats":{"Line":15},"fn_name":null},{"line":379,"address":[5186304],"length":1,"stats":{"Line":8},"fn_name":"next_after_empty"},{"line":380,"address":[5186388],"length":1,"stats":{"Line":10},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[5042049],"length":1,"stats":{"Line":18},"fn_name":null},{"line":415,"address":[5186416],"length":1,"stats":{"Line":21},"fn_name":"slots_len"},{"line":416,"address":[5186425,5186500,5186530],"length":1,"stats":{"Line":23},"fn_name":null},{"line":419,"address":[5186544],"length":1,"stats":{"Line":5},"fn_name":"next_after_empty"},{"line":420,"address":[5186568,5186595,5186625],"length":1,"stats":{"Line":3},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[4940469],"length":1,"stats":{"Line":8},"fn_name":null},{"line":428,"address":[4940540],"length":1,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[4940569,4940475,4943804,4952408,4978284,4959827],"length":1,"stats":{"Line":17},"fn_name":null},{"line":432,"address":[4940584,4940491],"length":1,"stats":{"Line":10},"fn_name":null},{"line":433,"address":[4896880,4896894],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[4952246,4952354,4952394],"length":1,"stats":{"Line":6},"fn_name":null},{"line":438,"address":[4952262,4952358],"length":1,"stats":{"Line":4},"fn_name":null},{"line":439,"address":[4952396],"length":1,"stats":{"Line":2},"fn_name":null},{"line":440,"address":[4952333],"length":1,"stats":{"Line":2},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[4959767,4959813,4959659],"length":1,"stats":{"Line":4},"fn_name":null},{"line":446,"address":[4952413],"length":1,"stats":{"Line":2},"fn_name":null},{"line":447,"address":[4952432],"length":1,"stats":{"Line":2},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[4952461],"length":1,"stats":{"Line":2},"fn_name":null},{"line":450,"address":[4952536],"length":1,"stats":{"Line":2},"fn_name":null},{"line":452,"address":[4959787,4959675],"length":1,"stats":{"Line":4},"fn_name":null},{"line":453,"address":[4959815],"length":1,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[4959746],"length":1,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[4978230,4978270,4978128],"length":1,"stats":{"Line":6},"fn_name":null},{"line":460,"address":[4978144,4978234],"length":1,"stats":{"Line":6},"fn_name":null},{"line":461,"address":[4978272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[4978209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[4978294],"length":1,"stats":{"Line":6},"fn_name":null},{"line":466,"address":[4940557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[4421039],"length":1,"stats":{"Line":14},"fn_name":null},{"line":477,"address":[4421110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[4421045,4421131,4440299,4432925,4458711,4424360],"length":1,"stats":{"Line":25},"fn_name":null},{"line":484,"address":[4421146,4421061],"length":1,"stats":{"Line":16},"fn_name":null},{"line":485,"address":[4424337],"length":1,"stats":{"Line":2},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[4432915,4432802,4432903],"length":1,"stats":{"Line":5},"fn_name":null},{"line":490,"address":[4432818,4432907],"length":1,"stats":{"Line":5},"fn_name":null},{"line":491,"address":[4432917],"length":1,"stats":{"Line":2},"fn_name":null},{"line":492,"address":[4432857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[4440277,4440176,4440289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[4432930],"length":1,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[4432949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[4432978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[4433053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[4440192,4440281],"length":1,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[4440291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[4440231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[4458701,4458594,4458689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[4458610,4458693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[4458703],"length":1,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[4458643],"length":1,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[4458721],"length":1,"stats":{"Line":11},"fn_name":null},{"line":518,"address":[4421123],"length":1,"stats":{"Line":8},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[4978965],"length":1,"stats":{"Line":28},"fn_name":null},{"line":527,"address":[4979036],"length":1,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[5041576,4982406,4978971,5006652,4979205,5041505,4998839],"length":1,"stats":{"Line":70},"fn_name":null},{"line":531,"address":[4979215,4978987],"length":1,"stats":{"Line":34},"fn_name":null},{"line":533,"address":[4998825,4998729],"length":1,"stats":{"Line":15},"fn_name":null},{"line":534,"address":[4998733,4998625],"length":1,"stats":{"Line":15},"fn_name":null},{"line":535,"address":[4998827],"length":1,"stats":{"Line":5},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[4998668],"length":1,"stats":{"Line":12},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[5006638,5006542],"length":1,"stats":{"Line":4},"fn_name":null},{"line":543,"address":[5006546,5006438],"length":1,"stats":{"Line":8},"fn_name":null},{"line":544,"address":[5006640],"length":1,"stats":{"Line":6},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[5006481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":552,"address":[5041491,5041395],"length":1,"stats":{"Line":4},"fn_name":null},{"line":553,"address":[5041399,5041299],"length":1,"stats":{"Line":8},"fn_name":null},{"line":554,"address":[5041493],"length":1,"stats":{"Line":4},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[5041334],"length":1,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[5041515],"length":1,"stats":{"Line":17},"fn_name":null},{"line":561,"address":[5041578],"length":1,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[5186640],"length":1,"stats":{"Line":23},"fn_name":"captures_read_at"},{"line":583,"address":[5186707],"length":1,"stats":{"Line":21},"fn_name":null},{"line":584,"address":[5186930,5186999,5186747],"length":1,"stats":{"Line":46},"fn_name":null},{"line":585,"address":[5186964],"length":1,"stats":{"Line":21},"fn_name":null},{"line":589,"address":[5186899],"length":1,"stats":{"Line":21},"fn_name":null},{"line":590,"address":[5187012,5187151,5250087,5250066],"length":1,"stats":{"Line":23},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":592,"address":[4896938,4896912],"length":1,"stats":{"Line":32},"fn_name":"{{closure}}"},{"line":593,"address":[4897144,4896951],"length":1,"stats":{"Line":8},"fn_name":null},{"line":594,"address":[4897199,4897171,4897037],"length":1,"stats":{"Line":8},"fn_name":null},{"line":595,"address":[4897111],"length":1,"stats":{"Line":8},"fn_name":null},{"line":600,"address":[5313064,5187043,5187146],"length":1,"stats":{"Line":65},"fn_name":null},{"line":601,"address":[5313104],"length":1,"stats":{"Line":0},"fn_name":null},{"line":603,"address":[5376462,5313070,5376445,5316567,5341172,5376245,5333243,5313248],"length":1,"stats":{"Line":47},"fn_name":null},{"line":605,"address":[5313124,5313258],"length":1,"stats":{"Line":24},"fn_name":null},{"line":606,"address":[4897218,4897200],"length":1,"stats":{"Line":9},"fn_name":"{{closure}}"},{"line":607,"address":[4897228,4897266],"length":1,"stats":{"Line":4},"fn_name":null},{"line":608,"address":[4897234],"length":1,"stats":{"Line":2},"fn_name":null},{"line":609,"address":[4897239],"length":1,"stats":{"Line":2},"fn_name":null},{"line":610,"address":[4897250],"length":1,"stats":{"Line":2},"fn_name":null},{"line":611,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":612,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":617,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":618,"address":[5332927,5316572,5333241],"length":1,"stats":{"Line":16},"fn_name":null},{"line":619,"address":[5332862],"length":1,"stats":{"Line":6},"fn_name":null},{"line":621,"address":[5332860,5333237,5316617,5333220,5333045],"length":1,"stats":{"Line":8},"fn_name":null},{"line":622,"address":[5332932,5333143,5333047],"length":1,"stats":{"Line":6},"fn_name":null},{"line":623,"address":[5333087],"length":1,"stats":{"Line":2},"fn_name":null},{"line":624,"address":[5333095],"length":1,"stats":{"Line":2},"fn_name":null},{"line":625,"address":[5333111],"length":1,"stats":{"Line":2},"fn_name":null},{"line":626,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":627,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":629,"address":[5333230],"length":1,"stats":{"Line":2},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":631,"address":[5332975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":637,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":638,"address":[5340861,5341151,5333248,5340976,5341168],"length":1,"stats":{"Line":6},"fn_name":null},{"line":639,"address":[5341074,5340863,5340978],"length":1,"stats":{"Line":6},"fn_name":null},{"line":640,"address":[5341018],"length":1,"stats":{"Line":2},"fn_name":null},{"line":641,"address":[5341026],"length":1,"stats":{"Line":2},"fn_name":null},{"line":642,"address":[5341042],"length":1,"stats":{"Line":2},"fn_name":null},{"line":643,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":646,"address":[5341161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":647,"address":[5340906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":651,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":652,"address":[5341177,5376241,5375958,5376067,5376224],"length":1,"stats":{"Line":8},"fn_name":null},{"line":653,"address":[5376069,5376162,5375960],"length":1,"stats":{"Line":6},"fn_name":null},{"line":654,"address":[5376109],"length":1,"stats":{"Line":2},"fn_name":null},{"line":655,"address":[5376117],"length":1,"stats":{"Line":2},"fn_name":null},{"line":656,"address":[5376133],"length":1,"stats":{"Line":2},"fn_name":null},{"line":657,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":660,"address":[5376234],"length":1,"stats":{"Line":2},"fn_name":null},{"line":661,"address":[5375997],"length":1,"stats":{"Line":0},"fn_name":null},{"line":664,"address":[5376258],"length":1,"stats":{"Line":15},"fn_name":null},{"line":665,"address":[5376271],"length":1,"stats":{"Line":13},"fn_name":null},{"line":667,"address":[5376455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":680,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":687,"address":[4421458,4423914,4424166],"length":1,"stats":{"Line":22},"fn_name":null},{"line":688,"address":[4421230],"length":1,"stats":{"Line":15},"fn_name":null},{"line":689,"address":[4421465],"length":1,"stats":{"Line":13},"fn_name":null},{"line":690,"address":[4421489,4423869],"length":1,"stats":{"Line":29},"fn_name":null},{"line":692,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":693,"address":[4423919],"length":1,"stats":{"Line":6},"fn_name":null},{"line":694,"address":[4424030,4423940],"length":1,"stats":{"Line":8},"fn_name":null},{"line":695,"address":[4424035,4424137],"length":1,"stats":{"Line":12},"fn_name":null},{"line":696,"address":[4424121],"length":1,"stats":{"Line":14},"fn_name":null},{"line":698,"address":[4424018],"length":1,"stats":{"Line":2},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":702,"address":[4424171],"length":1,"stats":{"Line":6},"fn_name":null},{"line":703,"address":[4424198,4424308],"length":1,"stats":{"Line":12},"fn_name":null},{"line":704,"address":[4424292],"length":1,"stats":{"Line":10},"fn_name":null},{"line":706,"address":[4421274,4421429,4421373],"length":1,"stats":{"Line":12},"fn_name":null},{"line":707,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":711,"address":[4421319],"length":1,"stats":{"Line":4},"fn_name":null},{"line":712,"address":[4421413],"length":1,"stats":{"Line":8},"fn_name":null},{"line":722,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":728,"address":[4990848,5025023,4990905,5025080],"length":1,"stats":{"Line":19},"fn_name":null},{"line":729,"address":[4982475,5016650],"length":1,"stats":{"Line":19},"fn_name":null},{"line":730,"address":[5016669,4982494],"length":1,"stats":{"Line":19},"fn_name":null},{"line":731,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":732,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":733,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":735,"address":[5025082,4990864,5025039,4990907],"length":1,"stats":{"Line":30},"fn_name":null},{"line":736,"address":[5025123,4990948],"length":1,"stats":{"Line":12},"fn_name":null},{"line":737,"address":[4990962,5025137],"length":1,"stats":{"Line":12},"fn_name":null},{"line":738,"address":[4991091,5025266],"length":1,"stats":{"Line":12},"fn_name":null},{"line":741,"address":[5032499,5032700,4998324,5032570,4998395,4998525],"length":1,"stats":{"Line":28},"fn_name":null},{"line":742,"address":[4991115,5025290],"length":1,"stats":{"Line":12},"fn_name":null},{"line":743,"address":[4991142,5025317],"length":1,"stats":{"Line":12},"fn_name":null},{"line":744,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":745,"address":[5025356,4991181],"length":1,"stats":{"Line":12},"fn_name":null},{"line":746,"address":[4998565,5032740,4991243,5025418],"length":1,"stats":{"Line":12},"fn_name":null},{"line":748,"address":[4998402,4998595,5032515,4998340,5032577,5032770],"length":1,"stats":{"Line":28},"fn_name":null},{"line":749,"address":[5032702,4998527],"length":1,"stats":{"Line":0},"fn_name":null},{"line":750,"address":[4998383,5032558],"length":1,"stats":{"Line":0},"fn_name":null},{"line":762,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":768,"address":[5006376,5006338,5006123,5006194],"length":1,"stats":{"Line":18},"fn_name":null},{"line":769,"address":[4998908],"length":1,"stats":{"Line":6},"fn_name":null},{"line":770,"address":[4998927],"length":1,"stats":{"Line":6},"fn_name":null},{"line":771,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":772,"address":[4998966],"length":1,"stats":{"Line":6},"fn_name":null},{"line":773,"address":[5006378,4999044],"length":1,"stats":{"Line":7},"fn_name":null},{"line":775,"address":[5006408,5006139,5006201],"length":1,"stats":{"Line":13},"fn_name":null},{"line":776,"address":[5006340],"length":1,"stats":{"Line":6},"fn_name":null},{"line":777,"address":[5006182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":784,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":785,"address":[4424429,4450279],"length":1,"stats":{"Line":7},"fn_name":null},{"line":792,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":797,"address":[4450208],"length":1,"stats":{"Line":2},"fn_name":null},{"line":798,"address":[4450091,4458562],"length":1,"stats":{"Line":5},"fn_name":null},{"line":799,"address":[4450115],"length":1,"stats":{"Line":6},"fn_name":null},{"line":818,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":825,"address":[4440400],"length":1,"stats":{"Line":8},"fn_name":null},{"line":826,"address":[4440435,4440519],"length":1,"stats":{"Line":8},"fn_name":null},{"line":827,"address":[4440477],"length":1,"stats":{"Line":8},"fn_name":null},{"line":828,"address":[4440485],"length":1,"stats":{"Line":8},"fn_name":null},{"line":829,"address":[4440501],"length":1,"stats":{"Line":8},"fn_name":null},{"line":830,"address":[4440517,4440549],"length":1,"stats":{"Line":16},"fn_name":null},{"line":831,"address":[4442014,4449911,4440695,4441967,4442149],"length":1,"stats":{"Line":32},"fn_name":null},{"line":832,"address":[4442062,4441983],"length":1,"stats":{"Line":14},"fn_name":null},{"line":833,"address":[4441998],"length":1,"stats":{"Line":8},"fn_name":null},{"line":835,"address":[4442157,4449941],"length":1,"stats":{"Line":8},"fn_name":null},{"line":836,"address":[4449455,4449603],"length":1,"stats":{"Line":8},"fn_name":null},{"line":837,"address":[4442233],"length":1,"stats":{"Line":8},"fn_name":null},{"line":838,"address":[4442252],"length":1,"stats":{"Line":8},"fn_name":null},{"line":839,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":840,"address":[4442283],"length":1,"stats":{"Line":8},"fn_name":null},{"line":841,"address":[4442361,4449971],"length":1,"stats":{"Line":8},"fn_name":null},{"line":843,"address":[4449605,4449471],"length":1,"stats":{"Line":16},"fn_name":null},{"line":844,"address":[4450061,4449622],"length":1,"stats":{"Line":8},"fn_name":null},{"line":845,"address":[4449795],"length":1,"stats":{"Line":6},"fn_name":null},{"line":846,"address":[4450001,4449811],"length":1,"stats":{"Line":6},"fn_name":null},{"line":847,"address":[4449855,4450031],"length":1,"stats":{"Line":6},"fn_name":null},{"line":848,"address":[4449906],"length":1,"stats":{"Line":6},"fn_name":null},{"line":850,"address":[4449541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":853,"address":[4440616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":863,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":870,"address":[5016584],"length":1,"stats":{"Line":0},"fn_name":null},{"line":871,"address":[5032800,5016444],"length":1,"stats":{"Line":12},"fn_name":null},{"line":872,"address":[5016468,5032807],"length":1,"stats":{"Line":12},"fn_name":null},{"line":873,"address":[5016483],"length":1,"stats":{"Line":6},"fn_name":null},{"line":882,"address":[5041116,5041251],"length":1,"stats":{"Line":12},"fn_name":null},{"line":883,"address":[5032831],"length":1,"stats":{"Line":6},"fn_name":null},{"line":884,"address":[5032858],"length":1,"stats":{"Line":6},"fn_name":null},{"line":885,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":886,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":887,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":889,"address":[5041255,5041132],"length":1,"stats":{"Line":6},"fn_name":null},{"line":890,"address":[5041285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":891,"address":[5041167],"length":1,"stats":{"Line":6},"fn_name":null},{"line":901,"address":[5376608],"length":1,"stats":{"Line":0},"fn_name":"match_nfa"},{"line":902,"address":[5376632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":906,"address":[5376704],"length":1,"stats":{"Line":11},"fn_name":"match_nfa_type"},{"line":912,"address":[5376839],"length":1,"stats":{"Line":11},"fn_name":null},{"line":913,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":914,"address":[5376754],"length":1,"stats":{"Line":11},"fn_name":null},{"line":915,"address":[5376764],"length":1,"stats":{"Line":11},"fn_name":null},{"line":918,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":919,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":920,"address":[5376776],"length":1,"stats":{"Line":11},"fn_name":null},{"line":926,"address":[5376960],"length":1,"stats":{"Line":2},"fn_name":"shortest_nfa"},{"line":927,"address":[5376984],"length":1,"stats":{"Line":2},"fn_name":null},{"line":931,"address":[5377072],"length":1,"stats":{"Line":8},"fn_name":"shortest_nfa_type"},{"line":937,"address":[5377122],"length":1,"stats":{"Line":8},"fn_name":null},{"line":938,"address":[5377402,5377295],"length":1,"stats":{"Line":14},"fn_name":null},{"line":939,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":940,"address":[5377210],"length":1,"stats":{"Line":8},"fn_name":null},{"line":941,"address":[5377226],"length":1,"stats":{"Line":8},"fn_name":null},{"line":944,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":945,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":946,"address":[5377239],"length":1,"stats":{"Line":8},"fn_name":null},{"line":948,"address":[5377404],"length":1,"stats":{"Line":10},"fn_name":null},{"line":950,"address":[5377393],"length":1,"stats":{"Line":6},"fn_name":null},{"line":955,"address":[5377472],"length":1,"stats":{"Line":11},"fn_name":"find_nfa"},{"line":961,"address":[5377524],"length":1,"stats":{"Line":11},"fn_name":null},{"line":962,"address":[5377828,5378023,5377711],"length":1,"stats":{"Line":34},"fn_name":null},{"line":963,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":964,"address":[5377612],"length":1,"stats":{"Line":11},"fn_name":null},{"line":965,"address":[5377628],"length":1,"stats":{"Line":11},"fn_name":null},{"line":968,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":969,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":970,"address":[5377644],"length":1,"stats":{"Line":13},"fn_name":null},{"line":972,"address":[5377833,5377923],"length":1,"stats":{"Line":15},"fn_name":null},{"line":973,"address":[5377897,5377925],"length":1,"stats":{"Line":27},"fn_name":null},{"line":974,"address":[5377916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":977,"address":[5377821],"length":1,"stats":{"Line":10},"fn_name":null},{"line":985,"address":[5378048],"length":1,"stats":{"Line":6},"fn_name":"captures_nfa"},{"line":991,"address":[5378172],"length":1,"stats":{"Line":6},"fn_name":null},{"line":992,"address":[5378100],"length":1,"stats":{"Line":6},"fn_name":null},{"line":993,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":994,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":995,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":996,"address":[5378110],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1001,"address":[5378240],"length":1,"stats":{"Line":21},"fn_name":"captures_nfa_type"},{"line":1009,"address":[5378346,5378732,5378475],"length":1,"stats":{"Line":52},"fn_name":null},{"line":1010,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1011,"address":[5378331],"length":1,"stats":{"Line":19},"fn_name":null},{"line":1012,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1015,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1016,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1017,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1019,"address":[5378755,5378489,5378635],"length":1,"stats":{"Line":18},"fn_name":null},{"line":1020,"address":[5378637,5378612],"length":1,"stats":{"Line":37},"fn_name":null},{"line":1021,"address":[5378628],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1024,"address":[5378468],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1028,"address":[5378816],"length":1,"stats":{"Line":21},"fn_name":"exec_nfa"},{"line":1040,"address":[5379233,5378973],"length":1,"stats":{"Line":35},"fn_name":null},{"line":1041,"address":[5379067,5379209,5379127],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1042,"address":[5379211],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1044,"address":[5379187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1050,"address":[5379239,5379502],"length":1,"stats":{"Line":36},"fn_name":null},{"line":1051,"address":[5379400],"length":1,"stats":{"Line":13},"fn_name":null},{"line":1052,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1053,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1054,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1055,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1056,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1057,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1060,"address":[5379360],"length":1,"stats":{"Line":18},"fn_name":null},{"line":1065,"address":[5379536],"length":1,"stats":{"Line":13},"fn_name":"exec_pikevm"},{"line":1074,"address":[5380039,5380233,5379650],"length":1,"stats":{"Line":35},"fn_name":null},{"line":1076,"address":[5379807],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1077,"address":[5379833],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1078,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1079,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1080,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1081,"address":[5379866],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1082,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1083,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1087,"address":[5379781],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1088,"address":[5380057],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1089,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1090,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1091,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1092,"address":[5380098],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1093,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1094,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1100,"address":[5380272],"length":1,"stats":{"Line":16},"fn_name":"exec_backtrack"},{"line":1108,"address":[5380721,5380360,5380896],"length":1,"stats":{"Line":44},"fn_name":null},{"line":1110,"address":[5380509],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1111,"address":[5380535],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1114,"address":[5380568],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1120,"address":[5380483],"length":1,"stats":{"Line":14},"fn_name":null},{"line":1121,"address":[5380739],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1124,"address":[5380780],"length":1,"stats":{"Line":14},"fn_name":null},{"line":1125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1138,"address":[5380928],"length":1,"stats":{"Line":13},"fn_name":"many_matches_at"},{"line":1145,"address":[5381113],"length":1,"stats":{"Line":13},"fn_name":null},{"line":1146,"address":[5381145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1148,"address":[5381233,5385059,5394724,5404350,5381127,5404544],"length":1,"stats":{"Line":36},"fn_name":null},{"line":1150,"address":[5381248,5381184],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1151,"address":[5381284,5384613],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1152,"address":[5404551,5384940,5384601],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1153,"address":[5385023,5404581],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1157,"address":[5394449,5394582,5394722,5394569,5394559],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1158,"address":[5385072],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1159,"address":[5385110],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1164,"address":[5394465,5394561],"length":1,"stats":{"Line":7},"fn_name":null},{"line":1165,"address":[5394574],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1166,"address":[5394602],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1167,"address":[5394504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1169,"address":[5394512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1174,"address":[5394543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1180,"address":[5404217,5404204,5404348,5404194,5404096],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1181,"address":[5394737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1182,"address":[5394775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1187,"address":[5404196,5404112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1188,"address":[5404209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1189,"address":[5404237],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1190,"address":[5404145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1192,"address":[5404153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1197,"address":[5404181],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1201,"address":[5404438,5404363],"length":1,"stats":{"Line":22},"fn_name":null},{"line":1202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1204,"address":[5404376],"length":1,"stats":{"Line":11},"fn_name":null},{"line":1207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1209,"address":[5404408],"length":1,"stats":{"Line":11},"fn_name":null},{"line":1211,"address":[5381225],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1223,"address":[5404640],"length":1,"stats":{"Line":22},"fn_name":"imp"},{"line":1225,"address":[5404670,5405163],"length":1,"stats":{"Line":25},"fn_name":null},{"line":1226,"address":[5404761],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1227,"address":[5404793,5405113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1228,"address":[5405165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1231,"address":[5405187],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1234,"address":[4421002],"length":1,"stats":{"Line":83},"fn_name":null},{"line":1237,"address":[5405200],"length":1,"stats":{"Line":8},"fn_name":"capture_name_idx"},{"line":1238,"address":[5405209],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1243,"address":[5405248],"length":1,"stats":{"Line":5},"fn_name":"capture_name_idx"},{"line":1244,"address":[5405257],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1252,"address":[4420750,4459240],"length":1,"stats":{"Line":147},"fn_name":null},{"line":1254,"address":[4420758,4459248],"length":1,"stats":{"Line":103},"fn_name":null},{"line":1255,"address":[4420766,4459256],"length":1,"stats":{"Line":99},"fn_name":null},{"line":1261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1262,"address":[4978696,4940197,4939055,5042554,4939631,5041894,5042762],"length":1,"stats":{"Line":44},"fn_name":null},{"line":1266,"address":[5405280],"length":1,"stats":{"Line":8},"fn_name":"into_regex"},{"line":1267,"address":[5405287],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1271,"address":[5405360],"length":1,"stats":{"Line":8},"fn_name":"into_regex_set"},{"line":1272,"address":[5405367],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1276,"address":[5405440],"length":1,"stats":{"Line":4},"fn_name":"into_byte_regex"},{"line":1277,"address":[5405447],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1281,"address":[5405520],"length":1,"stats":{"Line":6},"fn_name":"into_byte_regex_set"},{"line":1282,"address":[5405527],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1287,"address":[5405600],"length":1,"stats":{"Line":8},"fn_name":"regex_strings"},{"line":1288,"address":[5405609],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1294,"address":[5405664],"length":1,"stats":{"Line":8},"fn_name":"capture_names"},{"line":1295,"address":[5405673],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1300,"address":[5405728],"length":1,"stats":{"Line":19},"fn_name":"capture_name_idx"},{"line":1301,"address":[5405737],"length":1,"stats":{"Line":21},"fn_name":null},{"line":1306,"address":[5405813,5405776],"length":1,"stats":{"Line":0},"fn_name":"clone"},{"line":1307,"address":[5405793,5405830,5405888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1312,"address":[5405920],"length":1,"stats":{"Line":25},"fn_name":"choose_match_type"},{"line":1313,"address":[5405942,5405998],"length":1,"stats":{"Line":45},"fn_name":null},{"line":1314,"address":[5406011,5406056],"length":1,"stats":{"Line":40},"fn_name":null},{"line":1317,"address":[5406062,5405978],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1318,"address":[5406088],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1320,"address":[5406144,5406073,5406099],"length":1,"stats":{"Line":29},"fn_name":null},{"line":1321,"address":[5406160],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1323,"address":[5406174,5406129,5406222],"length":1,"stats":{"Line":33},"fn_name":null},{"line":1324,"address":[5406238],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1327,"address":[5406199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1332,"address":[5406256],"length":1,"stats":{"Line":12},"fn_name":"choose_literal_match_type"},{"line":1333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1339,"address":[5406304],"length":1,"stats":{"Line":12},"fn_name":"imp"},{"line":1351,"address":[5406313],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1352,"address":[5406377],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1354,"address":[5406399,5406357],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1355,"address":[5406429],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1356,"address":[5406424],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1359,"address":[5406410,5406464],"length":1,"stats":{"Line":26},"fn_name":null},{"line":1360,"address":[5406579,5406543,5406500],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1361,"address":[5406545],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1363,"address":[5406509],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1366,"address":[5406475,5406588],"length":1,"stats":{"Line":22},"fn_name":null},{"line":1367,"address":[5406688,5406693,5406609,5406652],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1368,"address":[5406654],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1373,"address":[5406618],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1376,"address":[5406594],"length":1,"stats":{"Line":11},"fn_name":null},{"line":1379,"address":[5406265],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1383,"address":[5406704],"length":1,"stats":{"Line":11},"fn_name":"choose_dfa_match_type"},{"line":1384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1390,"address":[5406752],"length":1,"stats":{"Line":12},"fn_name":"imp"},{"line":1391,"address":[5406761],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1392,"address":[5406824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1395,"address":[5406802,5406847],"length":1,"stats":{"Line":26},"fn_name":null},{"line":1396,"address":[5406874],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1400,"address":[5406897,5406858],"length":1,"stats":{"Line":15},"fn_name":null},{"line":1401,"address":[5406950],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1407,"address":[5406980,5406939],"length":1,"stats":{"Line":24},"fn_name":null},{"line":1408,"address":[5407012],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1412,"address":[5406986],"length":1,"stats":{"Line":11},"fn_name":null},{"line":1415,"address":[5406713],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1433,"address":[5407040],"length":1,"stats":{"Line":13},"fn_name":"should_suffix_scan"},{"line":1434,"address":[5407049],"length":1,"stats":{"Line":13},"fn_name":null},{"line":1435,"address":[5407111],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1437,"address":[5407135,5407090],"length":1,"stats":{"Line":16},"fn_name":null},{"line":1438,"address":[5407155,5407210],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1511,"address":[5407248,5407302],"length":1,"stats":{"Line":25},"fn_name":"new"},{"line":1513,"address":[5407266],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1514,"address":[5407330],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1516,"address":[5407342],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1518,"address":[5407383],"length":1,"stats":{"Line":23},"fn_name":null},{"line":1526,"address":[5407664,5407732],"length":1,"stats":{"Line":10},"fn_name":"alternation_literals"},{"line":1537,"address":[5407754,5407682],"length":1,"stats":{"Line":20},"fn_name":null},{"line":1538,"address":[5407792],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1540,"address":[5407768],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1541,"address":[5407823,5407863],"length":1,"stats":{"Line":19},"fn_name":null},{"line":1542,"address":[5407842],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1545,"address":[4898482,4898240,4898315],"length":1,"stats":{"Line":19},"fn_name":"{{closure}}"},{"line":1546,"address":[4898329,4898262],"length":1,"stats":{"Line":20},"fn_name":null},{"line":1547,"address":[4898336],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1548,"address":[4898376,4898476],"length":1,"stats":{"Line":20},"fn_name":null},{"line":1550,"address":[4898289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1551,"address":[4898301],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1555,"address":[5407886],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1556,"address":[5408011,5409129,5407923,5408175],"length":1,"stats":{"Line":30},"fn_name":null},{"line":1557,"address":[5408218],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1558,"address":[5408630,5408280,5408496],"length":1,"stats":{"Line":28},"fn_name":null},{"line":1559,"address":[5408309,5408429],"length":1,"stats":{"Line":17},"fn_name":null},{"line":1560,"address":[5408506],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1561,"address":[5408518,5408635,5408855],"length":1,"stats":{"Line":19},"fn_name":null},{"line":1562,"address":[5408669],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1563,"address":[5408788,5408698],"length":1,"stats":{"Line":18},"fn_name":null},{"line":1570,"address":[5409054],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1572,"address":[5408079],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1578,"address":[4799744,4799749],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1585,"address":[4799776,4799783],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1586,"address":[4799856,4799866],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1592,"address":[4800144,4800151],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1593,"address":[4800224,4800234],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1596,"address":[5617633],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1598,"address":[5617704],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1599,"address":[5617782],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1600,"address":[5618128,5618395,5617844],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1601,"address":[5618298,5618400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1606,"address":[4800517,4800512],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1613,"address":[4800544,4800551],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1614,"address":[4800634,4800624],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1620,"address":[4800912,4800919],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1621,"address":[4801002,4800992],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1624,"address":[5619175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1626,"address":[5619220],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1627,"address":[5619230],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1628,"address":[5619283,5619563,5619830],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1629,"address":[5619733,5619835],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":444,"coverable":658},{"path":["/","usr","src","regex","src","expand.rs"],"content":"use std::str;\n\nuse find_byte::find_byte;\n\nuse re_bytes;\nuse re_unicode;\n\npub fn expand_str(\n    caps: &re_unicode::Captures,\n    mut replacement: &str,\n    dst: &mut String,\n) {\n    while !replacement.is_empty() {\n        match find_byte(b'$', replacement.as_bytes()) {\n            None => break,\n            Some(i) => {\n                dst.push_str(&replacement[..i]);\n                replacement = &replacement[i..];\n            }\n        }\n        if replacement.as_bytes().get(1).map_or(false, |&b| b == b'$') {\n            dst.push_str(\"$\");\n            replacement = &replacement[2..];\n            continue;\n        }\n        debug_assert!(!replacement.is_empty());\n        let cap_ref = match find_cap_ref(replacement) {\n            Some(cap_ref) => cap_ref,\n            None => {\n                dst.push_str(\"$\");\n                replacement = &replacement[1..];\n                continue;\n            }\n        };\n        replacement = &replacement[cap_ref.end..];\n        match cap_ref.cap {\n            Ref::Number(i) => {\n                dst.push_str(caps.get(i).map(|m| m.as_str()).unwrap_or(\"\"));\n            }\n            Ref::Named(name) => {\n                dst.push_str(\n                    caps.name(name).map(|m| m.as_str()).unwrap_or(\"\"),\n                );\n            }\n        }\n    }\n    dst.push_str(replacement);\n}\n\npub fn expand_bytes(\n    caps: &re_bytes::Captures,\n    mut replacement: &[u8],\n    dst: &mut Vec<u8>,\n) {\n    while !replacement.is_empty() {\n        match find_byte(b'$', replacement) {\n            None => break,\n            Some(i) => {\n                dst.extend(&replacement[..i]);\n                replacement = &replacement[i..];\n            }\n        }\n        if replacement.get(1).map_or(false, |&b| b == b'$') {\n            dst.push(b'$');\n            replacement = &replacement[2..];\n            continue;\n        }\n        debug_assert!(!replacement.is_empty());\n        let cap_ref = match find_cap_ref(replacement) {\n            Some(cap_ref) => cap_ref,\n            None => {\n                dst.push(b'$');\n                replacement = &replacement[1..];\n                continue;\n            }\n        };\n        replacement = &replacement[cap_ref.end..];\n        match cap_ref.cap {\n            Ref::Number(i) => {\n                dst.extend(caps.get(i).map(|m| m.as_bytes()).unwrap_or(b\"\"));\n            }\n            Ref::Named(name) => {\n                dst.extend(\n                    caps.name(name).map(|m| m.as_bytes()).unwrap_or(b\"\"),\n                );\n            }\n        }\n    }\n    dst.extend(replacement);\n}\n\n/// `CaptureRef` represents a reference to a capture group inside some text.\n/// The reference is either a capture group name or a number.\n///\n/// It is also tagged with the position in the text following the\n/// capture reference.\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\nstruct CaptureRef<'a> {\n    cap: Ref<'a>,\n    end: usize,\n}\n\n/// A reference to a capture group in some text.\n///\n/// e.g., `$2`, `$foo`, `${foo}`.\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\nenum Ref<'a> {\n    Named(&'a str),\n    Number(usize),\n}\n\nimpl<'a> From<&'a str> for Ref<'a> {\n    fn from(x: &'a str) -> Ref<'a> {\n        Ref::Named(x)\n    }\n}\n\nimpl From<usize> for Ref<'static> {\n    fn from(x: usize) -> Ref<'static> {\n        Ref::Number(x)\n    }\n}\n\n/// Parses a possible reference to a capture group name in the given text,\n/// starting at the beginning of `replacement`.\n///\n/// If no such valid reference could be found, None is returned.\nfn find_cap_ref<T: ?Sized + AsRef<[u8]>>(\n    replacement: &T,\n) -> Option<CaptureRef> {\n    let mut i = 0;\n    let rep: &[u8] = replacement.as_ref();\n    if rep.len() <= 1 || rep[0] != b'$' {\n        return None;\n    }\n    let mut brace = false;\n    i += 1;\n    if rep[i] == b'{' {\n        brace = true;\n        i += 1;\n    }\n    let mut cap_end = i;\n    while rep.get(cap_end).map_or(false, is_valid_cap_letter) {\n        cap_end += 1;\n    }\n    if cap_end == i {\n        return None;\n    }\n    // We just verified that the range 0..cap_end is valid ASCII, so it must\n    // therefore be valid UTF-8. If we really cared, we could avoid this UTF-8\n    // check with either unsafe or by parsing the number straight from &[u8].\n    let cap =\n        str::from_utf8(&rep[i..cap_end]).expect(\"valid UTF-8 capture name\");\n    if brace {\n        if !rep.get(cap_end).map_or(false, |&b| b == b'}') {\n            return None;\n        }\n        cap_end += 1;\n    }\n    Some(CaptureRef {\n        cap: match cap.parse::<u32>() {\n            Ok(i) => Ref::Number(i as usize),\n            Err(_) => Ref::Named(cap),\n        },\n        end: cap_end,\n    })\n}\n\n/// Returns true if and only if the given byte is allowed in a capture name.\nfn is_valid_cap_letter(b: &u8) -> bool {\n    match *b {\n        b'0'..=b'9' | b'a'..=b'z' | b'A'..=b'Z' | b'_' => true,\n        _ => false,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{find_cap_ref, CaptureRef};\n\n    macro_rules! find {\n        ($name:ident, $text:expr) => {\n            #[test]\n            fn $name() {\n                assert_eq!(None, find_cap_ref($text));\n            }\n        };\n        ($name:ident, $text:expr, $capref:expr) => {\n            #[test]\n            fn $name() {\n                assert_eq!(Some($capref), find_cap_ref($text));\n            }\n        };\n    }\n\n    macro_rules! c {\n        ($name_or_number:expr, $pos:expr) => {\n            CaptureRef { cap: $name_or_number.into(), end: $pos }\n        };\n    }\n\n    find!(find_cap_ref1, \"$foo\", c!(\"foo\", 4));\n    find!(find_cap_ref2, \"${foo}\", c!(\"foo\", 6));\n    find!(find_cap_ref3, \"$0\", c!(0, 2));\n    find!(find_cap_ref4, \"$5\", c!(5, 2));\n    find!(find_cap_ref5, \"$10\", c!(10, 3));\n    // see https://github.com/rust-lang/regex/pull/585 for more on characters following numbers\n    find!(find_cap_ref6, \"$42a\", c!(\"42a\", 4));\n    find!(find_cap_ref7, \"${42}a\", c!(42, 5));\n    find!(find_cap_ref8, \"${42\");\n    find!(find_cap_ref9, \"${42 \");\n    find!(find_cap_ref10, \" $0 \");\n    find!(find_cap_ref11, \"$\");\n    find!(find_cap_ref12, \" \");\n    find!(find_cap_ref13, \"\");\n    find!(find_cap_ref14, \"$1-$2\", c!(1, 2));\n    find!(find_cap_ref15, \"$1_$2\", c!(\"1_\", 3));\n    find!(find_cap_ref16, \"$x-$y\", c!(\"x\", 2));\n    find!(find_cap_ref17, \"$x_$y\", c!(\"x_\", 3));\n}\n","traces":[{"line":8,"address":[5813792],"length":1,"stats":{"Line":7},"fn_name":"expand_str"},{"line":13,"address":[5815259,5813847],"length":1,"stats":{"Line":19},"fn_name":null},{"line":14,"address":[5813893,5814110,5813994],"length":1,"stats":{"Line":15},"fn_name":null},{"line":15,"address":[5814112,5814015],"length":1,"stats":{"Line":24},"fn_name":null},{"line":16,"address":[5814030],"length":1,"stats":{"Line":15},"fn_name":null},{"line":17,"address":[5814046,5814172],"length":1,"stats":{"Line":30},"fn_name":null},{"line":18,"address":[5814177],"length":1,"stats":{"Line":15},"fn_name":null},{"line":21,"address":[4604544,4604553],"length":1,"stats":{"Line":56},"fn_name":"{{closure}}"},{"line":22,"address":[5814451],"length":1,"stats":{"Line":9},"fn_name":null},{"line":23,"address":[5814464],"length":1,"stats":{"Line":9},"fn_name":null},{"line":24,"address":[5814542],"length":1,"stats":{"Line":9},"fn_name":null},{"line":26,"address":[5814551,5814409,5814590],"length":1,"stats":{"Line":28},"fn_name":null},{"line":27,"address":[5814679,5814559],"length":1,"stats":{"Line":15},"fn_name":null},{"line":28,"address":[5814620,5814681],"length":1,"stats":{"Line":32},"fn_name":null},{"line":30,"address":[5814661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[5814867],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[5814945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[5814955,5814809],"length":1,"stats":{"Line":30},"fn_name":null},{"line":36,"address":[5815175,5815257,5815051],"length":1,"stats":{"Line":15},"fn_name":null},{"line":37,"address":[5814976,5815053],"length":1,"stats":{"Line":27},"fn_name":null},{"line":38,"address":[4604580,4604576],"length":1,"stats":{"Line":30},"fn_name":"{{closure}}"},{"line":40,"address":[5814993],"length":1,"stats":{"Line":7},"fn_name":null},{"line":41,"address":[5815252],"length":1,"stats":{"Line":5},"fn_name":null},{"line":42,"address":[4604608,4604612],"length":1,"stats":{"Line":24},"fn_name":"{{closure}}"},{"line":47,"address":[5814114],"length":1,"stats":{"Line":12},"fn_name":null},{"line":50,"address":[5815280],"length":1,"stats":{"Line":4},"fn_name":"expand_bytes"},{"line":55,"address":[5816575,5815335],"length":1,"stats":{"Line":11},"fn_name":null},{"line":56,"address":[5815519,5815382],"length":1,"stats":{"Line":4},"fn_name":null},{"line":57,"address":[5815521,5815424],"length":1,"stats":{"Line":13},"fn_name":null},{"line":58,"address":[5815439],"length":1,"stats":{"Line":9},"fn_name":null},{"line":59,"address":[5815455,5815582],"length":1,"stats":{"Line":18},"fn_name":null},{"line":60,"address":[5815588],"length":1,"stats":{"Line":9},"fn_name":null},{"line":63,"address":[4604640,4604649],"length":1,"stats":{"Line":27},"fn_name":"{{closure}}"},{"line":64,"address":[5815776],"length":1,"stats":{"Line":4},"fn_name":null},{"line":65,"address":[5815787],"length":1,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[5815865],"length":1,"stats":{"Line":4},"fn_name":null},{"line":68,"address":[5815740,5815874,5815913],"length":1,"stats":{"Line":18},"fn_name":null},{"line":69,"address":[5815882,5815993],"length":1,"stats":{"Line":9},"fn_name":null},{"line":70,"address":[5815995,5815943],"length":1,"stats":{"Line":18},"fn_name":null},{"line":72,"address":[5815977],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[5816181],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[5816259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[5816269,5816123],"length":1,"stats":{"Line":18},"fn_name":null},{"line":78,"address":[5816490,5816365,5816573],"length":1,"stats":{"Line":9},"fn_name":null},{"line":79,"address":[5816290,5816367],"length":1,"stats":{"Line":15},"fn_name":null},{"line":80,"address":[4604676,4604672],"length":1,"stats":{"Line":18},"fn_name":"{{closure}}"},{"line":82,"address":[5816307],"length":1,"stats":{"Line":3},"fn_name":null},{"line":83,"address":[5816567],"length":1,"stats":{"Line":3},"fn_name":null},{"line":84,"address":[4604708,4604704],"length":1,"stats":{"Line":12},"fn_name":"{{closure}}"},{"line":89,"address":[5815523],"length":1,"stats":{"Line":6},"fn_name":null},{"line":113,"address":[5816592],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":114,"address":[5816608],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[5816640],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":120,"address":[5816648],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[4604736,4606016],"length":1,"stats":{"Line":23},"fn_name":"find_cap_ref<str>"},{"line":131,"address":[4606042,4604762],"length":1,"stats":{"Line":25},"fn_name":null},{"line":132,"address":[4604782,4606062],"length":1,"stats":{"Line":23},"fn_name":null},{"line":133,"address":[4605840,4604837,4606118,4607121],"length":1,"stats":{"Line":25},"fn_name":null},{"line":134,"address":[4606270,4604989,4606295,4605014],"length":1,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[4606221,4604940],"length":1,"stats":{"Line":23},"fn_name":null},{"line":137,"address":[4607148,4605867,4604948,4606229,4606302,4605021],"length":1,"stats":{"Line":48},"fn_name":null},{"line":138,"address":[4606310,4607178,4605897,4605029],"length":1,"stats":{"Line":25},"fn_name":null},{"line":139,"address":[4605081,4606362],"length":1,"stats":{"Line":9},"fn_name":null},{"line":140,"address":[4606370,4605089,4605925,4607206],"length":1,"stats":{"Line":9},"fn_name":null},{"line":142,"address":[4605133,4606414],"length":1,"stats":{"Line":23},"fn_name":null},{"line":143,"address":[4606430,4605268,4605149,4606549],"length":1,"stats":{"Line":48},"fn_name":null},{"line":144,"address":[4605955,4606505,4607236,4605224],"length":1,"stats":{"Line":25},"fn_name":null},{"line":146,"address":[4605204,4606485],"length":1,"stats":{"Line":25},"fn_name":null},{"line":147,"address":[4605354,4606635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[4606551,4605366,4606647,4605270],"length":1,"stats":{"Line":50},"fn_name":null},{"line":154,"address":[4605451,4606732],"length":1,"stats":{"Line":23},"fn_name":null},{"line":155,"address":[4605461,4606742,4607337,4607305,4607296,4607328],"length":1,"stats":{"Line":27},"fn_name":"{{closure}}<str>"},{"line":156,"address":[4605556,4606837],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[4605572,4606853,4607266,4607296,4605516,4606797,4606015,4605985],"length":1,"stats":{"Line":18},"fn_name":"{{closure}}<str>"},{"line":160,"address":[4605724,4607005],"length":1,"stats":{"Line":25},"fn_name":null},{"line":161,"address":[4605590,4605674,4606871,4606955],"length":1,"stats":{"Line":36},"fn_name":null},{"line":162,"address":[4605619,4605678,4606900,4606959],"length":1,"stats":{"Line":40},"fn_name":null},{"line":163,"address":[4605641,4606922],"length":1,"stats":{"Line":11},"fn_name":null},{"line":165,"address":[4605716,4606997],"length":1,"stats":{"Line":18},"fn_name":null},{"line":170,"address":[5816672],"length":1,"stats":{"Line":23},"fn_name":"is_valid_cap_letter"},{"line":171,"address":[5816752],"length":1,"stats":{"Line":9},"fn_name":null},{"line":172,"address":[5816681,5816754],"length":1,"stats":{"Line":48},"fn_name":null},{"line":173,"address":[5816747],"length":1,"stats":{"Line":9},"fn_name":null},{"line":184,"address":[4316176,4316181,4316213,4316272,4316277,4316309,4316144,4316245,4316149,4316208,4316240,4316304],"length":1,"stats":{"Line":18},"fn_name":"{{closure}}"},{"line":185,"address":[4791390,4792373,4792686,4791822,4792805,4793547,4792254,4793118,4793237,4793665,4791941,4791509],"length":1,"stats":{"Line":6},"fn_name":null},{"line":190,"address":[4316080,4316368,4316021,4315952,4315957,4316437,4316112,4315984,4316117,4316432,4316336,4316016,4316400,4315920,4316373,4316053,4315925,4316048,4316341,4316085,4315989,4316405],"length":1,"stats":{"Line":33},"fn_name":"{{closure}}"},{"line":191,"address":[4795323,4795718,4795883,4789985,4794044,4787622,4787787,4788347,4795158,4790374,4790924,4789276,4789820,4789441,4788731,4794598,4788182,4788896,4791089,4794209,4790539,4794763],"length":1,"stats":{"Line":11},"fn_name":null},{"line":202,"address":[4787534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[4788094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[4788651],"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[4789191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[4789735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[4790286],"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[4790839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[4793959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[4794510],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[4795070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[4795630],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":91,"coverable":98},{"path":["/","usr","src","regex","src","find_byte.rs"],"content":"/// Searches for the given needle in the given haystack.\n///\n/// If the perf-literal feature is enabled, then this uses the super optimized\n/// memchr crate. Otherwise, it uses the naive byte-at-a-time implementation.\npub fn find_byte(needle: u8, haystack: &[u8]) -> Option<usize> {\n    #[cfg(not(feature = \"perf-literal\"))]\n    fn imp(needle: u8, haystack: &[u8]) -> Option<usize> {\n        haystack.iter().position(|&b| b == needle)\n    }\n\n    #[cfg(feature = \"perf-literal\")]\n    fn imp(needle: u8, haystack: &[u8]) -> Option<usize> {\n        use memchr::memchr;\n        memchr(needle, haystack)\n    }\n\n    imp(needle, haystack)\n}\n","traces":[{"line":5,"address":[10215472],"length":1,"stats":{"Line":12},"fn_name":"find_byte"},{"line":12,"address":[5744016],"length":1,"stats":{"Line":12},"fn_name":"imp"},{"line":14,"address":[9226515],"length":1,"stats":{"Line":12},"fn_name":null},{"line":17,"address":[5743971],"length":1,"stats":{"Line":12},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","usr","src","regex","src","input.rs"],"content":"use std::char;\nuse std::cmp::Ordering;\nuse std::fmt;\nuse std::ops;\nuse std::u32;\n\nuse syntax;\n\nuse literal::LiteralSearcher;\nuse prog::InstEmptyLook;\nuse utf8::{decode_last_utf8, decode_utf8};\n\n/// Represents a location in the input.\n#[derive(Clone, Copy, Debug)]\npub struct InputAt {\n    pos: usize,\n    c: Char,\n    byte: Option<u8>,\n    len: usize,\n}\n\nimpl InputAt {\n    /// Returns true iff this position is at the beginning of the input.\n    pub fn is_start(&self) -> bool {\n        self.pos == 0\n    }\n\n    /// Returns true iff this position is past the end of the input.\n    pub fn is_end(&self) -> bool {\n        self.c.is_none() && self.byte.is_none()\n    }\n\n    /// Returns the character at this position.\n    ///\n    /// If this position is just before or after the input, then an absent\n    /// character is returned.\n    pub fn char(&self) -> Char {\n        self.c\n    }\n\n    /// Returns the byte at this position.\n    pub fn byte(&self) -> Option<u8> {\n        self.byte\n    }\n\n    /// Returns the UTF-8 width of the character at this position.\n    pub fn len(&self) -> usize {\n        self.len\n    }\n\n    /// Returns whether the UTF-8 width of the character at this position\n    /// is zero.\n    pub fn is_empty(&self) -> bool {\n        self.len == 0\n    }\n\n    /// Returns the byte offset of this position.\n    pub fn pos(&self) -> usize {\n        self.pos\n    }\n\n    /// Returns the byte offset of the next position in the input.\n    pub fn next_pos(&self) -> usize {\n        self.pos + self.len\n    }\n}\n\n/// An abstraction over input used in the matching engines.\npub trait Input: fmt::Debug {\n    /// Return an encoding of the position at byte offset `i`.\n    fn at(&self, i: usize) -> InputAt;\n\n    /// Return the Unicode character occurring next to `at`.\n    ///\n    /// If no such character could be decoded, then `Char` is absent.\n    fn next_char(&self, at: InputAt) -> Char;\n\n    /// Return the Unicode character occurring previous to `at`.\n    ///\n    /// If no such character could be decoded, then `Char` is absent.\n    fn previous_char(&self, at: InputAt) -> Char;\n\n    /// Return true if the given empty width instruction matches at the\n    /// input position given.\n    fn is_empty_match(&self, at: InputAt, empty: &InstEmptyLook) -> bool;\n\n    /// Scan the input for a matching prefix.\n    fn prefix_at(\n        &self,\n        prefixes: &LiteralSearcher,\n        at: InputAt,\n    ) -> Option<InputAt>;\n\n    /// The number of bytes in the input.\n    fn len(&self) -> usize;\n\n    /// Whether the input is empty.\n    fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Return the given input as a sequence of bytes.\n    fn as_bytes(&self) -> &[u8];\n}\n\nimpl<'a, T: Input> Input for &'a T {\n    fn at(&self, i: usize) -> InputAt {\n        (**self).at(i)\n    }\n\n    fn next_char(&self, at: InputAt) -> Char {\n        (**self).next_char(at)\n    }\n\n    fn previous_char(&self, at: InputAt) -> Char {\n        (**self).previous_char(at)\n    }\n\n    fn is_empty_match(&self, at: InputAt, empty: &InstEmptyLook) -> bool {\n        (**self).is_empty_match(at, empty)\n    }\n\n    fn prefix_at(\n        &self,\n        prefixes: &LiteralSearcher,\n        at: InputAt,\n    ) -> Option<InputAt> {\n        (**self).prefix_at(prefixes, at)\n    }\n\n    fn len(&self) -> usize {\n        (**self).len()\n    }\n\n    fn as_bytes(&self) -> &[u8] {\n        (**self).as_bytes()\n    }\n}\n\n/// An input reader over characters.\n#[derive(Clone, Copy, Debug)]\npub struct CharInput<'t>(&'t [u8]);\n\nimpl<'t> CharInput<'t> {\n    /// Return a new character input reader for the given string.\n    pub fn new(s: &'t [u8]) -> CharInput<'t> {\n        CharInput(s)\n    }\n}\n\nimpl<'t> ops::Deref for CharInput<'t> {\n    type Target = [u8];\n\n    fn deref(&self) -> &[u8] {\n        self.0\n    }\n}\n\nimpl<'t> Input for CharInput<'t> {\n    fn at(&self, i: usize) -> InputAt {\n        if i >= self.len() {\n            InputAt { pos: self.len(), c: None.into(), byte: None, len: 0 }\n        } else {\n            let c = decode_utf8(&self[i..]).map(|(c, _)| c).into();\n            InputAt { pos: i, c: c, byte: None, len: c.len_utf8() }\n        }\n    }\n\n    fn next_char(&self, at: InputAt) -> Char {\n        at.char()\n    }\n\n    fn previous_char(&self, at: InputAt) -> Char {\n        decode_last_utf8(&self[..at.pos()]).map(|(c, _)| c).into()\n    }\n\n    fn is_empty_match(&self, at: InputAt, empty: &InstEmptyLook) -> bool {\n        use prog::EmptyLook::*;\n        match empty.look {\n            StartLine => {\n                let c = self.previous_char(at);\n                at.pos() == 0 || c == '\\n'\n            }\n            EndLine => {\n                let c = self.next_char(at);\n                at.pos() == self.len() || c == '\\n'\n            }\n            StartText => at.pos() == 0,\n            EndText => at.pos() == self.len(),\n            WordBoundary => {\n                let (c1, c2) = (self.previous_char(at), self.next_char(at));\n                c1.is_word_char() != c2.is_word_char()\n            }\n            NotWordBoundary => {\n                let (c1, c2) = (self.previous_char(at), self.next_char(at));\n                c1.is_word_char() == c2.is_word_char()\n            }\n            WordBoundaryAscii => {\n                let (c1, c2) = (self.previous_char(at), self.next_char(at));\n                c1.is_word_byte() != c2.is_word_byte()\n            }\n            NotWordBoundaryAscii => {\n                let (c1, c2) = (self.previous_char(at), self.next_char(at));\n                c1.is_word_byte() == c2.is_word_byte()\n            }\n        }\n    }\n\n    fn prefix_at(\n        &self,\n        prefixes: &LiteralSearcher,\n        at: InputAt,\n    ) -> Option<InputAt> {\n        prefixes.find(&self[at.pos()..]).map(|(s, _)| self.at(at.pos() + s))\n    }\n\n    fn len(&self) -> usize {\n        self.0.len()\n    }\n\n    fn as_bytes(&self) -> &[u8] {\n        self.0\n    }\n}\n\n/// An input reader over bytes.\n#[derive(Clone, Copy, Debug)]\npub struct ByteInput<'t> {\n    text: &'t [u8],\n    only_utf8: bool,\n}\n\nimpl<'t> ByteInput<'t> {\n    /// Return a new byte-based input reader for the given string.\n    pub fn new(text: &'t [u8], only_utf8: bool) -> ByteInput<'t> {\n        ByteInput { text: text, only_utf8: only_utf8 }\n    }\n}\n\nimpl<'t> ops::Deref for ByteInput<'t> {\n    type Target = [u8];\n\n    fn deref(&self) -> &[u8] {\n        self.text\n    }\n}\n\nimpl<'t> Input for ByteInput<'t> {\n    fn at(&self, i: usize) -> InputAt {\n        if i >= self.len() {\n            InputAt { pos: self.len(), c: None.into(), byte: None, len: 0 }\n        } else {\n            InputAt {\n                pos: i,\n                c: None.into(),\n                byte: self.get(i).cloned(),\n                len: 1,\n            }\n        }\n    }\n\n    fn next_char(&self, at: InputAt) -> Char {\n        decode_utf8(&self[at.pos()..]).map(|(c, _)| c).into()\n    }\n\n    fn previous_char(&self, at: InputAt) -> Char {\n        decode_last_utf8(&self[..at.pos()]).map(|(c, _)| c).into()\n    }\n\n    fn is_empty_match(&self, at: InputAt, empty: &InstEmptyLook) -> bool {\n        use prog::EmptyLook::*;\n        match empty.look {\n            StartLine => {\n                let c = self.previous_char(at);\n                at.pos() == 0 || c == '\\n'\n            }\n            EndLine => {\n                let c = self.next_char(at);\n                at.pos() == self.len() || c == '\\n'\n            }\n            StartText => at.pos() == 0,\n            EndText => at.pos() == self.len(),\n            WordBoundary => {\n                let (c1, c2) = (self.previous_char(at), self.next_char(at));\n                c1.is_word_char() != c2.is_word_char()\n            }\n            NotWordBoundary => {\n                let (c1, c2) = (self.previous_char(at), self.next_char(at));\n                c1.is_word_char() == c2.is_word_char()\n            }\n            WordBoundaryAscii => {\n                let (c1, c2) = (self.previous_char(at), self.next_char(at));\n                if self.only_utf8 {\n                    // If we must match UTF-8, then we can't match word\n                    // boundaries at invalid UTF-8.\n                    if c1.is_none() && !at.is_start() {\n                        return false;\n                    }\n                    if c2.is_none() && !at.is_end() {\n                        return false;\n                    }\n                }\n                c1.is_word_byte() != c2.is_word_byte()\n            }\n            NotWordBoundaryAscii => {\n                let (c1, c2) = (self.previous_char(at), self.next_char(at));\n                if self.only_utf8 {\n                    // If we must match UTF-8, then we can't match word\n                    // boundaries at invalid UTF-8.\n                    if c1.is_none() && !at.is_start() {\n                        return false;\n                    }\n                    if c2.is_none() && !at.is_end() {\n                        return false;\n                    }\n                }\n                c1.is_word_byte() == c2.is_word_byte()\n            }\n        }\n    }\n\n    fn prefix_at(\n        &self,\n        prefixes: &LiteralSearcher,\n        at: InputAt,\n    ) -> Option<InputAt> {\n        prefixes.find(&self[at.pos()..]).map(|(s, _)| self.at(at.pos() + s))\n    }\n\n    fn len(&self) -> usize {\n        self.text.len()\n    }\n\n    fn as_bytes(&self) -> &[u8] {\n        self.text\n    }\n}\n\n/// An inline representation of `Option<char>`.\n///\n/// This eliminates the need to do case analysis on `Option<char>` to determine\n/// ordinality with other characters.\n///\n/// (The `Option<char>` is not related to encoding. Instead, it is used in the\n/// matching engines to represent the beginning and ending boundaries of the\n/// search text.)\n#[derive(Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord)]\npub struct Char(u32);\n\nimpl fmt::Debug for Char {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match char::from_u32(self.0) {\n            None => write!(f, \"Empty\"),\n            Some(c) => write!(f, \"{:?}\", c),\n        }\n    }\n}\n\nimpl Char {\n    /// Returns true iff the character is absent.\n    #[inline]\n    pub fn is_none(self) -> bool {\n        self.0 == u32::MAX\n    }\n\n    /// Returns the length of the character's UTF-8 encoding.\n    ///\n    /// If the character is absent, then `1` is returned.\n    #[inline]\n    pub fn len_utf8(self) -> usize {\n        char::from_u32(self.0).map_or(1, |c| c.len_utf8())\n    }\n\n    /// Returns true iff the character is a word character.\n    ///\n    /// If the character is absent, then false is returned.\n    pub fn is_word_char(self) -> bool {\n        // is_word_character can panic if the Unicode data for \\w isn't\n        // available. However, our compiler ensures that if a Unicode word\n        // boundary is used, then the data must also be available. If it isn't,\n        // then the compiler returns an error.\n        char::from_u32(self.0).map_or(false, syntax::is_word_character)\n    }\n\n    /// Returns true iff the byte is a word byte.\n    ///\n    /// If the byte is absent, then false is returned.\n    pub fn is_word_byte(self) -> bool {\n        match char::from_u32(self.0) {\n            Some(c) if c <= '\\u{7F}' => syntax::is_word_byte(c as u8),\n            None | Some(_) => false,\n        }\n    }\n}\n\nimpl From<char> for Char {\n    fn from(c: char) -> Char {\n        Char(c as u32)\n    }\n}\n\nimpl From<Option<char>> for Char {\n    fn from(c: Option<char>) -> Char {\n        c.map_or(Char(u32::MAX), |c| c.into())\n    }\n}\n\nimpl PartialEq<char> for Char {\n    #[inline]\n    fn eq(&self, other: &char) -> bool {\n        self.0 == *other as u32\n    }\n}\n\nimpl PartialEq<Char> for char {\n    #[inline]\n    fn eq(&self, other: &Char) -> bool {\n        *self as u32 == other.0\n    }\n}\n\nimpl PartialOrd<char> for Char {\n    #[inline]\n    fn partial_cmp(&self, other: &char) -> Option<Ordering> {\n        self.0.partial_cmp(&(*other as u32))\n    }\n}\n\nimpl PartialOrd<Char> for char {\n    #[inline]\n    fn partial_cmp(&self, other: &Char) -> Option<Ordering> {\n        (*self as u32).partial_cmp(&other.0)\n    }\n}\n","traces":[{"line":24,"address":[4408016],"length":1,"stats":{"Line":19},"fn_name":"is_start"},{"line":25,"address":[4408021],"length":1,"stats":{"Line":20},"fn_name":null},{"line":29,"address":[4408048],"length":1,"stats":{"Line":2},"fn_name":"is_end"},{"line":30,"address":[4408135,4408057],"length":1,"stats":{"Line":4},"fn_name":null},{"line":37,"address":[4408160],"length":1,"stats":{"Line":16},"fn_name":"char"},{"line":38,"address":[4408165],"length":1,"stats":{"Line":16},"fn_name":null},{"line":42,"address":[4408176],"length":1,"stats":{"Line":18},"fn_name":"byte"},{"line":43,"address":[4408181],"length":1,"stats":{"Line":17},"fn_name":null},{"line":47,"address":[4408192],"length":1,"stats":{"Line":0},"fn_name":"len"},{"line":48,"address":[4408197],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[4408208],"length":1,"stats":{"Line":0},"fn_name":"is_empty"},{"line":54,"address":[4408213],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[4408240],"length":1,"stats":{"Line":15},"fn_name":"pos"},{"line":59,"address":[4408245],"length":1,"stats":{"Line":14},"fn_name":null},{"line":63,"address":[4408256],"length":1,"stats":{"Line":20},"fn_name":"next_pos"},{"line":64,"address":[4408295,4408325,4408265],"length":1,"stats":{"Line":20},"fn_name":null},{"line":98,"address":[4407280,4407328],"length":1,"stats":{"Line":0},"fn_name":"is_empty<regex::input::CharInput>"},{"line":99,"address":[4407337,4407289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[4408336],"length":1,"stats":{"Line":18},"fn_name":"new"},{"line":147,"address":[4408350],"length":1,"stats":{"Line":16},"fn_name":null},{"line":154,"address":[4408384],"length":1,"stats":{"Line":18},"fn_name":"deref"},{"line":155,"address":[4408389],"length":1,"stats":{"Line":16},"fn_name":null},{"line":160,"address":[4408400],"length":1,"stats":{"Line":16},"fn_name":"at"},{"line":161,"address":[4408431,4408602],"length":1,"stats":{"Line":35},"fn_name":null},{"line":162,"address":[4408501],"length":1,"stats":{"Line":13},"fn_name":null},{"line":164,"address":[4407389,4407376],"length":1,"stats":{"Line":68},"fn_name":"{{closure}}"},{"line":165,"address":[4408716],"length":1,"stats":{"Line":18},"fn_name":null},{"line":169,"address":[4408816],"length":1,"stats":{"Line":8},"fn_name":"next_char"},{"line":170,"address":[4408825],"length":1,"stats":{"Line":8},"fn_name":null},{"line":173,"address":[4408848],"length":1,"stats":{"Line":8},"fn_name":"previous_char"},{"line":174,"address":[4407408,4407421],"length":1,"stats":{"Line":24},"fn_name":"{{closure}}"},{"line":177,"address":[4409008],"length":1,"stats":{"Line":16},"fn_name":"is_empty_match"},{"line":179,"address":[4409561,4409866,4409628,4409303,4409161,4410344,4409471,4410106],"length":1,"stats":{"Line":50},"fn_name":null},{"line":180,"address":[4409031],"length":1,"stats":{"Line":14},"fn_name":null},{"line":181,"address":[4409171],"length":1,"stats":{"Line":4},"fn_name":null},{"line":182,"address":[4409242,4409316],"length":1,"stats":{"Line":8},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[4409342],"length":1,"stats":{"Line":4},"fn_name":null},{"line":186,"address":[4409413,4409484],"length":1,"stats":{"Line":8},"fn_name":null},{"line":188,"address":[4409529],"length":1,"stats":{"Line":14},"fn_name":null},{"line":189,"address":[4409574],"length":1,"stats":{"Line":13},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[4409641],"length":1,"stats":{"Line":8},"fn_name":null},{"line":192,"address":[4409819],"length":1,"stats":{"Line":8},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[4409879],"length":1,"stats":{"Line":7},"fn_name":null},{"line":196,"address":[4410057],"length":1,"stats":{"Line":7},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[4410119],"length":1,"stats":{"Line":4},"fn_name":null},{"line":200,"address":[4410297],"length":1,"stats":{"Line":4},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[4410357,4409093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[4410470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[4410544],"length":1,"stats":{"Line":6},"fn_name":"prefix_at"},{"line":214,"address":[4407467,4407440],"length":1,"stats":{"Line":24},"fn_name":"{{closure}}"},{"line":217,"address":[4412944],"length":1,"stats":{"Line":16},"fn_name":"len"},{"line":218,"address":[4412953],"length":1,"stats":{"Line":18},"fn_name":null},{"line":221,"address":[4412992],"length":1,"stats":{"Line":0},"fn_name":"as_bytes"},{"line":222,"address":[4412997],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[4413008],"length":1,"stats":{"Line":16},"fn_name":"new"},{"line":243,"address":[4413056],"length":1,"stats":{"Line":17},"fn_name":"deref"},{"line":244,"address":[4413061],"length":1,"stats":{"Line":17},"fn_name":null},{"line":249,"address":[4413072],"length":1,"stats":{"Line":17},"fn_name":"at"},{"line":250,"address":[4413257,4413100],"length":1,"stats":{"Line":31},"fn_name":null},{"line":251,"address":[4413171],"length":1,"stats":{"Line":14},"fn_name":null},{"line":255,"address":[4413143],"length":1,"stats":{"Line":17},"fn_name":null},{"line":256,"address":[4413264],"length":1,"stats":{"Line":17},"fn_name":null},{"line":262,"address":[4413392],"length":1,"stats":{"Line":7},"fn_name":"next_char"},{"line":263,"address":[4407600,4407613],"length":1,"stats":{"Line":21},"fn_name":"{{closure}}"},{"line":266,"address":[4413552],"length":1,"stats":{"Line":7},"fn_name":"previous_char"},{"line":267,"address":[4407632,4407645],"length":1,"stats":{"Line":15},"fn_name":"{{closure}}"},{"line":270,"address":[4413712],"length":1,"stats":{"Line":11},"fn_name":"is_empty_match"},{"line":272,"address":[4415709,4414277,4414582,4414822,4413865,4414184,4415304,4415704,4414344,4414010],"length":1,"stats":{"Line":30},"fn_name":null},{"line":273,"address":[4413735],"length":1,"stats":{"Line":10},"fn_name":null},{"line":274,"address":[4413875],"length":1,"stats":{"Line":2},"fn_name":null},{"line":275,"address":[4413946,4414023],"length":1,"stats":{"Line":4},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[4414052],"length":1,"stats":{"Line":2},"fn_name":null},{"line":279,"address":[4414123,4414197],"length":1,"stats":{"Line":4},"fn_name":null},{"line":281,"address":[4414245],"length":1,"stats":{"Line":8},"fn_name":null},{"line":282,"address":[4414290],"length":1,"stats":{"Line":6},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[4414357],"length":1,"stats":{"Line":2},"fn_name":null},{"line":285,"address":[4414535],"length":1,"stats":{"Line":2},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[4414595],"length":1,"stats":{"Line":3},"fn_name":null},{"line":289,"address":[4414773],"length":1,"stats":{"Line":3},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[4414835],"length":1,"stats":{"Line":2},"fn_name":null},{"line":293,"address":[4415021,4415247],"length":1,"stats":{"Line":4},"fn_name":null},{"line":296,"address":[4415043],"length":1,"stats":{"Line":2},"fn_name":null},{"line":297,"address":[4415172,4415142],"length":1,"stats":{"Line":4},"fn_name":null},{"line":299,"address":[4415174,4415131],"length":1,"stats":{"Line":2},"fn_name":null},{"line":300,"address":[4415249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[4415263],"length":1,"stats":{"Line":2},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[4415317,4413797],"length":1,"stats":{"Line":10},"fn_name":null},{"line":307,"address":[4415438,4415645],"length":1,"stats":{"Line":5},"fn_name":null},{"line":310,"address":[4415460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[4415559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[4415548,4415572],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[4415647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[4415661],"length":1,"stats":{"Line":5},"fn_name":null},{"line":322,"address":[4415712],"length":1,"stats":{"Line":4},"fn_name":"prefix_at"},{"line":327,"address":[4407664,4407691],"length":1,"stats":{"Line":16},"fn_name":"{{closure}}"},{"line":330,"address":[4418112],"length":1,"stats":{"Line":17},"fn_name":"len"},{"line":331,"address":[4418121],"length":1,"stats":{"Line":17},"fn_name":null},{"line":334,"address":[4418160],"length":1,"stats":{"Line":0},"fn_name":"as_bytes"},{"line":335,"address":[4418165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[4418176],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":352,"address":[4418199,4418387,4418479,4418313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[4418215,4418320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[4418394,4418243],"length":1,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[4418512],"length":1,"stats":{"Line":2},"fn_name":"is_none"},{"line":363,"address":[4418519],"length":1,"stats":{"Line":2},"fn_name":null},{"line":370,"address":[4418544],"length":1,"stats":{"Line":16},"fn_name":"len_utf8"},{"line":371,"address":[4407832,4407824],"length":1,"stats":{"Line":52},"fn_name":"{{closure}}"},{"line":377,"address":[4418592],"length":1,"stats":{"Line":8},"fn_name":"is_word_char"},{"line":382,"address":[4418600],"length":1,"stats":{"Line":8},"fn_name":null},{"line":388,"address":[4418640],"length":1,"stats":{"Line":7},"fn_name":"is_word_byte"},{"line":389,"address":[4418648,4418726,4418680],"length":1,"stats":{"Line":13},"fn_name":null},{"line":390,"address":[4418682,4418657],"length":1,"stats":{"Line":14},"fn_name":null},{"line":391,"address":[4418728],"length":1,"stats":{"Line":7},"fn_name":null},{"line":397,"address":[4418752],"length":1,"stats":{"Line":18},"fn_name":"from"},{"line":398,"address":[4418757],"length":1,"stats":{"Line":16},"fn_name":null},{"line":403,"address":[4418768],"length":1,"stats":{"Line":22},"fn_name":"from"},{"line":404,"address":[4407864,4407856],"length":1,"stats":{"Line":54},"fn_name":"{{closure}}"},{"line":410,"address":[4418816],"length":1,"stats":{"Line":6},"fn_name":"eq"},{"line":411,"address":[4418829],"length":1,"stats":{"Line":6},"fn_name":null},{"line":417,"address":[4418864],"length":1,"stats":{"Line":9},"fn_name":"eq"},{"line":418,"address":[4418877],"length":1,"stats":{"Line":9},"fn_name":null},{"line":424,"address":[4418896],"length":1,"stats":{"Line":15},"fn_name":"partial_cmp"},{"line":425,"address":[4418910],"length":1,"stats":{"Line":15},"fn_name":null},{"line":431,"address":[4418944],"length":1,"stats":{"Line":17},"fn_name":"partial_cmp"},{"line":432,"address":[4418958],"length":1,"stats":{"Line":13},"fn_name":null}],"covered":104,"coverable":149},{"path":["/","usr","src","regex","src","literal","imp.rs"],"content":"use std::cmp;\nuse std::mem;\n\nuse aho_corasick::{self, packed, AhoCorasick, AhoCorasickBuilder};\nuse memchr::{memchr, memchr2, memchr3};\nuse syntax::hir::literal::{Literal, Literals};\n\nuse freqs::BYTE_FREQUENCIES;\n\n/// A prefix extracted from a compiled regular expression.\n///\n/// A regex prefix is a set of literal strings that *must* be matched at the\n/// beginning of a regex in order for the entire regex to match. Similarly\n/// for a regex suffix.\n#[derive(Clone, Debug)]\npub struct LiteralSearcher {\n    complete: bool,\n    lcp: FreqyPacked,\n    lcs: FreqyPacked,\n    matcher: Matcher,\n}\n\n#[derive(Clone, Debug)]\nenum Matcher {\n    /// No literals. (Never advances through the input.)\n    Empty,\n    /// A set of four or more single byte literals.\n    Bytes(SingleByteSet),\n    /// A single substring, find using memchr and frequency analysis.\n    FreqyPacked(FreqyPacked),\n    /// A single substring, find using Boyer-Moore.\n    BoyerMoore(BoyerMooreSearch),\n    /// An Aho-Corasick automaton.\n    AC { ac: AhoCorasick<u32>, lits: Vec<Literal> },\n    /// A packed multiple substring searcher, using SIMD.\n    ///\n    /// Note that Aho-Corasick will actually use this packed searcher\n    /// internally automatically, however, there is some overhead associated\n    /// with going through the Aho-Corasick machinery. So using the packed\n    /// searcher directly results in some gains.\n    Packed { s: packed::Searcher, lits: Vec<Literal> },\n}\n\nimpl LiteralSearcher {\n    /// Returns a matcher that never matches and never advances the input.\n    pub fn empty() -> Self {\n        Self::new(Literals::empty(), Matcher::Empty)\n    }\n\n    /// Returns a matcher for literal prefixes from the given set.\n    pub fn prefixes(lits: Literals) -> Self {\n        let matcher = Matcher::prefixes(&lits);\n        Self::new(lits, matcher)\n    }\n\n    /// Returns a matcher for literal suffixes from the given set.\n    pub fn suffixes(lits: Literals) -> Self {\n        let matcher = Matcher::suffixes(&lits);\n        Self::new(lits, matcher)\n    }\n\n    fn new(lits: Literals, matcher: Matcher) -> Self {\n        let complete = lits.all_complete();\n        LiteralSearcher {\n            complete: complete,\n            lcp: FreqyPacked::new(lits.longest_common_prefix().to_vec()),\n            lcs: FreqyPacked::new(lits.longest_common_suffix().to_vec()),\n            matcher: matcher,\n        }\n    }\n\n    /// Returns true if all matches comprise the entire regular expression.\n    ///\n    /// This does not necessarily mean that a literal match implies a match\n    /// of the regular expression. For example, the regular expresison `^a`\n    /// is comprised of a single complete literal `a`, but the regular\n    /// expression demands that it only match at the beginning of a string.\n    pub fn complete(&self) -> bool {\n        self.complete && !self.is_empty()\n    }\n\n    /// Find the position of a literal in `haystack` if it exists.\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub fn find(&self, haystack: &[u8]) -> Option<(usize, usize)> {\n        use self::Matcher::*;\n        match self.matcher {\n            Empty => Some((0, 0)),\n            Bytes(ref sset) => sset.find(haystack).map(|i| (i, i + 1)),\n            FreqyPacked(ref s) => s.find(haystack).map(|i| (i, i + s.len())),\n            BoyerMoore(ref s) => s.find(haystack).map(|i| (i, i + s.len())),\n            AC { ref ac, .. } => {\n                ac.find(haystack).map(|m| (m.start(), m.end()))\n            }\n            Packed { ref s, .. } => {\n                s.find(haystack).map(|m| (m.start(), m.end()))\n            }\n        }\n    }\n\n    /// Like find, except matches must start at index `0`.\n    pub fn find_start(&self, haystack: &[u8]) -> Option<(usize, usize)> {\n        for lit in self.iter() {\n            if lit.len() > haystack.len() {\n                continue;\n            }\n            if lit == &haystack[0..lit.len()] {\n                return Some((0, lit.len()));\n            }\n        }\n        None\n    }\n\n    /// Like find, except matches must end at index `haystack.len()`.\n    pub fn find_end(&self, haystack: &[u8]) -> Option<(usize, usize)> {\n        for lit in self.iter() {\n            if lit.len() > haystack.len() {\n                continue;\n            }\n            if lit == &haystack[haystack.len() - lit.len()..] {\n                return Some((haystack.len() - lit.len(), haystack.len()));\n            }\n        }\n        None\n    }\n\n    /// Returns an iterator over all literals to be matched.\n    pub fn iter(&self) -> LiteralIter {\n        match self.matcher {\n            Matcher::Empty => LiteralIter::Empty,\n            Matcher::Bytes(ref sset) => LiteralIter::Bytes(&sset.dense),\n            Matcher::FreqyPacked(ref s) => LiteralIter::Single(&s.pat),\n            Matcher::BoyerMoore(ref s) => LiteralIter::Single(&s.pattern),\n            Matcher::AC { ref lits, .. } => LiteralIter::AC(lits),\n            Matcher::Packed { ref lits, .. } => LiteralIter::Packed(lits),\n        }\n    }\n\n    /// Returns a matcher for the longest common prefix of this matcher.\n    pub fn lcp(&self) -> &FreqyPacked {\n        &self.lcp\n    }\n\n    /// Returns a matcher for the longest common suffix of this matcher.\n    pub fn lcs(&self) -> &FreqyPacked {\n        &self.lcs\n    }\n\n    /// Returns true iff this prefix is empty.\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Returns the number of prefixes in this machine.\n    pub fn len(&self) -> usize {\n        use self::Matcher::*;\n        match self.matcher {\n            Empty => 0,\n            Bytes(ref sset) => sset.dense.len(),\n            FreqyPacked(_) => 1,\n            BoyerMoore(_) => 1,\n            AC { ref ac, .. } => ac.pattern_count(),\n            Packed { ref lits, .. } => lits.len(),\n        }\n    }\n\n    /// Return the approximate heap usage of literals in bytes.\n    pub fn approximate_size(&self) -> usize {\n        use self::Matcher::*;\n        match self.matcher {\n            Empty => 0,\n            Bytes(ref sset) => sset.approximate_size(),\n            FreqyPacked(ref single) => single.approximate_size(),\n            BoyerMoore(ref single) => single.approximate_size(),\n            AC { ref ac, .. } => ac.heap_bytes(),\n            Packed { ref s, .. } => s.heap_bytes(),\n        }\n    }\n}\n\nimpl Matcher {\n    fn prefixes(lits: &Literals) -> Self {\n        let sset = SingleByteSet::prefixes(lits);\n        Matcher::new(lits, sset)\n    }\n\n    fn suffixes(lits: &Literals) -> Self {\n        let sset = SingleByteSet::suffixes(lits);\n        Matcher::new(lits, sset)\n    }\n\n    fn new(lits: &Literals, sset: SingleByteSet) -> Self {\n        if lits.literals().is_empty() {\n            return Matcher::Empty;\n        }\n        if sset.dense.len() >= 26 {\n            // Avoid trying to match a large number of single bytes.\n            // This is *very* sensitive to a frequency analysis comparison\n            // between the bytes in sset and the composition of the haystack.\n            // No matter the size of sset, if its members all are rare in the\n            // haystack, then it'd be worth using it. How to tune this... IDK.\n            // ---AG\n            return Matcher::Empty;\n        }\n        if sset.complete {\n            return Matcher::Bytes(sset);\n        }\n        if lits.literals().len() == 1 {\n            let lit = lits.literals()[0].to_vec();\n            if BoyerMooreSearch::should_use(lit.as_slice()) {\n                return Matcher::BoyerMoore(BoyerMooreSearch::new(lit));\n            } else {\n                return Matcher::FreqyPacked(FreqyPacked::new(lit));\n            }\n        }\n\n        let pats = lits.literals().to_owned();\n        let is_aho_corasick_fast = sset.dense.len() <= 1 && sset.all_ascii;\n        if lits.literals().len() <= 100 && !is_aho_corasick_fast {\n            let mut builder = packed::Config::new()\n                .match_kind(packed::MatchKind::LeftmostFirst)\n                .builder();\n            if let Some(s) = builder.extend(&pats).build() {\n                return Matcher::Packed { s, lits: pats };\n            }\n        }\n        let ac = AhoCorasickBuilder::new()\n            .match_kind(aho_corasick::MatchKind::LeftmostFirst)\n            .dfa(true)\n            .build_with_size::<u32, _, _>(&pats)\n            .unwrap();\n        Matcher::AC { ac, lits: pats }\n    }\n}\n\npub enum LiteralIter<'a> {\n    Empty,\n    Bytes(&'a [u8]),\n    Single(&'a [u8]),\n    AC(&'a [Literal]),\n    Packed(&'a [Literal]),\n}\n\nimpl<'a> Iterator for LiteralIter<'a> {\n    type Item = &'a [u8];\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match *self {\n            LiteralIter::Empty => None,\n            LiteralIter::Bytes(ref mut many) => {\n                if many.is_empty() {\n                    None\n                } else {\n                    let next = &many[0..1];\n                    *many = &many[1..];\n                    Some(next)\n                }\n            }\n            LiteralIter::Single(ref mut one) => {\n                if one.is_empty() {\n                    None\n                } else {\n                    let next = &one[..];\n                    *one = &[];\n                    Some(next)\n                }\n            }\n            LiteralIter::AC(ref mut lits) => {\n                if lits.is_empty() {\n                    None\n                } else {\n                    let next = &lits[0];\n                    *lits = &lits[1..];\n                    Some(&**next)\n                }\n            }\n            LiteralIter::Packed(ref mut lits) => {\n                if lits.is_empty() {\n                    None\n                } else {\n                    let next = &lits[0];\n                    *lits = &lits[1..];\n                    Some(&**next)\n                }\n            }\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\nstruct SingleByteSet {\n    sparse: Vec<bool>,\n    dense: Vec<u8>,\n    complete: bool,\n    all_ascii: bool,\n}\n\nimpl SingleByteSet {\n    fn new() -> SingleByteSet {\n        SingleByteSet {\n            sparse: vec![false; 256],\n            dense: vec![],\n            complete: true,\n            all_ascii: true,\n        }\n    }\n\n    fn prefixes(lits: &Literals) -> SingleByteSet {\n        let mut sset = SingleByteSet::new();\n        for lit in lits.literals() {\n            sset.complete = sset.complete && lit.len() == 1;\n            if let Some(&b) = lit.get(0) {\n                if !sset.sparse[b as usize] {\n                    if b > 0x7F {\n                        sset.all_ascii = false;\n                    }\n                    sset.dense.push(b);\n                    sset.sparse[b as usize] = true;\n                }\n            }\n        }\n        sset\n    }\n\n    fn suffixes(lits: &Literals) -> SingleByteSet {\n        let mut sset = SingleByteSet::new();\n        for lit in lits.literals() {\n            sset.complete = sset.complete && lit.len() == 1;\n            if let Some(&b) = lit.get(lit.len().checked_sub(1).unwrap()) {\n                if !sset.sparse[b as usize] {\n                    if b > 0x7F {\n                        sset.all_ascii = false;\n                    }\n                    sset.dense.push(b);\n                    sset.sparse[b as usize] = true;\n                }\n            }\n        }\n        sset\n    }\n\n    /// Faster find that special cases certain sizes to use memchr.\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn find(&self, text: &[u8]) -> Option<usize> {\n        match self.dense.len() {\n            0 => None,\n            1 => memchr(self.dense[0], text),\n            2 => memchr2(self.dense[0], self.dense[1], text),\n            3 => memchr3(self.dense[0], self.dense[1], self.dense[2], text),\n            _ => self._find(text),\n        }\n    }\n\n    /// Generic find that works on any sized set.\n    fn _find(&self, haystack: &[u8]) -> Option<usize> {\n        for (i, &b) in haystack.iter().enumerate() {\n            if self.sparse[b as usize] {\n                return Some(i);\n            }\n        }\n        None\n    }\n\n    fn approximate_size(&self) -> usize {\n        (self.dense.len() * mem::size_of::<u8>())\n            + (self.sparse.len() * mem::size_of::<bool>())\n    }\n}\n\n/// Provides an implementation of fast subtring search using frequency\n/// analysis.\n///\n/// memchr is so fast that we do everything we can to keep the loop in memchr\n/// for as long as possible. The easiest way to do this is to intelligently\n/// pick the byte to send to memchr. The best byte is the byte that occurs\n/// least frequently in the haystack. Since doing frequency analysis on the\n/// haystack is far too expensive, we compute a set of fixed frequencies up\n/// front and hard code them in src/freqs.rs. Frequency analysis is done via\n/// scripts/frequencies.py.\n#[derive(Clone, Debug)]\npub struct FreqyPacked {\n    /// The pattern.\n    pat: Vec<u8>,\n    /// The number of Unicode characters in the pattern. This is useful for\n    /// determining the effective length of a pattern when deciding which\n    /// optimizations to perform. A trailing incomplete UTF-8 sequence counts\n    /// as one character.\n    char_len: usize,\n    /// The rarest byte in the pattern, according to pre-computed frequency\n    /// analysis.\n    rare1: u8,\n    /// The offset of the rarest byte in `pat`.\n    rare1i: usize,\n    /// The second rarest byte in the pattern, according to pre-computed\n    /// frequency analysis. (This may be equivalent to the rarest byte.)\n    ///\n    /// The second rarest byte is used as a type of guard for quickly detecting\n    /// a mismatch after memchr locates an instance of the rarest byte. This\n    /// is a hedge against pathological cases where the pre-computed frequency\n    /// analysis may be off. (But of course, does not prevent *all*\n    /// pathological cases.)\n    rare2: u8,\n    /// The offset of the second rarest byte in `pat`.\n    rare2i: usize,\n}\n\nimpl FreqyPacked {\n    fn new(pat: Vec<u8>) -> FreqyPacked {\n        if pat.is_empty() {\n            return FreqyPacked::empty();\n        }\n\n        // Find the rarest two bytes. Try to make them distinct (but it's not\n        // required).\n        let mut rare1 = pat[0];\n        let mut rare2 = pat[0];\n        for b in pat[1..].iter().cloned() {\n            if freq_rank(b) < freq_rank(rare1) {\n                rare1 = b;\n            }\n        }\n        for &b in &pat {\n            if rare1 == rare2 {\n                rare2 = b\n            } else if b != rare1 && freq_rank(b) < freq_rank(rare2) {\n                rare2 = b;\n            }\n        }\n\n        // And find the offsets of their last occurrences.\n        let rare1i = pat.iter().rposition(|&b| b == rare1).unwrap();\n        let rare2i = pat.iter().rposition(|&b| b == rare2).unwrap();\n\n        let char_len = char_len_lossy(&pat);\n        FreqyPacked {\n            pat: pat,\n            char_len: char_len,\n            rare1: rare1,\n            rare1i: rare1i,\n            rare2: rare2,\n            rare2i: rare2i,\n        }\n    }\n\n    fn empty() -> FreqyPacked {\n        FreqyPacked {\n            pat: vec![],\n            char_len: 0,\n            rare1: 0,\n            rare1i: 0,\n            rare2: 0,\n            rare2i: 0,\n        }\n    }\n\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub fn find(&self, haystack: &[u8]) -> Option<usize> {\n        let pat = &*self.pat;\n        if haystack.len() < pat.len() || pat.is_empty() {\n            return None;\n        }\n        let mut i = self.rare1i;\n        while i < haystack.len() {\n            i += match memchr(self.rare1, &haystack[i..]) {\n                None => return None,\n                Some(i) => i,\n            };\n            let start = i - self.rare1i;\n            let end = start + pat.len();\n            if end > haystack.len() {\n                return None;\n            }\n            let aligned = &haystack[start..end];\n            if aligned[self.rare2i] == self.rare2 && aligned == &*self.pat {\n                return Some(start);\n            }\n            i += 1;\n        }\n        None\n    }\n\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub fn is_suffix(&self, text: &[u8]) -> bool {\n        if text.len() < self.len() {\n            return false;\n        }\n        text[text.len() - self.len()..] == *self.pat\n    }\n\n    pub fn len(&self) -> usize {\n        self.pat.len()\n    }\n\n    pub fn char_len(&self) -> usize {\n        self.char_len\n    }\n\n    fn approximate_size(&self) -> usize {\n        self.pat.len() * mem::size_of::<u8>()\n    }\n}\n\nfn char_len_lossy(bytes: &[u8]) -> usize {\n    String::from_utf8_lossy(bytes).chars().count()\n}\n\n/// An implementation of Tuned Boyer-Moore as laid out by\n/// Andrew Hume and Daniel Sunday in \"Fast String Searching\".\n/// O(n) in the size of the input.\n///\n/// Fast string searching algorithms come in many variations,\n/// but they can generally be described in terms of three main\n/// components.\n///\n/// The skip loop is where the string searcher wants to spend\n/// as much time as possible. Exactly which character in the\n/// pattern the skip loop examines varies from algorithm to\n/// algorithm, but in the simplest case this loop repeated\n/// looks at the last character in the pattern and jumps\n/// forward in the input if it is not in the pattern.\n/// Robert Boyer and J Moore called this the \"fast\" loop in\n/// their original paper.\n///\n/// The match loop is responsible for actually examining the\n/// whole potentially matching substring. In order to fail\n/// faster, the match loop sometimes has a guard test attached.\n/// The guard test uses frequency analysis of the different\n/// characters in the pattern to choose the least frequency\n/// occurring character and use it to find match failures\n/// as quickly as possible.\n///\n/// The shift rule governs how the algorithm will shuffle its\n/// test window in the event of a failure during the match loop.\n/// Certain shift rules allow the worst-case run time of the\n/// algorithm to be shown to be O(n) in the size of the input\n/// rather than O(nm) in the size of the input and the size\n/// of the pattern (as naive Boyer-Moore is).\n///\n/// \"Fast String Searching\", in addition to presenting a tuned\n/// algorithm, provides a comprehensive taxonomy of the many\n/// different flavors of string searchers. Under that taxonomy\n/// TBM, the algorithm implemented here, uses an unrolled fast\n/// skip loop with memchr fallback, a forward match loop with guard,\n/// and the mini Sunday's delta shift rule. To unpack that you'll have to\n/// read the paper.\n#[derive(Clone, Debug)]\npub struct BoyerMooreSearch {\n    /// The pattern we are going to look for in the haystack.\n    pattern: Vec<u8>,\n\n    /// The skip table for the skip loop.\n    ///\n    /// Maps the character at the end of the input\n    /// to a shift.\n    skip_table: Vec<usize>,\n\n    /// The guard character (least frequently occurring char).\n    guard: u8,\n    /// The reverse-index of the guard character in the pattern.\n    guard_reverse_idx: usize,\n\n    /// Daniel Sunday's mini generalized delta2 shift table.\n    ///\n    /// We use a skip loop, so we only have to provide a shift\n    /// for the skip char (last char). This is why it is a mini\n    /// shift rule.\n    md2_shift: usize,\n}\n\nimpl BoyerMooreSearch {\n    /// Create a new string searcher, performing whatever\n    /// compilation steps are required.\n    fn new(pattern: Vec<u8>) -> Self {\n        debug_assert!(!pattern.is_empty());\n\n        let (g, gi) = Self::select_guard(pattern.as_slice());\n        let skip_table = Self::compile_skip_table(pattern.as_slice());\n        let md2_shift = Self::compile_md2_shift(pattern.as_slice());\n        BoyerMooreSearch {\n            pattern: pattern,\n            skip_table: skip_table,\n            guard: g,\n            guard_reverse_idx: gi,\n            md2_shift: md2_shift,\n        }\n    }\n\n    /// Find the pattern in `haystack`, returning the offset\n    /// of the start of the first occurrence of the pattern\n    /// in `haystack`.\n    #[inline]\n    fn find(&self, haystack: &[u8]) -> Option<usize> {\n        if haystack.len() < self.pattern.len() {\n            return None;\n        }\n\n        let mut window_end = self.pattern.len() - 1;\n\n        // Inspired by the grep source. It is a way\n        // to do correct loop unrolling without having to place\n        // a crashpad of terminating charicters at the end in\n        // the way described in the Fast String Searching paper.\n        const NUM_UNROLL: usize = 10;\n        // 1 for the initial position, and 1 for the md2 shift\n        let short_circut = (NUM_UNROLL + 2) * self.pattern.len();\n\n        if haystack.len() > short_circut {\n            // just 1 for the md2 shift\n            let backstop =\n                haystack.len() - ((NUM_UNROLL + 1) * self.pattern.len());\n            loop {\n                window_end =\n                    match self.skip_loop(haystack, window_end, backstop) {\n                        Some(i) => i,\n                        None => return None,\n                    };\n                if window_end >= backstop {\n                    break;\n                }\n\n                if self.check_match(haystack, window_end) {\n                    return Some(window_end - (self.pattern.len() - 1));\n                } else {\n                    let skip = self.skip_table[haystack[window_end] as usize];\n                    window_end +=\n                        if skip == 0 { self.md2_shift } else { skip };\n                    continue;\n                }\n            }\n        }\n\n        // now process the input after the backstop\n        while window_end < haystack.len() {\n            let mut skip = self.skip_table[haystack[window_end] as usize];\n            if skip == 0 {\n                if self.check_match(haystack, window_end) {\n                    return Some(window_end - (self.pattern.len() - 1));\n                } else {\n                    skip = self.md2_shift;\n                }\n            }\n            window_end += skip;\n        }\n\n        None\n    }\n\n    fn len(&self) -> usize {\n        return self.pattern.len();\n    }\n\n    /// The key heuristic behind which the BoyerMooreSearch lives.\n    ///\n    /// See `rust-lang/regex/issues/408`.\n    ///\n    /// Tuned Boyer-Moore is actually pretty slow! It turns out a handrolled\n    /// platform-specific memchr routine with a bit of frequency\n    /// analysis sprinkled on top actually wins most of the time.\n    /// However, there are a few cases where Tuned Boyer-Moore still\n    /// wins.\n    ///\n    /// If the haystack is random, frequency analysis doesn't help us,\n    /// so Boyer-Moore will win for sufficiently large needles.\n    /// Unfortunately, there is no obvious way to determine this\n    /// ahead of time.\n    ///\n    /// If the pattern itself consists of very common characters,\n    /// frequency analysis won't get us anywhere. The most extreme\n    /// example of this is a pattern like `eeeeeeeeeeeeeeee`. Fortunately,\n    /// this case is wholly determined by the pattern, so we can actually\n    /// implement the heuristic.\n    ///\n    /// A third case is if the pattern is sufficiently long. The idea\n    /// here is that once the pattern gets long enough the Tuned\n    /// Boyer-Moore skip loop will start making strides long enough\n    /// to beat the asm deep magic that is memchr.\n    fn should_use(pattern: &[u8]) -> bool {\n        // The minimum pattern length required to use TBM.\n        const MIN_LEN: usize = 9;\n        // The minimum frequency rank (lower is rarer) that every byte in the\n        // pattern must have in order to use TBM. That is, if the pattern\n        // contains _any_ byte with a lower rank, then TBM won't be used.\n        const MIN_CUTOFF: usize = 150;\n        // The maximum frequency rank for any byte.\n        const MAX_CUTOFF: usize = 255;\n        // The scaling factor used to determine the actual cutoff frequency\n        // to use (keeping in mind that the minimum frequency rank is bounded\n        // by MIN_CUTOFF). This scaling factor is an attempt to make TBM more\n        // likely to be used as the pattern grows longer. That is, longer\n        // patterns permit somewhat less frequent bytes than shorter patterns,\n        // under the assumption that TBM gets better as the pattern gets\n        // longer.\n        const LEN_CUTOFF_PROPORTION: usize = 4;\n\n        let scaled_rank = pattern.len().wrapping_mul(LEN_CUTOFF_PROPORTION);\n        let cutoff = cmp::max(\n            MIN_CUTOFF,\n            MAX_CUTOFF - cmp::min(MAX_CUTOFF, scaled_rank),\n        );\n        // The pattern must be long enough to be worthwhile. e.g., memchr will\n        // be faster on `e` because it is short even though e is quite common.\n        pattern.len() > MIN_LEN\n            // all the bytes must be more common than the cutoff.\n            && pattern.iter().all(|c| freq_rank(*c) >= cutoff)\n    }\n\n    /// Check to see if there is a match at the given position\n    #[inline]\n    fn check_match(&self, haystack: &[u8], window_end: usize) -> bool {\n        // guard test\n        if haystack[window_end - self.guard_reverse_idx] != self.guard {\n            return false;\n        }\n\n        // match loop\n        let window_start = window_end - (self.pattern.len() - 1);\n        for i in 0..self.pattern.len() {\n            if self.pattern[i] != haystack[window_start + i] {\n                return false;\n            }\n        }\n\n        true\n    }\n\n    /// Skip forward according to the shift table.\n    ///\n    /// Returns the offset of the next occurrence\n    /// of the last char in the pattern, or the none\n    /// if it never reappears. If `skip_loop` hits the backstop\n    /// it will leave early.\n    #[inline]\n    fn skip_loop(\n        &self,\n        haystack: &[u8],\n        mut window_end: usize,\n        backstop: usize,\n    ) -> Option<usize> {\n        let window_end_snapshot = window_end;\n        let skip_of = |we: usize| -> usize {\n            // Unsafe might make this faster, but the benchmarks\n            // were hard to interpret.\n            self.skip_table[haystack[we] as usize]\n        };\n\n        loop {\n            let mut skip = skip_of(window_end);\n            window_end += skip;\n            skip = skip_of(window_end);\n            window_end += skip;\n            if skip != 0 {\n                skip = skip_of(window_end);\n                window_end += skip;\n                skip = skip_of(window_end);\n                window_end += skip;\n                skip = skip_of(window_end);\n                window_end += skip;\n                if skip != 0 {\n                    skip = skip_of(window_end);\n                    window_end += skip;\n                    skip = skip_of(window_end);\n                    window_end += skip;\n                    skip = skip_of(window_end);\n                    window_end += skip;\n                    if skip != 0 {\n                        skip = skip_of(window_end);\n                        window_end += skip;\n                        skip = skip_of(window_end);\n                        window_end += skip;\n\n                        // If ten iterations did not make at least 16 words\n                        // worth of progress, we just fall back on memchr.\n                        if window_end - window_end_snapshot\n                            > 16 * mem::size_of::<usize>()\n                        {\n                            // Returning a window_end >= backstop will\n                            // immediatly break us out of the inner loop in\n                            // `find`.\n                            if window_end >= backstop {\n                                return Some(window_end);\n                            }\n\n                            continue; // we made enough progress\n                        } else {\n                            // In case we are already there, and so that\n                            // we will catch the guard char.\n                            window_end = window_end\n                                .checked_sub(1 + self.guard_reverse_idx)\n                                .unwrap_or(0);\n\n                            match memchr(self.guard, &haystack[window_end..]) {\n                                None => return None,\n                                Some(g_idx) => {\n                                    return Some(\n                                        window_end\n                                            + g_idx\n                                            + self.guard_reverse_idx,\n                                    );\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            return Some(window_end);\n        }\n    }\n\n    /// Compute the ufast skip table.\n    fn compile_skip_table(pattern: &[u8]) -> Vec<usize> {\n        let mut tab = vec![pattern.len(); 256];\n\n        // For every char in the pattern, we write a skip\n        // that will line us up with the rightmost occurrence.\n        //\n        // N.B. the sentinel (0) is written by the last\n        // loop iteration.\n        for (i, c) in pattern.iter().enumerate() {\n            tab[*c as usize] = (pattern.len() - 1) - i;\n        }\n\n        tab\n    }\n\n    /// Select the guard character based off of the precomputed\n    /// frequency table.\n    fn select_guard(pattern: &[u8]) -> (u8, usize) {\n        let mut rarest = pattern[0];\n        let mut rarest_rev_idx = pattern.len() - 1;\n        for (i, c) in pattern.iter().enumerate() {\n            if freq_rank(*c) < freq_rank(rarest) {\n                rarest = *c;\n                rarest_rev_idx = (pattern.len() - 1) - i;\n            }\n        }\n\n        (rarest, rarest_rev_idx)\n    }\n\n    /// If there is another occurrence of the skip\n    /// char, shift to it, otherwise just shift to\n    /// the next window.\n    fn compile_md2_shift(pattern: &[u8]) -> usize {\n        let shiftc = *pattern.last().unwrap();\n\n        // For a pattern of length 1 we will never apply the\n        // shift rule, so we use a poison value on the principle\n        // that failing fast is a good thing.\n        if pattern.len() == 1 {\n            return 0xDEADBEAF;\n        }\n\n        let mut i = pattern.len() - 2;\n        while i > 0 {\n            if pattern[i] == shiftc {\n                return (pattern.len() - 1) - i;\n            }\n            i -= 1;\n        }\n\n        // The skip char never re-occurs in the pattern, so\n        // we can just shift the whole window length.\n        pattern.len() - 1\n    }\n\n    fn approximate_size(&self) -> usize {\n        (self.pattern.len() * mem::size_of::<u8>())\n            + (256 * mem::size_of::<usize>()) // skip table\n    }\n}\n\nfn freq_rank(b: u8) -> usize {\n    BYTE_FREQUENCIES[b as usize] as usize\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{BoyerMooreSearch, FreqyPacked};\n\n    //\n    // Unit Tests\n    //\n\n    // The \"hello, world\" of string searching\n    #[test]\n    fn bm_find_subs() {\n        let searcher = BoyerMooreSearch::new(Vec::from(&b\"pattern\"[..]));\n        let haystack = b\"I keep seeing patterns in this text\";\n        assert_eq!(14, searcher.find(haystack).unwrap());\n    }\n\n    #[test]\n    fn bm_find_no_subs() {\n        let searcher = BoyerMooreSearch::new(Vec::from(&b\"pattern\"[..]));\n        let haystack = b\"I keep seeing needles in this text\";\n        assert_eq!(None, searcher.find(haystack));\n    }\n\n    //\n    // Regression Tests\n    //\n\n    #[test]\n    fn bm_skip_reset_bug() {\n        let haystack = vec![0, 0, 0, 0, 0, 1, 1, 0];\n        let needle = vec![0, 1, 1, 0];\n\n        let searcher = BoyerMooreSearch::new(needle);\n        let offset = searcher.find(haystack.as_slice()).unwrap();\n        assert_eq!(4, offset);\n    }\n\n    #[test]\n    fn bm_backstop_underflow_bug() {\n        let haystack = vec![0, 0];\n        let needle = vec![0, 0];\n\n        let searcher = BoyerMooreSearch::new(needle);\n        let offset = searcher.find(haystack.as_slice()).unwrap();\n        assert_eq!(0, offset);\n    }\n\n    #[test]\n    fn bm_naive_off_by_one_bug() {\n        let haystack = vec![91];\n        let needle = vec![91];\n\n        let naive_offset = naive_find(&needle, &haystack).unwrap();\n        assert_eq!(0, naive_offset);\n    }\n\n    #[test]\n    fn bm_memchr_fallback_indexing_bug() {\n        let mut haystack = vec![\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let needle = vec![1, 1, 1, 1, 32, 32, 87];\n        let needle_start = haystack.len();\n        haystack.extend(needle.clone());\n\n        let searcher = BoyerMooreSearch::new(needle);\n        assert_eq!(needle_start, searcher.find(haystack.as_slice()).unwrap());\n    }\n\n    #[test]\n    fn bm_backstop_boundary() {\n        let haystack = b\"\\\n// aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\ne_data.clone_created(entity_id, entity_to_add.entity_id);\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\"\n        .to_vec();\n        let needle = b\"clone_created\".to_vec();\n\n        let searcher = BoyerMooreSearch::new(needle);\n        let result = searcher.find(&haystack);\n        assert_eq!(Some(43), result);\n    }\n\n    #[test]\n    fn bm_win_gnu_indexing_bug() {\n        let haystack_raw = vec![\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let needle = vec![1, 1, 1, 1, 1, 1, 1];\n        let haystack = haystack_raw.as_slice();\n\n        BoyerMooreSearch::new(needle.clone()).find(haystack);\n    }\n\n    //\n    // QuickCheck Properties\n    //\n\n    use quickcheck::TestResult;\n\n    fn naive_find(needle: &[u8], haystack: &[u8]) -> Option<usize> {\n        assert!(needle.len() <= haystack.len());\n\n        for i in 0..(haystack.len() - (needle.len() - 1)) {\n            if haystack[i] == needle[0]\n                && &haystack[i..(i + needle.len())] == needle\n            {\n                return Some(i);\n            }\n        }\n\n        None\n    }\n\n    quickcheck! {\n        fn qc_bm_equals_nieve_find(pile1: Vec<u8>, pile2: Vec<u8>) -> TestResult {\n            if pile1.len() == 0 || pile2.len() == 0 {\n                return TestResult::discard();\n            }\n\n            let (needle, haystack) = if pile1.len() < pile2.len() {\n                (pile1, pile2.as_slice())\n            } else {\n                (pile2, pile1.as_slice())\n            };\n\n            let searcher = BoyerMooreSearch::new(needle.clone());\n            TestResult::from_bool(\n                searcher.find(haystack) == naive_find(&needle, haystack))\n        }\n\n        fn qc_bm_equals_single(pile1: Vec<u8>, pile2: Vec<u8>) -> TestResult {\n            if pile1.len() == 0 || pile2.len() == 0 {\n                return TestResult::discard();\n            }\n\n            let (needle, haystack) = if pile1.len() < pile2.len() {\n                (pile1, pile2.as_slice())\n            } else {\n                (pile2, pile1.as_slice())\n            };\n\n            let bm_searcher = BoyerMooreSearch::new(needle.clone());\n            let freqy_memchr = FreqyPacked::new(needle);\n            TestResult::from_bool(\n                bm_searcher.find(haystack) == freqy_memchr.find(haystack))\n        }\n\n        fn qc_bm_finds_trailing_needle(\n            haystack_pre: Vec<u8>,\n            needle: Vec<u8>\n        ) -> TestResult {\n            if needle.len() == 0 {\n                return TestResult::discard();\n            }\n\n            let mut haystack = haystack_pre.clone();\n            let searcher = BoyerMooreSearch::new(needle.clone());\n\n            if haystack.len() >= needle.len() &&\n                searcher.find(haystack.as_slice()).is_some() {\n                return TestResult::discard();\n            }\n\n            haystack.extend(needle.clone());\n\n            // What if the the tail of the haystack can start the\n            // needle?\n            let start = haystack_pre.len()\n                .checked_sub(needle.len())\n                .unwrap_or(0);\n            for i in 0..(needle.len() - 1) {\n                if searcher.find(&haystack[(i + start)..]).is_some() {\n                    return TestResult::discard();\n                }\n            }\n\n            TestResult::from_bool(\n                searcher.find(haystack.as_slice())\n                        .map(|x| x == haystack_pre.len())\n                        .unwrap_or(false))\n        }\n\n        // qc_equals_* is only testing the negative case as @burntsushi\n        // pointed out in https://github.com/rust-lang/regex/issues/446.\n        // This quickcheck prop represents an effort to force testing of\n        // the positive case. qc_bm_finds_first and qc_bm_finds_trailing_needle\n        // already check some of the positive cases, but they don't cover\n        // cases where the needle is in the middle of haystack. This prop\n        // fills that hole.\n        fn qc_bm_finds_subslice(\n            haystack: Vec<u8>,\n            needle_start: usize,\n            needle_length: usize\n        ) -> TestResult {\n            if haystack.len() == 0 {\n                return TestResult::discard();\n            }\n\n            let needle_start = needle_start % haystack.len();\n            let needle_length = needle_length % (haystack.len() - needle_start);\n\n            if needle_length == 0 {\n                return TestResult::discard();\n            }\n\n            let needle = &haystack[needle_start..(needle_start + needle_length)];\n\n            let bm_searcher = BoyerMooreSearch::new(needle.to_vec());\n\n            let start = naive_find(&needle, &haystack);\n            match start {\n                None => TestResult::from_bool(false),\n                Some(nf_start) =>\n                    TestResult::from_bool(\n                        nf_start <= needle_start\n                            && bm_searcher.find(&haystack) == start\n                    )\n            }\n        }\n\n        fn qc_bm_finds_first(needle: Vec<u8>) -> TestResult {\n            if needle.len() == 0 {\n                return TestResult::discard();\n            }\n\n            let mut haystack = needle.clone();\n            let searcher = BoyerMooreSearch::new(needle.clone());\n            haystack.extend(needle);\n\n            TestResult::from_bool(\n                searcher.find(haystack.as_slice())\n                        .map(|x| x == 0)\n                        .unwrap_or(false))\n        }\n    }\n}\n","traces":[{"line":46,"address":[5569728],"length":1,"stats":{"Line":27},"fn_name":"empty"},{"line":47,"address":[5569746],"length":1,"stats":{"Line":27},"fn_name":null},{"line":51,"address":[5569888,5569824],"length":1,"stats":{"Line":16},"fn_name":"prefixes"},{"line":52,"address":[5569842],"length":1,"stats":{"Line":20},"fn_name":null},{"line":53,"address":[5569903],"length":1,"stats":{"Line":25},"fn_name":null},{"line":57,"address":[5570096,5570160],"length":1,"stats":{"Line":25},"fn_name":"suffixes"},{"line":58,"address":[5570114],"length":1,"stats":{"Line":25},"fn_name":null},{"line":59,"address":[5570175],"length":1,"stats":{"Line":25},"fn_name":null},{"line":62,"address":[5570424,5570368],"length":1,"stats":{"Line":27},"fn_name":"new"},{"line":63,"address":[5570386,5570443],"length":1,"stats":{"Line":54},"fn_name":null},{"line":66,"address":[5570452,5570503],"length":1,"stats":{"Line":54},"fn_name":null},{"line":67,"address":[5570552,5570590],"length":1,"stats":{"Line":54},"fn_name":null},{"line":78,"address":[5570864],"length":1,"stats":{"Line":13},"fn_name":"complete"},{"line":79,"address":[5570937,5570873],"length":1,"stats":{"Line":17},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[4421738,4422395,4421813,4423696,4423792],"length":1,"stats":{"Line":69},"fn_name":null},{"line":87,"address":[4421745,4421612],"length":1,"stats":{"Line":25},"fn_name":null},{"line":88,"address":[4421826,4422382],"length":1,"stats":{"Line":64},"fn_name":null},{"line":89,"address":[4422408,4423659],"length":1,"stats":{"Line":58},"fn_name":null},{"line":90,"address":[4423709],"length":1,"stats":{"Line":18},"fn_name":null},{"line":91,"address":[4423802],"length":1,"stats":{"Line":23},"fn_name":null},{"line":92,"address":[4423816],"length":1,"stats":{"Line":54},"fn_name":null},{"line":94,"address":[4410808,4415976],"length":1,"stats":{"Line":18},"fn_name":null},{"line":95,"address":[4415990,4410822],"length":1,"stats":{"Line":34},"fn_name":null},{"line":101,"address":[5570960],"length":1,"stats":{"Line":4},"fn_name":"find_start"},{"line":102,"address":[5571444,5570994,5571152],"length":1,"stats":{"Line":5},"fn_name":null},{"line":103,"address":[5571218],"length":1,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[5571310],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[5571281,5571315],"length":1,"stats":{"Line":8},"fn_name":null},{"line":107,"address":[5571449,5571490],"length":1,"stats":{"Line":8},"fn_name":null},{"line":110,"address":[5571140],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[5571552],"length":1,"stats":{"Line":2},"fn_name":"find_end"},{"line":115,"address":[5571586,5571762,5572085],"length":1,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[5571828],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[5571914],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[5571919,5571901,5572265],"length":1,"stats":{"Line":4},"fn_name":null},{"line":120,"address":[5572325,5572295,5572100,5572126],"length":1,"stats":{"Line":4},"fn_name":null},{"line":123,"address":[5571750],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[5572336],"length":1,"stats":{"Line":4},"fn_name":"iter"},{"line":128,"address":[5572452,5572604,5572677,5572747,5572438,5572531],"length":1,"stats":{"Line":8},"fn_name":null},{"line":129,"address":[5572445,5572351],"length":1,"stats":{"Line":4},"fn_name":null},{"line":130,"address":[5572462],"length":1,"stats":{"Line":4},"fn_name":null},{"line":131,"address":[5572541],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[5572614],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[5572684],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[5572400,5572759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[5572800],"length":1,"stats":{"Line":2},"fn_name":"lcp"},{"line":140,"address":[5572805],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[5572832],"length":1,"stats":{"Line":8},"fn_name":"lcs"},{"line":145,"address":[5572837],"length":1,"stats":{"Line":8},"fn_name":null},{"line":149,"address":[5572864],"length":1,"stats":{"Line":18},"fn_name":"is_empty"},{"line":150,"address":[5572873],"length":1,"stats":{"Line":18},"fn_name":null},{"line":154,"address":[5572912],"length":1,"stats":{"Line":18},"fn_name":"len"},{"line":156,"address":[5573034,5573045,5573087,5572985,5573056,5572996],"length":1,"stats":{"Line":57},"fn_name":null},{"line":157,"address":[5572987,5572921],"length":1,"stats":{"Line":31},"fn_name":null},{"line":158,"address":[5573003],"length":1,"stats":{"Line":10},"fn_name":null},{"line":159,"address":[5573036],"length":1,"stats":{"Line":8},"fn_name":null},{"line":160,"address":[5573047],"length":1,"stats":{"Line":8},"fn_name":null},{"line":161,"address":[5573063],"length":1,"stats":{"Line":12},"fn_name":null},{"line":162,"address":[5572958],"length":1,"stats":{"Line":9},"fn_name":null},{"line":167,"address":[5573104],"length":1,"stats":{"Line":8},"fn_name":"approximate_size"},{"line":169,"address":[5573191,5573222,5573315,5573180,5573284,5573253],"length":1,"stats":{"Line":14},"fn_name":null},{"line":170,"address":[5573113,5573182],"length":1,"stats":{"Line":16},"fn_name":null},{"line":171,"address":[5573198],"length":1,"stats":{"Line":2},"fn_name":null},{"line":172,"address":[5573229],"length":1,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[5573260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[5573291],"length":1,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[5573150],"length":1,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[5573344],"length":1,"stats":{"Line":16},"fn_name":"prefixes"},{"line":182,"address":[5573362],"length":1,"stats":{"Line":21},"fn_name":null},{"line":183,"address":[5573390],"length":1,"stats":{"Line":25},"fn_name":null},{"line":186,"address":[5573456],"length":1,"stats":{"Line":25},"fn_name":"suffixes"},{"line":187,"address":[5573474],"length":1,"stats":{"Line":25},"fn_name":null},{"line":188,"address":[5573502],"length":1,"stats":{"Line":25},"fn_name":null},{"line":191,"address":[5573696,5573568],"length":1,"stats":{"Line":25},"fn_name":"new"},{"line":192,"address":[5573594,5573771,5573727],"length":1,"stats":{"Line":75},"fn_name":null},{"line":193,"address":[5573819],"length":1,"stats":{"Line":23},"fn_name":null},{"line":195,"address":[5573852,5573785],"length":1,"stats":{"Line":22},"fn_name":null},{"line":202,"address":[5573882],"length":1,"stats":{"Line":8},"fn_name":null},{"line":204,"address":[5573866],"length":1,"stats":{"Line":11},"fn_name":null},{"line":205,"address":[5573929],"length":1,"stats":{"Line":11},"fn_name":null},{"line":207,"address":[5574052,5573894],"length":1,"stats":{"Line":16},"fn_name":null},{"line":208,"address":[5576005,5574139],"length":1,"stats":{"Line":8},"fn_name":null},{"line":209,"address":[5574317],"length":1,"stats":{"Line":8},"fn_name":null},{"line":210,"address":[5574573,5574449],"length":1,"stats":{"Line":17},"fn_name":null},{"line":212,"address":[5574383,5574586],"length":1,"stats":{"Line":16},"fn_name":null},{"line":216,"address":[5574101,5574657],"length":1,"stats":{"Line":16},"fn_name":null},{"line":217,"address":[5574782,5574680],"length":1,"stats":{"Line":16},"fn_name":null},{"line":218,"address":[5574742,5574790],"length":1,"stats":{"Line":16},"fn_name":null},{"line":219,"address":[5574930,5574882],"length":1,"stats":{"Line":16},"fn_name":null},{"line":220,"address":[5574922],"length":1,"stats":{"Line":8},"fn_name":null},{"line":222,"address":[5575061,5575002,5575119],"length":1,"stats":{"Line":24},"fn_name":null},{"line":223,"address":[5575192],"length":1,"stats":{"Line":8},"fn_name":null},{"line":226,"address":[5575442,5575415],"length":1,"stats":{"Line":20},"fn_name":null},{"line":227,"address":[5575434],"length":1,"stats":{"Line":11},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[5576128],"length":1,"stats":{"Line":4},"fn_name":"next"},{"line":247,"address":[5577073,5576263,5577302,5576249,5576588,5576792],"length":1,"stats":{"Line":7},"fn_name":null},{"line":248,"address":[5576251,5576143],"length":1,"stats":{"Line":4},"fn_name":null},{"line":249,"address":[5576276],"length":1,"stats":{"Line":4},"fn_name":null},{"line":250,"address":[5576431,5576298],"length":1,"stats":{"Line":6},"fn_name":null},{"line":251,"address":[5576419],"length":1,"stats":{"Line":2},"fn_name":null},{"line":253,"address":[5576348,5576444],"length":1,"stats":{"Line":8},"fn_name":null},{"line":254,"address":[5576476],"length":1,"stats":{"Line":4},"fn_name":null},{"line":255,"address":[5576564],"length":1,"stats":{"Line":4},"fn_name":null},{"line":258,"address":[5576601],"length":1,"stats":{"Line":2},"fn_name":null},{"line":259,"address":[5576716,5576623],"length":1,"stats":{"Line":3},"fn_name":null},{"line":260,"address":[5576704],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[5576726,5576673],"length":1,"stats":{"Line":6},"fn_name":null},{"line":263,"address":[5576750],"length":1,"stats":{"Line":3},"fn_name":null},{"line":264,"address":[5576776],"length":1,"stats":{"Line":3},"fn_name":null},{"line":267,"address":[5576805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[5576827,5576913],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[5576901],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[5576926,5577382,5576874,5577355],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[5576937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[5577015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[5576194],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[5577142,5576216,5577085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[5577130],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[5577328,5577155,5577103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[5577166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[5577244],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[5577392,5577432],"length":1,"stats":{"Line":17},"fn_name":"new"},{"line":300,"address":[5577401],"length":1,"stats":{"Line":21},"fn_name":null},{"line":301,"address":[5577453],"length":1,"stats":{"Line":17},"fn_name":null},{"line":307,"address":[5577657,5577600],"length":1,"stats":{"Line":17},"fn_name":"prefixes"},{"line":308,"address":[5577618],"length":1,"stats":{"Line":21},"fn_name":null},{"line":309,"address":[5577880,5577752,5577672,5578292],"length":1,"stats":{"Line":49},"fn_name":null},{"line":310,"address":[5578007,5577914],"length":1,"stats":{"Line":22},"fn_name":null},{"line":311,"address":[5578041,5578290,5577986],"length":1,"stats":{"Line":33},"fn_name":null},{"line":312,"address":[5578159],"length":1,"stats":{"Line":11},"fn_name":null},{"line":313,"address":[5578213],"length":1,"stats":{"Line":11},"fn_name":null},{"line":314,"address":[5578217],"length":1,"stats":{"Line":8},"fn_name":null},{"line":316,"address":[5578225],"length":1,"stats":{"Line":11},"fn_name":null},{"line":317,"address":[5578255],"length":1,"stats":{"Line":11},"fn_name":null},{"line":321,"address":[5577843],"length":1,"stats":{"Line":25},"fn_name":null},{"line":324,"address":[5578320,5578380],"length":1,"stats":{"Line":25},"fn_name":"suffixes"},{"line":325,"address":[5578338],"length":1,"stats":{"Line":25},"fn_name":null},{"line":326,"address":[5578496,5579191,5578636,5578395],"length":1,"stats":{"Line":61},"fn_name":null},{"line":327,"address":[5578775,5578670],"length":1,"stats":{"Line":20},"fn_name":null},{"line":328,"address":[5578751,5578812,5579189],"length":1,"stats":{"Line":31},"fn_name":null},{"line":329,"address":[5579056],"length":1,"stats":{"Line":11},"fn_name":null},{"line":330,"address":[5579110],"length":1,"stats":{"Line":11},"fn_name":null},{"line":331,"address":[5579114],"length":1,"stats":{"Line":8},"fn_name":null},{"line":333,"address":[5579122],"length":1,"stats":{"Line":11},"fn_name":null},{"line":334,"address":[5579152],"length":1,"stats":{"Line":11},"fn_name":null},{"line":338,"address":[5578596],"length":1,"stats":{"Line":25},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[4411023,4411149,4416334,4416403,4416317,4416512,4411235,4416191,4411166,4411344],"length":1,"stats":{"Line":85},"fn_name":null},{"line":345,"address":[4411063,4416322,4416231,4411154],"length":1,"stats":{"Line":24},"fn_name":null},{"line":346,"address":[4416347,4411179],"length":1,"stats":{"Line":34},"fn_name":null},{"line":347,"address":[4422111],"length":1,"stats":{"Line":15},"fn_name":null},{"line":348,"address":[4422226],"length":1,"stats":{"Line":10},"fn_name":null},{"line":349,"address":[4421991],"length":1,"stats":{"Line":16},"fn_name":null},{"line":354,"address":[5579216],"length":1,"stats":{"Line":8},"fn_name":"_find"},{"line":355,"address":[5579252,5579509,5579407],"length":1,"stats":{"Line":16},"fn_name":null},{"line":356,"address":[5579479],"length":1,"stats":{"Line":8},"fn_name":null},{"line":357,"address":[5579519],"length":1,"stats":{"Line":8},"fn_name":null},{"line":360,"address":[5579396],"length":1,"stats":{"Line":8},"fn_name":null},{"line":363,"address":[5579552],"length":1,"stats":{"Line":2},"fn_name":"approximate_size"},{"line":364,"address":[5579826,5579712,5579618,5579561,5579736,5579796],"length":1,"stats":{"Line":6},"fn_name":null},{"line":365,"address":[5579641,5579766,5579684],"length":1,"stats":{"Line":4},"fn_name":null},{"line":407,"address":[5579895,5579840],"length":1,"stats":{"Line":26},"fn_name":"new"},{"line":408,"address":[5579850,5579917],"length":1,"stats":{"Line":52},"fn_name":null},{"line":409,"address":[5579974],"length":1,"stats":{"Line":27},"fn_name":null},{"line":414,"address":[5580021,5579951],"length":1,"stats":{"Line":22},"fn_name":null},{"line":415,"address":[5580042],"length":1,"stats":{"Line":13},"fn_name":null},{"line":416,"address":[5580507,5580074,5580394],"length":1,"stats":{"Line":20},"fn_name":null},{"line":417,"address":[5580424],"length":1,"stats":{"Line":9},"fn_name":null},{"line":418,"address":[5580500],"length":1,"stats":{"Line":9},"fn_name":null},{"line":421,"address":[5580359,5580650,5580861,5580520],"length":1,"stats":{"Line":35},"fn_name":null},{"line":422,"address":[5580740,5580859,5580685],"length":1,"stats":{"Line":37},"fn_name":null},{"line":423,"address":[5580733],"length":1,"stats":{"Line":11},"fn_name":null},{"line":424,"address":[5580742,5580715],"length":1,"stats":{"Line":18},"fn_name":null},{"line":425,"address":[5580852],"length":1,"stats":{"Line":10},"fn_name":null},{"line":430,"address":[5419133,5419120],"length":1,"stats":{"Line":52},"fn_name":"{{closure}}"},{"line":431,"address":[5419181,5419168],"length":1,"stats":{"Line":46},"fn_name":"{{closure}}"},{"line":433,"address":[5581205],"length":1,"stats":{"Line":13},"fn_name":null},{"line":444,"address":[5581440],"length":1,"stats":{"Line":27},"fn_name":"empty"},{"line":446,"address":[5581456],"length":1,"stats":{"Line":27},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[4440773,4422470],"length":1,"stats":{"Line":29},"fn_name":null},{"line":458,"address":[4440846,4422538],"length":1,"stats":{"Line":29},"fn_name":null},{"line":459,"address":[4416912,4411744],"length":1,"stats":{"Line":12},"fn_name":null},{"line":461,"address":[4416898,4411730],"length":1,"stats":{"Line":29},"fn_name":null},{"line":462,"address":[4416910,4416929,4417644,4412476,4411742,4411761],"length":1,"stats":{"Line":79},"fn_name":null},{"line":463,"address":[4411997,4412481,4416991,4417114,4411946,4411823,4417649,4417165],"length":1,"stats":{"Line":88},"fn_name":null},{"line":464,"address":[4417083,4411975,4411915,4417143],"length":1,"stats":{"Line":44},"fn_name":null},{"line":465,"address":[4411930,4417098],"length":1,"stats":{"Line":29},"fn_name":null},{"line":467,"address":[4412511,4417173,4417679,4412005],"length":1,"stats":{"Line":30},"fn_name":null},{"line":468,"address":[4412541,4412064,4417232,4417709],"length":1,"stats":{"Line":30},"fn_name":null},{"line":469,"address":[4417292,4412124],"length":1,"stats":{"Line":30},"fn_name":null},{"line":470,"address":[4412265,4417433],"length":1,"stats":{"Line":2},"fn_name":null},{"line":472,"address":[4417313,4412145],"length":1,"stats":{"Line":30},"fn_name":null},{"line":473,"address":[4417739,4412282,4412225,4417393,4412571,4417450],"length":1,"stats":{"Line":59},"fn_name":null},{"line":474,"address":[4412438,4417606],"length":1,"stats":{"Line":29},"fn_name":null},{"line":476,"address":[4417767,4412599,4412400,4412468,4417568,4417636],"length":1,"stats":{"Line":42},"fn_name":null},{"line":478,"address":[4416974,4411806],"length":1,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[5404867],"length":1,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[5404958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[5404914,5405072,5404976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[5581568],"length":1,"stats":{"Line":9},"fn_name":"len"},{"line":490,"address":[5581577],"length":1,"stats":{"Line":9},"fn_name":null},{"line":493,"address":[5581600],"length":1,"stats":{"Line":8},"fn_name":"char_len"},{"line":494,"address":[5581605],"length":1,"stats":{"Line":8},"fn_name":null},{"line":497,"address":[5581616],"length":1,"stats":{"Line":2},"fn_name":"approximate_size"},{"line":498,"address":[5581665,5581625,5581691,5581721],"length":1,"stats":{"Line":4},"fn_name":null},{"line":502,"address":[5581781,5581728],"length":1,"stats":{"Line":18},"fn_name":"char_len_lossy"},{"line":503,"address":[5581798,5581742,5581865],"length":1,"stats":{"Line":44},"fn_name":null},{"line":572,"address":[5581963,5581920],"length":1,"stats":{"Line":9},"fn_name":"new"},{"line":573,"address":[5582027,5581982,5581930],"length":1,"stats":{"Line":18},"fn_name":null},{"line":575,"address":[5582070,5582010],"length":1,"stats":{"Line":18},"fn_name":null},{"line":576,"address":[5582133],"length":1,"stats":{"Line":9},"fn_name":null},{"line":577,"address":[5582237,5582177],"length":1,"stats":{"Line":18},"fn_name":null},{"line":591,"address":[5582496],"length":1,"stats":{"Line":7},"fn_name":"find"},{"line":592,"address":[5582535],"length":1,"stats":{"Line":7},"fn_name":null},{"line":593,"address":[5582644],"length":1,"stats":{"Line":0},"fn_name":null},{"line":596,"address":[5582688,5584021,5582625],"length":1,"stats":{"Line":14},"fn_name":null},{"line":604,"address":[5584051,5582738],"length":1,"stats":{"Line":7},"fn_name":null},{"line":606,"address":[5583203,5582825],"length":1,"stats":{"Line":8},"fn_name":null},{"line":608,"address":[5584081,5582880],"length":1,"stats":{"Line":1},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":610,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":611,"address":[5583122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":612,"address":[5583012,5583104],"length":1,"stats":{"Line":1},"fn_name":null},{"line":613,"address":[5583073,5583106],"length":1,"stats":{"Line":2},"fn_name":null},{"line":614,"address":[5583150,5583090],"length":1,"stats":{"Line":2},"fn_name":null},{"line":616,"address":[5583138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":617,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":620,"address":[5583157,5583215],"length":1,"stats":{"Line":2},"fn_name":null},{"line":621,"address":[5583289,5584141],"length":1,"stats":{"Line":1},"fn_name":null},{"line":623,"address":[5583229,5584201,5583440],"length":1,"stats":{"Line":2},"fn_name":null},{"line":624,"address":[5584235,5583527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":625,"address":[5583481],"length":1,"stats":{"Line":1},"fn_name":null},{"line":626,"address":[5583573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":632,"address":[5583578,5584016],"length":1,"stats":{"Line":11},"fn_name":null},{"line":633,"address":[5584265,5583660],"length":1,"stats":{"Line":7},"fn_name":null},{"line":634,"address":[5583847,5583761],"length":1,"stats":{"Line":8},"fn_name":null},{"line":635,"address":[5583776],"length":1,"stats":{"Line":7},"fn_name":null},{"line":636,"address":[5584296,5583849],"length":1,"stats":{"Line":7},"fn_name":null},{"line":638,"address":[5583835],"length":1,"stats":{"Line":1},"fn_name":null},{"line":641,"address":[5584356,5584386,5583972],"length":1,"stats":{"Line":4},"fn_name":null},{"line":644,"address":[5583635],"length":1,"stats":{"Line":1},"fn_name":null},{"line":647,"address":[5584400],"length":1,"stats":{"Line":6},"fn_name":"len"},{"line":648,"address":[5584409],"length":1,"stats":{"Line":6},"fn_name":null},{"line":676,"address":[5584432],"length":1,"stats":{"Line":8},"fn_name":"should_use"},{"line":694,"address":[5584459],"length":1,"stats":{"Line":8},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":697,"address":[5584707,5584737,5584498],"length":1,"stats":{"Line":8},"fn_name":null},{"line":701,"address":[5584660,5584701,5584580],"length":1,"stats":{"Line":24},"fn_name":null},{"line":703,"address":[5419230,5419216],"length":1,"stats":{"Line":32},"fn_name":"{{closure}}"},{"line":708,"address":[5584752],"length":1,"stats":{"Line":7},"fn_name":"check_match"},{"line":710,"address":[5584791,5585337],"length":1,"stats":{"Line":7},"fn_name":null},{"line":711,"address":[5584907],"length":1,"stats":{"Line":1},"fn_name":null},{"line":715,"address":[5584891,5584940,5585395],"length":1,"stats":{"Line":14},"fn_name":null},{"line":716,"address":[5585011,5585171,5585319],"length":1,"stats":{"Line":14},"fn_name":null},{"line":717,"address":[5585210,5585455],"length":1,"stats":{"Line":7},"fn_name":null},{"line":718,"address":[5585324],"length":1,"stats":{"Line":1},"fn_name":null},{"line":722,"address":[5585158],"length":1,"stats":{"Line":7},"fn_name":null},{"line":732,"address":[5585520],"length":1,"stats":{"Line":1},"fn_name":"skip_loop"},{"line":738,"address":[5585567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":739,"address":[5419296],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":742,"address":[5419439,5419310,5419411],"length":1,"stats":{"Line":3},"fn_name":null},{"line":745,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":746,"address":[5585631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":747,"address":[5585676,5587363],"length":1,"stats":{"Line":1},"fn_name":null},{"line":748,"address":[5585728],"length":1,"stats":{"Line":1},"fn_name":null},{"line":749,"address":[5585789,5587393],"length":1,"stats":{"Line":1},"fn_name":null},{"line":750,"address":[5587328,5585841],"length":1,"stats":{"Line":2},"fn_name":null},{"line":751,"address":[5585856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":752,"address":[5587423,5585917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":753,"address":[5585969],"length":1,"stats":{"Line":1},"fn_name":null},{"line":754,"address":[5586030,5587453],"length":1,"stats":{"Line":1},"fn_name":null},{"line":755,"address":[5586082],"length":1,"stats":{"Line":1},"fn_name":null},{"line":756,"address":[5587483,5586143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":757,"address":[5586560,5586195],"length":1,"stats":{"Line":2},"fn_name":null},{"line":758,"address":[5586210],"length":1,"stats":{"Line":1},"fn_name":null},{"line":759,"address":[5587513,5586271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":760,"address":[5586323],"length":1,"stats":{"Line":1},"fn_name":null},{"line":761,"address":[5586384,5587543],"length":1,"stats":{"Line":1},"fn_name":null},{"line":762,"address":[5586436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":763,"address":[5586497,5587573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":764,"address":[5586549],"length":1,"stats":{"Line":1},"fn_name":null},{"line":765,"address":[5586565],"length":1,"stats":{"Line":1},"fn_name":null},{"line":766,"address":[5587603,5586626],"length":1,"stats":{"Line":1},"fn_name":null},{"line":767,"address":[5586678],"length":1,"stats":{"Line":1},"fn_name":null},{"line":768,"address":[5587633,5586733],"length":1,"stats":{"Line":1},"fn_name":null},{"line":772,"address":[5586884,5587663,5586779],"length":1,"stats":{"Line":2},"fn_name":null},{"line":773,"address":[5586847,5587693],"length":1,"stats":{"Line":1},"fn_name":null},{"line":778,"address":[5586947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":779,"address":[5586962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":782,"address":[5586957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":786,"address":[5586889,5587026],"length":1,"stats":{"Line":2},"fn_name":null},{"line":787,"address":[5586897,5587723],"length":1,"stats":{"Line":1},"fn_name":null},{"line":788,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":790,"address":[5587078,5587248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":791,"address":[5587190,5587250],"length":1,"stats":{"Line":2},"fn_name":null},{"line":792,"address":[5587205],"length":1,"stats":{"Line":1},"fn_name":null},{"line":793,"address":[5587306],"length":1,"stats":{"Line":1},"fn_name":null},{"line":794,"address":[5587221,5587280,5587753,5587813],"length":1,"stats":{"Line":2},"fn_name":null},{"line":795,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":796,"address":[5587267],"length":1,"stats":{"Line":1},"fn_name":null},{"line":805,"address":[5587330],"length":1,"stats":{"Line":1},"fn_name":null},{"line":810,"address":[5587889,5587824],"length":1,"stats":{"Line":9},"fn_name":"compile_skip_table"},{"line":811,"address":[5587855,5587904],"length":1,"stats":{"Line":18},"fn_name":null},{"line":818,"address":[5588398,5588204,5587924,5587997],"length":1,"stats":{"Line":27},"fn_name":null},{"line":819,"address":[5588423,5588270],"length":1,"stats":{"Line":9},"fn_name":null},{"line":822,"address":[5588154],"length":1,"stats":{"Line":9},"fn_name":null},{"line":827,"address":[5588496],"length":1,"stats":{"Line":9},"fn_name":"select_guard"},{"line":828,"address":[5589067,5588523],"length":1,"stats":{"Line":9},"fn_name":null},{"line":829,"address":[5588563,5589094],"length":1,"stats":{"Line":9},"fn_name":null},{"line":830,"address":[5588633,5588842,5589062],"length":1,"stats":{"Line":18},"fn_name":null},{"line":831,"address":[5588908],"length":1,"stats":{"Line":9},"fn_name":null},{"line":832,"address":[5588969],"length":1,"stats":{"Line":9},"fn_name":null},{"line":833,"address":[5588988,5589184,5589124],"length":1,"stats":{"Line":18},"fn_name":"compile_md2_shift"},{"line":837,"address":[5588801],"length":1,"stats":{"Line":9},"fn_name":null},{"line":843,"address":[5589184],"length":1,"stats":{"Line":0},"fn_name":"compile_md2_shift"},{"line":844,"address":[5589217],"length":1,"stats":{"Line":9},"fn_name":null},{"line":849,"address":[5589280],"length":1,"stats":{"Line":9},"fn_name":null},{"line":850,"address":[5589356,5589325],"length":1,"stats":{"Line":10},"fn_name":null},{"line":853,"address":[5589312,5589683,5589363],"length":1,"stats":{"Line":18},"fn_name":null},{"line":854,"address":[5589399,5589632],"length":1,"stats":{"Line":18},"fn_name":null},{"line":855,"address":[5589713,5589436],"length":1,"stats":{"Line":9},"fn_name":null},{"line":856,"address":[5589741,5589532],"length":1,"stats":{"Line":9},"fn_name":null},{"line":858,"address":[5589801,5589489,5589624],"length":1,"stats":{"Line":18},"fn_name":null},{"line":863,"address":[5589861,5589831,5589420,5589642],"length":1,"stats":{"Line":2},"fn_name":null},{"line":866,"address":[5589872],"length":1,"stats":{"Line":0},"fn_name":"approximate_size"},{"line":867,"address":[5590080,5590110,5589881,5589921,5589996,5590020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":868,"address":[5590050,5589963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":872,"address":[5590112],"length":1,"stats":{"Line":9},"fn_name":"freq_rank"},{"line":873,"address":[5590127,5590211,5590239],"length":1,"stats":{"Line":9},"fn_name":null},{"line":886,"address":[5420464,5420507],"length":1,"stats":{"Line":3},"fn_name":"bm_find_subs"},{"line":887,"address":[5420478,5420522],"length":1,"stats":{"Line":2},"fn_name":null},{"line":888,"address":[5420569],"length":1,"stats":{"Line":1},"fn_name":null},{"line":889,"address":[5420685,5420802,5420584],"length":1,"stats":{"Line":2},"fn_name":null},{"line":893,"address":[5421152,5421192],"length":1,"stats":{"Line":3},"fn_name":"bm_find_no_subs"},{"line":894,"address":[5421166,5421207],"length":1,"stats":{"Line":2},"fn_name":null},{"line":895,"address":[5421251],"length":1,"stats":{"Line":1},"fn_name":null},{"line":896,"address":[5421457,5421266,5421481],"length":1,"stats":{"Line":2},"fn_name":null},{"line":904,"address":[5421824,5421904],"length":1,"stats":{"Line":3},"fn_name":"bm_skip_reset_bug"},{"line":905,"address":[5421831],"length":1,"stats":{"Line":1},"fn_name":null},{"line":906,"address":[5421929],"length":1,"stats":{"Line":1},"fn_name":null},{"line":908,"address":[5422006],"length":1,"stats":{"Line":1},"fn_name":null},{"line":909,"address":[5422069,5422139],"length":1,"stats":{"Line":2},"fn_name":null},{"line":910,"address":[5422296,5422185],"length":1,"stats":{"Line":1},"fn_name":null},{"line":914,"address":[5422728,5422672],"length":1,"stats":{"Line":3},"fn_name":"bm_backstop_underflow_bug"},{"line":915,"address":[5422679],"length":1,"stats":{"Line":1},"fn_name":null},{"line":916,"address":[5422753],"length":1,"stats":{"Line":1},"fn_name":null},{"line":918,"address":[5422822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":919,"address":[5422885,5422955],"length":1,"stats":{"Line":2},"fn_name":null},{"line":920,"address":[5423112,5423001],"length":1,"stats":{"Line":1},"fn_name":null},{"line":924,"address":[5423488,5423541],"length":1,"stats":{"Line":3},"fn_name":"bm_naive_off_by_one_bug"},{"line":925,"address":[5423495],"length":1,"stats":{"Line":1},"fn_name":null},{"line":926,"address":[5423561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":928,"address":[5423629,5423761],"length":1,"stats":{"Line":2},"fn_name":null},{"line":929,"address":[5423939,5423824],"length":1,"stats":{"Line":1},"fn_name":null},{"line":933,"address":[5424320,5424768],"length":1,"stats":{"Line":3},"fn_name":"bm_memchr_fallback_indexing_bug"},{"line":934,"address":[5424327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":941,"address":[5424793,5424882],"length":1,"stats":{"Line":2},"fn_name":null},{"line":942,"address":[5424890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":943,"address":[5424927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":945,"address":[5424977],"length":1,"stats":{"Line":1},"fn_name":null},{"line":946,"address":[5425276,5425048,5425118],"length":1,"stats":{"Line":2},"fn_name":null},{"line":950,"address":[5425766,5425728],"length":1,"stats":{"Line":3},"fn_name":"bm_backstop_boundary"},{"line":951,"address":[5425742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":958,"address":[5425781],"length":1,"stats":{"Line":1},"fn_name":null},{"line":960,"address":[5425812],"length":1,"stats":{"Line":1},"fn_name":null},{"line":961,"address":[5425883,5425973],"length":1,"stats":{"Line":2},"fn_name":null},{"line":962,"address":[5426124,5425994],"length":1,"stats":{"Line":1},"fn_name":null},{"line":966,"address":[5426897,5426512],"length":1,"stats":{"Line":3},"fn_name":"bm_win_gnu_indexing_bug"},{"line":967,"address":[5426519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":973,"address":[5426922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":974,"address":[5427004],"length":1,"stats":{"Line":1},"fn_name":null},{"line":976,"address":[5427134,5427057],"length":1,"stats":{"Line":2},"fn_name":null},{"line":985,"address":[5419440],"length":1,"stats":{"Line":1},"fn_name":"naive_find"},{"line":986,"address":[5419608,5419479],"length":1,"stats":{"Line":1},"fn_name":null},{"line":988,"address":[5419873,5419638,5419595,5420255,5420309],"length":1,"stats":{"Line":3},"fn_name":null},{"line":989,"address":[5419985,5420242,5419915,5420369],"length":1,"stats":{"Line":3},"fn_name":null},{"line":990,"address":[5419956,5420092,5420427,5420457],"length":1,"stats":{"Line":2},"fn_name":null},{"line":992,"address":[5420265],"length":1,"stats":{"Line":1},"fn_name":null},{"line":996,"address":[5419856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1001,"address":[5427306,5427500,5427471],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1002,"address":[5427532],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1005,"address":[5427957,5427618,5427862,5427978,5427508],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1006,"address":[5427724,5427864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1008,"address":[5427883,5427959,5427657],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1011,"address":[5428042,5428114],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1012,"address":[5428327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1013,"address":[5428139,5428249],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1017,"address":[5428890,5428858,5428682],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1018,"address":[5428925],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1021,"address":[5429282,5429011,5428898,5429383,5429404],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1022,"address":[5429132,5429284],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1024,"address":[5429385,5429059,5429303],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1027,"address":[5429476,5429554],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1028,"address":[5429561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1029,"address":[5431311],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1030,"address":[5429697,5431255,5429648],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1037,"address":[5431722,5431799],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1038,"address":[5431901,5431866],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1041,"address":[5431839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1042,"address":[5431938],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1044,"address":[5432165,5432085,5432284,5432007],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1045,"address":[5432196,5432062],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1046,"address":[5432324,5432379],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1049,"address":[5432297,5432400],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1053,"address":[5432407,5432477],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1054,"address":[5432434],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1056,"address":[5432551,5432797,5433299,5433003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1057,"address":[5433331,5432839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1058,"address":[5433008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1062,"address":[5433140],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1063,"address":[5432777,5433050,5433083],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1064,"address":[5433075],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1080,"address":[5433434,5433520],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1081,"address":[5433606,5433571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1084,"address":[5433632,5434509,5433544],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1085,"address":[5433682,5434541],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1087,"address":[5433811],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1088,"address":[5433863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1091,"address":[5433895,5434601,5433841],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1093,"address":[5433983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1095,"address":[5434055,5434173],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1096,"address":[5434451,5434240],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1097,"address":[5434194,5434242,5434487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1098,"address":[5434209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1099,"address":[5434315],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1100,"address":[5434233,5434266,5434438],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1101,"address":[5434286,5434360],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1107,"address":[5434682,5434752],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1108,"address":[5434779],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1111,"address":[5434758],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1112,"address":[5434829],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1113,"address":[5434889],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1115,"address":[5435060],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1116,"address":[5434950,5434994],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1117,"address":[5614121,5614112],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"}],"covered":398,"coverable":439},{"path":["/","usr","src","regex","src","literal","mod.rs"],"content":"pub use self::imp::*;\n\n#[cfg(feature = \"perf-literal\")]\nmod imp;\n\n#[allow(missing_docs)]\n#[cfg(not(feature = \"perf-literal\"))]\nmod imp {\n    use syntax::hir::literal::Literals;\n\n    #[derive(Clone, Debug)]\n    pub struct LiteralSearcher(());\n\n    impl LiteralSearcher {\n        pub fn empty() -> Self {\n            LiteralSearcher(())\n        }\n\n        pub fn prefixes(_: Literals) -> Self {\n            LiteralSearcher(())\n        }\n\n        pub fn suffixes(_: Literals) -> Self {\n            LiteralSearcher(())\n        }\n\n        pub fn complete(&self) -> bool {\n            false\n        }\n\n        pub fn find(&self, _: &[u8]) -> Option<(usize, usize)> {\n            unreachable!()\n        }\n\n        pub fn find_start(&self, _: &[u8]) -> Option<(usize, usize)> {\n            unreachable!()\n        }\n\n        pub fn find_end(&self, _: &[u8]) -> Option<(usize, usize)> {\n            unreachable!()\n        }\n\n        pub fn is_empty(&self) -> bool {\n            true\n        }\n\n        pub fn len(&self) -> usize {\n            0\n        }\n\n        pub fn approximate_size(&self) -> usize {\n            0\n        }\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":8},{"path":["/","usr","src","regex","src","pattern.rs"],"content":"use std::str::pattern::{Pattern, SearchStep, Searcher};\n\nuse re_unicode::{Matches, Regex};\n\npub struct RegexSearcher<'r, 't> {\n    haystack: &'t str,\n    it: Matches<'r, 't>,\n    last_step_end: usize,\n    next_match: Option<(usize, usize)>,\n}\n\nimpl<'r, 't> Pattern<'t> for &'r Regex {\n    type Searcher = RegexSearcher<'r, 't>;\n\n    fn into_searcher(self, haystack: &'t str) -> RegexSearcher<'r, 't> {\n        RegexSearcher {\n            haystack: haystack,\n            it: self.find_iter(haystack),\n            last_step_end: 0,\n            next_match: None,\n        }\n    }\n}\n\nunsafe impl<'r, 't> Searcher<'t> for RegexSearcher<'r, 't> {\n    #[inline]\n    fn haystack(&self) -> &'t str {\n        self.haystack\n    }\n\n    #[inline]\n    fn next(&mut self) -> SearchStep {\n        if let Some((s, e)) = self.next_match {\n            self.next_match = None;\n            self.last_step_end = e;\n            return SearchStep::Match(s, e);\n        }\n        match self.it.next() {\n            None => {\n                if self.last_step_end < self.haystack().len() {\n                    let last = self.last_step_end;\n                    self.last_step_end = self.haystack().len();\n                    SearchStep::Reject(last, self.haystack().len())\n                } else {\n                    SearchStep::Done\n                }\n            }\n            Some(m) => {\n                let (s, e) = (m.start(), m.end());\n                if s == self.last_step_end {\n                    self.last_step_end = e;\n                    SearchStep::Match(s, e)\n                } else {\n                    self.next_match = Some((s, e));\n                    let last = self.last_step_end;\n                    self.last_step_end = s;\n                    SearchStep::Reject(last, s)\n                }\n            }\n        }\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":25},{"path":["/","usr","src","regex","src","pikevm.rs"],"content":"// This module implements the Pike VM. That is, it guarantees linear time\n// search of a regex on any text with memory use proportional to the size of\n// the regex.\n//\n// It is equal in power to the backtracking engine in this crate, except the\n// backtracking engine is typically faster on small regexes/texts at the\n// expense of a bigger memory footprint.\n//\n// It can do more than the DFA can (specifically, record capture locations\n// and execute Unicode word boundary assertions), but at a slower speed.\n// Specifically, the Pike VM exectues a DFA implicitly by repeatedly expanding\n// epsilon transitions. That is, the Pike VM engine can be in multiple states\n// at once where as the DFA is only ever in one state at a time.\n//\n// Therefore, the Pike VM is generally treated as the fallback when the other\n// matching engines either aren't feasible to run or are insufficient.\n\nuse std::mem;\n\nuse exec::ProgramCache;\nuse input::{Input, InputAt};\nuse prog::{InstPtr, Program};\nuse re_trait::Slot;\nuse sparse::SparseSet;\n\n/// An NFA simulation matching engine.\n#[derive(Debug)]\npub struct Fsm<'r, I> {\n    /// The sequence of opcodes (among other things) that is actually executed.\n    ///\n    /// The program may be byte oriented or Unicode codepoint oriented.\n    prog: &'r Program,\n    /// An explicit stack used for following epsilon transitions. (This is\n    /// borrowed from the cache.)\n    stack: &'r mut Vec<FollowEpsilon>,\n    /// The input to search.\n    input: I,\n}\n\n/// A cached allocation that can be reused on each execution.\n#[derive(Clone, Debug)]\npub struct Cache {\n    /// A pair of ordered sets for tracking NFA states.\n    clist: Threads,\n    nlist: Threads,\n    /// An explicit stack used for following epsilon transitions.\n    stack: Vec<FollowEpsilon>,\n}\n\n/// An ordered set of NFA states and their captures.\n#[derive(Clone, Debug)]\nstruct Threads {\n    /// An ordered set of opcodes (each opcode is an NFA state).\n    set: SparseSet,\n    /// Captures for every NFA state.\n    ///\n    /// It is stored in row-major order, where the columns are the capture\n    /// slots and the rows are the states.\n    caps: Vec<Slot>,\n    /// The number of capture slots stored per thread. (Every capture has\n    /// two slots.)\n    slots_per_thread: usize,\n}\n\n/// A representation of an explicit stack frame when following epsilon\n/// transitions. This is used to avoid recursion.\n#[derive(Clone, Debug)]\nenum FollowEpsilon {\n    /// Follow transitions at the given instruction pointer.\n    IP(InstPtr),\n    /// Restore the capture slot with the given position in the input.\n    Capture { slot: usize, pos: Slot },\n}\n\nimpl Cache {\n    /// Create a new allocation used by the NFA machine to record execution\n    /// and captures.\n    pub fn new(_prog: &Program) -> Self {\n        Cache { clist: Threads::new(), nlist: Threads::new(), stack: vec![] }\n    }\n}\n\nimpl<'r, I: Input> Fsm<'r, I> {\n    /// Execute the NFA matching engine.\n    ///\n    /// If there's a match, `exec` returns `true` and populates the given\n    /// captures accordingly.\n    pub fn exec(\n        prog: &'r Program,\n        cache: &ProgramCache,\n        matches: &mut [bool],\n        slots: &mut [Slot],\n        quit_after_match: bool,\n        input: I,\n        start: usize,\n        end: usize,\n    ) -> bool {\n        let mut cache = cache.borrow_mut();\n        let cache = &mut cache.pikevm;\n        cache.clist.resize(prog.len(), prog.captures.len());\n        cache.nlist.resize(prog.len(), prog.captures.len());\n        let at = input.at(start);\n        Fsm { prog: prog, stack: &mut cache.stack, input: input }.exec_(\n            &mut cache.clist,\n            &mut cache.nlist,\n            matches,\n            slots,\n            quit_after_match,\n            at,\n            end,\n        )\n    }\n\n    fn exec_(\n        &mut self,\n        mut clist: &mut Threads,\n        mut nlist: &mut Threads,\n        matches: &mut [bool],\n        slots: &mut [Slot],\n        quit_after_match: bool,\n        mut at: InputAt,\n        end: usize,\n    ) -> bool {\n        let mut matched = false;\n        let mut all_matched = false;\n        clist.set.clear();\n        nlist.set.clear();\n        'LOOP: loop {\n            if clist.set.is_empty() {\n                // Three ways to bail out when our current set of threads is\n                // empty.\n                //\n                // 1. We have a match---so we're done exploring any possible\n                //    alternatives. Time to quit. (We can't do this if we're\n                //    looking for matches for multiple regexes, unless we know\n                //    they all matched.)\n                //\n                // 2. If the expression starts with a '^' we can terminate as\n                //    soon as the last thread dies.\n                if (matched && matches.len() <= 1)\n                    || all_matched\n                    || (!at.is_start() && self.prog.is_anchored_start)\n                {\n                    break;\n                }\n\n                // 3. If there's a literal prefix for the program, try to\n                //    jump ahead quickly. If it can't be found, then we can\n                //    bail out early.\n                if !self.prog.prefixes.is_empty() {\n                    at = match self.input.prefix_at(&self.prog.prefixes, at) {\n                        None => break,\n                        Some(at) => at,\n                    };\n                }\n            }\n\n            // This simulates a preceding '.*?' for every regex by adding\n            // a state starting at the current position in the input for the\n            // beginning of the program only if we don't already have a match.\n            if clist.set.is_empty()\n                || (!self.prog.is_anchored_start && !all_matched)\n            {\n                self.add(&mut clist, slots, 0, at);\n            }\n            // The previous call to \"add\" actually inspects the position just\n            // before the current character. For stepping through the machine,\n            // we can to look at the current character, so we advance the\n            // input.\n            let at_next = self.input.at(at.next_pos());\n            for i in 0..clist.set.len() {\n                let ip = clist.set[i];\n                if self.step(\n                    &mut nlist,\n                    matches,\n                    slots,\n                    clist.caps(ip),\n                    ip,\n                    at,\n                    at_next,\n                ) {\n                    matched = true;\n                    all_matched = all_matched || matches.iter().all(|&b| b);\n                    if quit_after_match {\n                        // If we only care if a match occurs (not its\n                        // position), then we can quit right now.\n                        break 'LOOP;\n                    }\n                    if self.prog.matches.len() == 1 {\n                        // We don't need to check the rest of the threads\n                        // in this set because we've matched something\n                        // (\"leftmost-first\"). However, we still need to check\n                        // threads in the next set to support things like\n                        // greedy matching.\n                        //\n                        // This is only true on normal regexes. For regex sets,\n                        // we need to mush on to observe other matches.\n                        break;\n                    }\n                }\n            }\n            if at.pos() >= end {\n                break;\n            }\n            at = at_next;\n            mem::swap(clist, nlist);\n            nlist.set.clear();\n        }\n        matched\n    }\n\n    /// Step through the input, one token (byte or codepoint) at a time.\n    ///\n    /// nlist is the set of states that will be processed on the next token\n    /// in the input.\n    ///\n    /// caps is the set of captures passed by the caller of the NFA. They are\n    /// written to only when a match state is visited.\n    ///\n    /// thread_caps is the set of captures set for the current NFA state, ip.\n    ///\n    /// at and at_next are the current and next positions in the input. at or\n    /// at_next may be EOF.\n    fn step(\n        &mut self,\n        nlist: &mut Threads,\n        matches: &mut [bool],\n        slots: &mut [Slot],\n        thread_caps: &mut [Option<usize>],\n        ip: usize,\n        at: InputAt,\n        at_next: InputAt,\n    ) -> bool {\n        use prog::Inst::*;\n        match self.prog[ip] {\n            Match(match_slot) => {\n                if match_slot < matches.len() {\n                    matches[match_slot] = true;\n                }\n                for (slot, val) in slots.iter_mut().zip(thread_caps.iter()) {\n                    *slot = *val;\n                }\n                true\n            }\n            Char(ref inst) => {\n                if inst.c == at.char() {\n                    self.add(nlist, thread_caps, inst.goto, at_next);\n                }\n                false\n            }\n            Ranges(ref inst) => {\n                if inst.matches(at.char()) {\n                    self.add(nlist, thread_caps, inst.goto, at_next);\n                }\n                false\n            }\n            Bytes(ref inst) => {\n                if let Some(b) = at.byte() {\n                    if inst.matches(b) {\n                        self.add(nlist, thread_caps, inst.goto, at_next);\n                    }\n                }\n                false\n            }\n            EmptyLook(_) | Save(_) | Split(_) => false,\n        }\n    }\n\n    /// Follows epsilon transitions and adds them for processing to nlist,\n    /// starting at and including ip.\n    fn add(\n        &mut self,\n        nlist: &mut Threads,\n        thread_caps: &mut [Option<usize>],\n        ip: usize,\n        at: InputAt,\n    ) {\n        self.stack.push(FollowEpsilon::IP(ip));\n        while let Some(frame) = self.stack.pop() {\n            match frame {\n                FollowEpsilon::IP(ip) => {\n                    self.add_step(nlist, thread_caps, ip, at);\n                }\n                FollowEpsilon::Capture { slot, pos } => {\n                    thread_caps[slot] = pos;\n                }\n            }\n        }\n    }\n\n    /// A helper function for add that avoids excessive pushing to the stack.\n    fn add_step(\n        &mut self,\n        nlist: &mut Threads,\n        thread_caps: &mut [Option<usize>],\n        mut ip: usize,\n        at: InputAt,\n    ) {\n        // Instead of pushing and popping to the stack, we mutate ip as we\n        // traverse the set of states. We only push to the stack when we\n        // absolutely need recursion (restoring captures or following a\n        // branch).\n        use prog::Inst::*;\n        loop {\n            // Don't visit states we've already added.\n            if nlist.set.contains(ip) {\n                return;\n            }\n            nlist.set.insert(ip);\n            match self.prog[ip] {\n                EmptyLook(ref inst) => {\n                    if self.input.is_empty_match(at, inst) {\n                        ip = inst.goto;\n                    }\n                }\n                Save(ref inst) => {\n                    if inst.slot < thread_caps.len() {\n                        self.stack.push(FollowEpsilon::Capture {\n                            slot: inst.slot,\n                            pos: thread_caps[inst.slot],\n                        });\n                        thread_caps[inst.slot] = Some(at.pos());\n                    }\n                    ip = inst.goto;\n                }\n                Split(ref inst) => {\n                    self.stack.push(FollowEpsilon::IP(inst.goto2));\n                    ip = inst.goto1;\n                }\n                Match(_) | Char(_) | Ranges(_) | Bytes(_) => {\n                    let t = &mut nlist.caps(ip);\n                    for (slot, val) in t.iter_mut().zip(thread_caps.iter()) {\n                        *slot = *val;\n                    }\n                    return;\n                }\n            }\n        }\n    }\n}\n\nimpl Threads {\n    fn new() -> Self {\n        Threads { set: SparseSet::new(0), caps: vec![], slots_per_thread: 0 }\n    }\n\n    fn resize(&mut self, num_insts: usize, ncaps: usize) {\n        if num_insts == self.set.capacity() {\n            return;\n        }\n        self.slots_per_thread = ncaps * 2;\n        self.set = SparseSet::new(num_insts);\n        self.caps = vec![None; self.slots_per_thread * num_insts];\n    }\n\n    fn caps(&mut self, pc: usize) -> &mut [Option<usize>] {\n        let i = pc * self.slots_per_thread;\n        &mut self.caps[i..i + self.slots_per_thread]\n    }\n}\n","traces":[{"line":78,"address":[4482219,4482176],"length":1,"stats":{"Line":25},"fn_name":"new"},{"line":79,"address":[4482239,4482194],"length":1,"stats":{"Line":48},"fn_name":null},{"line":88,"address":[5676028,5675792,5677032,5676816],"length":1,"stats":{"Line":18},"fn_name":"exec<regex::input::CharInput>"},{"line":98,"address":[5677055,5676919,5675922,5676051],"length":1,"stats":{"Line":36},"fn_name":null},{"line":99,"address":[5677087,5676083],"length":1,"stats":{"Line":19},"fn_name":null},{"line":100,"address":[5676205,5677209],"length":1,"stats":{"Line":19},"fn_name":null},{"line":101,"address":[5677277,5677339,5676335,5676273],"length":1,"stats":{"Line":38},"fn_name":null},{"line":102,"address":[5677426,5676422],"length":1,"stats":{"Line":19},"fn_name":null},{"line":103,"address":[5677580,5676545,5676434,5677438],"length":1,"stats":{"Line":38},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[5677544,5676509],"length":1,"stats":{"Line":19},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[5676513,5677548],"length":1,"stats":{"Line":19},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[5677856,5680016],"length":1,"stats":{"Line":19},"fn_name":"exec_<regex::input::ByteInput>"},{"line":124,"address":[5677970,5680130],"length":1,"stats":{"Line":19},"fn_name":null},{"line":125,"address":[5677978,5680138],"length":1,"stats":{"Line":19},"fn_name":null},{"line":126,"address":[5680146,5677986],"length":1,"stats":{"Line":19},"fn_name":null},{"line":127,"address":[5680226,5678066],"length":1,"stats":{"Line":19},"fn_name":null},{"line":128,"address":[5682138,5679978,5680242,5678082],"length":1,"stats":{"Line":39},"fn_name":null},{"line":129,"address":[5680905,5678745,5680268,5678108],"length":1,"stats":{"Line":37},"fn_name":null},{"line":140,"address":[5678208,5680553,5678147,5680307,5678393,5680368],"length":1,"stats":{"Line":57},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[5680579,5678351,5678419,5680351,5678191,5680511],"length":1,"stats":{"Line":42},"fn_name":null},{"line":144,"address":[5678455,5680615],"length":1,"stats":{"Line":7},"fn_name":null},{"line":150,"address":[5678736,5680629,5680595,5680896,5678469,5678435],"length":1,"stats":{"Line":45},"fn_name":null},{"line":151,"address":[5678738,5678488,5680853,5678693,5680648,5680898],"length":1,"stats":{"Line":18},"fn_name":null},{"line":152,"address":[5680900,5680732,5678740,5678572],"length":1,"stats":{"Line":15},"fn_name":null},{"line":153,"address":[5678597,5680757],"length":1,"stats":{"Line":9},"fn_name":null},{"line":161,"address":[5681042,5678819,5680907,5681147,5678882,5680979,5678987,5678747],"length":1,"stats":{"Line":74},"fn_name":null},{"line":162,"address":[5678847,5681007,5678800,5680960],"length":1,"stats":{"Line":35},"fn_name":null},{"line":164,"address":[5681059,5678899],"length":1,"stats":{"Line":16},"fn_name":null},{"line":170,"address":[5678997,5681157],"length":1,"stats":{"Line":21},"fn_name":null},{"line":171,"address":[5679061,5679820,5681221,5681980],"length":1,"stats":{"Line":42},"fn_name":null},{"line":172,"address":[5679263,5680011,5682171,5681423,5679329,5682143,5679983,5681489],"length":1,"stats":{"Line":42},"fn_name":null},{"line":173,"address":[5679813,5681712,5679552,5681973],"length":1,"stats":{"Line":24},"fn_name":null},{"line":174,"address":[5679367,5681527],"length":1,"stats":{"Line":21},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[5679375,5681535],"length":1,"stats":{"Line":21},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[5679419,5681579],"length":1,"stats":{"Line":21},"fn_name":null},{"line":180,"address":[5679454,5681614],"length":1,"stats":{"Line":21},"fn_name":null},{"line":182,"address":[5679624,5681784],"length":1,"stats":{"Line":22},"fn_name":null},{"line":183,"address":[5681792,5682237,5679734,5681894,5682176,5679632,5682189,5682224],"length":1,"stats":{"Line":88},"fn_name":"{{closure}}<regex::input::ByteInput>"},{"line":184,"address":[5679728,5681888],"length":1,"stats":{"Line":22},"fn_name":null},{"line":187,"address":[5681955,5679795],"length":1,"stats":{"Line":14},"fn_name":null},{"line":189,"address":[5681967,5679769,5679807,5681929],"length":1,"stats":{"Line":26},"fn_name":null},{"line":198,"address":[5681975,5679815],"length":1,"stats":{"Line":13},"fn_name":null},{"line":202,"address":[5681998,5679304,5679838,5681464],"length":1,"stats":{"Line":34},"fn_name":null},{"line":203,"address":[5682117,5679957],"length":1,"stats":{"Line":14},"fn_name":null},{"line":205,"address":[5682003,5679843],"length":1,"stats":{"Line":17},"fn_name":null},{"line":206,"address":[5679934,5682094],"length":1,"stats":{"Line":20},"fn_name":null},{"line":207,"address":[5679962,5682122],"length":1,"stats":{"Line":20},"fn_name":null},{"line":209,"address":[5678084,5680244],"length":1,"stats":{"Line":22},"fn_name":null},{"line":224,"address":[5682272,5683808],"length":1,"stats":{"Line":21},"fn_name":"step<regex::input::ByteInput>"},{"line":235,"address":[5683924,5684473,5682528,5685233,5684064,5684130,5682594,5682937,5683697,5682388,5684788,5683454,5683732,5685268,5684990,5683252],"length":1,"stats":{"Line":88},"fn_name":null},{"line":236,"address":[5682604,5684088,5682552,5684140],"length":1,"stats":{"Line":35},"fn_name":null},{"line":237,"address":[5682655,5684191],"length":1,"stats":{"Line":14},"fn_name":null},{"line":238,"address":[5685330,5683763,5683794,5682694,5684230,5685299],"length":1,"stats":{"Line":19},"fn_name":null},{"line":240,"address":[5682942,5684478,5683028,5684564,5682743,5684279],"length":1,"stats":{"Line":40},"fn_name":null},{"line":241,"address":[5684550,5683014],"length":1,"stats":{"Line":19},"fn_name":null},{"line":243,"address":[5684465,5682929],"length":1,"stats":{"Line":21},"fn_name":null},{"line":245,"address":[5683041,5684577],"length":1,"stats":{"Line":6},"fn_name":null},{"line":246,"address":[5684610,5683242,5683074,5684778],"length":1,"stats":{"Line":12},"fn_name":null},{"line":247,"address":[5683151,5684687],"length":1,"stats":{"Line":6},"fn_name":null},{"line":249,"address":[5683244,5684780],"length":1,"stats":{"Line":6},"fn_name":null},{"line":251,"address":[5684801,5683265],"length":1,"stats":{"Line":8},"fn_name":null},{"line":252,"address":[5684847,5684980,5683444,5683311],"length":1,"stats":{"Line":14},"fn_name":null},{"line":253,"address":[5684889,5683353],"length":1,"stats":{"Line":8},"fn_name":null},{"line":255,"address":[5684982,5683446],"length":1,"stats":{"Line":8},"fn_name":null},{"line":257,"address":[5683467,5685003],"length":1,"stats":{"Line":11},"fn_name":null},{"line":258,"address":[5683687,5685041,5685223,5683505],"length":1,"stats":{"Line":21},"fn_name":null},{"line":259,"address":[5683685,5685103,5683567,5685221],"length":1,"stats":{"Line":19},"fn_name":null},{"line":260,"address":[5683594,5685130],"length":1,"stats":{"Line":8},"fn_name":null},{"line":263,"address":[5683689,5685225],"length":1,"stats":{"Line":10},"fn_name":null},{"line":265,"address":[5683699,5685235],"length":1,"stats":{"Line":21},"fn_name":null},{"line":271,"address":[5685344,5685808],"length":1,"stats":{"Line":19},"fn_name":"add<regex::input::ByteInput>"},{"line":278,"address":[5685391,5685855],"length":1,"stats":{"Line":17},"fn_name":null},{"line":279,"address":[5685978,5685450,5686233,5685914,5685514,5685769],"length":1,"stats":{"Line":54},"fn_name":null},{"line":280,"address":[5686104,5685734,5686198,5685640],"length":1,"stats":{"Line":18},"fn_name":null},{"line":281,"address":[5685540,5685642,5686106,5686004],"length":1,"stats":{"Line":36},"fn_name":null},{"line":282,"address":[5686127,5685663],"length":1,"stats":{"Line":19},"fn_name":null},{"line":284,"address":[5686019,5685555],"length":1,"stats":{"Line":17},"fn_name":null},{"line":285,"address":[5685741,5685608,5686205,5686266,5685774,5686072,5685802,5686238],"length":1,"stats":{"Line":39},"fn_name":null},{"line":292,"address":[5687728,5686272],"length":1,"stats":{"Line":17},"fn_name":"add_step<regex::input::CharInput>"},{"line":304,"address":[5687614,5689070],"length":1,"stats":{"Line":19},"fn_name":null},{"line":306,"address":[5687823,5686367],"length":1,"stats":{"Line":19},"fn_name":null},{"line":307,"address":[5686429,5687885],"length":1,"stats":{"Line":15},"fn_name":null},{"line":309,"address":[5687867,5686411],"length":1,"stats":{"Line":19},"fn_name":null},{"line":310,"address":[5686489,5687903,5686737,5688193,5687945,5687619,5688041,5688595,5687139,5686447,5687258,5686585,5689075,5688714],"length":1,"stats":{"Line":90},"fn_name":null},{"line":311,"address":[5686595,5687993,5688051,5686537],"length":1,"stats":{"Line":34},"fn_name":null},{"line":312,"address":[5688092,5686636],"length":1,"stats":{"Line":14},"fn_name":null},{"line":313,"address":[5688182,5686726],"length":1,"stats":{"Line":16},"fn_name":null},{"line":316,"address":[5686750,5688206],"length":1,"stats":{"Line":20},"fn_name":null},{"line":317,"address":[5688242,5686786],"length":1,"stats":{"Line":19},"fn_name":null},{"line":318,"address":[5688399,5686853,5686943,5688309],"length":1,"stats":{"Line":40},"fn_name":null},{"line":319,"address":[5688318,5686862],"length":1,"stats":{"Line":19},"fn_name":null},{"line":320,"address":[5687653,5688322,5689109,5686866],"length":1,"stats":{"Line":21},"fn_name":null},{"line":322,"address":[5687715,5687005,5687684,5688461,5689140,5689171],"length":1,"stats":{"Line":21},"fn_name":null},{"line":324,"address":[5687128,5688584],"length":1,"stats":{"Line":19},"fn_name":null},{"line":326,"address":[5688608,5687152],"length":1,"stats":{"Line":16},"fn_name":null},{"line":327,"address":[5687196,5688652],"length":1,"stats":{"Line":16},"fn_name":null},{"line":328,"address":[5687247,5688703],"length":1,"stats":{"Line":16},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[5687263,5688719],"length":1,"stats":{"Line":17},"fn_name":null},{"line":332,"address":[5687609,5689065,5687523,5687316,5688772,5688979],"length":1,"stats":{"Line":36},"fn_name":null},{"line":333,"address":[5687595,5689051],"length":1,"stats":{"Line":16},"fn_name":null},{"line":335,"address":[5687518,5688974],"length":1,"stats":{"Line":18},"fn_name":null},{"line":343,"address":[4482532,4482496],"length":1,"stats":{"Line":25},"fn_name":"new"},{"line":344,"address":[4482507,4482553],"length":1,"stats":{"Line":46},"fn_name":null},{"line":347,"address":[4482688,4482752],"length":1,"stats":{"Line":13},"fn_name":"resize"},{"line":348,"address":[4482719,4482777],"length":1,"stats":{"Line":26},"fn_name":null},{"line":349,"address":[4482816],"length":1,"stats":{"Line":11},"fn_name":null},{"line":351,"address":[4483121,4482836,4482787],"length":1,"stats":{"Line":26},"fn_name":null},{"line":352,"address":[4482840,4482922],"length":1,"stats":{"Line":13},"fn_name":null},{"line":353,"address":[4482974,4482867,4483171],"length":1,"stats":{"Line":26},"fn_name":null},{"line":356,"address":[4483232],"length":1,"stats":{"Line":8},"fn_name":"caps"},{"line":357,"address":[4483385,4483246],"length":1,"stats":{"Line":10},"fn_name":null},{"line":358,"address":[4483445,4483286,4483415],"length":1,"stats":{"Line":8},"fn_name":null}],"covered":112,"coverable":122},{"path":["/","usr","src","regex","src","prog.rs"],"content":"use std::cmp::Ordering;\nuse std::collections::HashMap;\nuse std::fmt;\nuse std::mem;\nuse std::ops::Deref;\nuse std::slice;\nuse std::sync::Arc;\n\nuse input::Char;\nuse literal::LiteralSearcher;\n\n/// `InstPtr` represents the index of an instruction in a regex program.\npub type InstPtr = usize;\n\n/// Program is a sequence of instructions and various facts about thos\n/// instructions.\n#[derive(Clone)]\npub struct Program {\n    /// A sequence of instructions that represents an NFA.\n    pub insts: Vec<Inst>,\n    /// Pointers to each Match instruction in the sequence.\n    ///\n    /// This is always length 1 unless this program represents a regex set.\n    pub matches: Vec<InstPtr>,\n    /// The ordered sequence of all capture groups extracted from the AST.\n    /// Unnamed groups are `None`.\n    pub captures: Vec<Option<String>>,\n    /// Pointers to all named capture groups into `captures`.\n    pub capture_name_idx: Arc<HashMap<String, usize>>,\n    /// A pointer to the start instruction. This can vary depending on how\n    /// the program was compiled. For example, programs for use with the DFA\n    /// engine have a `.*?` inserted at the beginning of unanchored regular\n    /// expressions. The actual starting point of the program is after the\n    /// `.*?`.\n    pub start: InstPtr,\n    /// A set of equivalence classes for discriminating bytes in the compiled\n    /// program.\n    pub byte_classes: Vec<u8>,\n    /// When true, this program can only match valid UTF-8.\n    pub only_utf8: bool,\n    /// When true, this program uses byte range instructions instead of Unicode\n    /// range instructions.\n    pub is_bytes: bool,\n    /// When true, the program is compiled for DFA matching. For example, this\n    /// implies `is_bytes` and also inserts a preceding `.*?` for unanchored\n    /// regexes.\n    pub is_dfa: bool,\n    /// When true, the program matches text in reverse (for use only in the\n    /// DFA).\n    pub is_reverse: bool,\n    /// Whether the regex must match from the start of the input.\n    pub is_anchored_start: bool,\n    /// Whether the regex must match at the end of the input.\n    pub is_anchored_end: bool,\n    /// Whether this program contains a Unicode word boundary instruction.\n    pub has_unicode_word_boundary: bool,\n    /// A possibly empty machine for very quickly matching prefix literals.\n    pub prefixes: LiteralSearcher,\n    /// A limit on the size of the cache that the DFA is allowed to use while\n    /// matching.\n    ///\n    /// The cache limit specifies approximately how much space we're willing to\n    /// give to the state cache. Once the state cache exceeds the size, it is\n    /// wiped and all states must be re-computed.\n    ///\n    /// Note that this value does not impact correctness. It can be set to 0\n    /// and the DFA will run just fine. (It will only ever store exactly one\n    /// state in the cache, and will likely run very slowly, but it will work.)\n    ///\n    /// Also note that this limit is *per thread of execution*. That is,\n    /// if the same regex is used to search text across multiple threads\n    /// simultaneously, then the DFA cache is not shared. Instead, copies are\n    /// made.\n    pub dfa_size_limit: usize,\n}\n\nimpl Program {\n    /// Creates an empty instruction sequence. Fields are given default\n    /// values.\n    pub fn new() -> Self {\n        Program {\n            insts: vec![],\n            matches: vec![],\n            captures: vec![],\n            capture_name_idx: Arc::new(HashMap::new()),\n            start: 0,\n            byte_classes: vec![0; 256],\n            only_utf8: true,\n            is_bytes: false,\n            is_dfa: false,\n            is_reverse: false,\n            is_anchored_start: false,\n            is_anchored_end: false,\n            has_unicode_word_boundary: false,\n            prefixes: LiteralSearcher::empty(),\n            dfa_size_limit: 2 * (1 << 20),\n        }\n    }\n\n    /// If pc is an index to a no-op instruction (like Save), then return the\n    /// next pc that is not a no-op instruction.\n    pub fn skip(&self, mut pc: usize) -> usize {\n        loop {\n            match self[pc] {\n                Inst::Save(ref i) => pc = i.goto,\n                _ => return pc,\n            }\n        }\n    }\n\n    /// Return true if and only if an execution engine at instruction `pc` will\n    /// always lead to a match.\n    pub fn leads_to_match(&self, pc: usize) -> bool {\n        if self.matches.len() > 1 {\n            // If we have a regex set, then we have more than one ending\n            // state, so leading to one of those states is generally\n            // meaningless.\n            return false;\n        }\n        match self[self.skip(pc)] {\n            Inst::Match(_) => true,\n            _ => false,\n        }\n    }\n\n    /// Returns true if the current configuration demands that an implicit\n    /// `.*?` be prepended to the instruction sequence.\n    pub fn needs_dotstar(&self) -> bool {\n        self.is_dfa && !self.is_reverse && !self.is_anchored_start\n    }\n\n    /// Returns true if this program uses Byte instructions instead of\n    /// Char/Range instructions.\n    pub fn uses_bytes(&self) -> bool {\n        self.is_bytes || self.is_dfa\n    }\n\n    /// Returns true if this program exclusively matches valid UTF-8 bytes.\n    ///\n    /// That is, if an invalid UTF-8 byte is seen, then no match is possible.\n    pub fn only_utf8(&self) -> bool {\n        self.only_utf8\n    }\n\n    /// Return the approximate heap usage of this instruction sequence in\n    /// bytes.\n    pub fn approximate_size(&self) -> usize {\n        // The only instruction that uses heap space is Ranges (for\n        // Unicode codepoint programs) to store non-overlapping codepoint\n        // ranges. To keep this operation constant time, we ignore them.\n        (self.len() * mem::size_of::<Inst>())\n            + (self.matches.len() * mem::size_of::<InstPtr>())\n            + (self.captures.len() * mem::size_of::<Option<String>>())\n            + (self.capture_name_idx.len()\n                * (mem::size_of::<String>() + mem::size_of::<usize>()))\n            + (self.byte_classes.len() * mem::size_of::<u8>())\n            + self.prefixes.approximate_size()\n    }\n}\n\nimpl Deref for Program {\n    type Target = [Inst];\n\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn deref(&self) -> &Self::Target {\n        &*self.insts\n    }\n}\n\nimpl fmt::Debug for Program {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        use self::Inst::*;\n\n        fn with_goto(cur: usize, goto: usize, fmtd: String) -> String {\n            if goto == cur + 1 {\n                fmtd\n            } else {\n                format!(\"{} (goto: {})\", fmtd, goto)\n            }\n        }\n\n        fn visible_byte(b: u8) -> String {\n            use std::ascii::escape_default;\n            let escaped = escape_default(b).collect::<Vec<u8>>();\n            String::from_utf8_lossy(&escaped).into_owned()\n        }\n\n        for (pc, inst) in self.iter().enumerate() {\n            match *inst {\n                Match(slot) => write!(f, \"{:04} Match({:?})\", pc, slot)?,\n                Save(ref inst) => {\n                    let s = format!(\"{:04} Save({})\", pc, inst.slot);\n                    write!(f, \"{}\", with_goto(pc, inst.goto, s))?;\n                }\n                Split(ref inst) => {\n                    write!(\n                        f,\n                        \"{:04} Split({}, {})\",\n                        pc, inst.goto1, inst.goto2\n                    )?;\n                }\n                EmptyLook(ref inst) => {\n                    let s = format!(\"{:?}\", inst.look);\n                    write!(f, \"{:04} {}\", pc, with_goto(pc, inst.goto, s))?;\n                }\n                Char(ref inst) => {\n                    let s = format!(\"{:?}\", inst.c);\n                    write!(f, \"{:04} {}\", pc, with_goto(pc, inst.goto, s))?;\n                }\n                Ranges(ref inst) => {\n                    let ranges = inst\n                        .ranges\n                        .iter()\n                        .map(|r| format!(\"{:?}-{:?}\", r.0, r.1))\n                        .collect::<Vec<String>>()\n                        .join(\", \");\n                    write!(\n                        f,\n                        \"{:04} {}\",\n                        pc,\n                        with_goto(pc, inst.goto, ranges)\n                    )?;\n                }\n                Bytes(ref inst) => {\n                    let s = format!(\n                        \"Bytes({}, {})\",\n                        visible_byte(inst.start),\n                        visible_byte(inst.end)\n                    );\n                    write!(f, \"{:04} {}\", pc, with_goto(pc, inst.goto, s))?;\n                }\n            }\n            if pc == self.start {\n                write!(f, \" (start)\")?;\n            }\n            write!(f, \"\\n\")?;\n        }\n        Ok(())\n    }\n}\n\nimpl<'a> IntoIterator for &'a Program {\n    type Item = &'a Inst;\n    type IntoIter = slice::Iter<'a, Inst>;\n    fn into_iter(self) -> Self::IntoIter {\n        self.iter()\n    }\n}\n\n/// Inst is an instruction code in a Regex program.\n///\n/// Regrettably, a regex program either contains Unicode codepoint\n/// instructions (Char and Ranges) or it contains byte instructions (Bytes).\n/// A regex program can never contain both.\n///\n/// It would be worth investigating splitting this into two distinct types and\n/// then figuring out how to make the matching engines polymorphic over those\n/// types without sacrificing performance.\n///\n/// Other than the benefit of moving invariants into the type system, another\n/// benefit is the decreased size. If we remove the `Char` and `Ranges`\n/// instructions from the `Inst` enum, then its size shrinks from 40 bytes to\n/// 24 bytes. (This is because of the removal of a `Vec` in the `Ranges`\n/// variant.) Given that byte based machines are typically much bigger than\n/// their Unicode analogues (because they can decode UTF-8 directly), this ends\n/// up being a pretty significant savings.\n#[derive(Clone, Debug)]\npub enum Inst {\n    /// Match indicates that the program has reached a match state.\n    ///\n    /// The number in the match corresponds to the Nth logical regular\n    /// expression in this program. This index is always 0 for normal regex\n    /// programs. Values greater than 0 appear when compiling regex sets, and\n    /// each match instruction gets its own unique value. The value corresponds\n    /// to the Nth regex in the set.\n    Match(usize),\n    /// Save causes the program to save the current location of the input in\n    /// the slot indicated by InstSave.\n    Save(InstSave),\n    /// Split causes the program to diverge to one of two paths in the\n    /// program, preferring goto1 in InstSplit.\n    Split(InstSplit),\n    /// EmptyLook represents a zero-width assertion in a regex program. A\n    /// zero-width assertion does not consume any of the input text.\n    EmptyLook(InstEmptyLook),\n    /// Char requires the regex program to match the character in InstChar at\n    /// the current position in the input.\n    Char(InstChar),\n    /// Ranges requires the regex program to match the character at the current\n    /// position in the input with one of the ranges specified in InstRanges.\n    Ranges(InstRanges),\n    /// Bytes is like Ranges, except it expresses a single byte range. It is\n    /// used in conjunction with Split instructions to implement multi-byte\n    /// character classes.\n    Bytes(InstBytes),\n}\n\nimpl Inst {\n    /// Returns true if and only if this is a match instruction.\n    pub fn is_match(&self) -> bool {\n        match *self {\n            Inst::Match(_) => true,\n            _ => false,\n        }\n    }\n}\n\n/// Representation of the Save instruction.\n#[derive(Clone, Debug)]\npub struct InstSave {\n    /// The next location to execute in the program.\n    pub goto: InstPtr,\n    /// The capture slot (there are two slots for every capture in a regex,\n    /// including the zeroth capture for the entire match).\n    pub slot: usize,\n}\n\n/// Representation of the Split instruction.\n#[derive(Clone, Debug)]\npub struct InstSplit {\n    /// The first instruction to try. A match resulting from following goto1\n    /// has precedence over a match resulting from following goto2.\n    pub goto1: InstPtr,\n    /// The second instruction to try. A match resulting from following goto1\n    /// has precedence over a match resulting from following goto2.\n    pub goto2: InstPtr,\n}\n\n/// Representation of the `EmptyLook` instruction.\n#[derive(Clone, Debug)]\npub struct InstEmptyLook {\n    /// The next location to execute in the program if this instruction\n    /// succeeds.\n    pub goto: InstPtr,\n    /// The type of zero-width assertion to check.\n    pub look: EmptyLook,\n}\n\n/// The set of zero-width match instructions.\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\npub enum EmptyLook {\n    /// Start of line or input.\n    StartLine,\n    /// End of line or input.\n    EndLine,\n    /// Start of input.\n    StartText,\n    /// End of input.\n    EndText,\n    /// Word character on one side and non-word character on other.\n    WordBoundary,\n    /// Word character on both sides or non-word character on both sides.\n    NotWordBoundary,\n    /// ASCII word boundary.\n    WordBoundaryAscii,\n    /// Not ASCII word boundary.\n    NotWordBoundaryAscii,\n}\n\n/// Representation of the Char instruction.\n#[derive(Clone, Debug)]\npub struct InstChar {\n    /// The next location to execute in the program if this instruction\n    /// succeeds.\n    pub goto: InstPtr,\n    /// The character to test.\n    pub c: char,\n}\n\n/// Representation of the Ranges instruction.\n#[derive(Clone, Debug)]\npub struct InstRanges {\n    /// The next location to execute in the program if this instruction\n    /// succeeds.\n    pub goto: InstPtr,\n    /// The set of Unicode scalar value ranges to test.\n    pub ranges: Vec<(char, char)>,\n}\n\nimpl InstRanges {\n    /// Tests whether the given input character matches this instruction.\n    pub fn matches(&self, c: Char) -> bool {\n        // This speeds up the `match_class_unicode` benchmark by checking\n        // some common cases quickly without binary search. e.g., Matching\n        // a Unicode class on predominantly ASCII text.\n        for r in self.ranges.iter().take(4) {\n            if c < r.0 {\n                return false;\n            }\n            if c <= r.1 {\n                return true;\n            }\n        }\n        self.ranges\n            .binary_search_by(|r| {\n                if r.1 < c {\n                    Ordering::Less\n                } else if r.0 > c {\n                    Ordering::Greater\n                } else {\n                    Ordering::Equal\n                }\n            })\n            .is_ok()\n    }\n\n    /// Return the number of distinct characters represented by all of the\n    /// ranges.\n    pub fn num_chars(&self) -> usize {\n        self.ranges\n            .iter()\n            .map(|&(s, e)| 1 + (e as u32) - (s as u32))\n            .sum::<u32>() as usize\n    }\n}\n\n/// Representation of the Bytes instruction.\n#[derive(Clone, Debug)]\npub struct InstBytes {\n    /// The next location to execute in the program if this instruction\n    /// succeeds.\n    pub goto: InstPtr,\n    /// The start (inclusive) of this byte range.\n    pub start: u8,\n    /// The end (inclusive) of this byte range.\n    pub end: u8,\n}\n\nimpl InstBytes {\n    /// Returns true if and only if the given byte is in this range.\n    pub fn matches(&self, byte: u8) -> bool {\n        self.start <= byte && byte <= self.end\n    }\n}\n","traces":[{"line":80,"address":[5047968,5048032],"length":1,"stats":{"Line":27},"fn_name":"new"},{"line":82,"address":[5047995],"length":1,"stats":{"Line":27},"fn_name":null},{"line":83,"address":[5048056],"length":1,"stats":{"Line":27},"fn_name":null},{"line":84,"address":[5048114],"length":1,"stats":{"Line":27},"fn_name":null},{"line":85,"address":[5048195,5048168],"length":1,"stats":{"Line":54},"fn_name":null},{"line":87,"address":[5048220],"length":1,"stats":{"Line":27},"fn_name":null},{"line":95,"address":[5048269],"length":1,"stats":{"Line":27},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[5048688],"length":1,"stats":{"Line":0},"fn_name":"skip"},{"line":103,"address":[5048849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[5048741,5048854,5048882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[5048810,5048774],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[5048795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[5048896],"length":1,"stats":{"Line":0},"fn_name":"leads_to_match"},{"line":114,"address":[5048910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[5048990],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[5048988,5049083,5049092,5049120,5049019],"length":1,"stats":{"Line":2},"fn_name":"needs_dotstar"},{"line":121,"address":[5049085,5049057],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[5049078],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[5049120],"length":1,"stats":{"Line":25},"fn_name":"needs_dotstar"},{"line":129,"address":[5049129,5049192],"length":1,"stats":{"Line":54},"fn_name":null},{"line":134,"address":[5049248],"length":1,"stats":{"Line":27},"fn_name":"uses_bytes"},{"line":135,"address":[5049257],"length":1,"stats":{"Line":27},"fn_name":null},{"line":141,"address":[5049328],"length":1,"stats":{"Line":8},"fn_name":"only_utf8"},{"line":142,"address":[5049333],"length":1,"stats":{"Line":8},"fn_name":null},{"line":147,"address":[5049360],"length":1,"stats":{"Line":8},"fn_name":"approximate_size"},{"line":151,"address":[5050205,5050265,5049497,5050355,5049764,5049948,5049638,5049440,5050145,5050114,5050063,5050415,5050475],"length":1,"stats":{"Line":56},"fn_name":null},{"line":152,"address":[5050175,5049530,5049597],"length":1,"stats":{"Line":16},"fn_name":null},{"line":153,"address":[5049669,5050235,5049729],"length":1,"stats":{"Line":16},"fn_name":null},{"line":154,"address":[5050325,5049916,5049792],"length":1,"stats":{"Line":16},"fn_name":null},{"line":155,"address":[5049886,5050295],"length":1,"stats":{"Line":8},"fn_name":null},{"line":156,"address":[5050031,5050385,5049976],"length":1,"stats":{"Line":16},"fn_name":null},{"line":157,"address":[5050091],"length":1,"stats":{"Line":8},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[4405164],"length":1,"stats":{"Line":202},"fn_name":null},{"line":171,"address":[5050480,5050570],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":174,"address":[5057292,5057200],"length":1,"stats":{"Line":0},"fn_name":"with_goto"},{"line":175,"address":[5057769,5057223,5057317,5057509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[5057469],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[5057349,5057524],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[5057869,5057824],"length":1,"stats":{"Line":0},"fn_name":"visible_byte"},{"line":184,"address":[5057839,5057881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[5057960,5057897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[5050568,5050787,5050503,5050601,5056891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[5052808,5055532,5054599,5051387,5052317,5053717,5050971,5056574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[5050853,5050988,5051392,5051422],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[5051458],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[5051472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[5051858],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[5052337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[5052367,5052813],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[5052351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[5052358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[5052849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[5052863],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[5053107],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[5053737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[5053751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[5053989],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[5054612],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[5054626],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[5932768,5932801],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":217,"address":[5055009,5055145,5055445],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[5054901],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[5054908],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[5050904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[5055572],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[5050925],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[5055545],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[5056030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[5056576,5056733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[5056610,5056735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[5056768,5056896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[5050774],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[5058032],"length":1,"stats":{"Line":13},"fn_name":"into_iter"},{"line":246,"address":[5058078],"length":1,"stats":{"Line":13},"fn_name":null},{"line":300,"address":[5058112],"length":1,"stats":{"Line":3},"fn_name":"is_match"},{"line":301,"address":[5058132],"length":1,"stats":{"Line":3},"fn_name":null},{"line":302,"address":[5058121,5058134],"length":1,"stats":{"Line":5},"fn_name":null},{"line":303,"address":[5058127],"length":1,"stats":{"Line":2},"fn_name":null},{"line":382,"address":[5058160],"length":1,"stats":{"Line":15},"fn_name":"matches"},{"line":386,"address":[5058531,5058179,5058396],"length":1,"stats":{"Line":28},"fn_name":null},{"line":387,"address":[5058430],"length":1,"stats":{"Line":15},"fn_name":null},{"line":388,"address":[5058519,5058495],"length":1,"stats":{"Line":19},"fn_name":null},{"line":390,"address":[5058470,5058525],"length":1,"stats":{"Line":30},"fn_name":null},{"line":391,"address":[5058536],"length":1,"stats":{"Line":11},"fn_name":null},{"line":394,"address":[5058367,5058556],"length":1,"stats":{"Line":26},"fn_name":null},{"line":395,"address":[5058548],"length":1,"stats":{"Line":34},"fn_name":null},{"line":396,"address":[5933118,5933197,5933221],"length":1,"stats":{"Line":33},"fn_name":null},{"line":397,"address":[5933192],"length":1,"stats":{"Line":17},"fn_name":null},{"line":398,"address":[5933175,5933214,5933203],"length":1,"stats":{"Line":19},"fn_name":null},{"line":399,"address":[5933216],"length":1,"stats":{"Line":7},"fn_name":null},{"line":401,"address":[5933209],"length":1,"stats":{"Line":5},"fn_name":null},{"line":409,"address":[5058624],"length":1,"stats":{"Line":0},"fn_name":"num_chars"},{"line":410,"address":[5058633],"length":1,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[5933232,5933246],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[5058752],"length":1,"stats":{"Line":16},"fn_name":"matches"},{"line":432,"address":[5058766],"length":1,"stats":{"Line":15},"fn_name":null}],"covered":44,"coverable":104},{"path":["/","usr","src","regex","src","re_builder.rs"],"content":"/// The set of user configurable options for compiling zero or more regexes.\n#[derive(Clone, Debug)]\n#[allow(missing_docs)]\npub struct RegexOptions {\n    pub pats: Vec<String>,\n    pub size_limit: usize,\n    pub dfa_size_limit: usize,\n    pub nest_limit: u32,\n    pub case_insensitive: bool,\n    pub multi_line: bool,\n    pub dot_matches_new_line: bool,\n    pub swap_greed: bool,\n    pub ignore_whitespace: bool,\n    pub unicode: bool,\n    pub octal: bool,\n}\n\nimpl Default for RegexOptions {\n    fn default() -> Self {\n        RegexOptions {\n            pats: vec![],\n            size_limit: 10 * (1 << 20),\n            dfa_size_limit: 2 * (1 << 20),\n            nest_limit: 250,\n            case_insensitive: false,\n            multi_line: false,\n            dot_matches_new_line: false,\n            swap_greed: false,\n            ignore_whitespace: false,\n            unicode: true,\n            octal: false,\n        }\n    }\n}\n\nmacro_rules! define_builder {\n    ($name:ident, $regex_mod:ident, $only_utf8:expr) => {\n        pub mod $name {\n            use super::RegexOptions;\n            use error::Error;\n            use exec::ExecBuilder;\n\n            use $regex_mod::Regex;\n\n            /// A configurable builder for a regular expression.\n            ///\n            /// A builder can be used to configure how the regex is built, for example, by\n            /// setting the default flags (which can be overridden in the expression\n            /// itself) or setting various limits.\n            pub struct RegexBuilder(RegexOptions);\n\n            impl RegexBuilder {\n                /// Create a new regular expression builder with the given pattern.\n                ///\n                /// If the pattern is invalid, then an error will be returned when\n                /// `build` is called.\n                pub fn new(pattern: &str) -> RegexBuilder {\n                    let mut builder = RegexBuilder(RegexOptions::default());\n                    builder.0.pats.push(pattern.to_owned());\n                    builder\n                }\n\n                /// Consume the builder and compile the regular expression.\n                ///\n                /// Note that calling `as_str` on the resulting `Regex` will produce the\n                /// pattern given to `new` verbatim. Notably, it will not incorporate any\n                /// of the flags set on this builder.\n                pub fn build(&self) -> Result<Regex, Error> {\n                    ExecBuilder::new_options(self.0.clone())\n                        .only_utf8($only_utf8)\n                        .build()\n                        .map(Regex::from)\n                }\n\n                /// Set the value for the case insensitive (`i`) flag.\n                ///\n                /// When enabled, letters in the pattern will match both upper case and\n                /// lower case variants.\n                pub fn case_insensitive(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexBuilder {\n                    self.0.case_insensitive = yes;\n                    self\n                }\n\n                /// Set the value for the multi-line matching (`m`) flag.\n                ///\n                /// When enabled, `^` matches the beginning of lines and `$` matches the\n                /// end of lines.\n                ///\n                /// By default, they match beginning/end of the input.\n                pub fn multi_line(&mut self, yes: bool) -> &mut RegexBuilder {\n                    self.0.multi_line = yes;\n                    self\n                }\n\n                /// Set the value for the any character (`s`) flag, where in `.` matches\n                /// anything when `s` is set and matches anything except for new line when\n                /// it is not set (the default).\n                ///\n                /// N.B. \"matches anything\" means \"any byte\" when Unicode is disabled and\n                /// means \"any valid UTF-8 encoding of any Unicode scalar value\" when\n                /// Unicode is enabled.\n                pub fn dot_matches_new_line(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexBuilder {\n                    self.0.dot_matches_new_line = yes;\n                    self\n                }\n\n                /// Set the value for the greedy swap (`U`) flag.\n                ///\n                /// When enabled, a pattern like `a*` is lazy (tries to find shortest\n                /// match) and `a*?` is greedy (tries to find longest match).\n                ///\n                /// By default, `a*` is greedy and `a*?` is lazy.\n                pub fn swap_greed(&mut self, yes: bool) -> &mut RegexBuilder {\n                    self.0.swap_greed = yes;\n                    self\n                }\n\n                /// Set the value for the ignore whitespace (`x`) flag.\n                ///\n                /// When enabled, whitespace such as new lines and spaces will be ignored\n                /// between expressions of the pattern, and `#` can be used to start a\n                /// comment until the next new line.\n                pub fn ignore_whitespace(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexBuilder {\n                    self.0.ignore_whitespace = yes;\n                    self\n                }\n\n                /// Set the value for the Unicode (`u`) flag.\n                ///\n                /// Enabled by default. When disabled, character classes such as `\\w` only\n                /// match ASCII word characters instead of all Unicode word characters.\n                pub fn unicode(&mut self, yes: bool) -> &mut RegexBuilder {\n                    self.0.unicode = yes;\n                    self\n                }\n\n                /// Whether to support octal syntax or not.\n                ///\n                /// Octal syntax is a little-known way of uttering Unicode codepoints in\n                /// a regular expression. For example, `a`, `\\x61`, `\\u0061` and\n                /// `\\141` are all equivalent regular expressions, where the last example\n                /// shows octal syntax.\n                ///\n                /// While supporting octal syntax isn't in and of itself a problem, it does\n                /// make good error messages harder. That is, in PCRE based regex engines,\n                /// syntax like `\\0` invokes a backreference, which is explicitly\n                /// unsupported in Rust's regex engine. However, many users expect it to\n                /// be supported. Therefore, when octal support is disabled, the error\n                /// message will explicitly mention that backreferences aren't supported.\n                ///\n                /// Octal syntax is disabled by default.\n                pub fn octal(&mut self, yes: bool) -> &mut RegexBuilder {\n                    self.0.octal = yes;\n                    self\n                }\n\n                /// Set the approximate size limit of the compiled regular expression.\n                ///\n                /// This roughly corresponds to the number of bytes occupied by a single\n                /// compiled program. If the program exceeds this number, then a\n                /// compilation error is returned.\n                pub fn size_limit(\n                    &mut self,\n                    limit: usize,\n                ) -> &mut RegexBuilder {\n                    self.0.size_limit = limit;\n                    self\n                }\n\n                /// Set the approximate size of the cache used by the DFA.\n                ///\n                /// This roughly corresponds to the number of bytes that the DFA will\n                /// use while searching.\n                ///\n                /// Note that this is a *per thread* limit. There is no way to set a global\n                /// limit. In particular, if a regex is used from multiple threads\n                /// simultaneously, then each thread may use up to the number of bytes\n                /// specified here.\n                pub fn dfa_size_limit(\n                    &mut self,\n                    limit: usize,\n                ) -> &mut RegexBuilder {\n                    self.0.dfa_size_limit = limit;\n                    self\n                }\n\n                /// Set the nesting limit for this parser.\n                ///\n                /// The nesting limit controls how deep the abstract syntax tree is allowed\n                /// to be. If the AST exceeds the given limit (e.g., with too many nested\n                /// groups), then an error is returned by the parser.\n                ///\n                /// The purpose of this limit is to act as a heuristic to prevent stack\n                /// overflow for consumers that do structural induction on an `Ast` using\n                /// explicit recursion. While this crate never does this (instead using\n                /// constant stack space and moving the call stack to the heap), other\n                /// crates may.\n                ///\n                /// This limit is not checked until the entire Ast is parsed. Therefore,\n                /// if callers want to put a limit on the amount of heap space used, then\n                /// they should impose a limit on the length, in bytes, of the concrete\n                /// pattern string. In particular, this is viable since this parser\n                /// implementation will limit itself to heap space proportional to the\n                /// length of the pattern string.\n                ///\n                /// Note that a nest limit of `0` will return a nest limit error for most\n                /// patterns but not all. For example, a nest limit of `0` permits `a` but\n                /// not `ab`, since `ab` requires a concatenation, which results in a nest\n                /// depth of `1`. In general, a nest limit is not something that manifests\n                /// in an obvious way in the concrete syntax, therefore, it should not be\n                /// used in a granular way.\n                pub fn nest_limit(&mut self, limit: u32) -> &mut RegexBuilder {\n                    self.0.nest_limit = limit;\n                    self\n                }\n            }\n        }\n    };\n}\n\ndefine_builder!(bytes, re_bytes, false);\ndefine_builder!(unicode, re_unicode, true);\n\nmacro_rules! define_set_builder {\n    ($name:ident, $regex_mod:ident, $only_utf8:expr) => {\n        pub mod $name {\n            use super::RegexOptions;\n            use error::Error;\n            use exec::ExecBuilder;\n\n            use re_set::$regex_mod::RegexSet;\n\n            /// A configurable builder for a set of regular expressions.\n            ///\n            /// A builder can be used to configure how the regexes are built, for example,\n            /// by setting the default flags (which can be overridden in the expression\n            /// itself) or setting various limits.\n            pub struct RegexSetBuilder(RegexOptions);\n\n            impl RegexSetBuilder {\n                /// Create a new regular expression builder with the given pattern.\n                ///\n                /// If the pattern is invalid, then an error will be returned when\n                /// `build` is called.\n                pub fn new<I, S>(patterns: I) -> RegexSetBuilder\n                where\n                    S: AsRef<str>,\n                    I: IntoIterator<Item = S>,\n                {\n                    let mut builder = RegexSetBuilder(RegexOptions::default());\n                    for pat in patterns {\n                        builder.0.pats.push(pat.as_ref().to_owned());\n                    }\n                    builder\n                }\n\n                /// Consume the builder and compile the regular expressions into a set.\n                pub fn build(&self) -> Result<RegexSet, Error> {\n                    ExecBuilder::new_options(self.0.clone())\n                        .only_utf8($only_utf8)\n                        .build()\n                        .map(RegexSet::from)\n                }\n\n                /// Set the value for the case insensitive (`i`) flag.\n                pub fn case_insensitive(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexSetBuilder {\n                    self.0.case_insensitive = yes;\n                    self\n                }\n\n                /// Set the value for the multi-line matching (`m`) flag.\n                pub fn multi_line(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexSetBuilder {\n                    self.0.multi_line = yes;\n                    self\n                }\n\n                /// Set the value for the any character (`s`) flag, where in `.` matches\n                /// anything when `s` is set and matches anything except for new line when\n                /// it is not set (the default).\n                ///\n                /// N.B. \"matches anything\" means \"any byte\" for `regex::bytes::RegexSet`\n                /// expressions and means \"any Unicode scalar value\" for `regex::RegexSet`\n                /// expressions.\n                pub fn dot_matches_new_line(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexSetBuilder {\n                    self.0.dot_matches_new_line = yes;\n                    self\n                }\n\n                /// Set the value for the greedy swap (`U`) flag.\n                pub fn swap_greed(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexSetBuilder {\n                    self.0.swap_greed = yes;\n                    self\n                }\n\n                /// Set the value for the ignore whitespace (`x`) flag.\n                pub fn ignore_whitespace(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexSetBuilder {\n                    self.0.ignore_whitespace = yes;\n                    self\n                }\n\n                /// Set the value for the Unicode (`u`) flag.\n                pub fn unicode(&mut self, yes: bool) -> &mut RegexSetBuilder {\n                    self.0.unicode = yes;\n                    self\n                }\n\n                /// Whether to support octal syntax or not.\n                ///\n                /// Octal syntax is a little-known way of uttering Unicode codepoints in\n                /// a regular expression. For example, `a`, `\\x61`, `\\u0061` and\n                /// `\\141` are all equivalent regular expressions, where the last example\n                /// shows octal syntax.\n                ///\n                /// While supporting octal syntax isn't in and of itself a problem, it does\n                /// make good error messages harder. That is, in PCRE based regex engines,\n                /// syntax like `\\0` invokes a backreference, which is explicitly\n                /// unsupported in Rust's regex engine. However, many users expect it to\n                /// be supported. Therefore, when octal support is disabled, the error\n                /// message will explicitly mention that backreferences aren't supported.\n                ///\n                /// Octal syntax is disabled by default.\n                pub fn octal(&mut self, yes: bool) -> &mut RegexSetBuilder {\n                    self.0.octal = yes;\n                    self\n                }\n\n                /// Set the approximate size limit of the compiled regular expression.\n                ///\n                /// This roughly corresponds to the number of bytes occupied by a single\n                /// compiled program. If the program exceeds this number, then a\n                /// compilation error is returned.\n                pub fn size_limit(\n                    &mut self,\n                    limit: usize,\n                ) -> &mut RegexSetBuilder {\n                    self.0.size_limit = limit;\n                    self\n                }\n\n                /// Set the approximate size of the cache used by the DFA.\n                ///\n                /// This roughly corresponds to the number of bytes that the DFA will\n                /// use while searching.\n                ///\n                /// Note that this is a *per thread* limit. There is no way to set a global\n                /// limit. In particular, if a regex is used from multiple threads\n                /// simultaneously, then each thread may use up to the number of bytes\n                /// specified here.\n                pub fn dfa_size_limit(\n                    &mut self,\n                    limit: usize,\n                ) -> &mut RegexSetBuilder {\n                    self.0.dfa_size_limit = limit;\n                    self\n                }\n\n                /// Set the nesting limit for this parser.\n                ///\n                /// The nesting limit controls how deep the abstract syntax tree is allowed\n                /// to be. If the AST exceeds the given limit (e.g., with too many nested\n                /// groups), then an error is returned by the parser.\n                ///\n                /// The purpose of this limit is to act as a heuristic to prevent stack\n                /// overflow for consumers that do structural induction on an `Ast` using\n                /// explicit recursion. While this crate never does this (instead using\n                /// constant stack space and moving the call stack to the heap), other\n                /// crates may.\n                ///\n                /// This limit is not checked until the entire Ast is parsed. Therefore,\n                /// if callers want to put a limit on the amount of heap space used, then\n                /// they should impose a limit on the length, in bytes, of the concrete\n                /// pattern string. In particular, this is viable since this parser\n                /// implementation will limit itself to heap space proportional to the\n                /// length of the pattern string.\n                ///\n                /// Note that a nest limit of `0` will return a nest limit error for most\n                /// patterns but not all. For example, a nest limit of `0` permits `a` but\n                /// not `ab`, since `ab` requires a concatenation, which results in a nest\n                /// depth of `1`. In general, a nest limit is not something that manifests\n                /// in an obvious way in the concrete syntax, therefore, it should not be\n                /// used in a granular way.\n                pub fn nest_limit(\n                    &mut self,\n                    limit: u32,\n                ) -> &mut RegexSetBuilder {\n                    self.0.nest_limit = limit;\n                    self\n                }\n            }\n        }\n    };\n}\n\ndefine_set_builder!(set_bytes, bytes, false);\ndefine_set_builder!(set_unicode, unicode, true);\n","traces":[{"line":19,"address":[5803344],"length":1,"stats":{"Line":21},"fn_name":"default"},{"line":21,"address":[5803360],"length":1,"stats":{"Line":16},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[4610701,4610640],"length":1,"stats":{"Line":16},"fn_name":"new"},{"line":58,"address":[4681164,4681114],"length":1,"stats":{"Line":40},"fn_name":null},{"line":59,"address":[4681228],"length":1,"stats":{"Line":22},"fn_name":null},{"line":60,"address":[4681292],"length":1,"stats":{"Line":22},"fn_name":null},{"line":68,"address":[4681344],"length":1,"stats":{"Line":21},"fn_name":"build"},{"line":69,"address":[4681362],"length":1,"stats":{"Line":21},"fn_name":null},{"line":79,"address":[4681488],"length":1,"stats":{"Line":0},"fn_name":"case_insensitive"},{"line":83,"address":[4681505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[4611072],"length":1,"stats":{"Line":0},"fn_name":"multi_line"},{"line":94,"address":[4611089],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[4611120],"length":1,"stats":{"Line":0},"fn_name":"dot_matches_new_line"},{"line":109,"address":[4611137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[4611168],"length":1,"stats":{"Line":0},"fn_name":"swap_greed"},{"line":120,"address":[4611185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[4611216],"length":1,"stats":{"Line":0},"fn_name":"ignore_whitespace"},{"line":133,"address":[4611233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[4681728],"length":1,"stats":{"Line":0},"fn_name":"unicode"},{"line":142,"address":[4611281],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[4681776],"length":1,"stats":{"Line":1},"fn_name":"octal"},{"line":162,"address":[4611329],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[4611360],"length":1,"stats":{"Line":0},"fn_name":"size_limit"},{"line":175,"address":[4611373],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[4611392],"length":1,"stats":{"Line":0},"fn_name":"dfa_size_limit"},{"line":192,"address":[4611405],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[4611424],"length":1,"stats":{"Line":0},"fn_name":"nest_limit"},{"line":222,"address":[4611436],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[4213391,4214608,4214687,4214044,4213952,4213312],"length":1,"stats":{"Line":9},"fn_name":"new<&[&str; 1],&&str>"},{"line":259,"address":[4213406,4213330,4214059,4213978,4214626,4214702],"length":1,"stats":{"Line":18},"fn_name":null},{"line":260,"address":[4214224,4214114,4213539,4213768,4214193,4213570,4214831,4214862,4213461,4215060,4214420,4214757],"length":1,"stats":{"Line":34},"fn_name":null},{"line":261,"address":[4214377,4214386,4215026,4215017,4213734,4214952,4213660,4213725,4214314],"length":1,"stats":{"Line":23},"fn_name":null},{"line":263,"address":[4214430,4213778,4215070],"length":1,"stats":{"Line":10},"fn_name":null},{"line":267,"address":[5673632],"length":1,"stats":{"Line":3},"fn_name":"build"},{"line":268,"address":[5673650],"length":1,"stats":{"Line":4},"fn_name":null},{"line":275,"address":[5673760],"length":1,"stats":{"Line":0},"fn_name":"case_insensitive"},{"line":279,"address":[5673777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[5673808],"length":1,"stats":{"Line":0},"fn_name":"multi_line"},{"line":288,"address":[5673825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[5673856],"length":1,"stats":{"Line":0},"fn_name":"dot_matches_new_line"},{"line":303,"address":[5673873],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[5673904],"length":1,"stats":{"Line":0},"fn_name":"swap_greed"},{"line":312,"address":[5673921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[5673952],"length":1,"stats":{"Line":0},"fn_name":"ignore_whitespace"},{"line":321,"address":[5673969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[5674000],"length":1,"stats":{"Line":0},"fn_name":"unicode"},{"line":327,"address":[5674017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[5674048],"length":1,"stats":{"Line":0},"fn_name":"octal"},{"line":347,"address":[5674065],"length":1,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[5674096],"length":1,"stats":{"Line":0},"fn_name":"size_limit"},{"line":360,"address":[5674109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[5674128],"length":1,"stats":{"Line":0},"fn_name":"dfa_size_limit"},{"line":377,"address":[5674141],"length":1,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[5674160],"length":1,"stats":{"Line":0},"fn_name":"nest_limit"},{"line":410,"address":[5674172],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":17,"coverable":57},{"path":["/","usr","src","regex","src","re_bytes.rs"],"content":"use std::borrow::Cow;\nuse std::collections::HashMap;\nuse std::fmt;\nuse std::ops::{Index, Range};\nuse std::str::FromStr;\nuse std::sync::Arc;\n\nuse find_byte::find_byte;\n\nuse error::Error;\nuse exec::{Exec, ExecNoSync};\nuse expand::expand_bytes;\nuse re_builder::bytes::RegexBuilder;\nuse re_trait::{self, RegularExpression, SubCapturesPosIter};\n\n/// Match represents a single match of a regex in a haystack.\n///\n/// The lifetime parameter `'t` refers to the lifetime of the matched text.\n#[derive(Copy, Clone, Debug, Eq, PartialEq)]\npub struct Match<'t> {\n    text: &'t [u8],\n    start: usize,\n    end: usize,\n}\n\nimpl<'t> Match<'t> {\n    /// Returns the starting byte offset of the match in the haystack.\n    #[inline]\n    pub fn start(&self) -> usize {\n        self.start\n    }\n\n    /// Returns the ending byte offset of the match in the haystack.\n    #[inline]\n    pub fn end(&self) -> usize {\n        self.end\n    }\n\n    /// Returns the range over the starting and ending byte offsets of the\n    /// match in the haystack.\n    #[inline]\n    pub fn range(&self) -> Range<usize> {\n        self.start..self.end\n    }\n\n    /// Returns the matched text.\n    #[inline]\n    pub fn as_bytes(&self) -> &'t [u8] {\n        &self.text[self.range()]\n    }\n\n    /// Creates a new match from the given haystack and byte offsets.\n    #[inline]\n    fn new(haystack: &'t [u8], start: usize, end: usize) -> Match<'t> {\n        Match { text: haystack, start: start, end: end }\n    }\n}\n\nimpl<'t> From<Match<'t>> for Range<usize> {\n    fn from(m: Match<'t>) -> Range<usize> {\n        m.range()\n    }\n}\n\n/// A compiled regular expression for matching arbitrary bytes.\n///\n/// It can be used to search, split or replace text. All searching is done with\n/// an implicit `.*?` at the beginning and end of an expression. To force an\n/// expression to match the whole string (or a prefix or a suffix), you must\n/// use an anchor like `^` or `$` (or `\\A` and `\\z`).\n///\n/// Like the `Regex` type in the parent module, matches with this regex return\n/// byte offsets into the search text. **Unlike** the parent `Regex` type,\n/// these byte offsets may not correspond to UTF-8 sequence boundaries since\n/// the regexes in this module can match arbitrary bytes.\n#[derive(Clone)]\npub struct Regex(Exec);\n\nimpl fmt::Display for Regex {\n    /// Shows the original regular expression.\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{}\", self.as_str())\n    }\n}\n\nimpl fmt::Debug for Regex {\n    /// Shows the original regular expression.\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Display::fmt(self, f)\n    }\n}\n\n/// A constructor for Regex from an Exec.\n///\n/// This is hidden because Exec isn't actually part of the public API.\n#[doc(hidden)]\nimpl From<Exec> for Regex {\n    fn from(exec: Exec) -> Regex {\n        Regex(exec)\n    }\n}\n\nimpl FromStr for Regex {\n    type Err = Error;\n\n    /// Attempts to parse a string into a regular expression\n    fn from_str(s: &str) -> Result<Regex, Error> {\n        Regex::new(s)\n    }\n}\n\n/// Core regular expression methods.\nimpl Regex {\n    /// Compiles a regular expression. Once compiled, it can be used repeatedly\n    /// to search, split or replace text in a string.\n    ///\n    /// If an invalid expression is given, then an error is returned.\n    pub fn new(re: &str) -> Result<Regex, Error> {\n        RegexBuilder::new(re).build()\n    }\n\n    /// Returns true if and only if the regex matches the string given.\n    ///\n    /// It is recommended to use this method if all you need to do is test\n    /// a match, since the underlying matching engine may be able to do less\n    /// work.\n    ///\n    /// # Example\n    ///\n    /// Test if some text contains at least one word with exactly 13 ASCII word\n    /// bytes:\n    ///\n    /// ```rust\n    /// # extern crate regex; use regex::bytes::Regex;\n    /// # fn main() {\n    /// let text = b\"I categorically deny having triskaidekaphobia.\";\n    /// assert!(Regex::new(r\"\\b\\w{13}\\b\").unwrap().is_match(text));\n    /// # }\n    /// ```\n    pub fn is_match(&self, text: &[u8]) -> bool {\n        self.is_match_at(text, 0)\n    }\n\n    /// Returns the start and end byte range of the leftmost-first match in\n    /// `text`. If no match exists, then `None` is returned.\n    ///\n    /// Note that this should only be used if you want to discover the position\n    /// of the match. Testing the existence of a match is faster if you use\n    /// `is_match`.\n    ///\n    /// # Example\n    ///\n    /// Find the start and end location of the first word with exactly 13\n    /// ASCII word bytes:\n    ///\n    /// ```rust\n    /// # extern crate regex; use regex::bytes::Regex;\n    /// # fn main() {\n    /// let text = b\"I categorically deny having triskaidekaphobia.\";\n    /// let mat = Regex::new(r\"\\b\\w{13}\\b\").unwrap().find(text).unwrap();\n    /// assert_eq!((mat.start(), mat.end()), (2, 15));\n    /// # }\n    /// ```\n    pub fn find<'t>(&self, text: &'t [u8]) -> Option<Match<'t>> {\n        self.find_at(text, 0)\n    }\n\n    /// Returns an iterator for each successive non-overlapping match in\n    /// `text`, returning the start and end byte indices with respect to\n    /// `text`.\n    ///\n    /// # Example\n    ///\n    /// Find the start and end location of every word with exactly 13 ASCII\n    /// word bytes:\n    ///\n    /// ```rust\n    /// # extern crate regex; use regex::bytes::Regex;\n    /// # fn main() {\n    /// let text = b\"Retroactively relinquishing remunerations is reprehensible.\";\n    /// for mat in Regex::new(r\"\\b\\w{13}\\b\").unwrap().find_iter(text) {\n    ///     println!(\"{:?}\", mat);\n    /// }\n    /// # }\n    /// ```\n    pub fn find_iter<'r, 't>(&'r self, text: &'t [u8]) -> Matches<'r, 't> {\n        Matches(self.0.searcher().find_iter(text))\n    }\n\n    /// Returns the capture groups corresponding to the leftmost-first\n    /// match in `text`. Capture group `0` always corresponds to the entire\n    /// match. If no match is found, then `None` is returned.\n    ///\n    /// You should only use `captures` if you need access to the location of\n    /// capturing group matches. Otherwise, `find` is faster for discovering\n    /// the location of the overall match.\n    ///\n    /// # Examples\n    ///\n    /// Say you have some text with movie names and their release years,\n    /// like \"'Citizen Kane' (1941)\". It'd be nice if we could search for text\n    /// looking like that, while also extracting the movie name and its release\n    /// year separately.\n    ///\n    /// ```rust\n    /// # extern crate regex; use regex::bytes::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(r\"'([^']+)'\\s+\\((\\d{4})\\)\").unwrap();\n    /// let text = b\"Not my favorite movie: 'Citizen Kane' (1941).\";\n    /// let caps = re.captures(text).unwrap();\n    /// assert_eq!(caps.get(1).unwrap().as_bytes(), &b\"Citizen Kane\"[..]);\n    /// assert_eq!(caps.get(2).unwrap().as_bytes(), &b\"1941\"[..]);\n    /// assert_eq!(caps.get(0).unwrap().as_bytes(), &b\"'Citizen Kane' (1941)\"[..]);\n    /// // You can also access the groups by index using the Index notation.\n    /// // Note that this will panic on an invalid index.\n    /// assert_eq!(&caps[1], b\"Citizen Kane\");\n    /// assert_eq!(&caps[2], b\"1941\");\n    /// assert_eq!(&caps[0], b\"'Citizen Kane' (1941)\");\n    /// # }\n    /// ```\n    ///\n    /// Note that the full match is at capture group `0`. Each subsequent\n    /// capture group is indexed by the order of its opening `(`.\n    ///\n    /// We can make this example a bit clearer by using *named* capture groups:\n    ///\n    /// ```rust\n    /// # extern crate regex; use regex::bytes::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(r\"'(?P<title>[^']+)'\\s+\\((?P<year>\\d{4})\\)\")\n    ///                .unwrap();\n    /// let text = b\"Not my favorite movie: 'Citizen Kane' (1941).\";\n    /// let caps = re.captures(text).unwrap();\n    /// assert_eq!(caps.name(\"title\").unwrap().as_bytes(), b\"Citizen Kane\");\n    /// assert_eq!(caps.name(\"year\").unwrap().as_bytes(), b\"1941\");\n    /// assert_eq!(caps.get(0).unwrap().as_bytes(), &b\"'Citizen Kane' (1941)\"[..]);\n    /// // You can also access the groups by name using the Index notation.\n    /// // Note that this will panic on an invalid group name.\n    /// assert_eq!(&caps[\"title\"], b\"Citizen Kane\");\n    /// assert_eq!(&caps[\"year\"], b\"1941\");\n    /// assert_eq!(&caps[0], b\"'Citizen Kane' (1941)\");\n    ///\n    /// # }\n    /// ```\n    ///\n    /// Here we name the capture groups, which we can access with the `name`\n    /// method or the `Index` notation with a `&str`. Note that the named\n    /// capture groups are still accessible with `get` or the `Index` notation\n    /// with a `usize`.\n    ///\n    /// The `0`th capture group is always unnamed, so it must always be\n    /// accessed with `get(0)` or `[0]`.\n    pub fn captures<'t>(&self, text: &'t [u8]) -> Option<Captures<'t>> {\n        let mut locs = self.capture_locations();\n        self.captures_read_at(&mut locs, text, 0).map(move |_| Captures {\n            text: text,\n            locs: locs.0,\n            named_groups: self.0.capture_name_idx().clone(),\n        })\n    }\n\n    /// Returns an iterator over all the non-overlapping capture groups matched\n    /// in `text`. This is operationally the same as `find_iter`, except it\n    /// yields information about capturing group matches.\n    ///\n    /// # Example\n    ///\n    /// We can use this to find all movie titles and their release years in\n    /// some text, where the movie is formatted like \"'Title' (xxxx)\":\n    ///\n    /// ```rust\n    /// # extern crate regex; use std::str; use regex::bytes::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(r\"'(?P<title>[^']+)'\\s+\\((?P<year>\\d{4})\\)\")\n    ///                .unwrap();\n    /// let text = b\"'Citizen Kane' (1941), 'The Wizard of Oz' (1939), 'M' (1931).\";\n    /// for caps in re.captures_iter(text) {\n    ///     let title = str::from_utf8(&caps[\"title\"]).unwrap();\n    ///     let year = str::from_utf8(&caps[\"year\"]).unwrap();\n    ///     println!(\"Movie: {:?}, Released: {:?}\", title, year);\n    /// }\n    /// // Output:\n    /// // Movie: Citizen Kane, Released: 1941\n    /// // Movie: The Wizard of Oz, Released: 1939\n    /// // Movie: M, Released: 1931\n    /// # }\n    /// ```\n    pub fn captures_iter<'r, 't>(\n        &'r self,\n        text: &'t [u8],\n    ) -> CaptureMatches<'r, 't> {\n        CaptureMatches(self.0.searcher().captures_iter(text))\n    }\n\n    /// Returns an iterator of substrings of `text` delimited by a match of the\n    /// regular expression. Namely, each element of the iterator corresponds to\n    /// text that *isn't* matched by the regular expression.\n    ///\n    /// This method will *not* copy the text given.\n    ///\n    /// # Example\n    ///\n    /// To split a string delimited by arbitrary amounts of spaces or tabs:\n    ///\n    /// ```rust\n    /// # extern crate regex; use regex::bytes::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(r\"[ \\t]+\").unwrap();\n    /// let fields: Vec<&[u8]> = re.split(b\"a b \\t  c\\td    e\").collect();\n    /// assert_eq!(fields, vec![\n    ///     &b\"a\"[..], &b\"b\"[..], &b\"c\"[..], &b\"d\"[..], &b\"e\"[..],\n    /// ]);\n    /// # }\n    /// ```\n    pub fn split<'r, 't>(&'r self, text: &'t [u8]) -> Split<'r, 't> {\n        Split { finder: self.find_iter(text), last: 0 }\n    }\n\n    /// Returns an iterator of at most `limit` substrings of `text` delimited\n    /// by a match of the regular expression. (A `limit` of `0` will return no\n    /// substrings.) Namely, each element of the iterator corresponds to text\n    /// that *isn't* matched by the regular expression. The remainder of the\n    /// string that is not split will be the last element in the iterator.\n    ///\n    /// This method will *not* copy the text given.\n    ///\n    /// # Example\n    ///\n    /// Get the first two words in some text:\n    ///\n    /// ```rust\n    /// # extern crate regex; use regex::bytes::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(r\"\\W+\").unwrap();\n    /// let fields: Vec<&[u8]> = re.splitn(b\"Hey! How are you?\", 3).collect();\n    /// assert_eq!(fields, vec![&b\"Hey\"[..], &b\"How\"[..], &b\"are you?\"[..]]);\n    /// # }\n    /// ```\n    pub fn splitn<'r, 't>(\n        &'r self,\n        text: &'t [u8],\n        limit: usize,\n    ) -> SplitN<'r, 't> {\n        SplitN { splits: self.split(text), n: limit }\n    }\n\n    /// Replaces the leftmost-first match with the replacement provided. The\n    /// replacement can be a regular byte string (where `$N` and `$name` are\n    /// expanded to match capture groups) or a function that takes the matches'\n    /// `Captures` and returns the replaced byte string.\n    ///\n    /// If no match is found, then a copy of the byte string is returned\n    /// unchanged.\n    ///\n    /// # Replacement string syntax\n    ///\n    /// All instances of `$name` in the replacement text is replaced with the\n    /// corresponding capture group `name`.\n    ///\n    /// `name` may be an integer corresponding to the index of the\n    /// capture group (counted by order of opening parenthesis where `0` is the\n    /// entire match) or it can be a name (consisting of letters, digits or\n    /// underscores) corresponding to a named capture group.\n    ///\n    /// If `name` isn't a valid capture group (whether the name doesn't exist\n    /// or isn't a valid index), then it is replaced with the empty string.\n    ///\n    /// The longest possible name is used. e.g., `$1a` looks up the capture\n    /// group named `1a` and not the capture group at index `1`. To exert more\n    /// precise control over the name, use braces, e.g., `${1}a`.\n    ///\n    /// To write a literal `$` use `$$`.\n    ///\n    /// # Examples\n    ///\n    /// Note that this function is polymorphic with respect to the replacement.\n    /// In typical usage, this can just be a normal byte string:\n    ///\n    /// ```rust\n    /// # extern crate regex; use regex::bytes::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(\"[^01]+\").unwrap();\n    /// assert_eq!(re.replace(b\"1078910\", &b\"\"[..]), &b\"1010\"[..]);\n    /// # }\n    /// ```\n    ///\n    /// But anything satisfying the `Replacer` trait will work. For example, a\n    /// closure of type `|&Captures| -> Vec<u8>` provides direct access to the\n    /// captures corresponding to a match. This allows one to access capturing\n    /// group matches easily:\n    ///\n    /// ```rust\n    /// # extern crate regex; use regex::bytes::Regex;\n    /// # use regex::bytes::Captures; fn main() {\n    /// let re = Regex::new(r\"([^,\\s]+),\\s+(\\S+)\").unwrap();\n    /// let result = re.replace(b\"Springsteen, Bruce\", |caps: &Captures| {\n    ///     let mut replacement = caps[2].to_owned();\n    ///     replacement.push(b' ');\n    ///     replacement.extend(&caps[1]);\n    ///     replacement\n    /// });\n    /// assert_eq!(result, &b\"Bruce Springsteen\"[..]);\n    /// # }\n    /// ```\n    ///\n    /// But this is a bit cumbersome to use all the time. Instead, a simple\n    /// syntax is supported that expands `$name` into the corresponding capture\n    /// group. Here's the last example, but using this expansion technique\n    /// with named capture groups:\n    ///\n    /// ```rust\n    /// # extern crate regex; use regex::bytes::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(r\"(?P<last>[^,\\s]+),\\s+(?P<first>\\S+)\").unwrap();\n    /// let result = re.replace(b\"Springsteen, Bruce\", &b\"$first $last\"[..]);\n    /// assert_eq!(result, &b\"Bruce Springsteen\"[..]);\n    /// # }\n    /// ```\n    ///\n    /// Note that using `$2` instead of `$first` or `$1` instead of `$last`\n    /// would produce the same result. To write a literal `$` use `$$`.\n    ///\n    /// Sometimes the replacement string requires use of curly braces to\n    /// delineate a capture group replacement and surrounding literal text.\n    /// For example, if we wanted to join two words together with an\n    /// underscore:\n    ///\n    /// ```rust\n    /// # extern crate regex; use regex::bytes::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(r\"(?P<first>\\w+)\\s+(?P<second>\\w+)\").unwrap();\n    /// let result = re.replace(b\"deep fried\", &b\"${first}_$second\"[..]);\n    /// assert_eq!(result, &b\"deep_fried\"[..]);\n    /// # }\n    /// ```\n    ///\n    /// Without the curly braces, the capture group name `first_` would be\n    /// used, and since it doesn't exist, it would be replaced with the empty\n    /// string.\n    ///\n    /// Finally, sometimes you just want to replace a literal string with no\n    /// regard for capturing group expansion. This can be done by wrapping a\n    /// byte string with `NoExpand`:\n    ///\n    /// ```rust\n    /// # extern crate regex; use regex::bytes::Regex;\n    /// # fn main() {\n    /// use regex::bytes::NoExpand;\n    ///\n    /// let re = Regex::new(r\"(?P<last>[^,\\s]+),\\s+(\\S+)\").unwrap();\n    /// let result = re.replace(b\"Springsteen, Bruce\", NoExpand(b\"$2 $last\"));\n    /// assert_eq!(result, &b\"$2 $last\"[..]);\n    /// # }\n    /// ```\n    pub fn replace<'t, R: Replacer>(\n        &self,\n        text: &'t [u8],\n        rep: R,\n    ) -> Cow<'t, [u8]> {\n        self.replacen(text, 1, rep)\n    }\n\n    /// Replaces all non-overlapping matches in `text` with the replacement\n    /// provided. This is the same as calling `replacen` with `limit` set to\n    /// `0`.\n    ///\n    /// See the documentation for `replace` for details on how to access\n    /// capturing group matches in the replacement text.\n    pub fn replace_all<'t, R: Replacer>(\n        &self,\n        text: &'t [u8],\n        rep: R,\n    ) -> Cow<'t, [u8]> {\n        self.replacen(text, 0, rep)\n    }\n\n    /// Replaces at most `limit` non-overlapping matches in `text` with the\n    /// replacement provided. If `limit` is 0, then all non-overlapping matches\n    /// are replaced.\n    ///\n    /// See the documentation for `replace` for details on how to access\n    /// capturing group matches in the replacement text.\n    pub fn replacen<'t, R: Replacer>(\n        &self,\n        text: &'t [u8],\n        limit: usize,\n        mut rep: R,\n    ) -> Cow<'t, [u8]> {\n        if let Some(rep) = rep.no_expansion() {\n            let mut it = self.find_iter(text).enumerate().peekable();\n            if it.peek().is_none() {\n                return Cow::Borrowed(text);\n            }\n            let mut new = Vec::with_capacity(text.len());\n            let mut last_match = 0;\n            for (i, m) in it {\n                if limit > 0 && i >= limit {\n                    break;\n                }\n                new.extend_from_slice(&text[last_match..m.start()]);\n                new.extend_from_slice(&rep);\n                last_match = m.end();\n            }\n            new.extend_from_slice(&text[last_match..]);\n            return Cow::Owned(new);\n        }\n\n        // The slower path, which we use if the replacement needs access to\n        // capture groups.\n        let mut it = self.captures_iter(text).enumerate().peekable();\n        if it.peek().is_none() {\n            return Cow::Borrowed(text);\n        }\n        let mut new = Vec::with_capacity(text.len());\n        let mut last_match = 0;\n        for (i, cap) in it {\n            if limit > 0 && i >= limit {\n                break;\n            }\n            // unwrap on 0 is OK because captures only reports matches\n            let m = cap.get(0).unwrap();\n            new.extend_from_slice(&text[last_match..m.start()]);\n            rep.replace_append(&cap, &mut new);\n            last_match = m.end();\n        }\n        new.extend_from_slice(&text[last_match..]);\n        Cow::Owned(new)\n    }\n}\n\n/// Advanced or \"lower level\" search methods.\nimpl Regex {\n    /// Returns the end location of a match in the text given.\n    ///\n    /// This method may have the same performance characteristics as\n    /// `is_match`, except it provides an end location for a match. In\n    /// particular, the location returned *may be shorter* than the proper end\n    /// of the leftmost-first match.\n    ///\n    /// # Example\n    ///\n    /// Typically, `a+` would match the entire first sequence of `a` in some\n    /// text, but `shortest_match` can give up as soon as it sees the first\n    /// `a`.\n    ///\n    /// ```rust\n    /// # extern crate regex; use regex::bytes::Regex;\n    /// # fn main() {\n    /// let text = b\"aaaaa\";\n    /// let pos = Regex::new(r\"a+\").unwrap().shortest_match(text);\n    /// assert_eq!(pos, Some(1));\n    /// # }\n    /// ```\n    pub fn shortest_match(&self, text: &[u8]) -> Option<usize> {\n        self.shortest_match_at(text, 0)\n    }\n\n    /// Returns the same as shortest_match, but starts the search at the given\n    /// offset.\n    ///\n    /// The significance of the starting point is that it takes the surrounding\n    /// context into consideration. For example, the `\\A` anchor can only\n    /// match when `start == 0`.\n    pub fn shortest_match_at(\n        &self,\n        text: &[u8],\n        start: usize,\n    ) -> Option<usize> {\n        self.0.searcher().shortest_match_at(text, start)\n    }\n\n    /// Returns the same as is_match, but starts the search at the given\n    /// offset.\n    ///\n    /// The significance of the starting point is that it takes the surrounding\n    /// context into consideration. For example, the `\\A` anchor can only\n    /// match when `start == 0`.\n    pub fn is_match_at(&self, text: &[u8], start: usize) -> bool {\n        self.shortest_match_at(text, start).is_some()\n    }\n\n    /// Returns the same as find, but starts the search at the given\n    /// offset.\n    ///\n    /// The significance of the starting point is that it takes the surrounding\n    /// context into consideration. For example, the `\\A` anchor can only\n    /// match when `start == 0`.\n    pub fn find_at<'t>(\n        &self,\n        text: &'t [u8],\n        start: usize,\n    ) -> Option<Match<'t>> {\n        self.0\n            .searcher()\n            .find_at(text, start)\n            .map(|(s, e)| Match::new(text, s, e))\n    }\n\n    /// This is like `captures`, but uses\n    /// [`CaptureLocations`](struct.CaptureLocations.html)\n    /// instead of\n    /// [`Captures`](struct.Captures.html) in order to amortize allocations.\n    ///\n    /// To create a `CaptureLocations` value, use the\n    /// `Regex::capture_locations` method.\n    ///\n    /// This returns the overall match if this was successful, which is always\n    /// equivalence to the `0`th capture group.\n    pub fn captures_read<'t>(\n        &self,\n        locs: &mut CaptureLocations,\n        text: &'t [u8],\n    ) -> Option<Match<'t>> {\n        self.captures_read_at(locs, text, 0)\n    }\n\n    /// Returns the same as `captures_read`, but starts the search at the given\n    /// offset and populates the capture locations given.\n    ///\n    /// The significance of the starting point is that it takes the surrounding\n    /// context into consideration. For example, the `\\A` anchor can only\n    /// match when `start == 0`.\n    pub fn captures_read_at<'t>(\n        &self,\n        locs: &mut CaptureLocations,\n        text: &'t [u8],\n        start: usize,\n    ) -> Option<Match<'t>> {\n        self.0\n            .searcher()\n            .captures_read_at(&mut locs.0, text, start)\n            .map(|(s, e)| Match::new(text, s, e))\n    }\n\n    /// An undocumented alias for `captures_read_at`.\n    ///\n    /// The `regex-capi` crate previously used this routine, so to avoid\n    /// breaking that crate, we continue to provide the name as an undocumented\n    /// alias.\n    #[doc(hidden)]\n    pub fn read_captures_at<'t>(\n        &self,\n        locs: &mut CaptureLocations,\n        text: &'t [u8],\n        start: usize,\n    ) -> Option<Match<'t>> {\n        self.captures_read_at(locs, text, start)\n    }\n}\n\n/// Auxiliary methods.\nimpl Regex {\n    /// Returns the original string of this regex.\n    pub fn as_str(&self) -> &str {\n        &self.0.regex_strings()[0]\n    }\n\n    /// Returns an iterator over the capture names.\n    pub fn capture_names(&self) -> CaptureNames {\n        CaptureNames(self.0.capture_names().iter())\n    }\n\n    /// Returns the number of captures.\n    pub fn captures_len(&self) -> usize {\n        self.0.capture_names().len()\n    }\n\n    /// Returns an empty set of capture locations that can be reused in\n    /// multiple calls to `captures_read` or `captures_read_at`.\n    pub fn capture_locations(&self) -> CaptureLocations {\n        CaptureLocations(self.0.searcher().locations())\n    }\n\n    /// An alias for `capture_locations` to preserve backward compatibility.\n    ///\n    /// The `regex-capi` crate uses this method, so to avoid breaking that\n    /// crate, we continue to export it as an undocumented API.\n    #[doc(hidden)]\n    pub fn locations(&self) -> CaptureLocations {\n        CaptureLocations(self.0.searcher().locations())\n    }\n}\n\n/// An iterator over all non-overlapping matches for a particular string.\n///\n/// The iterator yields a tuple of integers corresponding to the start and end\n/// of the match. The indices are byte offsets. The iterator stops when no more\n/// matches can be found.\n///\n/// `'r` is the lifetime of the compiled regular expression and `'t` is the\n/// lifetime of the matched byte string.\npub struct Matches<'r, 't>(re_trait::Matches<'t, ExecNoSync<'r>>);\n\nimpl<'r, 't> Iterator for Matches<'r, 't> {\n    type Item = Match<'t>;\n\n    fn next(&mut self) -> Option<Match<'t>> {\n        let text = self.0.text();\n        self.0.next().map(|(s, e)| Match::new(text, s, e))\n    }\n}\n\n/// An iterator that yields all non-overlapping capture groups matching a\n/// particular regular expression.\n///\n/// The iterator stops when no more matches can be found.\n///\n/// `'r` is the lifetime of the compiled regular expression and `'t` is the\n/// lifetime of the matched byte string.\npub struct CaptureMatches<'r, 't>(\n    re_trait::CaptureMatches<'t, ExecNoSync<'r>>,\n);\n\nimpl<'r, 't> Iterator for CaptureMatches<'r, 't> {\n    type Item = Captures<'t>;\n\n    fn next(&mut self) -> Option<Captures<'t>> {\n        self.0.next().map(|locs| Captures {\n            text: self.0.text(),\n            locs: locs,\n            named_groups: self.0.regex().capture_name_idx().clone(),\n        })\n    }\n}\n\n/// Yields all substrings delimited by a regular expression match.\n///\n/// `'r` is the lifetime of the compiled regular expression and `'t` is the\n/// lifetime of the byte string being split.\npub struct Split<'r, 't> {\n    finder: Matches<'r, 't>,\n    last: usize,\n}\n\nimpl<'r, 't> Iterator for Split<'r, 't> {\n    type Item = &'t [u8];\n\n    fn next(&mut self) -> Option<&'t [u8]> {\n        let text = self.finder.0.text();\n        match self.finder.next() {\n            None => {\n                if self.last > text.len() {\n                    None\n                } else {\n                    let s = &text[self.last..];\n                    self.last = text.len() + 1; // Next call will return None\n                    Some(s)\n                }\n            }\n            Some(m) => {\n                let matched = &text[self.last..m.start()];\n                self.last = m.end();\n                Some(matched)\n            }\n        }\n    }\n}\n\n/// Yields at most `N` substrings delimited by a regular expression match.\n///\n/// The last substring will be whatever remains after splitting.\n///\n/// `'r` is the lifetime of the compiled regular expression and `'t` is the\n/// lifetime of the byte string being split.\npub struct SplitN<'r, 't> {\n    splits: Split<'r, 't>,\n    n: usize,\n}\n\nimpl<'r, 't> Iterator for SplitN<'r, 't> {\n    type Item = &'t [u8];\n\n    fn next(&mut self) -> Option<&'t [u8]> {\n        if self.n == 0 {\n            return None;\n        }\n\n        self.n -= 1;\n        if self.n > 0 {\n            return self.splits.next();\n        }\n\n        let text = self.splits.finder.0.text();\n        if self.splits.last > text.len() {\n            // We've already returned all substrings.\n            None\n        } else {\n            // self.n == 0, so future calls will return None immediately\n            Some(&text[self.splits.last..])\n        }\n    }\n}\n\n/// An iterator over the names of all possible captures.\n///\n/// `None` indicates an unnamed capture; the first element (capture 0, the\n/// whole matched region) is always unnamed.\n///\n/// `'r` is the lifetime of the compiled regular expression.\npub struct CaptureNames<'r>(::std::slice::Iter<'r, Option<String>>);\n\nimpl<'r> Iterator for CaptureNames<'r> {\n    type Item = Option<&'r str>;\n\n    fn next(&mut self) -> Option<Option<&'r str>> {\n        self.0\n            .next()\n            .as_ref()\n            .map(|slot| slot.as_ref().map(|name| name.as_ref()))\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.0.size_hint()\n    }\n}\n\n/// CaptureLocations is a low level representation of the raw offsets of each\n/// submatch.\n///\n/// You can think of this as a lower level\n/// [`Captures`](struct.Captures.html), where this type does not support\n/// named capturing groups directly and it does not borrow the text that these\n/// offsets were matched on.\n///\n/// Primarily, this type is useful when using the lower level `Regex` APIs\n/// such as `read_captures`, which permits amortizing the allocation in which\n/// capture match locations are stored.\n///\n/// In order to build a value of this type, you'll need to call the\n/// `capture_locations` method on the `Regex` being used to execute the search.\n/// The value returned can then be reused in subsequent searches.\n#[derive(Clone, Debug)]\npub struct CaptureLocations(re_trait::Locations);\n\n/// A type alias for `CaptureLocations` for backwards compatibility.\n///\n/// Previously, we exported `CaptureLocations` as `Locations` in an\n/// undocumented API. To prevent breaking that code (e.g., in `regex-capi`),\n/// we continue re-exporting the same undocumented API.\n#[doc(hidden)]\npub type Locations = CaptureLocations;\n\nimpl CaptureLocations {\n    /// Returns the start and end positions of the Nth capture group. Returns\n    /// `None` if `i` is not a valid capture group or if the capture group did\n    /// not match anything. The positions returned are *always* byte indices\n    /// with respect to the original string matched.\n    #[inline]\n    pub fn get(&self, i: usize) -> Option<(usize, usize)> {\n        self.0.pos(i)\n    }\n\n    /// Returns the total number of capturing groups.\n    ///\n    /// This is always at least `1` since every regex has at least `1`\n    /// capturing group that corresponds to the entire match.\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.0.len()\n    }\n\n    /// An alias for the `get` method for backwards compatibility.\n    ///\n    /// Previously, we exported `get` as `pos` in an undocumented API. To\n    /// prevent breaking that code (e.g., in `regex-capi`), we continue\n    /// re-exporting the same undocumented API.\n    #[doc(hidden)]\n    #[inline]\n    pub fn pos(&self, i: usize) -> Option<(usize, usize)> {\n        self.get(i)\n    }\n}\n\n/// Captures represents a group of captured byte strings for a single match.\n///\n/// The 0th capture always corresponds to the entire match. Each subsequent\n/// index corresponds to the next capture group in the regex. If a capture\n/// group is named, then the matched byte string is *also* available via the\n/// `name` method. (Note that the 0th capture is always unnamed and so must be\n/// accessed with the `get` method.)\n///\n/// Positions returned from a capture group are always byte indices.\n///\n/// `'t` is the lifetime of the matched text.\npub struct Captures<'t> {\n    text: &'t [u8],\n    locs: re_trait::Locations,\n    named_groups: Arc<HashMap<String, usize>>,\n}\n\nimpl<'t> Captures<'t> {\n    /// Returns the match associated with the capture group at index `i`. If\n    /// `i` does not correspond to a capture group, or if the capture group\n    /// did not participate in the match, then `None` is returned.\n    ///\n    /// # Examples\n    ///\n    /// Get the text of the match with a default of an empty string if this\n    /// group didn't participate in the match:\n    ///\n    /// ```rust\n    /// # use regex::bytes::Regex;\n    /// let re = Regex::new(r\"[a-z]+(?:([0-9]+)|([A-Z]+))\").unwrap();\n    /// let caps = re.captures(b\"abc123\").unwrap();\n    ///\n    /// let text1 = caps.get(1).map_or(&b\"\"[..], |m| m.as_bytes());\n    /// let text2 = caps.get(2).map_or(&b\"\"[..], |m| m.as_bytes());\n    /// assert_eq!(text1, &b\"123\"[..]);\n    /// assert_eq!(text2, &b\"\"[..]);\n    /// ```\n    pub fn get(&self, i: usize) -> Option<Match<'t>> {\n        self.locs.pos(i).map(|(s, e)| Match::new(self.text, s, e))\n    }\n\n    /// Returns the match for the capture group named `name`. If `name` isn't a\n    /// valid capture group or didn't match anything, then `None` is returned.\n    pub fn name(&self, name: &str) -> Option<Match<'t>> {\n        self.named_groups.get(name).and_then(|&i| self.get(i))\n    }\n\n    /// An iterator that yields all capturing matches in the order in which\n    /// they appear in the regex. If a particular capture group didn't\n    /// participate in the match, then `None` is yielded for that capture.\n    ///\n    /// The first match always corresponds to the overall match of the regex.\n    pub fn iter<'c>(&'c self) -> SubCaptureMatches<'c, 't> {\n        SubCaptureMatches { caps: self, it: self.locs.iter() }\n    }\n\n    /// Expands all instances of `$name` in `replacement` to the corresponding\n    /// capture group `name`, and writes them to the `dst` buffer given.\n    ///\n    /// `name` may be an integer corresponding to the index of the\n    /// capture group (counted by order of opening parenthesis where `0` is the\n    /// entire match) or it can be a name (consisting of letters, digits or\n    /// underscores) corresponding to a named capture group.\n    ///\n    /// If `name` isn't a valid capture group (whether the name doesn't exist\n    /// or isn't a valid index), then it is replaced with the empty string.\n    ///\n    /// The longest possible name is used. e.g., `$1a` looks up the capture\n    /// group named `1a` and not the capture group at index `1`. To exert more\n    /// precise control over the name, use braces, e.g., `${1}a`.\n    ///\n    /// To write a literal `$` use `$$`.\n    pub fn expand(&self, replacement: &[u8], dst: &mut Vec<u8>) {\n        expand_bytes(self, replacement, dst)\n    }\n\n    /// Returns the number of captured groups.\n    ///\n    /// This is always at least `1`, since every regex has at least one capture\n    /// group that corresponds to the full match.\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.locs.len()\n    }\n}\n\nimpl<'t> fmt::Debug for Captures<'t> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_tuple(\"Captures\").field(&CapturesDebug(self)).finish()\n    }\n}\n\nstruct CapturesDebug<'c, 't: 'c>(&'c Captures<'t>);\n\nimpl<'c, 't> fmt::Debug for CapturesDebug<'c, 't> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fn escape_bytes(bytes: &[u8]) -> String {\n            let mut s = String::new();\n            for &b in bytes {\n                s.push_str(&escape_byte(b));\n            }\n            s\n        }\n\n        fn escape_byte(byte: u8) -> String {\n            use std::ascii::escape_default;\n\n            let escaped: Vec<u8> = escape_default(byte).collect();\n            String::from_utf8_lossy(&escaped).into_owned()\n        }\n\n        // We'd like to show something nice here, even if it means an\n        // allocation to build a reverse index.\n        let slot_to_name: HashMap<&usize, &String> =\n            self.0.named_groups.iter().map(|(a, b)| (b, a)).collect();\n        let mut map = f.debug_map();\n        for (slot, m) in self.0.locs.iter().enumerate() {\n            let m = m.map(|(s, e)| escape_bytes(&self.0.text[s..e]));\n            if let Some(name) = slot_to_name.get(&slot) {\n                map.entry(&name, &m);\n            } else {\n                map.entry(&slot, &m);\n            }\n        }\n        map.finish()\n    }\n}\n\n/// Get a group by index.\n///\n/// `'t` is the lifetime of the matched text.\n///\n/// The text can't outlive the `Captures` object if this method is\n/// used, because of how `Index` is defined (normally `a[i]` is part\n/// of `a` and can't outlive it); to do that, use `get()` instead.\n///\n/// # Panics\n///\n/// If there is no group at the given index.\nimpl<'t> Index<usize> for Captures<'t> {\n    type Output = [u8];\n\n    fn index(&self, i: usize) -> &[u8] {\n        self.get(i)\n            .map(|m| m.as_bytes())\n            .unwrap_or_else(|| panic!(\"no group at index '{}'\", i))\n    }\n}\n\n/// Get a group by name.\n///\n/// `'t` is the lifetime of the matched text and `'i` is the lifetime\n/// of the group name (the index).\n///\n/// The text can't outlive the `Captures` object if this method is\n/// used, because of how `Index` is defined (normally `a[i]` is part\n/// of `a` and can't outlive it); to do that, use `name` instead.\n///\n/// # Panics\n///\n/// If there is no group named by the given value.\nimpl<'t, 'i> Index<&'i str> for Captures<'t> {\n    type Output = [u8];\n\n    fn index<'a>(&'a self, name: &'i str) -> &'a [u8] {\n        self.name(name)\n            .map(|m| m.as_bytes())\n            .unwrap_or_else(|| panic!(\"no group named '{}'\", name))\n    }\n}\n\n/// An iterator that yields all capturing matches in the order in which they\n/// appear in the regex.\n///\n/// If a particular capture group didn't participate in the match, then `None`\n/// is yielded for that capture. The first match always corresponds to the\n/// overall match of the regex.\n///\n/// The lifetime `'c` corresponds to the lifetime of the `Captures` value, and\n/// the lifetime `'t` corresponds to the originally matched text.\npub struct SubCaptureMatches<'c, 't: 'c> {\n    caps: &'c Captures<'t>,\n    it: SubCapturesPosIter<'c>,\n}\n\nimpl<'c, 't> Iterator for SubCaptureMatches<'c, 't> {\n    type Item = Option<Match<'t>>;\n\n    fn next(&mut self) -> Option<Option<Match<'t>>> {\n        self.it\n            .next()\n            .map(|cap| cap.map(|(s, e)| Match::new(self.caps.text, s, e)))\n    }\n}\n\n/// Replacer describes types that can be used to replace matches in a byte\n/// string.\n///\n/// In general, users of this crate shouldn't need to implement this trait,\n/// since implementations are already provided for `&[u8]` and\n/// `FnMut(&Captures) -> Vec<u8>` (or any `FnMut(&Captures) -> T`\n/// where `T: AsRef<[u8]>`), which covers most use cases.\npub trait Replacer {\n    /// Appends text to `dst` to replace the current match.\n    ///\n    /// The current match is represented by `caps`, which is guaranteed to\n    /// have a match at capture group `0`.\n    ///\n    /// For example, a no-op replacement would be\n    /// `dst.extend(&caps[0])`.\n    fn replace_append(&mut self, caps: &Captures, dst: &mut Vec<u8>);\n\n    /// Return a fixed unchanging replacement byte string.\n    ///\n    /// When doing replacements, if access to `Captures` is not needed (e.g.,\n    /// the replacement byte string does not need `$` expansion), then it can\n    /// be beneficial to avoid finding sub-captures.\n    ///\n    /// In general, this is called once for every call to `replacen`.\n    fn no_expansion<'r>(&'r mut self) -> Option<Cow<'r, [u8]>> {\n        None\n    }\n\n    /// Return a `Replacer` that borrows and wraps this `Replacer`.\n    ///\n    /// This is useful when you want to take a generic `Replacer` (which might\n    /// not be cloneable) and use it without consuming it, so it can be used\n    /// more than once.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use regex::bytes::{Regex, Replacer};\n    ///\n    /// fn replace_all_twice<R: Replacer>(\n    ///     re: Regex,\n    ///     src: &[u8],\n    ///     mut rep: R,\n    /// ) -> Vec<u8> {\n    ///     let dst = re.replace_all(src, rep.by_ref());\n    ///     let dst = re.replace_all(&dst, rep.by_ref());\n    ///     dst.into_owned()\n    /// }\n    /// ```\n    fn by_ref<'r>(&'r mut self) -> ReplacerRef<'r, Self> {\n        ReplacerRef(self)\n    }\n}\n\n/// By-reference adaptor for a `Replacer`\n///\n/// Returned by [`Replacer::by_ref`](trait.Replacer.html#method.by_ref).\n#[derive(Debug)]\npub struct ReplacerRef<'a, R: ?Sized + 'a>(&'a mut R);\n\nimpl<'a, R: Replacer + ?Sized + 'a> Replacer for ReplacerRef<'a, R> {\n    fn replace_append(&mut self, caps: &Captures, dst: &mut Vec<u8>) {\n        self.0.replace_append(caps, dst)\n    }\n    fn no_expansion<'r>(&'r mut self) -> Option<Cow<'r, [u8]>> {\n        self.0.no_expansion()\n    }\n}\n\nimpl<'a> Replacer for &'a [u8] {\n    fn replace_append(&mut self, caps: &Captures, dst: &mut Vec<u8>) {\n        caps.expand(*self, dst);\n    }\n\n    fn no_expansion(&mut self) -> Option<Cow<[u8]>> {\n        match find_byte(b'$', *self) {\n            Some(_) => None,\n            None => Some(Cow::Borrowed(*self)),\n        }\n    }\n}\n\nimpl<F, T> Replacer for F\nwhere\n    F: FnMut(&Captures) -> T,\n    T: AsRef<[u8]>,\n{\n    fn replace_append(&mut self, caps: &Captures, dst: &mut Vec<u8>) {\n        dst.extend_from_slice((*self)(caps).as_ref());\n    }\n}\n\n/// `NoExpand` indicates literal byte string replacement.\n///\n/// It can be used with `replace` and `replace_all` to do a literal byte string\n/// replacement without expanding `$name` to their corresponding capture\n/// groups. This can be both convenient (to avoid escaping `$`, for example)\n/// and performant (since capture groups don't need to be found).\n///\n/// `'t` is the lifetime of the literal text.\npub struct NoExpand<'t>(pub &'t [u8]);\n\nimpl<'t> Replacer for NoExpand<'t> {\n    fn replace_append(&mut self, _: &Captures, dst: &mut Vec<u8>) {\n        dst.extend_from_slice(self.0);\n    }\n\n    fn no_expansion(&mut self) -> Option<Cow<[u8]>> {\n        Some(Cow::Borrowed(self.0))\n    }\n}\n","traces":[{"line":29,"address":[5064896],"length":1,"stats":{"Line":7},"fn_name":"start"},{"line":30,"address":[5064901],"length":1,"stats":{"Line":7},"fn_name":null},{"line":35,"address":[5064912],"length":1,"stats":{"Line":7},"fn_name":"end"},{"line":36,"address":[5064917],"length":1,"stats":{"Line":7},"fn_name":null},{"line":42,"address":[5064928],"length":1,"stats":{"Line":7},"fn_name":"range"},{"line":43,"address":[5064937],"length":1,"stats":{"Line":7},"fn_name":null},{"line":48,"address":[5064976],"length":1,"stats":{"Line":7},"fn_name":"as_bytes"},{"line":49,"address":[5064985],"length":1,"stats":{"Line":7},"fn_name":null},{"line":54,"address":[5065072],"length":1,"stats":{"Line":8},"fn_name":"new"},{"line":60,"address":[5748880],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":61,"address":[5748884],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[5065120],"length":1,"stats":{"Line":3},"fn_name":"fmt"},{"line":82,"address":[5065143],"length":1,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[5065344],"length":1,"stats":{"Line":3},"fn_name":"fmt"},{"line":89,"address":[5065358],"length":1,"stats":{"Line":3},"fn_name":null},{"line":98,"address":[5065392],"length":1,"stats":{"Line":14},"fn_name":"from"},{"line":99,"address":[5065399],"length":1,"stats":{"Line":14},"fn_name":null},{"line":107,"address":[5065488],"length":1,"stats":{"Line":0},"fn_name":"from_str"},{"line":108,"address":[5065509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[5065536,5065577],"length":1,"stats":{"Line":9},"fn_name":"new"},{"line":119,"address":[5065553,5065599],"length":1,"stats":{"Line":20},"fn_name":null},{"line":140,"address":[5065664],"length":1,"stats":{"Line":3},"fn_name":"is_match"},{"line":141,"address":[5065687],"length":1,"stats":{"Line":3},"fn_name":null},{"line":164,"address":[5065712],"length":1,"stats":{"Line":0},"fn_name":"find"},{"line":165,"address":[5065742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[5065760],"length":1,"stats":{"Line":9},"fn_name":"find_iter"},{"line":187,"address":[5065917],"length":1,"stats":{"Line":9},"fn_name":null},{"line":253,"address":[5066000,5066090],"length":1,"stats":{"Line":8},"fn_name":"captures"},{"line":254,"address":[5066034],"length":1,"stats":{"Line":8},"fn_name":null},{"line":255,"address":[4723705,4723584,4723671],"length":1,"stats":{"Line":22},"fn_name":"{{closure}}"},{"line":256,"address":[4723591],"length":1,"stats":{"Line":7},"fn_name":null},{"line":257,"address":[4723598],"length":1,"stats":{"Line":7},"fn_name":null},{"line":258,"address":[4723616],"length":1,"stats":{"Line":7},"fn_name":null},{"line":288,"address":[5066304],"length":1,"stats":{"Line":3},"fn_name":"captures_iter"},{"line":292,"address":[5066461],"length":1,"stats":{"Line":3},"fn_name":null},{"line":315,"address":[5066544],"length":1,"stats":{"Line":4},"fn_name":"split"},{"line":316,"address":[5066566],"length":1,"stats":{"Line":4},"fn_name":null},{"line":339,"address":[5066640],"length":1,"stats":{"Line":3},"fn_name":"splitn"},{"line":344,"address":[5066667],"length":1,"stats":{"Line":3},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":554,"address":[5066752],"length":1,"stats":{"Line":4},"fn_name":"shortest_match"},{"line":555,"address":[5066775],"length":1,"stats":{"Line":4},"fn_name":null},{"line":564,"address":[5066816],"length":1,"stats":{"Line":3},"fn_name":"shortest_match_at"},{"line":569,"address":[5066989],"length":1,"stats":{"Line":3},"fn_name":null},{"line":578,"address":[5105088],"length":1,"stats":{"Line":3},"fn_name":"is_match_at"},{"line":579,"address":[5105112],"length":1,"stats":{"Line":3},"fn_name":null},{"line":588,"address":[5105168],"length":1,"stats":{"Line":0},"fn_name":"find_at"},{"line":593,"address":[5105344,5168136,5168154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[5105360],"length":1,"stats":{"Line":0},"fn_name":null},{"line":596,"address":[4723798,4723776],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":609,"address":[5168224],"length":1,"stats":{"Line":0},"fn_name":"captures_read"},{"line":614,"address":[5168258],"length":1,"stats":{"Line":0},"fn_name":null},{"line":623,"address":[5168272],"length":1,"stats":{"Line":8},"fn_name":"captures_read_at"},{"line":629,"address":[5168488,5168455,5168430],"length":1,"stats":{"Line":23},"fn_name":null},{"line":631,"address":[5168445],"length":1,"stats":{"Line":8},"fn_name":null},{"line":632,"address":[4723894,4723872],"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":641,"address":[5168528],"length":1,"stats":{"Line":0},"fn_name":"read_captures_at"},{"line":647,"address":[5168565],"length":1,"stats":{"Line":0},"fn_name":null},{"line":654,"address":[5168592],"length":1,"stats":{"Line":3},"fn_name":"as_str"},{"line":655,"address":[5168601,5168673,5168700],"length":1,"stats":{"Line":3},"fn_name":null},{"line":659,"address":[5168704],"length":1,"stats":{"Line":3},"fn_name":"capture_names"},{"line":660,"address":[5168713],"length":1,"stats":{"Line":3},"fn_name":null},{"line":664,"address":[5168800],"length":1,"stats":{"Line":3},"fn_name":"captures_len"},{"line":665,"address":[5168809],"length":1,"stats":{"Line":3},"fn_name":null},{"line":670,"address":[5168864],"length":1,"stats":{"Line":8},"fn_name":"capture_locations"},{"line":671,"address":[5168954],"length":1,"stats":{"Line":8},"fn_name":null},{"line":679,"address":[5169024],"length":1,"stats":{"Line":0},"fn_name":"locations"},{"line":680,"address":[5169114],"length":1,"stats":{"Line":0},"fn_name":null},{"line":697,"address":[5169184],"length":1,"stats":{"Line":9},"fn_name":"next"},{"line":698,"address":[5169201],"length":1,"stats":{"Line":9},"fn_name":null},{"line":699,"address":[4723968,4723990],"length":1,"stats":{"Line":19},"fn_name":"{{closure}}"},{"line":717,"address":[5169296],"length":1,"stats":{"Line":3},"fn_name":"next"},{"line":718,"address":[4724135,4724064,4724273],"length":1,"stats":{"Line":9},"fn_name":"{{closure}}"},{"line":719,"address":[4724082],"length":1,"stats":{"Line":3},"fn_name":null},{"line":720,"address":[4724160],"length":1,"stats":{"Line":3},"fn_name":null},{"line":721,"address":[4724192,4724251],"length":1,"stats":{"Line":6},"fn_name":null},{"line":738,"address":[5169392],"length":1,"stats":{"Line":4},"fn_name":"next"},{"line":739,"address":[5169407],"length":1,"stats":{"Line":4},"fn_name":null},{"line":740,"address":[5169594,5169822,5169454],"length":1,"stats":{"Line":8},"fn_name":null},{"line":741,"address":[5169470],"length":1,"stats":{"Line":4},"fn_name":null},{"line":742,"address":[5169601,5169708],"length":1,"stats":{"Line":8},"fn_name":null},{"line":743,"address":[5169699],"length":1,"stats":{"Line":4},"fn_name":null},{"line":745,"address":[5169651,5169715],"length":1,"stats":{"Line":8},"fn_name":null},{"line":746,"address":[5170027,5169746,5169997],"length":1,"stats":{"Line":4},"fn_name":null},{"line":747,"address":[5169804],"length":1,"stats":{"Line":4},"fn_name":null},{"line":750,"address":[5169493],"length":1,"stats":{"Line":4},"fn_name":null},{"line":751,"address":[5169832,5169562],"length":1,"stats":{"Line":8},"fn_name":null},{"line":752,"address":[5169921],"length":1,"stats":{"Line":4},"fn_name":null},{"line":753,"address":[5169958],"length":1,"stats":{"Line":4},"fn_name":null},{"line":773,"address":[5170032],"length":1,"stats":{"Line":3},"fn_name":"next"},{"line":774,"address":[5170041],"length":1,"stats":{"Line":4},"fn_name":null},{"line":775,"address":[5170088],"length":1,"stats":{"Line":4},"fn_name":null},{"line":778,"address":[5170058,5170122,5170323,5170353],"length":1,"stats":{"Line":8},"fn_name":null},{"line":779,"address":[5170126],"length":1,"stats":{"Line":4},"fn_name":null},{"line":780,"address":[5170173],"length":1,"stats":{"Line":4},"fn_name":null},{"line":783,"address":[5170138],"length":1,"stats":{"Line":4},"fn_name":null},{"line":784,"address":[5170195,5170296],"length":1,"stats":{"Line":7},"fn_name":null},{"line":786,"address":[5170287],"length":1,"stats":{"Line":3},"fn_name":null},{"line":789,"address":[5170303,5170245],"length":1,"stats":{"Line":8},"fn_name":null},{"line":805,"address":[5170368],"length":1,"stats":{"Line":3},"fn_name":"next"},{"line":806,"address":[5170385],"length":1,"stats":{"Line":3},"fn_name":null},{"line":809,"address":[4724473,4724416,4724425,4724464],"length":1,"stats":{"Line":12},"fn_name":"{{closure}}"},{"line":812,"address":[5170448],"length":1,"stats":{"Line":3},"fn_name":"size_hint"},{"line":813,"address":[5170465],"length":1,"stats":{"Line":3},"fn_name":null},{"line":849,"address":[5170480],"length":1,"stats":{"Line":0},"fn_name":"get"},{"line":850,"address":[5170501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":858,"address":[5170528],"length":1,"stats":{"Line":0},"fn_name":"len"},{"line":859,"address":[5170537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":869,"address":[5170560],"length":1,"stats":{"Line":0},"fn_name":"pos"},{"line":870,"address":[5170581],"length":1,"stats":{"Line":0},"fn_name":null},{"line":911,"address":[5170608],"length":1,"stats":{"Line":5},"fn_name":"get"},{"line":912,"address":[4724550,4724528],"length":1,"stats":{"Line":13},"fn_name":"{{closure}}"},{"line":917,"address":[5170704],"length":1,"stats":{"Line":4},"fn_name":"name"},{"line":918,"address":[4724640,4724657],"length":1,"stats":{"Line":10},"fn_name":"{{closure}}"},{"line":926,"address":[5170848],"length":1,"stats":{"Line":3},"fn_name":"iter"},{"line":927,"address":[5170860],"length":1,"stats":{"Line":3},"fn_name":null},{"line":946,"address":[5170944],"length":1,"stats":{"Line":4},"fn_name":"expand"},{"line":947,"address":[5170968],"length":1,"stats":{"Line":5},"fn_name":null},{"line":955,"address":[5170992],"length":1,"stats":{"Line":3},"fn_name":"len"},{"line":956,"address":[5171001],"length":1,"stats":{"Line":3},"fn_name":null},{"line":961,"address":[5171040],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":962,"address":[5171061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":969,"address":[5171168,5171222],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":970,"address":[5172048,5172109],"length":1,"stats":{"Line":0},"fn_name":"escape_bytes"},{"line":971,"address":[5172074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":972,"address":[5172410,5172287,5172190,5172124,5172313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":973,"address":[5172310,5172327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":975,"address":[5172243],"length":1,"stats":{"Line":0},"fn_name":null},{"line":978,"address":[5172464,5172509],"length":1,"stats":{"Line":0},"fn_name":"escape_byte"},{"line":981,"address":[5172479,5172521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":982,"address":[5172537,5172600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":987,"address":[4724723,4724704],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":988,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":989,"address":[5171288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":990,"address":[5171976,5171312,5171530,5171377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":991,"address":[4724768,4724790],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":992,"address":[5171888,5171953,5171765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":993,"address":[5171904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":995,"address":[5171839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":998,"address":[5171504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1016,"address":[5172672],"length":1,"stats":{"Line":5},"fn_name":"index"},{"line":1017,"address":[5172686,5172744],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1018,"address":[4724896,4724900],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":1019,"address":[4724928,4724944],"length":1,"stats":{"Line":9},"fn_name":"{{closure}}"},{"line":1038,"address":[5172800],"length":1,"stats":{"Line":4},"fn_name":"index"},{"line":1039,"address":[5172882,5172819],"length":1,"stats":{"Line":7},"fn_name":null},{"line":1040,"address":[4725092,4725088],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":1041,"address":[4725136,4725120],"length":1,"stats":{"Line":9},"fn_name":"{{closure}}"},{"line":1062,"address":[5172928],"length":1,"stats":{"Line":3},"fn_name":"next"},{"line":1063,"address":[5172987,5172940],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1065,"address":[4725280,4725392,4725302,4725404],"length":1,"stats":{"Line":15},"fn_name":"{{closure}}"},{"line":1093,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1094,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1118,"address":[4725504,4725472],"length":1,"stats":{"Line":0},"fn_name":"by_ref<regex::re_bytes::NoExpand>"},{"line":1119,"address":[4725513,4725481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1139,"address":[5173024],"length":1,"stats":{"Line":3},"fn_name":"replace_append"},{"line":1140,"address":[5173043],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1143,"address":[5173088],"length":1,"stats":{"Line":3},"fn_name":"no_expansion"},{"line":1144,"address":[5173234,5173100],"length":1,"stats":{"Line":7},"fn_name":null},{"line":1145,"address":[5173149,5173243],"length":1,"stats":{"Line":7},"fn_name":null},{"line":1146,"address":[5173168],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1156,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1157,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":1172,"address":[5173264],"length":1,"stats":{"Line":0},"fn_name":"replace_append"},{"line":1173,"address":[5173282],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1176,"address":[5173312],"length":1,"stats":{"Line":3},"fn_name":"no_expansion"},{"line":1177,"address":[5173324],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":150,"coverable":203},{"path":["/","usr","src","regex","src","re_set.rs"],"content":"macro_rules! define_set {\n    ($name:ident, $builder_mod:ident, $text_ty:ty, $as_bytes:expr,\n     $(#[$doc_regexset_example:meta])* ) => {\n        pub mod $name {\n            use std::fmt;\n            use std::iter;\n            use std::slice;\n            use std::vec;\n\n            use error::Error;\n            use exec::Exec;\n            use re_builder::$builder_mod::RegexSetBuilder;\n            use re_trait::RegularExpression;\n\n/// Match multiple (possibly overlapping) regular expressions in a single scan.\n///\n/// A regex set corresponds to the union of two or more regular expressions.\n/// That is, a regex set will match text where at least one of its\n/// constituent regular expressions matches. A regex set as its formulated here\n/// provides a touch more power: it will also report *which* regular\n/// expressions in the set match. Indeed, this is the key difference between\n/// regex sets and a single `Regex` with many alternates, since only one\n/// alternate can match at a time.\n///\n/// For example, consider regular expressions to match email addresses and\n/// domains: `[a-z]+@[a-z]+\\.(com|org|net)` and `[a-z]+\\.(com|org|net)`. If a\n/// regex set is constructed from those regexes, then searching the text\n/// `foo@example.com` will report both regexes as matching. Of course, one\n/// could accomplish this by compiling each regex on its own and doing two\n/// searches over the text. The key advantage of using a regex set is that it\n/// will report the matching regexes using a *single pass through the text*.\n/// If one has hundreds or thousands of regexes to match repeatedly (like a URL\n/// router for a complex web application or a user agent matcher), then a regex\n/// set can realize huge performance gains.\n///\n/// # Example\n///\n/// This shows how the above two regexes (for matching email addresses and\n/// domains) might work:\n///\n$(#[$doc_regexset_example])*\n///\n/// Note that it would be possible to adapt the above example to using `Regex`\n/// with an expression like:\n///\n/// ```ignore\n/// (?P<email>[a-z]+@(?P<email_domain>[a-z]+[.](com|org|net)))|(?P<domain>[a-z]+[.](com|org|net))\n/// ```\n///\n/// After a match, one could then inspect the capture groups to figure out\n/// which alternates matched. The problem is that it is hard to make this\n/// approach scale when there are many regexes since the overlap between each\n/// alternate isn't always obvious to reason about.\n///\n/// # Limitations\n///\n/// Regex sets are limited to answering the following two questions:\n///\n/// 1. Does any regex in the set match?\n/// 2. If so, which regexes in the set match?\n///\n/// As with the main `Regex` type, it is cheaper to ask (1) instead of (2)\n/// since the matching engines can stop after the first match is found.\n///\n/// Other features like finding the location of successive matches or their\n/// sub-captures aren't supported. If you need this functionality, the\n/// recommended approach is to compile each regex in the set independently and\n/// selectively match them based on which regexes in the set matched.\n///\n/// # Performance\n///\n/// A `RegexSet` has the same performance characteristics as `Regex`. Namely,\n/// search takes `O(mn)` time, where `m` is proportional to the size of the\n/// regex set and `n` is proportional to the length of the search text.\n#[derive(Clone)]\npub struct RegexSet(Exec);\n\nimpl RegexSet {\n    /// Create a new regex set with the given regular expressions.\n    ///\n    /// This takes an iterator of `S`, where `S` is something that can produce\n    /// a `&str`. If any of the strings in the iterator are not valid regular\n    /// expressions, then an error is returned.\n    ///\n    /// # Example\n    ///\n    /// Create a new regex set from an iterator of strings:\n    ///\n    /// ```rust\n    /// # use regex::RegexSet;\n    /// let set = RegexSet::new(&[r\"\\w+\", r\"\\d+\"]).unwrap();\n    /// assert!(set.is_match(\"foo\"));\n    /// ```\n    pub fn new<I, S>(exprs: I) -> Result<RegexSet, Error>\n            where S: AsRef<str>, I: IntoIterator<Item=S> {\n        RegexSetBuilder::new(exprs).build()\n    }\n\n    /// Returns true if and only if one of the regexes in this set matches\n    /// the text given.\n    ///\n    /// This method should be preferred if you only need to test whether any\n    /// of the regexes in the set should match, but don't care about *which*\n    /// regexes matched. This is because the underlying matching engine will\n    /// quit immediately after seeing the first match instead of continuing to\n    /// find all matches.\n    ///\n    /// Note that as with searches using `Regex`, the expression is unanchored\n    /// by default. That is, if the regex does not start with `^` or `\\A`, or\n    /// end with `$` or `\\z`, then it is permitted to match anywhere in the\n    /// text.\n    ///\n    /// # Example\n    ///\n    /// Tests whether a set matches some text:\n    ///\n    /// ```rust\n    /// # use regex::RegexSet;\n    /// let set = RegexSet::new(&[r\"\\w+\", r\"\\d+\"]).unwrap();\n    /// assert!(set.is_match(\"foo\"));\n    /// assert!(!set.is_match(\"☃\"));\n    /// ```\n    pub fn is_match(&self, text: $text_ty) -> bool {\n        self.is_match_at(text, 0)\n    }\n\n    /// Returns the same as is_match, but starts the search at the given\n    /// offset.\n    ///\n    /// The significance of the starting point is that it takes the surrounding\n    /// context into consideration. For example, the `\\A` anchor can only\n    /// match when `start == 0`.\n    #[doc(hidden)]\n    pub fn is_match_at(&self, text: $text_ty, start: usize) -> bool {\n        self.0.searcher().is_match_at($as_bytes(text), start)\n    }\n\n    /// Returns the set of regular expressions that match in the given text.\n    ///\n    /// The set returned contains the index of each regular expression that\n    /// matches in the given text. The index is in correspondence with the\n    /// order of regular expressions given to `RegexSet`'s constructor.\n    ///\n    /// The set can also be used to iterate over the matched indices.\n    ///\n    /// Note that as with searches using `Regex`, the expression is unanchored\n    /// by default. That is, if the regex does not start with `^` or `\\A`, or\n    /// end with `$` or `\\z`, then it is permitted to match anywhere in the\n    /// text.\n    ///\n    /// # Example\n    ///\n    /// Tests which regular expressions match the given text:\n    ///\n    /// ```rust\n    /// # use regex::RegexSet;\n    /// let set = RegexSet::new(&[\n    ///     r\"\\w+\",\n    ///     r\"\\d+\",\n    ///     r\"\\pL+\",\n    ///     r\"foo\",\n    ///     r\"bar\",\n    ///     r\"barfoo\",\n    ///     r\"foobar\",\n    /// ]).unwrap();\n    /// let matches: Vec<_> = set.matches(\"foobar\").into_iter().collect();\n    /// assert_eq!(matches, vec![0, 2, 3, 4, 6]);\n    ///\n    /// // You can also test whether a particular regex matched:\n    /// let matches = set.matches(\"foobar\");\n    /// assert!(!matches.matched(5));\n    /// assert!(matches.matched(6));\n    /// ```\n    pub fn matches(&self, text: $text_ty) -> SetMatches {\n        let mut matches = vec![false; self.0.regex_strings().len()];\n        let any = self.read_matches_at(&mut matches, text, 0);\n        SetMatches {\n            matched_any: any,\n            matches: matches,\n        }\n    }\n\n    /// Returns the same as matches, but starts the search at the given\n    /// offset and stores the matches into the slice given.\n    ///\n    /// The significance of the starting point is that it takes the surrounding\n    /// context into consideration. For example, the `\\A` anchor can only\n    /// match when `start == 0`.\n    ///\n    /// `matches` must have a length that is at least the number of regexes\n    /// in this set.\n    ///\n    /// This method returns true if and only if at least one member of\n    /// `matches` is true after executing the set against `text`.\n    #[doc(hidden)]\n    pub fn read_matches_at(\n        &self,\n        matches: &mut [bool],\n        text: $text_ty,\n        start: usize,\n    ) -> bool {\n        self.0.searcher().many_matches_at(matches, $as_bytes(text), start)\n    }\n\n    /// Returns the total number of regular expressions in this set.\n    pub fn len(&self) -> usize {\n        self.0.regex_strings().len()\n    }\n\n    /// Returns the patterns that this set will match on.\n    ///\n    /// This function can be used to determine the pattern for a match. The\n    /// slice returned has exactly as many patterns givens to this regex set,\n    /// and the order of the slice is the same as the order of the patterns\n    /// provided to the set.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use regex::RegexSet;\n    /// let set = RegexSet::new(&[\n    ///     r\"\\w+\",\n    ///     r\"\\d+\",\n    ///     r\"\\pL+\",\n    ///     r\"foo\",\n    ///     r\"bar\",\n    ///     r\"barfoo\",\n    ///     r\"foobar\",\n    /// ]).unwrap();\n    /// let matches: Vec<_> = set\n    ///     .matches(\"foobar\")\n    ///     .into_iter()\n    ///     .map(|match_idx| &set.patterns()[match_idx])\n    ///     .collect();\n    /// assert_eq!(matches, vec![r\"\\w+\", r\"\\pL+\", r\"foo\", r\"bar\", r\"foobar\"]);\n    /// ```\n    pub fn patterns(&self) -> &[String] {\n        self.0.regex_strings()\n    }\n}\n\n/// A set of matches returned by a regex set.\n#[derive(Clone, Debug)]\npub struct SetMatches {\n    matched_any: bool,\n    matches: Vec<bool>,\n}\n\nimpl SetMatches {\n    /// Whether this set contains any matches.\n    pub fn matched_any(&self) -> bool {\n        self.matched_any\n    }\n\n    /// Whether the regex at the given index matched.\n    ///\n    /// The index for a regex is determined by its insertion order upon the\n    /// initial construction of a `RegexSet`, starting at `0`.\n    ///\n    /// # Panics\n    ///\n    /// If `regex_index` is greater than or equal to `self.len()`.\n    pub fn matched(&self, regex_index: usize) -> bool {\n        self.matches[regex_index]\n    }\n\n    /// The total number of regexes in the set that created these matches.\n    pub fn len(&self) -> usize {\n        self.matches.len()\n    }\n\n    /// Returns an iterator over indexes in the regex that matched.\n    ///\n    /// This will always produces matches in ascending order of index, where\n    /// the index corresponds to the index of the regex that matched with\n    /// respect to its position when initially building the set.\n    pub fn iter(&self) -> SetMatchesIter {\n        SetMatchesIter((&*self.matches).into_iter().enumerate())\n    }\n}\n\nimpl IntoIterator for SetMatches {\n    type IntoIter = SetMatchesIntoIter;\n    type Item = usize;\n\n    fn into_iter(self) -> Self::IntoIter {\n        SetMatchesIntoIter(self.matches.into_iter().enumerate())\n    }\n}\n\nimpl<'a> IntoIterator for &'a SetMatches {\n    type IntoIter = SetMatchesIter<'a>;\n    type Item = usize;\n\n    fn into_iter(self) -> Self::IntoIter {\n        self.iter()\n    }\n}\n\n/// An owned iterator over the set of matches from a regex set.\n///\n/// This will always produces matches in ascending order of index, where the\n/// index corresponds to the index of the regex that matched with respect to\n/// its position when initially building the set.\npub struct SetMatchesIntoIter(iter::Enumerate<vec::IntoIter<bool>>);\n\nimpl Iterator for SetMatchesIntoIter {\n    type Item = usize;\n\n    fn next(&mut self) -> Option<usize> {\n        loop {\n            match self.0.next() {\n                None => return None,\n                Some((_, false)) => {}\n                Some((i, true)) => return Some(i),\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.0.size_hint()\n    }\n}\n\nimpl DoubleEndedIterator for SetMatchesIntoIter {\n    fn next_back(&mut self) -> Option<usize> {\n        loop {\n            match self.0.next_back() {\n                None => return None,\n                Some((_, false)) => {}\n                Some((i, true)) => return Some(i),\n            }\n        }\n    }\n}\n\n/// A borrowed iterator over the set of matches from a regex set.\n///\n/// The lifetime `'a` refers to the lifetime of a `SetMatches` value.\n///\n/// This will always produces matches in ascending order of index, where the\n/// index corresponds to the index of the regex that matched with respect to\n/// its position when initially building the set.\n#[derive(Clone)]\npub struct SetMatchesIter<'a>(iter::Enumerate<slice::Iter<'a, bool>>);\n\nimpl<'a> Iterator for SetMatchesIter<'a> {\n    type Item = usize;\n\n    fn next(&mut self) -> Option<usize> {\n        loop {\n            match self.0.next() {\n                None => return None,\n                Some((_, &false)) => {}\n                Some((i, &true)) => return Some(i),\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.0.size_hint()\n    }\n}\n\nimpl<'a> DoubleEndedIterator for SetMatchesIter<'a> {\n    fn next_back(&mut self) -> Option<usize> {\n        loop {\n            match self.0.next_back() {\n                None => return None,\n                Some((_, &false)) => {}\n                Some((i, &true)) => return Some(i),\n            }\n        }\n    }\n}\n\n#[doc(hidden)]\nimpl From<Exec> for RegexSet {\n    fn from(exec: Exec) -> Self {\n        RegexSet(exec)\n    }\n}\n\nimpl fmt::Debug for RegexSet {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"RegexSet({:?})\", self.0.regex_strings())\n    }\n}\n\n#[allow(dead_code)] fn as_bytes_str(text: &str) -> &[u8] { text.as_bytes() }\n#[allow(dead_code)] fn as_bytes_bytes(text: &[u8]) -> &[u8] { text }\n        }\n    }\n}\n\ndefine_set! {\n    unicode,\n    set_unicode,\n    &str,\n    as_bytes_str,\n/// ```rust\n/// # use regex::RegexSet;\n/// let set = RegexSet::new(&[\n///     r\"[a-z]+@[a-z]+\\.(com|org|net)\",\n///     r\"[a-z]+\\.(com|org|net)\",\n/// ]).unwrap();\n///\n/// // Ask whether any regexes in the set match.\n/// assert!(set.is_match(\"foo@example.com\"));\n///\n/// // Identify which regexes in the set match.\n/// let matches: Vec<_> = set.matches(\"foo@example.com\").into_iter().collect();\n/// assert_eq!(vec![0, 1], matches);\n///\n/// // Try again, but with text that only matches one of the regexes.\n/// let matches: Vec<_> = set.matches(\"example.com\").into_iter().collect();\n/// assert_eq!(vec![1], matches);\n///\n/// // Try again, but with text that doesn't match any regex in the set.\n/// let matches: Vec<_> = set.matches(\"example\").into_iter().collect();\n/// assert!(matches.is_empty());\n/// ```\n}\n\ndefine_set! {\n    bytes,\n    set_bytes,\n    &[u8],\n    as_bytes_bytes,\n/// ```rust\n/// # use regex::bytes::RegexSet;\n/// let set = RegexSet::new(&[\n///     r\"[a-z]+@[a-z]+\\.(com|org|net)\",\n///     r\"[a-z]+\\.(com|org|net)\",\n/// ]).unwrap();\n///\n/// // Ask whether any regexes in the set match.\n/// assert!(set.is_match(b\"foo@example.com\"));\n///\n/// // Identify which regexes in the set match.\n/// let matches: Vec<_> = set.matches(b\"foo@example.com\").into_iter().collect();\n/// assert_eq!(vec![0, 1], matches);\n///\n/// // Try again, but with text that only matches one of the regexes.\n/// let matches: Vec<_> = set.matches(b\"example.com\").into_iter().collect();\n/// assert_eq!(vec![1], matches);\n///\n/// // Try again, but with text that doesn't match any regex in the set.\n/// let matches: Vec<_> = set.matches(b\"example\").into_iter().collect();\n/// assert!(matches.is_empty());\n/// ```\n}\n","traces":[{"line":75,"address":[4460896,4460940],"length":1,"stats":{"Line":0},"fn_name":"clone"},{"line":76,"address":[4460908],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[4216912,4217077,4217209,4216949,4217168,4217040],"length":1,"stats":{"Line":7},"fn_name":"new<&[&str; 2],&&str>"},{"line":96,"address":[4217221,4216924,4217185,4216961,4217052,4217089],"length":1,"stats":{"Line":15},"fn_name":null},{"line":123,"address":[4420640],"length":1,"stats":{"Line":13},"fn_name":"is_match"},{"line":124,"address":[4420663],"length":1,"stats":{"Line":13},"fn_name":null},{"line":134,"address":[4420688],"length":1,"stats":{"Line":13},"fn_name":"is_match_at"},{"line":135,"address":[4420861],"length":1,"stats":{"Line":14},"fn_name":null},{"line":174,"address":[4458832,4458914],"length":1,"stats":{"Line":13},"fn_name":"matches"},{"line":175,"address":[4458939,4458866],"length":1,"stats":{"Line":26},"fn_name":null},{"line":176,"address":[4458968,4459055],"length":1,"stats":{"Line":21},"fn_name":null},{"line":177,"address":[4459101],"length":1,"stats":{"Line":15},"fn_name":null},{"line":179,"address":[4459064],"length":1,"stats":{"Line":14},"fn_name":null},{"line":196,"address":[4459184],"length":1,"stats":{"Line":13},"fn_name":"read_matches_at"},{"line":202,"address":[4459346],"length":1,"stats":{"Line":13},"fn_name":null},{"line":206,"address":[4459440],"length":1,"stats":{"Line":0},"fn_name":"len"},{"line":207,"address":[4459449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[4459504],"length":1,"stats":{"Line":8},"fn_name":"patterns"},{"line":238,"address":[4459513],"length":1,"stats":{"Line":8},"fn_name":null},{"line":243,"address":[4461017,4461081,4460976,4461152,4461232,4461311],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":245,"address":[4461269,4461071,4460997,4461244],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[4461012,4461142,4461259,4461291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[4459552],"length":1,"stats":{"Line":17},"fn_name":"matched_any"},{"line":252,"address":[4459557],"length":1,"stats":{"Line":17},"fn_name":null},{"line":263,"address":[4459568],"length":1,"stats":{"Line":8},"fn_name":"matched"},{"line":264,"address":[4459582],"length":1,"stats":{"Line":8},"fn_name":null},{"line":268,"address":[4459616],"length":1,"stats":{"Line":0},"fn_name":"len"},{"line":269,"address":[4459625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[4459648],"length":1,"stats":{"Line":0},"fn_name":"iter"},{"line":278,"address":[4459665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[4459776],"length":1,"stats":{"Line":17},"fn_name":"into_iter"},{"line":287,"address":[4459783],"length":1,"stats":{"Line":17},"fn_name":null},{"line":295,"address":[4459888],"length":1,"stats":{"Line":0},"fn_name":"into_iter"},{"line":296,"address":[4459905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[4459920],"length":1,"stats":{"Line":17},"fn_name":"next"},{"line":311,"address":[4460030,4460028],"length":1,"stats":{"Line":14},"fn_name":null},{"line":312,"address":[4460002,4459937],"length":1,"stats":{"Line":17},"fn_name":null},{"line":313,"address":[4459951,4460004],"length":1,"stats":{"Line":25},"fn_name":null},{"line":314,"address":[4459969],"length":1,"stats":{"Line":13},"fn_name":null},{"line":315,"address":[4459976],"length":1,"stats":{"Line":11},"fn_name":null},{"line":320,"address":[4460032],"length":1,"stats":{"Line":10},"fn_name":"size_hint"},{"line":321,"address":[4460049],"length":1,"stats":{"Line":11},"fn_name":null},{"line":326,"address":[4460064],"length":1,"stats":{"Line":0},"fn_name":"next_back"},{"line":327,"address":[4460172,4460174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[4460081,4460146],"length":1,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[4460095,4460148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[4460113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[4460120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[4461360,4461399],"length":1,"stats":{"Line":0},"fn_name":"clone"},{"line":345,"address":[4461372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[4460176],"length":1,"stats":{"Line":0},"fn_name":"next"},{"line":351,"address":[4460292,4460290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[4460193,4460264],"length":1,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[4460208,4460266],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[4460228],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[4460238],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[4460304],"length":1,"stats":{"Line":0},"fn_name":"size_hint"},{"line":361,"address":[4460321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[4460336],"length":1,"stats":{"Line":0},"fn_name":"next_back"},{"line":367,"address":[4460452,4460450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[4460353,4460424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[4460368,4460426],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[4460388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[4460398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[4460464],"length":1,"stats":{"Line":17},"fn_name":"from"},{"line":380,"address":[4460471],"length":1,"stats":{"Line":18},"fn_name":null},{"line":385,"address":[4460560],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":386,"address":[4460583],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[4460846,4460851,4460784],"length":1,"stats":{"Line":16},"fn_name":"as_bytes_str"},{"line":391,"address":[4460864,4460877,4460888],"length":1,"stats":{"Line":11},"fn_name":"as_bytes_bytes"}],"covered":33,"coverable":70},{"path":["/","usr","src","regex","src","re_trait.rs"],"content":"/// Slot is a single saved capture location. Note that there are two slots for\n/// every capture in a regular expression (one slot each for the start and end\n/// of the capture).\npub type Slot = Option<usize>;\n\n/// Locations represents the offsets of each capturing group in a regex for\n/// a single match.\n///\n/// Unlike `Captures`, a `Locations` value only stores offsets.\n#[doc(hidden)]\n#[derive(Clone, Debug)]\npub struct Locations(Vec<Slot>);\n\nimpl Locations {\n    /// Returns the start and end positions of the Nth capture group. Returns\n    /// `None` if `i` is not a valid capture group or if the capture group did\n    /// not match anything. The positions returned are *always* byte indices\n    /// with respect to the original string matched.\n    pub fn pos(&self, i: usize) -> Option<(usize, usize)> {\n        let (s, e) = (i * 2, i * 2 + 1);\n        match (self.0.get(s), self.0.get(e)) {\n            (Some(&Some(s)), Some(&Some(e))) => Some((s, e)),\n            _ => None,\n        }\n    }\n\n    /// Creates an iterator of all the capture group positions in order of\n    /// appearance in the regular expression. Positions are byte indices\n    /// in terms of the original string matched.\n    pub fn iter(&self) -> SubCapturesPosIter {\n        SubCapturesPosIter { idx: 0, locs: self }\n    }\n\n    /// Returns the total number of capturing groups.\n    ///\n    /// This is always at least `1` since every regex has at least `1`\n    /// capturing group that corresponds to the entire match.\n    pub fn len(&self) -> usize {\n        self.0.len() / 2\n    }\n\n    /// Return the individual slots as a slice.\n    pub(crate) fn as_slots(&mut self) -> &mut [Slot] {\n        &mut self.0\n    }\n}\n\n/// An iterator over capture group positions for a particular match of a\n/// regular expression.\n///\n/// Positions are byte indices in terms of the original string matched.\n///\n/// `'c` is the lifetime of the captures.\npub struct SubCapturesPosIter<'c> {\n    idx: usize,\n    locs: &'c Locations,\n}\n\nimpl<'c> Iterator for SubCapturesPosIter<'c> {\n    type Item = Option<(usize, usize)>;\n\n    fn next(&mut self) -> Option<Option<(usize, usize)>> {\n        if self.idx >= self.locs.len() {\n            return None;\n        }\n        let x = match self.locs.pos(self.idx) {\n            None => Some(None),\n            Some((s, e)) => Some(Some((s, e))),\n        };\n        self.idx += 1;\n        x\n    }\n}\n\n/// `RegularExpression` describes types that can implement regex searching.\n///\n/// This trait is my attempt at reducing code duplication and to standardize\n/// the internal API. Specific duplication that is avoided are the `find`\n/// and `capture` iterators, which are slightly tricky.\n///\n/// It's not clear whether this trait is worth it, and it also isn't\n/// clear whether it's useful as a public trait or not. Methods like\n/// `next_after_empty` reak of bad design, but the rest of the methods seem\n/// somewhat reasonable. One particular thing this trait would expose would be\n/// the ability to start the search of a regex anywhere in a haystack, which\n/// isn't possible in the current public API.\npub trait RegularExpression: Sized {\n    /// The type of the haystack.\n    type Text: ?Sized;\n\n    /// The number of capture slots in the compiled regular expression. This is\n    /// always two times the number of capture groups (two slots per group).\n    fn slots_len(&self) -> usize;\n\n    /// Allocates fresh space for all capturing groups in this regex.\n    fn locations(&self) -> Locations {\n        Locations(vec![None; self.slots_len()])\n    }\n\n    /// Returns the position of the next character after `i`.\n    ///\n    /// For example, a haystack with type `&[u8]` probably returns `i+1`,\n    /// whereas a haystack with type `&str` probably returns `i` plus the\n    /// length of the next UTF-8 sequence.\n    fn next_after_empty(&self, text: &Self::Text, i: usize) -> usize;\n\n    /// Returns the location of the shortest match.\n    fn shortest_match_at(\n        &self,\n        text: &Self::Text,\n        start: usize,\n    ) -> Option<usize>;\n\n    /// Returns whether the regex matches the text given.\n    fn is_match_at(&self, text: &Self::Text, start: usize) -> bool;\n\n    /// Returns the leftmost-first match location if one exists.\n    fn find_at(\n        &self,\n        text: &Self::Text,\n        start: usize,\n    ) -> Option<(usize, usize)>;\n\n    /// Returns the leftmost-first match location if one exists, and also\n    /// fills in any matching capture slot locations.\n    fn captures_read_at(\n        &self,\n        locs: &mut Locations,\n        text: &Self::Text,\n        start: usize,\n    ) -> Option<(usize, usize)>;\n\n    /// Returns an iterator over all non-overlapping successive leftmost-first\n    /// matches.\n    fn find_iter(self, text: &Self::Text) -> Matches<Self> {\n        Matches { re: self, text: text, last_end: 0, last_match: None }\n    }\n\n    /// Returns an iterator over all non-overlapping successive leftmost-first\n    /// matches with captures.\n    fn captures_iter(self, text: &Self::Text) -> CaptureMatches<Self> {\n        CaptureMatches(self.find_iter(text))\n    }\n}\n\n/// An iterator over all non-overlapping successive leftmost-first matches.\npub struct Matches<'t, R>\nwhere\n    R: RegularExpression,\n    R::Text: 't,\n{\n    re: R,\n    text: &'t R::Text,\n    last_end: usize,\n    last_match: Option<usize>,\n}\n\nimpl<'t, R> Matches<'t, R>\nwhere\n    R: RegularExpression,\n    R::Text: 't,\n{\n    /// Return the text being searched.\n    pub fn text(&self) -> &'t R::Text {\n        self.text\n    }\n\n    /// Return the underlying regex.\n    pub fn regex(&self) -> &R {\n        &self.re\n    }\n}\n\nimpl<'t, R> Iterator for Matches<'t, R>\nwhere\n    R: RegularExpression,\n    R::Text: 't + AsRef<[u8]>,\n{\n    type Item = (usize, usize);\n\n    fn next(&mut self) -> Option<(usize, usize)> {\n        if self.last_end > self.text.as_ref().len() {\n            return None;\n        }\n        let (s, e) = match self.re.find_at(self.text, self.last_end) {\n            None => return None,\n            Some((s, e)) => (s, e),\n        };\n        if s == e {\n            // This is an empty match. To ensure we make progress, start\n            // the next search at the smallest possible starting position\n            // of the next match following this one.\n            self.last_end = self.re.next_after_empty(self.text, e);\n            // Don't accept empty matches immediately following a match.\n            // Just move on to the next match.\n            if Some(e) == self.last_match {\n                return self.next();\n            }\n        } else {\n            self.last_end = e;\n        }\n        self.last_match = Some(e);\n        Some((s, e))\n    }\n}\n\n/// An iterator over all non-overlapping successive leftmost-first matches with\n/// captures.\npub struct CaptureMatches<'t, R>(Matches<'t, R>)\nwhere\n    R: RegularExpression,\n    R::Text: 't;\n\nimpl<'t, R> CaptureMatches<'t, R>\nwhere\n    R: RegularExpression,\n    R::Text: 't,\n{\n    /// Return the text being searched.\n    pub fn text(&self) -> &'t R::Text {\n        self.0.text()\n    }\n\n    /// Return the underlying regex.\n    pub fn regex(&self) -> &R {\n        self.0.regex()\n    }\n}\n\nimpl<'t, R> Iterator for CaptureMatches<'t, R>\nwhere\n    R: RegularExpression,\n    R::Text: 't + AsRef<[u8]>,\n{\n    type Item = Locations;\n\n    fn next(&mut self) -> Option<Locations> {\n        if self.0.last_end > self.0.text.as_ref().len() {\n            return None;\n        }\n        let mut locs = self.0.re.locations();\n        let (s, e) = match self.0.re.captures_read_at(\n            &mut locs,\n            self.0.text,\n            self.0.last_end,\n        ) {\n            None => return None,\n            Some((s, e)) => (s, e),\n        };\n        if s == e {\n            self.0.last_end = self.0.re.next_after_empty(self.0.text, e);\n            if Some(e) == self.0.last_match {\n                return self.next();\n            }\n        } else {\n            self.0.last_end = e;\n        }\n        self.0.last_match = Some(e);\n        Some(locs)\n    }\n}\n","traces":[{"line":19,"address":[5672240],"length":1,"stats":{"Line":15},"fn_name":"pos"},{"line":20,"address":[5672271,5672761],"length":1,"stats":{"Line":15},"fn_name":null},{"line":21,"address":[5672443,5672595],"length":1,"stats":{"Line":24},"fn_name":null},{"line":22,"address":[5672559,5672604],"length":1,"stats":{"Line":30},"fn_name":null},{"line":23,"address":[5672588],"length":1,"stats":{"Line":8},"fn_name":null},{"line":30,"address":[5672864],"length":1,"stats":{"Line":8},"fn_name":"iter"},{"line":38,"address":[5672912],"length":1,"stats":{"Line":8},"fn_name":"len"},{"line":39,"address":[5672921],"length":1,"stats":{"Line":8},"fn_name":null},{"line":43,"address":[5672960],"length":1,"stats":{"Line":23},"fn_name":"as_slots"},{"line":44,"address":[5672969],"length":1,"stats":{"Line":21},"fn_name":null},{"line":62,"address":[5673008],"length":1,"stats":{"Line":8},"fn_name":"next"},{"line":63,"address":[5673026],"length":1,"stats":{"Line":8},"fn_name":null},{"line":64,"address":[5673110],"length":1,"stats":{"Line":8},"fn_name":null},{"line":66,"address":[5673086,5673261],"length":1,"stats":{"Line":16},"fn_name":null},{"line":67,"address":[5673265,5673130],"length":1,"stats":{"Line":16},"fn_name":null},{"line":68,"address":[5673142],"length":1,"stats":{"Line":8},"fn_name":null},{"line":70,"address":[5673309,5673409,5673379],"length":1,"stats":{"Line":8},"fn_name":null},{"line":71,"address":[5673343],"length":1,"stats":{"Line":8},"fn_name":null},{"line":96,"address":[4898496,4898608],"length":1,"stats":{"Line":21},"fn_name":"locations<regex::exec::ExecNoSyncStr>"},{"line":97,"address":[4898508,4898620],"length":1,"stats":{"Line":23},"fn_name":null},{"line":135,"address":[4898800,4898720],"length":1,"stats":{"Line":15},"fn_name":"find_iter<regex::exec::ExecNoSync>"},{"line":136,"address":[4898747,4898827],"length":1,"stats":{"Line":15},"fn_name":null},{"line":141,"address":[4898880,4898976],"length":1,"stats":{"Line":8},"fn_name":"captures_iter<regex::exec::ExecNoSyncStr>"},{"line":142,"address":[4899003,4898907],"length":1,"stats":{"Line":8},"fn_name":null},{"line":164,"address":[5440944,5440960],"length":1,"stats":{"Line":15},"fn_name":"text<regex::exec::ExecNoSyncStr>"},{"line":165,"address":[5440965,5440949],"length":1,"stats":{"Line":16},"fn_name":null},{"line":169,"address":[5440976,5440992],"length":1,"stats":{"Line":8},"fn_name":"regex<regex::exec::ExecNoSync>"},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[5504496,5441008],"length":1,"stats":{"Line":17},"fn_name":"next<regex::exec::ExecNoSync>"},{"line":182,"address":[5441033,5504521],"length":1,"stats":{"Line":16},"fn_name":null},{"line":183,"address":[5504017,5567584],"length":1,"stats":{"Line":9},"fn_name":null},{"line":185,"address":[5504007,5441176,5567574,5504153,5504663,5504104,5567720,5567671],"length":1,"stats":{"Line":52},"fn_name":null},{"line":186,"address":[5504041,5567730,5567608,5504163],"length":1,"stats":{"Line":35},"fn_name":null},{"line":187,"address":[5567623,5504056],"length":1,"stats":{"Line":15},"fn_name":null},{"line":189,"address":[5567703,5504136,5504318,5504192,5567885,5567759],"length":1,"stats":{"Line":38},"fn_name":null},{"line":193,"address":[5504213,5567780],"length":1,"stats":{"Line":13},"fn_name":null},{"line":196,"address":[5504261,5567828],"length":1,"stats":{"Line":10},"fn_name":null},{"line":197,"address":[5567903,5504336],"length":1,"stats":{"Line":10},"fn_name":null},{"line":200,"address":[5567755,5504188],"length":1,"stats":{"Line":11},"fn_name":null},{"line":202,"address":[5504351,5567918],"length":1,"stats":{"Line":17},"fn_name":null},{"line":203,"address":[5567975,5504408],"length":1,"stats":{"Line":12},"fn_name":null},{"line":220,"address":[5568112,5568064],"length":1,"stats":{"Line":8},"fn_name":"text<regex::exec::ExecNoSyncStr>"},{"line":221,"address":[5568121,5568073],"length":1,"stats":{"Line":8},"fn_name":null},{"line":225,"address":[5568160,5568192],"length":1,"stats":{"Line":8},"fn_name":"regex<regex::exec::ExecNoSyncStr>"},{"line":226,"address":[5568169,5568201],"length":1,"stats":{"Line":8},"fn_name":null},{"line":237,"address":[5568298,5568224,5568912,5568985],"length":1,"stats":{"Line":8},"fn_name":"next<regex::exec::ExecNoSync>"},{"line":238,"address":[5569010,5568323,5568930,5568242],"length":1,"stats":{"Line":16},"fn_name":null},{"line":239,"address":[5569061,5568374],"length":1,"stats":{"Line":8},"fn_name":null},{"line":241,"address":[5569041,5568354],"length":1,"stats":{"Line":8},"fn_name":null},{"line":242,"address":[5569314,5568546,5568508,5568424,5569358],"length":1,"stats":{"Line":11},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[5569086,5568399],"length":1,"stats":{"Line":8},"fn_name":null},{"line":245,"address":[5568407,5569094],"length":1,"stats":{"Line":8},"fn_name":null},{"line":247,"address":[5568570,5568553,5569365,5569382,5569234,5568434],"length":1,"stats":{"Line":28},"fn_name":null},{"line":248,"address":[5568466,5569266],"length":1,"stats":{"Line":8},"fn_name":null},{"line":250,"address":[5569401,5568589,5568534,5568716,5569346,5569528],"length":1,"stats":{"Line":24},"fn_name":null},{"line":251,"address":[5569411,5568599],"length":1,"stats":{"Line":8},"fn_name":null},{"line":252,"address":[5569458,5568646],"length":1,"stats":{"Line":8},"fn_name":null},{"line":253,"address":[5568728,5569540],"length":1,"stats":{"Line":8},"fn_name":null},{"line":256,"address":[5569397,5568585],"length":1,"stats":{"Line":8},"fn_name":null},{"line":258,"address":[5568745,5569557],"length":1,"stats":{"Line":8},"fn_name":null},{"line":259,"address":[5569606,5568794],"length":1,"stats":{"Line":8},"fn_name":null}],"covered":60,"coverable":62},{"path":["/","usr","src","regex","src","re_unicode.rs"],"content":"use std::borrow::Cow;\nuse std::collections::HashMap;\nuse std::fmt;\nuse std::ops::{Index, Range};\nuse std::str::FromStr;\nuse std::sync::Arc;\n\nuse find_byte::find_byte;\nuse syntax;\n\nuse error::Error;\nuse exec::{Exec, ExecNoSyncStr};\nuse expand::expand_str;\nuse re_builder::unicode::RegexBuilder;\nuse re_trait::{self, RegularExpression, SubCapturesPosIter};\n\n/// Escapes all regular expression meta characters in `text`.\n///\n/// The string returned may be safely used as a literal in a regular\n/// expression.\npub fn escape(text: &str) -> String {\n    syntax::escape(text)\n}\n\n/// Match represents a single match of a regex in a haystack.\n///\n/// The lifetime parameter `'t` refers to the lifetime of the matched text.\n#[derive(Copy, Clone, Debug, Eq, PartialEq)]\npub struct Match<'t> {\n    text: &'t str,\n    start: usize,\n    end: usize,\n}\n\nimpl<'t> Match<'t> {\n    /// Returns the starting byte offset of the match in the haystack.\n    #[inline]\n    pub fn start(&self) -> usize {\n        self.start\n    }\n\n    /// Returns the ending byte offset of the match in the haystack.\n    #[inline]\n    pub fn end(&self) -> usize {\n        self.end\n    }\n\n    /// Returns the range over the starting and ending byte offsets of the\n    /// match in the haystack.\n    #[inline]\n    pub fn range(&self) -> Range<usize> {\n        self.start..self.end\n    }\n\n    /// Returns the matched text.\n    #[inline]\n    pub fn as_str(&self) -> &'t str {\n        &self.text[self.range()]\n    }\n\n    /// Creates a new match from the given haystack and byte offsets.\n    #[inline]\n    fn new(haystack: &'t str, start: usize, end: usize) -> Match<'t> {\n        Match { text: haystack, start: start, end: end }\n    }\n}\n\nimpl<'t> From<Match<'t>> for &'t str {\n    fn from(m: Match<'t>) -> &'t str {\n        m.as_str()\n    }\n}\n\nimpl<'t> From<Match<'t>> for Range<usize> {\n    fn from(m: Match<'t>) -> Range<usize> {\n        m.range()\n    }\n}\n\n/// A compiled regular expression for matching Unicode strings.\n///\n/// It is represented as either a sequence of bytecode instructions (dynamic)\n/// or as a specialized Rust function (native). It can be used to search, split\n/// or replace text. All searching is done with an implicit `.*?` at the\n/// beginning and end of an expression. To force an expression to match the\n/// whole string (or a prefix or a suffix), you must use an anchor like `^` or\n/// `$` (or `\\A` and `\\z`).\n///\n/// While this crate will handle Unicode strings (whether in the regular\n/// expression or in the search text), all positions returned are **byte\n/// indices**. Every byte index is guaranteed to be at a Unicode code point\n/// boundary.\n///\n/// The lifetimes `'r` and `'t` in this crate correspond to the lifetime of a\n/// compiled regular expression and text to search, respectively.\n///\n/// The only methods that allocate new strings are the string replacement\n/// methods. All other methods (searching and splitting) return borrowed\n/// pointers into the string given.\n///\n/// # Examples\n///\n/// Find the location of a US phone number:\n///\n/// ```rust\n/// # use regex::Regex;\n/// let re = Regex::new(\"[0-9]{3}-[0-9]{3}-[0-9]{4}\").unwrap();\n/// let mat = re.find(\"phone: 111-222-3333\").unwrap();\n/// assert_eq!((mat.start(), mat.end()), (7, 19));\n/// ```\n///\n/// # Using the `std::str::pattern` methods with `Regex`\n///\n/// > **Note**: This section requires that this crate is compiled with the\n/// > `pattern` Cargo feature enabled, which **requires nightly Rust**.\n///\n/// Since `Regex` implements `Pattern`, you can use regexes with methods\n/// defined on `&str`. For example, `is_match`, `find`, `find_iter`\n/// and `split` can be replaced with `str::contains`, `str::find`,\n/// `str::match_indices` and `str::split`.\n///\n/// Here are some examples:\n///\n/// ```rust,ignore\n/// # use regex::Regex;\n/// let re = Regex::new(r\"\\d+\").unwrap();\n/// let haystack = \"a111b222c\";\n///\n/// assert!(haystack.contains(&re));\n/// assert_eq!(haystack.find(&re), Some(1));\n/// assert_eq!(haystack.match_indices(&re).collect::<Vec<_>>(),\n///            vec![(1, 4), (5, 8)]);\n/// assert_eq!(haystack.split(&re).collect::<Vec<_>>(), vec![\"a\", \"b\", \"c\"]);\n/// ```\n#[derive(Clone)]\npub struct Regex(Exec);\n\nimpl fmt::Display for Regex {\n    /// Shows the original regular expression.\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{}\", self.as_str())\n    }\n}\n\nimpl fmt::Debug for Regex {\n    /// Shows the original regular expression.\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Display::fmt(self, f)\n    }\n}\n\n#[doc(hidden)]\nimpl From<Exec> for Regex {\n    fn from(exec: Exec) -> Regex {\n        Regex(exec)\n    }\n}\n\nimpl FromStr for Regex {\n    type Err = Error;\n\n    /// Attempts to parse a string into a regular expression\n    fn from_str(s: &str) -> Result<Regex, Error> {\n        Regex::new(s)\n    }\n}\n\n/// Core regular expression methods.\nimpl Regex {\n    /// Compiles a regular expression. Once compiled, it can be used repeatedly\n    /// to search, split or replace text in a string.\n    ///\n    /// If an invalid expression is given, then an error is returned.\n    pub fn new(re: &str) -> Result<Regex, Error> {\n        RegexBuilder::new(re).build()\n    }\n\n    /// Returns true if and only if the regex matches the string given.\n    ///\n    /// It is recommended to use this method if all you need to do is test\n    /// a match, since the underlying matching engine may be able to do less\n    /// work.\n    ///\n    /// # Example\n    ///\n    /// Test if some text contains at least one word with exactly 13\n    /// Unicode word characters:\n    ///\n    /// ```rust\n    /// # extern crate regex; use regex::Regex;\n    /// # fn main() {\n    /// let text = \"I categorically deny having triskaidekaphobia.\";\n    /// assert!(Regex::new(r\"\\b\\w{13}\\b\").unwrap().is_match(text));\n    /// # }\n    /// ```\n    pub fn is_match(&self, text: &str) -> bool {\n        self.is_match_at(text, 0)\n    }\n\n    /// Returns the start and end byte range of the leftmost-first match in\n    /// `text`. If no match exists, then `None` is returned.\n    ///\n    /// Note that this should only be used if you want to discover the position\n    /// of the match. Testing the existence of a match is faster if you use\n    /// `is_match`.\n    ///\n    /// # Example\n    ///\n    /// Find the start and end location of the first word with exactly 13\n    /// Unicode word characters:\n    ///\n    /// ```rust\n    /// # extern crate regex; use regex::Regex;\n    /// # fn main() {\n    /// let text = \"I categorically deny having triskaidekaphobia.\";\n    /// let mat = Regex::new(r\"\\b\\w{13}\\b\").unwrap().find(text).unwrap();\n    /// assert_eq!(mat.start(), 2);\n    /// assert_eq!(mat.end(), 15);\n    /// # }\n    /// ```\n    pub fn find<'t>(&self, text: &'t str) -> Option<Match<'t>> {\n        self.find_at(text, 0)\n    }\n\n    /// Returns an iterator for each successive non-overlapping match in\n    /// `text`, returning the start and end byte indices with respect to\n    /// `text`.\n    ///\n    /// # Example\n    ///\n    /// Find the start and end location of every word with exactly 13 Unicode\n    /// word characters:\n    ///\n    /// ```rust\n    /// # extern crate regex; use regex::Regex;\n    /// # fn main() {\n    /// let text = \"Retroactively relinquishing remunerations is reprehensible.\";\n    /// for mat in Regex::new(r\"\\b\\w{13}\\b\").unwrap().find_iter(text) {\n    ///     println!(\"{:?}\", mat);\n    /// }\n    /// # }\n    /// ```\n    pub fn find_iter<'r, 't>(&'r self, text: &'t str) -> Matches<'r, 't> {\n        Matches(self.0.searcher_str().find_iter(text))\n    }\n\n    /// Returns the capture groups corresponding to the leftmost-first\n    /// match in `text`. Capture group `0` always corresponds to the entire\n    /// match. If no match is found, then `None` is returned.\n    ///\n    /// You should only use `captures` if you need access to the location of\n    /// capturing group matches. Otherwise, `find` is faster for discovering\n    /// the location of the overall match.\n    ///\n    /// # Examples\n    ///\n    /// Say you have some text with movie names and their release years,\n    /// like \"'Citizen Kane' (1941)\". It'd be nice if we could search for text\n    /// looking like that, while also extracting the movie name and its release\n    /// year separately.\n    ///\n    /// ```rust\n    /// # extern crate regex; use regex::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(r\"'([^']+)'\\s+\\((\\d{4})\\)\").unwrap();\n    /// let text = \"Not my favorite movie: 'Citizen Kane' (1941).\";\n    /// let caps = re.captures(text).unwrap();\n    /// assert_eq!(caps.get(1).unwrap().as_str(), \"Citizen Kane\");\n    /// assert_eq!(caps.get(2).unwrap().as_str(), \"1941\");\n    /// assert_eq!(caps.get(0).unwrap().as_str(), \"'Citizen Kane' (1941)\");\n    /// // You can also access the groups by index using the Index notation.\n    /// // Note that this will panic on an invalid index.\n    /// assert_eq!(&caps[1], \"Citizen Kane\");\n    /// assert_eq!(&caps[2], \"1941\");\n    /// assert_eq!(&caps[0], \"'Citizen Kane' (1941)\");\n    /// # }\n    /// ```\n    ///\n    /// Note that the full match is at capture group `0`. Each subsequent\n    /// capture group is indexed by the order of its opening `(`.\n    ///\n    /// We can make this example a bit clearer by using *named* capture groups:\n    ///\n    /// ```rust\n    /// # extern crate regex; use regex::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(r\"'(?P<title>[^']+)'\\s+\\((?P<year>\\d{4})\\)\")\n    ///                .unwrap();\n    /// let text = \"Not my favorite movie: 'Citizen Kane' (1941).\";\n    /// let caps = re.captures(text).unwrap();\n    /// assert_eq!(caps.name(\"title\").unwrap().as_str(), \"Citizen Kane\");\n    /// assert_eq!(caps.name(\"year\").unwrap().as_str(), \"1941\");\n    /// assert_eq!(caps.get(0).unwrap().as_str(), \"'Citizen Kane' (1941)\");\n    /// // You can also access the groups by name using the Index notation.\n    /// // Note that this will panic on an invalid group name.\n    /// assert_eq!(&caps[\"title\"], \"Citizen Kane\");\n    /// assert_eq!(&caps[\"year\"], \"1941\");\n    /// assert_eq!(&caps[0], \"'Citizen Kane' (1941)\");\n    ///\n    /// # }\n    /// ```\n    ///\n    /// Here we name the capture groups, which we can access with the `name`\n    /// method or the `Index` notation with a `&str`. Note that the named\n    /// capture groups are still accessible with `get` or the `Index` notation\n    /// with a `usize`.\n    ///\n    /// The `0`th capture group is always unnamed, so it must always be\n    /// accessed with `get(0)` or `[0]`.\n    pub fn captures<'t>(&self, text: &'t str) -> Option<Captures<'t>> {\n        let mut locs = self.capture_locations();\n        self.captures_read_at(&mut locs, text, 0).map(move |_| Captures {\n            text: text,\n            locs: locs.0,\n            named_groups: self.0.capture_name_idx().clone(),\n        })\n    }\n\n    /// Returns an iterator over all the non-overlapping capture groups matched\n    /// in `text`. This is operationally the same as `find_iter`, except it\n    /// yields information about capturing group matches.\n    ///\n    /// # Example\n    ///\n    /// We can use this to find all movie titles and their release years in\n    /// some text, where the movie is formatted like \"'Title' (xxxx)\":\n    ///\n    /// ```rust\n    /// # extern crate regex; use regex::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(r\"'(?P<title>[^']+)'\\s+\\((?P<year>\\d{4})\\)\")\n    ///                .unwrap();\n    /// let text = \"'Citizen Kane' (1941), 'The Wizard of Oz' (1939), 'M' (1931).\";\n    /// for caps in re.captures_iter(text) {\n    ///     println!(\"Movie: {:?}, Released: {:?}\",\n    ///              &caps[\"title\"], &caps[\"year\"]);\n    /// }\n    /// // Output:\n    /// // Movie: Citizen Kane, Released: 1941\n    /// // Movie: The Wizard of Oz, Released: 1939\n    /// // Movie: M, Released: 1931\n    /// # }\n    /// ```\n    pub fn captures_iter<'r, 't>(\n        &'r self,\n        text: &'t str,\n    ) -> CaptureMatches<'r, 't> {\n        CaptureMatches(self.0.searcher_str().captures_iter(text))\n    }\n\n    /// Returns an iterator of substrings of `text` delimited by a match of the\n    /// regular expression. Namely, each element of the iterator corresponds to\n    /// text that *isn't* matched by the regular expression.\n    ///\n    /// This method will *not* copy the text given.\n    ///\n    /// # Example\n    ///\n    /// To split a string delimited by arbitrary amounts of spaces or tabs:\n    ///\n    /// ```rust\n    /// # extern crate regex; use regex::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(r\"[ \\t]+\").unwrap();\n    /// let fields: Vec<&str> = re.split(\"a b \\t  c\\td    e\").collect();\n    /// assert_eq!(fields, vec![\"a\", \"b\", \"c\", \"d\", \"e\"]);\n    /// # }\n    /// ```\n    pub fn split<'r, 't>(&'r self, text: &'t str) -> Split<'r, 't> {\n        Split { finder: self.find_iter(text), last: 0 }\n    }\n\n    /// Returns an iterator of at most `limit` substrings of `text` delimited\n    /// by a match of the regular expression. (A `limit` of `0` will return no\n    /// substrings.) Namely, each element of the iterator corresponds to text\n    /// that *isn't* matched by the regular expression. The remainder of the\n    /// string that is not split will be the last element in the iterator.\n    ///\n    /// This method will *not* copy the text given.\n    ///\n    /// # Example\n    ///\n    /// Get the first two words in some text:\n    ///\n    /// ```rust\n    /// # extern crate regex; use regex::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(r\"\\W+\").unwrap();\n    /// let fields: Vec<&str> = re.splitn(\"Hey! How are you?\", 3).collect();\n    /// assert_eq!(fields, vec!(\"Hey\", \"How\", \"are you?\"));\n    /// # }\n    /// ```\n    pub fn splitn<'r, 't>(\n        &'r self,\n        text: &'t str,\n        limit: usize,\n    ) -> SplitN<'r, 't> {\n        SplitN { splits: self.split(text), n: limit }\n    }\n\n    /// Replaces the leftmost-first match with the replacement provided.\n    /// The replacement can be a regular string (where `$N` and `$name` are\n    /// expanded to match capture groups) or a function that takes the matches'\n    /// `Captures` and returns the replaced string.\n    ///\n    /// If no match is found, then a copy of the string is returned unchanged.\n    ///\n    /// # Replacement string syntax\n    ///\n    /// All instances of `$name` in the replacement text is replaced with the\n    /// corresponding capture group `name`.\n    ///\n    /// `name` may be an integer corresponding to the index of the\n    /// capture group (counted by order of opening parenthesis where `0` is the\n    /// entire match) or it can be a name (consisting of letters, digits or\n    /// underscores) corresponding to a named capture group.\n    ///\n    /// If `name` isn't a valid capture group (whether the name doesn't exist\n    /// or isn't a valid index), then it is replaced with the empty string.\n    ///\n    /// The longest possible name is used. e.g., `$1a` looks up the capture\n    /// group named `1a` and not the capture group at index `1`. To exert more\n    /// precise control over the name, use braces, e.g., `${1}a`.\n    ///\n    /// To write a literal `$` use `$$`.\n    ///\n    /// # Examples\n    ///\n    /// Note that this function is polymorphic with respect to the replacement.\n    /// In typical usage, this can just be a normal string:\n    ///\n    /// ```rust\n    /// # extern crate regex; use regex::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(\"[^01]+\").unwrap();\n    /// assert_eq!(re.replace(\"1078910\", \"\"), \"1010\");\n    /// # }\n    /// ```\n    ///\n    /// But anything satisfying the `Replacer` trait will work. For example,\n    /// a closure of type `|&Captures| -> String` provides direct access to the\n    /// captures corresponding to a match. This allows one to access\n    /// capturing group matches easily:\n    ///\n    /// ```rust\n    /// # extern crate regex; use regex::Regex;\n    /// # use regex::Captures; fn main() {\n    /// let re = Regex::new(r\"([^,\\s]+),\\s+(\\S+)\").unwrap();\n    /// let result = re.replace(\"Springsteen, Bruce\", |caps: &Captures| {\n    ///     format!(\"{} {}\", &caps[2], &caps[1])\n    /// });\n    /// assert_eq!(result, \"Bruce Springsteen\");\n    /// # }\n    /// ```\n    ///\n    /// But this is a bit cumbersome to use all the time. Instead, a simple\n    /// syntax is supported that expands `$name` into the corresponding capture\n    /// group. Here's the last example, but using this expansion technique\n    /// with named capture groups:\n    ///\n    /// ```rust\n    /// # extern crate regex; use regex::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(r\"(?P<last>[^,\\s]+),\\s+(?P<first>\\S+)\").unwrap();\n    /// let result = re.replace(\"Springsteen, Bruce\", \"$first $last\");\n    /// assert_eq!(result, \"Bruce Springsteen\");\n    /// # }\n    /// ```\n    ///\n    /// Note that using `$2` instead of `$first` or `$1` instead of `$last`\n    /// would produce the same result. To write a literal `$` use `$$`.\n    ///\n    /// Sometimes the replacement string requires use of curly braces to\n    /// delineate a capture group replacement and surrounding literal text.\n    /// For example, if we wanted to join two words together with an\n    /// underscore:\n    ///\n    /// ```rust\n    /// # extern crate regex; use regex::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(r\"(?P<first>\\w+)\\s+(?P<second>\\w+)\").unwrap();\n    /// let result = re.replace(\"deep fried\", \"${first}_$second\");\n    /// assert_eq!(result, \"deep_fried\");\n    /// # }\n    /// ```\n    ///\n    /// Without the curly braces, the capture group name `first_` would be\n    /// used, and since it doesn't exist, it would be replaced with the empty\n    /// string.\n    ///\n    /// Finally, sometimes you just want to replace a literal string with no\n    /// regard for capturing group expansion. This can be done by wrapping a\n    /// byte string with `NoExpand`:\n    ///\n    /// ```rust\n    /// # extern crate regex; use regex::Regex;\n    /// # fn main() {\n    /// use regex::NoExpand;\n    ///\n    /// let re = Regex::new(r\"(?P<last>[^,\\s]+),\\s+(\\S+)\").unwrap();\n    /// let result = re.replace(\"Springsteen, Bruce\", NoExpand(\"$2 $last\"));\n    /// assert_eq!(result, \"$2 $last\");\n    /// # }\n    /// ```\n    pub fn replace<'t, R: Replacer>(\n        &self,\n        text: &'t str,\n        rep: R,\n    ) -> Cow<'t, str> {\n        self.replacen(text, 1, rep)\n    }\n\n    /// Replaces all non-overlapping matches in `text` with the replacement\n    /// provided. This is the same as calling `replacen` with `limit` set to\n    /// `0`.\n    ///\n    /// See the documentation for `replace` for details on how to access\n    /// capturing group matches in the replacement string.\n    pub fn replace_all<'t, R: Replacer>(\n        &self,\n        text: &'t str,\n        rep: R,\n    ) -> Cow<'t, str> {\n        self.replacen(text, 0, rep)\n    }\n\n    /// Replaces at most `limit` non-overlapping matches in `text` with the\n    /// replacement provided. If `limit` is 0, then all non-overlapping matches\n    /// are replaced.\n    ///\n    /// See the documentation for `replace` for details on how to access\n    /// capturing group matches in the replacement string.\n    pub fn replacen<'t, R: Replacer>(\n        &self,\n        text: &'t str,\n        limit: usize,\n        mut rep: R,\n    ) -> Cow<'t, str> {\n        // If we know that the replacement doesn't have any capture expansions,\n        // then we can fast path. The fast path can make a tremendous\n        // difference:\n        //\n        //   1) We use `find_iter` instead of `captures_iter`. Not asking for\n        //      captures generally makes the regex engines faster.\n        //   2) We don't need to look up all of the capture groups and do\n        //      replacements inside the replacement string. We just push it\n        //      at each match and be done with it.\n        if let Some(rep) = rep.no_expansion() {\n            let mut it = self.find_iter(text).enumerate().peekable();\n            if it.peek().is_none() {\n                return Cow::Borrowed(text);\n            }\n            let mut new = String::with_capacity(text.len());\n            let mut last_match = 0;\n            for (i, m) in it {\n                if limit > 0 && i >= limit {\n                    break;\n                }\n                new.push_str(&text[last_match..m.start()]);\n                new.push_str(&rep);\n                last_match = m.end();\n            }\n            new.push_str(&text[last_match..]);\n            return Cow::Owned(new);\n        }\n\n        // The slower path, which we use if the replacement needs access to\n        // capture groups.\n        let mut it = self.captures_iter(text).enumerate().peekable();\n        if it.peek().is_none() {\n            return Cow::Borrowed(text);\n        }\n        let mut new = String::with_capacity(text.len());\n        let mut last_match = 0;\n        for (i, cap) in it {\n            if limit > 0 && i >= limit {\n                break;\n            }\n            // unwrap on 0 is OK because captures only reports matches\n            let m = cap.get(0).unwrap();\n            new.push_str(&text[last_match..m.start()]);\n            rep.replace_append(&cap, &mut new);\n            last_match = m.end();\n        }\n        new.push_str(&text[last_match..]);\n        Cow::Owned(new)\n    }\n}\n\n/// Advanced or \"lower level\" search methods.\nimpl Regex {\n    /// Returns the end location of a match in the text given.\n    ///\n    /// This method may have the same performance characteristics as\n    /// `is_match`, except it provides an end location for a match. In\n    /// particular, the location returned *may be shorter* than the proper end\n    /// of the leftmost-first match.\n    ///\n    /// # Example\n    ///\n    /// Typically, `a+` would match the entire first sequence of `a` in some\n    /// text, but `shortest_match` can give up as soon as it sees the first\n    /// `a`.\n    ///\n    /// ```rust\n    /// # extern crate regex; use regex::Regex;\n    /// # fn main() {\n    /// let text = \"aaaaa\";\n    /// let pos = Regex::new(r\"a+\").unwrap().shortest_match(text);\n    /// assert_eq!(pos, Some(1));\n    /// # }\n    /// ```\n    pub fn shortest_match(&self, text: &str) -> Option<usize> {\n        self.shortest_match_at(text, 0)\n    }\n\n    /// Returns the same as shortest_match, but starts the search at the given\n    /// offset.\n    ///\n    /// The significance of the starting point is that it takes the surrounding\n    /// context into consideration. For example, the `\\A` anchor can only\n    /// match when `start == 0`.\n    pub fn shortest_match_at(\n        &self,\n        text: &str,\n        start: usize,\n    ) -> Option<usize> {\n        self.0.searcher_str().shortest_match_at(text, start)\n    }\n\n    /// Returns the same as is_match, but starts the search at the given\n    /// offset.\n    ///\n    /// The significance of the starting point is that it takes the surrounding\n    /// context into consideration. For example, the `\\A` anchor can only\n    /// match when `start == 0`.\n    pub fn is_match_at(&self, text: &str, start: usize) -> bool {\n        self.shortest_match_at(text, start).is_some()\n    }\n\n    /// Returns the same as find, but starts the search at the given\n    /// offset.\n    ///\n    /// The significance of the starting point is that it takes the surrounding\n    /// context into consideration. For example, the `\\A` anchor can only\n    /// match when `start == 0`.\n    pub fn find_at<'t>(\n        &self,\n        text: &'t str,\n        start: usize,\n    ) -> Option<Match<'t>> {\n        self.0\n            .searcher_str()\n            .find_at(text, start)\n            .map(|(s, e)| Match::new(text, s, e))\n    }\n\n    /// This is like `captures`, but uses\n    /// [`CaptureLocations`](struct.CaptureLocations.html)\n    /// instead of\n    /// [`Captures`](struct.Captures.html) in order to amortize allocations.\n    ///\n    /// To create a `CaptureLocations` value, use the\n    /// `Regex::capture_locations` method.\n    ///\n    /// This returns the overall match if this was successful, which is always\n    /// equivalence to the `0`th capture group.\n    pub fn captures_read<'t>(\n        &self,\n        locs: &mut CaptureLocations,\n        text: &'t str,\n    ) -> Option<Match<'t>> {\n        self.captures_read_at(locs, text, 0)\n    }\n\n    /// Returns the same as captures, but starts the search at the given\n    /// offset and populates the capture locations given.\n    ///\n    /// The significance of the starting point is that it takes the surrounding\n    /// context into consideration. For example, the `\\A` anchor can only\n    /// match when `start == 0`.\n    pub fn captures_read_at<'t>(\n        &self,\n        locs: &mut CaptureLocations,\n        text: &'t str,\n        start: usize,\n    ) -> Option<Match<'t>> {\n        self.0\n            .searcher_str()\n            .captures_read_at(&mut locs.0, text, start)\n            .map(|(s, e)| Match::new(text, s, e))\n    }\n\n    /// An undocumented alias for `captures_read_at`.\n    ///\n    /// The `regex-capi` crate previously used this routine, so to avoid\n    /// breaking that crate, we continue to provide the name as an undocumented\n    /// alias.\n    #[doc(hidden)]\n    pub fn read_captures_at<'t>(\n        &self,\n        locs: &mut CaptureLocations,\n        text: &'t str,\n        start: usize,\n    ) -> Option<Match<'t>> {\n        self.captures_read_at(locs, text, start)\n    }\n}\n\n/// Auxiliary methods.\nimpl Regex {\n    /// Returns the original string of this regex.\n    pub fn as_str(&self) -> &str {\n        &self.0.regex_strings()[0]\n    }\n\n    /// Returns an iterator over the capture names.\n    pub fn capture_names(&self) -> CaptureNames {\n        CaptureNames(self.0.capture_names().iter())\n    }\n\n    /// Returns the number of captures.\n    pub fn captures_len(&self) -> usize {\n        self.0.capture_names().len()\n    }\n\n    /// Returns an empty set of capture locations that can be reused in\n    /// multiple calls to `captures_read` or `captures_read_at`.\n    pub fn capture_locations(&self) -> CaptureLocations {\n        CaptureLocations(self.0.searcher_str().locations())\n    }\n\n    /// An alias for `capture_locations` to preserve backward compatibility.\n    ///\n    /// The `regex-capi` crate uses this method, so to avoid breaking that\n    /// crate, we continue to export it as an undocumented API.\n    #[doc(hidden)]\n    pub fn locations(&self) -> CaptureLocations {\n        CaptureLocations(self.0.searcher_str().locations())\n    }\n}\n\n/// An iterator over the names of all possible captures.\n///\n/// `None` indicates an unnamed capture; the first element (capture 0, the\n/// whole matched region) is always unnamed.\n///\n/// `'r` is the lifetime of the compiled regular expression.\npub struct CaptureNames<'r>(::std::slice::Iter<'r, Option<String>>);\n\nimpl<'r> Iterator for CaptureNames<'r> {\n    type Item = Option<&'r str>;\n\n    fn next(&mut self) -> Option<Option<&'r str>> {\n        self.0\n            .next()\n            .as_ref()\n            .map(|slot| slot.as_ref().map(|name| name.as_ref()))\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.0.size_hint()\n    }\n}\n\n/// Yields all substrings delimited by a regular expression match.\n///\n/// `'r` is the lifetime of the compiled regular expression and `'t` is the\n/// lifetime of the string being split.\npub struct Split<'r, 't> {\n    finder: Matches<'r, 't>,\n    last: usize,\n}\n\nimpl<'r, 't> Iterator for Split<'r, 't> {\n    type Item = &'t str;\n\n    fn next(&mut self) -> Option<&'t str> {\n        let text = self.finder.0.text();\n        match self.finder.next() {\n            None => {\n                if self.last > text.len() {\n                    None\n                } else {\n                    let s = &text[self.last..];\n                    self.last = text.len() + 1; // Next call will return None\n                    Some(s)\n                }\n            }\n            Some(m) => {\n                let matched = &text[self.last..m.start()];\n                self.last = m.end();\n                Some(matched)\n            }\n        }\n    }\n}\n\n/// Yields at most `N` substrings delimited by a regular expression match.\n///\n/// The last substring will be whatever remains after splitting.\n///\n/// `'r` is the lifetime of the compiled regular expression and `'t` is the\n/// lifetime of the string being split.\npub struct SplitN<'r, 't> {\n    splits: Split<'r, 't>,\n    n: usize,\n}\n\nimpl<'r, 't> Iterator for SplitN<'r, 't> {\n    type Item = &'t str;\n\n    fn next(&mut self) -> Option<&'t str> {\n        if self.n == 0 {\n            return None;\n        }\n\n        self.n -= 1;\n        if self.n > 0 {\n            return self.splits.next();\n        }\n\n        let text = self.splits.finder.0.text();\n        if self.splits.last > text.len() {\n            // We've already returned all substrings.\n            None\n        } else {\n            // self.n == 0, so future calls will return None immediately\n            Some(&text[self.splits.last..])\n        }\n    }\n}\n\n/// CaptureLocations is a low level representation of the raw offsets of each\n/// submatch.\n///\n/// You can think of this as a lower level\n/// [`Captures`](struct.Captures.html), where this type does not support\n/// named capturing groups directly and it does not borrow the text that these\n/// offsets were matched on.\n///\n/// Primarily, this type is useful when using the lower level `Regex` APIs\n/// such as `read_captures`, which permits amortizing the allocation in which\n/// capture match locations are stored.\n///\n/// In order to build a value of this type, you'll need to call the\n/// `capture_locations` method on the `Regex` being used to execute the search.\n/// The value returned can then be reused in subsequent searches.\n#[derive(Clone, Debug)]\npub struct CaptureLocations(re_trait::Locations);\n\n/// A type alias for `CaptureLocations` for backwards compatibility.\n///\n/// Previously, we exported `CaptureLocations` as `Locations` in an\n/// undocumented API. To prevent breaking that code (e.g., in `regex-capi`),\n/// we continue re-exporting the same undocumented API.\n#[doc(hidden)]\npub type Locations = CaptureLocations;\n\nimpl CaptureLocations {\n    /// Returns the start and end positions of the Nth capture group. Returns\n    /// `None` if `i` is not a valid capture group or if the capture group did\n    /// not match anything. The positions returned are *always* byte indices\n    /// with respect to the original string matched.\n    #[inline]\n    pub fn get(&self, i: usize) -> Option<(usize, usize)> {\n        self.0.pos(i)\n    }\n\n    /// Returns the total number of capturing groups.\n    ///\n    /// This is always at least `1` since every regex has at least `1`\n    /// capturing group that corresponds to the entire match.\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.0.len()\n    }\n\n    /// An alias for the `get` method for backwards compatibility.\n    ///\n    /// Previously, we exported `get` as `pos` in an undocumented API. To\n    /// prevent breaking that code (e.g., in `regex-capi`), we continue\n    /// re-exporting the same undocumented API.\n    #[doc(hidden)]\n    #[inline]\n    pub fn pos(&self, i: usize) -> Option<(usize, usize)> {\n        self.get(i)\n    }\n}\n\n/// Captures represents a group of captured strings for a single match.\n///\n/// The 0th capture always corresponds to the entire match. Each subsequent\n/// index corresponds to the next capture group in the regex. If a capture\n/// group is named, then the matched string is *also* available via the `name`\n/// method. (Note that the 0th capture is always unnamed and so must be\n/// accessed with the `get` method.)\n///\n/// Positions returned from a capture group are always byte indices.\n///\n/// `'t` is the lifetime of the matched text.\npub struct Captures<'t> {\n    text: &'t str,\n    locs: re_trait::Locations,\n    named_groups: Arc<HashMap<String, usize>>,\n}\n\nimpl<'t> Captures<'t> {\n    /// Returns the match associated with the capture group at index `i`. If\n    /// `i` does not correspond to a capture group, or if the capture group\n    /// did not participate in the match, then `None` is returned.\n    ///\n    /// # Examples\n    ///\n    /// Get the text of the match with a default of an empty string if this\n    /// group didn't participate in the match:\n    ///\n    /// ```rust\n    /// # use regex::Regex;\n    /// let re = Regex::new(r\"[a-z]+(?:([0-9]+)|([A-Z]+))\").unwrap();\n    /// let caps = re.captures(\"abc123\").unwrap();\n    ///\n    /// let text1 = caps.get(1).map_or(\"\", |m| m.as_str());\n    /// let text2 = caps.get(2).map_or(\"\", |m| m.as_str());\n    /// assert_eq!(text1, \"123\");\n    /// assert_eq!(text2, \"\");\n    /// ```\n    pub fn get(&self, i: usize) -> Option<Match<'t>> {\n        self.locs.pos(i).map(|(s, e)| Match::new(self.text, s, e))\n    }\n\n    /// Returns the match for the capture group named `name`. If `name` isn't a\n    /// valid capture group or didn't match anything, then `None` is returned.\n    pub fn name(&self, name: &str) -> Option<Match<'t>> {\n        self.named_groups.get(name).and_then(|&i| self.get(i))\n    }\n\n    /// An iterator that yields all capturing matches in the order in which\n    /// they appear in the regex. If a particular capture group didn't\n    /// participate in the match, then `None` is yielded for that capture.\n    ///\n    /// The first match always corresponds to the overall match of the regex.\n    pub fn iter<'c>(&'c self) -> SubCaptureMatches<'c, 't> {\n        SubCaptureMatches { caps: self, it: self.locs.iter() }\n    }\n\n    /// Expands all instances of `$name` in `replacement` to the corresponding\n    /// capture group `name`, and writes them to the `dst` buffer given.\n    ///\n    /// `name` may be an integer corresponding to the index of the\n    /// capture group (counted by order of opening parenthesis where `0` is the\n    /// entire match) or it can be a name (consisting of letters, digits or\n    /// underscores) corresponding to a named capture group.\n    ///\n    /// If `name` isn't a valid capture group (whether the name doesn't exist\n    /// or isn't a valid index), then it is replaced with the empty string.\n    ///\n    /// The longest possible name is used. e.g., `$1a` looks up the capture\n    /// group named `1a` and not the capture group at index `1`. To exert more\n    /// precise control over the name, use braces, e.g., `${1}a`.\n    ///\n    /// To write a literal `$` use `$$`.\n    pub fn expand(&self, replacement: &str, dst: &mut String) {\n        expand_str(self, replacement, dst)\n    }\n\n    /// Returns the number of captured groups.\n    ///\n    /// This is always at least `1`, since every regex has at least one capture\n    /// group that corresponds to the full match.\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.locs.len()\n    }\n}\n\nimpl<'t> fmt::Debug for Captures<'t> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_tuple(\"Captures\").field(&CapturesDebug(self)).finish()\n    }\n}\n\nstruct CapturesDebug<'c, 't: 'c>(&'c Captures<'t>);\n\nimpl<'c, 't> fmt::Debug for CapturesDebug<'c, 't> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        // We'd like to show something nice here, even if it means an\n        // allocation to build a reverse index.\n        let slot_to_name: HashMap<&usize, &String> =\n            self.0.named_groups.iter().map(|(a, b)| (b, a)).collect();\n        let mut map = f.debug_map();\n        for (slot, m) in self.0.locs.iter().enumerate() {\n            let m = m.map(|(s, e)| &self.0.text[s..e]);\n            if let Some(name) = slot_to_name.get(&slot) {\n                map.entry(&name, &m);\n            } else {\n                map.entry(&slot, &m);\n            }\n        }\n        map.finish()\n    }\n}\n\n/// Get a group by index.\n///\n/// `'t` is the lifetime of the matched text.\n///\n/// The text can't outlive the `Captures` object if this method is\n/// used, because of how `Index` is defined (normally `a[i]` is part\n/// of `a` and can't outlive it); to do that, use `get()` instead.\n///\n/// # Panics\n///\n/// If there is no group at the given index.\nimpl<'t> Index<usize> for Captures<'t> {\n    type Output = str;\n\n    fn index(&self, i: usize) -> &str {\n        self.get(i)\n            .map(|m| m.as_str())\n            .unwrap_or_else(|| panic!(\"no group at index '{}'\", i))\n    }\n}\n\n/// Get a group by name.\n///\n/// `'t` is the lifetime of the matched text and `'i` is the lifetime\n/// of the group name (the index).\n///\n/// The text can't outlive the `Captures` object if this method is\n/// used, because of how `Index` is defined (normally `a[i]` is part\n/// of `a` and can't outlive it); to do that, use `name` instead.\n///\n/// # Panics\n///\n/// If there is no group named by the given value.\nimpl<'t, 'i> Index<&'i str> for Captures<'t> {\n    type Output = str;\n\n    fn index<'a>(&'a self, name: &'i str) -> &'a str {\n        self.name(name)\n            .map(|m| m.as_str())\n            .unwrap_or_else(|| panic!(\"no group named '{}'\", name))\n    }\n}\n\n/// An iterator that yields all capturing matches in the order in which they\n/// appear in the regex.\n///\n/// If a particular capture group didn't participate in the match, then `None`\n/// is yielded for that capture. The first match always corresponds to the\n/// overall match of the regex.\n///\n/// The lifetime `'c` corresponds to the lifetime of the `Captures` value, and\n/// the lifetime `'t` corresponds to the originally matched text.\npub struct SubCaptureMatches<'c, 't: 'c> {\n    caps: &'c Captures<'t>,\n    it: SubCapturesPosIter<'c>,\n}\n\nimpl<'c, 't> Iterator for SubCaptureMatches<'c, 't> {\n    type Item = Option<Match<'t>>;\n\n    fn next(&mut self) -> Option<Option<Match<'t>>> {\n        self.it\n            .next()\n            .map(|cap| cap.map(|(s, e)| Match::new(self.caps.text, s, e)))\n    }\n}\n\n/// An iterator that yields all non-overlapping capture groups matching a\n/// particular regular expression.\n///\n/// The iterator stops when no more matches can be found.\n///\n/// `'r` is the lifetime of the compiled regular expression and `'t` is the\n/// lifetime of the matched string.\npub struct CaptureMatches<'r, 't>(\n    re_trait::CaptureMatches<'t, ExecNoSyncStr<'r>>,\n);\n\nimpl<'r, 't> Iterator for CaptureMatches<'r, 't> {\n    type Item = Captures<'t>;\n\n    fn next(&mut self) -> Option<Captures<'t>> {\n        self.0.next().map(|locs| Captures {\n            text: self.0.text(),\n            locs: locs,\n            named_groups: self.0.regex().capture_name_idx().clone(),\n        })\n    }\n}\n\n/// An iterator over all non-overlapping matches for a particular string.\n///\n/// The iterator yields a `Match` value. The iterator stops when no more\n/// matches can be found.\n///\n/// `'r` is the lifetime of the compiled regular expression and `'t` is the\n/// lifetime of the matched string.\npub struct Matches<'r, 't>(re_trait::Matches<'t, ExecNoSyncStr<'r>>);\n\nimpl<'r, 't> Iterator for Matches<'r, 't> {\n    type Item = Match<'t>;\n\n    fn next(&mut self) -> Option<Match<'t>> {\n        let text = self.0.text();\n        self.0.next().map(|(s, e)| Match::new(text, s, e))\n    }\n}\n\n/// Replacer describes types that can be used to replace matches in a string.\n///\n/// In general, users of this crate shouldn't need to implement this trait,\n/// since implementations are already provided for `&str` and\n/// `FnMut(&Captures) -> String` (or any `FnMut(&Captures) -> T`\n/// where `T: AsRef<str>`), which covers most use cases.\npub trait Replacer {\n    /// Appends text to `dst` to replace the current match.\n    ///\n    /// The current match is represented by `caps`, which is guaranteed to\n    /// have a match at capture group `0`.\n    ///\n    /// For example, a no-op replacement would be\n    /// `dst.extend(caps.get(0).unwrap().as_str())`.\n    fn replace_append(&mut self, caps: &Captures, dst: &mut String);\n\n    /// Return a fixed unchanging replacement string.\n    ///\n    /// When doing replacements, if access to `Captures` is not needed (e.g.,\n    /// the replacement byte string does not need `$` expansion), then it can\n    /// be beneficial to avoid finding sub-captures.\n    ///\n    /// In general, this is called once for every call to `replacen`.\n    fn no_expansion<'r>(&'r mut self) -> Option<Cow<'r, str>> {\n        None\n    }\n\n    /// Return a `Replacer` that borrows and wraps this `Replacer`.\n    ///\n    /// This is useful when you want to take a generic `Replacer` (which might\n    /// not be cloneable) and use it without consuming it, so it can be used\n    /// more than once.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use regex::{Regex, Replacer};\n    ///\n    /// fn replace_all_twice<R: Replacer>(\n    ///     re: Regex,\n    ///     src: &str,\n    ///     mut rep: R,\n    /// ) -> String {\n    ///     let dst = re.replace_all(src, rep.by_ref());\n    ///     let dst = re.replace_all(&dst, rep.by_ref());\n    ///     dst.into_owned()\n    /// }\n    /// ```\n    fn by_ref<'r>(&'r mut self) -> ReplacerRef<'r, Self> {\n        ReplacerRef(self)\n    }\n}\n\n/// By-reference adaptor for a `Replacer`\n///\n/// Returned by [`Replacer::by_ref`](trait.Replacer.html#method.by_ref).\n#[derive(Debug)]\npub struct ReplacerRef<'a, R: ?Sized + 'a>(&'a mut R);\n\nimpl<'a, R: Replacer + ?Sized + 'a> Replacer for ReplacerRef<'a, R> {\n    fn replace_append(&mut self, caps: &Captures, dst: &mut String) {\n        self.0.replace_append(caps, dst)\n    }\n    fn no_expansion(&mut self) -> Option<Cow<str>> {\n        self.0.no_expansion()\n    }\n}\n\nimpl<'a> Replacer for &'a str {\n    fn replace_append(&mut self, caps: &Captures, dst: &mut String) {\n        caps.expand(*self, dst);\n    }\n\n    fn no_expansion(&mut self) -> Option<Cow<str>> {\n        match find_byte(b'$', self.as_bytes()) {\n            Some(_) => None,\n            None => Some(Cow::Borrowed(*self)),\n        }\n    }\n}\n\nimpl<F, T> Replacer for F\nwhere\n    F: FnMut(&Captures) -> T,\n    T: AsRef<str>,\n{\n    fn replace_append(&mut self, caps: &Captures, dst: &mut String) {\n        dst.push_str((*self)(caps).as_ref());\n    }\n}\n\n/// `NoExpand` indicates literal string replacement.\n///\n/// It can be used with `replace` and `replace_all` to do a literal string\n/// replacement without expanding `$name` to their corresponding capture\n/// groups. This can be both convenient (to avoid escaping `$`, for example)\n/// and performant (since capture groups don't need to be found).\n///\n/// `'t` is the lifetime of the literal text.\npub struct NoExpand<'t>(pub &'t str);\n\nimpl<'t> Replacer for NoExpand<'t> {\n    fn replace_append(&mut self, _: &Captures, dst: &mut String) {\n        dst.push_str(self.0);\n    }\n\n    fn no_expansion(&mut self) -> Option<Cow<str>> {\n        Some(Cow::Borrowed(self.0))\n    }\n}\n","traces":[{"line":21,"address":[4937936],"length":1,"stats":{"Line":0},"fn_name":"escape"},{"line":22,"address":[4937957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[4937984],"length":1,"stats":{"Line":11},"fn_name":"start"},{"line":39,"address":[4937989],"length":1,"stats":{"Line":11},"fn_name":null},{"line":44,"address":[4938000],"length":1,"stats":{"Line":11},"fn_name":"end"},{"line":45,"address":[4938005],"length":1,"stats":{"Line":11},"fn_name":null},{"line":51,"address":[4938016],"length":1,"stats":{"Line":14},"fn_name":"range"},{"line":52,"address":[4938025],"length":1,"stats":{"Line":14},"fn_name":null},{"line":57,"address":[4938064],"length":1,"stats":{"Line":14},"fn_name":"as_str"},{"line":58,"address":[4938073],"length":1,"stats":{"Line":14},"fn_name":null},{"line":63,"address":[4938160],"length":1,"stats":{"Line":15},"fn_name":"new"},{"line":69,"address":[4938208],"length":1,"stats":{"Line":5},"fn_name":"from"},{"line":70,"address":[4938212],"length":1,"stats":{"Line":5},"fn_name":null},{"line":75,"address":[5748928],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":76,"address":[5748932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[4938256],"length":1,"stats":{"Line":5},"fn_name":"fmt"},{"line":141,"address":[4938279],"length":1,"stats":{"Line":5},"fn_name":null},{"line":147,"address":[4938480],"length":1,"stats":{"Line":5},"fn_name":"fmt"},{"line":148,"address":[4938494],"length":1,"stats":{"Line":5},"fn_name":null},{"line":154,"address":[4938528],"length":1,"stats":{"Line":13},"fn_name":"from"},{"line":155,"address":[4938535],"length":1,"stats":{"Line":13},"fn_name":null},{"line":163,"address":[4938624],"length":1,"stats":{"Line":0},"fn_name":"from_str"},{"line":164,"address":[4938645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[4938672,4938713],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":175,"address":[4938735,4938689],"length":1,"stats":{"Line":4},"fn_name":null},{"line":196,"address":[4938800],"length":1,"stats":{"Line":5},"fn_name":"is_match"},{"line":197,"address":[4938823],"length":1,"stats":{"Line":5},"fn_name":null},{"line":221,"address":[4938848],"length":1,"stats":{"Line":0},"fn_name":"find"},{"line":222,"address":[4938878],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[4938896],"length":1,"stats":{"Line":6},"fn_name":"find_iter"},{"line":244,"address":[4939097],"length":1,"stats":{"Line":6},"fn_name":null},{"line":310,"address":[4939258,4939168],"length":1,"stats":{"Line":15},"fn_name":"captures"},{"line":311,"address":[4939202],"length":1,"stats":{"Line":13},"fn_name":null},{"line":312,"address":[4939303],"length":1,"stats":{"Line":37},"fn_name":null},{"line":313,"address":[5726967],"length":1,"stats":{"Line":14},"fn_name":null},{"line":314,"address":[5726974],"length":1,"stats":{"Line":12},"fn_name":null},{"line":315,"address":[5726992],"length":1,"stats":{"Line":14},"fn_name":null},{"line":344,"address":[4939472],"length":1,"stats":{"Line":5},"fn_name":"captures_iter"},{"line":348,"address":[4939673],"length":1,"stats":{"Line":5},"fn_name":null},{"line":369,"address":[4939744],"length":1,"stats":{"Line":6},"fn_name":"split"},{"line":370,"address":[4939766],"length":1,"stats":{"Line":6},"fn_name":null},{"line":393,"address":[4939840],"length":1,"stats":{"Line":5},"fn_name":"splitn"},{"line":398,"address":[4939867],"length":1,"stats":{"Line":5},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":557,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":559,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":564,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":576,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":582,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":585,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":613,"address":[4939952],"length":1,"stats":{"Line":6},"fn_name":"shortest_match"},{"line":614,"address":[4939975],"length":1,"stats":{"Line":6},"fn_name":null},{"line":623,"address":[4940016],"length":1,"stats":{"Line":5},"fn_name":"shortest_match_at"},{"line":628,"address":[4940229],"length":1,"stats":{"Line":5},"fn_name":null},{"line":637,"address":[4978432],"length":1,"stats":{"Line":5},"fn_name":"is_match_at"},{"line":638,"address":[4978456],"length":1,"stats":{"Line":5},"fn_name":null},{"line":647,"address":[4978512],"length":1,"stats":{"Line":0},"fn_name":"find_at"},{"line":652,"address":[5041610,4978728,5041592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":654,"address":[4978744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":655,"address":[5041594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":668,"address":[5041680],"length":1,"stats":{"Line":0},"fn_name":"captures_read"},{"line":673,"address":[5041714],"length":1,"stats":{"Line":0},"fn_name":null},{"line":682,"address":[5041728],"length":1,"stats":{"Line":15},"fn_name":"captures_read_at"},{"line":688,"address":[5041926,5042077],"length":1,"stats":{"Line":24},"fn_name":null},{"line":690,"address":[5041941],"length":1,"stats":{"Line":15},"fn_name":null},{"line":691,"address":[5042067],"length":1,"stats":{"Line":39},"fn_name":null},{"line":700,"address":[5042112],"length":1,"stats":{"Line":0},"fn_name":"read_captures_at"},{"line":706,"address":[5042149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":713,"address":[5042176],"length":1,"stats":{"Line":5},"fn_name":"as_str"},{"line":714,"address":[5042185,5042257,5042284],"length":1,"stats":{"Line":5},"fn_name":null},{"line":718,"address":[5042288],"length":1,"stats":{"Line":5},"fn_name":"capture_names"},{"line":719,"address":[5042297],"length":1,"stats":{"Line":5},"fn_name":null},{"line":723,"address":[5042384],"length":1,"stats":{"Line":5},"fn_name":"captures_len"},{"line":724,"address":[5042393],"length":1,"stats":{"Line":5},"fn_name":null},{"line":729,"address":[5042448],"length":1,"stats":{"Line":15},"fn_name":"capture_locations"},{"line":730,"address":[5042574],"length":1,"stats":{"Line":15},"fn_name":null},{"line":738,"address":[5042656],"length":1,"stats":{"Line":0},"fn_name":"locations"},{"line":739,"address":[5042782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":754,"address":[5042864],"length":1,"stats":{"Line":5},"fn_name":"next"},{"line":755,"address":[5042881],"length":1,"stats":{"Line":5},"fn_name":null},{"line":758,"address":[5727392,5727353,5727401,5727344],"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":761,"address":[5042944],"length":1,"stats":{"Line":5},"fn_name":"size_hint"},{"line":762,"address":[5042961],"length":1,"stats":{"Line":5},"fn_name":null},{"line":778,"address":[5042976],"length":1,"stats":{"Line":6},"fn_name":"next"},{"line":779,"address":[5042991],"length":1,"stats":{"Line":6},"fn_name":null},{"line":780,"address":[5043038,5043178,5043404],"length":1,"stats":{"Line":12},"fn_name":null},{"line":781,"address":[5043054],"length":1,"stats":{"Line":6},"fn_name":null},{"line":782,"address":[5043185,5043291],"length":1,"stats":{"Line":12},"fn_name":null},{"line":783,"address":[5043282],"length":1,"stats":{"Line":6},"fn_name":null},{"line":785,"address":[5043298,5043234],"length":1,"stats":{"Line":12},"fn_name":null},{"line":786,"address":[5043609,5043329,5043579],"length":1,"stats":{"Line":6},"fn_name":null},{"line":787,"address":[5043386],"length":1,"stats":{"Line":6},"fn_name":null},{"line":790,"address":[5043077],"length":1,"stats":{"Line":6},"fn_name":null},{"line":791,"address":[5043414,5043146],"length":1,"stats":{"Line":12},"fn_name":null},{"line":792,"address":[5043503],"length":1,"stats":{"Line":6},"fn_name":null},{"line":793,"address":[5043540],"length":1,"stats":{"Line":6},"fn_name":null},{"line":813,"address":[5043616],"length":1,"stats":{"Line":5},"fn_name":"next"},{"line":814,"address":[5043625],"length":1,"stats":{"Line":5},"fn_name":null},{"line":815,"address":[5043672],"length":1,"stats":{"Line":6},"fn_name":null},{"line":818,"address":[5043906,5043936,5043642,5043706],"length":1,"stats":{"Line":11},"fn_name":"get"},{"line":819,"address":[5043710],"length":1,"stats":{"Line":6},"fn_name":null},{"line":820,"address":[5043757],"length":1,"stats":{"Line":6},"fn_name":null},{"line":823,"address":[5043722],"length":1,"stats":{"Line":6},"fn_name":null},{"line":824,"address":[5043779,5043879],"length":1,"stats":{"Line":11},"fn_name":null},{"line":826,"address":[5043870],"length":1,"stats":{"Line":5},"fn_name":null},{"line":829,"address":[5043886,5043828],"length":1,"stats":{"Line":12},"fn_name":null},{"line":866,"address":[5043936],"length":1,"stats":{"Line":0},"fn_name":"get"},{"line":867,"address":[5043957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":875,"address":[5043984],"length":1,"stats":{"Line":0},"fn_name":"len"},{"line":876,"address":[5043993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":886,"address":[5044016],"length":1,"stats":{"Line":0},"fn_name":"pos"},{"line":887,"address":[5044037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":928,"address":[5044064],"length":1,"stats":{"Line":9},"fn_name":"get"},{"line":929,"address":[5044081],"length":1,"stats":{"Line":27},"fn_name":null},{"line":934,"address":[5044160],"length":1,"stats":{"Line":7},"fn_name":"name"},{"line":935,"address":[5044182],"length":1,"stats":{"Line":17},"fn_name":null},{"line":943,"address":[5044304],"length":1,"stats":{"Line":5},"fn_name":"iter"},{"line":944,"address":[5044316],"length":1,"stats":{"Line":5},"fn_name":null},{"line":963,"address":[5044400],"length":1,"stats":{"Line":8},"fn_name":"expand"},{"line":964,"address":[5044424],"length":1,"stats":{"Line":7},"fn_name":null},{"line":972,"address":[5044448],"length":1,"stats":{"Line":5},"fn_name":"len"},{"line":973,"address":[5044457],"length":1,"stats":{"Line":5},"fn_name":null},{"line":978,"address":[5044496],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":979,"address":[5044517],"length":1,"stats":{"Line":0},"fn_name":null},{"line":986,"address":[5044678,5044624],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":989,"address":[5044644,5044693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":990,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":991,"address":[5044750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":992,"address":[5044774,5044992,5045426,5044839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":993,"address":[5045138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":994,"address":[5045422,5045255,5045357],"length":1,"stats":{"Line":0},"fn_name":null},{"line":995,"address":[5045373],"length":1,"stats":{"Line":0},"fn_name":null},{"line":997,"address":[5045308],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1000,"address":[5044966],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1018,"address":[5045488],"length":1,"stats":{"Line":9},"fn_name":"index"},{"line":1019,"address":[5045502,5045560],"length":1,"stats":{"Line":14},"fn_name":null},{"line":1020,"address":[5727792,5727796],"length":1,"stats":{"Line":10},"fn_name":"{{closure}}"},{"line":1021,"address":[5045550],"length":1,"stats":{"Line":15},"fn_name":null},{"line":1040,"address":[5045616],"length":1,"stats":{"Line":7},"fn_name":"index"},{"line":1041,"address":[5045635,5045698],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1042,"address":[5727984,5727988],"length":1,"stats":{"Line":10},"fn_name":"{{closure}}"},{"line":1043,"address":[5045688],"length":1,"stats":{"Line":15},"fn_name":null},{"line":1064,"address":[5045744],"length":1,"stats":{"Line":5},"fn_name":"next"},{"line":1065,"address":[5045756,5045803],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1067,"address":[5045793],"length":1,"stats":{"Line":25},"fn_name":null},{"line":1085,"address":[5045840],"length":1,"stats":{"Line":5},"fn_name":"next"},{"line":1086,"address":[5045852],"length":1,"stats":{"Line":15},"fn_name":null},{"line":1087,"address":[5728386],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1088,"address":[5728464],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1089,"address":[5728496,5728555],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1106,"address":[5045936],"length":1,"stats":{"Line":6},"fn_name":"next"},{"line":1107,"address":[5045953],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1108,"address":[5045986],"length":1,"stats":{"Line":26},"fn_name":null},{"line":1135,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1136,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1160,"address":[5728848,5728816],"length":1,"stats":{"Line":0},"fn_name":"by_ref<&str>"},{"line":1161,"address":[5728825,5728857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1181,"address":[5046048],"length":1,"stats":{"Line":5},"fn_name":"replace_append"},{"line":1182,"address":[5046067],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1185,"address":[5046112],"length":1,"stats":{"Line":6},"fn_name":"no_expansion"},{"line":1186,"address":[5046207,5046127,5046307],"length":1,"stats":{"Line":17},"fn_name":null},{"line":1187,"address":[5046222,5046316],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1188,"address":[5046241],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1198,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1199,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":1214,"address":[5046336],"length":1,"stats":{"Line":0},"fn_name":"replace_append"},{"line":1215,"address":[5046354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1218,"address":[5046384],"length":1,"stats":{"Line":5},"fn_name":"no_expansion"},{"line":1219,"address":[5046396],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":152,"coverable":199},{"path":["/","usr","src","regex","src","sparse.rs"],"content":"use std::fmt;\nuse std::ops::Deref;\nuse std::slice;\n\n/// A sparse set used for representing ordered NFA states.\n///\n/// This supports constant time addition and membership testing. Clearing an\n/// entire set can also be done in constant time. Iteration yields elements\n/// in the order in which they were inserted.\n///\n/// The data structure is based on: http://research.swtch.com/sparse\n/// Note though that we don't actually use uninitialized memory. We generally\n/// reuse allocations, so the initial allocation cost is bareable. However,\n/// its other properties listed above are extremely useful.\n#[derive(Clone)]\npub struct SparseSet {\n    /// Dense contains the instruction pointers in the order in which they\n    /// were inserted.\n    dense: Vec<usize>,\n    /// Sparse maps instruction pointers to their location in dense.\n    ///\n    /// An instruction pointer is in the set if and only if\n    /// sparse[ip] < dense.len() && ip == dense[sparse[ip]].\n    sparse: Box<[usize]>,\n}\n\nimpl SparseSet {\n    pub fn new(size: usize) -> SparseSet {\n        SparseSet {\n            dense: Vec::with_capacity(size),\n            sparse: vec![0; size].into_boxed_slice(),\n        }\n    }\n\n    pub fn len(&self) -> usize {\n        self.dense.len()\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.dense.is_empty()\n    }\n\n    pub fn capacity(&self) -> usize {\n        self.dense.capacity()\n    }\n\n    pub fn insert(&mut self, value: usize) {\n        let i = self.len();\n        assert!(i < self.capacity());\n        self.dense.push(value);\n        self.sparse[value] = i;\n    }\n\n    pub fn contains(&self, value: usize) -> bool {\n        let i = self.sparse[value];\n        self.dense.get(i) == Some(&value)\n    }\n\n    pub fn clear(&mut self) {\n        self.dense.clear();\n    }\n}\n\nimpl fmt::Debug for SparseSet {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"SparseSet({:?})\", self.dense)\n    }\n}\n\nimpl Deref for SparseSet {\n    type Target = [usize];\n\n    fn deref(&self) -> &Self::Target {\n        &self.dense\n    }\n}\n\nimpl<'a> IntoIterator for &'a SparseSet {\n    type Item = &'a usize;\n    type IntoIter = slice::Iter<'a, usize>;\n    fn into_iter(self) -> Self::IntoIter {\n        self.iter()\n    }\n}\n","traces":[{"line":28,"address":[4936704,4936747],"length":1,"stats":{"Line":25},"fn_name":"new"},{"line":30,"address":[5616172],"length":1,"stats":{"Line":23},"fn_name":null},{"line":31,"address":[5616215],"length":1,"stats":{"Line":25},"fn_name":null},{"line":35,"address":[5616352],"length":1,"stats":{"Line":11},"fn_name":"len"},{"line":36,"address":[5616361],"length":1,"stats":{"Line":13},"fn_name":null},{"line":39,"address":[5616384],"length":1,"stats":{"Line":13},"fn_name":"is_empty"},{"line":40,"address":[5616393],"length":1,"stats":{"Line":13},"fn_name":null},{"line":43,"address":[5616432],"length":1,"stats":{"Line":13},"fn_name":"capacity"},{"line":44,"address":[4936969],"length":1,"stats":{"Line":13},"fn_name":null},{"line":47,"address":[4936992],"length":1,"stats":{"Line":11},"fn_name":"insert"},{"line":48,"address":[4937016],"length":1,"stats":{"Line":13},"fn_name":null},{"line":49,"address":[4937036,4937091],"length":1,"stats":{"Line":11},"fn_name":null},{"line":50,"address":[4937075],"length":1,"stats":{"Line":13},"fn_name":null},{"line":51,"address":[4937183,4937211,4937126],"length":1,"stats":{"Line":11},"fn_name":null},{"line":54,"address":[4937216],"length":1,"stats":{"Line":11},"fn_name":"contains"},{"line":55,"address":[4937410,4937230,4937382],"length":1,"stats":{"Line":13},"fn_name":null},{"line":56,"address":[5616762],"length":1,"stats":{"Line":11},"fn_name":null},{"line":59,"address":[4937424],"length":1,"stats":{"Line":13},"fn_name":"clear"},{"line":60,"address":[5616901],"length":1,"stats":{"Line":13},"fn_name":null},{"line":65,"address":[4937440],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":66,"address":[4937470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[4937632],"length":1,"stats":{"Line":14},"fn_name":"deref"},{"line":74,"address":[4937641],"length":1,"stats":{"Line":14},"fn_name":null},{"line":81,"address":[4937680],"length":1,"stats":{"Line":8},"fn_name":"into_iter"},{"line":82,"address":[4937689],"length":1,"stats":{"Line":8},"fn_name":null}],"covered":23,"coverable":25},{"path":["/","usr","src","regex","src","utf8.rs"],"content":"/// A few elementary UTF-8 encoding and decoding functions used by the matching\n/// engines.\n///\n/// In an ideal world, the matching engines operate on `&str` and we can just\n/// lean on the standard library for all our UTF-8 needs. However, to support\n/// byte based regexes (that can match on arbitrary bytes which may contain\n/// UTF-8), we need to be capable of searching and decoding UTF-8 on a `&[u8]`.\n/// The standard library doesn't really recognize this use case, so we have\n/// to build it out ourselves.\n///\n/// Should this be factored out into a separate crate? It seems independently\n/// useful. There are other crates that already exist (e.g., `utf-8`) that have\n/// overlapping use cases. Not sure what to do.\nuse std::char;\n\nconst TAG_CONT: u8 = 0b1000_0000;\nconst TAG_TWO: u8 = 0b1100_0000;\nconst TAG_THREE: u8 = 0b1110_0000;\nconst TAG_FOUR: u8 = 0b1111_0000;\n\n/// Returns the smallest possible index of the next valid UTF-8 sequence\n/// starting after `i`.\npub fn next_utf8(text: &[u8], i: usize) -> usize {\n    let b = match text.get(i) {\n        None => return i + 1,\n        Some(&b) => b,\n    };\n    let inc = if b <= 0x7F {\n        1\n    } else if b <= 0b110_11111 {\n        2\n    } else if b <= 0b1110_1111 {\n        3\n    } else {\n        4\n    };\n    i + inc\n}\n\n/// Decode a single UTF-8 sequence into a single Unicode codepoint from `src`.\n///\n/// If no valid UTF-8 sequence could be found, then `None` is returned.\n/// Otherwise, the decoded codepoint and the number of bytes read is returned.\n/// The number of bytes read (for a valid UTF-8 sequence) is guaranteed to be\n/// 1, 2, 3 or 4.\n///\n/// Note that a UTF-8 sequence is invalid if it is incorrect UTF-8, encodes a\n/// codepoint that is out of range (surrogate codepoints are out of range) or\n/// is not the shortest possible UTF-8 sequence for that codepoint.\n#[inline]\npub fn decode_utf8(src: &[u8]) -> Option<(char, usize)> {\n    let b0 = match src.get(0) {\n        None => return None,\n        Some(&b) if b <= 0x7F => return Some((b as char, 1)),\n        Some(&b) => b,\n    };\n    match b0 {\n        0b110_00000..=0b110_11111 => {\n            if src.len() < 2 {\n                return None;\n            }\n            let b1 = src[1];\n            if 0b11_000000 & b1 != TAG_CONT {\n                return None;\n            }\n            let cp = ((b0 & !TAG_TWO) as u32) << 6 | ((b1 & !TAG_CONT) as u32);\n            match cp {\n                0x80..=0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n                _ => None,\n            }\n        }\n        0b1110_0000..=0b1110_1111 => {\n            if src.len() < 3 {\n                return None;\n            }\n            let (b1, b2) = (src[1], src[2]);\n            if 0b11_000000 & b1 != TAG_CONT {\n                return None;\n            }\n            if 0b11_000000 & b2 != TAG_CONT {\n                return None;\n            }\n            let cp = ((b0 & !TAG_THREE) as u32) << 12\n                | ((b1 & !TAG_CONT) as u32) << 6\n                | ((b2 & !TAG_CONT) as u32);\n            match cp {\n                // char::from_u32 will disallow surrogate codepoints.\n                0x800..=0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n                _ => None,\n            }\n        }\n        0b11110_000..=0b11110_111 => {\n            if src.len() < 4 {\n                return None;\n            }\n            let (b1, b2, b3) = (src[1], src[2], src[3]);\n            if 0b11_000000 & b1 != TAG_CONT {\n                return None;\n            }\n            if 0b11_000000 & b2 != TAG_CONT {\n                return None;\n            }\n            if 0b11_000000 & b3 != TAG_CONT {\n                return None;\n            }\n            let cp = ((b0 & !TAG_FOUR) as u32) << 18\n                | ((b1 & !TAG_CONT) as u32) << 12\n                | ((b2 & !TAG_CONT) as u32) << 6\n                | ((b3 & !TAG_CONT) as u32);\n            match cp {\n                0x10000..=0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n                _ => None,\n            }\n        }\n        _ => None,\n    }\n}\n\n/// Like `decode_utf8`, but decodes the last UTF-8 sequence in `src` instead\n/// of the first.\npub fn decode_last_utf8(src: &[u8]) -> Option<(char, usize)> {\n    if src.is_empty() {\n        return None;\n    }\n    let mut start = src.len() - 1;\n    if src[start] <= 0x7F {\n        return Some((src[start] as char, 1));\n    }\n    while start > src.len().saturating_sub(4) {\n        start -= 1;\n        if is_start_byte(src[start]) {\n            break;\n        }\n    }\n    match decode_utf8(&src[start..]) {\n        None => None,\n        Some((_, n)) if n < src.len() - start => None,\n        Some((cp, n)) => Some((cp, n)),\n    }\n}\n\nfn is_start_byte(b: u8) -> bool {\n    b & 0b11_000000 != 0b1_0000000\n}\n\n#[cfg(test)]\nmod tests {\n    use std::str;\n\n    use quickcheck::quickcheck;\n\n    use super::{\n        decode_last_utf8, decode_utf8, TAG_CONT, TAG_FOUR, TAG_THREE, TAG_TWO,\n    };\n\n    #[test]\n    fn prop_roundtrip() {\n        fn p(given_cp: char) -> bool {\n            let mut tmp = [0; 4];\n            let encoded_len = given_cp.encode_utf8(&mut tmp).len();\n            let (got_cp, got_len) = decode_utf8(&tmp[..encoded_len]).unwrap();\n            encoded_len == got_len && given_cp == got_cp\n        }\n        quickcheck(p as fn(char) -> bool)\n    }\n\n    #[test]\n    fn prop_roundtrip_last() {\n        fn p(given_cp: char) -> bool {\n            let mut tmp = [0; 4];\n            let encoded_len = given_cp.encode_utf8(&mut tmp).len();\n            let (got_cp, got_len) =\n                decode_last_utf8(&tmp[..encoded_len]).unwrap();\n            encoded_len == got_len && given_cp == got_cp\n        }\n        quickcheck(p as fn(char) -> bool)\n    }\n\n    #[test]\n    fn prop_encode_matches_std() {\n        fn p(cp: char) -> bool {\n            let mut got = [0; 4];\n            let n = cp.encode_utf8(&mut got).len();\n            let expected = cp.to_string();\n            &got[..n] == expected.as_bytes()\n        }\n        quickcheck(p as fn(char) -> bool)\n    }\n\n    #[test]\n    fn prop_decode_matches_std() {\n        fn p(given_cp: char) -> bool {\n            let mut tmp = [0; 4];\n            let n = given_cp.encode_utf8(&mut tmp).len();\n            let (got_cp, _) = decode_utf8(&tmp[..n]).unwrap();\n            let expected_cp =\n                str::from_utf8(&tmp[..n]).unwrap().chars().next().unwrap();\n            got_cp == expected_cp\n        }\n        quickcheck(p as fn(char) -> bool)\n    }\n\n    #[test]\n    fn prop_decode_last_matches_std() {\n        fn p(given_cp: char) -> bool {\n            let mut tmp = [0; 4];\n            let n = given_cp.encode_utf8(&mut tmp).len();\n            let (got_cp, _) = decode_last_utf8(&tmp[..n]).unwrap();\n            let expected_cp = str::from_utf8(&tmp[..n])\n                .unwrap()\n                .chars()\n                .rev()\n                .next()\n                .unwrap();\n            got_cp == expected_cp\n        }\n        quickcheck(p as fn(char) -> bool)\n    }\n\n    #[test]\n    fn reject_invalid() {\n        // Invalid start byte\n        assert_eq!(decode_utf8(&[0xFF]), None);\n        // Surrogate pair\n        assert_eq!(decode_utf8(&[0xED, 0xA0, 0x81]), None);\n        // Invalid continuation byte.\n        assert_eq!(decode_utf8(&[0xD4, 0xC2]), None);\n        // Bad lengths\n        assert_eq!(decode_utf8(&[0xC3]), None); // 2 bytes\n        assert_eq!(decode_utf8(&[0xEF, 0xBF]), None); // 3 bytes\n        assert_eq!(decode_utf8(&[0xF4, 0x8F, 0xBF]), None); // 4 bytes\n                                                            // Not a minimal UTF-8 sequence\n        assert_eq!(decode_utf8(&[TAG_TWO, TAG_CONT | b'a']), None);\n        assert_eq!(decode_utf8(&[TAG_THREE, TAG_CONT, TAG_CONT | b'a']), None);\n        assert_eq!(\n            decode_utf8(&[TAG_FOUR, TAG_CONT, TAG_CONT, TAG_CONT | b'a',]),\n            None\n        );\n    }\n\n    #[test]\n    fn reject_invalid_last() {\n        // Invalid start byte\n        assert_eq!(decode_last_utf8(&[0xFF]), None);\n        // Surrogate pair\n        assert_eq!(decode_last_utf8(&[0xED, 0xA0, 0x81]), None);\n        // Bad lengths\n        assert_eq!(decode_last_utf8(&[0xC3]), None); // 2 bytes\n        assert_eq!(decode_last_utf8(&[0xEF, 0xBF]), None); // 3 bytes\n        assert_eq!(decode_last_utf8(&[0xF4, 0x8F, 0xBF]), None); // 4 bytes\n                                                                 // Not a minimal UTF-8 sequence\n        assert_eq!(decode_last_utf8(&[TAG_TWO, TAG_CONT | b'a']), None);\n        assert_eq!(\n            decode_last_utf8(&[TAG_THREE, TAG_CONT, TAG_CONT | b'a',]),\n            None\n        );\n        assert_eq!(\n            decode_last_utf8(\n                &[TAG_FOUR, TAG_CONT, TAG_CONT, TAG_CONT | b'a',]\n            ),\n            None\n        );\n    }\n}\n","traces":[{"line":23,"address":[5669216],"length":1,"stats":{"Line":8},"fn_name":"next_utf8"},{"line":24,"address":[5669240,5669297],"length":1,"stats":{"Line":10},"fn_name":null},{"line":25,"address":[5669480,5669304,5669510,5669344,5669251],"length":1,"stats":{"Line":17},"fn_name":null},{"line":26,"address":[5669271],"length":1,"stats":{"Line":6},"fn_name":null},{"line":28,"address":[5669286,5669370,5669415],"length":1,"stats":{"Line":17},"fn_name":null},{"line":29,"address":[5669361],"length":1,"stats":{"Line":6},"fn_name":null},{"line":30,"address":[5669355,5669413,5669391],"length":1,"stats":{"Line":12},"fn_name":null},{"line":31,"address":[5669382],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[5669376,5669402],"length":1,"stats":{"Line":6},"fn_name":null},{"line":33,"address":[5669404],"length":1,"stats":{"Line":6},"fn_name":null},{"line":35,"address":[5669393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[5669422,5669450],"length":1,"stats":{"Line":7},"fn_name":null},{"line":51,"address":[5669520],"length":1,"stats":{"Line":16},"fn_name":"decode_utf8"},{"line":52,"address":[5669557,5669596],"length":1,"stats":{"Line":18},"fn_name":null},{"line":53,"address":[5669598,5669634,5669571],"length":1,"stats":{"Line":36},"fn_name":null},{"line":54,"address":[5669638],"length":1,"stats":{"Line":18},"fn_name":null},{"line":55,"address":[5669730],"length":1,"stats":{"Line":11},"fn_name":null},{"line":57,"address":[5670444,5670951,5669827,5670067],"length":1,"stats":{"Line":35},"fn_name":null},{"line":58,"address":[5669754],"length":1,"stats":{"Line":12},"fn_name":null},{"line":59,"address":[5669842],"length":1,"stats":{"Line":9},"fn_name":null},{"line":60,"address":[5669890],"length":1,"stats":{"Line":5},"fn_name":null},{"line":62,"address":[5669864,5669911,5670958],"length":1,"stats":{"Line":18},"fn_name":null},{"line":63,"address":[5669921],"length":1,"stats":{"Line":9},"fn_name":null},{"line":64,"address":[5669953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[5669973,5669939],"length":1,"stats":{"Line":18},"fn_name":null},{"line":67,"address":[5670026,5670065],"length":1,"stats":{"Line":9},"fn_name":null},{"line":68,"address":[4487944,4487936],"length":1,"stats":{"Line":36},"fn_name":"{{closure}}"},{"line":69,"address":[5670015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[5669772],"length":1,"stats":{"Line":12},"fn_name":null},{"line":73,"address":[5670082],"length":1,"stats":{"Line":10},"fn_name":null},{"line":74,"address":[5670130],"length":1,"stats":{"Line":9},"fn_name":null},{"line":76,"address":[5670986,5670104,5670151],"length":1,"stats":{"Line":20},"fn_name":null},{"line":77,"address":[5670242],"length":1,"stats":{"Line":10},"fn_name":null},{"line":78,"address":[5670276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[5670268],"length":1,"stats":{"Line":10},"fn_name":null},{"line":81,"address":[5670310],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[5670359,5670296,5670347],"length":1,"stats":{"Line":30},"fn_name":null},{"line":84,"address":[5670327],"length":1,"stats":{"Line":10},"fn_name":null},{"line":85,"address":[5670353],"length":1,"stats":{"Line":10},"fn_name":null},{"line":86,"address":[5670403,5670442],"length":1,"stats":{"Line":10},"fn_name":null},{"line":88,"address":[4487992,4487984],"length":1,"stats":{"Line":40},"fn_name":"{{closure}}"},{"line":89,"address":[5670392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[5669794],"length":1,"stats":{"Line":10},"fn_name":null},{"line":93,"address":[5670459],"length":1,"stats":{"Line":10},"fn_name":null},{"line":94,"address":[5670507],"length":1,"stats":{"Line":5},"fn_name":null},{"line":96,"address":[5670481,5671042,5670528],"length":1,"stats":{"Line":20},"fn_name":null},{"line":97,"address":[5670688],"length":1,"stats":{"Line":10},"fn_name":null},{"line":98,"address":[5670727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[5670719],"length":1,"stats":{"Line":10},"fn_name":null},{"line":101,"address":[5670755],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[5670747],"length":1,"stats":{"Line":10},"fn_name":null},{"line":104,"address":[5670786],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[5670854,5670823,5670772,5670866],"length":1,"stats":{"Line":40},"fn_name":null},{"line":107,"address":[5670803],"length":1,"stats":{"Line":10},"fn_name":null},{"line":108,"address":[5670829],"length":1,"stats":{"Line":10},"fn_name":null},{"line":109,"address":[5670860],"length":1,"stats":{"Line":10},"fn_name":null},{"line":110,"address":[5670910,5670949],"length":1,"stats":{"Line":10},"fn_name":null},{"line":111,"address":[4488040,4488032],"length":1,"stats":{"Line":40},"fn_name":"{{closure}}"},{"line":112,"address":[5670899],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[5669816],"length":1,"stats":{"Line":6},"fn_name":null},{"line":121,"address":[5671136],"length":1,"stats":{"Line":9},"fn_name":"decode_last_utf8"},{"line":122,"address":[5671175],"length":1,"stats":{"Line":9},"fn_name":null},{"line":123,"address":[5671230],"length":1,"stats":{"Line":8},"fn_name":null},{"line":125,"address":[5672020,5671269,5671217],"length":1,"stats":{"Line":18},"fn_name":null},{"line":126,"address":[5672050,5671305],"length":1,"stats":{"Line":9},"fn_name":null},{"line":127,"address":[5671365,5672081],"length":1,"stats":{"Line":9},"fn_name":null},{"line":129,"address":[5671473,5671667,5671363],"length":1,"stats":{"Line":25},"fn_name":null},{"line":130,"address":[5671548,5672112],"length":1,"stats":{"Line":9},"fn_name":null},{"line":131,"address":[5671592,5672142],"length":1,"stats":{"Line":9},"fn_name":null},{"line":132,"address":[5671672],"length":1,"stats":{"Line":9},"fn_name":null},{"line":135,"address":[5671938,5671786,5671799,5671674],"length":1,"stats":{"Line":22},"fn_name":null},{"line":136,"address":[5671788,5671760],"length":1,"stats":{"Line":14},"fn_name":null},{"line":137,"address":[5672203,5672173,5671804],"length":1,"stats":{"Line":9},"fn_name":null},{"line":138,"address":[5671940],"length":1,"stats":{"Line":9},"fn_name":null},{"line":142,"address":[5672208],"length":1,"stats":{"Line":9},"fn_name":"is_start_byte"},{"line":143,"address":[5672216],"length":1,"stats":{"Line":9},"fn_name":null},{"line":157,"address":[4281616],"length":1,"stats":{"Line":3},"fn_name":"prop_roundtrip"},{"line":158,"address":[4281632],"length":1,"stats":{"Line":1},"fn_name":"p"},{"line":159,"address":[4281654],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[4281689],"length":1,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[4281740],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[4281870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[4281617],"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[4281936],"length":1,"stats":{"Line":3},"fn_name":"prop_roundtrip_last"},{"line":169,"address":[4281952],"length":1,"stats":{"Line":1},"fn_name":"p"},{"line":170,"address":[4281974],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[4282009],"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[4282165],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[4282190],"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[4281937],"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[4282256],"length":1,"stats":{"Line":3},"fn_name":"prop_encode_matches_std"},{"line":181,"address":[4282350,4282272],"length":1,"stats":{"Line":1},"fn_name":"p"},{"line":182,"address":[4282290],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[4282375,4282316],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[4282393],"length":1,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[4282527,4282414],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[4282257],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[4282624],"length":1,"stats":{"Line":3},"fn_name":"prop_decode_matches_std"},{"line":192,"address":[4282640],"length":1,"stats":{"Line":1},"fn_name":"p"},{"line":193,"address":[4282671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[4282709],"length":1,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[4282760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[4282876],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[4283073],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[4282625],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[4283104],"length":1,"stats":{"Line":3},"fn_name":"prop_decode_last_matches_std"},{"line":205,"address":[4283120],"length":1,"stats":{"Line":1},"fn_name":"p"},{"line":206,"address":[4283151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[4283198],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[4283252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[4283368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[4283590],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[4283105],"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[4283616],"length":1,"stats":{"Line":3},"fn_name":"reject_invalid"},{"line":223,"address":[4283802,4283623],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[4284284,4283765,4284137],"length":1,"stats":{"Line":2},"fn_name":null},{"line":227,"address":[4284619,4284766,4284247],"length":1,"stats":{"Line":2},"fn_name":null},{"line":229,"address":[4285101,4285248,4284729],"length":1,"stats":{"Line":2},"fn_name":null},{"line":230,"address":[4285583,4285211,4285730],"length":1,"stats":{"Line":2},"fn_name":null},{"line":231,"address":[4285693,4286212,4286065],"length":1,"stats":{"Line":2},"fn_name":null},{"line":233,"address":[4286175,4286547,4286694],"length":1,"stats":{"Line":2},"fn_name":null},{"line":234,"address":[4287029,4287176,4286657],"length":1,"stats":{"Line":2},"fn_name":null},{"line":235,"address":[4287587,4287481],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[4287139],"length":1,"stats":{"Line":1},"fn_name":null},{"line":242,"address":[4287888],"length":1,"stats":{"Line":3},"fn_name":"reject_invalid_last"},{"line":244,"address":[4287895,4288074],"length":1,"stats":{"Line":1},"fn_name":null},{"line":246,"address":[4288409,4288037,4288556],"length":1,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[4288519,4288891,4289038],"length":1,"stats":{"Line":2},"fn_name":null},{"line":249,"address":[4289373,4289001,4289520],"length":1,"stats":{"Line":2},"fn_name":null},{"line":250,"address":[4289855,4289483,4290002],"length":1,"stats":{"Line":2},"fn_name":null},{"line":252,"address":[4289965,4290484,4290337],"length":1,"stats":{"Line":2},"fn_name":null},{"line":253,"address":[4290819,4290966],"length":1,"stats":{"Line":1},"fn_name":null},{"line":254,"address":[4290447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[4291377,4291271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[4290941],"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[4290929],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":128,"coverable":136},{"path":["/","usr","src","regex","tests","api.rs"],"content":"#[test]\nfn empty_regex_empty_match() {\n    let re = regex!(\"\");\n    assert_eq!(vec![(0, 0)], findall!(re, \"\"));\n}\n\n#[test]\nfn empty_regex_nonempty_match() {\n    let re = regex!(\"\");\n    assert_eq!(vec![(0, 0), (1, 1), (2, 2), (3, 3)], findall!(re, \"abc\"));\n}\n\n#[test]\nfn one_zero_length_match() {\n    let re = regex!(r\"[0-9]*\");\n    assert_eq!(vec![(0, 0), (1, 2), (3, 4)], findall!(re, \"a1b2\"));\n}\n\n#[test]\nfn many_zero_length_match() {\n    let re = regex!(r\"[0-9]*\");\n    assert_eq!(\n        vec![(0, 0), (1, 2), (3, 3), (4, 4), (5, 6)],\n        findall!(re, \"a1bbb2\")\n    );\n}\n\n#[test]\nfn many_sequential_zero_length_match() {\n    let re = regex!(r\"[0-9]?\");\n    assert_eq!(\n        vec![(0, 0), (1, 2), (2, 3), (4, 5), (6, 6)],\n        findall!(re, \"a12b3c\")\n    );\n}\n\n#[test]\nfn quoted_bracket_set() {\n    let re = regex!(r\"([\\x{5b}\\x{5d}])\");\n    assert_eq!(vec![(0, 1), (1, 2)], findall!(re, \"[]\"));\n    let re = regex!(r\"([\\[\\]])\");\n    assert_eq!(vec![(0, 1), (1, 2)], findall!(re, \"[]\"));\n}\n\n#[test]\nfn first_range_starts_with_left_bracket() {\n    let re = regex!(r\"([\\[-z])\");\n    assert_eq!(vec![(0, 1), (1, 2)], findall!(re, \"[]\"));\n}\n\n#[test]\nfn range_ends_with_escape() {\n    let re = regex!(r\"([\\[-\\x{5d}])\");\n    assert_eq!(vec![(0, 1), (1, 2)], findall!(re, \"[]\"));\n}\n\n#[test]\nfn empty_match_find_iter() {\n    let re = regex!(r\".*?\");\n    assert_eq!(vec![(0, 0), (1, 1), (2, 2), (3, 3)], findall!(re, \"abc\"));\n}\n\n#[test]\nfn empty_match_captures_iter() {\n    let re = regex!(r\".*?\");\n    let ms: Vec<_> = re\n        .captures_iter(text!(\"abc\"))\n        .map(|c| c.get(0).unwrap())\n        .map(|m| (m.start(), m.end()))\n        .collect();\n    assert_eq!(ms, vec![(0, 0), (1, 1), (2, 2), (3, 3)]);\n}\n\n#[test]\nfn capture_names() {\n    let re = regex!(r\"(.)(?P<a>.)\");\n    assert_eq!(3, re.captures_len());\n    assert_eq!((3, Some(3)), re.capture_names().size_hint());\n    assert_eq!(\n        vec![None, None, Some(\"a\")],\n        re.capture_names().collect::<Vec<_>>()\n    );\n}\n\n#[test]\nfn regex_string() {\n    assert_eq!(r\"[a-zA-Z0-9]+\", regex!(r\"[a-zA-Z0-9]+\").as_str());\n    assert_eq!(r\"[a-zA-Z0-9]+\", &format!(\"{}\", regex!(r\"[a-zA-Z0-9]+\")));\n    assert_eq!(r\"[a-zA-Z0-9]+\", &format!(\"{:?}\", regex!(r\"[a-zA-Z0-9]+\")));\n}\n\n#[test]\nfn capture_index() {\n    let re = regex!(r\"^(?P<name>.+)$\");\n    let cap = re.captures(t!(\"abc\")).unwrap();\n    assert_eq!(&cap[0], t!(\"abc\"));\n    assert_eq!(&cap[1], t!(\"abc\"));\n    assert_eq!(&cap[\"name\"], t!(\"abc\"));\n}\n\n#[test]\n#[should_panic]\n#[cfg_attr(all(target_env = \"msvc\", target_pointer_width = \"32\"), ignore)]\nfn capture_index_panic_usize() {\n    let re = regex!(r\"^(?P<name>.+)$\");\n    let cap = re.captures(t!(\"abc\")).unwrap();\n    let _ = cap[2];\n}\n\n#[test]\n#[should_panic]\n#[cfg_attr(all(target_env = \"msvc\", target_pointer_width = \"32\"), ignore)]\nfn capture_index_panic_name() {\n    let re = regex!(r\"^(?P<name>.+)$\");\n    let cap = re.captures(t!(\"abc\")).unwrap();\n    let _ = cap[\"bad name\"];\n}\n\n#[test]\nfn capture_index_lifetime() {\n    // This is a test of whether the types on `caps[\"...\"]` are general\n    // enough. If not, this will fail to typecheck.\n    fn inner(s: &str) -> usize {\n        let re = regex!(r\"(?P<number>[0-9]+)\");\n        let caps = re.captures(t!(s)).unwrap();\n        caps[\"number\"].len()\n    }\n    assert_eq!(3, inner(\"123\"));\n}\n\n#[test]\nfn capture_misc() {\n    let re = regex!(r\"(.)(?P<a>a)?(.)(?P<b>.)\");\n    let cap = re.captures(t!(\"abc\")).unwrap();\n\n    assert_eq!(5, cap.len());\n\n    assert_eq!((0, 3), {\n        let m = cap.get(0).unwrap();\n        (m.start(), m.end())\n    });\n    assert_eq!(None, cap.get(2));\n    assert_eq!((2, 3), {\n        let m = cap.get(4).unwrap();\n        (m.start(), m.end())\n    });\n\n    assert_eq!(t!(\"abc\"), match_text!(cap.get(0).unwrap()));\n    assert_eq!(None, cap.get(2));\n    assert_eq!(t!(\"c\"), match_text!(cap.get(4).unwrap()));\n\n    assert_eq!(None, cap.name(\"a\"));\n    assert_eq!(t!(\"c\"), match_text!(cap.name(\"b\").unwrap()));\n}\n\n#[test]\nfn sub_capture_matches() {\n    let re = regex!(r\"([a-z])(([a-z])|([0-9]))\");\n    let cap = re.captures(t!(\"a5\")).unwrap();\n    let subs: Vec<_> = cap.iter().collect();\n\n    assert_eq!(5, subs.len());\n    assert!(subs[0].is_some());\n    assert!(subs[1].is_some());\n    assert!(subs[2].is_some());\n    assert!(subs[3].is_none());\n    assert!(subs[4].is_some());\n\n    assert_eq!(t!(\"a5\"), match_text!(subs[0].unwrap()));\n    assert_eq!(t!(\"a\"), match_text!(subs[1].unwrap()));\n    assert_eq!(t!(\"5\"), match_text!(subs[2].unwrap()));\n    assert_eq!(t!(\"5\"), match_text!(subs[4].unwrap()));\n}\n\nexpand!(expand1, r\"(?-u)(?P<foo>\\w+)\", \"abc\", \"$foo\", \"abc\");\nexpand!(expand2, r\"(?-u)(?P<foo>\\w+)\", \"abc\", \"$0\", \"abc\");\nexpand!(expand3, r\"(?-u)(?P<foo>\\w+)\", \"abc\", \"$1\", \"abc\");\nexpand!(expand4, r\"(?-u)(?P<foo>\\w+)\", \"abc\", \"$$1\", \"$1\");\nexpand!(expand5, r\"(?-u)(?P<foo>\\w+)\", \"abc\", \"$$foo\", \"$foo\");\nexpand!(expand6, r\"(?-u)(?P<a>\\w+)\\s+(?P<b>\\d+)\", \"abc 123\", \"$b$a\", \"123abc\");\nexpand!(expand7, r\"(?-u)(?P<a>\\w+)\\s+(?P<b>\\d+)\", \"abc 123\", \"z$bz$az\", \"z\");\nexpand!(\n    expand8,\n    r\"(?-u)(?P<a>\\w+)\\s+(?P<b>\\d+)\",\n    \"abc 123\",\n    \".$b.$a.\",\n    \".123.abc.\"\n);\nexpand!(\n    expand9,\n    r\"(?-u)(?P<a>\\w+)\\s+(?P<b>\\d+)\",\n    \"abc 123\",\n    \" $b $a \",\n    \" 123 abc \"\n);\nexpand!(expand10, r\"(?-u)(?P<a>\\w+)\\s+(?P<b>\\d+)\", \"abc 123\", \"$bz$az\", \"\");\n\nsplit!(\n    split1,\n    r\"(?-u)\\s+\",\n    \"a b\\nc\\td\\n\\t e\",\n    &[t!(\"a\"), t!(\"b\"), t!(\"c\"), t!(\"d\"), t!(\"e\")]\n);\nsplit!(\n    split2,\n    r\"(?-u)\\b\",\n    \"a b c\",\n    &[t!(\"\"), t!(\"a\"), t!(\" \"), t!(\"b\"), t!(\" \"), t!(\"c\"), t!(\"\")]\n);\nsplit!(split3, r\"a$\", \"a\", &[t!(\"\"), t!(\"\")]);\nsplit!(split_none, r\"-\", r\"a\", &[t!(\"a\")]);\nsplit!(split_trailing_blank, r\"-\", r\"a-\", &[t!(\"a\"), t!(\"\")]);\nsplit!(split_trailing_blanks, r\"-\", r\"a--\", &[t!(\"a\"), t!(\"\"), t!(\"\")]);\nsplit!(split_empty, r\"-\", r\"\", &[t!(\"\")]);\n\nsplitn!(splitn_below_limit, r\"-\", r\"a\", 2, &[t!(\"a\")]);\nsplitn!(splitn_at_limit, r\"-\", r\"a-b\", 2, &[t!(\"a\"), t!(\"b\")]);\nsplitn!(splitn_above_limit, r\"-\", r\"a-b-c\", 2, &[t!(\"a\"), t!(\"b-c\")]);\nsplitn!(splitn_zero_limit, r\"-\", r\"a-b\", 0, empty_vec!());\nsplitn!(splitn_trailing_blank, r\"-\", r\"a-\", 2, &[t!(\"a\"), t!(\"\")]);\nsplitn!(splitn_trailing_separator, r\"-\", r\"a--\", 2, &[t!(\"a\"), t!(\"-\")]);\nsplitn!(splitn_empty, r\"-\", r\"\", 1, &[t!(\"\")]);\n","traces":[{"line":2,"address":[6773570,6773536],"length":1,"stats":{"Line":24},"fn_name":"empty_regex_empty_match"},{"line":3,"address":[6773547,6773585],"length":1,"stats":{"Line":16},"fn_name":null},{"line":4,"address":[6773810,6773715],"length":1,"stats":{"Line":13},"fn_name":null},{"line":8,"address":[6774464,6774498],"length":1,"stats":{"Line":24},"fn_name":"empty_regex_nonempty_match"},{"line":9,"address":[6774513,6774475],"length":1,"stats":{"Line":16},"fn_name":null},{"line":10,"address":[6774882,6774643],"length":1,"stats":{"Line":13},"fn_name":null},{"line":14,"address":[6775536,6775574],"length":1,"stats":{"Line":24},"fn_name":"one_zero_length_match"},{"line":15,"address":[6775550,6775589],"length":1,"stats":{"Line":16},"fn_name":null},{"line":16,"address":[6775719,6775910],"length":1,"stats":{"Line":13},"fn_name":null},{"line":20,"address":[6776560,6776598],"length":1,"stats":{"Line":24},"fn_name":"many_zero_length_match"},{"line":21,"address":[6776574,6776613],"length":1,"stats":{"Line":16},"fn_name":null},{"line":22,"address":[6777136,6777066],"length":1,"stats":{"Line":8},"fn_name":null},{"line":23,"address":[6776743],"length":1,"stats":{"Line":8},"fn_name":null},{"line":24,"address":[6777030,6777098],"length":1,"stats":{"Line":13},"fn_name":null},{"line":29,"address":[6777718,6777680],"length":1,"stats":{"Line":24},"fn_name":"many_sequential_zero_length_match"},{"line":30,"address":[6777694,6777733],"length":1,"stats":{"Line":16},"fn_name":null},{"line":31,"address":[6778186,6778256],"length":1,"stats":{"Line":8},"fn_name":null},{"line":32,"address":[6777863],"length":1,"stats":{"Line":8},"fn_name":null},{"line":33,"address":[6778150,6778218],"length":1,"stats":{"Line":13},"fn_name":null},{"line":38,"address":[6778800,6778838],"length":1,"stats":{"Line":24},"fn_name":"quoted_bracket_set"},{"line":39,"address":[6778853,6778814],"length":1,"stats":{"Line":16},"fn_name":null},{"line":40,"address":[6778986,6779132],"length":1,"stats":{"Line":13},"fn_name":null},{"line":41,"address":[6779744],"length":1,"stats":{"Line":8},"fn_name":null},{"line":42,"address":[6780070,6779924],"length":1,"stats":{"Line":13},"fn_name":null},{"line":46,"address":[6780800,6780838],"length":1,"stats":{"Line":24},"fn_name":"first_range_starts_with_left_bracket"},{"line":47,"address":[6780814,6780853],"length":1,"stats":{"Line":16},"fn_name":null},{"line":48,"address":[6781126,6780983],"length":1,"stats":{"Line":13},"fn_name":null},{"line":52,"address":[6781814,6781776],"length":1,"stats":{"Line":24},"fn_name":"range_ends_with_escape"},{"line":53,"address":[6781829,6781790],"length":1,"stats":{"Line":16},"fn_name":null},{"line":54,"address":[6781959,6782102],"length":1,"stats":{"Line":13},"fn_name":null},{"line":58,"address":[6782752,6782790],"length":1,"stats":{"Line":24},"fn_name":"empty_match_find_iter"},{"line":59,"address":[6782766,6782805],"length":1,"stats":{"Line":16},"fn_name":null},{"line":60,"address":[6783174,6782935],"length":1,"stats":{"Line":13},"fn_name":null},{"line":64,"address":[6783862,6783824],"length":1,"stats":{"Line":24},"fn_name":"empty_match_captures_iter"},{"line":65,"address":[6783877,6783838],"length":1,"stats":{"Line":16},"fn_name":null},{"line":66,"address":[6783997,6784088],"length":1,"stats":{"Line":16},"fn_name":null},{"line":68,"address":[8454464,8454476],"length":1,"stats":{"Line":16},"fn_name":"{{closure}}"},{"line":69,"address":[8454624,8454633],"length":1,"stats":{"Line":16},"fn_name":"{{closure}}"},{"line":71,"address":[6784128,6784378],"length":1,"stats":{"Line":16},"fn_name":null},{"line":75,"address":[6784912,6784950],"length":1,"stats":{"Line":24},"fn_name":"capture_names"},{"line":76,"address":[6784926,6784965],"length":1,"stats":{"Line":16},"fn_name":null},{"line":77,"address":[6785088,6785320],"length":1,"stats":{"Line":8},"fn_name":null},{"line":78,"address":[6785267,6786028,6785697],"length":1,"stats":{"Line":16},"fn_name":null},{"line":79,"address":[6786405,6786456],"length":1,"stats":{"Line":8},"fn_name":null},{"line":80,"address":[6785875],"length":1,"stats":{"Line":8},"fn_name":null},{"line":81,"address":[6786441,6786376],"length":1,"stats":{"Line":16},"fn_name":null},{"line":86,"address":[6787045,6786992],"length":1,"stats":{"Line":24},"fn_name":"regex_string"},{"line":87,"address":[6787006,6787060],"length":1,"stats":{"Line":16},"fn_name":null},{"line":88,"address":[6787781],"length":1,"stats":{"Line":8},"fn_name":null},{"line":89,"address":[6788760],"length":1,"stats":{"Line":8},"fn_name":null},{"line":93,"address":[6789792,6789830],"length":1,"stats":{"Line":24},"fn_name":"capture_index"},{"line":94,"address":[6789806,6789845],"length":1,"stats":{"Line":16},"fn_name":null},{"line":95,"address":[6789968],"length":1,"stats":{"Line":11},"fn_name":null},{"line":96,"address":[6790056,6790319,6790270],"length":1,"stats":{"Line":16},"fn_name":null},{"line":97,"address":[6790276,6790687,6790891],"length":1,"stats":{"Line":19},"fn_name":null},{"line":98,"address":[6790841,6791235,6791393],"length":1,"stats":{"Line":19},"fn_name":null},{"line":104,"address":[6791760,6791798],"length":1,"stats":{"Line":32},"fn_name":"capture_index_panic_usize"},{"line":105,"address":[6791774,6791813],"length":1,"stats":{"Line":16},"fn_name":null},{"line":106,"address":[6791919],"length":1,"stats":{"Line":11},"fn_name":null},{"line":107,"address":[6791997],"length":1,"stats":{"Line":8},"fn_name":null},{"line":113,"address":[6792112,6792150],"length":1,"stats":{"Line":32},"fn_name":"capture_index_panic_name"},{"line":114,"address":[6792165,6792126],"length":1,"stats":{"Line":16},"fn_name":null},{"line":115,"address":[6792271],"length":1,"stats":{"Line":11},"fn_name":null},{"line":116,"address":[6792349],"length":1,"stats":{"Line":8},"fn_name":null},{"line":120,"address":[6792480],"length":1,"stats":{"Line":24},"fn_name":"capture_index_lifetime"},{"line":123,"address":[6792896,6792963],"length":1,"stats":{"Line":8},"fn_name":"inner"},{"line":124,"address":[6792978,6792926],"length":1,"stats":{"Line":16},"fn_name":null},{"line":125,"address":[6793092],"length":1,"stats":{"Line":11},"fn_name":null},{"line":126,"address":[6793172],"length":1,"stats":{"Line":8},"fn_name":null},{"line":128,"address":[6792494,6792615],"length":1,"stats":{"Line":8},"fn_name":null},{"line":132,"address":[6793344,6793382],"length":1,"stats":{"Line":24},"fn_name":"capture_misc"},{"line":133,"address":[6793397,6793358],"length":1,"stats":{"Line":16},"fn_name":null},{"line":134,"address":[6793520],"length":1,"stats":{"Line":11},"fn_name":null},{"line":136,"address":[6793608,6793830],"length":1,"stats":{"Line":8},"fn_name":null},{"line":138,"address":[6794315,6793783,6794478],"length":1,"stats":{"Line":16},"fn_name":null},{"line":139,"address":[6793790,6794199],"length":1,"stats":{"Line":16},"fn_name":null},{"line":140,"address":[6794237],"length":1,"stats":{"Line":8},"fn_name":null},{"line":142,"address":[6794428,6795001,6794846],"length":1,"stats":{"Line":16},"fn_name":null},{"line":143,"address":[6795477,6794951,6795637],"length":1,"stats":{"Line":16},"fn_name":null},{"line":144,"address":[6795361,6794958],"length":1,"stats":{"Line":16},"fn_name":null},{"line":145,"address":[6795399],"length":1,"stats":{"Line":8},"fn_name":null},{"line":148,"address":[6795590,6795997,6796266],"length":1,"stats":{"Line":13},"fn_name":null},{"line":149,"address":[6796216,6796634,6796789],"length":1,"stats":{"Line":16},"fn_name":null},{"line":150,"address":[6797149,6797446,6796739],"length":1,"stats":{"Line":13},"fn_name":null},{"line":152,"address":[6797814,6797997,6797368],"length":1,"stats":{"Line":16},"fn_name":null},{"line":153,"address":[6797919,6798345,6798559],"length":1,"stats":{"Line":13},"fn_name":null},{"line":157,"address":[6798928,6798966],"length":1,"stats":{"Line":24},"fn_name":"sub_capture_matches"},{"line":158,"address":[6798981,6798942],"length":1,"stats":{"Line":16},"fn_name":null},{"line":159,"address":[6799104],"length":1,"stats":{"Line":11},"fn_name":null},{"line":160,"address":[6799192],"length":1,"stats":{"Line":8},"fn_name":null},{"line":162,"address":[6799462,6799258],"length":1,"stats":{"Line":8},"fn_name":null},{"line":163,"address":[6799839,6799894,6799444],"length":1,"stats":{"Line":16},"fn_name":null},{"line":164,"address":[6799935,6799990,6799879],"length":1,"stats":{"Line":16},"fn_name":null},{"line":165,"address":[6799975,6800031,6800086],"length":1,"stats":{"Line":16},"fn_name":null},{"line":166,"address":[6800182,6800127,6800071],"length":1,"stats":{"Line":16},"fn_name":null},{"line":167,"address":[6800292,6800223,6800167],"length":1,"stats":{"Line":16},"fn_name":null},{"line":169,"address":[6800250,6800333,6800621],"length":1,"stats":{"Line":13},"fn_name":null},{"line":170,"address":[6800575,6800989,6801277],"length":1,"stats":{"Line":13},"fn_name":null},{"line":171,"address":[6801645,6801231,6801933],"length":1,"stats":{"Line":13},"fn_name":null},{"line":172,"address":[6801887,6802516,6802283],"length":1,"stats":{"Line":13},"fn_name":null},{"line":202,"address":[5777004],"length":1,"stats":{"Line":3},"fn_name":null},{"line":208,"address":[5778737],"length":1,"stats":{"Line":3},"fn_name":null},{"line":210,"address":[5779980],"length":1,"stats":{"Line":3},"fn_name":null},{"line":211,"address":[5780918],"length":1,"stats":{"Line":3},"fn_name":null},{"line":212,"address":[5781980],"length":1,"stats":{"Line":3},"fn_name":null},{"line":213,"address":[5783163],"length":1,"stats":{"Line":3},"fn_name":null},{"line":214,"address":[5784134],"length":1,"stats":{"Line":3},"fn_name":null},{"line":216,"address":[5785062],"length":1,"stats":{"Line":3},"fn_name":null},{"line":217,"address":[5786127],"length":1,"stats":{"Line":3},"fn_name":null},{"line":218,"address":[5787199],"length":1,"stats":{"Line":3},"fn_name":null},{"line":219,"address":[6820837],"length":1,"stats":{"Line":8},"fn_name":null},{"line":220,"address":[5789119],"length":1,"stats":{"Line":3},"fn_name":null},{"line":221,"address":[5790191],"length":1,"stats":{"Line":3},"fn_name":null},{"line":222,"address":[5791126],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":114,"coverable":114},{"path":["/","usr","src","regex","tests","api_str.rs"],"content":"// These tests don't really make sense with the bytes API, so we only test them\n// on the Unicode API.\n\n#[test]\nfn empty_match_unicode_find_iter() {\n    // Tests that we still yield byte ranges at valid UTF-8 sequence boundaries\n    // even when we're susceptible to empty width matches.\n    let re = regex!(r\".*?\");\n    assert_eq!(\n        vec![(0, 0), (3, 3), (4, 4), (7, 7), (8, 8)],\n        findall!(re, \"Ⅰ1Ⅱ2\")\n    );\n}\n\n#[test]\nfn empty_match_unicode_captures_iter() {\n    // Same as empty_match_unicode_find_iter, but tests capture iteration.\n    let re = regex!(r\".*?\");\n    let ms: Vec<_> = re\n        .captures_iter(text!(\"Ⅰ1Ⅱ2\"))\n        .map(|c| c.get(0).unwrap())\n        .map(|m| (m.start(), m.end()))\n        .collect();\n    assert_eq!(vec![(0, 0), (3, 3), (4, 4), (7, 7), (8, 8)], ms);\n}\n\n#[test]\nfn match_as_str() {\n    let re = regex!(r\"fo+\");\n    let caps = re.captures(\"barfoobar\").unwrap();\n    assert_eq!(caps.get(0).map(|m| m.as_str()), Some(\"foo\"));\n    assert_eq!(caps.get(0).map(From::from), Some(\"foo\"));\n    assert_eq!(caps.get(0).map(Into::into), Some(\"foo\"));\n}\n","traces":[{"line":5,"address":[5254032,5254070],"length":1,"stats":{"Line":15},"fn_name":"empty_match_unicode_find_iter"},{"line":8,"address":[5254046,5254085],"length":1,"stats":{"Line":10},"fn_name":null},{"line":9,"address":[5254538,5254608],"length":1,"stats":{"Line":5},"fn_name":null},{"line":10,"address":[7474764],"length":1,"stats":{"Line":5},"fn_name":null},{"line":11,"address":[4232598,4232666],"length":1,"stats":{"Line":10},"fn_name":null},{"line":16,"address":[4231397,4231392],"length":1,"stats":{"Line":15},"fn_name":"{{closure}}"},{"line":18,"address":[4233301,4233262],"length":1,"stats":{"Line":10},"fn_name":null},{"line":19,"address":[4233512,4233421],"length":1,"stats":{"Line":10},"fn_name":null},{"line":21,"address":[4396048,4396060],"length":1,"stats":{"Line":10},"fn_name":"{{closure}}"},{"line":22,"address":[4396217,4396208],"length":1,"stats":{"Line":10},"fn_name":"{{closure}}"},{"line":24,"address":[4233850,4233552],"length":1,"stats":{"Line":10},"fn_name":null},{"line":28,"address":[4231744,4231749],"length":1,"stats":{"Line":15},"fn_name":"{{closure}}"},{"line":29,"address":[4234398,4234437],"length":1,"stats":{"Line":10},"fn_name":null},{"line":30,"address":[4234560],"length":1,"stats":{"Line":5},"fn_name":null},{"line":31,"address":[4231856,4231860],"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":32,"address":[4235467,4235269,4234867],"length":1,"stats":{"Line":10},"fn_name":null},{"line":33,"address":[4235985,4235433,4235823],"length":1,"stats":{"Line":10},"fn_name":null}],"covered":17,"coverable":17},{"path":["/","usr","src","regex","tests","bytes.rs"],"content":"// These are tests specifically crafted for regexes that can match arbitrary\n// bytes.\n\n// A silly wrapper to make it possible to write and match raw bytes.\nstruct R<'a>(&'a [u8]);\nimpl<'a> R<'a> {\n    fn as_bytes(&self) -> &'a [u8] {\n        self.0\n    }\n}\n\nmat!(word_boundary, r\"(?-u) \\b\", \" δ\", None);\n#[cfg(feature = \"unicode-perl\")]\nmat!(word_boundary_unicode, r\" \\b\", \" δ\", Some((0, 1)));\nmat!(word_not_boundary, r\"(?-u) \\B\", \" δ\", Some((0, 1)));\n#[cfg(feature = \"unicode-perl\")]\nmat!(word_not_boundary_unicode, r\" \\B\", \" δ\", None);\n\nmat!(perl_w_ascii, r\"(?-u)\\w+\", \"aδ\", Some((0, 1)));\n#[cfg(feature = \"unicode-perl\")]\nmat!(perl_w_unicode, r\"\\w+\", \"aδ\", Some((0, 3)));\nmat!(perl_d_ascii, r\"(?-u)\\d+\", \"1२३9\", Some((0, 1)));\n#[cfg(feature = \"unicode-perl\")]\nmat!(perl_d_unicode, r\"\\d+\", \"1२३9\", Some((0, 8)));\nmat!(perl_s_ascii, r\"(?-u)\\s+\", \" \\u{1680}\", Some((0, 1)));\n#[cfg(feature = \"unicode-perl\")]\nmat!(perl_s_unicode, r\"\\s+\", \" \\u{1680}\", Some((0, 4)));\n\n// The first `(.+)` matches two Unicode codepoints, but can't match the 5th\n// byte, which isn't valid UTF-8. The second (byte based) `(.+)` takes over and\n// matches.\nmat!(\n    mixed1,\n    r\"(.+)(?-u)(.+)\",\n    R(b\"\\xCE\\x93\\xCE\\x94\\xFF\"),\n    Some((0, 5)),\n    Some((0, 4)),\n    Some((4, 5))\n);\n\nmat!(case_ascii_one, r\"(?i-u)a\", \"A\", Some((0, 1)));\nmat!(case_ascii_class, r\"(?i-u)[a-z]+\", \"AaAaA\", Some((0, 5)));\n#[cfg(feature = \"unicode-case\")]\nmat!(case_unicode, r\"(?i)[a-z]+\", \"aA\\u{212A}aA\", Some((0, 7)));\nmat!(case_not_unicode, r\"(?i-u)[a-z]+\", \"aA\\u{212A}aA\", Some((0, 2)));\n\nmat!(negate_unicode, r\"[^a]\", \"δ\", Some((0, 2)));\nmat!(negate_not_unicode, r\"(?-u)[^a]\", \"δ\", Some((0, 1)));\n\n// This doesn't match in a normal Unicode regex because the implicit preceding\n// `.*?` is Unicode aware.\nmat!(dotstar_prefix_not_unicode1, r\"(?-u)a\", R(b\"\\xFFa\"), Some((1, 2)));\nmat!(dotstar_prefix_not_unicode2, r\"a\", R(b\"\\xFFa\"), Some((1, 2)));\n\n// Have fun with null bytes.\nmat!(\n    null_bytes,\n    r\"(?-u)(?P<cstr>[^\\x00]+)\\x00\",\n    R(b\"foo\\x00\"),\n    Some((0, 4)),\n    Some((0, 3))\n);\n\n// Test that lookahead operators work properly in the face of invalid UTF-8.\n// See: https://github.com/rust-lang/regex/issues/277\nmatiter!(\n    invalidutf8_anchor1,\n    r\"(?-u)\\xcc?^\",\n    R(b\"\\x8d#;\\x1a\\xa4s3\\x05foobarX\\\\\\x0f0t\\xe4\\x9b\\xa4\"),\n    (0, 0)\n);\nmatiter!(\n    invalidutf8_anchor2,\n    r\"(?-u)^\\xf7|4\\xff\\d\\x8a\\x8a\\x8a\\x8a\\x8a\\x8a\\x8a\\x8a\\x8a\\x8a\\x8a\\x8a\\x8a##########[] d\\x8a\\x8a\\x8a\\x8a\\x8a\\x8a\\x8a\\x8a\\x8a\\x8a\\x8a\\x8a\\x8a##########\\[] #####\\x80\\S7|$\",\n    R(b\"\\x8d#;\\x1a\\xa4s3\\x05foobarX\\\\\\x0f0t\\xe4\\x9b\\xa4\"),\n    (22, 22)\n);\nmatiter!(\n    invalidutf8_anchor3,\n    r\"(?-u)^|ddp\\xff\\xffdddddlQd@\\x80\",\n    R(b\"\\x8d#;\\x1a\\xa4s3\\x05foobarX\\\\\\x0f0t\\xe4\\x9b\\xa4\"),\n    (0, 0)\n);\n\n// See https://github.com/rust-lang/regex/issues/303\n#[test]\nfn negated_full_byte_range() {\n    assert!(::regex::bytes::Regex::new(r#\"(?-u)[^\\x00-\\xff]\"#).is_err());\n}\n\nmatiter!(word_boundary_ascii1, r\"(?-u:\\B)x(?-u:\\B)\", \"áxβ\");\nmatiter!(\n    word_boundary_ascii2,\n    r\"(?-u:\\B)\",\n    \"0\\u{7EF5E}\",\n    (2, 2),\n    (3, 3),\n    (4, 4),\n    (5, 5)\n);\n\n// See: https://github.com/rust-lang/regex/issues/264\nmat!(ascii_boundary_no_capture, r\"(?-u)\\B\", \"\\u{28f3e}\", Some((0, 0)));\nmat!(ascii_boundary_capture, r\"(?-u)(\\B)\", \"\\u{28f3e}\", Some((0, 0)));\n\n// See: https://github.com/rust-lang/regex/issues/271\nmat!(end_not_wb, r\"$(?-u:\\B)\", \"\\u{5c124}\\u{b576c}\", Some((8, 8)));\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":12,"address":[7800041,7801235],"length":1,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[7802057,7803307],"length":1,"stats":{"Line":3},"fn_name":null},{"line":15,"address":[7805371,7804121],"length":1,"stats":{"Line":3},"fn_name":null},{"line":17,"address":[7806185,7807379],"length":1,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[7809451,7808201],"length":1,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[7811515,7810265],"length":1,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[7812329,7813579],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[7815643,7814393],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[7816457,7817707],"length":1,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[7819771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[7820471],"length":1,"stats":{"Line":3},"fn_name":null},{"line":36,"address":[7820534],"length":1,"stats":{"Line":3},"fn_name":null},{"line":37,"address":[7820602],"length":1,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[7820670],"length":1,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[7824059,7822809],"length":1,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[7824873,7826123],"length":1,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[7828187,7826937],"length":1,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[7829001,7830251],"length":1,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[7831065],"length":1,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[7834379,7833129],"length":1,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[7836392,7835142,7835079],"length":1,"stats":{"Line":6},"fn_name":null},{"line":53,"address":[7837095,7837158,7838408],"length":1,"stats":{"Line":6},"fn_name":null},{"line":59,"address":[7839111],"length":1,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[7839174],"length":1,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[7839242],"length":1,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[7841239],"length":1,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[7841302],"length":1,"stats":{"Line":3},"fn_name":null},{"line":75,"address":[7843111],"length":1,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[7843174],"length":1,"stats":{"Line":3},"fn_name":null},{"line":81,"address":[7844983],"length":1,"stats":{"Line":3},"fn_name":null},{"line":82,"address":[7845046],"length":1,"stats":{"Line":3},"fn_name":null},{"line":87,"address":[7846848,7846880],"length":1,"stats":{"Line":9},"fn_name":"negated_full_byte_range"},{"line":88,"address":[7846897,7846957,7846859],"length":1,"stats":{"Line":6},"fn_name":null},{"line":91,"address":[7848213,7847440],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[7849001],"length":1,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[7849025],"length":1,"stats":{"Line":3},"fn_name":null},{"line":98,"address":[7849049],"length":1,"stats":{"Line":3},"fn_name":null},{"line":99,"address":[7849073],"length":1,"stats":{"Line":3},"fn_name":null},{"line":103,"address":[7851065,7852315],"length":1,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[7853129,7854379],"length":1,"stats":{"Line":3},"fn_name":null},{"line":107,"address":[7856443,7855193],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":41,"coverable":43},{"path":["/","usr","src","regex","tests","consistent.rs"],"content":"use regex::internal::ExecBuilder;\n\n/// Given a regex, check if all of the backends produce the same\n/// results on a number of different inputs.\n///\n/// For now this just throws quickcheck at the problem, which\n/// is not very good because it only really tests half of the\n/// problem space. It is pretty unlikely that a random string\n/// will match any given regex, so this will probably just\n/// be checking that the different backends fail in the same\n/// way. This is still worthwhile to test, but is definitely not\n/// the whole story.\n///\n/// TODO(ethan): In order to cover the other half of the problem\n/// space, we should generate a random matching string by inspecting\n/// the AST of the input regex. The right way to do this probably\n/// involves adding a custom Arbitrary instance around a couple\n/// of newtypes. That way we can respect the quickcheck size hinting\n/// and shrinking and whatnot.\npub fn backends_are_consistent(re: &str) -> Result<u64, String> {\n    let standard_backends = vec![\n        (\n            \"bounded_backtracking_re\",\n            ExecBuilder::new(re)\n                .bounded_backtracking()\n                .build()\n                .map(|exec| exec.into_regex())\n                .map_err(|err| format!(\"{}\", err))?,\n        ),\n        (\n            \"pikevm_re\",\n            ExecBuilder::new(re)\n                .nfa()\n                .build()\n                .map(|exec| exec.into_regex())\n                .map_err(|err| format!(\"{}\", err))?,\n        ),\n        (\n            \"default_re\",\n            ExecBuilder::new(re)\n                .build()\n                .map(|exec| exec.into_regex())\n                .map_err(|err| format!(\"{}\", err))?,\n        ),\n    ];\n\n    let utf8bytes_backends = vec![\n        (\n            \"bounded_backtracking_utf8bytes_re\",\n            ExecBuilder::new(re)\n                .bounded_backtracking()\n                .bytes(true)\n                .build()\n                .map(|exec| exec.into_regex())\n                .map_err(|err| format!(\"{}\", err))?,\n        ),\n        (\n            \"pikevm_utf8bytes_re\",\n            ExecBuilder::new(re)\n                .nfa()\n                .bytes(true)\n                .build()\n                .map(|exec| exec.into_regex())\n                .map_err(|err| format!(\"{}\", err))?,\n        ),\n        (\n            \"default_utf8bytes_re\",\n            ExecBuilder::new(re)\n                .bytes(true)\n                .build()\n                .map(|exec| exec.into_regex())\n                .map_err(|err| format!(\"{}\", err))?,\n        ),\n    ];\n\n    let bytes_backends = vec![\n        (\n            \"bounded_backtracking_bytes_re\",\n            ExecBuilder::new(re)\n                .bounded_backtracking()\n                .only_utf8(false)\n                .build()\n                .map(|exec| exec.into_byte_regex())\n                .map_err(|err| format!(\"{}\", err))?,\n        ),\n        (\n            \"pikevm_bytes_re\",\n            ExecBuilder::new(re)\n                .nfa()\n                .only_utf8(false)\n                .build()\n                .map(|exec| exec.into_byte_regex())\n                .map_err(|err| format!(\"{}\", err))?,\n        ),\n        (\n            \"default_bytes_re\",\n            ExecBuilder::new(re)\n                .only_utf8(false)\n                .build()\n                .map(|exec| exec.into_byte_regex())\n                .map_err(|err| format!(\"{}\", err))?,\n        ),\n    ];\n\n    Ok(string_checker::check_backends(&standard_backends)?\n        + string_checker::check_backends(&utf8bytes_backends)?\n        + bytes_checker::check_backends(&bytes_backends)?)\n}\n\n//\n// A consistency checker parameterized by the input type (&str or &[u8]).\n//\n\nmacro_rules! checker {\n    ($module_name:ident, $regex_type:path, $mk_input:expr) => {\n        mod $module_name {\n            use quickcheck;\n            use quickcheck::{Arbitrary, TestResult};\n\n            pub fn check_backends(\n                backends: &[(&str, $regex_type)],\n            ) -> Result<u64, String> {\n                let mut total_passed = 0;\n                for regex in backends[1..].iter() {\n                    total_passed += quickcheck_regex_eq(&backends[0], regex)?;\n                }\n\n                Ok(total_passed)\n            }\n\n            fn quickcheck_regex_eq(\n                &(name1, ref re1): &(&str, $regex_type),\n                &(name2, ref re2): &(&str, $regex_type),\n            ) -> Result<u64, String> {\n                quickcheck::QuickCheck::new()\n                    .quicktest(RegexEqualityTest::new(\n                        re1.clone(),\n                        re2.clone(),\n                    ))\n                    .map_err(|err| {\n                        format!(\n                            \"{}(/{}/) and {}(/{}/) are inconsistent.\\\n                             QuickCheck Err: {:?}\",\n                            name1, re1, name2, re2, err\n                        )\n                    })\n            }\n\n            struct RegexEqualityTest {\n                re1: $regex_type,\n                re2: $regex_type,\n            }\n            impl RegexEqualityTest {\n                fn new(re1: $regex_type, re2: $regex_type) -> Self {\n                    RegexEqualityTest { re1: re1, re2: re2 }\n                }\n            }\n\n            impl quickcheck::Testable for RegexEqualityTest {\n                fn result<G: quickcheck::Gen>(\n                    &self,\n                    gen: &mut G,\n                ) -> TestResult {\n                    let input = $mk_input(gen);\n                    let input = &input;\n\n                    if self.re1.find(&input) != self.re2.find(input) {\n                        return TestResult::error(format!(\n                            \"find mismatch input={:?}\",\n                            input\n                        ));\n                    }\n\n                    let cap1 = self.re1.captures(input);\n                    let cap2 = self.re2.captures(input);\n                    match (cap1, cap2) {\n                        (None, None) => {}\n                        (Some(cap1), Some(cap2)) => {\n                            for (c1, c2) in cap1.iter().zip(cap2.iter()) {\n                                if c1 != c2 {\n                                    return TestResult::error(format!(\n                                        \"captures mismatch input={:?}\",\n                                        input\n                                    ));\n                                }\n                            }\n                        }\n                        _ => {\n                            return TestResult::error(format!(\n                                \"captures mismatch input={:?}\",\n                                input\n                            ))\n                        }\n                    }\n\n                    let fi1 = self.re1.find_iter(input);\n                    let fi2 = self.re2.find_iter(input);\n                    for (m1, m2) in fi1.zip(fi2) {\n                        if m1 != m2 {\n                            return TestResult::error(format!(\n                                \"find_iter mismatch input={:?}\",\n                                input\n                            ));\n                        }\n                    }\n\n                    let ci1 = self.re1.captures_iter(input);\n                    let ci2 = self.re2.captures_iter(input);\n                    for (cap1, cap2) in ci1.zip(ci2) {\n                        for (c1, c2) in cap1.iter().zip(cap2.iter()) {\n                            if c1 != c2 {\n                                return TestResult::error(format!(\n                                    \"captures_iter mismatch input={:?}\",\n                                    input\n                                ));\n                            }\n                        }\n                    }\n\n                    let s1 = self.re1.split(input);\n                    let s2 = self.re2.split(input);\n                    for (chunk1, chunk2) in s1.zip(s2) {\n                        if chunk1 != chunk2 {\n                            return TestResult::error(format!(\n                                \"split mismatch input={:?}\",\n                                input\n                            ));\n                        }\n                    }\n\n                    TestResult::from_bool(true)\n                }\n            }\n        } // mod\n    }; // rule case\n} // macro_rules!\n\nchecker!(string_checker, ::regex::Regex, |gen| String::arbitrary(gen));\nchecker!(bytes_checker, ::regex::bytes::Regex, |gen| Vec::<u8>::arbitrary(\n    gen\n));\n","traces":[{"line":20,"address":[4595375,4595264],"length":1,"stats":{"Line":0},"fn_name":"backends_are_consistent"},{"line":21,"address":[4596669,4596933,4597283,4602682,4595941,4595926,4596505,4595312,4595538,4596107,4596530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[4595553,4595346,4595804,4595390],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[4563808,4563815],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":28,"address":[4563898,4563888],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":32,"address":[4596137,4595959,4596388,4595772],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[4564183,4564176],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":36,"address":[4564266,4564256],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":40,"address":[4596714,4596356,4597166,4596548],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[4564551,4564544],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":43,"address":[4564624,4564634],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":47,"address":[4602700,4597945,4597975,4598173,4599031,4598767,4597570,4599384,4598571,4598596,4597333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[4597836,4597390,4597346,4597585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[4564919,4564912],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":55,"address":[4565002,4564992],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":59,"address":[4597993,4598203,4598454,4597804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[4565280,4565287],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":64,"address":[4565360,4565370],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":68,"address":[4599267,4598422,4598614,4598812],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[4565648,4565655],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":72,"address":[4565728,4565738],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":76,"address":[4600046,4602718,4600079,4600274,4600865,4599671,4600697,4599434,4601482,4601129,4600672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[4599937,4599686,4599494,4599447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[4566016,4566023],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":84,"address":[4566096,4566106],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":88,"address":[4599905,4600097,4600555,4600304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[4566391,4566384],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":93,"address":[4566464,4566474],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":97,"address":[4600910,4600715,4601365,4600523],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[4566759,4566752],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":101,"address":[4566832,4566842],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":105,"address":[4602581,4602364,4601527,4603533,4602012,4601674,4601580,4601874,4601723],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[4602037,4601703,4602201,4601897,4601991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[4602567,4602343,4602388,4602214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[4213114,4212752],"length":1,"stats":{"Line":0},"fn_name":"check_backends"},{"line":123,"address":[4212778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[4212987,4213316,4212787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[4213129,4213284,4213321,4213030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[4568865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[4213408,4213529],"length":1,"stats":{"Line":0},"fn_name":"quickcheck_regex_eq"},{"line":132,"address":[4213434],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[4569375],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[4569624,4569541,4569404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[4213590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[4213544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[4213570],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[4213663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[4640547,4640291,4640615],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[4640269],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[4640276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[4213824],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":155,"address":[4213834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[4641212,4641072],"length":1,"stats":{"Line":0},"fn_name":"result<quickcheck::arbitrary::StdThreadGen>"},{"line":164,"address":[4641104,4641151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[4641235],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[4641251,4641360],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[4641824,4641650,4641554],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[4641539],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[4641829,4641497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[4641888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[4641974,4643411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[4642190,4642282],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[4642404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[4642777,4642540,4643078,4642653],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[4643051],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[4643374,4647495,4643098,4643387],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[4643083],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[4643336,4643392,4642594,4642755],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[4642325,4643424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[4642310],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[4643595,4647698],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[4643690],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[4644088,4644389,4643776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[4644362],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[4644409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[4644394],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[4644654,4644046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[4644705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[4646406,4644791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[4645489,4645659,4645783,4645573,4646078],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[4646057],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[4646366,4646098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[4646083],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[4645540,4646411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[4646453],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[4646810,4647013,4646521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[4646972],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[4647033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[4647018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[4646783],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[4648016,4648033,4641144],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}<quickcheck::arbitrary::StdThreadGen>"},{"line":239,"address":[4651832,4658737,4658720],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}<quickcheck::arbitrary::StdThreadGen>"}],"covered":0,"coverable":92},{"path":["/","usr","src","regex","tests","crazy.rs"],"content":"mat!(ascii_literal, r\"a\", \"a\", Some((0, 1)));\n\n// Some crazy expressions from regular-expressions.info.\nmat!(\n    match_ranges,\n    r\"(?-u)\\b(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\",\n    \"num: 255\",\n    Some((5, 8))\n);\nmat!(\n    match_ranges_not,\n    r\"(?-u)\\b(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\",\n    \"num: 256\",\n    None\n);\nmat!(match_float1, r\"[-+]?[0-9]*\\.?[0-9]+\", \"0.1\", Some((0, 3)));\nmat!(match_float2, r\"[-+]?[0-9]*\\.?[0-9]+\", \"0.1.2\", Some((0, 3)));\nmat!(match_float3, r\"[-+]?[0-9]*\\.?[0-9]+\", \"a1.2\", Some((1, 4)));\nmat!(match_float4, r\"^[-+]?[0-9]*\\.?[0-9]+$\", \"1.a\", None);\nmat!(\n    match_email,\n    r\"(?i-u)\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}\\b\",\n    \"mine is jam.slam@gmail.com \",\n    Some((8, 26))\n);\nmat!(\n    match_email_not,\n    r\"(?i-u)\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}\\b\",\n    \"mine is jam.slam@gmail \",\n    None\n);\nmat!(\n    match_email_big,\n    r\"[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\",\n    \"mine is jam.slam@gmail.com \",\n    Some((8, 26))\n);\nmat!(\n    match_date1,\n    r\"(?-u)^(19|20)\\d\\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$\",\n    \"1900-01-01\",\n    Some((0, 10))\n);\nmat!(\n    match_date2,\n    r\"(?-u)^(19|20)\\d\\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$\",\n    \"1900-00-01\",\n    None\n);\nmat!(\n    match_date3,\n    r\"(?-u)^(19|20)\\d\\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$\",\n    \"1900-13-01\",\n    None\n);\n\n// Do some crazy dancing with the start/end assertions.\nmatiter!(match_start_end_empty, r\"^$\", \"\", (0, 0));\nmatiter!(match_start_end_empty_many_1, r\"^$^$^$\", \"\", (0, 0));\nmatiter!(match_start_end_empty_many_2, r\"^^^$$$\", \"\", (0, 0));\nmatiter!(match_start_end_empty_rev, r\"$^\", \"\", (0, 0));\nmatiter!(\n    match_start_end_empty_rep,\n    r\"(?:^$)*\",\n    \"a\\nb\\nc\",\n    (0, 0),\n    (1, 1),\n    (2, 2),\n    (3, 3),\n    (4, 4),\n    (5, 5)\n);\nmatiter!(\n    match_start_end_empty_rep_rev,\n    r\"(?:$^)*\",\n    \"a\\nb\\nc\",\n    (0, 0),\n    (1, 1),\n    (2, 2),\n    (3, 3),\n    (4, 4),\n    (5, 5)\n);\n\n// Test negated character classes.\nmat!(negclass_letters, r\"[^ac]\", \"acx\", Some((2, 3)));\nmat!(negclass_letter_comma, r\"[^a,]\", \"a,x\", Some((2, 3)));\nmat!(negclass_letter_space, r\"[^a[:space:]]\", \"a x\", Some((2, 3)));\nmat!(negclass_comma, r\"[^,]\", \",,x\", Some((2, 3)));\nmat!(negclass_space, r\"[^[:space:]]\", \" a\", Some((1, 2)));\nmat!(negclass_space_comma, r\"[^,[:space:]]\", \", a\", Some((2, 3)));\nmat!(negclass_comma_space, r\"[^[:space:],]\", \" ,a\", Some((2, 3)));\nmat!(negclass_ascii, r\"[^[:alpha:]Z]\", \"A1\", Some((1, 2)));\n\n// Test that repeated empty expressions don't loop forever.\nmat!(lazy_many_many, r\"((?:.*)*?)=\", \"a=b\", Some((0, 2)));\nmat!(lazy_many_optional, r\"((?:.?)*?)=\", \"a=b\", Some((0, 2)));\nmat!(lazy_one_many_many, r\"((?:.*)+?)=\", \"a=b\", Some((0, 2)));\nmat!(lazy_one_many_optional, r\"((?:.?)+?)=\", \"a=b\", Some((0, 2)));\nmat!(lazy_range_min_many, r\"((?:.*){1,}?)=\", \"a=b\", Some((0, 2)));\nmat!(lazy_range_many, r\"((?:.*){1,2}?)=\", \"a=b\", Some((0, 2)));\nmat!(greedy_many_many, r\"((?:.*)*)=\", \"a=b\", Some((0, 2)));\nmat!(greedy_many_optional, r\"((?:.?)*)=\", \"a=b\", Some((0, 2)));\nmat!(greedy_one_many_many, r\"((?:.*)+)=\", \"a=b\", Some((0, 2)));\nmat!(greedy_one_many_optional, r\"((?:.?)+)=\", \"a=b\", Some((0, 2)));\nmat!(greedy_range_min_many, r\"((?:.*){1,})=\", \"a=b\", Some((0, 2)));\nmat!(greedy_range_many, r\"((?:.*){1,2})=\", \"a=b\", Some((0, 2)));\n\n// Test that we handle various flavors of empty expressions.\nmatiter!(match_empty1, r\"\", \"\", (0, 0));\nmatiter!(match_empty2, r\"\", \"abc\", (0, 0), (1, 1), (2, 2), (3, 3));\nmatiter!(match_empty3, r\"()\", \"abc\", (0, 0), (1, 1), (2, 2), (3, 3));\nmatiter!(match_empty4, r\"()*\", \"abc\", (0, 0), (1, 1), (2, 2), (3, 3));\nmatiter!(match_empty5, r\"()+\", \"abc\", (0, 0), (1, 1), (2, 2), (3, 3));\nmatiter!(match_empty6, r\"()?\", \"abc\", (0, 0), (1, 1), (2, 2), (3, 3));\nmatiter!(match_empty7, r\"()()\", \"abc\", (0, 0), (1, 1), (2, 2), (3, 3));\nmatiter!(match_empty8, r\"()+|z\", \"abc\", (0, 0), (1, 1), (2, 2), (3, 3));\nmatiter!(match_empty9, r\"z|()+\", \"abc\", (0, 0), (1, 1), (2, 2), (3, 3));\nmatiter!(match_empty10, r\"()+|b\", \"abc\", (0, 0), (1, 1), (2, 2), (3, 3));\nmatiter!(match_empty11, r\"b|()+\", \"abc\", (0, 0), (1, 2), (3, 3));\nmatiter!(match_empty12, r\"|b\", \"abc\", (0, 0), (1, 1), (2, 2), (3, 3));\nmatiter!(match_empty13, r\"b|\", \"abc\", (0, 0), (1, 2), (3, 3));\nmatiter!(match_empty14, r\"|z\", \"abc\", (0, 0), (1, 1), (2, 2), (3, 3));\nmatiter!(match_empty15, r\"z|\", \"abc\", (0, 0), (1, 1), (2, 2), (3, 3));\nmatiter!(match_empty16, r\"|\", \"abc\", (0, 0), (1, 1), (2, 2), (3, 3));\nmatiter!(match_empty17, r\"||\", \"abc\", (0, 0), (1, 1), (2, 2), (3, 3));\nmatiter!(match_empty18, r\"||z\", \"abc\", (0, 0), (1, 1), (2, 2), (3, 3));\nmatiter!(match_empty19, r\"(?:)|b\", \"abc\", (0, 0), (1, 1), (2, 2), (3, 3));\nmatiter!(match_empty20, r\"b|(?:)\", \"abc\", (0, 0), (1, 2), (3, 3));\nmatiter!(match_empty21, r\"(?:|)\", \"abc\", (0, 0), (1, 1), (2, 2), (3, 3));\nmatiter!(match_empty22, r\"(?:|)|z\", \"abc\", (0, 0), (1, 1), (2, 2), (3, 3));\nmatiter!(match_empty23, r\"a(?:)|b\", \"abc\", (0, 1), (1, 2));\n\n// Test that the DFA can handle pathological cases.\n// (This should result in the DFA's cache being flushed too frequently, which\n// should cause it to quit and fall back to the NFA algorithm.)\n#[test]\nfn dfa_handles_pathological_case() {\n    fn ones_and_zeroes(count: usize) -> String {\n        use rand::{thread_rng, Rng};\n\n        let mut rng = thread_rng();\n        let mut s = String::new();\n        for _ in 0..count {\n            if rng.gen() {\n                s.push('1');\n            } else {\n                s.push('0');\n            }\n        }\n        s\n    }\n\n    let re = regex!(r\"[01]*1[01]{20}$\");\n    let text = {\n        let mut pieces = ones_and_zeroes(100_000);\n        pieces.push('1');\n        pieces.push_str(&ones_and_zeroes(20));\n        pieces\n    };\n    assert!(re.is_match(text!(&*text)));\n}\n\n#[test]\nfn nest_limit_makes_it_parse() {\n    use regex::RegexBuilder;\n\n    RegexBuilder::new(\n        r#\"(?-u)\n        2(?:\n          [45]\\d{3}|\n          7(?:\n            1[0-267]|\n            2[0-289]|\n            3[0-29]|\n            4[01]|\n            5[1-3]|\n            6[013]|\n            7[0178]|\n            91\n          )|\n          8(?:\n            0[125]|\n            [139][1-6]|\n            2[0157-9]|\n            41|\n            6[1-35]|\n            7[1-5]|\n            8[1-8]|\n            90\n          )|\n          9(?:\n            0[0-2]|\n            1[0-4]|\n            2[568]|\n            3[3-6]|\n            5[5-7]|\n            6[0167]|\n            7[15]|\n            8[0146-9]\n          )\n        )\\d{4}|\n        3(?:\n          12?[5-7]\\d{2}|\n          0(?:\n            2(?:\n              [025-79]\\d|\n              [348]\\d{1,2}\n            )|\n            3(?:\n              [2-4]\\d|\n              [56]\\d?\n            )\n          )|\n          2(?:\n            1\\d{2}|\n            2(?:\n              [12]\\d|\n              [35]\\d{1,2}|\n              4\\d?\n            )\n          )|\n          3(?:\n            1\\d{2}|\n            2(?:\n              [2356]\\d|\n              4\\d{1,2}\n            )\n          )|\n          4(?:\n            1\\d{2}|\n            2(?:\n              2\\d{1,2}|\n              [47]|\n              5\\d{2}\n            )\n          )|\n          5(?:\n            1\\d{2}|\n            29\n          )|\n          [67]1\\d{2}|\n          8(?:\n            1\\d{2}|\n            2(?:\n              2\\d{2}|\n              3|\n              4\\d\n            )\n          )\n        )\\d{3}|\n        4(?:\n          0(?:\n            2(?:\n              [09]\\d|\n              7\n            )|\n            33\\d{2}\n          )|\n          1\\d{3}|\n          2(?:\n            1\\d{2}|\n            2(?:\n              [25]\\d?|\n              [348]\\d|\n              [67]\\d{1,2}\n            )\n          )|\n          3(?:\n            1\\d{2}(?:\n              \\d{2}\n            )?|\n            2(?:\n              [045]\\d|\n              [236-9]\\d{1,2}\n            )|\n            32\\d{2}\n          )|\n          4(?:\n            [18]\\d{2}|\n            2(?:\n              [2-46]\\d{2}|\n              3\n            )|\n            5[25]\\d{2}\n          )|\n          5(?:\n            1\\d{2}|\n            2(?:\n              3\\d|\n              5\n            )\n          )|\n          6(?:\n            [18]\\d{2}|\n            2(?:\n              3(?:\n                \\d{2}\n              )?|\n              [46]\\d{1,2}|\n              5\\d{2}|\n              7\\d\n            )|\n            5(?:\n              3\\d?|\n              4\\d|\n              [57]\\d{1,2}|\n              6\\d{2}|\n              8\n            )\n          )|\n          71\\d{2}|\n          8(?:\n            [18]\\d{2}|\n            23\\d{2}|\n            54\\d{2}\n          )|\n          9(?:\n            [18]\\d{2}|\n            2[2-5]\\d{2}|\n            53\\d{1,2}\n          )\n        )\\d{3}|\n        5(?:\n          02[03489]\\d{2}|\n          1\\d{2}|\n          2(?:\n            1\\d{2}|\n            2(?:\n              2(?:\n                \\d{2}\n              )?|\n              [457]\\d{2}\n            )\n          )|\n          3(?:\n            1\\d{2}|\n            2(?:\n              [37](?:\n                \\d{2}\n              )?|\n              [569]\\d{2}\n            )\n          )|\n          4(?:\n            1\\d{2}|\n            2[46]\\d{2}\n          )|\n          5(?:\n            1\\d{2}|\n            26\\d{1,2}\n          )|\n          6(?:\n            [18]\\d{2}|\n            2|\n            53\\d{2}\n          )|\n          7(?:\n            1|\n            24\n          )\\d{2}|\n          8(?:\n            1|\n            26\n          )\\d{2}|\n          91\\d{2}\n        )\\d{3}|\n        6(?:\n          0(?:\n            1\\d{2}|\n            2(?:\n              3\\d{2}|\n              4\\d{1,2}\n            )\n          )|\n          2(?:\n            2[2-5]\\d{2}|\n            5(?:\n              [3-5]\\d{2}|\n              7\n            )|\n            8\\d{2}\n          )|\n          3(?:\n            1|\n            2[3478]\n          )\\d{2}|\n          4(?:\n            1|\n            2[34]\n          )\\d{2}|\n          5(?:\n            1|\n            2[47]\n          )\\d{2}|\n          6(?:\n            [18]\\d{2}|\n            6(?:\n              2(?:\n                2\\d|\n                [34]\\d{2}\n              )|\n              5(?:\n                [24]\\d{2}|\n                3\\d|\n                5\\d{1,2}\n              )\n            )\n          )|\n          72[2-5]\\d{2}|\n          8(?:\n            1\\d{2}|\n            2[2-5]\\d{2}\n          )|\n          9(?:\n            1\\d{2}|\n            2[2-6]\\d{2}\n          )\n        )\\d{3}|\n        7(?:\n          (?:\n            02|\n            [3-589]1|\n            6[12]|\n            72[24]\n          )\\d{2}|\n          21\\d{3}|\n          32\n        )\\d{3}|\n        8(?:\n          (?:\n            4[12]|\n            [5-7]2|\n            1\\d?\n          )|\n          (?:\n            0|\n            3[12]|\n            [5-7]1|\n            217\n          )\\d\n        )\\d{4}|\n        9(?:\n          [35]1|\n          (?:\n            [024]2|\n            81\n          )\\d|\n          (?:\n            1|\n            [24]1\n          )\\d{2}\n        )\\d{3}\n        \"#,\n    )\n    .build()\n    .unwrap();\n}\n","traces":[{"line":1,"address":[5849188,5850564,5849150],"length":1,"stats":{"Line":13},"fn_name":null},{"line":8,"address":[5851316],"length":1,"stats":{"Line":8},"fn_name":null},{"line":14,"address":[5853444],"length":1,"stats":{"Line":8},"fn_name":null},{"line":16,"address":[5855508,5855470,5856884],"length":1,"stats":{"Line":13},"fn_name":null},{"line":17,"address":[5857598,5857636,5859012],"length":1,"stats":{"Line":13},"fn_name":null},{"line":18,"address":[5859726,5861140,5859764],"length":1,"stats":{"Line":13},"fn_name":null},{"line":19,"address":[5861854,5863212,5861892],"length":1,"stats":{"Line":13},"fn_name":null},{"line":24,"address":[5863956],"length":1,"stats":{"Line":8},"fn_name":null},{"line":30,"address":[5866084],"length":1,"stats":{"Line":8},"fn_name":null},{"line":36,"address":[5868148],"length":1,"stats":{"Line":8},"fn_name":null},{"line":42,"address":[5870276],"length":1,"stats":{"Line":8},"fn_name":null},{"line":48,"address":[5872404],"length":1,"stats":{"Line":8},"fn_name":null},{"line":54,"address":[5874468],"length":1,"stats":{"Line":8},"fn_name":null},{"line":58,"address":[5877024,5876532,5877797,5876487],"length":1,"stats":{"Line":13},"fn_name":null},{"line":59,"address":[5878516,5878471,5879781,5879008],"length":1,"stats":{"Line":13},"fn_name":null},{"line":60,"address":[5880992,5880455,5880500,5881765],"length":1,"stats":{"Line":13},"fn_name":null},{"line":61,"address":[5882484,5882976,5882439,5883749],"length":1,"stats":{"Line":13},"fn_name":null},{"line":66,"address":[5884468],"length":1,"stats":{"Line":8},"fn_name":null},{"line":67,"address":[5884492],"length":1,"stats":{"Line":8},"fn_name":null},{"line":68,"address":[5884516],"length":1,"stats":{"Line":8},"fn_name":null},{"line":69,"address":[5884540],"length":1,"stats":{"Line":8},"fn_name":null},{"line":70,"address":[5884564],"length":1,"stats":{"Line":8},"fn_name":null},{"line":71,"address":[5884588],"length":1,"stats":{"Line":8},"fn_name":null},{"line":77,"address":[5886692],"length":1,"stats":{"Line":8},"fn_name":null},{"line":78,"address":[5886716],"length":1,"stats":{"Line":8},"fn_name":null},{"line":79,"address":[5886740],"length":1,"stats":{"Line":8},"fn_name":null},{"line":80,"address":[5886764],"length":1,"stats":{"Line":8},"fn_name":null},{"line":81,"address":[5886788],"length":1,"stats":{"Line":8},"fn_name":null},{"line":82,"address":[5886812],"length":1,"stats":{"Line":8},"fn_name":null},{"line":86,"address":[5888916,5888878,5890292],"length":1,"stats":{"Line":13},"fn_name":null},{"line":87,"address":[5891044,5891006,5892420],"length":1,"stats":{"Line":13},"fn_name":null},{"line":88,"address":[5893172,5894548,5893134],"length":1,"stats":{"Line":13},"fn_name":null},{"line":89,"address":[5896676,5895300,5895262],"length":1,"stats":{"Line":13},"fn_name":null},{"line":90,"address":[5897428,5897390,5898804],"length":1,"stats":{"Line":13},"fn_name":null},{"line":91,"address":[5899518,5899556,5900932],"length":1,"stats":{"Line":13},"fn_name":null},{"line":92,"address":[5901646,5903060,5901684],"length":1,"stats":{"Line":13},"fn_name":null},{"line":93,"address":[5905188,5903774,5903812],"length":1,"stats":{"Line":13},"fn_name":null},{"line":96,"address":[5907316,5905902,5905940],"length":1,"stats":{"Line":13},"fn_name":null},{"line":97,"address":[5909444,5908030,5908068],"length":1,"stats":{"Line":13},"fn_name":null},{"line":98,"address":[5911572,5910158,5910196],"length":1,"stats":{"Line":13},"fn_name":null},{"line":99,"address":[5912286,5913700,5912324],"length":1,"stats":{"Line":13},"fn_name":null},{"line":100,"address":[5914414,5914452,5915828],"length":1,"stats":{"Line":13},"fn_name":null},{"line":101,"address":[5916542,5917956,5916580],"length":1,"stats":{"Line":13},"fn_name":null},{"line":102,"address":[5920084,5918708,5918670],"length":1,"stats":{"Line":13},"fn_name":null},{"line":103,"address":[5920798,5922212,5920836],"length":1,"stats":{"Line":13},"fn_name":null},{"line":104,"address":[5924340,5922926,5922964],"length":1,"stats":{"Line":13},"fn_name":null},{"line":105,"address":[5926468,5925092,5925054],"length":1,"stats":{"Line":13},"fn_name":null},{"line":106,"address":[5928596,5927220,5927182],"length":1,"stats":{"Line":13},"fn_name":null},{"line":107,"address":[5929310,5929348,5930724],"length":1,"stats":{"Line":13},"fn_name":null},{"line":110,"address":[5931431,5931476,5932740,5931967],"length":1,"stats":{"Line":13},"fn_name":null},{"line":111,"address":[5933422,5934095,5934868,5933460],"length":1,"stats":{"Line":13},"fn_name":null},{"line":112,"address":[5936224,5936997,5935550,5935588],"length":1,"stats":{"Line":13},"fn_name":null},{"line":113,"address":[5938352,5937716,5937678,5939125],"length":1,"stats":{"Line":13},"fn_name":null},{"line":114,"address":[5939806,5940480,5939844,5941253],"length":1,"stats":{"Line":13},"fn_name":null},{"line":115,"address":[5942608,5943381,5941972,5941934],"length":1,"stats":{"Line":13},"fn_name":null},{"line":116,"address":[5944100,5945509,5944062,5944736],"length":1,"stats":{"Line":13},"fn_name":null},{"line":117,"address":[5946228,5947637,5946190,5946864],"length":1,"stats":{"Line":13},"fn_name":null},{"line":118,"address":[5948356,5948318,5948992,5949765],"length":1,"stats":{"Line":13},"fn_name":null},{"line":119,"address":[5951120,5950446,5950484,5951893],"length":1,"stats":{"Line":13},"fn_name":null},{"line":120,"address":[5953200,5952574,5952612,5953973],"length":1,"stats":{"Line":13},"fn_name":null},{"line":121,"address":[5954654,5956101,5954692,5955328],"length":1,"stats":{"Line":13},"fn_name":null},{"line":122,"address":[5957408,5956820,5956782,5958181],"length":1,"stats":{"Line":13},"fn_name":null},{"line":123,"address":[5960309,5959536,5958900,5958862],"length":1,"stats":{"Line":13},"fn_name":null},{"line":124,"address":[5962437,5960990,5961664,5961028],"length":1,"stats":{"Line":13},"fn_name":null},{"line":125,"address":[5963156,5964565,5963118,5963792],"length":1,"stats":{"Line":13},"fn_name":null},{"line":126,"address":[5966693,5965246,5965920,5965284],"length":1,"stats":{"Line":13},"fn_name":null},{"line":127,"address":[5967412,5968821,5968048,5967374],"length":1,"stats":{"Line":13},"fn_name":null},{"line":128,"address":[5970949,5970176,5969540,5969502],"length":1,"stats":{"Line":13},"fn_name":null},{"line":129,"address":[5972256,5971668,5973029,5971630],"length":1,"stats":{"Line":13},"fn_name":null},{"line":130,"address":[5974384,5973748,5973710,5975157],"length":1,"stats":{"Line":13},"fn_name":null},{"line":131,"address":[5977285,5975876,5975838,5976512],"length":1,"stats":{"Line":13},"fn_name":null},{"line":132,"address":[5978544,5977966,5978004,5979317],"length":1,"stats":{"Line":13},"fn_name":null},{"line":138,"address":[5979984,5980022],"length":1,"stats":{"Line":24},"fn_name":"dfa_handles_pathological_case"},{"line":139,"address":[5980654,5980608],"length":1,"stats":{"Line":8},"fn_name":"ones_and_zeroes"},{"line":142,"address":[5980641],"length":1,"stats":{"Line":8},"fn_name":null},{"line":143,"address":[5980669],"length":1,"stats":{"Line":8},"fn_name":null},{"line":144,"address":[5980967,5980877,5980764,5980679],"length":1,"stats":{"Line":24},"fn_name":null},{"line":145,"address":[5980908,5980963],"length":1,"stats":{"Line":16},"fn_name":null},{"line":146,"address":[5980956],"length":1,"stats":{"Line":8},"fn_name":null},{"line":148,"address":[5980939],"length":1,"stats":{"Line":8},"fn_name":null},{"line":151,"address":[5980833],"length":1,"stats":{"Line":8},"fn_name":null},{"line":154,"address":[5980037,5979998],"length":1,"stats":{"Line":16},"fn_name":null},{"line":156,"address":[5980164],"length":1,"stats":{"Line":8},"fn_name":null},{"line":157,"address":[5980184],"length":1,"stats":{"Line":8},"fn_name":null},{"line":158,"address":[5980220,5980251],"length":1,"stats":{"Line":16},"fn_name":null},{"line":159,"address":[5980328],"length":1,"stats":{"Line":8},"fn_name":null},{"line":161,"address":[5980368,5980438,5980463],"length":1,"stats":{"Line":16},"fn_name":null},{"line":165,"address":[5981030,5980992],"length":1,"stats":{"Line":24},"fn_name":"nest_limit_makes_it_parse"}],"covered":88,"coverable":88},{"path":["/","usr","src","regex","tests","flags.rs"],"content":"mat!(match_flag_case, \"(?-u)(?i)abc\", \"ABC\", Some((0, 3)));\nmat!(match_flag_weird_case, \"(?-u)(?i)a(?-i)bc\", \"Abc\", Some((0, 3)));\nmat!(match_flag_weird_case_not, \"(?-u)(?i)a(?-i)bc\", \"ABC\", None);\nmat!(match_flag_case_dotnl, \"(?-u)(?is)a(?u:.)\", \"A\\n\", Some((0, 2)));\nmat!(\n    match_flag_case_dotnl_toggle,\n    \"(?-u)(?is)a(?u:.)(?-is)a(?u:.)\",\n    \"A\\nab\",\n    Some((0, 4))\n);\nmat!(\n    match_flag_case_dotnl_toggle_not,\n    \"(?-u)(?is)a(?u:.)(?-is)a(?u:.)\",\n    \"A\\na\\n\",\n    None\n);\nmat!(\n    match_flag_case_dotnl_toggle_ok,\n    \"(?-u)(?is)a(?u:.)(?-is:a(?u:.))?\",\n    \"A\\na\\n\",\n    Some((0, 2))\n);\nmat!(\n    match_flag_multi,\n    r\"(?-u)(?m)(?:^\\d+$\\n?)+\",\n    \"123\\n456\\n789\",\n    Some((0, 11))\n);\nmat!(match_flag_ungreedy, \"(?U)a+\", \"aa\", Some((0, 1)));\nmat!(match_flag_ungreedy_greedy, \"(?U)a+?\", \"aa\", Some((0, 2)));\nmat!(match_flag_ungreedy_noop, \"(?U)(?-U)a+\", \"aa\", Some((0, 2)));\n","traces":[{"line":1,"address":[5869780,5868436,5868398],"length":1,"stats":{"Line":13},"fn_name":null},{"line":2,"address":[7794836,7794798,7796100],"length":1,"stats":{"Line":13},"fn_name":null},{"line":3,"address":[8423980,8422622,8422660],"length":1,"stats":{"Line":13},"fn_name":null},{"line":4,"address":[7364366,7365780,7364404],"length":1,"stats":{"Line":13},"fn_name":null},{"line":9,"address":[7800820],"length":1,"stats":{"Line":8},"fn_name":null},{"line":15,"address":[5878852],"length":1,"stats":{"Line":8},"fn_name":null},{"line":21,"address":[7370724],"length":1,"stats":{"Line":8},"fn_name":null},{"line":29,"address":[8435300,8436676,8435262],"length":1,"stats":{"Line":13},"fn_name":null},{"line":30,"address":[7377070,7377108,7378484],"length":1,"stats":{"Line":13},"fn_name":null},{"line":31,"address":[7380612,7379198,7379236],"length":1,"stats":{"Line":13},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","usr","src","regex","tests","fowler.rs"],"content":"// DO NOT EDIT. Automatically generated by 'scripts/regex-match-tests.py'\n// on 2019-09-02 11:07:37.849994.\n\n// Tests from basic.dat\nmat!(match_basic_3, r\"abracadabra$\", r\"abracadabracadabra\", Some((7, 18)));\nmat!(match_basic_4, r\"a...b\", r\"abababbb\", Some((2, 7)));\nmat!(match_basic_5, r\"XXXXXX\", r\"..XXXXXX\", Some((2, 8)));\nmat!(match_basic_6, r\"\\)\", r\"()\", Some((1, 2)));\nmat!(match_basic_7, r\"a]\", r\"a]a\", Some((0, 2)));\nmat!(match_basic_9, r\"\\}\", r\"}\", Some((0, 1)));\nmat!(match_basic_10, r\"\\]\", r\"]\", Some((0, 1)));\nmat!(match_basic_12, r\"]\", r\"]\", Some((0, 1)));\nmat!(match_basic_15, r\"^a\", r\"ax\", Some((0, 1)));\nmat!(match_basic_16, r\"\\^a\", r\"a^a\", Some((1, 3)));\nmat!(match_basic_17, r\"a\\^\", r\"a^\", Some((0, 2)));\nmat!(match_basic_18, r\"a$\", r\"aa\", Some((1, 2)));\nmat!(match_basic_19, r\"a\\$\", r\"a$\", Some((0, 2)));\nmat!(match_basic_20, r\"^$\", r\"\", Some((0, 0)));\nmat!(match_basic_21, r\"$^\", r\"\", Some((0, 0)));\nmat!(match_basic_22, r\"a($)\", r\"aa\", Some((1, 2)), Some((2, 2)));\nmat!(match_basic_23, r\"a*(^a)\", r\"aa\", Some((0, 1)), Some((0, 1)));\nmat!(match_basic_24, r\"(..)*(...)*\", r\"a\", Some((0, 0)));\nmat!(match_basic_25, r\"(..)*(...)*\", r\"abcd\", Some((0, 4)), Some((2, 4)));\nmat!(\n    match_basic_26,\n    r\"(ab|a)(bc|c)\",\n    r\"abc\",\n    Some((0, 3)),\n    Some((0, 2)),\n    Some((2, 3))\n);\nmat!(match_basic_27, r\"(ab)c|abc\", r\"abc\", Some((0, 3)), Some((0, 2)));\nmat!(match_basic_28, r\"a{0}b\", r\"ab\", Some((1, 2)));\nmat!(\n    match_basic_29,\n    r\"(a*)(b?)(b+)b{3}\",\n    r\"aaabbbbbbb\",\n    Some((0, 10)),\n    Some((0, 3)),\n    Some((3, 4)),\n    Some((4, 7))\n);\nmat!(\n    match_basic_30,\n    r\"(a*)(b{0,1})(b{1,})b{3}\",\n    r\"aaabbbbbbb\",\n    Some((0, 10)),\n    Some((0, 3)),\n    Some((3, 4)),\n    Some((4, 7))\n);\nmat!(\n    match_basic_32,\n    r\"((a|a)|a)\",\n    r\"a\",\n    Some((0, 1)),\n    Some((0, 1)),\n    Some((0, 1))\n);\nmat!(\n    match_basic_33,\n    r\"(a*)(a|aa)\",\n    r\"aaaa\",\n    Some((0, 4)),\n    Some((0, 3)),\n    Some((3, 4))\n);\nmat!(match_basic_34, r\"a*(a.|aa)\", r\"aaaa\", Some((0, 4)), Some((2, 4)));\nmat!(\n    match_basic_35,\n    r\"a(b)|c(d)|a(e)f\",\n    r\"aef\",\n    Some((0, 3)),\n    None,\n    None,\n    Some((1, 2))\n);\nmat!(match_basic_36, r\"(a|b)?.*\", r\"b\", Some((0, 1)), Some((0, 1)));\nmat!(match_basic_37, r\"(a|b)c|a(b|c)\", r\"ac\", Some((0, 2)), Some((0, 1)));\nmat!(\n    match_basic_38,\n    r\"(a|b)c|a(b|c)\",\n    r\"ab\",\n    Some((0, 2)),\n    None,\n    Some((1, 2))\n);\nmat!(match_basic_39, r\"(a|b)*c|(a|ab)*c\", r\"abc\", Some((0, 3)), Some((1, 2)));\nmat!(match_basic_40, r\"(a|b)*c|(a|ab)*c\", r\"xc\", Some((1, 2)));\nmat!(\n    match_basic_41,\n    r\"(.a|.b).*|.*(.a|.b)\",\n    r\"xa\",\n    Some((0, 2)),\n    Some((0, 2))\n);\nmat!(match_basic_42, r\"a?(ab|ba)ab\", r\"abab\", Some((0, 4)), Some((0, 2)));\nmat!(match_basic_43, r\"a?(ac{0}b|ba)ab\", r\"abab\", Some((0, 4)), Some((0, 2)));\nmat!(match_basic_44, r\"ab|abab\", r\"abbabab\", Some((0, 2)));\nmat!(match_basic_45, r\"aba|bab|bba\", r\"baaabbbaba\", Some((5, 8)));\nmat!(match_basic_46, r\"aba|bab\", r\"baaabbbaba\", Some((6, 9)));\nmat!(\n    match_basic_47,\n    r\"(aa|aaa)*|(a|aaaaa)\",\n    r\"aa\",\n    Some((0, 2)),\n    Some((0, 2))\n);\nmat!(\n    match_basic_48,\n    r\"(a.|.a.)*|(a|.a...)\",\n    r\"aa\",\n    Some((0, 2)),\n    Some((0, 2))\n);\nmat!(match_basic_49, r\"ab|a\", r\"xabc\", Some((1, 3)));\nmat!(match_basic_50, r\"ab|a\", r\"xxabc\", Some((2, 4)));\nmat!(\n    match_basic_51,\n    r\"(?i)(?-u)(Ab|cD)*\",\n    r\"aBcD\",\n    Some((0, 4)),\n    Some((2, 4))\n);\nmat!(match_basic_52, r\"[^-]\", r\"--a\", Some((2, 3)));\nmat!(match_basic_53, r\"[a-]*\", r\"--a\", Some((0, 3)));\nmat!(match_basic_54, r\"[a-m-]*\", r\"--amoma--\", Some((0, 4)));\nmat!(\n    match_basic_55,\n    r\":::1:::0:|:::1:1:0:\",\n    r\":::0:::1:::1:::0:\",\n    Some((8, 17))\n);\nmat!(\n    match_basic_56,\n    r\":::1:::0:|:::1:1:1:\",\n    r\":::0:::1:::1:::0:\",\n    Some((8, 17))\n);\nmat!(match_basic_57, r\"[[:upper:]]\", r\"A\", Some((0, 1)));\nmat!(match_basic_58, r\"[[:lower:]]+\", r\"`az{\", Some((1, 3)));\nmat!(match_basic_59, r\"[[:upper:]]+\", r\"@AZ[\", Some((1, 3)));\nmat!(\n    match_basic_65,\n    r\"\n\",\n    r\"\n\",\n    Some((0, 1))\n);\nmat!(\n    match_basic_66,\n    r\"\n\",\n    r\"\n\",\n    Some((0, 1))\n);\nmat!(\n    match_basic_67,\n    r\"[^a]\",\n    r\"\n\",\n    Some((0, 1))\n);\nmat!(\n    match_basic_68,\n    r\"\na\",\n    r\"\na\",\n    Some((0, 2))\n);\nmat!(\n    match_basic_69,\n    r\"(a)(b)(c)\",\n    r\"abc\",\n    Some((0, 3)),\n    Some((0, 1)),\n    Some((1, 2)),\n    Some((2, 3))\n);\nmat!(match_basic_70, r\"xxx\", r\"xxx\", Some((0, 3)));\nmat!(\n    match_basic_71,\n    r\"(^|[ (,;])((([Ff]eb[^ ]* *|0*2/|\\* */?)0*[6-7]))([^0-9]|$)\",\n    r\"feb 6,\",\n    Some((0, 6))\n);\nmat!(\n    match_basic_72,\n    r\"(^|[ (,;])((([Ff]eb[^ ]* *|0*2/|\\* */?)0*[6-7]))([^0-9]|$)\",\n    r\"2/7\",\n    Some((0, 3))\n);\nmat!(\n    match_basic_73,\n    r\"(^|[ (,;])((([Ff]eb[^ ]* *|0*2/|\\* */?)0*[6-7]))([^0-9]|$)\",\n    r\"feb 1,Feb 6\",\n    Some((5, 11))\n);\nmat!(\n    match_basic_74,\n    r\"((((((((((((((((((((((((((((((x))))))))))))))))))))))))))))))\",\n    r\"x\",\n    Some((0, 1)),\n    Some((0, 1)),\n    Some((0, 1))\n);\nmat!(\n    match_basic_75,\n    r\"((((((((((((((((((((((((((((((x))))))))))))))))))))))))))))))*\",\n    r\"xx\",\n    Some((0, 2)),\n    Some((1, 2)),\n    Some((1, 2))\n);\nmat!(\n    match_basic_76,\n    r\"a?(ab|ba)*\",\n    r\"ababababababababababababababababababababababababababababababababababababababababa\",\n    Some((0, 81)),\n    Some((79, 81))\n);\nmat!(\n    match_basic_77,\n    r\"abaa|abbaa|abbbaa|abbbbaa\",\n    r\"ababbabbbabbbabbbbabbbbaa\",\n    Some((18, 25))\n);\nmat!(\n    match_basic_78,\n    r\"abaa|abbaa|abbbaa|abbbbaa\",\n    r\"ababbabbbabbbabbbbabaa\",\n    Some((18, 22))\n);\nmat!(\n    match_basic_79,\n    r\"aaac|aabc|abac|abbc|baac|babc|bbac|bbbc\",\n    r\"baaabbbabac\",\n    Some((7, 11))\n);\nmat!(match_basic_80, r\".*\", r\"\u0001\", Some((0, 2)));\nmat!(\n    match_basic_81,\n    r\"aaaa|bbbb|cccc|ddddd|eeeeee|fffffff|gggg|hhhh|iiiii|jjjjj|kkkkk|llll\",\n    r\"XaaaXbbbXcccXdddXeeeXfffXgggXhhhXiiiXjjjXkkkXlllXcbaXaaaa\",\n    Some((53, 57))\n);\nmat!(match_basic_83, r\"a*a*a*a*a*b\", r\"aaaaaaaaab\", Some((0, 10)));\nmat!(match_basic_84, r\"^\", r\"\", Some((0, 0)));\nmat!(match_basic_85, r\"$\", r\"\", Some((0, 0)));\nmat!(match_basic_86, r\"^$\", r\"\", Some((0, 0)));\nmat!(match_basic_87, r\"^a$\", r\"a\", Some((0, 1)));\nmat!(match_basic_88, r\"abc\", r\"abc\", Some((0, 3)));\nmat!(match_basic_89, r\"abc\", r\"xabcy\", Some((1, 4)));\nmat!(match_basic_90, r\"abc\", r\"ababc\", Some((2, 5)));\nmat!(match_basic_91, r\"ab*c\", r\"abc\", Some((0, 3)));\nmat!(match_basic_92, r\"ab*bc\", r\"abc\", Some((0, 3)));\nmat!(match_basic_93, r\"ab*bc\", r\"abbc\", Some((0, 4)));\nmat!(match_basic_94, r\"ab*bc\", r\"abbbbc\", Some((0, 6)));\nmat!(match_basic_95, r\"ab+bc\", r\"abbc\", Some((0, 4)));\nmat!(match_basic_96, r\"ab+bc\", r\"abbbbc\", Some((0, 6)));\nmat!(match_basic_97, r\"ab?bc\", r\"abbc\", Some((0, 4)));\nmat!(match_basic_98, r\"ab?bc\", r\"abc\", Some((0, 3)));\nmat!(match_basic_99, r\"ab?c\", r\"abc\", Some((0, 3)));\nmat!(match_basic_100, r\"^abc$\", r\"abc\", Some((0, 3)));\nmat!(match_basic_101, r\"^abc\", r\"abcc\", Some((0, 3)));\nmat!(match_basic_102, r\"abc$\", r\"aabc\", Some((1, 4)));\nmat!(match_basic_103, r\"^\", r\"abc\", Some((0, 0)));\nmat!(match_basic_104, r\"$\", r\"abc\", Some((3, 3)));\nmat!(match_basic_105, r\"a.c\", r\"abc\", Some((0, 3)));\nmat!(match_basic_106, r\"a.c\", r\"axc\", Some((0, 3)));\nmat!(match_basic_107, r\"a.*c\", r\"axyzc\", Some((0, 5)));\nmat!(match_basic_108, r\"a[bc]d\", r\"abd\", Some((0, 3)));\nmat!(match_basic_109, r\"a[b-d]e\", r\"ace\", Some((0, 3)));\nmat!(match_basic_110, r\"a[b-d]\", r\"aac\", Some((1, 3)));\nmat!(match_basic_111, r\"a[-b]\", r\"a-\", Some((0, 2)));\nmat!(match_basic_112, r\"a[b-]\", r\"a-\", Some((0, 2)));\nmat!(match_basic_113, r\"a]\", r\"a]\", Some((0, 2)));\nmat!(match_basic_114, r\"a[]]b\", r\"a]b\", Some((0, 3)));\nmat!(match_basic_115, r\"a[^bc]d\", r\"aed\", Some((0, 3)));\nmat!(match_basic_116, r\"a[^-b]c\", r\"adc\", Some((0, 3)));\nmat!(match_basic_117, r\"a[^]b]c\", r\"adc\", Some((0, 3)));\nmat!(match_basic_118, r\"ab|cd\", r\"abc\", Some((0, 2)));\nmat!(match_basic_119, r\"ab|cd\", r\"abcd\", Some((0, 2)));\nmat!(match_basic_120, r\"a\\(b\", r\"a(b\", Some((0, 3)));\nmat!(match_basic_121, r\"a\\(*b\", r\"ab\", Some((0, 2)));\nmat!(match_basic_122, r\"a\\(*b\", r\"a((b\", Some((0, 4)));\nmat!(\n    match_basic_123,\n    r\"((a))\",\n    r\"abc\",\n    Some((0, 1)),\n    Some((0, 1)),\n    Some((0, 1))\n);\nmat!(\n    match_basic_124,\n    r\"(a)b(c)\",\n    r\"abc\",\n    Some((0, 3)),\n    Some((0, 1)),\n    Some((2, 3))\n);\nmat!(match_basic_125, r\"a+b+c\", r\"aabbabc\", Some((4, 7)));\nmat!(match_basic_126, r\"a*\", r\"aaa\", Some((0, 3)));\nmat!(match_basic_128, r\"(a*)*\", r\"-\", Some((0, 0)), None);\nmat!(match_basic_129, r\"(a*)+\", r\"-\", Some((0, 0)), Some((0, 0)));\nmat!(match_basic_131, r\"(a*|b)*\", r\"-\", Some((0, 0)), None);\nmat!(match_basic_132, r\"(a+|b)*\", r\"ab\", Some((0, 2)), Some((1, 2)));\nmat!(match_basic_133, r\"(a+|b)+\", r\"ab\", Some((0, 2)), Some((1, 2)));\nmat!(match_basic_134, r\"(a+|b)?\", r\"ab\", Some((0, 1)), Some((0, 1)));\nmat!(match_basic_135, r\"[^ab]*\", r\"cde\", Some((0, 3)));\nmat!(match_basic_137, r\"(^)*\", r\"-\", Some((0, 0)), None);\nmat!(match_basic_138, r\"a*\", r\"\", Some((0, 0)));\nmat!(match_basic_139, r\"([abc])*d\", r\"abbbcd\", Some((0, 6)), Some((4, 5)));\nmat!(match_basic_140, r\"([abc])*bcd\", r\"abcd\", Some((0, 4)), Some((0, 1)));\nmat!(match_basic_141, r\"a|b|c|d|e\", r\"e\", Some((0, 1)));\nmat!(match_basic_142, r\"(a|b|c|d|e)f\", r\"ef\", Some((0, 2)), Some((0, 1)));\nmat!(match_basic_144, r\"((a*|b))*\", r\"-\", Some((0, 0)), None, None);\nmat!(match_basic_145, r\"abcd*efg\", r\"abcdefg\", Some((0, 7)));\nmat!(match_basic_146, r\"ab*\", r\"xabyabbbz\", Some((1, 3)));\nmat!(match_basic_147, r\"ab*\", r\"xayabbbz\", Some((1, 2)));\nmat!(match_basic_148, r\"(ab|cd)e\", r\"abcde\", Some((2, 5)), Some((2, 4)));\nmat!(match_basic_149, r\"[abhgefdc]ij\", r\"hij\", Some((0, 3)));\nmat!(match_basic_150, r\"(a|b)c*d\", r\"abcd\", Some((1, 4)), Some((1, 2)));\nmat!(match_basic_151, r\"(ab|ab*)bc\", r\"abc\", Some((0, 3)), Some((0, 1)));\nmat!(match_basic_152, r\"a([bc]*)c*\", r\"abc\", Some((0, 3)), Some((1, 3)));\nmat!(\n    match_basic_153,\n    r\"a([bc]*)(c*d)\",\n    r\"abcd\",\n    Some((0, 4)),\n    Some((1, 3)),\n    Some((3, 4))\n);\nmat!(\n    match_basic_154,\n    r\"a([bc]+)(c*d)\",\n    r\"abcd\",\n    Some((0, 4)),\n    Some((1, 3)),\n    Some((3, 4))\n);\nmat!(\n    match_basic_155,\n    r\"a([bc]*)(c+d)\",\n    r\"abcd\",\n    Some((0, 4)),\n    Some((1, 2)),\n    Some((2, 4))\n);\nmat!(match_basic_156, r\"a[bcd]*dcdcde\", r\"adcdcde\", Some((0, 7)));\nmat!(match_basic_157, r\"(ab|a)b*c\", r\"abc\", Some((0, 3)), Some((0, 2)));\nmat!(\n    match_basic_158,\n    r\"((a)(b)c)(d)\",\n    r\"abcd\",\n    Some((0, 4)),\n    Some((0, 3)),\n    Some((0, 1)),\n    Some((1, 2)),\n    Some((3, 4))\n);\nmat!(match_basic_159, r\"[A-Za-z_][A-Za-z0-9_]*\", r\"alpha\", Some((0, 5)));\nmat!(match_basic_160, r\"^a(bc+|b[eh])g|.h$\", r\"abh\", Some((1, 3)));\nmat!(\n    match_basic_161,\n    r\"(bc+d$|ef*g.|h?i(j|k))\",\n    r\"effgz\",\n    Some((0, 5)),\n    Some((0, 5))\n);\nmat!(\n    match_basic_162,\n    r\"(bc+d$|ef*g.|h?i(j|k))\",\n    r\"ij\",\n    Some((0, 2)),\n    Some((0, 2)),\n    Some((1, 2))\n);\nmat!(\n    match_basic_163,\n    r\"(bc+d$|ef*g.|h?i(j|k))\",\n    r\"reffgz\",\n    Some((1, 6)),\n    Some((1, 6))\n);\nmat!(\n    match_basic_164,\n    r\"(((((((((a)))))))))\",\n    r\"a\",\n    Some((0, 1)),\n    Some((0, 1)),\n    Some((0, 1)),\n    Some((0, 1)),\n    Some((0, 1)),\n    Some((0, 1)),\n    Some((0, 1)),\n    Some((0, 1)),\n    Some((0, 1)),\n    Some((0, 1))\n);\nmat!(\n    match_basic_165,\n    r\"multiple words\",\n    r\"multiple words yeah\",\n    Some((0, 14))\n);\nmat!(\n    match_basic_166,\n    r\"(.*)c(.*)\",\n    r\"abcde\",\n    Some((0, 5)),\n    Some((0, 2)),\n    Some((3, 5))\n);\nmat!(match_basic_167, r\"abcd\", r\"abcd\", Some((0, 4)));\nmat!(match_basic_168, r\"a(bc)d\", r\"abcd\", Some((0, 4)), Some((1, 3)));\nmat!(match_basic_169, r\"a[\u0001-\u0003]?c\", r\"a\u0002c\", Some((0, 3)));\nmat!(\n    match_basic_170,\n    r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\",\n    r\"Muammar Qaddafi\",\n    Some((0, 15)),\n    None,\n    Some((10, 12))\n);\nmat!(\n    match_basic_171,\n    r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\",\n    r\"Mo'ammar Gadhafi\",\n    Some((0, 16)),\n    None,\n    Some((11, 13))\n);\nmat!(\n    match_basic_172,\n    r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\",\n    r\"Muammar Kaddafi\",\n    Some((0, 15)),\n    None,\n    Some((10, 12))\n);\nmat!(\n    match_basic_173,\n    r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\",\n    r\"Muammar Qadhafi\",\n    Some((0, 15)),\n    None,\n    Some((10, 12))\n);\nmat!(\n    match_basic_174,\n    r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\",\n    r\"Muammar Gadafi\",\n    Some((0, 14)),\n    None,\n    Some((10, 11))\n);\nmat!(\n    match_basic_175,\n    r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\",\n    r\"Mu'ammar Qadafi\",\n    Some((0, 15)),\n    None,\n    Some((11, 12))\n);\nmat!(\n    match_basic_176,\n    r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\",\n    r\"Moamar Gaddafi\",\n    Some((0, 14)),\n    None,\n    Some((9, 11))\n);\nmat!(\n    match_basic_177,\n    r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\",\n    r\"Mu'ammar Qadhdhafi\",\n    Some((0, 18)),\n    None,\n    Some((13, 15))\n);\nmat!(\n    match_basic_178,\n    r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\",\n    r\"Muammar Khaddafi\",\n    Some((0, 16)),\n    None,\n    Some((11, 13))\n);\nmat!(\n    match_basic_179,\n    r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\",\n    r\"Muammar Ghaddafy\",\n    Some((0, 16)),\n    None,\n    Some((11, 13))\n);\nmat!(\n    match_basic_180,\n    r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\",\n    r\"Muammar Ghadafi\",\n    Some((0, 15)),\n    None,\n    Some((11, 12))\n);\nmat!(\n    match_basic_181,\n    r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\",\n    r\"Muammar Ghaddafi\",\n    Some((0, 16)),\n    None,\n    Some((11, 13))\n);\nmat!(\n    match_basic_182,\n    r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\",\n    r\"Muamar Kaddafi\",\n    Some((0, 14)),\n    None,\n    Some((9, 11))\n);\nmat!(\n    match_basic_183,\n    r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\",\n    r\"Muammar Quathafi\",\n    Some((0, 16)),\n    None,\n    Some((11, 13))\n);\nmat!(\n    match_basic_184,\n    r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\",\n    r\"Muammar Gheddafi\",\n    Some((0, 16)),\n    None,\n    Some((11, 13))\n);\nmat!(\n    match_basic_185,\n    r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\",\n    r\"Moammar Khadafy\",\n    Some((0, 15)),\n    None,\n    Some((11, 12))\n);\nmat!(\n    match_basic_186,\n    r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\",\n    r\"Moammar Qudhafi\",\n    Some((0, 15)),\n    None,\n    Some((10, 12))\n);\nmat!(match_basic_187, r\"a+(b|c)*d+\", r\"aabcdd\", Some((0, 6)), Some((3, 4)));\nmat!(match_basic_188, r\"^.+$\", r\"vivi\", Some((0, 4)));\nmat!(match_basic_189, r\"^(.+)$\", r\"vivi\", Some((0, 4)), Some((0, 4)));\nmat!(\n    match_basic_190,\n    r\"^([^!.]+).att.com!(.+)$\",\n    r\"gryphon.att.com!eby\",\n    Some((0, 19)),\n    Some((0, 7)),\n    Some((16, 19))\n);\nmat!(\n    match_basic_191,\n    r\"^([^!]+!)?([^!]+)$\",\n    r\"bas\",\n    Some((0, 3)),\n    None,\n    Some((0, 3))\n);\nmat!(\n    match_basic_192,\n    r\"^([^!]+!)?([^!]+)$\",\n    r\"bar!bas\",\n    Some((0, 7)),\n    Some((0, 4)),\n    Some((4, 7))\n);\nmat!(\n    match_basic_193,\n    r\"^([^!]+!)?([^!]+)$\",\n    r\"foo!bas\",\n    Some((0, 7)),\n    Some((0, 4)),\n    Some((4, 7))\n);\nmat!(\n    match_basic_194,\n    r\"^.+!([^!]+!)([^!]+)$\",\n    r\"foo!bar!bas\",\n    Some((0, 11)),\n    Some((4, 8)),\n    Some((8, 11))\n);\nmat!(\n    match_basic_195,\n    r\"((foo)|(bar))!bas\",\n    r\"bar!bas\",\n    Some((0, 7)),\n    Some((0, 3)),\n    None,\n    Some((0, 3))\n);\nmat!(\n    match_basic_196,\n    r\"((foo)|(bar))!bas\",\n    r\"foo!bar!bas\",\n    Some((4, 11)),\n    Some((4, 7)),\n    None,\n    Some((4, 7))\n);\nmat!(\n    match_basic_197,\n    r\"((foo)|(bar))!bas\",\n    r\"foo!bas\",\n    Some((0, 7)),\n    Some((0, 3)),\n    Some((0, 3))\n);\nmat!(\n    match_basic_198,\n    r\"((foo)|bar)!bas\",\n    r\"bar!bas\",\n    Some((0, 7)),\n    Some((0, 3))\n);\nmat!(\n    match_basic_199,\n    r\"((foo)|bar)!bas\",\n    r\"foo!bar!bas\",\n    Some((4, 11)),\n    Some((4, 7))\n);\nmat!(\n    match_basic_200,\n    r\"((foo)|bar)!bas\",\n    r\"foo!bas\",\n    Some((0, 7)),\n    Some((0, 3)),\n    Some((0, 3))\n);\nmat!(\n    match_basic_201,\n    r\"(foo|(bar))!bas\",\n    r\"bar!bas\",\n    Some((0, 7)),\n    Some((0, 3)),\n    Some((0, 3))\n);\nmat!(\n    match_basic_202,\n    r\"(foo|(bar))!bas\",\n    r\"foo!bar!bas\",\n    Some((4, 11)),\n    Some((4, 7)),\n    Some((4, 7))\n);\nmat!(\n    match_basic_203,\n    r\"(foo|(bar))!bas\",\n    r\"foo!bas\",\n    Some((0, 7)),\n    Some((0, 3))\n);\nmat!(\n    match_basic_204,\n    r\"(foo|bar)!bas\",\n    r\"bar!bas\",\n    Some((0, 7)),\n    Some((0, 3))\n);\nmat!(\n    match_basic_205,\n    r\"(foo|bar)!bas\",\n    r\"foo!bar!bas\",\n    Some((4, 11)),\n    Some((4, 7))\n);\nmat!(\n    match_basic_206,\n    r\"(foo|bar)!bas\",\n    r\"foo!bas\",\n    Some((0, 7)),\n    Some((0, 3))\n);\nmat!(\n    match_basic_207,\n    r\"^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$\",\n    r\"foo!bar!bas\",\n    Some((0, 11)),\n    Some((0, 11)),\n    None,\n    None,\n    Some((4, 8)),\n    Some((8, 11))\n);\nmat!(\n    match_basic_208,\n    r\"^([^!]+!)?([^!]+)$|^.+!([^!]+!)([^!]+)$\",\n    r\"bas\",\n    Some((0, 3)),\n    None,\n    Some((0, 3))\n);\nmat!(\n    match_basic_209,\n    r\"^([^!]+!)?([^!]+)$|^.+!([^!]+!)([^!]+)$\",\n    r\"bar!bas\",\n    Some((0, 7)),\n    Some((0, 4)),\n    Some((4, 7))\n);\nmat!(\n    match_basic_210,\n    r\"^([^!]+!)?([^!]+)$|^.+!([^!]+!)([^!]+)$\",\n    r\"foo!bar!bas\",\n    Some((0, 11)),\n    None,\n    None,\n    Some((4, 8)),\n    Some((8, 11))\n);\nmat!(\n    match_basic_211,\n    r\"^([^!]+!)?([^!]+)$|^.+!([^!]+!)([^!]+)$\",\n    r\"foo!bas\",\n    Some((0, 7)),\n    Some((0, 4)),\n    Some((4, 7))\n);\nmat!(\n    match_basic_212,\n    r\"^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$\",\n    r\"bas\",\n    Some((0, 3)),\n    Some((0, 3)),\n    None,\n    Some((0, 3))\n);\nmat!(\n    match_basic_213,\n    r\"^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$\",\n    r\"bar!bas\",\n    Some((0, 7)),\n    Some((0, 7)),\n    Some((0, 4)),\n    Some((4, 7))\n);\nmat!(\n    match_basic_214,\n    r\"^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$\",\n    r\"foo!bar!bas\",\n    Some((0, 11)),\n    Some((0, 11)),\n    None,\n    None,\n    Some((4, 8)),\n    Some((8, 11))\n);\nmat!(\n    match_basic_215,\n    r\"^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$\",\n    r\"foo!bas\",\n    Some((0, 7)),\n    Some((0, 7)),\n    Some((0, 4)),\n    Some((4, 7))\n);\nmat!(match_basic_216, r\".*(/XXX).*\", r\"/XXX\", Some((0, 4)), Some((0, 4)));\nmat!(match_basic_217, r\".*(\\\\XXX).*\", r\"\\XXX\", Some((0, 4)), Some((0, 4)));\nmat!(match_basic_218, r\"\\\\XXX\", r\"\\XXX\", Some((0, 4)));\nmat!(match_basic_219, r\".*(/000).*\", r\"/000\", Some((0, 4)), Some((0, 4)));\nmat!(match_basic_220, r\".*(\\\\000).*\", r\"\\000\", Some((0, 4)), Some((0, 4)));\nmat!(match_basic_221, r\"\\\\000\", r\"\\000\", Some((0, 4)));\n\n// Tests from nullsubexpr.dat\nmat!(match_nullsubexpr_3, r\"(a*)*\", r\"a\", Some((0, 1)), Some((0, 1)));\nmat!(match_nullsubexpr_5, r\"(a*)*\", r\"x\", Some((0, 0)), None);\nmat!(match_nullsubexpr_6, r\"(a*)*\", r\"aaaaaa\", Some((0, 6)), Some((0, 6)));\nmat!(match_nullsubexpr_7, r\"(a*)*\", r\"aaaaaax\", Some((0, 6)), Some((0, 6)));\nmat!(match_nullsubexpr_8, r\"(a*)+\", r\"a\", Some((0, 1)), Some((0, 1)));\nmat!(match_nullsubexpr_9, r\"(a*)+\", r\"x\", Some((0, 0)), Some((0, 0)));\nmat!(match_nullsubexpr_10, r\"(a*)+\", r\"aaaaaa\", Some((0, 6)), Some((0, 6)));\nmat!(match_nullsubexpr_11, r\"(a*)+\", r\"aaaaaax\", Some((0, 6)), Some((0, 6)));\nmat!(match_nullsubexpr_12, r\"(a+)*\", r\"a\", Some((0, 1)), Some((0, 1)));\nmat!(match_nullsubexpr_13, r\"(a+)*\", r\"x\", Some((0, 0)));\nmat!(match_nullsubexpr_14, r\"(a+)*\", r\"aaaaaa\", Some((0, 6)), Some((0, 6)));\nmat!(match_nullsubexpr_15, r\"(a+)*\", r\"aaaaaax\", Some((0, 6)), Some((0, 6)));\nmat!(match_nullsubexpr_16, r\"(a+)+\", r\"a\", Some((0, 1)), Some((0, 1)));\nmat!(match_nullsubexpr_17, r\"(a+)+\", r\"x\", None);\nmat!(match_nullsubexpr_18, r\"(a+)+\", r\"aaaaaa\", Some((0, 6)), Some((0, 6)));\nmat!(match_nullsubexpr_19, r\"(a+)+\", r\"aaaaaax\", Some((0, 6)), Some((0, 6)));\nmat!(match_nullsubexpr_21, r\"([a]*)*\", r\"a\", Some((0, 1)), Some((0, 1)));\nmat!(match_nullsubexpr_23, r\"([a]*)*\", r\"x\", Some((0, 0)), None);\nmat!(match_nullsubexpr_24, r\"([a]*)*\", r\"aaaaaa\", Some((0, 6)), Some((0, 6)));\nmat!(match_nullsubexpr_25, r\"([a]*)*\", r\"aaaaaax\", Some((0, 6)), Some((0, 6)));\nmat!(match_nullsubexpr_26, r\"([a]*)+\", r\"a\", Some((0, 1)), Some((0, 1)));\nmat!(match_nullsubexpr_27, r\"([a]*)+\", r\"x\", Some((0, 0)), Some((0, 0)));\nmat!(match_nullsubexpr_28, r\"([a]*)+\", r\"aaaaaa\", Some((0, 6)), Some((0, 6)));\nmat!(match_nullsubexpr_29, r\"([a]*)+\", r\"aaaaaax\", Some((0, 6)), Some((0, 6)));\nmat!(match_nullsubexpr_30, r\"([^b]*)*\", r\"a\", Some((0, 1)), Some((0, 1)));\nmat!(match_nullsubexpr_32, r\"([^b]*)*\", r\"b\", Some((0, 0)), None);\nmat!(match_nullsubexpr_33, r\"([^b]*)*\", r\"aaaaaa\", Some((0, 6)), Some((0, 6)));\nmat!(\n    match_nullsubexpr_34,\n    r\"([^b]*)*\",\n    r\"aaaaaab\",\n    Some((0, 6)),\n    Some((0, 6))\n);\nmat!(match_nullsubexpr_35, r\"([ab]*)*\", r\"a\", Some((0, 1)), Some((0, 1)));\nmat!(match_nullsubexpr_36, r\"([ab]*)*\", r\"aaaaaa\", Some((0, 6)), Some((0, 6)));\nmat!(match_nullsubexpr_37, r\"([ab]*)*\", r\"ababab\", Some((0, 6)), Some((0, 6)));\nmat!(match_nullsubexpr_38, r\"([ab]*)*\", r\"bababa\", Some((0, 6)), Some((0, 6)));\nmat!(match_nullsubexpr_39, r\"([ab]*)*\", r\"b\", Some((0, 1)), Some((0, 1)));\nmat!(match_nullsubexpr_40, r\"([ab]*)*\", r\"bbbbbb\", Some((0, 6)), Some((0, 6)));\nmat!(\n    match_nullsubexpr_41,\n    r\"([ab]*)*\",\n    r\"aaaabcde\",\n    Some((0, 5)),\n    Some((0, 5))\n);\nmat!(match_nullsubexpr_42, r\"([^a]*)*\", r\"b\", Some((0, 1)), Some((0, 1)));\nmat!(match_nullsubexpr_43, r\"([^a]*)*\", r\"bbbbbb\", Some((0, 6)), Some((0, 6)));\nmat!(match_nullsubexpr_45, r\"([^a]*)*\", r\"aaaaaa\", Some((0, 0)), None);\nmat!(\n    match_nullsubexpr_46,\n    r\"([^ab]*)*\",\n    r\"ccccxx\",\n    Some((0, 6)),\n    Some((0, 6))\n);\nmat!(match_nullsubexpr_48, r\"([^ab]*)*\", r\"ababab\", Some((0, 0)), None);\nmat!(\n    match_nullsubexpr_50,\n    r\"((z)+|a)*\",\n    r\"zabcde\",\n    Some((0, 2)),\n    Some((1, 2))\n);\nmat!(\n    match_nullsubexpr_69,\n    r\"(a*)*(x)\",\n    r\"x\",\n    Some((0, 1)),\n    None,\n    Some((0, 1))\n);\nmat!(\n    match_nullsubexpr_70,\n    r\"(a*)*(x)\",\n    r\"ax\",\n    Some((0, 2)),\n    Some((0, 1)),\n    Some((1, 2))\n);\nmat!(\n    match_nullsubexpr_71,\n    r\"(a*)*(x)\",\n    r\"axa\",\n    Some((0, 2)),\n    Some((0, 1)),\n    Some((1, 2))\n);\nmat!(\n    match_nullsubexpr_73,\n    r\"(a*)+(x)\",\n    r\"x\",\n    Some((0, 1)),\n    Some((0, 0)),\n    Some((0, 1))\n);\nmat!(\n    match_nullsubexpr_74,\n    r\"(a*)+(x)\",\n    r\"ax\",\n    Some((0, 2)),\n    Some((0, 1)),\n    Some((1, 2))\n);\nmat!(\n    match_nullsubexpr_75,\n    r\"(a*)+(x)\",\n    r\"axa\",\n    Some((0, 2)),\n    Some((0, 1)),\n    Some((1, 2))\n);\nmat!(\n    match_nullsubexpr_77,\n    r\"(a*){2}(x)\",\n    r\"x\",\n    Some((0, 1)),\n    Some((0, 0)),\n    Some((0, 1))\n);\nmat!(\n    match_nullsubexpr_78,\n    r\"(a*){2}(x)\",\n    r\"ax\",\n    Some((0, 2)),\n    Some((1, 1)),\n    Some((1, 2))\n);\nmat!(\n    match_nullsubexpr_79,\n    r\"(a*){2}(x)\",\n    r\"axa\",\n    Some((0, 2)),\n    Some((1, 1)),\n    Some((1, 2))\n);\n\n// Tests from repetition.dat\nmat!(match_repetition_10, r\"((..)|(.))\", r\"\", None);\nmat!(match_repetition_11, r\"((..)|(.))((..)|(.))\", r\"\", None);\nmat!(match_repetition_12, r\"((..)|(.))((..)|(.))((..)|(.))\", r\"\", None);\nmat!(match_repetition_14, r\"((..)|(.)){1}\", r\"\", None);\nmat!(match_repetition_15, r\"((..)|(.)){2}\", r\"\", None);\nmat!(match_repetition_16, r\"((..)|(.)){3}\", r\"\", None);\nmat!(match_repetition_18, r\"((..)|(.))*\", r\"\", Some((0, 0)));\nmat!(\n    match_repetition_20,\n    r\"((..)|(.))\",\n    r\"a\",\n    Some((0, 1)),\n    Some((0, 1)),\n    None,\n    Some((0, 1))\n);\nmat!(match_repetition_21, r\"((..)|(.))((..)|(.))\", r\"a\", None);\nmat!(match_repetition_22, r\"((..)|(.))((..)|(.))((..)|(.))\", r\"a\", None);\nmat!(\n    match_repetition_24,\n    r\"((..)|(.)){1}\",\n    r\"a\",\n    Some((0, 1)),\n    Some((0, 1)),\n    None,\n    Some((0, 1))\n);\nmat!(match_repetition_25, r\"((..)|(.)){2}\", r\"a\", None);\nmat!(match_repetition_26, r\"((..)|(.)){3}\", r\"a\", None);\nmat!(\n    match_repetition_28,\n    r\"((..)|(.))*\",\n    r\"a\",\n    Some((0, 1)),\n    Some((0, 1)),\n    None,\n    Some((0, 1))\n);\nmat!(\n    match_repetition_30,\n    r\"((..)|(.))\",\n    r\"aa\",\n    Some((0, 2)),\n    Some((0, 2)),\n    Some((0, 2)),\n    None\n);\nmat!(\n    match_repetition_31,\n    r\"((..)|(.))((..)|(.))\",\n    r\"aa\",\n    Some((0, 2)),\n    Some((0, 1)),\n    None,\n    Some((0, 1)),\n    Some((1, 2)),\n    None,\n    Some((1, 2))\n);\nmat!(match_repetition_32, r\"((..)|(.))((..)|(.))((..)|(.))\", r\"aa\", None);\nmat!(\n    match_repetition_34,\n    r\"((..)|(.)){1}\",\n    r\"aa\",\n    Some((0, 2)),\n    Some((0, 2)),\n    Some((0, 2)),\n    None\n);\nmat!(\n    match_repetition_35,\n    r\"((..)|(.)){2}\",\n    r\"aa\",\n    Some((0, 2)),\n    Some((1, 2)),\n    None,\n    Some((1, 2))\n);\nmat!(match_repetition_36, r\"((..)|(.)){3}\", r\"aa\", None);\nmat!(\n    match_repetition_38,\n    r\"((..)|(.))*\",\n    r\"aa\",\n    Some((0, 2)),\n    Some((0, 2)),\n    Some((0, 2)),\n    None\n);\nmat!(\n    match_repetition_40,\n    r\"((..)|(.))\",\n    r\"aaa\",\n    Some((0, 2)),\n    Some((0, 2)),\n    Some((0, 2)),\n    None\n);\nmat!(\n    match_repetition_41,\n    r\"((..)|(.))((..)|(.))\",\n    r\"aaa\",\n    Some((0, 3)),\n    Some((0, 2)),\n    Some((0, 2)),\n    None,\n    Some((2, 3)),\n    None,\n    Some((2, 3))\n);\nmat!(\n    match_repetition_42,\n    r\"((..)|(.))((..)|(.))((..)|(.))\",\n    r\"aaa\",\n    Some((0, 3)),\n    Some((0, 1)),\n    None,\n    Some((0, 1)),\n    Some((1, 2)),\n    None,\n    Some((1, 2)),\n    Some((2, 3)),\n    None,\n    Some((2, 3))\n);\nmat!(\n    match_repetition_44,\n    r\"((..)|(.)){1}\",\n    r\"aaa\",\n    Some((0, 2)),\n    Some((0, 2)),\n    Some((0, 2)),\n    None\n);\nmat!(\n    match_repetition_46,\n    r\"((..)|(.)){2}\",\n    r\"aaa\",\n    Some((0, 3)),\n    Some((2, 3)),\n    Some((0, 2)),\n    Some((2, 3))\n);\nmat!(\n    match_repetition_47,\n    r\"((..)|(.)){3}\",\n    r\"aaa\",\n    Some((0, 3)),\n    Some((2, 3)),\n    None,\n    Some((2, 3))\n);\nmat!(\n    match_repetition_50,\n    r\"((..)|(.))*\",\n    r\"aaa\",\n    Some((0, 3)),\n    Some((2, 3)),\n    Some((0, 2)),\n    Some((2, 3))\n);\nmat!(\n    match_repetition_52,\n    r\"((..)|(.))\",\n    r\"aaaa\",\n    Some((0, 2)),\n    Some((0, 2)),\n    Some((0, 2)),\n    None\n);\nmat!(\n    match_repetition_53,\n    r\"((..)|(.))((..)|(.))\",\n    r\"aaaa\",\n    Some((0, 4)),\n    Some((0, 2)),\n    Some((0, 2)),\n    None,\n    Some((2, 4)),\n    Some((2, 4)),\n    None\n);\nmat!(\n    match_repetition_54,\n    r\"((..)|(.))((..)|(.))((..)|(.))\",\n    r\"aaaa\",\n    Some((0, 4)),\n    Some((0, 2)),\n    Some((0, 2)),\n    None,\n    Some((2, 3)),\n    None,\n    Some((2, 3)),\n    Some((3, 4)),\n    None,\n    Some((3, 4))\n);\nmat!(\n    match_repetition_56,\n    r\"((..)|(.)){1}\",\n    r\"aaaa\",\n    Some((0, 2)),\n    Some((0, 2)),\n    Some((0, 2)),\n    None\n);\nmat!(\n    match_repetition_57,\n    r\"((..)|(.)){2}\",\n    r\"aaaa\",\n    Some((0, 4)),\n    Some((2, 4)),\n    Some((2, 4)),\n    None\n);\nmat!(\n    match_repetition_59,\n    r\"((..)|(.)){3}\",\n    r\"aaaa\",\n    Some((0, 4)),\n    Some((3, 4)),\n    Some((0, 2)),\n    Some((3, 4))\n);\nmat!(\n    match_repetition_61,\n    r\"((..)|(.))*\",\n    r\"aaaa\",\n    Some((0, 4)),\n    Some((2, 4)),\n    Some((2, 4)),\n    None\n);\nmat!(\n    match_repetition_63,\n    r\"((..)|(.))\",\n    r\"aaaaa\",\n    Some((0, 2)),\n    Some((0, 2)),\n    Some((0, 2)),\n    None\n);\nmat!(\n    match_repetition_64,\n    r\"((..)|(.))((..)|(.))\",\n    r\"aaaaa\",\n    Some((0, 4)),\n    Some((0, 2)),\n    Some((0, 2)),\n    None,\n    Some((2, 4)),\n    Some((2, 4)),\n    None\n);\nmat!(\n    match_repetition_65,\n    r\"((..)|(.))((..)|(.))((..)|(.))\",\n    r\"aaaaa\",\n    Some((0, 5)),\n    Some((0, 2)),\n    Some((0, 2)),\n    None,\n    Some((2, 4)),\n    Some((2, 4)),\n    None,\n    Some((4, 5)),\n    None,\n    Some((4, 5))\n);\nmat!(\n    match_repetition_67,\n    r\"((..)|(.)){1}\",\n    r\"aaaaa\",\n    Some((0, 2)),\n    Some((0, 2)),\n    Some((0, 2)),\n    None\n);\nmat!(\n    match_repetition_68,\n    r\"((..)|(.)){2}\",\n    r\"aaaaa\",\n    Some((0, 4)),\n    Some((2, 4)),\n    Some((2, 4)),\n    None\n);\nmat!(\n    match_repetition_70,\n    r\"((..)|(.)){3}\",\n    r\"aaaaa\",\n    Some((0, 5)),\n    Some((4, 5)),\n    Some((2, 4)),\n    Some((4, 5))\n);\nmat!(\n    match_repetition_73,\n    r\"((..)|(.))*\",\n    r\"aaaaa\",\n    Some((0, 5)),\n    Some((4, 5)),\n    Some((2, 4)),\n    Some((4, 5))\n);\nmat!(\n    match_repetition_75,\n    r\"((..)|(.))\",\n    r\"aaaaaa\",\n    Some((0, 2)),\n    Some((0, 2)),\n    Some((0, 2)),\n    None\n);\nmat!(\n    match_repetition_76,\n    r\"((..)|(.))((..)|(.))\",\n    r\"aaaaaa\",\n    Some((0, 4)),\n    Some((0, 2)),\n    Some((0, 2)),\n    None,\n    Some((2, 4)),\n    Some((2, 4)),\n    None\n);\nmat!(\n    match_repetition_77,\n    r\"((..)|(.))((..)|(.))((..)|(.))\",\n    r\"aaaaaa\",\n    Some((0, 6)),\n    Some((0, 2)),\n    Some((0, 2)),\n    None,\n    Some((2, 4)),\n    Some((2, 4)),\n    None,\n    Some((4, 6)),\n    Some((4, 6)),\n    None\n);\nmat!(\n    match_repetition_79,\n    r\"((..)|(.)){1}\",\n    r\"aaaaaa\",\n    Some((0, 2)),\n    Some((0, 2)),\n    Some((0, 2)),\n    None\n);\nmat!(\n    match_repetition_80,\n    r\"((..)|(.)){2}\",\n    r\"aaaaaa\",\n    Some((0, 4)),\n    Some((2, 4)),\n    Some((2, 4)),\n    None\n);\nmat!(\n    match_repetition_81,\n    r\"((..)|(.)){3}\",\n    r\"aaaaaa\",\n    Some((0, 6)),\n    Some((4, 6)),\n    Some((4, 6)),\n    None\n);\nmat!(\n    match_repetition_83,\n    r\"((..)|(.))*\",\n    r\"aaaaaa\",\n    Some((0, 6)),\n    Some((4, 6)),\n    Some((4, 6)),\n    None\n);\nmat!(\n    match_repetition_90,\n    r\"X(.?){0,}Y\",\n    r\"X1234567Y\",\n    Some((0, 9)),\n    Some((7, 8))\n);\nmat!(\n    match_repetition_91,\n    r\"X(.?){1,}Y\",\n    r\"X1234567Y\",\n    Some((0, 9)),\n    Some((7, 8))\n);\nmat!(\n    match_repetition_92,\n    r\"X(.?){2,}Y\",\n    r\"X1234567Y\",\n    Some((0, 9)),\n    Some((7, 8))\n);\nmat!(\n    match_repetition_93,\n    r\"X(.?){3,}Y\",\n    r\"X1234567Y\",\n    Some((0, 9)),\n    Some((7, 8))\n);\nmat!(\n    match_repetition_94,\n    r\"X(.?){4,}Y\",\n    r\"X1234567Y\",\n    Some((0, 9)),\n    Some((7, 8))\n);\nmat!(\n    match_repetition_95,\n    r\"X(.?){5,}Y\",\n    r\"X1234567Y\",\n    Some((0, 9)),\n    Some((7, 8))\n);\nmat!(\n    match_repetition_96,\n    r\"X(.?){6,}Y\",\n    r\"X1234567Y\",\n    Some((0, 9)),\n    Some((7, 8))\n);\nmat!(\n    match_repetition_97,\n    r\"X(.?){7,}Y\",\n    r\"X1234567Y\",\n    Some((0, 9)),\n    Some((7, 8))\n);\nmat!(\n    match_repetition_98,\n    r\"X(.?){8,}Y\",\n    r\"X1234567Y\",\n    Some((0, 9)),\n    Some((8, 8))\n);\nmat!(\n    match_repetition_100,\n    r\"X(.?){0,8}Y\",\n    r\"X1234567Y\",\n    Some((0, 9)),\n    Some((8, 8))\n);\nmat!(\n    match_repetition_102,\n    r\"X(.?){1,8}Y\",\n    r\"X1234567Y\",\n    Some((0, 9)),\n    Some((8, 8))\n);\nmat!(\n    match_repetition_104,\n    r\"X(.?){2,8}Y\",\n    r\"X1234567Y\",\n    Some((0, 9)),\n    Some((8, 8))\n);\nmat!(\n    match_repetition_106,\n    r\"X(.?){3,8}Y\",\n    r\"X1234567Y\",\n    Some((0, 9)),\n    Some((8, 8))\n);\nmat!(\n    match_repetition_108,\n    r\"X(.?){4,8}Y\",\n    r\"X1234567Y\",\n    Some((0, 9)),\n    Some((8, 8))\n);\nmat!(\n    match_repetition_110,\n    r\"X(.?){5,8}Y\",\n    r\"X1234567Y\",\n    Some((0, 9)),\n    Some((8, 8))\n);\nmat!(\n    match_repetition_112,\n    r\"X(.?){6,8}Y\",\n    r\"X1234567Y\",\n    Some((0, 9)),\n    Some((8, 8))\n);\nmat!(\n    match_repetition_114,\n    r\"X(.?){7,8}Y\",\n    r\"X1234567Y\",\n    Some((0, 9)),\n    Some((8, 8))\n);\nmat!(\n    match_repetition_115,\n    r\"X(.?){8,8}Y\",\n    r\"X1234567Y\",\n    Some((0, 9)),\n    Some((8, 8))\n);\nmat!(\n    match_repetition_126,\n    r\"(a|ab|c|bcd){0,}(d*)\",\n    r\"ababcd\",\n    Some((0, 1)),\n    Some((0, 1)),\n    Some((1, 1))\n);\nmat!(\n    match_repetition_127,\n    r\"(a|ab|c|bcd){1,}(d*)\",\n    r\"ababcd\",\n    Some((0, 1)),\n    Some((0, 1)),\n    Some((1, 1))\n);\nmat!(\n    match_repetition_128,\n    r\"(a|ab|c|bcd){2,}(d*)\",\n    r\"ababcd\",\n    Some((0, 6)),\n    Some((3, 6)),\n    Some((6, 6))\n);\nmat!(\n    match_repetition_129,\n    r\"(a|ab|c|bcd){3,}(d*)\",\n    r\"ababcd\",\n    Some((0, 6)),\n    Some((3, 6)),\n    Some((6, 6))\n);\nmat!(match_repetition_130, r\"(a|ab|c|bcd){4,}(d*)\", r\"ababcd\", None);\nmat!(\n    match_repetition_131,\n    r\"(a|ab|c|bcd){0,10}(d*)\",\n    r\"ababcd\",\n    Some((0, 1)),\n    Some((0, 1)),\n    Some((1, 1))\n);\nmat!(\n    match_repetition_132,\n    r\"(a|ab|c|bcd){1,10}(d*)\",\n    r\"ababcd\",\n    Some((0, 1)),\n    Some((0, 1)),\n    Some((1, 1))\n);\nmat!(\n    match_repetition_133,\n    r\"(a|ab|c|bcd){2,10}(d*)\",\n    r\"ababcd\",\n    Some((0, 6)),\n    Some((3, 6)),\n    Some((6, 6))\n);\nmat!(\n    match_repetition_134,\n    r\"(a|ab|c|bcd){3,10}(d*)\",\n    r\"ababcd\",\n    Some((0, 6)),\n    Some((3, 6)),\n    Some((6, 6))\n);\nmat!(match_repetition_135, r\"(a|ab|c|bcd){4,10}(d*)\", r\"ababcd\", None);\nmat!(\n    match_repetition_136,\n    r\"(a|ab|c|bcd)*(d*)\",\n    r\"ababcd\",\n    Some((0, 1)),\n    Some((0, 1)),\n    Some((1, 1))\n);\nmat!(\n    match_repetition_137,\n    r\"(a|ab|c|bcd)+(d*)\",\n    r\"ababcd\",\n    Some((0, 1)),\n    Some((0, 1)),\n    Some((1, 1))\n);\nmat!(\n    match_repetition_143,\n    r\"(ab|a|c|bcd){0,}(d*)\",\n    r\"ababcd\",\n    Some((0, 6)),\n    Some((4, 5)),\n    Some((5, 6))\n);\nmat!(\n    match_repetition_145,\n    r\"(ab|a|c|bcd){1,}(d*)\",\n    r\"ababcd\",\n    Some((0, 6)),\n    Some((4, 5)),\n    Some((5, 6))\n);\nmat!(\n    match_repetition_147,\n    r\"(ab|a|c|bcd){2,}(d*)\",\n    r\"ababcd\",\n    Some((0, 6)),\n    Some((4, 5)),\n    Some((5, 6))\n);\nmat!(\n    match_repetition_149,\n    r\"(ab|a|c|bcd){3,}(d*)\",\n    r\"ababcd\",\n    Some((0, 6)),\n    Some((4, 5)),\n    Some((5, 6))\n);\nmat!(match_repetition_150, r\"(ab|a|c|bcd){4,}(d*)\", r\"ababcd\", None);\nmat!(\n    match_repetition_152,\n    r\"(ab|a|c|bcd){0,10}(d*)\",\n    r\"ababcd\",\n    Some((0, 6)),\n    Some((4, 5)),\n    Some((5, 6))\n);\nmat!(\n    match_repetition_154,\n    r\"(ab|a|c|bcd){1,10}(d*)\",\n    r\"ababcd\",\n    Some((0, 6)),\n    Some((4, 5)),\n    Some((5, 6))\n);\nmat!(\n    match_repetition_156,\n    r\"(ab|a|c|bcd){2,10}(d*)\",\n    r\"ababcd\",\n    Some((0, 6)),\n    Some((4, 5)),\n    Some((5, 6))\n);\nmat!(\n    match_repetition_158,\n    r\"(ab|a|c|bcd){3,10}(d*)\",\n    r\"ababcd\",\n    Some((0, 6)),\n    Some((4, 5)),\n    Some((5, 6))\n);\nmat!(match_repetition_159, r\"(ab|a|c|bcd){4,10}(d*)\", r\"ababcd\", None);\nmat!(\n    match_repetition_161,\n    r\"(ab|a|c|bcd)*(d*)\",\n    r\"ababcd\",\n    Some((0, 6)),\n    Some((4, 5)),\n    Some((5, 6))\n);\nmat!(\n    match_repetition_163,\n    r\"(ab|a|c|bcd)+(d*)\",\n    r\"ababcd\",\n    Some((0, 6)),\n    Some((4, 5)),\n    Some((5, 6))\n);\n","traces":[{"line":5,"address":[7455918,7455956,7457332],"length":1,"stats":{"Line":13},"fn_name":null},{"line":6,"address":[7458084,7459460,7458046],"length":1,"stats":{"Line":13},"fn_name":null},{"line":7,"address":[7461588,7460212,7460174],"length":1,"stats":{"Line":13},"fn_name":null},{"line":8,"address":[7462302,7462340,7463716],"length":1,"stats":{"Line":13},"fn_name":null},{"line":9,"address":[7464468,7465844,7464430],"length":1,"stats":{"Line":13},"fn_name":null},{"line":10,"address":[7467972,7466558,7466596],"length":1,"stats":{"Line":13},"fn_name":null},{"line":11,"address":[7470100,7468724,7468686],"length":1,"stats":{"Line":13},"fn_name":null},{"line":12,"address":[7472228,7470814,7470852],"length":1,"stats":{"Line":13},"fn_name":null},{"line":13,"address":[7472942,7474356,7472980],"length":1,"stats":{"Line":13},"fn_name":null},{"line":14,"address":[7476484,7475070,7475108],"length":1,"stats":{"Line":13},"fn_name":null},{"line":15,"address":[7477236,7478612,7477198],"length":1,"stats":{"Line":13},"fn_name":null},{"line":16,"address":[7480740,7479326,7479364],"length":1,"stats":{"Line":13},"fn_name":null},{"line":17,"address":[7481454,7481492,7482868],"length":1,"stats":{"Line":13},"fn_name":null},{"line":18,"address":[7483575,7483620,7484996],"length":1,"stats":{"Line":13},"fn_name":null},{"line":19,"address":[7485748,7485703,7487124],"length":1,"stats":{"Line":13},"fn_name":null},{"line":20,"address":[7487838,7487876,7489356],"length":1,"stats":{"Line":13},"fn_name":null},{"line":21,"address":[7491596,7490116,7490078],"length":1,"stats":{"Line":13},"fn_name":null},{"line":22,"address":[7492356,7493732,7492318],"length":1,"stats":{"Line":13},"fn_name":null},{"line":23,"address":[7494446,7495964,7494484],"length":1,"stats":{"Line":13},"fn_name":null},{"line":28,"address":[7496724],"length":1,"stats":{"Line":8},"fn_name":null},{"line":29,"address":[7496792],"length":1,"stats":{"Line":8},"fn_name":null},{"line":30,"address":[7496860],"length":1,"stats":{"Line":8},"fn_name":null},{"line":32,"address":[7500540,7499022,7499060],"length":1,"stats":{"Line":13},"fn_name":null},{"line":33,"address":[7501262,7502676,7501300],"length":1,"stats":{"Line":13},"fn_name":null},{"line":38,"address":[7503428],"length":1,"stats":{"Line":8},"fn_name":null},{"line":39,"address":[7503496],"length":1,"stats":{"Line":8},"fn_name":null},{"line":40,"address":[7503564],"length":1,"stats":{"Line":8},"fn_name":null},{"line":41,"address":[7503632],"length":1,"stats":{"Line":8},"fn_name":null},{"line":47,"address":[7505876],"length":1,"stats":{"Line":8},"fn_name":null},{"line":48,"address":[7505944],"length":1,"stats":{"Line":8},"fn_name":null},{"line":49,"address":[7506012],"length":1,"stats":{"Line":8},"fn_name":null},{"line":50,"address":[7506080],"length":1,"stats":{"Line":8},"fn_name":null},{"line":56,"address":[7508324],"length":1,"stats":{"Line":8},"fn_name":null},{"line":57,"address":[7508392],"length":1,"stats":{"Line":8},"fn_name":null},{"line":58,"address":[7508460],"length":1,"stats":{"Line":8},"fn_name":null},{"line":64,"address":[7510660],"length":1,"stats":{"Line":8},"fn_name":null},{"line":65,"address":[7510728],"length":1,"stats":{"Line":8},"fn_name":null},{"line":66,"address":[7510796],"length":1,"stats":{"Line":8},"fn_name":null},{"line":68,"address":[7512958,7512996,7514476],"length":1,"stats":{"Line":13},"fn_name":null},{"line":73,"address":[7515236],"length":1,"stats":{"Line":8},"fn_name":null},{"line":74,"address":[7515304],"length":1,"stats":{"Line":8},"fn_name":null},{"line":75,"address":[7515316],"length":1,"stats":{"Line":8},"fn_name":null},{"line":76,"address":[7515328],"length":1,"stats":{"Line":8},"fn_name":null},{"line":78,"address":[7517534,7517572,7519052],"length":1,"stats":{"Line":13},"fn_name":null},{"line":79,"address":[7519812,7521292,7519774],"length":1,"stats":{"Line":13},"fn_name":null},{"line":84,"address":[7522052],"length":1,"stats":{"Line":8},"fn_name":null},{"line":85,"address":[7522120],"length":1,"stats":{"Line":8},"fn_name":null},{"line":86,"address":[7522132],"length":1,"stats":{"Line":8},"fn_name":null},{"line":88,"address":[7525804,7524324,7524286],"length":1,"stats":{"Line":13},"fn_name":null},{"line":89,"address":[7526564,7526526,7527940],"length":1,"stats":{"Line":13},"fn_name":null},{"line":94,"address":[7528692],"length":1,"stats":{"Line":8},"fn_name":null},{"line":95,"address":[7528760],"length":1,"stats":{"Line":8},"fn_name":null},{"line":97,"address":[7530932,7530894,7532412],"length":1,"stats":{"Line":13},"fn_name":null},{"line":98,"address":[7533172,7534652,7533134],"length":1,"stats":{"Line":13},"fn_name":null},{"line":99,"address":[7535374,7536788,7535412],"length":1,"stats":{"Line":13},"fn_name":null},{"line":100,"address":[7537502,7537540,7538916],"length":1,"stats":{"Line":13},"fn_name":null},{"line":101,"address":[7539668,7541044,7539630],"length":1,"stats":{"Line":13},"fn_name":null},{"line":106,"address":[7541796],"length":1,"stats":{"Line":8},"fn_name":null},{"line":107,"address":[7541864],"length":1,"stats":{"Line":8},"fn_name":null},{"line":113,"address":[7544036],"length":1,"stats":{"Line":8},"fn_name":null},{"line":114,"address":[7544104],"length":1,"stats":{"Line":8},"fn_name":null},{"line":116,"address":[7546238,7546276,7547652],"length":1,"stats":{"Line":13},"fn_name":null},{"line":117,"address":[7549780,7548366,7548404],"length":1,"stats":{"Line":13},"fn_name":null},{"line":122,"address":[7550532],"length":1,"stats":{"Line":8},"fn_name":null},{"line":123,"address":[7550600],"length":1,"stats":{"Line":8},"fn_name":null},{"line":125,"address":[7552772,7554148,7552734],"length":1,"stats":{"Line":13},"fn_name":null},{"line":126,"address":[7556276,7554862,7554900],"length":1,"stats":{"Line":13},"fn_name":null},{"line":127,"address":[7556990,7557028,7558404],"length":1,"stats":{"Line":13},"fn_name":null},{"line":132,"address":[7559156],"length":1,"stats":{"Line":8},"fn_name":null},{"line":138,"address":[7561284],"length":1,"stats":{"Line":8},"fn_name":null},{"line":140,"address":[7563374,7564788,7563412],"length":1,"stats":{"Line":13},"fn_name":null},{"line":141,"address":[7566916,7565502,7565540],"length":1,"stats":{"Line":13},"fn_name":null},{"line":142,"address":[7569044,7567630,7567668],"length":1,"stats":{"Line":13},"fn_name":null},{"line":149,"address":[7569796],"length":1,"stats":{"Line":8},"fn_name":null},{"line":157,"address":[7571924],"length":1,"stats":{"Line":8},"fn_name":null},{"line":164,"address":[7574052],"length":1,"stats":{"Line":8},"fn_name":null},{"line":172,"address":[7576180],"length":1,"stats":{"Line":8},"fn_name":null},{"line":178,"address":[7578308],"length":1,"stats":{"Line":8},"fn_name":null},{"line":179,"address":[7578376],"length":1,"stats":{"Line":8},"fn_name":null},{"line":180,"address":[7578444],"length":1,"stats":{"Line":8},"fn_name":null},{"line":181,"address":[7578512],"length":1,"stats":{"Line":8},"fn_name":null},{"line":183,"address":[7582132,7580718,7580756],"length":1,"stats":{"Line":13},"fn_name":null},{"line":188,"address":[7582884],"length":1,"stats":{"Line":8},"fn_name":null},{"line":194,"address":[7585012],"length":1,"stats":{"Line":8},"fn_name":null},{"line":200,"address":[7587140],"length":1,"stats":{"Line":8},"fn_name":null},{"line":206,"address":[7589268],"length":1,"stats":{"Line":8},"fn_name":null},{"line":207,"address":[7589336],"length":1,"stats":{"Line":8},"fn_name":null},{"line":208,"address":[7589404],"length":1,"stats":{"Line":8},"fn_name":null},{"line":214,"address":[7591604],"length":1,"stats":{"Line":8},"fn_name":null},{"line":215,"address":[7591672],"length":1,"stats":{"Line":8},"fn_name":null},{"line":216,"address":[7591740],"length":1,"stats":{"Line":8},"fn_name":null},{"line":222,"address":[7593940],"length":1,"stats":{"Line":8},"fn_name":null},{"line":223,"address":[7594008],"length":1,"stats":{"Line":8},"fn_name":null},{"line":229,"address":[7596180],"length":1,"stats":{"Line":8},"fn_name":null},{"line":235,"address":[7598308],"length":1,"stats":{"Line":8},"fn_name":null},{"line":241,"address":[7600436],"length":1,"stats":{"Line":8},"fn_name":null},{"line":243,"address":[7602564,7603940,7602526],"length":1,"stats":{"Line":13},"fn_name":null},{"line":248,"address":[7604692],"length":1,"stats":{"Line":8},"fn_name":null},{"line":250,"address":[7606820,7608196,7606782],"length":1,"stats":{"Line":13},"fn_name":null},{"line":251,"address":[7608948,7608903,7610324],"length":1,"stats":{"Line":13},"fn_name":null},{"line":252,"address":[7611031,7611076,7612452],"length":1,"stats":{"Line":13},"fn_name":null},{"line":253,"address":[7614580,7613159,7613204],"length":1,"stats":{"Line":13},"fn_name":null},{"line":254,"address":[7616708,7615294,7615332],"length":1,"stats":{"Line":13},"fn_name":null},{"line":255,"address":[7617460,7618836,7617422],"length":1,"stats":{"Line":13},"fn_name":null},{"line":256,"address":[7620964,7619588,7619550],"length":1,"stats":{"Line":13},"fn_name":null},{"line":257,"address":[7621716,7623092,7621678],"length":1,"stats":{"Line":13},"fn_name":null},{"line":258,"address":[7623844,7625220,7623806],"length":1,"stats":{"Line":13},"fn_name":null},{"line":259,"address":[7625972,7627348,7625934],"length":1,"stats":{"Line":13},"fn_name":null},{"line":260,"address":[7628062,7628100,7629476],"length":1,"stats":{"Line":13},"fn_name":null},{"line":261,"address":[7630190,7630228,7631604],"length":1,"stats":{"Line":13},"fn_name":null},{"line":262,"address":[7632318,7632356,7633732],"length":1,"stats":{"Line":13},"fn_name":null},{"line":263,"address":[7634484,7634446,7635860],"length":1,"stats":{"Line":13},"fn_name":null},{"line":264,"address":[7636574,7636612,7637988],"length":1,"stats":{"Line":13},"fn_name":null},{"line":265,"address":[7638702,7638740,7640116],"length":1,"stats":{"Line":13},"fn_name":null},{"line":266,"address":[7642244,7640830,7640868],"length":1,"stats":{"Line":13},"fn_name":null},{"line":267,"address":[7642958,7644372,7642996],"length":1,"stats":{"Line":13},"fn_name":null},{"line":268,"address":[7645086,7645124,7646500],"length":1,"stats":{"Line":13},"fn_name":null},{"line":269,"address":[7648628,7647214,7647252],"length":1,"stats":{"Line":13},"fn_name":null},{"line":270,"address":[7649342,7649380,7650756],"length":1,"stats":{"Line":13},"fn_name":null},{"line":271,"address":[7652884,7651470,7651508],"length":1,"stats":{"Line":13},"fn_name":null},{"line":272,"address":[7653636,7653598,7655012],"length":1,"stats":{"Line":13},"fn_name":null},{"line":273,"address":[7655764,7657140,7655726],"length":1,"stats":{"Line":13},"fn_name":null},{"line":274,"address":[7659268,7657892,7657854],"length":1,"stats":{"Line":13},"fn_name":null},{"line":275,"address":[7659982,7661396,7660020],"length":1,"stats":{"Line":13},"fn_name":null},{"line":276,"address":[7662110,7662148,7663524],"length":1,"stats":{"Line":13},"fn_name":null},{"line":277,"address":[7665652,7664276,7664238],"length":1,"stats":{"Line":13},"fn_name":null},{"line":278,"address":[7666404,7667780,7666366],"length":1,"stats":{"Line":13},"fn_name":null},{"line":279,"address":[7669908,7668494,7668532],"length":1,"stats":{"Line":13},"fn_name":null},{"line":280,"address":[7670660,7672036,7670622],"length":1,"stats":{"Line":13},"fn_name":null},{"line":281,"address":[7674164,7672750,7672788],"length":1,"stats":{"Line":13},"fn_name":null},{"line":282,"address":[7674916,7674878,7676292],"length":1,"stats":{"Line":13},"fn_name":null},{"line":283,"address":[7677044,7678420,7677006],"length":1,"stats":{"Line":13},"fn_name":null},{"line":284,"address":[7679134,7679172,7680548],"length":1,"stats":{"Line":13},"fn_name":null},{"line":285,"address":[7681262,7681300,7682676],"length":1,"stats":{"Line":13},"fn_name":null},{"line":286,"address":[7683390,7683428,7684804],"length":1,"stats":{"Line":13},"fn_name":null},{"line":287,"address":[7686932,7685518,7685556],"length":1,"stats":{"Line":13},"fn_name":null},{"line":288,"address":[7687646,7687684,7689060],"length":1,"stats":{"Line":13},"fn_name":null},{"line":289,"address":[7691188,7689812,7689774],"length":1,"stats":{"Line":13},"fn_name":null},{"line":294,"address":[7691940],"length":1,"stats":{"Line":8},"fn_name":null},{"line":295,"address":[7692008],"length":1,"stats":{"Line":8},"fn_name":null},{"line":296,"address":[7692076],"length":1,"stats":{"Line":8},"fn_name":null},{"line":302,"address":[7694276],"length":1,"stats":{"Line":8},"fn_name":null},{"line":303,"address":[7694344],"length":1,"stats":{"Line":8},"fn_name":null},{"line":304,"address":[7694412],"length":1,"stats":{"Line":8},"fn_name":null},{"line":306,"address":[7696612,7696574,7697988],"length":1,"stats":{"Line":13},"fn_name":null},{"line":307,"address":[7698740,7700116,7698702],"length":1,"stats":{"Line":13},"fn_name":null},{"line":308,"address":[7700830,7702292,7700868],"length":1,"stats":{"Line":13},"fn_name":null},{"line":309,"address":[7703044,7703006,7704524],"length":1,"stats":{"Line":13},"fn_name":null},{"line":310,"address":[7706708,7705284,7705246],"length":1,"stats":{"Line":13},"fn_name":null},{"line":311,"address":[7708940,7707422,7707460],"length":1,"stats":{"Line":13},"fn_name":null},{"line":312,"address":[7709662,7709700,7711180],"length":1,"stats":{"Line":13},"fn_name":null},{"line":313,"address":[7711902,7711940,7713420],"length":1,"stats":{"Line":13},"fn_name":null},{"line":314,"address":[7714142,7715556,7714180],"length":1,"stats":{"Line":13},"fn_name":null},{"line":315,"address":[7716308,7717732,7716270],"length":1,"stats":{"Line":13},"fn_name":null},{"line":316,"address":[7719860,7718484,7718439],"length":1,"stats":{"Line":13},"fn_name":null},{"line":317,"address":[7722092,7720574,7720612],"length":1,"stats":{"Line":13},"fn_name":null},{"line":318,"address":[7722814,7722852,7724332],"length":1,"stats":{"Line":13},"fn_name":null},{"line":319,"address":[7725054,7725092,7726468],"length":1,"stats":{"Line":13},"fn_name":null},{"line":320,"address":[7727182,7727220,7728700],"length":1,"stats":{"Line":13},"fn_name":null},{"line":321,"address":[7729422,7729460,7730932],"length":1,"stats":{"Line":13},"fn_name":null},{"line":322,"address":[7733060,7731684,7731646],"length":1,"stats":{"Line":13},"fn_name":null},{"line":323,"address":[7735188,7733774,7733812],"length":1,"stats":{"Line":13},"fn_name":null},{"line":324,"address":[7737316,7735902,7735940],"length":1,"stats":{"Line":13},"fn_name":null},{"line":325,"address":[7738068,7739548,7738030],"length":1,"stats":{"Line":13},"fn_name":null},{"line":326,"address":[7741684,7740308,7740270],"length":1,"stats":{"Line":13},"fn_name":null},{"line":327,"address":[7743916,7742436,7742398],"length":1,"stats":{"Line":13},"fn_name":null},{"line":328,"address":[7744676,7746156,7744638],"length":1,"stats":{"Line":13},"fn_name":null},{"line":329,"address":[7746878,7748396,7746916],"length":1,"stats":{"Line":13},"fn_name":null},{"line":334,"address":[7749156],"length":1,"stats":{"Line":8},"fn_name":null},{"line":335,"address":[7749224],"length":1,"stats":{"Line":8},"fn_name":null},{"line":336,"address":[7749292],"length":1,"stats":{"Line":8},"fn_name":null},{"line":342,"address":[7751492],"length":1,"stats":{"Line":8},"fn_name":null},{"line":343,"address":[7751560],"length":1,"stats":{"Line":8},"fn_name":null},{"line":344,"address":[7751628],"length":1,"stats":{"Line":8},"fn_name":null},{"line":350,"address":[7753828],"length":1,"stats":{"Line":8},"fn_name":null},{"line":351,"address":[7753896],"length":1,"stats":{"Line":8},"fn_name":null},{"line":352,"address":[7753964],"length":1,"stats":{"Line":8},"fn_name":null},{"line":354,"address":[7756164,7757540,7756126],"length":1,"stats":{"Line":13},"fn_name":null},{"line":355,"address":[7758292,7759772,7758254],"length":1,"stats":{"Line":13},"fn_name":null},{"line":360,"address":[7760532],"length":1,"stats":{"Line":8},"fn_name":null},{"line":361,"address":[7760600],"length":1,"stats":{"Line":8},"fn_name":null},{"line":362,"address":[7760668],"length":1,"stats":{"Line":8},"fn_name":null},{"line":363,"address":[7760736],"length":1,"stats":{"Line":8},"fn_name":null},{"line":364,"address":[7760804],"length":1,"stats":{"Line":8},"fn_name":null},{"line":366,"address":[7763076,7763038,7764452],"length":1,"stats":{"Line":13},"fn_name":null},{"line":367,"address":[7765204,7766580,7765166],"length":1,"stats":{"Line":13},"fn_name":null},{"line":372,"address":[7767332],"length":1,"stats":{"Line":8},"fn_name":null},{"line":373,"address":[7767400],"length":1,"stats":{"Line":8},"fn_name":null},{"line":379,"address":[7769572],"length":1,"stats":{"Line":8},"fn_name":null},{"line":380,"address":[7769640],"length":1,"stats":{"Line":8},"fn_name":null},{"line":381,"address":[7769708],"length":1,"stats":{"Line":8},"fn_name":null},{"line":387,"address":[7771908],"length":1,"stats":{"Line":8},"fn_name":null},{"line":388,"address":[7771976],"length":1,"stats":{"Line":8},"fn_name":null},{"line":394,"address":[7774148],"length":1,"stats":{"Line":8},"fn_name":null},{"line":395,"address":[7774216],"length":1,"stats":{"Line":8},"fn_name":null},{"line":396,"address":[7774284],"length":1,"stats":{"Line":8},"fn_name":null},{"line":397,"address":[7774352],"length":1,"stats":{"Line":8},"fn_name":null},{"line":398,"address":[7774420],"length":1,"stats":{"Line":8},"fn_name":null},{"line":399,"address":[7774488],"length":1,"stats":{"Line":8},"fn_name":null},{"line":400,"address":[7774556],"length":1,"stats":{"Line":8},"fn_name":null},{"line":401,"address":[7774624],"length":1,"stats":{"Line":8},"fn_name":null},{"line":402,"address":[7774692],"length":1,"stats":{"Line":8},"fn_name":null},{"line":403,"address":[7774760],"length":1,"stats":{"Line":8},"fn_name":null},{"line":409,"address":[7777268],"length":1,"stats":{"Line":8},"fn_name":null},{"line":415,"address":[7779396],"length":1,"stats":{"Line":8},"fn_name":null},{"line":416,"address":[7779464],"length":1,"stats":{"Line":8},"fn_name":null},{"line":417,"address":[7779532],"length":1,"stats":{"Line":8},"fn_name":null},{"line":419,"address":[7781694,7781732,7783108],"length":1,"stats":{"Line":13},"fn_name":null},{"line":420,"address":[7783860,7785340,7783822],"length":1,"stats":{"Line":13},"fn_name":null},{"line":421,"address":[7786100,7787476,7786062],"length":1,"stats":{"Line":13},"fn_name":null},{"line":426,"address":[7788228],"length":1,"stats":{"Line":8},"fn_name":null},{"line":427,"address":[7788296],"length":1,"stats":{"Line":8},"fn_name":null},{"line":428,"address":[7788308],"length":1,"stats":{"Line":8},"fn_name":null},{"line":434,"address":[7790500],"length":1,"stats":{"Line":8},"fn_name":null},{"line":435,"address":[7790568],"length":1,"stats":{"Line":8},"fn_name":null},{"line":436,"address":[7790580],"length":1,"stats":{"Line":8},"fn_name":null},{"line":442,"address":[7792772],"length":1,"stats":{"Line":8},"fn_name":null},{"line":443,"address":[7792840],"length":1,"stats":{"Line":8},"fn_name":null},{"line":444,"address":[7792852],"length":1,"stats":{"Line":8},"fn_name":null},{"line":450,"address":[7795044],"length":1,"stats":{"Line":8},"fn_name":null},{"line":451,"address":[7795112],"length":1,"stats":{"Line":8},"fn_name":null},{"line":452,"address":[7795124],"length":1,"stats":{"Line":8},"fn_name":null},{"line":458,"address":[7797316],"length":1,"stats":{"Line":8},"fn_name":null},{"line":459,"address":[7797384],"length":1,"stats":{"Line":8},"fn_name":null},{"line":460,"address":[7797396],"length":1,"stats":{"Line":8},"fn_name":null},{"line":466,"address":[7799588],"length":1,"stats":{"Line":8},"fn_name":null},{"line":467,"address":[7799656],"length":1,"stats":{"Line":8},"fn_name":null},{"line":468,"address":[7799668],"length":1,"stats":{"Line":8},"fn_name":null},{"line":474,"address":[7801860],"length":1,"stats":{"Line":8},"fn_name":null},{"line":475,"address":[7801928],"length":1,"stats":{"Line":8},"fn_name":null},{"line":476,"address":[7801940],"length":1,"stats":{"Line":8},"fn_name":null},{"line":482,"address":[7804132],"length":1,"stats":{"Line":8},"fn_name":null},{"line":483,"address":[7804200],"length":1,"stats":{"Line":8},"fn_name":null},{"line":484,"address":[7804212],"length":1,"stats":{"Line":8},"fn_name":null},{"line":490,"address":[7806404],"length":1,"stats":{"Line":8},"fn_name":null},{"line":491,"address":[7806472],"length":1,"stats":{"Line":8},"fn_name":null},{"line":492,"address":[7806484],"length":1,"stats":{"Line":8},"fn_name":null},{"line":498,"address":[7808676],"length":1,"stats":{"Line":8},"fn_name":null},{"line":499,"address":[7808744],"length":1,"stats":{"Line":8},"fn_name":null},{"line":500,"address":[7808756],"length":1,"stats":{"Line":8},"fn_name":null},{"line":506,"address":[7810948],"length":1,"stats":{"Line":8},"fn_name":null},{"line":507,"address":[7811016],"length":1,"stats":{"Line":8},"fn_name":null},{"line":508,"address":[7811028],"length":1,"stats":{"Line":8},"fn_name":null},{"line":514,"address":[7813220],"length":1,"stats":{"Line":8},"fn_name":null},{"line":515,"address":[7813288],"length":1,"stats":{"Line":8},"fn_name":null},{"line":516,"address":[7813300],"length":1,"stats":{"Line":8},"fn_name":null},{"line":522,"address":[7815492],"length":1,"stats":{"Line":8},"fn_name":null},{"line":523,"address":[7815560],"length":1,"stats":{"Line":8},"fn_name":null},{"line":524,"address":[7815572],"length":1,"stats":{"Line":8},"fn_name":null},{"line":530,"address":[7817764],"length":1,"stats":{"Line":8},"fn_name":null},{"line":531,"address":[7817832],"length":1,"stats":{"Line":8},"fn_name":null},{"line":532,"address":[7817844],"length":1,"stats":{"Line":8},"fn_name":null},{"line":538,"address":[7820036],"length":1,"stats":{"Line":8},"fn_name":null},{"line":539,"address":[7820104],"length":1,"stats":{"Line":8},"fn_name":null},{"line":540,"address":[7820116],"length":1,"stats":{"Line":8},"fn_name":null},{"line":546,"address":[7822308],"length":1,"stats":{"Line":8},"fn_name":null},{"line":547,"address":[7822376],"length":1,"stats":{"Line":8},"fn_name":null},{"line":548,"address":[7822388],"length":1,"stats":{"Line":8},"fn_name":null},{"line":554,"address":[7824580],"length":1,"stats":{"Line":8},"fn_name":null},{"line":555,"address":[7824648],"length":1,"stats":{"Line":8},"fn_name":null},{"line":556,"address":[7824660],"length":1,"stats":{"Line":8},"fn_name":null},{"line":558,"address":[7826814,7828332,7826852],"length":1,"stats":{"Line":13},"fn_name":null},{"line":559,"address":[7830468,7829054,7829092],"length":1,"stats":{"Line":13},"fn_name":null},{"line":560,"address":[7831182,7831220,7832700],"length":1,"stats":{"Line":13},"fn_name":null},{"line":565,"address":[7833460],"length":1,"stats":{"Line":8},"fn_name":null},{"line":566,"address":[7833528],"length":1,"stats":{"Line":8},"fn_name":null},{"line":567,"address":[7833596],"length":1,"stats":{"Line":8},"fn_name":null},{"line":573,"address":[7835796],"length":1,"stats":{"Line":8},"fn_name":null},{"line":574,"address":[7835864],"length":1,"stats":{"Line":8},"fn_name":null},{"line":575,"address":[7835876],"length":1,"stats":{"Line":8},"fn_name":null},{"line":581,"address":[7838068],"length":1,"stats":{"Line":8},"fn_name":null},{"line":582,"address":[7838136],"length":1,"stats":{"Line":8},"fn_name":null},{"line":583,"address":[7838204],"length":1,"stats":{"Line":8},"fn_name":null},{"line":589,"address":[7840404],"length":1,"stats":{"Line":8},"fn_name":null},{"line":590,"address":[7840472],"length":1,"stats":{"Line":8},"fn_name":null},{"line":591,"address":[7840540],"length":1,"stats":{"Line":8},"fn_name":null},{"line":597,"address":[7842740],"length":1,"stats":{"Line":8},"fn_name":null},{"line":598,"address":[7842808],"length":1,"stats":{"Line":8},"fn_name":null},{"line":599,"address":[7842876],"length":1,"stats":{"Line":8},"fn_name":null},{"line":605,"address":[7845076],"length":1,"stats":{"Line":8},"fn_name":null},{"line":606,"address":[7845144],"length":1,"stats":{"Line":8},"fn_name":null},{"line":607,"address":[7845212],"length":1,"stats":{"Line":8},"fn_name":null},{"line":608,"address":[7845224],"length":1,"stats":{"Line":8},"fn_name":null},{"line":614,"address":[7847460],"length":1,"stats":{"Line":8},"fn_name":null},{"line":615,"address":[7847528],"length":1,"stats":{"Line":8},"fn_name":null},{"line":616,"address":[7847596],"length":1,"stats":{"Line":8},"fn_name":null},{"line":617,"address":[7847608],"length":1,"stats":{"Line":8},"fn_name":null},{"line":623,"address":[7849844],"length":1,"stats":{"Line":8},"fn_name":null},{"line":624,"address":[7849912],"length":1,"stats":{"Line":8},"fn_name":null},{"line":625,"address":[7849980],"length":1,"stats":{"Line":8},"fn_name":null},{"line":631,"address":[7852180],"length":1,"stats":{"Line":8},"fn_name":null},{"line":632,"address":[7852248],"length":1,"stats":{"Line":8},"fn_name":null},{"line":638,"address":[7854420],"length":1,"stats":{"Line":8},"fn_name":null},{"line":639,"address":[7854488],"length":1,"stats":{"Line":8},"fn_name":null},{"line":645,"address":[7856660],"length":1,"stats":{"Line":8},"fn_name":null},{"line":646,"address":[7856728],"length":1,"stats":{"Line":8},"fn_name":null},{"line":647,"address":[7856796],"length":1,"stats":{"Line":8},"fn_name":null},{"line":653,"address":[7858996],"length":1,"stats":{"Line":8},"fn_name":null},{"line":654,"address":[7859064],"length":1,"stats":{"Line":8},"fn_name":null},{"line":655,"address":[7859132],"length":1,"stats":{"Line":8},"fn_name":null},{"line":661,"address":[7861332],"length":1,"stats":{"Line":8},"fn_name":null},{"line":662,"address":[7861400],"length":1,"stats":{"Line":8},"fn_name":null},{"line":663,"address":[7861468],"length":1,"stats":{"Line":8},"fn_name":null},{"line":669,"address":[7863668],"length":1,"stats":{"Line":8},"fn_name":null},{"line":670,"address":[7863736],"length":1,"stats":{"Line":8},"fn_name":null},{"line":676,"address":[7865908],"length":1,"stats":{"Line":8},"fn_name":null},{"line":677,"address":[7865976],"length":1,"stats":{"Line":8},"fn_name":null},{"line":683,"address":[7868148],"length":1,"stats":{"Line":8},"fn_name":null},{"line":684,"address":[7868216],"length":1,"stats":{"Line":8},"fn_name":null},{"line":690,"address":[7870388],"length":1,"stats":{"Line":8},"fn_name":null},{"line":691,"address":[7870456],"length":1,"stats":{"Line":8},"fn_name":null},{"line":697,"address":[7872628],"length":1,"stats":{"Line":8},"fn_name":null},{"line":698,"address":[7872696],"length":1,"stats":{"Line":8},"fn_name":null},{"line":699,"address":[7872764],"length":1,"stats":{"Line":8},"fn_name":null},{"line":700,"address":[7872776],"length":1,"stats":{"Line":8},"fn_name":null},{"line":701,"address":[7872788],"length":1,"stats":{"Line":8},"fn_name":null},{"line":702,"address":[7872856],"length":1,"stats":{"Line":8},"fn_name":null},{"line":708,"address":[7875172],"length":1,"stats":{"Line":8},"fn_name":null},{"line":709,"address":[7875240],"length":1,"stats":{"Line":8},"fn_name":null},{"line":710,"address":[7875252],"length":1,"stats":{"Line":8},"fn_name":null},{"line":716,"address":[7877444],"length":1,"stats":{"Line":8},"fn_name":null},{"line":717,"address":[7877512],"length":1,"stats":{"Line":8},"fn_name":null},{"line":718,"address":[7877580],"length":1,"stats":{"Line":8},"fn_name":null},{"line":724,"address":[7879780],"length":1,"stats":{"Line":8},"fn_name":null},{"line":725,"address":[7879848],"length":1,"stats":{"Line":8},"fn_name":null},{"line":726,"address":[7879860],"length":1,"stats":{"Line":8},"fn_name":null},{"line":727,"address":[7879872],"length":1,"stats":{"Line":8},"fn_name":null},{"line":728,"address":[7879940],"length":1,"stats":{"Line":8},"fn_name":null},{"line":734,"address":[7882212],"length":1,"stats":{"Line":8},"fn_name":null},{"line":735,"address":[7882280],"length":1,"stats":{"Line":8},"fn_name":null},{"line":736,"address":[7882348],"length":1,"stats":{"Line":8},"fn_name":null},{"line":742,"address":[7884548],"length":1,"stats":{"Line":8},"fn_name":null},{"line":743,"address":[7884616],"length":1,"stats":{"Line":8},"fn_name":null},{"line":744,"address":[7884684],"length":1,"stats":{"Line":8},"fn_name":null},{"line":745,"address":[7884696],"length":1,"stats":{"Line":8},"fn_name":null},{"line":751,"address":[7886932],"length":1,"stats":{"Line":8},"fn_name":null},{"line":752,"address":[7887000],"length":1,"stats":{"Line":8},"fn_name":null},{"line":753,"address":[7887068],"length":1,"stats":{"Line":8},"fn_name":null},{"line":754,"address":[7887136],"length":1,"stats":{"Line":8},"fn_name":null},{"line":760,"address":[7889380],"length":1,"stats":{"Line":8},"fn_name":null},{"line":761,"address":[7889448],"length":1,"stats":{"Line":8},"fn_name":null},{"line":762,"address":[7889516],"length":1,"stats":{"Line":8},"fn_name":null},{"line":763,"address":[7889528],"length":1,"stats":{"Line":8},"fn_name":null},{"line":764,"address":[7889540],"length":1,"stats":{"Line":8},"fn_name":null},{"line":765,"address":[7889608],"length":1,"stats":{"Line":8},"fn_name":null},{"line":771,"address":[7891924],"length":1,"stats":{"Line":8},"fn_name":null},{"line":772,"address":[7891992],"length":1,"stats":{"Line":8},"fn_name":null},{"line":773,"address":[7892060],"length":1,"stats":{"Line":8},"fn_name":null},{"line":774,"address":[7892128],"length":1,"stats":{"Line":8},"fn_name":null},{"line":776,"address":[7894372,7894334,7895852],"length":1,"stats":{"Line":13},"fn_name":null},{"line":777,"address":[7896574,7896612,7898092],"length":1,"stats":{"Line":13},"fn_name":null},{"line":778,"address":[7898814,7898852,7900228],"length":1,"stats":{"Line":13},"fn_name":null},{"line":779,"address":[7902460,7900980,7900942],"length":1,"stats":{"Line":13},"fn_name":null},{"line":780,"address":[7903220,7904700,7903182],"length":1,"stats":{"Line":13},"fn_name":null},{"line":781,"address":[7906836,7905460,7905422],"length":1,"stats":{"Line":13},"fn_name":null},{"line":784,"address":[7907588,7909068,7907550],"length":1,"stats":{"Line":13},"fn_name":null},{"line":785,"address":[7909828,7909790,7911252],"length":1,"stats":{"Line":13},"fn_name":null},{"line":786,"address":[7913484,7911966,7912004],"length":1,"stats":{"Line":13},"fn_name":null},{"line":787,"address":[7915724,7914244,7914206],"length":1,"stats":{"Line":13},"fn_name":null},{"line":788,"address":[7916446,7917964,7916484],"length":1,"stats":{"Line":13},"fn_name":null},{"line":789,"address":[7918686,7918724,7920204],"length":1,"stats":{"Line":13},"fn_name":null},{"line":790,"address":[7922444,7920926,7920964],"length":1,"stats":{"Line":13},"fn_name":null},{"line":791,"address":[7923166,7923204,7924684],"length":1,"stats":{"Line":13},"fn_name":null},{"line":792,"address":[7925444,7925406,7926924],"length":1,"stats":{"Line":13},"fn_name":null},{"line":793,"address":[7927684,7927646,7929060],"length":1,"stats":{"Line":13},"fn_name":null},{"line":794,"address":[7931292,7929812,7929774],"length":1,"stats":{"Line":13},"fn_name":null},{"line":795,"address":[7932052,7933532,7932014],"length":1,"stats":{"Line":13},"fn_name":null},{"line":796,"address":[7934292,7935772,7934254],"length":1,"stats":{"Line":13},"fn_name":null},{"line":797,"address":[7937852,7936532,7936494],"length":1,"stats":{"Line":13},"fn_name":null},{"line":798,"address":[7938558,7938596,7940076],"length":1,"stats":{"Line":13},"fn_name":null},{"line":799,"address":[7942316,7940836,7940798],"length":1,"stats":{"Line":13},"fn_name":null},{"line":800,"address":[7943038,7944556,7943076],"length":1,"stats":{"Line":13},"fn_name":null},{"line":801,"address":[7946740,7945316,7945278],"length":1,"stats":{"Line":13},"fn_name":null},{"line":802,"address":[7947454,7948972,7947492],"length":1,"stats":{"Line":13},"fn_name":null},{"line":803,"address":[7949694,7949732,7951212],"length":1,"stats":{"Line":13},"fn_name":null},{"line":804,"address":[7951934,7951972,7953452],"length":1,"stats":{"Line":13},"fn_name":null},{"line":805,"address":[7955692,7954174,7954212],"length":1,"stats":{"Line":13},"fn_name":null},{"line":806,"address":[7956452,7956414,7957932],"length":1,"stats":{"Line":13},"fn_name":null},{"line":807,"address":[7958654,7958692,7960172],"length":1,"stats":{"Line":13},"fn_name":null},{"line":808,"address":[7960894,7960932,7962412],"length":1,"stats":{"Line":13},"fn_name":null},{"line":809,"address":[7963134,7963172,7964596],"length":1,"stats":{"Line":13},"fn_name":null},{"line":810,"address":[7965310,7966828,7965348],"length":1,"stats":{"Line":13},"fn_name":null},{"line":815,"address":[7967588],"length":1,"stats":{"Line":8},"fn_name":null},{"line":816,"address":[7967656],"length":1,"stats":{"Line":8},"fn_name":null},{"line":818,"address":[7969790,7969828,7971308],"length":1,"stats":{"Line":13},"fn_name":null},{"line":819,"address":[7973548,7972030,7972068],"length":1,"stats":{"Line":13},"fn_name":null},{"line":820,"address":[7974308,7975788,7974270],"length":1,"stats":{"Line":13},"fn_name":null},{"line":821,"address":[7976548,7976510,7978028],"length":1,"stats":{"Line":13},"fn_name":null},{"line":822,"address":[7978750,7978788,7980268],"length":1,"stats":{"Line":13},"fn_name":null},{"line":823,"address":[7980990,7981028,7982508],"length":1,"stats":{"Line":13},"fn_name":null},{"line":828,"address":[7983268],"length":1,"stats":{"Line":8},"fn_name":null},{"line":829,"address":[7983336],"length":1,"stats":{"Line":8},"fn_name":null},{"line":831,"address":[7986988,7985508,7985470],"length":1,"stats":{"Line":13},"fn_name":null},{"line":832,"address":[7987710,7987748,7989228],"length":1,"stats":{"Line":13},"fn_name":null},{"line":833,"address":[7989950,7989988,7991412],"length":1,"stats":{"Line":13},"fn_name":null},{"line":838,"address":[7992164],"length":1,"stats":{"Line":8},"fn_name":null},{"line":839,"address":[7992232],"length":1,"stats":{"Line":8},"fn_name":null},{"line":841,"address":[7994404,7995828,7994366],"length":1,"stats":{"Line":13},"fn_name":null},{"line":846,"address":[7996580],"length":1,"stats":{"Line":8},"fn_name":null},{"line":847,"address":[7996648],"length":1,"stats":{"Line":8},"fn_name":null},{"line":853,"address":[7998820],"length":1,"stats":{"Line":8},"fn_name":null},{"line":854,"address":[7998888],"length":1,"stats":{"Line":8},"fn_name":null},{"line":855,"address":[7998900],"length":1,"stats":{"Line":8},"fn_name":null},{"line":861,"address":[8001092],"length":1,"stats":{"Line":8},"fn_name":null},{"line":862,"address":[8001160],"length":1,"stats":{"Line":8},"fn_name":null},{"line":863,"address":[8001228],"length":1,"stats":{"Line":8},"fn_name":null},{"line":869,"address":[8003428],"length":1,"stats":{"Line":8},"fn_name":null},{"line":870,"address":[8003496],"length":1,"stats":{"Line":8},"fn_name":null},{"line":871,"address":[8003564],"length":1,"stats":{"Line":8},"fn_name":null},{"line":877,"address":[8005764],"length":1,"stats":{"Line":8},"fn_name":null},{"line":878,"address":[8005832],"length":1,"stats":{"Line":8},"fn_name":null},{"line":879,"address":[8005900],"length":1,"stats":{"Line":8},"fn_name":null},{"line":885,"address":[8008100],"length":1,"stats":{"Line":8},"fn_name":null},{"line":886,"address":[8008168],"length":1,"stats":{"Line":8},"fn_name":null},{"line":887,"address":[8008236],"length":1,"stats":{"Line":8},"fn_name":null},{"line":893,"address":[8010436],"length":1,"stats":{"Line":8},"fn_name":null},{"line":894,"address":[8010504],"length":1,"stats":{"Line":8},"fn_name":null},{"line":895,"address":[8010572],"length":1,"stats":{"Line":8},"fn_name":null},{"line":901,"address":[8012772],"length":1,"stats":{"Line":8},"fn_name":null},{"line":902,"address":[8012840],"length":1,"stats":{"Line":8},"fn_name":null},{"line":903,"address":[8012908],"length":1,"stats":{"Line":8},"fn_name":null},{"line":909,"address":[8015108],"length":1,"stats":{"Line":8},"fn_name":null},{"line":910,"address":[8015176],"length":1,"stats":{"Line":8},"fn_name":null},{"line":911,"address":[8015244],"length":1,"stats":{"Line":8},"fn_name":null},{"line":917,"address":[8017444],"length":1,"stats":{"Line":8},"fn_name":null},{"line":918,"address":[8017512],"length":1,"stats":{"Line":8},"fn_name":null},{"line":919,"address":[8017580],"length":1,"stats":{"Line":8},"fn_name":null},{"line":923,"address":[8021100,8019735,8019780],"length":1,"stats":{"Line":13},"fn_name":null},{"line":924,"address":[8021844,8023164,8021799],"length":1,"stats":{"Line":13},"fn_name":null},{"line":925,"address":[8023863,8025228,8023908],"length":1,"stats":{"Line":13},"fn_name":null},{"line":926,"address":[8025927,8025972,8027292],"length":1,"stats":{"Line":13},"fn_name":null},{"line":927,"address":[8029356,8027991,8028036],"length":1,"stats":{"Line":13},"fn_name":null},{"line":928,"address":[8031420,8030100,8030055],"length":1,"stats":{"Line":13},"fn_name":null},{"line":929,"address":[8032119,8033540,8032164],"length":1,"stats":{"Line":13},"fn_name":null},{"line":934,"address":[8034292],"length":1,"stats":{"Line":8},"fn_name":null},{"line":935,"address":[8034360],"length":1,"stats":{"Line":8},"fn_name":null},{"line":936,"address":[8034428],"length":1,"stats":{"Line":8},"fn_name":null},{"line":937,"address":[8034440],"length":1,"stats":{"Line":8},"fn_name":null},{"line":939,"address":[8037996,8036676,8036638],"length":1,"stats":{"Line":13},"fn_name":null},{"line":940,"address":[8038702,8038740,8040060],"length":1,"stats":{"Line":13},"fn_name":null},{"line":945,"address":[8040804],"length":1,"stats":{"Line":8},"fn_name":null},{"line":946,"address":[8040872],"length":1,"stats":{"Line":8},"fn_name":null},{"line":947,"address":[8040940],"length":1,"stats":{"Line":8},"fn_name":null},{"line":948,"address":[8040952],"length":1,"stats":{"Line":8},"fn_name":null},{"line":950,"address":[8044508,8043188,8043150],"length":1,"stats":{"Line":13},"fn_name":null},{"line":951,"address":[8046572,8045252,8045214],"length":1,"stats":{"Line":13},"fn_name":null},{"line":956,"address":[8047316],"length":1,"stats":{"Line":8},"fn_name":null},{"line":957,"address":[8047384],"length":1,"stats":{"Line":8},"fn_name":null},{"line":958,"address":[8047452],"length":1,"stats":{"Line":8},"fn_name":null},{"line":959,"address":[8047464],"length":1,"stats":{"Line":8},"fn_name":null},{"line":965,"address":[8049700],"length":1,"stats":{"Line":8},"fn_name":null},{"line":966,"address":[8049768],"length":1,"stats":{"Line":8},"fn_name":null},{"line":967,"address":[8049836],"length":1,"stats":{"Line":8},"fn_name":null},{"line":968,"address":[8049904],"length":1,"stats":{"Line":8},"fn_name":null},{"line":974,"address":[8052084],"length":1,"stats":{"Line":8},"fn_name":null},{"line":975,"address":[8052152],"length":1,"stats":{"Line":8},"fn_name":null},{"line":976,"address":[8052220],"length":1,"stats":{"Line":8},"fn_name":null},{"line":977,"address":[8052232],"length":1,"stats":{"Line":8},"fn_name":null},{"line":978,"address":[8052300],"length":1,"stats":{"Line":8},"fn_name":null},{"line":979,"address":[8052368],"length":1,"stats":{"Line":8},"fn_name":null},{"line":980,"address":[8052380],"length":1,"stats":{"Line":8},"fn_name":null},{"line":982,"address":[8054740,8054702,8056060],"length":1,"stats":{"Line":13},"fn_name":null},{"line":987,"address":[8056804],"length":1,"stats":{"Line":8},"fn_name":null},{"line":988,"address":[8056872],"length":1,"stats":{"Line":8},"fn_name":null},{"line":989,"address":[8056940],"length":1,"stats":{"Line":8},"fn_name":null},{"line":990,"address":[8057008],"length":1,"stats":{"Line":8},"fn_name":null},{"line":996,"address":[8059188],"length":1,"stats":{"Line":8},"fn_name":null},{"line":997,"address":[8059256],"length":1,"stats":{"Line":8},"fn_name":null},{"line":998,"address":[8059324],"length":1,"stats":{"Line":8},"fn_name":null},{"line":999,"address":[8059336],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1001,"address":[8062892,8061534,8061572],"length":1,"stats":{"Line":13},"fn_name":null},{"line":1006,"address":[8063636],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1007,"address":[8063704],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1008,"address":[8063772],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1009,"address":[8063840],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1015,"address":[8066020],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1016,"address":[8066088],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1017,"address":[8066156],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1018,"address":[8066224],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1024,"address":[8068404],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1025,"address":[8068472],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1026,"address":[8068540],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1027,"address":[8068608],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1028,"address":[8068620],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1029,"address":[8068688],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1030,"address":[8068700],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1036,"address":[8071060],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1037,"address":[8071128],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1038,"address":[8071196],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1039,"address":[8071208],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1040,"address":[8071276],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1041,"address":[8071344],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1042,"address":[8071356],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1043,"address":[8071424],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1044,"address":[8071492],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1045,"address":[8071504],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1051,"address":[8074004],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1052,"address":[8074072],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1053,"address":[8074140],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1054,"address":[8074208],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1060,"address":[8076388],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1061,"address":[8076456],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1062,"address":[8076524],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1063,"address":[8076592],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1069,"address":[8078836],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1070,"address":[8078904],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1071,"address":[8078972],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1072,"address":[8078984],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1078,"address":[8081220],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1079,"address":[8081288],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1080,"address":[8081356],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1081,"address":[8081424],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1087,"address":[8083668],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1088,"address":[8083736],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1089,"address":[8083804],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1090,"address":[8083872],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1096,"address":[8086052],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1097,"address":[8086120],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1098,"address":[8086188],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1099,"address":[8086256],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1100,"address":[8086268],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1101,"address":[8086336],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1102,"address":[8086404],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1108,"address":[8088708],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1109,"address":[8088776],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1110,"address":[8088844],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1111,"address":[8088912],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1112,"address":[8088924],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1113,"address":[8088992],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1114,"address":[8089004],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1115,"address":[8089072],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1116,"address":[8089140],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1117,"address":[8089152],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1123,"address":[8091652],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1124,"address":[8091720],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1125,"address":[8091788],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1126,"address":[8091856],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1132,"address":[8094036],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1133,"address":[8094104],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1134,"address":[8094172],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1135,"address":[8094240],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1141,"address":[8096420],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1142,"address":[8096488],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1143,"address":[8096556],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1144,"address":[8096624],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1150,"address":[8098868],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1151,"address":[8098936],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1152,"address":[8099004],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1153,"address":[8099072],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1159,"address":[8101252],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1160,"address":[8101320],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1161,"address":[8101388],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1162,"address":[8101456],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1168,"address":[8103636],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1169,"address":[8103704],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1170,"address":[8103772],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1171,"address":[8103840],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1172,"address":[8103852],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1173,"address":[8103920],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1174,"address":[8103988],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1180,"address":[8106292],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1181,"address":[8106360],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1182,"address":[8106428],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1183,"address":[8106496],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1184,"address":[8106508],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1185,"address":[8106576],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1186,"address":[8106644],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1187,"address":[8106656],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1188,"address":[8106724],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1189,"address":[8106736],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1195,"address":[8109236],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1196,"address":[8109304],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1197,"address":[8109372],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1198,"address":[8109440],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1204,"address":[8111620],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1205,"address":[8111688],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1206,"address":[8111756],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1207,"address":[8111824],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1213,"address":[8114004],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1214,"address":[8114072],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1215,"address":[8114140],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1216,"address":[8114208],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1222,"address":[8116452],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1223,"address":[8116520],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1224,"address":[8116588],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1225,"address":[8116656],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1231,"address":[8118900],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1232,"address":[8118968],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1233,"address":[8119036],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1234,"address":[8119104],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1240,"address":[8121284],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1241,"address":[8121352],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1242,"address":[8121420],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1243,"address":[8121488],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1244,"address":[8121500],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1245,"address":[8121568],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1246,"address":[8121636],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1252,"address":[8123940],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1253,"address":[8124008],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1254,"address":[8124076],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1255,"address":[8124144],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1256,"address":[8124156],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1257,"address":[8124224],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1258,"address":[8124292],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1259,"address":[8124304],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1260,"address":[8124372],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1261,"address":[8124440],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1267,"address":[8126884],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1268,"address":[8126952],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1269,"address":[8127020],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1270,"address":[8127088],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1276,"address":[8129268],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1277,"address":[8129336],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1278,"address":[8129404],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1279,"address":[8129472],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1285,"address":[8131652],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1286,"address":[8131720],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1287,"address":[8131788],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1288,"address":[8131856],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1294,"address":[8134036],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1295,"address":[8134104],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1296,"address":[8134172],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1297,"address":[8134240],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1303,"address":[8136420],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1304,"address":[8136488],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1310,"address":[8138660],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1311,"address":[8138728],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1317,"address":[8140900],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1318,"address":[8140968],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1324,"address":[8143140],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1325,"address":[8143208],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1331,"address":[8145380],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1332,"address":[8145448],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1338,"address":[8147620],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1339,"address":[8147688],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1345,"address":[8149860],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1346,"address":[8149928],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1352,"address":[8152100],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1353,"address":[8152168],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1359,"address":[8154340],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1360,"address":[8154408],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1366,"address":[8156580],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1367,"address":[8156648],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1373,"address":[8158820],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1374,"address":[8158888],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1380,"address":[8161060],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1381,"address":[8161128],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1387,"address":[8163300],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1388,"address":[8163368],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1394,"address":[8165540],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1395,"address":[8165608],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1401,"address":[8167780],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1402,"address":[8167848],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1408,"address":[8170020],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1409,"address":[8170088],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1415,"address":[8172260],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1416,"address":[8172328],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1422,"address":[8174500],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1423,"address":[8174568],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1429,"address":[8176740],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1430,"address":[8176808],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1431,"address":[8176876],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1437,"address":[8179076],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1438,"address":[8179144],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1439,"address":[8179212],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1445,"address":[8181412],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1446,"address":[8181480],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1447,"address":[8181548],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1453,"address":[8183748],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1454,"address":[8183816],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1455,"address":[8183884],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1457,"address":[8186084,8187404,8186046],"length":1,"stats":{"Line":13},"fn_name":null},{"line":1462,"address":[8188148],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1463,"address":[8188216],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1464,"address":[8188284],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1470,"address":[8190484],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1471,"address":[8190552],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1472,"address":[8190620],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1478,"address":[8192820],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1479,"address":[8192888],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1480,"address":[8192956],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1486,"address":[8195156],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1487,"address":[8195224],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1488,"address":[8195292],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1490,"address":[8197492,8198812,8197454],"length":1,"stats":{"Line":13},"fn_name":null},{"line":1495,"address":[8199556],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1496,"address":[8199624],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1497,"address":[8199692],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1503,"address":[8201892],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1504,"address":[8201960],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1505,"address":[8202028],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1511,"address":[8204228],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1512,"address":[8204296],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1513,"address":[8204364],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1519,"address":[8206564],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1520,"address":[8206632],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1521,"address":[8206700],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1527,"address":[8208900],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1528,"address":[8208968],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1529,"address":[8209036],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1535,"address":[8211236],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1536,"address":[8211304],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1537,"address":[8211372],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1539,"address":[8213534,8213572,8214892],"length":1,"stats":{"Line":13},"fn_name":null},{"line":1544,"address":[8215636],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1545,"address":[8215704],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1546,"address":[8215772],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1552,"address":[8217972],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1553,"address":[8218040],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1554,"address":[8218108],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1560,"address":[8220308],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1561,"address":[8220376],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1562,"address":[8220444],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1568,"address":[8222644],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1569,"address":[8222712],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1570,"address":[8222780],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1572,"address":[8224942,8224980,8226300],"length":1,"stats":{"Line":13},"fn_name":null},{"line":1577,"address":[8227044],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1578,"address":[8227112],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1579,"address":[8227180],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1585,"address":[8229380],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1586,"address":[8229448],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1587,"address":[8229516],"length":1,"stats":{"Line":8},"fn_name":null}],"covered":723,"coverable":723},{"path":["/","usr","src","regex","tests","macros.rs"],"content":"// Convenience macros.\n\nmacro_rules! findall {\n    ($re:expr, $text:expr) => {{\n        $re.find_iter(text!($text))\n           .map(|m| (m.start(), m.end())).collect::<Vec<_>>()\n    }}\n}\n\n// Macros for automatically producing tests.\n\nmacro_rules! ismatch {\n    ($name:ident, $re:expr, $text:expr, $ismatch:expr) => {\n        #[test]\n        fn $name() {\n            let re = regex!($re);\n            assert_eq!($ismatch, re.is_match(text!($text)));\n        }\n    };\n}\n\nmacro_rules! mat(\n    ($name:ident, $re:expr, $text:expr, $($loc:tt)+) => (\n        #[test]\n        fn $name() {\n            let text = text!($text);\n            let expected: Vec<Option<_>> = vec![$($loc)+];\n            let r = regex!($re);\n            let got: Vec<Option<_>> = match r.captures(text) {\n                Some(c) => {\n                    assert!(r.is_match(text));\n                    assert!(r.shortest_match(text).is_some());\n                    r.capture_names()\n                     .enumerate()\n                     .map(|(i, _)| c.get(i).map(|m| (m.start(), m.end())))\n                     .collect()\n                }\n                None => vec![None],\n            };\n            // The test set sometimes leave out capture groups, so truncate\n            // actual capture groups to match test set.\n            let mut sgot = &got[..];\n            if sgot.len() > expected.len() {\n                sgot = &sgot[0..expected.len()]\n            }\n            if expected != sgot {\n                panic!(\"For RE '{}' against '{:?}', \\\n                        expected '{:?}' but got '{:?}'\",\n                       $re, text, expected, sgot);\n            }\n        }\n    );\n);\n\nmacro_rules! matiter(\n    ($name:ident, $re:expr, $text:expr) => (\n        #[test]\n        fn $name() {\n            let text = text!($text);\n            let expected: Vec<(usize, usize)> = vec![];\n            let r = regex!($re);\n            let got: Vec<_> =\n                r.find_iter(text).map(|m| (m.start(), m.end())).collect();\n            if expected != got {\n                panic!(\"For RE '{}' against '{:?}', \\\n                        expected '{:?}' but got '{:?}'\",\n                       $re, text, expected, got);\n            }\n            let captures_got: Vec<_> =\n                r.captures_iter(text)\n                 .map(|c| c.get(0).unwrap())\n                 .map(|m| (m.start(), m.end()))\n                 .collect();\n            if captures_got != got {\n                panic!(\"For RE '{}' against '{:?}', \\\n                        got '{:?}' using find_iter but got '{:?}' \\\n                        using captures_iter\",\n                       $re, text, got, captures_got);\n            }\n        }\n    );\n    ($name:ident, $re:expr, $text:expr, $($loc:tt)+) => (\n        #[test]\n        fn $name() {\n            let text = text!($text);\n            let expected: Vec<_> = vec![$($loc)+];\n            let r = regex!($re);\n            let got: Vec<_> =\n                r.find_iter(text).map(|m| (m.start(), m.end())).collect();\n            if expected != got {\n                panic!(\"For RE '{}' against '{:?}', \\\n                        expected '{:?}' but got '{:?}'\",\n                       $re, text, expected, got);\n            }\n            let captures_got: Vec<_> =\n                r.captures_iter(text)\n                 .map(|c| c.get(0).unwrap())\n                 .map(|m| (m.start(), m.end()))\n                 .collect();\n            if captures_got != got {\n                panic!(\"For RE '{}' against '{:?}', \\\n                        got '{:?}' using find_iter but got '{:?}' \\\n                        using captures_iter\",\n                       $re, text, got, captures_got);\n            }\n        }\n    );\n);\n\nmacro_rules! matset {\n    ($name:ident, $res:expr, $text:expr, $($match_index:expr),*) => {\n        #[test]\n        fn $name() {\n            let text = text!($text);\n            let set = regex_set!($res);\n            assert!(set.is_match(text));\n            let expected = vec![$($match_index),*];\n            let matches = set.matches(text);\n            assert!(matches.matched_any());\n            let got: Vec<_> = matches.into_iter().collect();\n            assert_eq!(expected, got);\n        }\n    }\n}\n\nmacro_rules! nomatset {\n    ($name:ident, $res:expr, $text:expr) => {\n        #[test]\n        fn $name() {\n            let text = text!($text);\n            let set = regex_set!($res);\n            assert!(!set.is_match(text));\n            let matches = set.matches(text);\n            assert!(!matches.matched_any());\n            assert_eq!(0, matches.into_iter().count());\n        }\n    }\n}\n\nmacro_rules! split {\n    ($name:ident, $re:expr, $text:expr, $expected:expr) => {\n        #[test]\n        fn $name() {\n            let re = regex!($re);\n            let splitted: Vec<_> = re.split(t!($text)).collect();\n            assert_eq!($expected, &*splitted);\n        }\n    }\n}\n\nmacro_rules! splitn {\n    ($name:ident, $re:expr, $text:expr, $limit:expr, $expected:expr) => {\n        #[test]\n        fn $name() {\n            let re = regex!($re);\n            let splitted: Vec<_> = re.splitn(t!($text), $limit).collect();\n            assert_eq!($expected, &*splitted);\n        }\n    }\n}\n","traces":[{"line":6,"address":[4231312,4231321],"length":1,"stats":{"Line":186},"fn_name":"{{closure}}"},{"line":15,"address":[7186208,7189989,7189872,7186320,7189984,7186213,7189877,7190837,7186325,7189760,7189765,7190832,7188293,7188288,7188069,7188176,7188064,7188400,7188405,7188181],"length":1,"stats":{"Line":240},"fn_name":"{{closure}}"},{"line":16,"address":[7418565,7432373,7433022,7433749,7434398,7443685,7445061,7444334,7434437,7417838,7433710,7445022,7417877,7432334,7450613,7418526,7433061,7444373,7443646,7450574],"length":1,"stats":{"Line":160},"fn_name":null},{"line":17,"address":[7444671,7432668,7445359,7434735,7450733,7444493,7433356,7450911,7432493,7418863,7433181,7433869,7443983,7443805,7445181,7418685,7434047,7417997,7434557,7418175],"length":1,"stats":{"Line":140},"fn_name":null},{"line":25,"address":[6009504,6003797,6016309,6010864,6017669,5996997,6005968,5997541,6001621,6007605,6014949,6012496,6013584,6015493,5998352,5996448,6013312,5996181,6008965,6001893,6006245,5996992,6001616,6009776,5995360,6012229,6010592,6012224,6011685,6013861,6014677,6002976,6002981,5995909,6004064,6000261,6004613,6016304,6003248,6003792,6011141,6011952,6016032,6003525,6011680,6009237,6002704,6017397,6004880,6001072,6007333,6011136,6007872,6013045,6017664,6016853,6014944,6007328,6005429,5999168,6004341,6006512,6010325,6010869,6001888,6008421,6015760,6007061,6002432,5997264,5999989,6008688,6005157,6005973,6012501,6014405,6016576,5998629,6008693,5996176,5999173,6004885,5998624,6002160,6000528,5995637,6001077,6004608,6008416,6001349,5997813,6001344,6013040,6016848,6017120,6015221,5995093,6002437,6008960,6004069,6007877,5997269,6003520,6005424,6015765,6009781,5997536,6000533,6010597,6015216,5999712,6000805,6004336,5995088,6013589,5998896,5995632,5996453,6012773,5997808,6010053,6005696,6011413,6007056,5996720,5999445,5996725,6008144,6009232,6007600,6002709,6011957,6012768,5998357,6006240,6005152,6006789,5998080,6014133,6000256,5999717,6006517,5995904,6003253,6016581,5995365,6017125,5999984,6010048,5999440,6002165,6013317,6010320,6000800,6005701,6014128,6014400,6016037,6008149,6011408,6014672,6015488,5998901,6013856,6006784,6009509,6017392,5998085],"length":1,"stats":{"Line":12276},"fn_name":"{{closure}}"},{"line":26,"address":[4973206,4953670,5206342,4506694,4475398,4634246,4958022,4683782,4997094,4508966,5164134,4544310,5102726,5040150,4588310,4964502,4709142,4485718,4829734,4781174,5023334,4609478,4702774,4598838,4751766,4847622,4615670,4886070,4852230,5117094,5077718,4502454,5082646,4825334,4968854,5202054,4840742,5112166,5085526,4814214,5170758,4947142,5012998,5114502,4526966,5126982,4659014,4467142,4517974,4581798,4481590,4648694,4656950,4619798,4640438,4897686,5033782,5188678,4671398,4776054,4876822,4949318,4673462,4765302,5135846,4914822,5019302,5049430,4504518,4491910,4721990,4747414,5179590,4535718,4869926,5146726,4524694,4550502,4809766,4711270,4906166,5031766,4692038,5035798,5124646,4767366,4849958,5155430,5175302,4592438,4865574,4687910,5001638,5017286,5021318,4932118,4607414,4899750,5184134,4749590,4724054,4583862,4489846,4704838,4977558,4498102,4477462,4845286,4513206,4567350,4916998,4805318,4667270,4901926,4617734,5029430,5142374,4785510,4552678,4904102,5159782,4611542,5010726,5168486,4955846,4663142,4594502,4923526,4556918,4992694,5138022,5177574,4771606,4783446,5092582,5186406,4628054,5006182,5107398,5065398,4843014,4919174,4623926,5105062,5210886,5122310,4895510,5219718,4863398,4563222,4469206,4838470,5087862,4962326,4632182,4773878,4745238,4728406,5140198,4791974,4644566,4596566,4565286,4554854,4803094,4888454,4940662,4981910,5058134,4694102,4823110,4893334,4927766,4960198,4874598,4571478,4603286,5003910,4590374,4861126,4496038,4934294,5056118,5129318,4856582,4685846,5199782,4546374,4760646,4696166,4636310,4883734,4605350,4533542,4569414,4483654,4630118,4758582,4986262,5080054,5099846,4642502,5166310,4575606,5195238,5060470,4661078,5072998,4811990,4548438,5075334,4539958,5070614,4966678,4730470,5042166,4944966,4625990,4542134,4479526,4700710,4921350,5008454,5015270,4585926,4573542,5068278,5213158,4679654,4681718,4787686,4975382,4831798,4698438,4754038,4520246,4522518,4938486,5044502,4736870,4942838,4879094,5090198,4675526,5027366,4719862,4796422,4769430,5161958,4833974,4493974,5208614,4872102,4984086,4789750,4820886,4734806,4818662,4827558,4867750,4515590,4910470,5051446,4798646,4912646,4677590,4726230,4908342,4529142,5192966,4558982,4613606,5038134,5197510,5109782,5204326,4800870,4511142,4988390,4601110,4999366,5025350,4732646,4854406,4646630,4531318,5173030,5181862,5215430,5097254,4715622,4561158,4537782,4858854,4979734,4971030,4654886,5217446,4816438,5053782,5151078,4990566,4762822,4881462,4836246,4890950,4779110,4473334,4621862,4669334,4794198,4925702,4936310,4994870,4807542,5131494,4951494,4740998,5133670,4665206,4929942,4577670,5190694,4652822,4713446,5148902,4579734,5153254,5062806,4471270,5144550,4650758,4638374,4689974,5157606,4717798,4738934,4706966,4756310,4487782,5046838,4500278,5094918,5119974,4743174],"length":1,"stats":{"Line":1579},"fn_name":null},{"line":27,"address":[5853456,5857704,5922946,5897410,5863938,5929416,5855576,5893240,5901752,5908136,5916562,5870258,5866066,5872416,5859832,5918690,5901666,5874480,5903794,5920818,5855490,5874450,5912306,5918776,5910178,5895368,5927288,5888984,5870344,5851384,5914434,5905922,5861904,5923032,5925160,5888898,5859746,5853426,5868216,5866096,5864024,5851298,5910264,5912392,5857618,5868130,5891112,5903880,5914520,5897496,5927202,5899538,5920904,5849170,5872386,5916648,5929330,5849256,5891026,5861874,5893154,5899624,5906008,5908050,5925074,5895282],"length":1,"stats":{"Line":8168},"fn_name":null},{"line":28,"address":[5851457,5897642,5855722,5927434,5925233,5923105,5849402,5857777,5899770,5857850,5901825,5916721,5904026,5864097,5859905,5920977,5874553,5889057,5849329,5903953,5906081,5864170,5912465,5862050,5929489,5929562,5910337,5872489,5891258,5918849,5914593,5925306,5866242,5861977,5891185,5893386,5914666,5897569,5901898,5853602,5870417,5851530,5912538,5853529,5906154,5889130,5899697,5908282,5870490,5895514,5927361,5859978,5868362,5921050,5855649,5908209,5918922,5893313,5910410,5868289,5916794,5874626,5866169,5872562,5895441,5923178],"length":1,"stats":{"Line":7150},"fn_name":null},{"line":29,"address":[5869112,5868637,5849677,5904776,5904301,5862325,5912813,5923290,5850152,5873312,5925418,5856472,5899882,5910685,5872837,5897917,5860253,5858600,5897754,5912650,5906266,5875376,5917069,5926056,5891533,5900520,5930312,5860090,5851642,5866992,5853877,5910522,5913288,5915416,5916906,5928184,5929837,5929674,5862800,5904138,5874738,5906904,5870602,5891370,5862162,5896264,5854352,5919034,5860728,5921800,5868474,5895789,5902173,5870765,5909032,5857962,5914778,5902648,5895626,5892008,5923928,5902010,5855997,5898392,5864445,5889880,5906429,5908394,5919672,5889242,5864282,5851805,5872674,5900045,5921325,5923453,5874901,5927546,5864920,5914941,5852280,5853714,5894136,5919197,5866354,5893498,5908557,5858125,5893661,5911160,5917544,5889405,5921162,5866517,5925581,5871240,5849514,5927709,5855834],"length":1,"stats":{"Line":7902},"fn_name":null},{"line":30,"address":[6026319,6032581,6032703,6030575,6030453,6028447,6021941,6024191,6028325,6022063,6024069,6026197],"length":1,"stats":{"Line":7902},"fn_name":null},{"line":31,"address":[6022240,6024239,6030752,6028495,6026367,6028624,6024368,6022111,6030623,6032751,6026496,6032880],"length":1,"stats":{"Line":3810},"fn_name":null},{"line":32,"address":[6028763,6030891,6026445,6022189,6024409,6028665,6028573,6026635,6032921,6022281,6033019,6024507,6030701,6032829,6026537,6030793,6024317,6022379],"length":1,"stats":{"Line":7620},"fn_name":null},{"line":33,"address":[6024472,6026719,6022412,6022463,6022344,6024540,6026600,6026668,6033052,6028796,6024591,6028728,6030856,6028847,6030924,6030975,6032984,6033103],"length":1,"stats":{"Line":11430},"fn_name":null},{"line":35,"address":[6022455,6028839,6030967,6033095,6024583,6026711],"length":1,"stats":{"Line":19050},"fn_name":null},{"line":38,"address":[6022517,6028557,6032813,6033157,6030507,6026251,6024301,6030685,6026773,6026429,6031029,6032635,6024645,6028901,6024123,6021995,6022173,6028379],"length":1,"stats":{"Line":4092},"fn_name":null},{"line":42,"address":[5920647,5856508,5864956,5871276,5875412,5867967,5903623,5911196,5922775,5924903,5913324,5926092,5872215,5928220,5860764,5851127,5858636,5861703,5927031,5855327,5870087,5907879,5931287,5869148,5867028,5863775,5862836,5905751,5914263,5915452,5889916,5865895,5904812,5850188,5906940,5898428,5854388,5896300,5873348,5909068,5892983,5923964,5930348,5852316,5901495,5929159,5895111,5902684,5890855,5916391,5919708,5899367,5921836,5900556,5897239,5918519,5859575,5892044,5917580,5894172,5910007,5857447,5876351,5912135,5853255,5874287],"length":1,"stats":{"Line":8184},"fn_name":null},{"line":43,"address":[5856564,5862892,5852372,5854444,5902740,5865012,5913380,5875468,5894228,5900612,5898484,5867084,5871332,5915508,5928276,5904868,5926148,5930404,5860820,5896356,5858692,5917636,5924020,5850244,5873404,5909124,5919764,5869204,5892100,5889972,5921892,5906996,5911252],"length":1,"stats":{"Line":4092},"fn_name":null},{"line":44,"address":[5902819,5917715,5862971,5873483,5909203,5875547,5869283,5921971,5865091,5860899,5892179,5856643,5907075,5896435,5894307,5924099,5926227,5858771,5898563,5915587,5911331,5913459,5904947,5930483,5867163,5854523,5871411,5890051,5928355,5850323,5919843,5852451,5900691],"length":1,"stats":{"Line":363},"fn_name":null},{"line":46,"address":[5894496,5928544,5873672,5858960,5926416,5922160,5856832,5915776,5898752,5907264,5924288,5900880,5852640,5896624,5854712,5861088,5930672,5909392,5911520,5875736,5865280,5890240,5892368,5869472,5920032,5863160,5917904,5903008,5905136,5913648,5871600,5867352,5850512],"length":1,"stats":{"Line":4092},"fn_name":null},{"line":47,"address":[5850557,5892427,5863205,5900925,5867411,5871659,5913707,5924347,5854771,5928603,5890299,5871645,5890285,5907323,5867397,5861147,5905195,5907309,5854757,5859005,5873731,5930717,5852685,5926461,5896683,5928589,5917949,5911565,5875781,5894555,5905181,5865339,5894541,5913693,5920077,5869517,5911579,5922205,5930731,5865325,5863219,5859019,5852699,5898797,5903067,5875795,5915821,5869531,5850571,5900939,5926475,5861133,5915835,5920091,5873717,5896669,5909437,5922219,5917963,5924333,5898811,5856877,5892413,5856891,5909451,5903053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[5844789,5820597,5825776,5830096,5833552,5837440,5812816,5829669,5832256,5831392,5838309,5820592,5838741,5843061,5810656,5839600,5843056,5844352,5840032,5839605,5833557,5843488,5824048,5838736,5825781,5840896,5821456,5826645,5840037,5817573,5826640,5839168,5840901,5810661,5829664,5841760,5844784,5812821,5837445,5830528,5832688,5831397,5835280,5842624,5843493,5830101,5844357,5829232,5842629,5824480,5832261,5839173,5817568,5835285,5829237,5824485,5832693,5830533,5821461,5841765,5838304,5824053],"length":1,"stats":{"Line":852},"fn_name":"{{closure}}"},{"line":59,"address":[5344054],"length":1,"stats":{"Line":109},"fn_name":null},{"line":60,"address":[6653350],"length":1,"stats":{"Line":284},"fn_name":null},{"line":61,"address":[6653470,6653396],"length":1,"stats":{"Line":497},"fn_name":null},{"line":63,"address":[5832377,5835392,5820704,5844464,5840144,5830208,5825888,5838857,5825897,5843609,5843177,5821577,5833673,5832800,5829344,5830649,5832809,5844905,5838848,5824601,5838416,5829353,5837561,5830640,5810777,5838425,5812928,5826752,5824160,5829776,5844473,5817680,5839712,5833664,5839289,5843600,5841008,5829785,5824592,5832368,5843168,5837552,5824169,5841881,5835401,5817689,5810768,5831513,5812937,5820713,5826761,5839721,5841017,5839280,5831504,5842736,5821568,5844896,5840153,5842745,5830217,5841872],"length":1,"stats":{"Line":568},"fn_name":"{{closure}}"},{"line":64,"address":[6653706],"length":1,"stats":{"Line":284},"fn_name":null},{"line":65,"address":[6653809,6653795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[6653749,6654431],"length":1,"stats":{"Line":568},"fn_name":null},{"line":71,"address":[5821660,5830720,5841100,5830300,5821648,5844988,5810848,5844556,5824672,5843260,5841952,5825968,5826844,5830732,5835484,5838940,5842816,5829436,5810860,5841964,5838496,5820784,5835472,5838508,5840236,5813020,5841088,5829868,5824252,5832880,5829424,5837632,5843692,5817760,5829856,5831584,5842828,5839792,5840224,5837644,5820796,5817772,5813008,5843680,5824240,5838928,5833756,5830288,5832460,5832448,5839372,5844976,5824684,5832892,5833744,5831596,5839360,5844544,5843248,5839804,5826832,5825980],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":72,"address":[5839088,5842121,5817920,5831753,5839961,5832617,5839529,5835641,5833904,5833049,5843849,5838656,5842985,5843408,5840393,5817929,5826128,5811017,5830016,5837792,5839952,5844713,5826137,5813177,5821808,5841248,5843417,5829593,5830448,5835632,5832608,5831744,5829584,5820953,5811008,5830880,5842976,5824841,5845145,5824832,5830457,5821817,5833913,5840384,5845136,5830889,5824409,5830025,5839097,5839520,5844704,5827001,5837801,5841257,5838665,5820944,5824400,5833040,5842112,5843840,5813168,5826992],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":74,"address":[6654500],"length":1,"stats":{"Line":284},"fn_name":null},{"line":75,"address":[6654568,6654582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[5819301,5827072,5811957,5818437,5825344,5827509,5831824,5819296,5825349,5831829,5833984,5840469,5843920,5819728,5822320,5830960,5826213,5816272,5814112,5827504,5814981,5842197,5818000,5828805,5841333,5827941,5815413,5820160,5814544,5811520,5845648,5845653,5836144,5813685,5818869,5827077,5813248,5811088,5815408,5822757,5818864,5828373,5815840,5830965,5833125,5822752,5816277,5822325,5824917,5834416,5816704,5834853,5836149,5824912,5812384,5819733,5823189,5833989,5835717,5817136,5836581,5837877,5845216,5821888,5827936,5814117,5812389,5813680,5823184,5821029,5823621,5817141,5814549,5828368,5845221,5818005,5840464,5821893,5828800,5826208,5833120,5842192,5811093,5821024,5837008,5837013,5811525,5834421,5836576,5841328,5813253,5811952,5816709,5820165,5834848,5835712,5814976,5837872,5815845,5823616,5843925,5818432],"length":1,"stats":{"Line":2682},"fn_name":"{{closure}}"},{"line":85,"address":[4326102,4332246,4315830,4247814,4301430,4307622,4237974,4293174,4303494,4334310,4313766,4311750,4295238,4336374,4245654,4319910,4328166,4305558,4291254,4321974,4330230,4239894,4243734,4297302,4309686,4317846,4324038,4241814,4299366],"length":1,"stats":{"Line":343},"fn_name":null},{"line":86,"address":[5931458,5963138,5961010,5971740,5880524,5948338,5931500,5946324,5978052,5971650,5939826,5948452,5933556,5969636,5886836,5939940,5977986,5969522,5935570,5878540,5880482,5954788,5946210,5950580,5952594,5937812,5958882,5975972,5878498,5965266,5876514,5942068,5963252,5950466,5884612,5933442,5952684,5944196,5967508,5973730,5973844,5954674,5882466,5944082,5876556,5975858,5958996,5956802,5935684,5967394,5941954,5965380,5886674,5961124,5884450,5937698,5956892,5882508],"length":1,"stats":{"Line":1788},"fn_name":null},{"line":87,"address":[5973978,5942276,5974052,5961258,5967716,5876618,5940074,5948586,5933763,5963460,5942202,5950788,5933690,5880586,5935818,5876692,5935892,5878676,5961332,5967642,5954922,5969770,5931635,5937946,5971850,5882644,5978212,5946458,5884868,5887092,5965588,5948660,5944330,5976106,5884794,5938020,5957076,5971924,5940148,5946532,5976180,5880660,5959204,5978138,5931562,5887018,5954996,5882570,5878602,5969844,5952794,5965514,5959130,5950714,5944404,5952868,5957002,5963386],"length":1,"stats":{"Line":1563},"fn_name":null},{"line":89,"address":[5811641,5823728,5836256,5817248,5825456,5834969,5823305,5844032,5823296,5845337,5819417,5820281,5828912,5815952,5837120,5835833,5837984,5822441,5823737,5814665,5815088,5818976,5822432,5827184,5836697,5811209,5840585,5833241,5826329,5815520,5831081,5813360,5815529,5828057,5821136,5841449,5812505,5842304,5818112,5822009,5833232,5816384,5834528,5820272,5811200,5842313,5827193,5812073,5816393,5834960,5812064,5815097,5827616,5831072,5834105,5828489,5841440,5845769,5813801,5831936,5844041,5821145,5816816,5818553,5814224,5813792,5814656,5835824,5813369,5840576,5828480,5819408,5836688,5845328,5822864,5826320,5828048,5811632,5818985,5812496,5817257,5827625,5822000,5831945,5834096,5834537,5822873,5828921,5837129,5837993,5816825,5845760,5825465,5815961,5819840,5825033,5814233,5818544,5819849,5825024,5836265,5818121],"length":1,"stats":{"Line":3576},"fn_name":"{{closure}}"},{"line":90,"address":[5972160,5959440,5938256,5948896,5961568,5946768,5940384,5976416,5963696,5882880,5942512,5955232,5951024,5876928,5933999,5957312,5970080,5978448,5965824,5974288,5878912,5880896,5953104,5967952,5944640,5931871,5936128,5887328,5885104],"length":1,"stats":{"Line":894},"fn_name":null},{"line":91,"address":[5970183,5931960,5978537,5944743,5953193,5959543,5885193,5936217,5936231,5944729,5957401,5970169,5934102,5951127,5968041,5938345,5879001,5882983,5976505,5940487,5946857,5931974,5961671,5972249,5953207,5885207,5968055,5974377,5877031,5887417,5955321,5879015,5940473,5942601,5965927,5978551,5955335,5877017,5959529,5974391,5880999,5880985,5965913,5957415,5887431,5976519,5963799,5961657,5946871,5972263,5934088,5882969,5951113,5938359,5942615,5948985,5948999,5963785],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[5972203,5970805,5887371,5936171,5961611,5963739,5970123,5964421,5953829,5968677,5877653,5974331,5960165,5965867,5946811,5934724,5880939,5958037,5976459,5953147,5948939,5888053,5945365,5955957,5972885,5940427,5931914,5934042,5978491,5957355,5883605,5941109,5951749,5943237,5979173,5938981,5977141,5936853,5881621,5951067,5962293,5885147,5932596,5938299,5942555,5876971,5967995,5975013,5949621,5947493,5879637,5882923,5885829,5959483,5966549,5878955,5944683,5955275],"length":1,"stats":{"Line":1788},"fn_name":null},{"line":97,"address":[5833312,5815180,5816464,5845408,5845420,5816896,5820352,5826412,5828560,5831152,5833324,5836348,5814316,5822512,5834176,5837200,5814748,5841532,5818624,5836780,5825116,5844112,5821216,5831164,5823808,5834188,5823820,5813884,5836768,5812588,5819056,5811712,5811280,5818204,5826400,5819920,5832028,5820364,5819488,5816032,5835904,5822944,5837212,5822524,5811724,5825536,5816044,5818636,5840668,5841520,5828992,5842384,5840656,5819932,5815168,5835052,5815600,5836336,5818192,5817340,5813440,5812156,5815612,5819500,5822092,5823388,5827708,5816476,5821228,5828572,5829004,5822080,5832016,5828128,5835040,5835916,5838076,5812144,5827264,5823376,5838064,5816908,5834620,5842396,5811292,5819068,5845840,5834608,5825104,5845852,5825548,5812576,5813872,5814736,5827276,5813452,5822956,5827696,5828140,5814304,5817328,5844124],"length":1,"stats":{"Line":1788},"fn_name":"{{closure}}"},{"line":98,"address":[5833472,5836505,5817056,5816201,5818361,5818784,5822681,5832185,5836073,5825696,5841689,5829161,5814464,5814041,5811440,5823113,5820521,5828729,5840816,5822249,5815769,5819216,5823545,5814896,5814032,5817488,5816633,5826560,5823968,5827433,5827856,5834345,5827424,5834777,5814473,5825273,5838224,5845577,5819657,5833481,5819225,5820512,5818352,5822240,5823536,5841680,5842544,5844281,5819648,5820089,5828288,5837369,5811872,5846000,5840825,5828720,5815328,5844272,5813609,5814905,5827865,5828297,5842553,5822672,5845568,5846009,5823977,5817065,5826569,5813600,5834336,5837360,5823104,5817497,5818793,5815337,5816624,5815760,5829152,5812304,5831321,5834768,5832176,5836496,5836937,5825264,5812736,5838233,5820080,5821376,5836064,5821385,5812313,5831312,5812745,5836928,5825705,5811881,5816192,5835200,5835209,5811449],"length":1,"stats":{"Line":1788},"fn_name":"{{closure}}"},{"line":100,"address":[5953898,5947562,5943306,5960234,5883674,5941178,5951818,5966618,5972954,5879706,5979242,5956026,5968746,5936922,5881690,5949690,5975082,5977210,5939050,5932665,5964490,5970874,5877722,5888122,5934793,5945434,5885898,5958106,5962362],"length":1,"stats":{"Line":894},"fn_name":null},{"line":101,"address":[5951886,5966700,5968814,5970956,5970942,5883756,5962444,5962430,5877804,5888190,5979310,5945516,5960316,5975164,5877790,5885980,5937004,5975150,5943374,5964572,5979324,5973022,5879788,5932747,5949758,5956108,5951900,5888204,5947630,5966686,5932733,5939132,5958174,5941246,5947644,5943388,5934875,5936990,5949772,5953980,5881758,5939118,5953966,5941260,5968828,5945502,5883742,5881772,5958188,5960302,5964558,5956094,5934861,5977292,5973036,5885966,5879774,5977278],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[5985013,5983440,5985344,5985685,5985797,5983893,5984453,5985456,5983669,5984672,5983333,5983888,5984112,5984784,5984336,5985008,5983221,5984005,5984560,5983776,5985232,5985125,5983781,5985237,5985461,5985573,5984224,5985680,5983557,5984341,5984789,5985792,5985120,5983109,5985349,5984896,5984448,5986016,5983328,5983552,5984000,5985568,5984677,5985904,5984565,5985909,5983104,5986021,5983664,5983445,5984229,5984901,5984117,5983216],"length":1,"stats":{"Line":648},"fn_name":"{{closure}}"},{"line":114,"address":[8515582,8516766,8523870,8501374,8521502,8513214,8503742,8502558,8512030,8507294,8522686,8525054,8526238,8527422,8528606,8517950,8520318,8509662,8504926,8500190,8519134,8499006,8506110,8497822,8508478,8510846,8514398],"length":1,"stats":{"Line":297},"fn_name":null},{"line":115,"address":[8501439,8510911,8514464,8515648,8527487,8499041,8507359,8526303,8509727,8519199,8497887,8503807,8520383,8509697,8518015,8510881,8508513,8517985,8504961,8512095,8521537,8521567,8501409,8526273,8502623,8506145,8503777,8528671,8513279,8514433,8523935,8507329,8527457,8513249,8519169,8499071,8515617,8497857,8516801,8520353,8512065,8516832,8523905,8525119,8506175,8500255,8504991,8522751,8500225,8508543,8525089,8502593,8522721,8528641],"length":1,"stats":{"Line":351},"fn_name":null},{"line":116,"address":[8526423,8515878,8505111,8513509,8521687,8526540,8528908,8503927,8524055,8505221,8498007,8506295,8518135,8509957,8512332,8518245,8499191,8499308,8501669,8502860,8504044,8508663,8517062,8527724,8509847,8515768,8520620,8521797,8522988,8512215,8516952,8519319,8524172,8525349,8507589,8527607,8522871,8498124,8520503,8513399,8502743,8514584,8507479,8519436,8525239,8528791,8500375,8514694,8506412,8501559,8500485,8511031,8511148,8508780],"length":1,"stats":{"Line":216},"fn_name":null},{"line":117,"address":[8505176,8524125,8513464,8520573,8506365,8498077,8514649,8526493,8507544,8525304,8499261,8515833,8512285,8517017,8500440,8502813,8501624,8508733,8511101,8518200,8519389,8509912,8503997,8521752,8527677,8522941,8528861],"length":1,"stats":{"Line":216},"fn_name":null},{"line":118,"address":[8506445,8498157,8509990,8515911,8504077,8517095,8519469,8523021,8502893,8507622,8514727,8524205,8525382,8508813,8518278,8501702,8505254,8511181,8521830,8527757,8520653,8500518,8528941,8499341,8513542,8512365,8526573],"length":1,"stats":{"Line":216},"fn_name":null},{"line":119,"address":[8505298,8501746,8525545,8515955,8511344,8526617,8526663,8520697,8506489,8516074,8508903,8512409,8507666,8513632,8504167,8525426,8511271,8518441,8516001,8507712,8521920,8525472,8513705,8527847,8526736,8529031,8523184,8507785,8506535,8504240,8505417,8518368,8527920,8519559,8519513,8498320,8501865,8503056,8518322,8499431,8512455,8510153,8514817,8517139,8521874,8506608,8520816,8510080,8500608,8513586,8517185,8504121,8512528,8505344,8523111,8499504,8500562,8514890,8514771,8519632,8520743,8500681,8521993,8524295,8508857,8498201,8501792,8508976,8523065,8527801,8529104,8517258,8498247,8502983,8499385,8502937,8511225,8510034,8524368,8524249,8528985],"length":1,"stats":{"Line":432},"fn_name":null},{"line":120,"address":[8498253,8526785,8529153,8519681,8512461,8523117,8513754,8505350,8514823,8516123,8510086,8520865,8529037,8513638,8518490,8499437,8507834,8524301,8524417,8504173,8501914,8522042,8508909,8510202,8521926,8527853,8498369,8502989,8519565,8500614,8526669,8500730,8514939,8517307,8516007,8518374,8506541,8525478,8511393,8507718,8499553,8505466,8501798,8504289,8509025,8511277,8503105,8512577,8517191,8520749,8525594,8506657,8527969,8523233],"length":1,"stats":{"Line":432},"fn_name":null},{"line":121,"address":[8523388,8499708,8525609,8509040,8510217,8526800,8516278,8524572,8504444,8511548,8505481,8512592,8502069,8527984,8513909,8503120,8519836,8520880,8505621,8500885,8512732,8501929,8498524,8506672,8515094,8507849,8518645,8499568,8507989,8513769,8517462,8511408,8521020,8518505,8522197,8522057,8506812,8509180,8523248,8524432,8517322,8525749,8526940,8503260,8528124,8510357,8529168,8516138,8519696,8529308,8498384,8500745,8504304,8514954],"length":1,"stats":{"Line":216},"fn_name":null},{"line":129,"address":[5986133,5986357,5986469,5986464,5986128,5986245,5986240,5986352],"length":1,"stats":{"Line":96},"fn_name":"{{closure}}"},{"line":130,"address":[8530830,8532942,8531874,8529790],"length":1,"stats":{"Line":44},"fn_name":null},{"line":131,"address":[8530865,8532977,8531929,8531962,8529825,8529855,8530895,8533007],"length":1,"stats":{"Line":52},"fn_name":null},{"line":132,"address":[8533127,8530073,8532082,8532180,8533225,8531113,8531015,8529975],"length":1,"stats":{"Line":32},"fn_name":null},{"line":133,"address":[8530037,8531077,8530106,8531146,8533189,8533258,8532144,8532213],"length":1,"stats":{"Line":64},"fn_name":null},{"line":134,"address":[8531154,8532335,8533266,8531268,8532221,8530228,8530114,8533380],"length":1,"stats":{"Line":32},"fn_name":null},{"line":135,"address":[8530413,8533565,8532368,8531189,8531453,8530149,8533301,8530261,8531301,8533413,8532256,8532520],"length":1,"stats":{"Line":64},"fn_name":null},{"line":143,"address":[6814816,6814038,6815670,6816448,6816486,6817264,6817302,6813222,6813184,6812406,6812368,6814000,6815632,6814854],"length":1,"stats":{"Line":192},"fn_name":"split1"},{"line":144,"address":[6814014,6812421,6815685,6814053,6813198,6814869,6815646,6816462,6817278,6813237,6816501,6814830,6812382,6817317],"length":1,"stats":{"Line":128},"fn_name":null},{"line":145,"address":[6814989,6812541,6813357,6814173,6815805,6817437,6816621],"length":1,"stats":{"Line":88},"fn_name":null},{"line":146,"address":[6815064,6816696,6815266,6814426,6814450,6817509,6812818,6816874,6813610,6815880,6814248,6817711,6816898,6812794,6813634,6816082,6813432,6817687,6815242,6816058,6812616],"length":1,"stats":{"Line":110},"fn_name":null},{"line":154,"address":[6823136,6823174,6822342,6818118,6820614,6819782,6818912,6819744,6820576,6821494,6818950,6818080,6822304,6821456],"length":1,"stats":{"Line":168},"fn_name":"splitn_below_limit"},{"line":155,"address":[6818926,6818965,6820590,6822318,6822357,6823150,6818133,6821470,6823189,6819758,6818094,6820629,6821509,6819797],"length":1,"stats":{"Line":112},"fn_name":null},{"line":156,"address":[6819085,6822477,6819917,6823309,6820749,6821632,6818253],"length":1,"stats":{"Line":77},"fn_name":null},{"line":157,"address":[6822736,6820200,6819368,6823565,6821723,6818536,6820889,6821901,6822558,6821925,6818334,6819166,6819344,6823387,6820852,6820176,6822760,6819998,6818512,6823589],"length":1,"stats":{"Line":100},"fn_name":null}],"covered":61,"coverable":68},{"path":["/","usr","src","regex","tests","macros_bytes.rs"],"content":"// Macros for use in writing tests generic over &str/&[u8].\nmacro_rules! text { ($text:expr) => { $text.as_bytes() } }\nmacro_rules! t { ($re:expr) => { text!($re) } }\nmacro_rules! match_text { ($text:expr) => { $text.as_bytes() } }\nmacro_rules! use_ { ($($path: tt)*) => { use regex::bytes::$($path)*; } }\nmacro_rules! empty_vec { () => { <Vec<&[u8]>>::new() } }\n\nmacro_rules! bytes { ($text:expr) => { $text } }\n\nmacro_rules! no_expand {\n    ($text:expr) => {{\n        use regex::bytes::NoExpand;\n        NoExpand(text!($text))\n    }}\n}\n\nmacro_rules! show {\n    ($text:expr) => {{\n        use std::ascii::escape_default;\n        let mut s = vec![];\n        for &b in bytes!($text) {\n            s.extend(escape_default(b));\n        }\n        String::from_utf8(s).unwrap()\n    }}\n}\n\nmacro_rules! expand {\n    ($name:ident, $re:expr, $text:expr, $expand:expr, $expected:expr) => {\n        #[test]\n        fn $name() {\n            let re = regex!($re);\n            let cap = re.captures(t!($text)).unwrap();\n\n            let mut got = vec![];\n            cap.expand(t!($expand), &mut got);\n            assert_eq!(show!(t!($expected)), show!(&*got));\n        }\n    }\n}\n","traces":[{"line":31,"address":[5454485,5454384,5454389,5454416,5454357,5454512,5454256,5454517,5454288,5454261,5454325,5454224,5454320,5454293,5454480,5454229,5454453,5454421,5454352,5454448],"length":1,"stats":{"Line":90},"fn_name":"{{closure}}"},{"line":32,"address":[5774078,5756988,5767708,5756926,5759132,5761276,5754844,5759070,5763358,5769852,5769790,5767646,5765564,5763420,5754782,5771934,5774140,5761214,5765502,5771996],"length":1,"stats":{"Line":60},"fn_name":null},{"line":33,"address":[5757153,5772161,5774243,5755009,5759235,5761441,5767811,5772099,5765667,5774305,5757091,5763585,5759297,5770017,5754947,5765729,5767873,5763523,5761379,5769955],"length":1,"stats":{"Line":60},"fn_name":null},{"line":35,"address":[5770056,5757192,5763624,5761480,5765768,5759336,5755048,5767912,5772200,5774344],"length":1,"stats":{"Line":30},"fn_name":null},{"line":36,"address":[5768053,5761621,5755189,5772341,5770197,5757333,5763765,5765909,5759477,5774485],"length":1,"stats":{"Line":30},"fn_name":null},{"line":37,"address":[5774556,5770268,5763969,5770401,5773838,5769550,5763836,5771694,5759548,5760974,5756686,5755260,5774689,5775982,5765262,5766113,5772412,5758830,5759681,5757404,5772545,5767406,5768257,5761692,5757537,5765980,5763118,5755393,5768124,5761825],"length":1,"stats":{"Line":60},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","usr","src","regex","tests","macros_str.rs"],"content":"// Macros for use in writing tests generic over &str/&[u8].\nmacro_rules! text { ($text:expr) => { $text } }\nmacro_rules! t { ($text:expr) => { text!($text) } }\nmacro_rules! match_text { ($text:expr) => { $text.as_str() } }\nmacro_rules! use_ { ($($path: tt)*) => { use regex::$($path)*; } }\nmacro_rules! empty_vec { () => { <Vec<&str>>::new() } }\n\nmacro_rules! no_expand {\n    ($text:expr) => {{\n        use regex::NoExpand;\n        NoExpand(text!($text))\n    }}\n}\n\nmacro_rules! show { ($text:expr) => { $text } }\n\n// N.B. The expansion API for &str and &[u8] APIs differs slightly for now,\n// but they should be unified in 1.0. Then we can move this macro back into\n// tests/api.rs where it is used. ---AG\nmacro_rules! expand {\n    ($name:ident, $re:expr, $text:expr, $expand:expr, $expected:expr) => {\n        #[test]\n        fn $name() {\n            let re = regex!($re);\n            let cap = re.captures(t!($text)).unwrap();\n\n            let mut got = String::new();\n            cap.expand(t!($expand), &mut got);\n            assert_eq!(show!(t!($expected)), show!(&*got));\n        }\n    }\n}\n\n#[cfg(feature = \"pattern\")]\nmacro_rules! searcher_expr { ($e:expr) => ($e) }\n#[cfg(not(feature = \"pattern\"))]\nmacro_rules! searcher_expr { ($e:expr) => ({}) }\n","traces":[{"line":23,"address":[8456768,8456101,8456773,8456208,8456656,8456096,8455872,8456432,8455760,8455765,8456325,8456549,8456544,8455989,8456661,8456213,8456320,8456437,8455877,8455984],"length":1,"stats":{"Line":150},"fn_name":"{{closure}}"},{"line":24,"address":[6097678,6096766,6094942,6098590,6100453,6094030,6096805,6092245,6093118,6094981,6097717,6093157,6092206,6099502,6099541,6095854,6100414,6098629,6095893,6094069],"length":1,"stats":{"Line":100},"fn_name":null},{"line":25,"address":[6810653,6811597,6804045,6804989,6808765,6809709,6806877,6805933,6803101,6807821],"length":1,"stats":{"Line":50},"fn_name":null},{"line":27,"address":[6809799,6806023,6805079,6807911,6806967,6803191,6808855,6804135,6810743,6811687],"length":1,"stats":{"Line":50},"fn_name":null},{"line":28,"address":[6806974,6803198,6808862,6804142,6805086,6807918,6809806,6806030,6811694,6810750],"length":1,"stats":{"Line":50},"fn_name":null},{"line":29,"address":[6811014,6803462,6807087,6811807,6808975,6806085,6805350,6810070,6804197,6805141,6805199,6809919,6803311,6806143,6809861,6810863,6803253,6807029,6804406,6808182,6807973,6808917,6810805,6806294,6807238,6808031,6811749,6804255,6811958,6809126],"length":1,"stats":{"Line":100},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","usr","src","regex","tests","misc.rs"],"content":"mat!(prefix_literal_match, r\"^abc\", r\"abc\", Some((0, 3)));\nmat!(prefix_literal_nomatch, r\"^abc\", r\"zabc\", None);\nmat!(one_literal_edge, r\"abc\", r\"xxxxxab\", None);\nmatiter!(terminates, r\"a$\", r\"a\", (0, 1));\n","traces":[{"line":1,"address":[7475428,7474126,7474164],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2,"address":[7476180,7476142,7477388],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3,"address":[7478132,7479340,7478094],"length":1,"stats":{"Line":2},"fn_name":null},{"line":4,"address":[7480084,7481237,7480046,7480464],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","usr","src","regex","tests","multiline.rs"],"content":"matiter!(\n    match_multi_1,\n    r\"(?m)^[a-z]+$\",\n    \"abc\\ndef\\nxyz\",\n    (0, 3),\n    (4, 7),\n    (8, 11)\n);\nmatiter!(match_multi_2, r\"(?m)^$\", \"abc\\ndef\\nxyz\");\nmatiter!(match_multi_3, r\"(?m)^\", \"abc\\ndef\\nxyz\", (0, 0), (4, 4), (8, 8));\nmatiter!(match_multi_4, r\"(?m)$\", \"abc\\ndef\\nxyz\", (3, 3), (7, 7), (11, 11));\nmatiter!(\n    match_multi_5,\n    r\"(?m)^[a-z]\",\n    \"abc\\ndef\\nxyz\",\n    (0, 1),\n    (4, 5),\n    (8, 9)\n);\nmatiter!(match_multi_6, r\"(?m)[a-z]^\", \"abc\\ndef\\nxyz\");\nmatiter!(\n    match_multi_7,\n    r\"(?m)[a-z]$\",\n    \"abc\\ndef\\nxyz\",\n    (2, 3),\n    (6, 7),\n    (10, 11)\n);\nmatiter!(match_multi_8, r\"(?m)$[a-z]\", \"abc\\ndef\\nxyz\");\nmatiter!(match_multi_9, r\"(?m)^$\", \"\", (0, 0));\n\nmatiter!(\n    match_multi_rep_1,\n    r\"(?m)(?:^$)*\",\n    \"a\\nb\\nc\",\n    (0, 0),\n    (1, 1),\n    (2, 2),\n    (3, 3),\n    (4, 4),\n    (5, 5)\n);\nmatiter!(\n    match_multi_rep_2,\n    r\"(?m)(?:^|a)+\",\n    \"a\\naaa\\n\",\n    (0, 0),\n    (2, 2),\n    (3, 5),\n    (6, 6)\n);\nmatiter!(\n    match_multi_rep_3,\n    r\"(?m)(?:^|a)*\",\n    \"a\\naaa\\n\",\n    (0, 1),\n    (2, 5),\n    (6, 6)\n);\nmatiter!(\n    match_multi_rep_4,\n    r\"(?m)(?:^[a-z])+\",\n    \"abc\\ndef\\nxyz\",\n    (0, 1),\n    (4, 5),\n    (8, 9)\n);\nmatiter!(\n    match_multi_rep_5,\n    r\"(?m)(?:^[a-z]{3}\\n?)+\",\n    \"abc\\ndef\\nxyz\",\n    (0, 11)\n);\nmatiter!(\n    match_multi_rep_6,\n    r\"(?m)(?:^[a-z]{3}\\n?)*\",\n    \"abc\\ndef\\nxyz\",\n    (0, 11)\n);\nmatiter!(\n    match_multi_rep_7,\n    r\"(?m)(?:\\n?[a-z]{3}$)+\",\n    \"abc\\ndef\\nxyz\",\n    (0, 11)\n);\nmatiter!(\n    match_multi_rep_8,\n    r\"(?m)(?:\\n?[a-z]{3}$)*\",\n    \"abc\\ndef\\nxyz\",\n    (0, 11)\n);\nmatiter!(\n    match_multi_rep_9,\n    r\"(?m)^*\",\n    \"\\naa\\n\",\n    (0, 0),\n    (1, 1),\n    (2, 2),\n    (3, 3),\n    (4, 4)\n);\nmatiter!(match_multi_rep_10, r\"(?m)^+\", \"\\naa\\n\", (0, 0), (1, 1), (4, 4));\nmatiter!(\n    match_multi_rep_11,\n    r\"(?m)$*\",\n    \"\\naa\\n\",\n    (0, 0),\n    (1, 1),\n    (2, 2),\n    (3, 3),\n    (4, 4)\n);\nmatiter!(match_multi_rep_12, r\"(?m)$+\", \"\\naa\\n\", (0, 0), (3, 3), (4, 4));\nmatiter!(match_multi_rep_13, r\"(?m)(?:$\\n)+\", \"\\n\\naaa\\n\\n\", (0, 2), (5, 7));\nmatiter!(\n    match_multi_rep_14,\n    r\"(?m)(?:$\\n)*\",\n    \"\\n\\naaa\\n\\n\",\n    (0, 2),\n    (3, 3),\n    (4, 4),\n    (5, 7)\n);\nmatiter!(match_multi_rep_15, r\"(?m)(?:$\\n^)+\", \"\\n\\naaa\\n\\n\", (0, 2), (5, 7));\nmatiter!(\n    match_multi_rep_16,\n    r\"(?m)(?:^|$)+\",\n    \"\\n\\naaa\\n\\n\",\n    (0, 0),\n    (1, 1),\n    (2, 2),\n    (5, 5),\n    (6, 6),\n    (7, 7)\n);\nmatiter!(\n    match_multi_rep_17,\n    r\"(?m)(?:$\\n)*\",\n    \"\\n\\naaa\\n\\n\",\n    (0, 2),\n    (3, 3),\n    (4, 4),\n    (5, 7)\n);\n","traces":[{"line":5,"address":[6701540],"length":1,"stats":{"Line":8},"fn_name":null},{"line":6,"address":[6701564],"length":1,"stats":{"Line":8},"fn_name":null},{"line":7,"address":[6701588],"length":1,"stats":{"Line":8},"fn_name":null},{"line":9,"address":[6703586,6704058,6704831],"length":1,"stats":{"Line":5},"fn_name":null},{"line":10,"address":[6706901,6706128,6705540,6705502],"length":1,"stats":{"Line":13},"fn_name":null},{"line":11,"address":[6708981,6708208,6707582,6707620],"length":1,"stats":{"Line":13},"fn_name":null},{"line":16,"address":[6709700],"length":1,"stats":{"Line":8},"fn_name":null},{"line":17,"address":[6709724],"length":1,"stats":{"Line":8},"fn_name":null},{"line":18,"address":[6709748],"length":1,"stats":{"Line":8},"fn_name":null},{"line":20,"address":[6712991,6711746,6712218],"length":1,"stats":{"Line":5},"fn_name":null},{"line":25,"address":[6713700],"length":1,"stats":{"Line":8},"fn_name":null},{"line":26,"address":[6713724],"length":1,"stats":{"Line":8},"fn_name":null},{"line":27,"address":[6713748],"length":1,"stats":{"Line":8},"fn_name":null},{"line":29,"address":[6715746,6716218,6716991],"length":1,"stats":{"Line":5},"fn_name":null},{"line":30,"address":[6717700,6717655,6718965,6718192],"length":1,"stats":{"Line":13},"fn_name":null},{"line":36,"address":[6719684],"length":1,"stats":{"Line":8},"fn_name":null},{"line":37,"address":[6719708],"length":1,"stats":{"Line":8},"fn_name":null},{"line":38,"address":[6719732],"length":1,"stats":{"Line":8},"fn_name":null},{"line":39,"address":[6719756],"length":1,"stats":{"Line":8},"fn_name":null},{"line":40,"address":[6719780],"length":1,"stats":{"Line":8},"fn_name":null},{"line":41,"address":[6719804],"length":1,"stats":{"Line":8},"fn_name":null},{"line":47,"address":[6721908],"length":1,"stats":{"Line":8},"fn_name":null},{"line":48,"address":[6721932],"length":1,"stats":{"Line":8},"fn_name":null},{"line":49,"address":[6721956],"length":1,"stats":{"Line":8},"fn_name":null},{"line":50,"address":[6721980],"length":1,"stats":{"Line":8},"fn_name":null},{"line":56,"address":[6724036],"length":1,"stats":{"Line":8},"fn_name":null},{"line":57,"address":[6724060],"length":1,"stats":{"Line":8},"fn_name":null},{"line":58,"address":[6724084],"length":1,"stats":{"Line":8},"fn_name":null},{"line":64,"address":[6726116],"length":1,"stats":{"Line":8},"fn_name":null},{"line":65,"address":[6726140],"length":1,"stats":{"Line":8},"fn_name":null},{"line":66,"address":[6726164],"length":1,"stats":{"Line":8},"fn_name":null},{"line":72,"address":[6728196],"length":1,"stats":{"Line":8},"fn_name":null},{"line":78,"address":[6730180],"length":1,"stats":{"Line":8},"fn_name":null},{"line":84,"address":[6732164],"length":1,"stats":{"Line":8},"fn_name":null},{"line":90,"address":[6734148],"length":1,"stats":{"Line":8},"fn_name":null},{"line":96,"address":[6736132],"length":1,"stats":{"Line":8},"fn_name":null},{"line":97,"address":[6736156],"length":1,"stats":{"Line":8},"fn_name":null},{"line":98,"address":[6736180],"length":1,"stats":{"Line":8},"fn_name":null},{"line":99,"address":[6736204],"length":1,"stats":{"Line":8},"fn_name":null},{"line":100,"address":[6736228],"length":1,"stats":{"Line":8},"fn_name":null},{"line":102,"address":[6738896,6738270,6739669,6738308],"length":1,"stats":{"Line":13},"fn_name":null},{"line":107,"address":[6740388],"length":1,"stats":{"Line":8},"fn_name":null},{"line":108,"address":[6740412],"length":1,"stats":{"Line":8},"fn_name":null},{"line":109,"address":[6740436],"length":1,"stats":{"Line":8},"fn_name":null},{"line":110,"address":[6740460],"length":1,"stats":{"Line":8},"fn_name":null},{"line":111,"address":[6740484],"length":1,"stats":{"Line":8},"fn_name":null},{"line":113,"address":[6742564,6743152,6743925,6742526],"length":1,"stats":{"Line":13},"fn_name":null},{"line":114,"address":[6745957,6744644,6744606,6745184],"length":1,"stats":{"Line":13},"fn_name":null},{"line":119,"address":[6746676],"length":1,"stats":{"Line":8},"fn_name":null},{"line":120,"address":[6746700],"length":1,"stats":{"Line":8},"fn_name":null},{"line":121,"address":[6746724],"length":1,"stats":{"Line":8},"fn_name":null},{"line":122,"address":[6746748],"length":1,"stats":{"Line":8},"fn_name":null},{"line":124,"address":[6748804,6749344,6750117,6748766],"length":1,"stats":{"Line":13},"fn_name":null},{"line":129,"address":[6750836],"length":1,"stats":{"Line":8},"fn_name":null},{"line":130,"address":[6750860],"length":1,"stats":{"Line":8},"fn_name":null},{"line":131,"address":[6750884],"length":1,"stats":{"Line":8},"fn_name":null},{"line":132,"address":[6750908],"length":1,"stats":{"Line":8},"fn_name":null},{"line":133,"address":[6750932],"length":1,"stats":{"Line":8},"fn_name":null},{"line":134,"address":[6750956],"length":1,"stats":{"Line":8},"fn_name":null},{"line":140,"address":[6753060],"length":1,"stats":{"Line":8},"fn_name":null},{"line":141,"address":[6753084],"length":1,"stats":{"Line":8},"fn_name":null},{"line":142,"address":[6753108],"length":1,"stats":{"Line":8},"fn_name":null},{"line":143,"address":[6753132],"length":1,"stats":{"Line":8},"fn_name":null}],"covered":63,"coverable":63},{"path":["/","usr","src","regex","tests","noparse.rs"],"content":"macro_rules! noparse(\n    ($name:ident, $re:expr) => (\n        #[test]\n        fn $name() {\n            let re = $re;\n            match regex_new!(re) {\n                Err(_) => {},\n                Ok(_) => panic!(\"Regex '{}' should cause a parse error.\", re),\n            }\n        }\n    );\n);\n\nnoparse!(fail_no_repeat_arg, \"*\");\nnoparse!(fail_incomplete_escape, \"\\\\\");\nnoparse!(fail_class_incomplete, \"[A-\");\nnoparse!(fail_class_not_closed, \"[A\");\nnoparse!(fail_class_no_begin, r\"[\\A]\");\nnoparse!(fail_class_no_end, r\"[\\z]\");\nnoparse!(fail_class_no_boundary, r\"[\\b]\");\nnoparse!(fail_open_paren, \"(\");\nnoparse!(fail_close_paren, \")\");\nnoparse!(fail_invalid_range, \"[a-Z]\");\nnoparse!(fail_empty_capture_name, \"(?P<>a)\");\nnoparse!(fail_bad_capture_name, \"(?P<na-me>)\");\nnoparse!(fail_bad_flag, \"(?a)a\");\nnoparse!(fail_too_big, \"a{10000000}\");\nnoparse!(fail_counted_no_close, \"a{1001\");\nnoparse!(fail_counted_decreasing, \"a{2,1}\");\nnoparse!(fail_counted_nonnegative, \"a{-1,1}\");\nnoparse!(fail_unfinished_cap, \"(?\");\nnoparse!(fail_unfinished_escape, \"\\\\\");\nnoparse!(fail_octal_digit, r\"\\8\");\nnoparse!(fail_hex_digit, r\"\\xG0\");\nnoparse!(fail_hex_short, r\"\\xF\");\nnoparse!(fail_hex_long_digits, r\"\\x{fffg}\");\nnoparse!(fail_flag_bad, \"(?a)\");\nnoparse!(fail_flag_empty, \"(?)\");\nnoparse!(fail_double_neg, \"(?-i-i)\");\nnoparse!(fail_neg_empty, \"(?i-)\");\nnoparse!(fail_dupe_named, \"(?P<a>.)(?P<a>.)\");\nnoparse!(fail_range_end_no_class, \"[a-[:lower:]]\");\nnoparse!(fail_range_end_no_begin, r\"[a-\\A]\");\nnoparse!(fail_range_end_no_end, r\"[a-\\z]\");\nnoparse!(fail_range_end_no_boundary, r\"[a-\\b]\");\n","traces":[{"line":4,"address":[5773088,5773142,5774742,5774342,5775888,5778288,5769088,5771888,5776742,5773488,5776288,5777488,5771942,5775542,5776342,5777888,5777088,5773942,5768742,5765888,5769488,5769942,5775942,5773888,5767888,5768288,5777542,5767142,5767488,5775142,5767942,5770742,5771142,5775488,5777942,5770288,5766688,5777142,5766742,5767088,5768688,5774288,5772288,5774688,5768342,5778342,5765942,5766288,5767542,5771542,5770342,5770688,5771088,5766342,5769142,5769888,5769542,5772742,5772342,5771488,5772688,5776688,5775088,5773542],"length":1,"stats":{"Line":768},"fn_name":"fail_no_repeat_arg"},{"line":6,"address":[8473216,8473845,8473045,8473445,8474204,8474645,8468604,8470645,8472645,8475804,8472604,8472816,8470016,8470416,8470245,8473804,8475845,8470204,8471616,8475445,8469845,8465216,8466204,8468016,8468245,8471445,8469004,8471045,8470816,8471804,8466604,8474016,8463404,8475045,8464645,8466245,8469045,8474816,8475404,8475616,8468416,8475216,8467404,8468645,8465045,8467004,8468816,8464816,8467445,8469216,8473404,8467804,8464416,8463445,8470604,8474416,8464016,8467045,8471404,8474604,8469404,8463616,8469445,8465804,8471216,8472016,8463804,8464204,8465445,8463845,8465616,8466416,8464245,8466816,8467216,8467616,8466016,8471845,8472245,8465845,8467845,8473616,8474245,8469804,8468204,8472204,8475004,8476016,8466645,8471004,8469616,8465404,8472416,8464604,8473004,8465004],"length":1,"stats":{"Line":448},"fn_name":null},{"line":7,"address":[8472728,8473128,8475128,8470728,8475528,8470328,8473528,8463528,8468728,8469528,8473928,8474728,8464328,8465528,8465928,8469128,8465128,8471128,8466328,8471528,8471928,8472328,8475928,8468328,8464728,8467128,8463928,8467528,8474328,8466728,8469928,8467928],"length":1,"stats":{"Line":256},"fn_name":null},{"line":8,"address":[8464509,8467309,8474109,8472742,8467942,8469634,8470434,8470342,8471142,8472034,8472342,8470909,8474834,8474909,8468909,8464834,8467234,8468834,8473234,8466509,8464034,8464742,8466834,8463942,8467542,8465634,8471234,8469309,8473542,8473634,8475942,8471709,8472909,8472834,8476034,8473942,8465942,8465234,8467634,8468034,8473709,8475142,8465142,8475309,8470109,8469709,8470742,8474509,8466434,8474434,8466742,8464434,8466909,8471542,8470509,8465709,8472109,8469942,8463634,8468509,8466034,8469542,8470034,8472509,8474034,8466342,8471942,8471309,8465542,8476109,8474742,8463542,8470834,8468109,8467142,8468742,8469234,8468342,8464909,8471634,8464342,8473309,8464109,8468434,8472434,8475542,8474342,8475634,8475709,8465309,8473142,8475234,8466109,8469142,8463709,8467709],"length":1,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[8463390],"length":1,"stats":{"Line":8},"fn_name":null},{"line":15,"address":[8463790],"length":1,"stats":{"Line":8},"fn_name":null},{"line":16,"address":[8464190],"length":1,"stats":{"Line":8},"fn_name":null},{"line":17,"address":[8464590],"length":1,"stats":{"Line":8},"fn_name":null},{"line":18,"address":[8464990],"length":1,"stats":{"Line":8},"fn_name":null},{"line":19,"address":[8465390],"length":1,"stats":{"Line":8},"fn_name":null},{"line":20,"address":[8465790],"length":1,"stats":{"Line":8},"fn_name":null},{"line":21,"address":[8466190],"length":1,"stats":{"Line":8},"fn_name":null},{"line":22,"address":[8466590],"length":1,"stats":{"Line":8},"fn_name":null},{"line":23,"address":[8466990],"length":1,"stats":{"Line":8},"fn_name":null},{"line":24,"address":[8467390],"length":1,"stats":{"Line":8},"fn_name":null},{"line":25,"address":[8467790],"length":1,"stats":{"Line":8},"fn_name":null},{"line":26,"address":[8468190],"length":1,"stats":{"Line":8},"fn_name":null},{"line":27,"address":[8468590],"length":1,"stats":{"Line":8},"fn_name":null},{"line":28,"address":[8468990],"length":1,"stats":{"Line":8},"fn_name":null},{"line":29,"address":[8469390],"length":1,"stats":{"Line":8},"fn_name":null},{"line":30,"address":[8469790],"length":1,"stats":{"Line":8},"fn_name":null},{"line":31,"address":[8470190],"length":1,"stats":{"Line":8},"fn_name":null},{"line":32,"address":[8470590],"length":1,"stats":{"Line":8},"fn_name":null},{"line":33,"address":[8470990],"length":1,"stats":{"Line":8},"fn_name":null},{"line":34,"address":[8471390],"length":1,"stats":{"Line":8},"fn_name":null},{"line":35,"address":[8471790],"length":1,"stats":{"Line":8},"fn_name":null},{"line":36,"address":[8472190],"length":1,"stats":{"Line":8},"fn_name":null},{"line":37,"address":[8472590],"length":1,"stats":{"Line":8},"fn_name":null},{"line":38,"address":[8472990],"length":1,"stats":{"Line":8},"fn_name":null},{"line":39,"address":[8473390],"length":1,"stats":{"Line":8},"fn_name":null},{"line":40,"address":[8473790],"length":1,"stats":{"Line":8},"fn_name":null},{"line":41,"address":[8474190],"length":1,"stats":{"Line":8},"fn_name":null},{"line":42,"address":[8474590],"length":1,"stats":{"Line":8},"fn_name":null},{"line":43,"address":[8474990],"length":1,"stats":{"Line":8},"fn_name":null},{"line":44,"address":[8475390],"length":1,"stats":{"Line":8},"fn_name":null},{"line":45,"address":[8475790],"length":1,"stats":{"Line":8},"fn_name":null}],"covered":35,"coverable":36},{"path":["/","usr","src","regex","tests","regression.rs"],"content":"// See: https://github.com/rust-lang/regex/issues/48\n#[test]\nfn invalid_regexes_no_crash() {\n    assert!(regex_new!(\"(*)\").is_err());\n    assert!(regex_new!(\"(?:?)\").is_err());\n    assert!(regex_new!(\"(?)\").is_err());\n    assert!(regex_new!(\"*\").is_err());\n}\n\n// See: https://github.com/rust-lang/regex/issues/98\n#[test]\nfn regression_many_repeat_stack_overflow() {\n    let re = regex!(\"^.{1,2500}\");\n    assert_eq!(vec![(0, 1)], findall!(re, \"a\"));\n}\n\n// See: https://github.com/rust-lang/regex/issues/555\n#[test]\nfn regression_invalid_repetition_expr() {\n    assert!(regex_new!(\"(?m){1,1}\").is_err());\n}\n\n// See: https://github.com/rust-lang/regex/issues/527\n#[test]\nfn regression_invalid_flags_expression() {\n    assert!(regex_new!(\"(((?x)))\").is_ok());\n}\n\n// See: https://github.com/rust-lang/regex/issues/75\nmat!(regression_unsorted_binary_search_1, r\"(?i-u)[a_]+\", \"A_\", Some((0, 2)));\nmat!(regression_unsorted_binary_search_2, r\"(?i-u)[A_]+\", \"a_\", Some((0, 2)));\n\n// See: https://github.com/rust-lang/regex/issues/99\n#[cfg(feature = \"unicode-case\")]\nmat!(regression_negated_char_class_1, r\"(?i)[^x]\", \"x\", None);\n#[cfg(feature = \"unicode-case\")]\nmat!(regression_negated_char_class_2, r\"(?i)[^x]\", \"X\", None);\n\n// See: https://github.com/rust-lang/regex/issues/101\nmat!(regression_ascii_word_underscore, r\"[[:word:]]\", \"_\", Some((0, 1)));\n\n// See: https://github.com/rust-lang/regex/issues/129\n#[test]\nfn regression_captures_rep() {\n    let re = regex!(r\"([a-f]){2}(?P<foo>[x-z])\");\n    let caps = re.captures(text!(\"abx\")).unwrap();\n    assert_eq!(match_text!(caps.name(\"foo\").unwrap()), text!(\"x\"));\n}\n\n// See: https://github.com/rust-lang/regex/issues/153\nmat!(regression_alt_in_alt1, r\"ab?|$\", \"az\", Some((0, 1)));\nmat!(regression_alt_in_alt2, r\"^(.*?)(\\n|\\r\\n?|$)\", \"ab\\rcd\", Some((0, 3)));\n\n// See: https://github.com/rust-lang/regex/issues/169\nmat!(regression_leftmost_first_prefix, r\"z*azb\", \"azb\", Some((0, 3)));\n\n// See: https://github.com/rust-lang/regex/issues/76\n#[cfg(all(feature = \"unicode-case\", feature = \"unicode-gencat\"))]\nmat!(uni_case_lower_nocase_flag, r\"(?i)\\p{Ll}+\", \"ΛΘΓΔα\", Some((0, 10)));\n\n// See: https://github.com/rust-lang/regex/issues/191\nmat!(many_alternates, r\"1|2|3|4|5|6|7|8|9|10|int\", \"int\", Some((0, 3)));\n\n// burntsushi was bad and didn't create an issue for this bug.\nmat!(anchored_prefix1, r\"^a[[:^space:]]\", \"a \", None);\nmat!(anchored_prefix2, r\"^a[[:^space:]]\", \"foo boo a \", None);\nmat!(anchored_prefix3, r\"^-[a-z]\", \"r-f\", None);\n\n// See: https://github.com/rust-lang/regex/issues/204\n#[cfg(feature = \"unicode-perl\")]\nsplit!(\n    split_on_word_boundary,\n    r\"\\b\",\n    r\"Should this (work?)\",\n    &[\n        t!(\"\"),\n        t!(\"Should\"),\n        t!(\" \"),\n        t!(\"this\"),\n        t!(\" (\"),\n        t!(\"work\"),\n        t!(\"?)\")\n    ]\n);\n#[cfg(feature = \"unicode-perl\")]\nmatiter!(\n    word_boundary_dfa,\n    r\"\\b\",\n    \"a b c\",\n    (0, 0),\n    (1, 1),\n    (2, 2),\n    (3, 3),\n    (4, 4),\n    (5, 5)\n);\n\n// See: https://github.com/rust-lang/regex/issues/268\nmatiter!(partial_anchor, r\"^a|b\", \"ba\", (0, 1));\n\n// See: https://github.com/rust-lang/regex/issues/280\nismatch!(partial_anchor_alternate_begin, r\"^a|z\", \"yyyyya\", false);\nismatch!(partial_anchor_alternate_end, r\"a$|z\", \"ayyyyy\", false);\n\n// See: https://github.com/rust-lang/regex/issues/289\nmat!(lits_unambiguous1, r\"(ABC|CDA|BC)X\", \"CDAX\", Some((0, 4)));\n\n// See: https://github.com/rust-lang/regex/issues/291\nmat!(\n    lits_unambiguous2,\n    r\"((IMG|CAM|MG|MB2)_|(DSCN|CIMG))(?P<n>[0-9]+)$\",\n    \"CIMG2341\",\n    Some((0, 8)),\n    Some((0, 4)),\n    None,\n    Some((0, 4)),\n    Some((4, 8))\n);\n\n// See: https://github.com/rust-lang/regex/issues/271\nmat!(endl_or_wb, r\"(?m:$)|(?-u:\\b)\", \"\\u{6084e}\", Some((4, 4)));\nmat!(zero_or_end, r\"(?i-u:\\x00)|$\", \"\\u{e682f}\", Some((4, 4)));\nmat!(y_or_endl, r\"(?i-u:y)|(?m:$)\", \"\\u{b4331}\", Some((4, 4)));\n#[cfg(feature = \"unicode-perl\")]\nmat!(wb_start_x, r\"(?u:\\b)^(?-u:X)\", \"X\", Some((0, 1)));\n\n// See: https://github.com/rust-lang/regex/issues/321\nismatch!(strange_anchor_non_complete_prefix, r\"a^{2}\", \"\", false);\nismatch!(strange_anchor_non_complete_suffix, r\"${2}a\", \"\", false);\n\n// See: https://github.com/BurntSushi/ripgrep/issues/1203\nismatch!(reverse_suffix1, r\"[0-4][0-4][0-4]000\", \"153.230000\", true);\nismatch!(reverse_suffix2, r\"[0-9][0-9][0-9]000\", \"153.230000\\n\", true);\nmatiter!(reverse_suffix3, r\"[0-9][0-9][0-9]000\", \"153.230000\\n\", (4, 10));\n\n// See: https://github.com/rust-lang/regex/issues/334\n// See: https://github.com/rust-lang/regex/issues/557\nmat!(\n    captures_after_dfa_premature_end1,\n    r\"a(b*(X|$))?\",\n    \"abcbX\",\n    Some((0, 1)),\n    None,\n    None\n);\nmat!(\n    captures_after_dfa_premature_end2,\n    r\"a(bc*(X|$))?\",\n    \"abcbX\",\n    Some((0, 1)),\n    None,\n    None\n);\nmat!(captures_after_dfa_premature_end3, r\"(aa$)?\", \"aaz\", Some((0, 0)));\n\n// See: https://github.com/rust-lang/regex/issues/437\nismatch!(\n    literal_panic,\n    r\"typename type\\-parameter\\-[0-9]+\\-[0-9]+::.+\",\n    \"test\",\n    false\n);\n\n// See: https://github.com/rust-lang/regex/issues/533\nismatch!(\n    blank_matches_nothing_between_space_and_tab,\n    r\"[[:blank:]]\",\n    \"\\u{a}\\u{b}\\u{c}\\u{d}\\u{e}\\u{f}\\\n     \\u{10}\\u{11}\\u{12}\\u{13}\\u{14}\\u{15}\\u{16}\\u{17}\\\n     \\u{18}\\u{19}\\u{1a}\\u{1b}\\u{1c}\\u{1d}\\u{1e}\\u{1f}\",\n    false\n);\n\nismatch!(\n    inverted_blank_matches_everything_between_space_and_tab,\n    r\"^[[:^blank:]]+$\",\n    \"\\u{a}\\u{b}\\u{c}\\u{d}\\u{e}\\u{f}\\\n     \\u{10}\\u{11}\\u{12}\\u{13}\\u{14}\\u{15}\\u{16}\\u{17}\\\n     \\u{18}\\u{19}\\u{1a}\\u{1b}\\u{1c}\\u{1d}\\u{1e}\\u{1f}\",\n    true\n);\n\n// Tests that our Aho-Corasick optimization works correctly. It only\n// kicks in when we have >32 literals. By \"works correctly,\" we mean that\n// leftmost-first match semantics are properly respected. That is, samwise\n// should match, not sam.\nmat!(\n    ahocorasick1,\n    \"samwise|sam|a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z|\\\n     A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z\",\n    \"samwise\",\n    Some((0, 7))\n);\n\n// See: https://github.com/BurntSushi/ripgrep/issues/1247\n#[test]\n#[cfg(feature = \"unicode-perl\")]\nfn regression_nfa_stops1() {\n    let re = ::regex::bytes::Regex::new(r\"\\bs(?:[ab])\").unwrap();\n    assert_eq!(0, re.find_iter(b\"s\\xE4\").count());\n}\n\n// See: https://github.com/rust-lang/regex/issues/640\n#[cfg(feature = \"unicode-case\")]\nmatiter!(\n    flags_are_unset,\n    r\"((?i)foo)|Bar\",\n    \"foo Foo bar Bar\",\n    (0, 3),\n    (4, 7),\n    (12, 15)\n);\n\n// See: https://github.com/rust-lang/regex/issues/659\n//\n// Note that 'Ј' is not 'j', but cyrillic Je\n// https://en.wikipedia.org/wiki/Je_(Cyrillic)\nismatch!(empty_group_match, r\"()Ј01\", \"zЈ01\", true);\nmatiter!(empty_group_find, r\"()Ј01\", \"zЈ01\", (1, 5));\n","traces":[{"line":3,"address":[7180816,7180821],"length":1,"stats":{"Line":24},"fn_name":"{{closure}}"},{"line":4,"address":[7382181,7382358,7382142],"length":1,"stats":{"Line":16},"fn_name":null},{"line":5,"address":[7382388,7382583,7382334],"length":1,"stats":{"Line":16},"fn_name":null},{"line":6,"address":[7382613,7382808,7382559],"length":1,"stats":{"Line":16},"fn_name":null},{"line":7,"address":[7383008,7382838,7382784],"length":1,"stats":{"Line":16},"fn_name":null},{"line":12,"address":[7181168,7181173],"length":1,"stats":{"Line":24},"fn_name":"{{closure}}"},{"line":13,"address":[7383173,7383134],"length":1,"stats":{"Line":16},"fn_name":null},{"line":14,"address":[7383303,7383398],"length":1,"stats":{"Line":13},"fn_name":null},{"line":19,"address":[7181360,7181365],"length":1,"stats":{"Line":24},"fn_name":"{{closure}}"},{"line":20,"address":[7384255,7384062,7384101],"length":1,"stats":{"Line":16},"fn_name":null},{"line":25,"address":[7181477,7181472],"length":1,"stats":{"Line":24},"fn_name":"{{closure}}"},{"line":26,"address":[7384357,7384511,7384318],"length":1,"stats":{"Line":16},"fn_name":null},{"line":30,"address":[7384574,7385988,7384612],"length":1,"stats":{"Line":13},"fn_name":null},{"line":31,"address":[7388116,7386702,7386740],"length":1,"stats":{"Line":13},"fn_name":null},{"line":35,"address":[7388868,7390188,7388830],"length":1,"stats":{"Line":13},"fn_name":null},{"line":37,"address":[7390894,7392252,7390932],"length":1,"stats":{"Line":13},"fn_name":null},{"line":40,"address":[7392996,7394372,7392958],"length":1,"stats":{"Line":13},"fn_name":null},{"line":44,"address":[7182949,7182944],"length":1,"stats":{"Line":24},"fn_name":"{{closure}}"},{"line":45,"address":[7395086,7395125],"length":1,"stats":{"Line":16},"fn_name":null},{"line":46,"address":[7395245],"length":1,"stats":{"Line":11},"fn_name":null},{"line":47,"address":[7395420,7395597,7395327],"length":1,"stats":{"Line":19},"fn_name":null},{"line":51,"address":[7395982,7397396,7396020],"length":1,"stats":{"Line":13},"fn_name":null},{"line":52,"address":[7398148,7398110,7399524],"length":1,"stats":{"Line":13},"fn_name":null},{"line":55,"address":[7401652,7400238,7400276],"length":1,"stats":{"Line":13},"fn_name":null},{"line":59,"address":[7402404,7403780,7402366],"length":1,"stats":{"Line":13},"fn_name":null},{"line":62,"address":[7404494,7404532,7405908],"length":1,"stats":{"Line":13},"fn_name":null},{"line":65,"address":[7406660,7407980,7406622],"length":1,"stats":{"Line":13},"fn_name":null},{"line":66,"address":[7410044,7408686,7408724],"length":1,"stats":{"Line":13},"fn_name":null},{"line":67,"address":[7410750,7410788,7412108],"length":1,"stats":{"Line":13},"fn_name":null},{"line":75,"address":[5304689],"length":1,"stats":{"Line":3},"fn_name":null},{"line":90,"address":[7413668],"length":1,"stats":{"Line":8},"fn_name":null},{"line":91,"address":[7413692],"length":1,"stats":{"Line":8},"fn_name":null},{"line":92,"address":[7413716],"length":1,"stats":{"Line":8},"fn_name":null},{"line":93,"address":[7413740],"length":1,"stats":{"Line":8},"fn_name":null},{"line":94,"address":[7413764],"length":1,"stats":{"Line":8},"fn_name":null},{"line":95,"address":[7413788],"length":1,"stats":{"Line":8},"fn_name":null},{"line":99,"address":[7415892,7417157,7416384,7415854],"length":1,"stats":{"Line":13},"fn_name":null},{"line":106,"address":[7419214,7419252,7420628],"length":1,"stats":{"Line":13},"fn_name":null},{"line":113,"address":[7421380],"length":1,"stats":{"Line":8},"fn_name":null},{"line":114,"address":[7421448],"length":1,"stats":{"Line":8},"fn_name":null},{"line":115,"address":[7421516],"length":1,"stats":{"Line":8},"fn_name":null},{"line":116,"address":[7421528],"length":1,"stats":{"Line":8},"fn_name":null},{"line":117,"address":[7421596],"length":1,"stats":{"Line":8},"fn_name":null},{"line":121,"address":[7423822,7423860,7425236],"length":1,"stats":{"Line":13},"fn_name":null},{"line":122,"address":[7425988,7425950,7427364],"length":1,"stats":{"Line":13},"fn_name":null},{"line":123,"address":[7428078,7428116,7429492],"length":1,"stats":{"Line":13},"fn_name":null},{"line":125,"address":[7431620,7430244,7430206],"length":1,"stats":{"Line":13},"fn_name":null},{"line":134,"address":[7435086,7435124,7436389,7435616],"length":1,"stats":{"Line":13},"fn_name":null},{"line":142,"address":[7437108],"length":1,"stats":{"Line":8},"fn_name":null},{"line":143,"address":[7437176],"length":1,"stats":{"Line":8},"fn_name":null},{"line":144,"address":[7437188],"length":1,"stats":{"Line":8},"fn_name":null},{"line":150,"address":[7439332],"length":1,"stats":{"Line":8},"fn_name":null},{"line":151,"address":[7439400],"length":1,"stats":{"Line":8},"fn_name":null},{"line":152,"address":[7439412],"length":1,"stats":{"Line":8},"fn_name":null},{"line":154,"address":[7441518,7442932,7441556],"length":1,"stats":{"Line":13},"fn_name":null},{"line":192,"address":[7445748],"length":1,"stats":{"Line":8},"fn_name":null},{"line":198,"address":[7190368,7190373],"length":1,"stats":{"Line":24},"fn_name":"{{closure}}"},{"line":199,"address":[7447838,7447884],"length":1,"stats":{"Line":16},"fn_name":null},{"line":200,"address":[7448013,7447905,7448128],"length":1,"stats":{"Line":16},"fn_name":null},{"line":209,"address":[7448532],"length":1,"stats":{"Line":8},"fn_name":null},{"line":210,"address":[7448556],"length":1,"stats":{"Line":8},"fn_name":null},{"line":211,"address":[7448580],"length":1,"stats":{"Line":8},"fn_name":null},{"line":219,"address":[7451262,7451300,7452565,7451792],"length":1,"stats":{"Line":13},"fn_name":null}],"covered":63,"coverable":63},{"path":["/","usr","src","regex","tests","replace.rs"],"content":"macro_rules! replace(\n    ($name:ident, $which:ident, $re:expr,\n     $search:expr, $replace:expr, $result:expr) => (\n        #[test]\n        fn $name() {\n            let re = regex!($re);\n            assert_eq!(re.$which(text!($search), $replace), text!($result));\n        }\n    );\n);\n\nreplace!(first, replace, r\"[0-9]\", \"age: 26\", t!(\"Z\"), \"age: Z6\");\nreplace!(plus, replace, r\"[0-9]+\", \"age: 26\", t!(\"Z\"), \"age: Z\");\nreplace!(all, replace_all, r\"[0-9]\", \"age: 26\", t!(\"Z\"), \"age: ZZ\");\nreplace!(\n    groups,\n    replace,\n    r\"(?-u)(\\S+)\\s+(\\S+)\",\n    \"w1 w2\",\n    t!(\"$2 $1\"),\n    \"w2 w1\"\n);\nreplace!(\n    double_dollar,\n    replace,\n    r\"(?-u)(\\S+)\\s+(\\S+)\",\n    \"w1 w2\",\n    t!(\"$2 $$1\"),\n    \"w2 $1\"\n);\n// replace!(adjacent_index, replace,\n// r\"([^aeiouy])ies$\", \"skies\", t!(\"$1y\"), \"sky\");\nreplace!(\n    named,\n    replace_all,\n    r\"(?-u)(?P<first>\\S+)\\s+(?P<last>\\S+)(?P<space>\\s*)\",\n    \"w1 w2 w3 w4\",\n    t!(\"$last $first$space\"),\n    \"w2 w1 w4 w3\"\n);\nreplace!(\n    trim,\n    replace_all,\n    \"^[ \\t]+|[ \\t]+$\",\n    \" \\t  trim me\\t   \\t\",\n    t!(\"\"),\n    \"trim me\"\n);\nreplace!(number_hypen, replace, r\"(.)(.)\", \"ab\", t!(\"$1-$2\"), \"a-b\");\n// replace!(number_underscore, replace, r\"(.)(.)\", \"ab\", t!(\"$1_$2\"), \"a_b\");\nreplace!(\n    simple_expand,\n    replace_all,\n    r\"(?-u)(\\w) (\\w)\",\n    \"a b\",\n    t!(\"$2 $1\"),\n    \"b a\"\n);\nreplace!(\n    literal_dollar1,\n    replace_all,\n    r\"(?-u)(\\w+) (\\w+)\",\n    \"a b\",\n    t!(\"$$1\"),\n    \"$1\"\n);\nreplace!(\n    literal_dollar2,\n    replace_all,\n    r\"(?-u)(\\w+) (\\w+)\",\n    \"a b\",\n    t!(\"$2 $$c $1\"),\n    \"b $c a\"\n);\nreplace!(\n    no_expand1,\n    replace,\n    r\"(?-u)(\\S+)\\s+(\\S+)\",\n    \"w1 w2\",\n    no_expand!(\"$2 $1\"),\n    \"$2 $1\"\n);\nreplace!(\n    no_expand2,\n    replace,\n    r\"(?-u)(\\S+)\\s+(\\S+)\",\n    \"w1 w2\",\n    no_expand!(\"$$1\"),\n    \"$$1\"\n);\nuse_!(Captures);\nreplace!(\n    closure_returning_reference,\n    replace,\n    r\"([0-9]+)\",\n    \"age: 26\",\n    |captures: &Captures| {\n        match_text!(captures.get(1).unwrap())[0..1].to_owned()\n    },\n    \"age: 2\"\n);\nreplace!(\n    closure_returning_value,\n    replace,\n    r\"[0-9]+\",\n    \"age: 26\",\n    |_captures: &Captures| t!(\"Z\").to_owned(),\n    \"age: Z\"\n);\n\n// See https://github.com/rust-lang/regex/issues/314\nreplace!(\n    match_at_start_replace_with_empty,\n    replace_all,\n    r\"foo\",\n    \"foobar\",\n    t!(\"\"),\n    \"bar\"\n);\n\n// See https://github.com/rust-lang/regex/issues/393\nreplace!(single_empty_match, replace, r\"^\", \"bar\", t!(\"foo\"), \"foobar\");\n\n// See https://github.com/rust-lang/regex/issues/399\nreplace!(\n    capture_longest_possible_name,\n    replace_all,\n    r\"(.)\",\n    \"b\",\n    t!(\"${1}a $1a\"),\n    \"ba \"\n);\n","traces":[{"line":5,"address":[7480384,7480048,7480165,7479157,7480933,7480277,7479824,7479152,7480608,7481104,7481216,7479605,7479712,7480272,7479488,7480613,7480501,7479493,7479381,7479269,7479829,7480160,7481109,7481221,7480389,7479376,7479600,7479264,7479936,7481328,7480496,7480928,7481333,7479941,7479717,7480053],"length":1,"stats":{"Line":432},"fn_name":"{{closure}}"},{"line":6,"address":[4285829,4289390,4295237,4285070,4295198,4295902,4290149,4287269,4296661,4287230,4288670,4295941,4285109,4287950,4291550,4290110,4285790,4292309,4293781,4289429,4292270,4288709,4290830,4286549,4294533,4296622,4291589,4297381,4293029,4294494,4287989,4286510,4292990,4293742,4290869,4297342],"length":1,"stats":{"Line":288},"fn_name":null},{"line":7,"address":[5239789,5239634,5240509,5242668,5248322,5243234,5244109,5241229,5240354,5241794,5245394,5246141,5250466,5247051,5238194,5241074,5243389,5249180,5247618,5246893,5249901,5243954,5249746,5241949,5244829,5245549,5242514,5246299,5247760,5248464,5249026,5239069,5244674,5238914,5238349,5250621],"length":1,"stats":{"Line":288},"fn_name":null},{"line":80,"address":[5246114],"length":1,"stats":{"Line":8},"fn_name":null},{"line":88,"address":[8283149],"length":1,"stats":{"Line":8},"fn_name":null},{"line":97,"address":[7480720],"length":1,"stats":{"Line":8},"fn_name":"{{closure}}"},{"line":98,"address":[5848442],"length":1,"stats":{"Line":8},"fn_name":null},{"line":107,"address":[5848736,5848760],"length":1,"stats":{"Line":16},"fn_name":"{{closure}}"}],"covered":8,"coverable":8},{"path":["/","usr","src","regex","tests","searcher.rs"],"content":"macro_rules! searcher {\n    ($name:ident, $re:expr, $haystack:expr) => (\n        searcher!($name, $re, $haystack, vec vec![]);\n    );\n    ($name:ident, $re:expr, $haystack:expr, $($steps:expr,)*) => (\n        searcher!($name, $re, $haystack, vec vec![$($steps),*]);\n    );\n    ($name:ident, $re:expr, $haystack:expr, $($steps:expr),*) => (\n        searcher!($name, $re, $haystack, vec vec![$($steps),*]);\n    );\n    ($name:ident, $re:expr, $haystack:expr, vec $expect_steps:expr) => (\n        #[test]\n        #[allow(unused_imports)]\n        fn $name() {\n            searcher_expr! {{\n                use std::str::pattern::{Pattern, Searcher};\n                use std::str::pattern::SearchStep::{Match, Reject, Done};\n                let re = regex!($re);\n                let mut se = re.into_searcher($haystack);\n                let mut got_steps = vec![];\n                loop {\n                    match se.next() {\n                        Done => break,\n                        step => { got_steps.push(step); }\n                    }\n                }\n                assert_eq!(got_steps, $expect_steps);\n            }}\n        }\n    );\n}\n\nsearcher!(searcher_empty_regex_empty_haystack, r\"\", \"\", Match(0, 0));\nsearcher!(\n    searcher_empty_regex,\n    r\"\",\n    \"ab\",\n    Match(0, 0),\n    Reject(0, 1),\n    Match(1, 1),\n    Reject(1, 2),\n    Match(2, 2)\n);\nsearcher!(searcher_empty_haystack, r\"\\d\", \"\");\nsearcher!(searcher_one_match, r\"\\d\", \"5\", Match(0, 1));\nsearcher!(searcher_no_match, r\"\\d\", \"a\", Reject(0, 1));\nsearcher!(\n    searcher_two_adjacent_matches,\n    r\"\\d\",\n    \"56\",\n    Match(0, 1),\n    Match(1, 2)\n);\nsearcher!(\n    searcher_two_non_adjacent_matches,\n    r\"\\d\",\n    \"5a6\",\n    Match(0, 1),\n    Reject(1, 2),\n    Match(2, 3)\n);\nsearcher!(searcher_reject_first, r\"\\d\", \"a6\", Reject(0, 1), Match(1, 2));\nsearcher!(\n    searcher_one_zero_length_matches,\n    r\"\\d*\",\n    \"a1b2\",\n    Match(0, 0),  // ^\n    Reject(0, 1), // a\n    Match(1, 2),  // a1\n    Reject(2, 3), // a1b\n    Match(3, 4),  // a1b2\n);\nsearcher!(\n    searcher_many_zero_length_matches,\n    r\"\\d*\",\n    \"a1bbb2\",\n    Match(0, 0),  // ^\n    Reject(0, 1), // a\n    Match(1, 2),  // a1\n    Reject(2, 3), // a1b\n    Match(3, 3),  // a1bb\n    Reject(3, 4), // a1bb\n    Match(4, 4),  // a1bbb\n    Reject(4, 5), // a1bbb\n    Match(5, 6),  // a1bbba\n);\nsearcher!(\n    searcher_unicode,\n    r\".+?\",\n    \"Ⅰ1Ⅱ2\",\n    Match(0, 3),\n    Match(3, 4),\n    Match(4, 7),\n    Match(7, 8)\n);\n","traces":[{"line":14,"address":[4232048,4231952,4231936,4232016,4231920,4231888,4231904,4231984,4231968,4232000,4232032],"length":1,"stats":{"Line":165},"fn_name":"searcher_empty_regex_empty_haystack"}],"covered":1,"coverable":1},{"path":["/","usr","src","regex","tests","set.rs"],"content":"matset!(set1, &[\"a\", \"a\"], \"a\", 0, 1);\nmatset!(set2, &[\"a\", \"a\"], \"ba\", 0, 1);\nmatset!(set3, &[\"a\", \"b\"], \"a\", 0);\nmatset!(set4, &[\"a\", \"b\"], \"b\", 1);\nmatset!(set5, &[\"a|b\", \"b|a\"], \"b\", 0, 1);\nmatset!(set6, &[\"foo\", \"oo\"], \"foo\", 0, 1);\nmatset!(set7, &[\"^foo\", \"bar$\"], \"foo\", 0);\nmatset!(set8, &[\"^foo\", \"bar$\"], \"foo bar\", 0, 1);\nmatset!(set9, &[\"^foo\", \"bar$\"], \"bar\", 1);\nmatset!(set10, &[r\"[a-z]+$\", \"foo\"], \"01234 foo\", 0, 1);\nmatset!(set11, &[r\"[a-z]+$\", \"foo\"], \"foo 01234\", 1);\nmatset!(set12, &[r\".*?\", \"a\"], \"zzzzzza\", 0, 1);\nmatset!(set13, &[r\".*\", \"a\"], \"zzzzzza\", 0, 1);\nmatset!(set14, &[r\".*\", \"a\"], \"zzzzzz\", 0);\nmatset!(set15, &[r\"(?-u)\\ba\\b\"], \"hello a bye\", 0);\nmatset!(set16, &[\"a\"], \"a\", 0);\nmatset!(set17, &[\".*a\"], \"a\", 0);\nmatset!(set18, &[\"a\", \"β\"], \"β\", 1);\n\n// regexes that match the empty string\nmatset!(setempty1, &[\"\", \"a\"], \"abc\", 0, 1);\nmatset!(setempty2, &[\"\", \"b\"], \"abc\", 0, 1);\nmatset!(setempty3, &[\"\", \"z\"], \"abc\", 0);\nmatset!(setempty4, &[\"a\", \"\"], \"abc\", 0, 1);\nmatset!(setempty5, &[\"b\", \"\"], \"abc\", 0, 1);\nmatset!(setempty6, &[\"z\", \"\"], \"abc\", 1);\nmatset!(setempty7, &[\"b\", \"(?:)\"], \"abc\", 0, 1);\nmatset!(setempty8, &[\"(?:)\", \"b\"], \"abc\", 0, 1);\nmatset!(setempty9, &[\"c(?:)\", \"b\"], \"abc\", 0, 1);\n\nnomatset!(nset1, &[\"a\", \"a\"], \"b\");\nnomatset!(nset2, &[\"^foo\", \"bar$\"], \"bar foo\");\nnomatset!(\n    nset3,\n    {\n        let xs: &[&str] = &[];\n        xs\n    },\n    \"a\"\n);\nnomatset!(nset4, &[r\"^rooted$\", r\"\\.log$\"], \"notrooted\");\n\n// See: https://github.com/rust-lang/regex/issues/187\n#[test]\nfn regression_subsequent_matches() {\n    let set = regex_set!(&[\"ab\", \"b\"]);\n    let text = text!(\"ba\");\n    assert!(set.matches(text).matched(1));\n    assert!(set.matches(text).matched(1));\n}\n\n#[test]\nfn get_set_patterns() {\n    let set = regex_set!(&[\"a\", \"b\"]);\n    assert_eq!(vec![\"a\", \"b\"], set.patterns());\n}\n","traces":[{"line":1,"address":[8497830],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2,"address":[8499014],"length":1,"stats":{"Line":8},"fn_name":null},{"line":3,"address":[8500198],"length":1,"stats":{"Line":8},"fn_name":null},{"line":4,"address":[8501382],"length":1,"stats":{"Line":8},"fn_name":null},{"line":5,"address":[8502566],"length":1,"stats":{"Line":8},"fn_name":null},{"line":6,"address":[8503750],"length":1,"stats":{"Line":8},"fn_name":null},{"line":7,"address":[8504934],"length":1,"stats":{"Line":8},"fn_name":null},{"line":8,"address":[8506118],"length":1,"stats":{"Line":8},"fn_name":null},{"line":9,"address":[8507302],"length":1,"stats":{"Line":8},"fn_name":null},{"line":10,"address":[8508486],"length":1,"stats":{"Line":8},"fn_name":null},{"line":11,"address":[8509670],"length":1,"stats":{"Line":8},"fn_name":null},{"line":12,"address":[8510854],"length":1,"stats":{"Line":8},"fn_name":null},{"line":13,"address":[8512038],"length":1,"stats":{"Line":8},"fn_name":null},{"line":14,"address":[8513222],"length":1,"stats":{"Line":8},"fn_name":null},{"line":15,"address":[8514406],"length":1,"stats":{"Line":8},"fn_name":null},{"line":16,"address":[8515590],"length":1,"stats":{"Line":8},"fn_name":null},{"line":17,"address":[8516774],"length":1,"stats":{"Line":8},"fn_name":null},{"line":18,"address":[8517958],"length":1,"stats":{"Line":8},"fn_name":null},{"line":21,"address":[8519142],"length":1,"stats":{"Line":8},"fn_name":null},{"line":22,"address":[8520326],"length":1,"stats":{"Line":8},"fn_name":null},{"line":23,"address":[8521510],"length":1,"stats":{"Line":8},"fn_name":null},{"line":24,"address":[8522694],"length":1,"stats":{"Line":8},"fn_name":null},{"line":25,"address":[8523878],"length":1,"stats":{"Line":8},"fn_name":null},{"line":26,"address":[8525062],"length":1,"stats":{"Line":8},"fn_name":null},{"line":27,"address":[8526246],"length":1,"stats":{"Line":8},"fn_name":null},{"line":28,"address":[8527430],"length":1,"stats":{"Line":8},"fn_name":null},{"line":29,"address":[8528614],"length":1,"stats":{"Line":8},"fn_name":null},{"line":31,"address":[8529798],"length":1,"stats":{"Line":8},"fn_name":null},{"line":32,"address":[8530838],"length":1,"stats":{"Line":8},"fn_name":null},{"line":36,"address":[8531902],"length":1,"stats":{"Line":8},"fn_name":null},{"line":41,"address":[8532950],"length":1,"stats":{"Line":8},"fn_name":null},{"line":45,"address":[5986576,5986581],"length":1,"stats":{"Line":24},"fn_name":"{{closure}}"},{"line":46,"address":[8534012,8533975],"length":1,"stats":{"Line":16},"fn_name":null},{"line":47,"address":[8534126],"length":1,"stats":{"Line":8},"fn_name":null},{"line":48,"address":[8534257,8534153,8534344],"length":1,"stats":{"Line":16},"fn_name":null},{"line":49,"address":[8534308,8534377,8534476],"length":1,"stats":{"Line":16},"fn_name":null},{"line":53,"address":[5986688,5986693],"length":1,"stats":{"Line":24},"fn_name":"{{closure}}"},{"line":54,"address":[8534583,8534620],"length":1,"stats":{"Line":16},"fn_name":null},{"line":55,"address":[8534750,8534831],"length":1,"stats":{"Line":16},"fn_name":null}],"covered":39,"coverable":39},{"path":["/","usr","src","regex","tests","shortest_match.rs"],"content":"macro_rules! shortmat {\n    ($name:ident, $re:expr, $text:expr, $shortest_match:expr) => {\n        #[test]\n        fn $name() {\n            let text = text!($text);\n            let re = regex!($re);\n            assert_eq!($shortest_match, re.shortest_match(text));\n        }\n    };\n}\n\nshortmat!(t01, r\"a+\", r\"aa\", Some(1));\n// Test that the reverse suffix optimization gets it right.\nshortmat!(t02, r\".*(?:abcd)+\", r\"abcdabcd\", Some(4));\n","traces":[{"line":4,"address":[7463296,7463968,7464033,7463361],"length":1,"stats":{"Line":12},"fn_name":"t01"},{"line":5,"address":[5795286,5794550],"length":1,"stats":{"Line":2},"fn_name":null},{"line":6,"address":[7463337,7463383,7464009,7464055],"length":1,"stats":{"Line":6},"fn_name":null},{"line":7,"address":[7463404,7463598,7464076,7463620,7464292,7464270],"length":1,"stats":{"Line":8},"fn_name":null},{"line":12,"address":[7463317],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[7463989],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","usr","src","regex","tests","suffix_reverse.rs"],"content":"mat!(t01, r\".*abcd\", r\"abcd\", Some((0, 4)));\nmat!(t02, r\".*(?:abcd)+\", r\"abcd\", Some((0, 4)));\nmat!(t03, r\".*(?:abcd)+\", r\"abcdabcd\", Some((0, 8)));\nmat!(t04, r\".*(?:abcd)+\", r\"abcdxabcd\", Some((0, 9)));\nmat!(t05, r\".*x(?:abcd)+\", r\"abcdxabcd\", Some((0, 9)));\nmat!(t06, r\"[^abcd]*x(?:abcd)+\", r\"abcdxabcd\", Some((4, 9)));\n","traces":[{"line":1,"address":[4212985,4214344],"length":1,"stats":{"Line":13},"fn_name":null},{"line":2,"address":[8403540,8404916,8403502],"length":1,"stats":{"Line":13},"fn_name":null},{"line":3,"address":[8024281,8025640],"length":1,"stats":{"Line":13},"fn_name":null},{"line":4,"address":[5310654,5310692,5312036],"length":1,"stats":{"Line":13},"fn_name":null},{"line":5,"address":[4221689,4223048],"length":1,"stats":{"Line":13},"fn_name":null},{"line":6,"address":[6032174,6033588,6032212],"length":1,"stats":{"Line":13},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","usr","src","regex","tests","test_backtrack.rs"],"content":"#![cfg_attr(feature = \"pattern\", feature(pattern))]\n\nextern crate rand;\nextern crate regex;\n\nmacro_rules! regex_new {\n    ($re:expr) => {{\n        use regex::internal::ExecBuilder;\n        ExecBuilder::new($re)\n            .bounded_backtracking()\n            .build()\n            .map(|e| e.into_regex())\n    }};\n}\n\nmacro_rules! regex {\n    ($re:expr) => {\n        regex_new!($re).unwrap()\n    };\n}\n\nmacro_rules! regex_set_new {\n    ($re:expr) => {{\n        use regex::internal::ExecBuilder;\n        ExecBuilder::new_many($re)\n            .bounded_backtracking()\n            .build()\n            .map(|e| e.into_regex_set())\n    }};\n}\n\nmacro_rules! regex_set {\n    ($res:expr) => {\n        regex_set_new!($res).unwrap()\n    };\n}\n\n// Must come before other module definitions.\ninclude!(\"macros_str.rs\");\ninclude!(\"macros.rs\");\n\nmod api;\nmod api_str;\nmod crazy;\nmod flags;\nmod fowler;\nmod multiline;\nmod noparse;\nmod regression;\nmod replace;\nmod searcher;\nmod set;\nmod suffix_reverse;\n#[cfg(feature = \"unicode\")]\nmod unicode;\n#[cfg(feature = \"unicode-perl\")]\nmod word_boundary;\n#[cfg(feature = \"unicode-perl\")]\nmod word_boundary_unicode;\n","traces":[{"line":12,"address":[4224960,4224080,4218192,4219015,4225696,4221296,4223159,4223808,4222112,4221072,4221184,4224624,4216224,4216727,4223152,4215840,4222656,4219552,4215680,4216455,4221079,4216039,4216343,4219287,4223383,4219824,4223040,4224967,4222391,4221575,4216992,4215760,4218464,4224631,4220103,4216720,4222663,4215767,4223271,4224855,4216448,4217920,4216032,4220647,4219008,4218199,4217271,4223815,4224352,4222928,4225264,4216336,4215687,4223264,4218736,4216231,4224359,4219280,4225808,4220640,4222384,4216999,4224736,4217264,4218743,4224087,4224848,4221303,4222119,4221191,4224743,4223376,4225271,4225703,4217927,4217536,4221840,4220096,4219559,4225815,4217543,4215927,4217808,4220215,4215920,4218471,4219831,4223047,4215847,4221568,4220208,4221847,4222935,4217815],"length":1,"stats":{"Line":1456},"fn_name":"{{closure}}"},{"line":28,"address":[8473847,8472944,8473056,8474960,8475520,8472608,8472391,8473735,8474288,8472727,8473168,8473840,8475856,8475303,8475863,8473728,8474400,8473175,8474407,8474743,8472496,8473287,8472720,8474064,8474848,8475632,8475639,8475968,8475751,8473063,8475184,8473623,8475072,8472384,8473399,8474071,8474183,8473959,8474624,8472503,8475079,8475408,8475415,8475296,8473616,8474736,8473952,8475527,8474512,8472839,8474855,8475975,8473280,8473504,8474519,8474631,8472615,8473511,8474295,8475744,8473392,8474176,8474967,8472832,8472951,8475191],"length":1,"stats":{"Line":66},"fn_name":"{{closure}}"}],"covered":2,"coverable":2},{"path":["/","usr","src","regex","tests","test_backtrack_bytes.rs"],"content":"extern crate rand;\nextern crate regex;\n\nmacro_rules! regex_new {\n    ($re:expr) => {{\n        use regex::internal::ExecBuilder;\n        ExecBuilder::new($re)\n            .bounded_backtracking()\n            .only_utf8(false)\n            .build()\n            .map(|e| e.into_byte_regex())\n    }};\n}\n\nmacro_rules! regex {\n    ($re:expr) => {\n        regex_new!($re).unwrap()\n    };\n}\n\nmacro_rules! regex_set_new {\n    ($re:expr) => {{\n        use regex::internal::ExecBuilder;\n        ExecBuilder::new_many($re)\n            .bounded_backtracking()\n            .only_utf8(false)\n            .build()\n            .map(|e| e.into_byte_regex_set())\n    }};\n}\n\nmacro_rules! regex_set {\n    ($res:expr) => {\n        regex_set_new!($res).unwrap()\n    };\n}\n\n// Must come before other module definitions.\ninclude!(\"macros_bytes.rs\");\ninclude!(\"macros.rs\");\n\nmod api;\nmod bytes;\nmod crazy;\nmod flags;\nmod fowler;\nmod multiline;\nmod noparse;\nmod regression;\nmod replace;\nmod set;\nmod suffix_reverse;\n#[cfg(feature = \"unicode\")]\nmod unicode;\n#[cfg(feature = \"unicode-perl\")]\nmod word_boundary;\n#[cfg(feature = \"unicode-perl\")]\nmod word_boundary_ascii;\n","traces":[{"line":11,"address":[4709495,4709063,4708631,4701712,4703008,4704311,4704743,4706903,4701280,4702576,4703447,4702151,4701287,4706039,4706896,4707767,4708624,4704736,4703015,4700423,4701719,4707328,4702583,4705607,4703879,4699552,4699984,4703440,4700855,4705600,4706464,4708199,4699991,4709056,4699559,4708192,4705175,4710359,4707760,4709488,4709927,4702144,4703872,4700416,4707335,4710352,4705168,4700848,4706471,4704304,4709920,4706032],"length":1,"stats":{"Line":1510},"fn_name":"{{closure}}"},{"line":28,"address":[6685351,6685799,6684679,6683664,6683104,6685456,6684224,6685127,6685120,6684448,6685792,6684672,6686576,6685680,6683671,6684112,6684231,6685687,6686128,6686247,6683895,6684455,6684000,6684560,6685904,6683111,6685232,6685568,6685911,6686352,6683447,6682999,6683440,6683223,6686016,6684343,6684567,6683335,6685463,6684791,6686023,6683776,6683328,6682992,6684896,6684903,6685239,6685344,6683216,6686471,6683783,6685575,6685015,6686583,6686135,6684119,6686464,6685008,6684007,6684336,6683888,6686240,6683552,6683559,6684784,6686359],"length":1,"stats":{"Line":66},"fn_name":"{{closure}}"}],"covered":2,"coverable":2},{"path":["/","usr","src","regex","tests","test_backtrack_utf8bytes.rs"],"content":"#![cfg_attr(feature = \"pattern\", feature(pattern))]\n\nextern crate rand;\nextern crate regex;\n\nmacro_rules! regex_new {\n    ($re:expr) => {{\n        use regex::internal::ExecBuilder;\n        ExecBuilder::new($re)\n            .bounded_backtracking()\n            .bytes(true)\n            .build()\n            .map(|e| e.into_regex())\n    }};\n}\n\nmacro_rules! regex {\n    ($re:expr) => {\n        regex_new!($re).unwrap()\n    };\n}\n\nmacro_rules! regex_set_new {\n    ($re:expr) => {{\n        use regex::internal::ExecBuilder;\n        ExecBuilder::new_many($re)\n            .bounded_backtracking()\n            .bytes(true)\n            .build()\n            .map(|e| e.into_regex_set())\n    }};\n}\n\nmacro_rules! regex_set {\n    ($res:expr) => {\n        regex_set_new!($res).unwrap()\n    };\n}\n\n// Must come before other module definitions.\ninclude!(\"macros_str.rs\");\ninclude!(\"macros.rs\");\n\nmod api;\nmod api_str;\nmod crazy;\nmod flags;\nmod fowler;\nmod multiline;\nmod noparse;\nmod regression;\nmod replace;\nmod searcher;\nmod set;\nmod suffix_reverse;\n#[cfg(feature = \"unicode\")]\nmod unicode;\n#[cfg(feature = \"unicode-perl\")]\nmod word_boundary;\n#[cfg(feature = \"unicode-perl\")]\nmod word_boundary_unicode;\n","traces":[{"line":13,"address":[4230208,4228855,4228576,4227760,4229671,4230480,4228311,4228583,4229127,4228304,4228032,4229120,4230487,4229943,4228848,4229664,4229392,4228039,4230215,4229936,4227767,4229399],"length":1,"stats":{"Line":1456},"fn_name":"{{closure}}"},{"line":30,"address":[5986279,5984928,5985943,5984487,5984039,5984144,5983584,5983255,5983920,5985264,5984711,5983696,5986608,5986503,5985383,5983927,5986496,5986384,5984032,5984599,5984816,5984368,5984256,5986167,5985040,5983367,5984151,5986720,5985824,5985376,5985712,5986160,5986615,5983136,5983808,5984704,5985152,5984935,5985719,5984480,5983360,5986048,5985831,5986055,5986272,5985271,5986727,5985047,5985495,5983591,5985607,5983248,5984375,5983479,5983472,5985488,5985600,5984592,5983703,5986391,5984263,5983815,5985159,5985936,5984823,5983143],"length":1,"stats":{"Line":66},"fn_name":"{{closure}}"}],"covered":2,"coverable":2},{"path":["/","usr","src","regex","tests","test_crates_regex.rs"],"content":"extern crate quickcheck;\nextern crate regex;\n\n/*\n * This test is a minimal version of <rofl_0> and <subdiff_0>\n *\n * Once this bug gets fixed, uncomment rofl_0 and subdiff_0\n * (in `tests/crates_regex.rs`).\n#[test]\nfn word_boundary_backtracking_default_mismatch() {\n    use regex::internal::ExecBuilder;\n\n    let backtrack_re = ExecBuilder::new(r\"\\b\")\n        .bounded_backtracking()\n        .build()\n        .map(|exec| exec.into_regex())\n        .map_err(|err| format!(\"{}\", err))\n        .unwrap();\n\n    let default_re = ExecBuilder::new(r\"\\b\")\n        .build()\n        .map(|exec| exec.into_regex())\n        .map_err(|err| format!(\"{}\", err))\n        .unwrap();\n\n    let input = \"䅅\\\\u{a0}\";\n\n    let fi1 = backtrack_re.find_iter(input);\n    let fi2 = default_re.find_iter(input);\n    for (m1, m2) in fi1.zip(fi2) {\n        assert_eq!(m1, m2);\n    }\n}\n*/\n\nmod consistent;\n\nmod crates_regex {\n\n    macro_rules! consistent {\n        ($test_name:ident, $regex_src:expr) => {\n            #[test]\n            fn $test_name() {\n                use super::consistent::backends_are_consistent;\n\n                if option_env!(\"RUST_REGEX_RANDOM_TEST\").is_some() {\n                    match backends_are_consistent($regex_src) {\n                        Ok(_) => {}\n                        Err(err) => panic!(\"{}\", err),\n                    }\n                }\n            }\n        };\n    }\n\n    include!(\"crates_regex.rs\");\n}\n","traces":[{"line":43,"address":[4544144,4429144,4272232,4247456,4406720,4344224,4502144,4245016,4533976,4261904,4391936,4242080,4345232,4401928,4520288,4256864,4282312,4303904,4548512,4331032,4375384,4345904,4551200,4510792,4241408,4452752,4317256,4411672,4387480,4249808,4316672,4358248,4288448,4327672,4382776,4384208,4543472,4550104,4435528,4261480,4300456,4348256,4265848,4267952,4351952,4490720,4352536,4388240,4500376,4311296,4507184,4217216,4477528,4507856,4336496,4476184,4550528,4322968,4478200,4270304,4316584,4247792,4281728,4337080,4405712,4407304,4439648,4363040,4466104,4440568,4439984,4236280,4291048,4238296,4316000,4268536,4272656,4426880,4252160,4388576,4403360,4383872,4498112,4527008,4318352,4430488,4481984,4306928,4404032,4297520,4225192,4307264,4392520,4292392,4377400,4376816,4444352,4250056,4519192,4404280,4232248,4437632,4544728,4246448,4222256,4290040,4384792,4348928,4360016,4417048,4532384,4484248,4299784,4419488,4528264,4493072,4431496,4383780,4409072,4448968,4374040,4425200,4406048,4252744,4518944,4382528,4357664,4310200,4335152,4373032,4368080,4328008,4498784,4553552,4421752,4523224,4251824,4331456,4415032,4226200,4317008,4428808,4461064,4482320,4469464,4397896,4522552,4550776,4220912,4297432,4419152,4297768,4341872,4374464,4512136,4233344,4300120,4311544,4363712,4228216,4365392,4215872,4440232,4460728,4501136,4348504,4548088,4384544,4300880,4499792,4535656,4385552,4289792,4478960,4450648,4438888,4364048,4363376,4326664,4519616,4219568,4233008,4524232,4531960,4249384,4285336,4414360,4540112,4341784,4498696,4243424,4497016,4282648,4324064,4367656,4487360,4241992,4294408,4277696,4309192,4344472,4365304,4324400,4257112,4371440,4502728,4548760,4399912,4297184,4335400,4497352,4358920,4425536,4294160,4218224,4390592,4461152,4468120,4318600,4428896,4456024,4562288,4246112,4543808,4243672,4313896,4506848,4292056,4309864,4416712,4525912,4419400,4343128,4457792,4423520,4550192,4254424,4240984,4481224,4493992,4333136,4518184,4288696,4359680,4461736,4495088,4267192,4437968,4275928,4231664,4425872,4400920,4217464,4494664,4386224,4449728,4534312,4258120,4511800,4400000,4480304,4320032,4264168,4291808,4467200,4421168,4338088,4341200,4408064,4400336,4484920,4438216,4382864,4241320,4408648,4270888,4288112,4448632,4335736,4350520,4560944,4559600,4344136,4408736,4468456,4539440,4261144,4268960,4243088,4441664,4282984,4484000,4216792,4229648,4542128,4555904,4385128,4441240,4337752,4468208,4399328,4355896,4273328,4339768,4444264,4485256,4509784,4279288,4521296,4460056,4545400,4522888,4480976,4553128,4347496,4383536,4249136,4287104,4373456,4442672,4485344,4256192,4455016,4344808,4215536,4435952,4466440,4410664,4315912,4218808,4292816,4282064,4350184,4237960,4407728,4416128,4234016,4473584,4402264,4255432,4276688,4434608,4453336,4458800,4464848,4246360,4273664,4283656,4467536,4265936,4321288,4350944,4229984,4558592,4264504,4351616,4536416,4539352,4405960,4475600,4501384,4254088,4540360,4430824,4463416,4464760,4403272,4276352,4301216,4426208,4379168,4470560,4286008,4352872,4305920,4391512,4400584,4445024,4288784,4540024,4295504,4555480,4357912,4420832,4240400,4278280,4325072,4300544,4539776,4507432,4478624,4290128,4286680,4554896,4531288,4232920,4387568,4478872,4246696,4301888,4360264,4496680,4563208,4441912,4249048,4269544,4240736,4276936,4235944,4279960,4378744,4220240,4413012,4415456,4313312,4522304,4368328,4451992,4219480,4472912,4219144,4360352,4396552,4432840,4442000,4449056,4229560,4538344,4560184,4389920,4491976,4532632,4340440,4235024,4239640,4308944,4267528,4321040,4420408,4459472,4475512,4396216,4329776,4514152,4231328,4513816,4517936,4289032,4448720,4504160,4527344,4444600,4516592,4309528,4497104,4326328,4355560,4299448,4508104,4328344,4332376,4329016,4238384,4227544,4369672,4542712,4353968,4385888,4259888,4510120,4252072,4482232,4370096,4449640,4407640,4445696,4488032,4535320,4287016,4337168,4415368,4480888,4443008,4292728,4362368,4297856,4384116,4259800,4324648,4339432,4231576,4522216,4541032,4476520,4349848,4275256,4549768,4328768,4377064,4381768,4293736,4286096,4375472,4492736,4515584,4554224,4544056,4377736,4415704,4525328,4266856,4390504,4319024,4502056,4320280,4489040,4367072,4394624,4234688,4346152,4561616,4311968,4489288,4461488,4562536,4245104,4250480,4504744,4474256,4415792,4463080,4505752,4523648,4482568,4222928,4236616,4508864,4454768,4522976,4404616,4224520,4510880,4299112,4253840,4276264,4443256,4534736,4550440,4362280,4551872,4379080,4423768,4494752,4405376,4524992,4548424,4252496,4405040,4423096,4271984,4457120,4514912,4304488,4559936,4289368,4373704,4447712,4414024,4424192,4393280,4325744,4456448,4458040,4355648,4511552,4458376,4339184,4219816,4352288,4228976,4503736,4434520,4436536,4226624,4295168,4296088,4535408,4439312,4307600,4552120,4370680,4414112,4560520,4427552,4220152,4245688,4501048,4508440,4411088,4435864,4234264,4338512,4510208,4440656,4505080,4538096,4491640,4530280,4528936,4244096,4372112,4468792,4302896,4464088,4285088,4458712,4272992,4456696,4537088,4320616,4317344,4410328,4476944,4295752,4358336,4463504,4559176,4558256,4299200,4366400,4283320,4306256,4426456,4400248,4234600,4278704,4247032,4429816,4485928,4216544,4372448,4503400,4352200,4470224,4298864,4237040,4220824,4469216,4499704,4549520,4285000,4408984,4460480,4515832,4279376,4251152,4532296,4222840,4434184,4219904,4256104,4257200,4285672,4325320,4361360,4455776,4438552,4487024,4547504,4371104,4299872,4561952,4426792,4545824,4255520,4327088,4409320,4271560,4235272,4218896,4305496,4346576,4525576,4464176,4411336,4370344,4340192,4294072,4473920,4555816,4345480,4552456,4286432,4376392,4408312,4289456,4498360,4313984,4492312,4396304,4429232,4313648,4244344,4283408,4554472,4451408,4312552,4244768,4337840,4518608,4553216,4558504,4422176,4559848,4404368,4536752,4410080,4435192,4235360,4256528,4275008,4360688,4336744,4387904,4420160,4523312,4401344,4327760,4472576,4482656,4495000,4226536,4260224,4343800,4485680,4308520,4302560,4243336,4417136,4281392,4487696,4454680,4371016,4294744,4450312,4481560,4537424,4362616,4389584,4532720,4534648,4528600,4431832,4419064,4385464,4349600,4462072,4423432,4295840,4479880,4527680,4356656,4416464,4293152,4476608,4386808,4306592,4315576,4254848,4543048,4453672,4457456,4367320,4491304,4230656,4227632,4420496,4533056,4549432,4457368,4487608,4216456,4385800,4449304,4338760,4372360,4419736,4479296,4373792,4308856,4392944,4313224,4393616,4320368,4396888,4466528,4499368,4462744,4483576,4311208,4423856,4239976,4350608,4335064,4243000,4245776,4223176,4388152,4430240,4432256,4478536,4521208,4526248,4348592,4454008,4380512,4493656,4522640,4558840,4463752,4387816,4293400,4221584,4294496,4354216,4477864,4488616,4256776,4340776,4361024,4430152,4490296,4520200,4393192,4470808,4221832,4287688,4277944,4301464,4347832,4428472,4253504,4520960,4377824,4523896,4513232,4304912,4219232,4521968,4541456,4312976,4389496,4417720,4449392,4342456,4225952,4338176,4382440,4433600,4284416,4225616,4465768,4274672,4401680,4559512,4268624,4279624,4316248,4477280,4426544,4524904,4429480,4221248,4326416,4520872,4329104,4486600,4413776,4271224,4496008,4432504,4463840,4465096,4436960,4258792,4262576,4378496,4390928,4358000,4365056,4414448,4275344,4260136,4266184,4379840,4498024,4449976,4221496,4333720,4343552,4240064,4516256,4225864,4262824,4283992,4409656,4496096,4518856,4556824,4241656,4253080,4258456,4363624,4413688,4335488,4446032,4451744,4488280,4287352,4293064,4242752,4403024,4291720,4312216,4341536,4318016,4269880,4485008,4547840,4433512,4458464,4529608,4471480,4247120,4492064,4396640,4412432,4259216,4386560,4556576,4531712,4236032,4459384,4472488,4374376,4288024,4338848,4257448,4468880,4466192,4508776,4534400,4284664,4318264,4320952,4225280,4344560,4486688,4341448,4321376,4495424,4348840,4375808,4512560,4530704,4259128,4252408,4328680,4480216,4284328,4555568,4528352,4399240,4397312,4446704,4228640,4521632,4539016,4452416,4488368,4529024,4245440,4332712,4338424,4519280,4530616,4280968,4333472,4512224,4335824,4455440,4504832,4230904,4298440,4252832,4497688,4512808,4465432,4220488,4251064,4424528,4389160,4398232,4435616,4486352,4456784,4273576,4416376,4337504,4558168,4495760,4443592,4296424,4289704,4440320,4223264,4500464,4273240,4265264,4498448,4502392,4258208,4383112,4353296,4503824,4424440,4534984,4406632,4374128,4527928,4513904,4226288,4269208,4356232,4445944,4334144,4550864,4475176,4327336,4239392,4317592,4482992,4547416,4420744,4302808,4483664,4545064,4234352,4278032,4425112,4249472,4467872,4515160,4557920,4545736,4418728,4355312,4358584,4487944,4444688,4278952,4511216,4551112,4371688,4482904,4351280,4278368,4496432,4353632,4524568,4306504,4554808,4404952,4547752,4470896,4322048,4321712,4281976,4514488,4331368,4541792,4284080,4308608,4317928,4388912,4483912,4527592,4465184,4362704,4446368,4322296,4368416,4455688,4314992,4553888,4520624,4261568,4290464,4310960,4356320,4384456,4255184,4351528,4305160,4397224,4437880,4217800,4267280,4530368,4483240,4458128,4537336,4381856,4450400,4474504,4287440,4342544,4540696,4306168,4378072,4513480,4274248,4310624,4336160,4279712,4433176,4438304,4478288,4429904,4526584,4536664,4337416,4394960,4369760,4222504,4239304,4230232,4366312,4469552,4224944,4442584,4334056,4366648,4342208,4220576,4552208,4291472,4437296,4438976,4504496,4508192,4413440,4467448,4488952,4535072,4506088,4224272,4261816,4340864,4514824,4266520,4406296,4307936,4315240,4407976,4459048,4432928,4469888,4388488,4293824,4443680,4472152,4333384,4552880,4262240,4466776,4314320,4285424,4549096,4233680,4326752,4546496,4330784,4293488,4392608,4423184,4245352,4404704,4298776,4227296,4409408,4493408,4420072,4267864,4386136,4393952,4504408,4517264,4412680,4518272,4350272,4381096,4228552,4217128,4431584,4440992,4414784,4483328,4296848,4534064,4551784,4551536,4255096,4445360,4537672,4342120,4506176,4549184,4323640,4442336,4424776,4427216,4541368,4359256,4447288,4376056,4462408,4319272,4471816,4548176,4562872,4333048,4237376,4398656,4490632,4526336,4247368,4511128,4372784,4491392,4453088,4351864,4238968,4312640,4453760,4513144,4433936,4238632,4451656,4463168,4469128,4489624,4260560,4292144,4246784,4421416,4383200,4226872,4402016,4473160,4553464,4304824,4481896,4380088,4510544,4327000,4417472,4334392,4254512,4367408,4462496,4229896,4319360,4395968,4417808,4268200,4230992,4264840,4356904,4331704,4367744,4421504,4460144,4372024,4380760,4529360,4223936,4318688,4363288,4296176,4336408,4434944,4546160,4561280,4275680,4430576,4529696,4263248,4231912,4224608,4364384,4228888,4436624,4492984,4511888,4263496,4319696,4398904,4456360,4334816,4312888,4506512,4312304,4330024,4349176,4393864,4225528,4244008,4298192,4434856,4232336,4504072,4341112,4509872,4393528,4270640,4444936,4364632,4506424,4296760,4260808,4264592,4562200,4484584,4346488,4558928,4281056,4353544,4368664,4254176,4354304,4416800,4322384,4405624,4556152,4457704,4308184,4529272,4234936,4431920,4248128,4375136,4395296,4535992,4418144,4554136,4327424,4323304,4476856,4514576,4215448,4271312,4439560,4330696,4401256,4444016,4475936,4487272,4546832,4493320,4216880,4443928,4267616,4236704,4261232,4365640,4433848,4383448,4217552,4557496,4516928,4237624,4427800,4524656,4264256,4398320,4343464,4369424,4413352,4361944,4437544,4389248,4359928,4422088,4280720,4422760,4521544,4325408,4329352,4265512,4427128,4471144,4319608,4538432,4370768,4287776,4510456,4512472,4459808,4367992,4440904,4239728,4376144,4253416,4217888,4314568,4259464,4467112,4472824,4334480,4399664,4442920,4240312,4502480,4361696,4484336,4495336,4481312,4500712,4364720,4304576,4316336,4381520,4268288,4307848,4542464,4465520,4395208,4411760,4277608,4277024,4273912,4227880,4253752,4392272,4262152,4298104,4531376,4462832,4348168,4378832,4270552,4400672,4298528,4391264,4464424,4508528,4354976,4215200,4427888,4459720,4490968,4503488,4334728,4461824,4476272,4543384,4489376,4377152,4505416,4516840,4227208,4324312,4480640,4411424,4445272,4450736,4474168,4526672,4248464,4355984,4426120,4450064,4305248,4314232,4380424,4542376,4332040,4241744,4430912,4460392,4249720,4546072,4390168,4304152,4519952,4339520,4224184,4556240,4260896,4545152,4391600,4486016,4238048,4421080,4424104,4551448,4339096,4373368,4303568,4361272,4228304,4379416,4380176,4251400,4250728,4540784,4257872,4473496,4477616,4421840,4533728,4251736,4468544,4357240,4451320,4247704,4402352,4284752,4268872,4397648,4274584,4441328,4331120,4539104,4560272,4324984,4491728,4357328,4250392,4533640,4230568,4276600,4221160,4439224,4356992,4291384,4223512,4429568,4479208,4453424,4241072,4366736,4387144,4359344,4386896,4413104,4236952,4519528,4415120,4376480,4302472,4391176,4447040,4494416,4233592,4336832,4343888,4548848,4387232,4544392,4523984,4281304,4409744,4361608,4425784,4235608,4321960,4359592,4507520,4282400,4280384,4297096,4291136,4432592,4369000,4280048,4309952,4471232,4481648,4453000,4397560,4446280,4560856,4529944,4401008,4358672,4280296,4412096,4559264,4447624,4417384,4248376,4454344,4277272,4277360,4342880,4371776,4321624,4461400,4324736,4378408,4259552,4329688,4546408,4262912,4305832,4345816,4328432,4408400,4340528,4464512,4532968,4474928,4325656,4435280,4533392,4500040,4331792,4506760,4286344,4428224,4371352,4511464,4497440,4226960,4248040,4280632,4406384,4401592,4229312,4294832,4375720,4230320,4306840,4318936,4354640,4525240,4302224,4232672,4279040,4528016,4315664,4366064,4538680,4543136,4531040,4465856,4395880,4374800,4223600,4269632,4407056,4392184,4232584,4455104,4286768,4346240,4237288,4263832,4542040,4353880,4309280,4562624,4389832,4505840,4316920,4365728,4275592,4501808,4368752,4281640,4282736,4462160,4473248,4347584,4474840,4544816,4398992,4352624,4475264,4526000,4260472,4271648,4271896,4452664,4471904,4523560,4530032,4512896,4254760,4274000,4557584,4354552,4422424,4537000,4398568,4363960,4489960,4538008,4394288,4450984,4517600,4240648,4272568,4494080,4535744,4526920,4537760,4222168,4236368,4328096,4248800,4232000,4258544,4531624,4455352,4290712,4516504,4366984,4330360,4501472,4544480,4248712,4258880,4233256,4474592,4326080,4484672,4314904,4357576,4250816,4223848,4434272,4499456,4290800,4332800,4320704,4543720,4411000,4532048,4244432,4353208,4448384,4307512,4424864,4218136,4303144,4340104,4222592,4457032,4552792,4360600,4218560,4459136,4355224,4288360,4359008,4374712,4497776,4289120,4433264,4490048,4538768,4257536,4295080,4380848,4229224,4451072,4246024,4250144,4541704,4524320,4364296,4530952,4369336,4470136,4301128,4556912,4346824,4330448,4412008,4479632,4347160,4314656,4303480,4323392,4370008,4499120,4517848,4517176,4330112,4427464,4446616,4390840,4345144,4394536,4470472,4238720,4295416,4216208,4278616,4494328,4446952,4541120,4347248,4332464,4263584,4477192,4501720,4547080,4292480,4396976,4447376,4412768,4418816,4492400,4263920,4436200,4554560,4562960,4561192,4227968,4251488,4290376,4283744,4302136,4315328,4242664,4274336,4270216,4381432,4507096,4557832,4518520,4253168,4266608,4514240,4490384,4443344,4479544,4509448,4265176,4360936,4342792,4425448,4431160,4255856,4454432,4350856,4553800,4362952,4486264,4491056,4499032,4496768,4407392,4265600,4447960,4347920,4309616,4452328,4561864,4272904,4410416,4266272,4303816,4269968,4493744,4391848,4419824,4233928,4399576,4402688,4515496,4257784,4369088,4325992,4507768,4528688,4416040,4221920,4557160,4349264,4418392,4473832,4436872,4264928,4235696,4301552,4519864,4452080,4256440,4303232,4242328,4300792,4319944,4546744,4561528,4344896,4405288,4422512,4505504,4509112,4224856,4448048,4439896,4310872,4323728,4379752,4296512,4346912,4557248,4395632,4362032,4521880,4244680,4503152,4438640,4495672,4313560,4418056,4489712,4412344,4517512,4540448,4351192,4469800,4365976,4432168,4467784,4305584,4525664,4460816,4403696,4310288,4301800,4283072,4352960,4418480,4403944,4266944,4274920,4422848,4349936,4388824,4343216,4539688,4516168,4270976,4329440,4471568,4536080,4442248,4216120,4376728,4545488,4345568,4492648,4502816,4533304,4231240,4242416,4299536,4304240,4475848,4445608,4448296,4276016,4239056,4509200,4520536,4485592,4428560,4552544,4382192,4527256,4496344,4237712,4364968,4431248,4549856,4322720,4370432,4403608,4441576,4515248,4466864,4555232,4375048,4372696,4307176,4311632,4456112,4472240,4477952,4262488,4394200,4406968,4509536,4332128,4373120,4382104,4215784,4547168,4381184,4310536,4500800,4390256,4379504,4378160,4480552,4336072,4255768,4410752,4479968,4349512,4311880,4385216,4513568,4402600,4285760,4218472,4500128,4536328,4308272,4437208,4556488,4263160,4384880,4354888,4409992,4436288,4402936,4394872,4333808,4322632,4392856,4323976,4505168,4488704,4503064,4414696,4386472,4397984,4428136,4377488,4454096,4560608,4300208,4486936,4269296,4356568,4542800,4395544,4323056,4317680,4555144,4339856,4515920,4243760,4272320],"length":1,"stats":{"Line":3108},"fn_name":"autoshutdown_0"},{"line":46,"address":[4459479,4305547,4349563,4477287,4220919,4486987,4229947,4276987,4354939,4372075,4267959,4266571,4396267,4461115,4455403,4408027,4348599,4448055,4521975,4559271,4453431,4541083,4479595,4264555,4308571,4313275,4427515,4248091,4231627,4411095,4431255,4395975,4458135,4485979,4561287,4562631,4456411,4296855,4381147,4475271,4294503,4288075,4323691,4471575,4392235,4329067,4468507,4516599,4545831,4475227,4556583,4495767,4482999,4302903,4437975,4326043,4258551,4365019,4475563,4546167,4336503,4311259,4315335,4363383,4375771,4389255,4509499,4251451,4531383,4340199,4551499,4470903,4436923,4520923,4496103,4524327,4528695,4288455,4216551,4424535,4221211,4513239,4439275,4543815,4274971,4249771,4309243,4226923,4262247,4425207,4351959,4230955,4267287,4402695,4556919,4422139,4468551,4535371,4323063,4506475,4429531,4310967,4531675,4250107,4488711,4371403,4381191,4379803,4282363,4365735,4441335,4464139,4508871,4369051,4249143,4515255,4554231,4463175,4230999,4232635,4262919,4258215,4380519,4256871,4225915,4473547,4306555,4239019,4509879,4559227,4465147,4508827,4510843,4508199,4486651,4522647,4413783,4325751,4290427,4274007,4287447,4420123,4499127,4303531,4291815,4252167,4300843,4457755,4517899,4518279,4353259,4216215,4396647,4541419,4468171,4360023,4538731,4562923,4331799,4439611,4414119,4554903,4560571,4522939,4553851,4253131,4508491,4453051,4449691,4504167,4243767,4377831,4510171,4537723,4355991,4529031,4437595,4479303,4533355,4389591,4551207,4253511,4273963,4559607,4270603,4291771,4323735,4430203,4457083,4300171,4354267,4222935,4407735,4229991,4220203,4409079,4478967,4490055,4558599,4226295,4418823,4336459,4318651,4397611,4512231,4487367,4322055,4326379,4332763,4343515,4525291,4336167,4371111,4365063,4522267,4556539,4475899,4267243,4274343,4278667,4327767,4334151,4329447,4433563,4562295,4378839,4244103,4526971,4219239,4222599,4280683,4392279,4432555,4514919,4338183,4508155,4453095,4243387,4279719,4289419,4321675,4429239,4403323,4238683,4405003,4344523,4490347,4541799,4356283,4421847,4459771,4227975,4253467,4518907,4358343,4334823,4429195,4498075,4310251,4267915,4511515,4430875,4398283,4433899,4542091,4283371,4485351,4221883,4266615,4557883,4314327,4430539,4398999,4524663,4221927,4345531,4561579,4248807,4331127,4500763,4305883,4446039,4314955,4268967,4356663,4466155,4394967,4335787,4467543,4392907,4271611,4508535,4393915,4537431,4376487,4509835,4334443,4264599,4454731,4242043,4472247,4521639,4557927,4234987,4338519,4440955,4476615,4269303,4331083,4482327,4548139,4450743,4467499,4362331,4334107,4287067,4470859,4475943,4442343,4548855,4383207,4384887,4281063,4536087,4312939,4353975,4487659,4439655,4234695,4474219,4241035,4370439,4551879,4294123,4358635,4368043,4400299,4279339,4249435,4310631,4263883,4497783,4251831,4403703,4377115,4451035,4223899,4530039,4383163,4327387,4458427,4490683,4280347,4389547,4377159,4336839,4272283,4335831,4419495,4268295,4301515,4354647,4435243,4471195,4471911,4349943,4266907,4493707,4301895,4514539,4523319,4369767,4395303,4266235,4267579,4324363,4330455,4462459,4224235,4471239,4494715,4498119,4506183,4397991,4412731,4315671,4543143,4441671,4294459,4368087,4337175,4302231,4499755,4513531,4295847,4438939,4523611,4467207,4467879,4450363,4375815,4473883,4321339,4362667,4521595,4364347,4388539,4410759,4513575,4359979,4500091,4240363,4241751,4251787,4539403,4547175,4527351,4236331,4318315,4544443,4448347,4217515,4385851,4302187,4233351,4319367,4482283,4438983,4243723,4489339,4556875,4447339,4464519,4263591,4305927,4529703,4543435,4337803,4445659,4412439,4377495,4335115,4350571,4298871,4295467,4396603,4492743,4501435,4517227,4308235,4348263,4437931,4407399,4396311,4261195,4468887,4284715,4360359,4419787,4217895,4279003,4342507,4515927,4472203,4304203,4357671,4327431,4321719,4549527,4557547,4552215,4403031,4219195,4546839,4277031,4391943,4419831,4301559,4271947,4393623,4351623,4276359,4414747,4245783,4228647,4231671,4425543,4321383,4376107,4520251,4407355,4368759,4429911,4533399,4464475,4516219,4284379,4247755,4487323,4265563,4271655,4379511,4399335,4484007,4384167,4325415,4499083,4510507,4512567,4550199,4218903,4507483,4527979,4560279,4366699,4535751,4274679,4410043,4317687,4384551,4257543,4466871,4487031,4502107,4303911,4365355,4412059,4282699,4427895,4339819,4440327,4442299,4443643,4387195,4431211,4537387,4344567,4418487,4252839,4387575,4413063,4265607,4556203,4251115,4347591,4428567,4436631,4469223,4427223,4480983,4426171,4229611,4495723,4332091,4386903,4463847,4552887,4301223,4411767,4554567,4218231,4289755,4333815,4448683,4466827,4471531,4429575,4286103,4451371,4483335,4281355,4463467,4466199,4510551,4504839,4401351,4552171,4305591,4546503,4550491,4418779,4257835,4391271,4307271,4352587,4230327,4540119,4270983,4372411,4359307,4447719,4512859,4278375,4324407,4533063,4511223,4330791,4330747,4230619,4499463,4357291,4532347,4417099,4367415,4455783,4400679,4228939,4238011,4355319,4355275,4402315,4260231,4255819,4424491,4551163,4434571,4258887,4482619,4446711,4483963,4503159,4223943,4470187,4247419,4298535,4493751,4408743,4219867,4260567,4412775,4439991,4492699,4292151,4373755,4361367,4309623,4249099,4503115,4349227,4222891,4419159,4338855,4373419,4532391,4534027,4295131,4289463,4281399,4446375,4511895,4352631,4386567,4238347,4397947,4415463,4507819,4317307,4355947,4245447,4338811,4463131,4480311,4549819,4333479,4518951,4400971,4217559,4555575,4236667,4221547,4453387,4470567,4498455,4380855,4416807,4414791,4555195,4291479,4438603,4531719,4535035,4539783,4558935,4217223,4495095,4462795,4311639,4462503,4438311,4276651,4358679,4225287,4473591,4368423,4541127,4306263,4328059,4390935,4309579,4232971,4292823,4312311,4342171,4413447,4254519,4520295,4522983,4378123,4409707,4292443,4378459,4372747,4240027,4423191,4216887,4378167,4438647,4297863,4285431,4430583,4425499,4235995,4481319,4482663,4351287,4282027,4367751,4390891,4402987,4425879,4275307,4299163,4543099,4504503,4481947,4369723,4310923,4382871,4510887,4272663,4530331,4442635,4400007,4388875,4466491,4467163,4491063,4401307,4415419,4215543,4224951,4407063,4333771,4504795,4417479,4562251,4450071,4274635,4304919,4523947,4462167,4220875,4514247,4500135,4297527,4325371,4446667,4222555,4562587,4224279,4222263,4302567,4406055,4268631,4483627,4328103,4320331,4295175,4520631,4311303,4544487,4252123,4528987,4375099,4347883,4436251,4261239,4474935,4235367,4375143,4464183,4271991,4284087,4352923,4459815,4232007,4427559,4543479,4440283,4256155,4306599,4323399,4417771,4257207,4478631,4287783,4550155,4255483,4538103,4370775,4269931,4484679,4530711,4390263,4528315,4345575,4244395,4363675,4398663,4279047,4234651,4282071,4478251,4405047,4314283,4251495,4281735,4536423,4553223,4366071,4374807,4277995,4350951,4488667,4416763,4331755,4507191,4409415,4227931,4491399,4533691,4428187,4459435,4244731,4393579,4237719,4264891,4259895,4497067,4267623,4469515,4340155,4273291,4319995,4341207,4369095,4425835,4454395,4492027,4247463,4411051,4427851,4216507,4226587,4258171,4340827,4537095,4328439,4385895,4512523,4277703,4405675,4360315,4235659,4245403,4357335,4422183,4354603,4413403,4502151,4322347,4496059,4455111,4324027,4428859,4270939,4421175,4464855,4320375,4230283,4286439,4218567,4394251,4349899,4382827,4381819,4223227,4502779,4321047,4363719,4379847,4550871,4445031,4530667,4499799,4513911,4235323,4443351,4322391,4389883,4524283,4220247,4481611,4485687,4375435,4386231,4514583,4309915,4259223,4506855,4299207,4347547,4240699,4377787,4298827,4326423,4426887,4451415,4268587,4265271,4358299,4314999,4374471,4272327,4365399,4521931,4441291,4339863,4460823,4522603,4433943,4219531,4286395,4479975,4417435,4486023,4297147,4280727,4398327,4455067,4265943,4502487,4422519,4291143,4317351,4342887,4364683,4241079,4530375,4305255,4306219,4380139,4403995,4442679,4449019,4415755,4524955,4231291,4341543,4319659,4416427,4227595,4364055,4345867,4507863,4556247,4234359,4381527,4434279,4233979,4327051,4260903,4297483,4287739,4305211,4355611,4377451,4391563,4468215,4525671,4551835,4472875,4264935,4546123,4334487,4326759,4390599,4312983,4229319,4316299,4397275,4287111,4245111,4408407,4420503,4324699,4474263,4373083,4547511,4549191,4275351,4515547,4272955,4279675,4289799,4353303,4494379,4485307,4328395,4333099,4385179,4481991,4553895,4413739,4460107,4496731,4235031,4524619,4258507,4308615,4313947,4237383,4256199,4473255,4477579,4341835,4443979,4304583,4307899,4421803,4518615,4544107,4387531,4247127,4233687,4370731,4516935,4285095,4339527,4304247,4218859,4260523,4428231,4351243,4486315,4289127,4309959,4231335,4416471,4452379,4355655,4457127,4308279,4483671,4215499,4296519,4436967,4503831,4561243,4262539,4512903,4443015,4388583,4322727,4494423,4247799,4339191,4351579,4539447,4526299,4493079,4348935,4329739,4303195,4346539,4293831,4453767,4426551,4330411,4421511,4490011,4269639,4444987,4523275,4540075,4223607,4310295,4427179,4443307,4519959,4329403,4547131,4248427,4362711,4303239,4472919,4388203,4501099,4401687,4515591,4542427,4344187,4350907,4543771,4276695,4321003,4461451,4423863,4249815,4239399,4263211,4352251,4378795,4406727,4430919,4402023,4364011,4451707,4529367,4454439,4283079,4311931,4356955,4486359,4296811,4337847,4307943,4546459,4242423,4403659,4435959,4238055,4491691,4244775,4353639,4312603,4366407,4514203,4315627,4460487,4390219,4329111,4250151,4457799,4254811,4504459,4536043,4559563,4559899,4325035,4485015,4504123,4347211,4375479,4359687,4407691,4440619,4476279,4325707,4349607,4458807,4271275,4482955,4332807,4313611,4385515,4235703,4538059,4468843,4440663,4410379,4359015,4261867,4396939,4331463,4301851,4229275,4221591,4223563,4261911,4422475,4507527,4409371,4557591,4437639,4251159,4296139,4265899,4363047,4236039,4551543,4224571,4360651,4248135,4223271,4404375,4286731,4302523,4361995,4271319,4285051,4290091,4312267,4322683,4394295,4318359,4383543,4426843,4234315,4466535,4513195,4534699,4372455,4554859,4528359,4371447,4255147,4346583,4447383,4275687,4351915,4458091,4245739,4528651,4300551,4408071,4516891,4290471,4347255,4489675,4414455,4344859,4332135,4294795,4538395,4455447,4497739,4431883,4397655,4548811,4541755,4327095,4395259,4497111,4392571,4227303,4400635,4437303,4491735,4423527,4518235,4259515,4261575,4434615,4481275,4521259,4280011,4283751,4439319,4300215,4259179,4395931,4496775,4509207,4465527,4259851,4432891,4281691,4495051,4518571,4489719,4263255,4237675,4297191,4254139,4415083,4547847,4216171,4501771,4445323,4261531,4555239,4380811,4492071,4264219,4552507,4298155,4495387,4515883,4310587,4323019,4493035,4444023,4548475,4408363,4275643,4244439,4432599,4257163,4367707,4470231,4368379,4364727,4542471,4330119,4461787,4417143,4293787,4396983,4290135,4457419,4545115,4370059,4399671,4526635,4469851,4232299,4283035,4237003,4558219,4323355,4277367,4433271,4265227,4525335,4370395,4484299,4537051,4412103,4288411,4391899,4324743,4546795,4526679,4316971,4252459,4307607,4215207,4317015,4471867,4488331,4503451,4519579,4314619,4318987,4410423,4432263,4228983,4515211,4441963,4346203,4517563,4320039,4476235,4299499,4275015,4292779,4437259,4253847,4477243,4219911,4275979,4226631,4552551,4236375,4346247,4379467,4418107,4553515,4269259,4478923,4544823,4538775,4421131,4335495,4363003,4339147,4217851,4263927,4250443,4279383,4364391,4374135,4420459,4270647,4418151,4461159,4325079,4498791,4283707,4361703,4436587,4348555,4303575,4387911,4531003,4295511,4237339,4245067,4342551,4255191,4313991,4322011,4459099,4509543,4506139,4505511,4519243,4536715,4507147,4526007,4484343,4420167,4366363,4231963,4501479,4449355,4229655,4353595,4480603,4519915,4444695,4326715,4232343,4374427,4476907,4511559,4405339,4406347,4465483,4304539,4373127,4489047,4502443,4284043,4459143,4553179,4547467,4266279,4225579,4233643,4400343,4383499,4397319,4404667,4430247,4514875,4228603,4558891,4458763,4434235,4536759,4490727,4222219,4501143,4263547,4387867,4480267,4480939,4484971,4516555,4524999,4531339,4376443,4470523,4472583,4295803,4539067,4431927,4444651,4494759,4239063,4294839,4505175,4491355,4553559,4497447,4454059,4557255,4449399,4465191,4326087,4403367,4335451,4389211,4313655,4535707,4454775,4435623,4298199,4453723,4257879,4542135,4252503,4288747,4363339,4367035,4523655,4432935,4441627,4444315,4532011,4549483,4224907,4291099,4307227,4409751,4541463,4382155,4402359,4505467,4240743,4286775,4316635,4337131,4392615,4503495,4241415,4228311,4278331,4438267,4560951,4233307,4316007,4304875,4260859,4308951,4371739,4529323,4361031,4276315,4220539,4359643,4489383,4509163,4404711,4492407,4335159,4243095,4269595,4242715,4239355,4242087,4447047,4371067,4313319,4544151,4319703,4520967,4456119,4296475,4545787,4500427,4352295,4243051,4379131,4542763,4343559,4554523,4298491,4399291,4477915,4531047,4292487,4416135,4276023,4469895,4374763,4278711,4433607,4451079,4331419,4442007,4481655,4474555,4406011,4477623,4390555,4414411,4342215,4417815,4300887,4387239,4549147,4479259,4552843,4534407,4360695,4343851,4456747,4296183,4394631,4356999,4230663,4393287,4440999,4299879,4558555,4357627,4446331,4395639,4339483,4411723,4215879,4272999,4356619,4309287,4255527,4226967,4455739,4505847,4238727,4432219,4291435,4418443,4361659,4242759,4254183,4434951,4306935,4489003,4216843,4389927,4407019,4463511,4487703,4532055,4319323,4557211,4449063,4348891,4346919,4219575,4367371,4445703,4262875,4461831,4451751,4253175,4510215,4241707,4560615,4280055,4493415,4274299,4475607,4228267,4362375,4511179,4420839,4356327,4488039,4511851,4308907,4450699,4429867,4408699,4428903,4476571,4373799,4499419,4215835,4270267,4284759,4424827,4350235,4554187,4365691,4452759,4460443,4500471,4341499,4242379,4548519,4555867,4266951,4332471,4384215,4317643,4526343,4238391,4462123,4402651,4561623,4368715,4412395,4506519,4290763,4450027,4383879,4333435,4465819,4218187,4318023,4540747,4393243,4431591,4393959,4411387,4366743,4285387,4285723,4352967,4270311,4344903,4369387,4343223,4388247,4490391,4563259,4226251,4424871,4534363,4341879,4392951,4517271,4405383,4472539,4539111,4523991,4435579,4328775,4477959,4519287,4262583,4315291,4317979,4345239,4354311,4381483,4533019,4376779,4383831,4225623,4336795,4343179,4370103,4379175,4398619,4399963,4256535,4422811,4483291,4293159,4293495,4371783,4240071,4436295,4502823,4512187,4299835,4254475,4337511,4297819,4301179,4456455,4500807,4492363,4493371,4273627,4288791,4353931,4473211,4302859,4479639,4316679,4320667,4494087,4534071,4528023,4404331,4257499,4373463,4289083,4444359,4246791,4340491,4385223,4480647,4456791,4520587,4561959,4239735,4345911,4300507,4542807,4314663,4330075,4307563,4273671,4406683,4478587,4401979,4284423,4484635,4517607,4529995,4280391,4232679,4423147,4336123,4281019,4286059,4329783,4340871,4292107,4421467,4246075,4250487,4248763,4354983,4450407,4372791,4254855,4327723,4358007,4505131,4404039,4259559,4415127,4320711,4347927,4498411,4426507,4545451,4382535,4247083,4561915,4240407,4218523,4420795,4410087,4467835,4517943,4538439,4306891,4545159,4282743,4460779,4348219,4268251,4338139,4316343,4463803,4221255,4462839,4448011,4382491,4529659,4558263,4220583,4416091,4522311,4497403,4361323,4495431,4496395,4469559,4425163,4318695,4443687,4445367,4555911,4445995,4423819,4494043,4244059,4282407,4384507,4395595,4479931,4256491,4513867,4527643,4287403,4527015,4359351,4237047,4334779,4248471,4358971,4341163,4369431,4333143,4547803,4311595,4422855,4380183,4560907,4252795,4288119,4272619,4246119,4537767,4303867,4391607,4391227,4311975,4452087,4243431,4246747,4290807,4448727,4525627,4380475,4253803,4461495,4503787,4384843,4501815,4294167,4386859,4486695,4532683,4415799,4447003,4285767,4241371,4350279,4388919,4414075,4394923,4260187,4262203,4360987,4496439,4338475,4386187,4447675,4550827,4236711,4506811,4535079,4277659,4458471,4476951,4519623,4227639,4382199,4343895,4525963,4224615,4337467,4319031,4340535,4372119,4411431,4424155,4562967,4378503,4419451,4473927,4434907,4536379,4398955,4485643,4527687,4540791,4487995,4469179,4545495,4550535,4465863,4374091,4435287,4410715,4452715,4234023,4423483,4454103,4460151,4217179,4516263,4250823,4521303,4233015,4386523,4293451,4399627,4273335,4401643,4401015,4419115,4544779,4328731,4376823,4250779,4283415,4539739,4293115,4549863,4258843,4424199,4560235,4342843,4426215,4548183,4346875,4532727,4357963,4533735,4249479,4488375,4474891,4559943,4448391,4540411,4413111,4505803,4433227,4464811,4457463,4540455,4239691,4269975,4452423,4324071,4362039,4345195,4255863,4312647,4449735,4349271,4431547,4315963,4381863,4299543,4439947,4478295,4376151,4527307,4268923,4435915,4456075,4405719,4428523,4406391,4498747,4491019,4246455,4256827,4277323,4225959,4442971,4474599,4555531,4344231,4350615,4227259,4366027,4246411,4264263,4452043,4367079,4409035,4534743,4332427,4385559,4535415,4225243,4394587,4278039],"length":1,"stats":{"Line":1036},"fn_name":null},{"line":47,"address":[4400379,4352792,4476440,4400043,4229480,4435784,4452584,4507688,4521128,4353339,4480683,4405419,4480472,4392440,4278747,4489419,4346072,4403739,4296219,4342376,4272152,4518987,4385048,4292312,4415163,4477659,4466235,4406091,4518315,4252203,4244936,4437339,4426712,4482363,4504875,4281099,4384712,4492443,4397691,4544648,4553931,4471064,4527051,4488200,4446200,4381563,4501515,4327803,4415960,4367451,4411803,4373835,4481019,4391979,4370936,4237755,4470267,4455272,4253547,4326123,4458507,4533099,4216923,4386392,4330491,4261064,4481816,4524824,4356488,4299704,4408443,4244475,4311003,4479339,4369592,4562456,4226456,4274168,4420328,4459976,4280216,4519448,4301048,4333515,4495928,4551915,4246616,4339899,4549899,4367576,4433307,4230152,4538264,4259259,4496264,4220408,4445192,4490552,4315496,4465352,4360395,4530411,4312683,4255899,4374843,4308315,4510923,4544984,4219275,4416968,4255352,4528856,4544859,4561112,4438472,4365896,4309112,4223432,4351659,4549352,4559307,4337547,4232504,4305752,4463000,4552251,4238763,4308987,4356824,4432760,4412932,4285256,4413483,4372827,4317848,4504539,4532216,4342040,4461992,4383368,4385931,4319528,4320075,4258712,4419320,4501976,4540616,4340235,4436120,4544187,4292859,4471400,4302603,4474424,4383243,4405755,4458843,4488872,4231371,4539608,4305963,4445864,4218267,4328811,4292648,4305627,4296344,4499835,4259720,4347963,4538936,4278536,4413819,4494123,4381016,4444731,4325576,4379000,4530747,4281771,4462875,4443723,4221752,4239771,4265307,4412600,4406763,4519323,4282443,4295000,4448216,4459515,4485051,4232168,4523144,4554392,4435659,4555611,4513275,4222760,4329147,4354347,4382696,4243467,4343720,4392104,4532091,4341032,4317387,4243592,4362872,4370811,4241576,4310331,4546328,4258587,4282568,4296555,4342251,4376312,4366568,4541835,4463211,4336539,4542507,4256235,4392315,4515416,4525371,4301595,4322427,4403067,4473080,4237083,4243928,4296008,4467032,4496811,4290632,4493787,4394456,4253336,4476776,4465016,4514408,4538475,4522472,4417851,4238552,4427931,4475432,4543976,4548680,4325451,4369467,4236536,4277739,4409787,4464008,4529403,4255563,4531419,4562120,4487739,4259595,4265643,4279419,4243131,4395675,4558635,4496139,4310667,4220283,4254891,4277403,4241115,4340024,4248843,4320411,4453803,4397816,4472619,4433768,4485848,4455483,4498616,4356027,4507352,4423688,4402059,4388408,4416507,4443387,4278200,4528059,4547336,4429611,4263752,4362411,4546664,4435448,4447544,4457499,4521675,4306760,4558299,4318395,4387275,4443512,4412808,4379211,4526840,4232379,4552376,4438347,4216587,4235067,4264424,4225112,4250312,4221416,4345947,4399160,4463883,4545656,4312808,4276731,4371483,4470728,4344939,4349643,4301931,4424360,4492568,4279880,4350987,4361528,4513736,4454936,4327928,4260939,4266776,4430619,4453131,4323560,4286600,4287147,4387400,4419531,4420875,4270347,4242459,4536795,4229144,4449435,4289499,4491435,4523019,4281435,4393112,4227464,4458632,4460523,4498491,4378328,4533896,4532763,4424571,4557963,4340360,4365099,4536584,4443051,4237419,4314699,4381352,4522011,4414952,4453256,4269339,4531755,4427595,4290171,4368123,4555947,4312472,4492904,4326459,4217931,4324443,4361192,4254680,4397480,4334648,4230027,4452248,4558424,4467915,4509368,4445739,4475643,4293195,4267995,4294875,4388619,4398027,4404536,4457163,4267659,4294203,4320872,4332296,4491099,4438011,4451240,4378875,4497147,4270472,4331288,4480808,4517643,4428939,4339016,4234184,4532552,4313816,4216040,4519112,4270808,4250523,4369131,4486395,4219736,4439480,4479128,4245272,4496936,4246155,4511259,4447755,4259048,4261736,4433643,4375976,4441160,4460859,4216712,4515291,4252875,4334312,4447419,4379672,4403528,4399707,4224651,4456827,4424696,4444059,4476104,4385720,4387736,4322552,4372491,4295672,4303947,4327467,4226792,4365224,4538600,4549016,4245483,4524027,4351112,4487864,4301720,4289624,4401176,4402731,4393448,4517307,4505672,4512392,4559432,4223643,4321208,4276059,4400715,4434651,4442715,4302056,4450107,4515080,4221080,4282904,4396808,4403192,4484379,4299032,4231035,4454600,4483496,4372280,4297563,4273707,4467579,4217595,4444856,4251656,4325787,4285592,4557291,4332171,4338344,4262408,4505211,4370475,4470603,4227800,4266987,4445403,4448427,4327592,4306299,4562331,4291304,4270136,4457960,4352667,4380680,4339227,4391643,4279208,4550571,4466696,4266104,4348088,4365560,4432971,4525160,4260392,4541960,4309323,4355144,4492107,4268456,4219064,4275387,4245608,4366232,4397355,4484043,4461656,4390088,4395339,4471611,4434315,4225784,4363208,4351323,4232043,4521339,4512603,4283115,4318856,4412264,4298360,4437675,4228136,4255016,4324232,4481691,4368459,4389627,4241240,4345064,4446075,4308104,4474971,4514619,4409451,4360059,4448091,4383700,4519784,4229816,4359723,4477995,4225323,4445528,4321755,4469384,4373163,4258376,4262955,4551032,4254555,4246827,4218939,4521003,4389752,4261611,4272488,4354011,4540952,4287944,4315832,4322216,4348299,4556619,4259384,4279755,4291976,4247835,4273371,4478792,4425704,4268667,4510251,4310792,4226331,4231496,4304744,4493451,4500632,4313691,4527848,4487528,4215915,4354472,4543179,4554939,4551368,4279083,4410459,4359387,4398824,4386056,4427384,4440152,4456155,4540491,4245944,4500507,4429064,4483832,4400840,4332632,4275176,4262283,4525035,4314363,4486520,4503195,4221291,4257704,4347752,4380344,4493912,4333304,4414616,4349432,4482152,4282779,4282107,4328139,4474760,4444520,4464219,4280763,4526379,4356699,4242795,4261947,4307768,4481355,4508907,4364888,4491224,4223768,4416632,4395003,4507227,4248968,4540827,4315707,4318520,4247960,4386939,4446536,4453467,4537592,4490427,4359051,4247163,4519659,4248632,4284795,4264971,4492232,4442379,4542843,4545531,4376648,4301259,4537467,4358840,4363083,4486059,4502859,4319403,4422219,4485176,4512056,4468587,4320747,4222635,4374632,4251531,4494248,4543851,4553048,4495131,4237880,4351448,4361739,4417179,4461195,4263291,4360731,4508696,4409115,4411928,4486731,4401848,4315371,4450779,4278411,4230363,4488747,4497483,4369928,4228808,4345736,4408904,4508024,4516760,4368248,4530075,4351995,4343595,4557752,4388072,4438808,4285467,4250187,4284584,4513611,4470392,4560651,4369803,4391768,4220744,4499960,4460312,4373624,4345400,4381899,4518104,4437003,4337211,4234395,4229691,4233848,4251867,4251195,4559979,4267112,4375640,4454811,4516424,4327131,4384251,4254219,4519995,4426251,4235192,4336664,4443176,4407771,4242920,4478456,4303064,4345611,4339563,4442043,4340907,4424235,4236411,4255688,4411592,4474299,4296680,4496475,4526715,4274715,4426376,4441496,4495592,4509243,4222088,4556744,4359176,4224315,4224440,4231707,4502312,4531208,4325240,4305291,4415288,4350440,4391307,4479003,4497944,4249515,4443848,4280888,4504203,4228472,4558760,4366107,4528395,4258923,4217720,4414827,4272027,4254344,4469931,4555064,4374507,4241451,4252539,4547547,4336328,4307643,4335867,4475307,4440699,4233051,4425243,4231832,4264299,4247288,4250984,4421211,4386603,4330616,4390424,4338219,4437128,4483160,4552587,4491771,4233723,4423352,4353464,4234059,4327256,4404411,4549227,4360520,4270011,4402856,4410584,4362200,4406888,4387947,4414280,4417515,4468040,4475768,4533224,4547000,4555736,4428056,4273160,4326920,4337000,4469048,4276395,4240904,4376984,4286139,4515627,4323099,4292187,4346619,4534107,4501851,4291851,4372155,4324568,4307979,4380008,4417976,4307307,4561448,4293867,4328475,4296891,4293531,4550360,4226120,4472744,4548008,4458968,4490216,4511931,4372616,4383576,4455819,4275051,4349307,4452795,4527176,4455944,4321544,4512939,4395128,4224987,4298571,4421672,4455608,4526043,4256571,4337336,4317512,4226667,4534568,4371272,4549688,4520120,4385384,4501179,4364427,4340696,4364091,4334523,4501640,4556408,4473627,4406552,4489755,4338680,4490763,4376523,4392651,4362536,4397019,4439355,4331960,4462328,4400168,4284920,4229355,4389963,4251320,4451115,4258251,4313480,4484168,4381227,4562792,4343931,4286264,4363880,4492779,4439816,4324107,4496600,4404200,4520792,4297899,4419656,4344603,4384587,4265768,4555400,4222971,4546539,4286475,4397144,4277067,4331163,4348424,4301384,4245819,4347627,4240779,4266651,4480347,4289835,4456280,4462664,4407560,4446872,4545320,4539944,4545195,4346744,4500843,4390635,4243803,4225659,4276184,4393323,4535115,4548344,4319739,4297016,4513947,4481480,4384923,4283787,4271480,4234856,4239560,4371147,4363419,4355355,4303275,4379336,4481144,4449099,4485387,4477323,4468923,4233512,4237208,4262072,4333179,4336875,4413944,4382907,4434104,4539483,4325912,4375304,4351784,4506008,4441832,4265096,4475096,4520456,4503867,4554603,4439144,4556955,4228347,4393995,4402395,4388744,4268331,4401512,4238216,4426587,4249304,4260728,4215579,4289288,4302267,4323771,4387611,4458296,4488536,4498827,4323435,4274043,4328936,4299243,4500296,4558971,4268120,4357371,4286811,4371819,4398488,4423563,4233176,4398152,4298024,4295211,4523355,4370139,4522683,4518651,4524488,4234731,4342923,4271816,4380219,4321419,4509579,4248507,4440363,4460187,4234520,4394667,4407099,4517432,4257032,4499499,4340571,4530536,4523691,4382235,4248296,4311800,4469595,4516971,4223979,4361864,4433979,4518440,4290843,4423899,4505000,4412475,4447083,4483371,4309784,4515752,4548891,4553259,4540155,4339688,4394331,4528731,4350651,4477784,4364552,4273832,4382024,4560987,4516299,4319067,4263963,4370264,4390299,4509032,4326584,4431291,4518776,4541624,4420664,4559768,4309659,4436456,4354136,4476987,4232840,4499624,4425915,4395464,4275512,4561995,4459640,4350315,4311675,4342587,4387064,4428392,4433096,4256907,4290968,4416171,4489083,4533435,4246952,4220072,4371944,4263627,4342712,4266315,4503656,4399496,4533560,4277864,4358379,4399035,4411467,4494459,4542632,4487192,4356152,4441371,4451576,4316715,4422555,4399832,4303400,4508235,4522808,4531544,4442504,4551704,4431416,4506555,4309448,4287483,4413272,4257915,4325115,4547672,4247624,4341915,4359512,4367115,4480136,4541163,4317051,4513400,4375515,4453592,4347291,4396347,4393659,4416843,4318731,4373960,4511048,4507563,4233387,4361067,4451787,4438136,4420539,4427259,4537256,4454475,4461320,4322091,4218728,4406427,4346408,4349768,4525832,4556283,4260267,4506219,4505336,4276856,4295883,4465227,4430072,4312136,4219947,4367912,4489544,4268792,4429947,4434440,4545992,4240443,4314824,4414155,4359848,4239435,4306088,4472072,4406216,4346283,4543515,4240107,4236872,4415499,4490091,4544523,4283576,4256360,4264088,4395800,4235864,4316168,4432424,4256696,4329272,4546875,4286936,4429736,4242123,4285928,4502984,4455147,4390971,4304072,4257243,4331835,4402520,4459304,4527387,4261400,4332843,4244600,4254008,4479464,4273496,4321083,4423016,4466024,4357707,4485723,4520331,4373288,4221627,4239099,4419867,4298235,4465688,4498280,4266440,4376859,4303611,4250648,4377531,4389080,4419992,4374968,4514283,4532888,4440027,4552040,4277528,4560776,4420203,4440824,4431627,4257579,4297688,4241787,4523480,4482027,4547211,4522136,4271691,4560104,4450443,4405083,4422680,4553384,4353128,4383032,4366904,4418984,4288491,4310120,4330827,4379883,4467243,4470939,4272363,4377195,4306971,4488075,4526168,4271355,4557416,4410123,4335531,4344056,4302392,4364216,4410795,4442840,4544312,4513064,4550235,4355816,4379547,4442168,4238427,4360856,4350104,4236747,4418523,4394120,4360184,4425368,4377867,4536123,4535787,4347416,4253883,4317723,4398699,4426040,4288952,4304408,4514744,4527512,4431963,4502187,4559643,4396472,4267323,4534443,4384036,4291640,4222299,4249179,4370600,4460648,4377992,4439019,4358504,4449896,4510712,4377656,4245147,4444395,4473416,4530200,4347080,4288827,4309995,4426923,4334859,4487067,4300376,4534904,4271144,4364763,4312011,4247499,4501304,4331624,4447880,4223096,4343048,4517096,4506680,4300251,4330155,4441035,4292523,4432088,4252328,4304283,4486184,4521464,4472955,4275848,4396011,4510587,4535451,4436331,4483707,4485512,4375179,4368795,4221963,4373499,4230699,4299579,4290296,4348971,4297227,4355480,4320200,4313144,4415624,4407224,4524363,4242248,4482488,4255227,4402184,4422344,4216251,4220955,4456491,4476651,4484504,4260603,4306424,4244264,4353675,4404747,4447208,4552712,4311339,4430955,4304619,4445067,4421336,4451451,4541288,4326795,4469259,4471947,4444184,4495256,4331499,4405544,4318184,4471275,4383912,4495803,4529192,4534232,4431080,4479800,4369256,4554728,4506344,4472283,4421883,4509704,4238091,4284459,4382571,4236200,4537928,4537803,4471736,4427048,4322763,4354683,4272824,4216376,4500968,4357160,4353003,4314488,4561784,4385259,4375851,4550696,4239224,4230824,4529528,4457835,4472408,4386267,4434987,4285803,4517768,4392987,4278075,4316840,4475979,4520667,4293992,4542171,4293320,4314027,4537131,4263416,4307432,4269003,4346955,4371608,4348635,4524152,4312347,4486856,4408779,4317176,4448763,4497819,4410920,4279544,4291179,4319864,4392776,4432299,4431752,4391432,4389291,4546203,4516088,4227339,4502523,4280552,4269675,4246280,4345275,4401723,4339352,4394792,4558088,4264635,4523816,4224776,4417304,4493576,4241912,4269128,4367240,4524699,4466360,4390760,4510376,4484840,4503531,4230488,4401387,4438683,4235403,4478120,4352456,4288155,4439691,4235528,4454139,4487403,4422008,4318059,4334984,4357035,4450232,4464891,4423227,4533771,4435323,4535240,4473963,4548219,4270683,4282232,4440488,4464680,4505547,4337883,4311128,4504328,4490888,4551579,4400504,4499163,4385595,4304955,4324779,4308651,4450568,4228011,4414491,4538811,4249851,4224104,4362075,4344728,4291515,4274504,4335992,4536248,4446411,4436667,4563128,4367787,4329944,4283451,4478331,4459179,4384376,4508360,4366443,4434776,4303736,4399371,4463672,4222424,4416296,4553720,4310456,4305080,4219400,4512267,4534779,4405880,4542296,4509915,4352120,4225995,4307096,4256024,4300712,4295547,4410248,4343259,4274840,4407896,4477448,4249640,4287819,4313019,4474635,4491560,4244139,4463547,4350776,4322888,4355691,4315160,4528184,4290507,4365435,4482699,4543304,4478667,4225448,4365771,4401051,4248171,4378539,4531880,4294664,4408232,4432635,4532427,4357496,4215243,4468251,4217384,4453928,4244811,4493115,4319192,4335195,4368920,4356363,4285131,4502648,4531083,4294539,4227675,4430283,4511720,4545867,4263080,4316379,4333851,4332507,4336203,4287272,4536920,4377320,4358168,4308776,4292984,4418312,4328264,4235739,4538139,4353800,4335320,4278872,4495467,4563003,4458171,4515963,4239896,4277192,4269464,4323896,4251992,4344392,4372952,4382360,4352331,4428728,4433432,4355019,4448888,4408107,4341243,4240232,4295336,4493240,4540280,4298696,4428603,4398363,4348760,4427720,4275723,4522347,4341368,4258040,4349096,4297352,4446747,4452123,4473291,4378203,4430408,4430744,4330952,4334187,4529864,4293656,4243256,4330280,4267784,4338008,4461867,4467368,4491896,4405208,4308440,4250859,4388283,4265979,4386728,4253211,4363544,4253672,4354808,4411131,4415835,4429275,4484715,4535576,4215704,4452920,4462203,4261275,4506891,4466571,4265432,4218603,4494920,4329608,4269800,4389416,4374296,4272699,4381688,4521800,4343384,4422891,4477112,4413608,4274379,4273035,4511595,4507899,4283912,4473752,4358043,4260056,4299368,4215368,4305416,4361403,4396683,4338555,4220619,4553595,4315035,4418187,4474088,4418859,4441707,4514955,4324904,4547883,4464344,4276520,4366779,4525707,4529067,4550024,4435112,4321880,4380891,4557627,4223307,4246491,4284123,4388955,4542968,4218056,4280091,4525496,4302939,4320536,4219611,4374171,4465563,4488411,4302728,4476315,4512728,4391096,4516635,4494584,4470056,4449560,4257368,4419195,4528520,4459851,4483035,4227128,4262619,4404872,4288280,4460984,4437800,4329483,4316043,4281560,4404075,4561323,4503992,4529739,4527723,4428267,4536459,4556072,4549563,4344267,4417640,4543640,4489880,4557080,4281896,4314152,4262744,4429400,4517979,4236075,4294328,4507016,4461531,4541499,4252664,4554056,4511384,4218392,4408568,4249976,4332968,4409576,4421000,4560315,4535912,4228683,4289163,4489208,4421547,4560440,4238888,4468376,4217259,4333640,4358715,4465899,4500171,4551243,4412139,4436792,4380555,4505883,4341579,4403864,4300923,4457288,4539272,4469720,4229019,4561659,4530872,4232715,4508571,4503320,4552923,4413147,4335656,4467704,4448552,4498952,4539819,4497608,4333976,4378664,4562667,4499288,4313355,4550907,4217048,4316504,4510040,4227003,4289960,4326248,4526504,4240568,4494795,4548555,4435995,4454264,4464555,4242584,4376187,4479675,4449224,4497272,4283240,4264760,4449771,4396136,4466907,4271019,4306635,4253000,4482824,4559096,4424907,4452459,4409912,4555275,4425032,4456952,4457624,4403403,4231160,4418648,4393784,4281224,4287608,4284248,4504664,4463336,4368584,4259931,4451912,4267448,4328600,4298907,4349979,4407435,4462539,4456616,4437464,4363755,4554267,4338891,4411256,4425579,4480011,4424024,4337672,4357832,4329819,4341704,4299915,4323224,4280427,4362747,4514072,4450904,4300587,4468712,4237544,4300040,4409240,4288616,4311464,4539147,4498155],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[4551597,4284813,4240125,4374189,4319085,4458861,4409133,4255581,4358061,4325133,4256589,4352013,4330173,4271037,4368477,4465245,4553613,4414509,4514637,4373853,4522365,4552941,4478349,4238109,4233069,4259949,4291869,4330509,4234749,4378221,4364781,4428957,4269357,4239453,4472301,4281789,4350333,4294221,4473645,4530765,4344621,4401069,4254237,4268685,4534125,4452477,4475997,4310685,4520685,4452813,4546557,4347309,4441053,4517997,4250877,4343277,4292541,4328829,4270029,4253229,4393005,4556973,4468941,4340253,4250541,4262301,4443069,4331853,4512285,4390653,4234413,4228029,4424925,4306989,4471965,4556637,4432989,4439373,4443741,4529085,4216941,4272045,4402749,4557645,4438701,4459533,4499517,4243821,4497837,4255245,4464909,4225677,4490109,4257597,4391997,4495821,4559325,4288509,4299597,4233405,4423917,4448781,4491117,4503549,4456845,4354029,4316733,4383261,4366125,4279773,4430301,4473981,4533789,4399725,4318413,4379901,4470621,4222653,4549245,4367469,4557309,4379229,4557981,4248525,4237437,4313373,4341933,4498173,4563021,4520013,4405773,4303629,4531101,4352685,4458189,4421565,4236429,4293549,4229373,4279437,4359405,4320093,4227357,4238781,4445085,4538157,4320765,4304973,4460205,4311357,4340589,4448445,4469949,4460877,4532109,4470285,4500525,4451133,4219293,4540845,4549917,4322445,4260621,4308333,4418541,4487085,4245837,4266669,4531437,4501533,4241469,4339917,4361085,4445757,4426605,4253901,4252557,4369485,4380909,4442397,4356381,4476333,4256253,4269693,4541517,4422237,4322781,4340925,4468605,4217613,4364109,4435341,4456173,4299933,4271709,4484733,4526397,4502877,4544877,4317405,4335549,4319757,4296573,4372173,4307325,4376877,4342605,4400733,4286157,4464237,4305309,4538829,4302957,4433661,4225005,4537485,4462893,4527069,4420893,4480701,4560333,4429293,4318077,4486077,4428621,4333533,4508253,4261629,4336557,4215261,4381917,4411821,4438365,4462557,4502205,4316397,4332525,4444749,4488093,4269021,4229037,4298253,4346301,4558989,4311021,4521357,4342941,4297581,4326477,4264317,4286829,4426941,4453149,4354701,4417197,4443405,4436013,4258269,4305981,4382253,4251885,4422573,4285149,4472973,4545885,4338909,4382925,4558653,4518669,4368813,4403421,4224333,4424253,4447101,4220637,4295229,4275741,4295565,4307661,4388637,4231389,4259277,4445421,4459869,4477341,4254909,4297245,4228365,4349661,4405437,4324797,4243485,4366797,4426269,4314045,4365117,4372509,4548909,4218285,4524045,4479357,4252893,4262973,4532445,4421229,4278429,4263309,4418877,4304301,4464573,4500861,4511277,4228701,4456509,4331181,4402077,4267341,4512621,4474317,4268013,4287837,4226013,4247853,4303293,4369149,4432653,4505901,4513293,4219965,4305645,4400061,4377885,4253565,4402413,4416189,4264653,4550253,4365789,4361421,4441389,4376205,4561341,4246845,4471293,4528749,4247181,4309677,4431309,4304637,4433997,4487421,4494477,4547901,4237773,4259613,4325469,4280781,4338573,4499181,4231725,4276413,4404765,4519677,4323789,4273725,4380573,4321437,4376541,4227693,4485405,4525053,4419885,4538493,4219629,4278093,4289181,4392333,4543197,4492797,4410477,4427613,4275405,4412825,4413165,4533117,4291533,4265325,4302621,4424589,4542189,4437693,4477677,4347981,4280109,4467261,4327821,4395693,4478685,4262637,4442061,4351341,4498509,4531773,4396365,4329165,4494141,4510941,4400397,4360413,4514973,4504221,4353021,4518333,4457853,4410813,4524381,4284477,4497501,4495149,4296237,4234077,4381581,4243149,4232733,4364445,4334541,4242813,4244157,4334877,4406781,4529757,4334205,4338237,4450797,4534461,4273389,4409805,4479693,4476669,4551261,4245501,4266333,4329837,4222317,4263645,4218957,4409469,4516989,4313709,4346973,4300605,4261293,4449789,4508589,4485069,4536141,4283805,4385949,4388301,4463229,4496493,4484061,4501869,4317069,4333197,4399389,4505229,4302285,4419213,4431645,4536813,4546221,4374861,4246509,4377213,4352349,4489437,4239117,4413501,4515981,4390317,4552605,4231053,4397373,4439709,4451469,4523373,4513965,4399053,4241805,4317741,4555965,4356717,4415181,4283133,4458525,4247517,4292205,4396701,4303965,4277085,4314381,4462221,4355709,4526061,4292877,4503213,4289517,4342269,4235757,4454157,4407789,4446093,4530093,4233741,4281117,4489773,4407453,4336893,4223325,4215597,4312365,4337229,4427949,4379565,4381245,4438029,4288173,4272381,4278765,4390989,4466925,4507581,4440045,4344957,4394013,4484397,4282461,4455837,4483725,4260957,4378893,4349325,4433325,4454829,4455501,4293213,4468269,4509597,4382589,4492125,4294557,4560669,4248189,4326141,4505565,4472637,4221981,4265997,4267005,4398381,4551933,4536477,4345293,4491453,4301949,4249869,4330845,4500189,4386285,4503885,4442733,4291197,4453485,4545549,4396029,4506909,4319421,4389981,4363437,4361757,4386957,4403085,4423245,4457517,4407117,4463901,4487757,4502541,4515309,4418205,4237101,4530429,4335885,4512957,4525389,4223997,4284141,4290861,4232061,4520349,4473309,4509933,4236093,4271373,4230717,4267677,4285821,4339581,4360749,4389309,4446765,4455165,4441725,4320429,4467597,4501197,4423581,4561677,4270701,4447437,4430637,4257933,4496829,4344285,4440717,4372845,4510269,4562349,4384605,4373181,4248861,4506237,4480029,4552269,4403757,4287501,4351005,4370493,4384269,4391661,4450125,4412493,4508925,4516653,4543533,4332189,4332861,4490781,4277757,4289853,4362765,4504557,4225341,4463565,4437357,4323453,4417533,4499853,4524717,4324461,4275069,4251549,4235085,4274733,4410141,4440381,4261965,4485741,4249533,4229709,4301277,4430973,4242477,4553277,4559997,4217949,4370829,4293885,4527741,4429965,4435005,4235421,4544205,4264989,4406109,4272717,4417869,4386621,4479021,4434669,4345629,4373517,4490445,4217277,4550925,4242141,4461213,4375197,4345965,4309341,4436685,4447773,4498845,4556301,4516317,4537149,4528413,4216605,4232397,4408461,4358397,4394685,4337565,4465917,4387965,4297917,4368141,4509261,4451805,4327149,4493805,4218621,4254573,4540173,4412157,4318749,4270365,4290525,4290189,4523709,4281453,4356045,4517661,4483389,4371501,4474653,4432317,4355037,4329501,4359741,4370157,4404429,4244493,4324125,4378557,4450461,4239789,4562013,4461549,4397037,4541853,4369821,4220973,4255917,4497165,4263981,4542525,4343949,4428285,4365453,4279101,4513629,4406445,4335213,4437021,4348317,4523037,4408125,4466589,4533453,4273053,4346637,4316061,4492461,4383593,4323117,4483053,4328157,4366461,4529421,4554621,4477005,4252221,4380237,4547565,4519005,4296909,4521021,4496157,4411149,4420557,4301613,4553949,4367805,4449117,4544541,4548237,4258605,4299261,4310013,4416525,4419549,4510605,4507917,4226349,4362093,4482717,4515645,4561005,4321101,4268349,4550589,4421901,4377549,4493469,4444413,4404093,4343613,4478013,4514301,4439037,4454493,4357389,4525725,4469613,4461885,4558317,4429629,4506573,4280445,4349997,4535469,4532781,4425597,4519341,4414173,4425261,4413837,4545213,4511613,4322109,4241133,4555293,4555629,4246173,4480365,4393677,4466253,4449453,4308669,4401405,4465581,4535133,4222989,4313037,4336221,4375533,4394349,4554957,4537821,4427277,4227021,4257261,4353693,4471629,4384941,4274397,4306653,4224669,4287165,4482045,4559661,4517325,4387293,4258941,4495485,4363773,4298589,4240797,4350669,4385277,4391325,4311693,4422909,4444077,4325805,4216269,4493133,4504893,4309005,4276077,4315389,4358733,4405101,4435677,4482381,4507245,4539165,4546893,4481037,4328493,4398045,4310349,4312701,4348653,4415853,4535805,4337901,4371837,4230381,4452141,4240461,4359069,4383929,4434333,4236765,4238445,4326813,4411485,4250205,4481373,4481709,4357053,4491789,4331517,4354365,4226685,4341597,4265661,4371165,4374525,4408797,4540509,4448109,4249197,4414845,4221645,4467933,4393341,4548573,4288845,4315053,4486749,4494813,4547229,4327485,4223661,4385613,4387629,4431981,4488429,4489101,4321773,4522701,4260285,4220301,4306317,4348989,4395357,4453821,4469277,4230045,4277421,4312029,4300941,4554285,4388973,4475325,4307997,4274061,4389645,4425933,4539837,4416861,4357725,4351677,4245165,4298925,4415517,4256925,4539501,4526733,4375869,4398717,4282797,4360077,4397709,4541181,4420221,4460541,4470957,4353357,4362429,4486413,4401741,4347645,4436349,4221309,4475661,4488765,4543869,4511949,4215933,4244829,4295901,4300269,4355373,4392669,4286493,4446429,4562685,4534797,4528077,4276749,4549581,4341261,4339245,4294893,4315725,4282125,4459197,4285485,4474989,4367133,4283469,4521693,4251213,4527405,4542861,4333869,4457181,4314717,4363101,4522029,4395021],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[4394697,4556649,4226811,4391673,4554747,4444203,4503751,4359081,4299945,4328841,4346427,4395033,4543735,4496359,4403097,4442409,4545561,4463767,4281991,4283671,4456185,4373643,4324327,4381707,4398247,4456857,4384281,4409931,4449319,4454023,4474329,4403433,4215799,4392459,4480041,4492663,4527081,4443531,4530967,4539963,4540375,4551609,4325335,4415719,4353223,4380027,4311223,4485607,4534809,4278891,4392795,4432329,4347175,4553625,4554075,4295431,4299127,4338103,4286283,4380921,4252905,4370283,4449915,4482057,4486951,4312041,4408809,4294347,4228041,4325481,4366999,4448907,4463019,4224199,4424937,4322793,4472313,4245703,4403769,4481911,4336087,4317753,4472167,4477353,4498971,4349191,4505767,4512823,4526187,4267017,4264329,4283931,4335675,4397385,4528875,4388649,4542727,4553961,4505431,4407915,4354567,4379355,4331047,4261495,4319211,4325817,4429083,4227033,4464439,4485195,4391191,4517115,4548027,4466119,4539291,4307451,4389435,4410343,4299799,4418217,4364571,4258281,4249995,4275867,4445883,4367335,4513083,4515321,4352361,4374987,4423707,4269223,4235959,4217739,4265337,4433001,4461079,4232859,4272729,4471495,4492999,4504759,4377225,4246635,4362555,4278967,4303755,4538169,4542537,4410939,4549707,4318951,4303305,4533243,4415307,4223115,4260411,4249545,4280647,4306779,4402875,4441065,4557175,4440057,4264183,4233943,4395559,4393207,4346503,4355575,4289865,4332315,4425387,4248315,4281243,4404777,4483591,4543545,4546233,4557657,4288039,4453497,4327015,4310361,4476345,4513419,4486875,4228491,4555495,4443417,4234761,4447899,4236967,4226215,4514167,4545003,4274073,4431771,4539177,4310697,4262427,4346649,4417545,4437223,4291399,4217479,4355911,4266123,4283259,4496169,4507035,4389993,4404891,4238907,4311147,4422103,4453687,4348665,4261305,4298791,4257723,4555755,4558665,4283817,4314843,4547431,4557993,4546347,4227895,4471083,4387641,4429495,4230393,4256119,4266871,4253431,4367481,4253577,4379019,4419225,4431321,4488441,4495611,4432443,4463431,4334553,4539513,4277097,4428633,4369687,4226475,4293079,4374055,4416651,4449801,4333995,4340715,4468953,4484859,4239991,4378759,4408473,4439385,4377415,4532983,4534251,4385739,4417209,4332873,4519207,4215945,4338249,4384731,4394811,4470075,4523721,4554823,4386633,4255371,4405563,4372635,4474665,4484409,4493335,4326825,4447785,4497177,4560795,4305771,4462759,4279303,4396231,4459995,4531785,4516183,4467273,4520475,4239579,4500537,4526073,4249323,4512151,4409259,4446631,4487433,4529883,4273255,4547355,4301067,4500651,4515099,4332727,4426617,4551723,4331979,4274263,4401753,4327351,4396377,4539031,4554633,4310215,4242679,4321563,4344075,4342281,4431657,4535481,4405899,4460667,4552059,4380363,4358263,4336905,4438155,4559191,4418667,4489303,4301625,4338699,4526523,4243351,4316187,4227223,4266535,4244955,4301479,4341387,4349115,4300953,4363785,4333399,4379095,4540857,4240137,4411161,4560681,4224009,4347847,4400187,4298601,4354491,4413513,4262313,4452603,4436551,4280235,4485867,4493259,4284939,4276875,4263175,4252683,4440583,4511961,4536153,4334407,4490907,4544407,4218411,4544553,4270903,4452007,4493931,4400409,4323915,4255111,4401531,4273927,4519467,4313499,4215723,4309207,4333209,4230507,4304763,4300281,4245627,4408999,4467051,4497291,4258617,4477803,4230247,4358599,4451145,4298455,4420233,4384131,4313835,4327497,4341799,4401081,4465593,4487883,4489113,4516855,4301143,4409481,4417881,4472763,4330857,4310475,4370841,4376407,4403959,4476871,4489785,4498711,4481049,4504233,4408251,4268475,4236631,4509051,4520811,4549447,4506027,4561879,4447563,4563033,4485943,4240809,4446891,4355049,4349527,4399255,4267543,4357927,4372711,4261755,4438231,4489227,4390519,4505913,4559337,4561689,4425273,4229385,4441927,4258395,4390779,4313911,4415193,4438377,4224345,4426135,4417735,4530295,4357515,4357737,4396155,4550119,4220313,4251079,4243833,4287703,4380103,4390665,4434199,4372039,4476681,4536825,4241259,4500201,4560199,4442599,4406457,4488631,4486539,4407801,4262503,4525065,4536679,4541193,4280311,4231737,4325671,4359271,4526745,4463241,4333735,4277433,4247383,4428747,4449129,4351017,4422439,4240923,4445211,4457193,4494825,4297929,4355385,4373047,4389847,4393017,4375399,4261159,4455177,4494939,4274859,4389511,4447303,4527531,4346167,4396713,4467723,4542391,4240473,4325595,4435131,4378347,4445623,4275753,4335079,4500727,4292217,4522491,4259479,4493595,4533465,4391787,4338439,4407243,4232935,4367931,4432107,4446295,4322983,4494343,4427815,4351803,4344151,4289719,4354155,4246375,4262091,4271911,4218297,4285833,4348519,4314583,4446777,4541383,4323655,4398729,4537351,4316859,4382715,4296027,4382379,4223001,4499865,4237975,4289307,4315927,4441401,4460217,4303831,4499047,4407129,4540635,4297783,4515511,4343067,4278441,4447975,4233531,4260823,4282137,4478361,4505577,4402279,4441591,4462683,4535671,4410825,4233753,4414711,4373529,4361433,4234279,4387083,4313721,4308459,4445959,4223191,4265451,4429641,4434681,4464775,4394887,4529211,4296249,4503415,4472503,4274599,4496023,4248873,4437033,4439721,4513977,4318761,4422363,4356171,4367259,4452489,4516665,4529433,4536489,4543881,4454505,4558107,4285497,4430763,4462011,4365991,4347993,4368679,4507447,4539703,4315401,4410153,4256379,4316523,4464699,4287291,4392681,4327947,4317531,4229049,4420011,4324587,4397163,4250331,4433451,4464103,4494007,4522231,4300617,4480231,4419003,4404295,4465111,4313575,4216807,4526859,4305099,4300135,4344487,4302411,4473657,4452825,4443943,4491243,4358859,4482919,4294759,4520887,4524583,4369275,4232409,4276761,4534327,4342617,4296363,4318615,4521369,4533655,4431993,4494153,4321899,4472839,4260297,4523239,4551463,4293561,4320967,4468135,4525401,4437895,4558329,4512411,4537275,4295095,4425609,4320891,4390855,4224459,4436025,4278777,4224535,4380699,4381783,4419339,4455513,4504087,4531449,4478697,4333323,4362967,4442935,4323579,4373383,4433673,4360539,4362219,4243015,4297371,4303083,4237303,4436139,4499307,4507707,4531303,4229239,4229721,4251897,4295913,4301739,4321303,4333659,4394551,4379431,4412359,4239319,4364311,4423111,4425799,4284343,4260633,4460071,4463355,4294087,4478475,4478887,4443271,4511143,4514427,4548699,4471831,4412695,4423929,4521223,4332651,4449579,4372375,4322457,4449655,4243947,4360615,4432183,4364983,4511625,4562215,4277769,4236777,4323465,4290055,4382265,4292743,4229835,4288299,4280907,4347099,4399179,4356583,4407465,4434009,4413627,4368343,4379767,4352887,4487959,4503225,4510395,4534587,4557435,4221321,4366137,4233081,4393803,4444875,4331865,4235287,4356057,4524247,4245291,4429419,4381593,4513495,4327833,4286505,4238571,4243687,4305657,4391451,4437559,4397049,4464585,4487211,4482247,4257051,4365579,4493481,4358187,4351543,4395483,4236891,4255257,4215387,4279449,4332055,4381035,4482171,4536603,4437705,4223673,4366663,4475001,4514985,4243275,4268025,4411611,4414185,4495275,4536939,4385479,4470747,4399515,4499193,4320555,4517337,4219419,4318203,4294569,4511403,4523911,4539627,4251561,4312231,4307337,4412505,4441851,4250889,4333545,4505241,4337095,4244283,4368825,4234615,4397721,4347511,4508937,4255783,4451335,4285161,4527271,4375545,4548363,4559673,4315737,4498299,4382043,4468731,4424791,4216953,4320441,4263657,4270491,4485531,4553479,4556167,4431099,4352139,4405975,4308681,4405639,4445097,4521705,4461415,4289383,4232187,4343403,4311895,4403883,4378683,4453015,4311483,4220839,4244619,4475451,4277959,4402089,4326679,4271385,4412951,4222665,4348329,4219977,4378087,4396827,4414635,4255593,4244169,4273591,4221657,4275607,4295767,4226361,4309467,4372185,4387495,4496841,4511739,4423035,4398057,4535595,4543995,4563223,4463691,4383463,4419897,4435803,4234539,4370169,4402425,4451817,4350795,4240999,4340937,4414039,4437819,4235883,4489449,4365243,4448983,4543063,4237785,4547019,4348779,4554151,4558183,4471641,4221511,4406907,4374537,4340265,4368153,4433863,4321975,4495161,4422775,4428487,4218487,4279975,4419079,4307863,4449991,4559787,4269705,4299723,4417063,4523835,4350459,4351689,4393131,4461751,4354231,4470633,4478139,4538619,4308795,4351131,4561017,4544331,4429977,4386411,4332201,4397835,4444089,4421577,4247307,4521819,4468471,4342731,4316073,4317417,4384953,4381371,4532235,4340043,4268697,4371367,4259403,4502889,4399591,4421431,4475673,4433787,4442859,4290651,4290987,4372299,4224123,4503079,4344823,4550265,4403211,4426281,4472649,4347657,4535335,4550379,4413703,4227369,4269483,4511815,4350681,4387977,4315515,4245367,4481835,4514091,4260487,4516107,4361883,4395819,4488777,4513755,4518535,4541307,4555305,4351207,4373307,4460331,4485081,4287031,4420423,4439575,4548585,4250743,4384471,4476123,4272507,4366923,4504011,4355499,4276089,4431847,4217625,4393689,4401195,4525591,4547241,4381111,4553739,4434459,4491319,4267803,4473771,4319623,4517787,4240663,4306443,4447449,4469067,4494267,4400599,4258807,4530555,4368007,4330711,4378233,4488967,4512633,4531227,4550043,4231065,4363975,4350009,4427143,4543399,4340379,4389099,4411351,4563147,4518795,4551051,4288185,4353369,4269147,4324923,4477689,4305511,4427625,4317081,4438567,4495351,4312713,4328505,4506103,4529959,4544743,4225689,4435017,4552731,4362295,4275417,4336011,4216617,4385067,4281319,4222183,4428411,4348183,4274745,4347435,4406121,4309017,4285015,4361769,4464363,4499529,4560009,4523385,4560345,4230843,4328359,4476459,4467609,4510135,4522155,4336233,4298715,4374727,4262763,4371031,4315179,4247529,4407991,4437483,4537497,4251339,4254699,4252347,4224681,4266009,4416987,4435207,4338027,4424043,4435689,4222779,4466455,4287849,4483401,4510471,4524507,4529769,4538505,4383387,4256455,4234425,4506585,4228155,4234089,4463577,4233195,4492923,4547691,4231255,4528539,4424119,4450999,4510617,4240327,4385815,4247193,4241595,4457307,4345495,4376071,4498521,4216731,4217289,4345083,4250071,4477017,4510281,4512297,4530105,4460553,4298379,4301403,4471755,4246039,4248987,4436697,4281579,4327611,4454619,4295691,4335339,4465447,4471419,4551127,4251225,4331643,4425723,4438827,4452267,4320777,4329177,4507783,4362441,4255929,4290537,4322647,4382937,4268361,4442187,4506775,4236441,4369351,4496283,4337913,4338585,4276425,4259289,4308871,4416391,4475337,4485417,4361211,4534923,4365655,4330635,4405449,4218633,4456635,4304427,4522041,4545225,4249735,4338775,4482507,4392345,4410603,4557099,4272843,4345977,4434535,4247643,4490121,4508791,4392009,4537015,4225207,4525179,4394475,4480491,4517451,4444951,4402761,4386969,4291545,4521147,4509799,4216395,4342953,4354827,4369497,4459735,4309353,4265673,4370023,4457979,4497849,4263435,4547095,4244695,4385289,4289193,4465707,4487623,4366327,4514763,4223451,4237899,4261083,4280121,4296699,4221435,4241671,4276951,4290391,4419415,4490793,4297257,4362631,4483515,4319959,4537833,4387305,4293751,4238235,4376217,4315065,4418331,4293003,4540971,4311033,4465929,4386151,4366473,4517191,4533801,4295577,4220427,4237113,4271721,4350871,4231851,4290727,4293897,4261419,4299463,4334217,4314729,4374391,4415979,4454283,4457047,4518123,4529623,4532121,4254027,4296103,4254249,4391115,4394139,4491915,4502667,4528203,4228231,4458391,4555831,4255447,4531899,4557771,4264107,4383795,4368267,4518459,4416537,4280457,4321639,4341609,4562025,4405227,4402951,4275195,4304985,4284153,4341127,4416873,4296585,4339783,4294905,4306107,4253095,4293339,4467387,4388313,4467945,4540711,4550601,4322235,4330375,4361547,4253913,4559115,4530631,4263511,4377339,4431435,4282327,4229911,4258731,4220763,4312377,4242153,4430091,4275943,4535817,4448793,4259815,4219641,4353705,4221771,4379577,4486203,4400859,4487097,4443607,4515993,4233271,4527943,4551273,4269559,4254439,4314393,4352697,4367817,4225131,4274523,4286619,4357179,4469961,4527607,4529547,4544889,4319769,4333881,4474855,4290873,4272393,4272583,4294683,4341945,4393543,4524171,4532311,4441737,4550937,4352551,4528951,4429831,4329513,4491465,4478215,4420569,4549371,4249881,4336683,4441515,4375323,4497703,4491655,4263099,4421241,4365801,4218823,4326153,4390107,4235433,4406311,4397499,4423593,4432855,4495687,4257609,4319287,4327687,4370955,4328619,4407319,4308345,4245849,4490311,4267353,4408587,4260969,4218747,4232263,4299387,4466937,4369833,4464249,4516443,4483737,4335897,4541979,4465371,4556427,4463095,4447227,4272919,4289529,4414971,4453161,4380775,4455963,4385143,4458201,4497963,4257273,4369947,4501995,4238457,4503003,4231401,4354041,4388427,4395895,4401943,4538695,4541529,4542651,4287963,4346091,4547577,4533915,4429305,4219755,4449243,4220167,4236295,4481499,4252759,4358523,4457865,4528279,4273065,4556985,4411947,4335561,4297593,4335003,4475863,4375063,4419751,4466043,4363899,4398171,4453833,4516519,4504905,4315591,4356507,4291735,4345159,4373719,4302969,4421691,4440171,4503561,4559527,4220985,4249063,4516329,4261831,4265787,4358073,4245513,4442263,4531113,4374873,4286023,4233867,4352811,4450587,4278631,4503339,4329703,4543323,4559001,4344297,4420759,4495947,4490457,4317943,4448647,4468807,4545751,4336423,4242603,4252233,4346313,4306329,4386297,4545339,4386747,4561467,4508265,4410679,4550791,4390443,4479895,4232745,4247047,4258471,4308123,4318539,4328955,4436361,4344747,4452343,4367671,4343625,4448311,4331383,4518345,4331307,4316935,4337431,4225353,4398919,4439049,4291881,4404631,4535931,4542987,4484073,4423783,4548921,4283595,4295355,4270567,4453611,4466601,4331529,4558519,4343289,4237449,4298265,4283145,4400745,4454695,4218151,4488295,4348855,4350123,4263771,4317607,4418071,4556313,4426807,4441255,4258059,4486089,4217815,4474519,4370619,4220503,4460889,4218969,4267879,4492327,4501735,4517863,4520697,4223787,4528761,4544071,4549035,4413963,4261641,4302297,4461675,4357851,4378569,4270155,4490647,4314247,4297035,4510731,4539849,4555083,4319097,4357255,4438903,4425051,4489563,4330039,4360761,4443867,4343961,4229575,4304313,4457383,4278105,4552281,4342059,4408923,4427403,4230171,4316409,4372857,4322121,4257127,4439911,4522567,4305993,4450327,4434795,4470487,4532571,4562551,4225879,4497367,4225467,4497513,4377897,4266681,4340601,4226887,4280793,4420347,4378011,4293675,4428297,4318425,4356919,4310025,4361623,4434871,4514503,4303159,4396567,4524057,4373979,4274409,4398507,4519803,4233417,4268811,4357065,4423447,4483065,4536343,4402203,4429755,4337355,4404105,4392199,4402539,4230583,4226139,4329031,4231927,4250407,4381929,4383605,4419675,4241481,4227705,4277547,4331719,4450251,4455703,4456039,4223337,4295019,4473099,4323801,4334071,4404441,4244359,4486615,4450809,4469289,4537161,4458537,4421095,4444279,4403623,4407579,4315851,4253241,4304839,4308009,4228903,4356843,4399401,4455627,4501399,4504569,4537687,4222329,4225803,4259739,4254585,4295241,4222107,4330185,4360089,4370359,4451671,4465035,4472091,4498039,4517673,4552135,4393467,4346763,4221847,4498185,4415865,4323129,4251675,4417659,4428823,4500055,4453351,4509463,4292331,4557847,4508379,4347321,4339593,4492137,4391527,4233607,4253691,4335225,4480903,4515771,4342135,4215463,4235769,4386487,4415643,4501545,4519131,4477879,4228713,4239801,4469625,4288971,4533319,4242489,4282473,4430839,4391863,4493671,4430985,4503897,4560535,4482393,4533129,4298119,4355835,4552471,4305321,4447113,4264779,4259961,4324663,4256715,4302487,4326007,4422027,4395369,4446967,4525927,4531563,4502553,4316745,4341463,4442523,4383719,4559451,4217143,4477543,4502217,4520551,4508455,4509609,4277287,4285275,4461003,4371513,4396491,4368939,4382601,4300471,4549257,4430167,4398843,4479147,4513305,4343739,4417323,4356729,4393879,4281129,4316263,4412023,4430427,4509723,4363639,4473511,4328283,4248055,4424715,4525737,4389321,4403287,4258135,4320105,4259143,4391337,4223527,4235211,4339707,4469143,4437369,4411497,4226551,4292667,4308535,4244841,4291063,4307673,4314057,4470969,4475191,4526935,4250667,4532457,4548103,4365129,4542055,4536007,4437147,4217067,4303977,4274935,4256043,4524843,4553815,4462569,4369015,4242007,4353483,4511479,4515847,4270377,4457643,4276279,4302075,4231591,4246521,4481239,4555641,4382455,4469479,4378423,4363113,4345831,4406983,4217961,4418553,4483255,4493817,4373193,4300807,4278295,4524729,4562697,4562811,4479819,4405303,4435467,4338921,4316599,4279563,4451259,4540299,4374315,4313163,4232073,4401271,4283481,4263847,4324999,4345641,4334331,4463913,4533991,4544217,4548439,4380585,4517001,4538023,4367145,4461897,4549111,4477207,4413367,4451595,4219495,4388091,4238983,4301961,4460743,4476009,4397911,4276203,4360203,4428075,4292071,4243161,4228377,4263993,4376553,4430503,4266345,4344633,4486279,4322907,4352215,4277883,4417995,4545675,4326603,4365915,4251415,4229163,4453947,4268215,4334889,4412619,4353895,4400935,4471305,4431511,4238121,4473435,4238311,4496695,4364121,4351879,4439239,4249399,4332537,4466379,4485271,4228827,4257799,4453275,4356393,4365319,4286695,4243611,4385403,4409335,4321449,4420683,4425463,4445769,4265001,4412283,4260075,4232599,4456971,4322571,4288635,4221175,4499719,4491129,4507593,4353559,4386823,4534473,4554411,4234203,4275531,4309543,4546905,4448571,4323319,4504683,4384395,4308199,4226025,4236555,4271049,4499979,4269819,4518009,4283335,4225017,4348107,4221099,4362105,4496505,4425127,4455291,4321113,4482843,4479033,4339111,4506249,4511289,4347771,4443753,4304167,4514839,4280983,4401417,4282251,4542315,4490571,4271835,4375209,4555977,4241335,4266459,4514649,4559863,4355239,4438491,4521559,4289643,4359195,4553289,4362891,4503675,4330521,4346985,4242343,4240587,4281655,4467463,4472985,4478551,4314171,4277211,4466265,4359753,4466791,4439835,4379691,4424455,4409671,4275081,4294011,4481385,4345419,4257387,4553143,4427479,4288521,4493145,4272247,4340119,4257945,4236219,4551945,4556091,4225543,4243497,4401607,4311369,4367595,4377003,4420905,4363449,4489899,4498635,4542201,4409145,4466715,4499383,4371177,4525851,4513159,4305175,4256265,4219831,4388763,4550715,4383941,4404967,4247979,4391001,4483927,4345305,4506363,4246971,4504423,4444615,4361097,4282663,4364793,4376889,4413291,4291995,4351467,4359607,4310551,4414521,4381447,4416315,4434123,4313385,4436475,4458315,4436215,4459063,4342807,4406793,4216135,4310887,4288857,4348443,4416201,4294423,4371627,4505691,4509273,4511067,4324809,4260151,4383273,4230057,4290315,4299273,4413027,4455031,4227483,4506439,4309131,4329291,4380439,4306665,4456299,4270231,4446555,4405113,4520139,4281915,4357401,4500873,4292889,4398583,4440247,4452153,4244505,4509945,4446105,4452939,4468395,4241145,4254921,4538359,4467799,4386075,4416055,4311559,4301815,4252011,4400523,4496955,4519689,4343815,4387755,4364235,4411275,4415529,4325145,4319883,4409817,4307001,4307115,4349337,4352025,4434345,4454169,4444425,4331193,4343479,4457719,4480155,4253355,4501323,4515175,4360425,4523499,4501659,4261977,4520361,4536267,4336759,4395147,4508119,4220649,4548249,4268551,4358935,4278555,4440393,4419561,4415383,4411687,4314919,4342471,4279899,4329849,4239655,4488219,4534663,4548775,4555159,4264443,4229499,4267131,4364457,4272057,4282923,4430313,4336569,4431175,4506699,4360279,4438713,4534137,4524393,4560871,4279113,4307787,4387159,4558443,4281465,4402615,4471977,4366251,4525515,4318875,4344411,4552953,4450473,4284603,4400073,4298937,4306183,4462233,4251003,4336347,4522827,4228567,4291323,4241817,4486425,4324251,4334743,4502743,4341051,4278219,4514313,4227559,4515435,4426953,4290201,4349001,4307527,4426395,4459209,4465783,4252087,4469403,4436887,4262649,4239129,4268139,4462423,4473175,4302633,4235097,4421767,4415047,4480713,4496619,4237227,4399065,4500987,4507929,4538283,4219305,4418743,4385625,4244023,4232523,4540039,4330971,4530777,4329367,4535259,4547913,4216281,4505355,4287627,4317867,4247865,4479369,4339371,4395705,4425945,4247719,4488555,4490235,4300059,4371703,4435543,4253019,4337577,4375881,4421355,4421913,4289979,4486761,4502331,4545079,4401867,4433337,4286841,4222519,4478811,4517527,4349451,4284267,4309689,4426731,4470823,4468281,4320631,4523575,4532793,4377561,4520215,4368489,4217403,4276615,4318089,4376743,4474779,4359531,4375659,4375735,4480827,4363227,4507111,4305435,4383127,4392871,4332391,4346839,4364647,4422921,4459545,4562139,4270713,4286359,4446441,4446219,4558779,4259067,4356247,4284489,4492587,4330299,4424265,4414857,4353147,4450137,4264519,4227147,4475527,4403547,4489975,4296775,4473321,4560459,4341723,4456711,4349787,4236105,4248651,4549593,4239915,4312155,4388167,4371849,4303419,4351353,4470151,4222855,4363563,4435879,4389657,4238793,4293225,4406571,4421019,4456521,4368603,4254775,4525255,4395223,4495015,4279639,4424601,4491801,4262839,4282999,4508601,4323991,4242939,4427739,4557321,4410489,4422699,4263321,4376667,4325931,4451931,4296439,4255707,4300731,4327275,4484187,4248537,4230919,4428969,4287177,4324473,4487547,4484599,4250553,4532647,4337241,4272171,4314507,4224871,4242825,4240251,4350199,4394025,4315255,4481575,4248727,4495833,4443081,4359867,4305847,4551387,4302747,4487769,4477467,4266199,4562361,4388839,4479705,4512969,4390183,4540185,4337691,4320295,4318279,4339929,4455367,4528089,4248201,4369611,4530891,4428151,4317195,4523049,4553067,4251751,4259625,4271239,4285351,4531639,4337767,4262167,4277623,4304091,4300395,4328695,4468059,4529097,4554969,4215273,4521483,4237563,4304503,4495497,4521033,4555419,4461561,4321227,4438041,4389771,4373865,4481163,4440507,4562475,4561353,4234951,4271163,4462905,4282809,4489639,4222443,4258953,4311705,4456375,4491991,4413849,4377675,4454841,4291659,4542873,4360875,4427289,4394215,4427961,4271575,4521895,4264855,4354377,4540521,4516779,4297111,4245963,4271499,4273737,4359417,4399851,4426059,4454955,4474443,4561207,4494489,4541643,4224795,4326267,4239243,4341273,4527195,4553403,4556503,4339257,4436811,4502071,4364907,4507371,4432519,4255035,4262985,4279227,4357591,4219083,4273851,4485753,4311819,4534999,4552395,4465257,4371291,4254103,4393353,4483179,4328023,4379241,4328169,4350535,4365465,4530219,4491579,4412837,4349673,4335751,4396041,4313239,4458651,4260747,4293415,4313049,4246857,4370505,4462087,4470297,4484745,4372971,4444761,4307191,4464027,4468617,4518199,4285947,4273515,4249659,4288375,4326939,4334667,4309879,4340455,4361959,4322311,4374651,4375995,4302823,4377751,4354903,4312567,4292407,4426471,4445287,4488891,4472427,4501063,4266795,4238647,4370695,4439163,4246299,4448121,4355163,4501881,4532907,4537611,4414299,4404219,4342395,4504347,4221993,4299609,4518871,4561543,4306519,4265191,4538841,4460407,4458987,4397239,4482583,4552807,4267689,4397575,4354713,4442073,4321785,4550455,4557511,4246185,4366587,4410267,4399737,4458873,4226697,4235623,4384055,4444539,4250217,4273401,4303495,4450663,4267207,4470411,4473993,4237639,4252423,4275271,4216471,4412169,4427067,4474183,4494603,4256937,4513641,4522713,4443195,4526409,4527753,4530441,4541865,4546423,4344969,4484523,4297447,4546759,4407655,4560123,4459881,4219159,4265527,4449465,4414375,4279785,4282587,4287367,4349863,4467127,4510807,4549929,4270827,4429159,4264665,4509127,4546011,4515657,4366809,4424379,4462347,4528615,4231515,4284007,4459399,4509387,4392535,4554487,4474107,4406647,4406235,4408663,4561131,4324137,4245031,4363303,4302151,4440729,4408137,4361287,4458055,4423371,4404555,4298043,4526599,4285687,4286169,4223863,4492251,4309803,4526263,4432665,4358745,4541047,4358409,4383051,4432779,4284679,4369161,4452679,4475115,4338363,4505019,4326343,4433115,4512747,4538955,4387831,4379913,4558855,4252569,4556763,4385961,4350345,4477131,4256601,4246711,4513831,4422249,4524919,4408327,4510059,4294233,4360951,4461339,4320219,4291209,4280571,4326489,4312903,4377079,4384807,4310811,4292553,4473847,4488105,4535145,4435353,4382119,4329963,4409595,4335415,4304649,4445433,4480377,4483851,4543659,4544667,4405785,4451481,4551799,4389175,4418889,4234875,4433191,4492473,4317271,4562887,4498857,4286955,4355721,4476535,4345755,4500391,4249209,4287513,4411015,4276539,4218075,4430649,4476795,4479223,4479483,4245177,4490983,4254363,4505095,4417399,4392123,4455849,4475787,4497031,4339447,4480567,4273179,4457529,4319433,4507257,4508043,4510953,4459323,4416727,4289047,4265115,4423257,4479559,4482729,4394361,4512487,4541719,4440843,4545415,4545897,4231179,4267467,4497627,4484935,4256791,4288711,4494679,4447639,4531975,4519353,4374201,4284825,4299051,4269895,4340791,4388985,4411833,4413177,4454359,4552617,4362777,4439499,4376331,4519017,4441179,4381257,4518681,4500315,4269369,4459659,4458727,4529287,4537947,4312491,4487287,4484263,4215609,4418407,4445547,4546087,4561803,4310139,4248391,4332987,4297707,4523163,4547767,4268887,4257463,4422585,4387419,4380249,4481721,4492809,4469739,4384617,4371963,4327161,4270041,4440919,4235547,4253767,4333063,4388503,4461225,4512075,4522377,4241931,4546683,4533579,4420087,4502407,4359943,4519879,4539367,4337019,4469815,4546569,4527867,4242267,4239465,4433527,4501209,4528425,4329627,4508715,4498375,4353033,4296921,4372521,4281801,4378905,4499643,4506921,4390329,4519543,4442745,4265863,4274187,4343143,4471159,4476199,4269033,4450923,4522903,4353819,4312827,4543209,4352475,4554297,4227819,4398393,4220091,4306855,4400263,4527417,4549783,4230729,4556839,4399927,4339035,4303641,4325259,4448457,4301289,4285611,4323243,4410007,4319547,4396903,4464921,4478025,4448235,4216059,4382791,4520025],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":5},{"path":["/","usr","src","regex","tests","test_default.rs"],"content":"#![cfg_attr(feature = \"pattern\", feature(pattern))]\n\nextern crate rand;\nextern crate regex;\n\n// Due to macro scoping rules, this definition only applies for the modules\n// defined below. Effectively, it allows us to use the same tests for both\n// native and dynamic regexes.\n//\n// This is also used to test the various matching engines. This one exercises\n// the normal code path which automatically chooses the engine based on the\n// regex and the input. Other dynamic tests explicitly set the engine to use.\nmacro_rules! regex_new {\n    ($re:expr) => {{\n        use regex::Regex;\n        Regex::new($re)\n    }};\n}\n\nmacro_rules! regex {\n    ($re:expr) => {\n        regex_new!($re).unwrap()\n    };\n}\n\nmacro_rules! regex_set_new {\n    ($re:expr) => {{\n        use regex::RegexSet;\n        RegexSet::new($re)\n    }};\n}\n\nmacro_rules! regex_set {\n    ($res:expr) => {\n        regex_set_new!($res).unwrap()\n    };\n}\n\n// Must come before other module definitions.\ninclude!(\"macros_str.rs\");\ninclude!(\"macros.rs\");\n\nmod api;\nmod api_str;\nmod crazy;\nmod flags;\nmod fowler;\nmod misc;\nmod multiline;\nmod noparse;\nmod regression;\nmod replace;\nmod searcher;\nmod set;\nmod shortest_match;\nmod suffix_reverse;\n#[cfg(feature = \"unicode\")]\nmod unicode;\n#[cfg(feature = \"unicode-perl\")]\nmod word_boundary;\n#[cfg(feature = \"unicode-perl\")]\nmod word_boundary_unicode;\n\n#[test]\nfn disallow_non_utf8() {\n    assert!(regex::Regex::new(r\"(?-u)\\xFF\").is_err());\n    assert!(regex::Regex::new(r\"(?-u).\").is_err());\n    assert!(regex::Regex::new(r\"(?-u)[\\xFF]\").is_err());\n    assert!(regex::Regex::new(r\"(?-u)☃\").is_err());\n}\n\n#[test]\nfn disallow_octal() {\n    assert!(regex::Regex::new(r\"\\0\").is_err());\n}\n\n#[test]\nfn allow_octal() {\n    assert!(regex::RegexBuilder::new(r\"\\0\").octal(true).build().is_ok());\n}\n\n#[test]\nfn oibits() {\n    use regex::bytes;\n    use regex::{Regex, RegexBuilder};\n    use std::panic::UnwindSafe;\n\n    fn assert_send<T: Send>() {}\n    fn assert_sync<T: Sync>() {}\n    fn assert_unwind_safe<T: UnwindSafe>() {}\n\n    assert_send::<Regex>();\n    assert_sync::<Regex>();\n    assert_unwind_safe::<Regex>();\n    assert_send::<RegexBuilder>();\n    assert_sync::<RegexBuilder>();\n    assert_unwind_safe::<RegexBuilder>();\n\n    assert_send::<bytes::Regex>();\n    assert_sync::<bytes::Regex>();\n    assert_unwind_safe::<bytes::Regex>();\n    assert_send::<bytes::RegexBuilder>();\n    assert_sync::<bytes::RegexBuilder>();\n    assert_unwind_safe::<bytes::RegexBuilder>();\n}\n\n// See: https://github.com/rust-lang/regex/issues/568\n#[test]\nfn oibits_regression() {\n    use regex::Regex;\n    use std::panic;\n\n    let _ = panic::catch_unwind(|| Regex::new(\"a\").unwrap());\n}\n","traces":[{"line":65,"address":[7816240,7816245],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":66,"address":[7593406,7593447,7593530],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[7593509,7593654,7593565],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[7593630,7593787,7593692],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[7593825,7593763,7593895],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[7816277,7816272],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":74,"address":[7594125,7594027,7594065],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[7816309,7816304],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":79,"address":[7594226,7594365,7594190],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[7816336,7816341],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":88,"address":[7816400,7816385,7816416,7816368,7816369,7816401,7816417,7816384],"length":1,"stats":{"Line":4},"fn_name":"assert_send<regex::re_bytes::Regex>"},{"line":89,"address":[7816464,7816465,7816481,7816449,7816448,7816433,7816480,7816432],"length":1,"stats":{"Line":4},"fn_name":"assert_sync<regex::re_unicode::Regex>"},{"line":90,"address":[7816544,7816512,7816497,7816545,7816529,7816513,7816528,7816496],"length":1,"stats":{"Line":4},"fn_name":"assert_unwind_safe<regex::re_bytes::Regex>"},{"line":92,"address":[7594433],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[7594438],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[7594443],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[7594448],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[7594453],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[7594458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[7594463],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[7594468],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[7594473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[7594478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[7594483],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[7594488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[7594496],"length":1,"stats":{"Line":3},"fn_name":"oibits_regression"},{"line":113,"address":[7594500],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":27,"coverable":27},{"path":["/","usr","src","regex","tests","test_default_bytes.rs"],"content":"extern crate rand;\nextern crate regex;\n\nmacro_rules! regex_new {\n    ($re:expr) => {{\n        use regex::bytes::Regex;\n        Regex::new($re)\n    }};\n}\n\nmacro_rules! regex_set_new {\n    ($res:expr) => {{\n        use regex::bytes::RegexSet;\n        RegexSet::new($res)\n    }};\n}\n\nmacro_rules! regex {\n    ($re:expr) => {\n        regex_new!($re).unwrap()\n    };\n}\n\nmacro_rules! regex_set {\n    ($res:expr) => {\n        regex_set_new!($res).unwrap()\n    };\n}\n\n// Must come before other module definitions.\ninclude!(\"macros_bytes.rs\");\ninclude!(\"macros.rs\");\n\n// A silly wrapper to make it possible to write and match raw bytes.\nstruct R<'a>(&'a [u8]);\nimpl<'a> R<'a> {\n    fn as_bytes(&self) -> &'a [u8] {\n        self.0\n    }\n}\n\n// See: https://github.com/rust-lang/regex/issues/321\n//\n// These tests are here because they do not have the same behavior in every\n// regex engine.\nmat!(invalid_utf8_nfa1, r\".\", R(b\"\\xD4\\xC2\\x65\\x2B\\x0E\\xFE\"), Some((2, 3)));\nmat!(invalid_utf8_nfa2, r\"${2}ä\", R(b\"\\xD4\\xC2\\x65\\x2B\\x0E\\xFE\"), None);\nmat!(\n    invalid_utf8_nfa3,\n    r\".\",\n    R(b\"\\x0A\\xDB\\x82\\x6E\\x33\\x01\\xDD\\x33\\xCD\"),\n    Some((1, 3))\n);\nmat!(\n    invalid_utf8_nfa4,\n    r\"${2}ä\",\n    R(b\"\\x0A\\xDB\\x82\\x6E\\x33\\x01\\xDD\\x33\\xCD\"),\n    None\n);\n\nmod api;\nmod bytes;\nmod crazy;\nmod flags;\nmod fowler;\nmod multiline;\nmod noparse;\nmod regression;\nmod replace;\nmod set;\nmod shortest_match;\nmod suffix_reverse;\n#[cfg(feature = \"unicode\")]\nmod unicode;\n#[cfg(feature = \"unicode-perl\")]\nmod word_boundary;\n#[cfg(feature = \"unicode-perl\")]\nmod word_boundary_unicode;\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[5229096,5227783,5227846],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[5229862,5229799],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[5231767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[5231830],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[5233783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[5233846],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":8,"coverable":8},{"path":["/","usr","src","regex","tests","test_nfa.rs"],"content":"#![cfg_attr(feature = \"pattern\", feature(pattern))]\n\nextern crate rand;\nextern crate regex;\n\nmacro_rules! regex_new {\n    ($re:expr) => {{\n        use regex::internal::ExecBuilder;\n        ExecBuilder::new($re).nfa().build().map(|e| e.into_regex())\n    }};\n}\n\nmacro_rules! regex {\n    ($re:expr) => {\n        regex_new!($re).unwrap()\n    };\n}\n\nmacro_rules! regex_set_new {\n    ($re:expr) => {{\n        use regex::internal::ExecBuilder;\n        ExecBuilder::new_many($re).nfa().build().map(|e| e.into_regex_set())\n    }};\n}\n\nmacro_rules! regex_set {\n    ($res:expr) => {\n        regex_set_new!($res).unwrap()\n    };\n}\n\n// Must come before other module definitions.\ninclude!(\"macros_str.rs\");\ninclude!(\"macros.rs\");\n\nmod api;\nmod api_str;\nmod crazy;\nmod flags;\nmod fowler;\nmod multiline;\nmod noparse;\nmod regression;\nmod replace;\nmod searcher;\nmod set;\nmod suffix_reverse;\n#[cfg(feature = \"unicode\")]\nmod unicode;\n#[cfg(feature = \"unicode-perl\")]\nmod word_boundary;\n#[cfg(feature = \"unicode-perl\")]\nmod word_boundary_unicode;\n","traces":[{"line":9,"address":[5212096,5218144,5219879,5213824,5209079,5220304,5206919,5205184,5212967,5189639,5214695,5190064,5207351,5192663,5193095,5186608,5217280,5202599,5198272,5213399,5208215,5192224,5210800,5210368,5200007,5201728,5219008,5191367,5193527,5194384,5195255,5211232,5187479,5201296,5215559,5208647,5200439,5189632,5218583,5194391,5192231,5215984,5200000,5190503,5197415,5203895,5191799,5195680,5198711,5192656,5198704,5201303,5216416,5202160,5203463,5196544,5191360,5193959,5212960,5196119,5199136,5208640,5211671,5209504,5203024,5197408,5213392,5213831,5210807,5214688,5219015,5215991,5187911,5194823,5187047,5216855,5207776,5209511,5215552,5217287,5196551,5200871,5210375,5190071,5196976,5185751,5195687,5202167,5203456,5216848,5194816,5193952,5200432,5209072,5220736,5220743,5190935,5206048,5204327,5202592,5185744,5209936,5219447,5218576,5196983,5188775,5211664,5212535,5218151,5195248,5206912,5186183,5186615,5203031,5208208,5199143,5204320,5211239,5193520,5212103,5214256,5199568,5190496,5191792,5215120,5217712,5217719,5219440,5219872,5215127,5188336,5214263,5189200,5198279,5197840,5200864,5204752,5205616,5205623,5212528,5190928,5220311,5193088,5199575,5189207,5216423,5187904,5207344,5203888,5186176,5197847,5206055,5206480,5187472,5188768,5188343,5196112,5205191,5206487,5201735,5204759,5207783,5187040,5209943],"length":1,"stats":{"Line":1456},"fn_name":"{{closure}}"},{"line":22,"address":[8481008,8481015,8480903,8481232,8480448,8482800,8483815,8481799,8480784,8480896,8481792,8481239,8482912,8480791,8483024,8482359,8481904,8483696,8483367,8483472,8483920,8481911,8482135,8481120,8483136,8483248,8483479,8481351,8481680,8483584,8482576,8481575,8481568,8482464,8483703,8482016,8481344,8481127,8480455,8480560,8482471,8482583,8482128,8480567,8482240,8482247,8480672,8482807,8482919,8483031,8483255,8483360,8483591,8483927,8481463,8480343,8482023,8482695,8483808,8482352,8483143,8481687,8482688,8480679,8480336,8481456],"length":1,"stats":{"Line":66},"fn_name":"{{closure}}"}],"covered":2,"coverable":2},{"path":["/","usr","src","regex","tests","test_nfa_bytes.rs"],"content":"extern crate rand;\nextern crate regex;\n\nmacro_rules! regex_new {\n    ($re:expr) => {{\n        use regex::internal::ExecBuilder;\n        ExecBuilder::new($re)\n            .nfa()\n            .only_utf8(false)\n            .build()\n            .map(|e| e.into_byte_regex())\n    }};\n}\n\nmacro_rules! regex {\n    ($re:expr) => {\n        regex_new!($re).unwrap()\n    };\n}\n\nmacro_rules! regex_set_new {\n    ($re:expr) => {{\n        use regex::internal::ExecBuilder;\n        ExecBuilder::new_many($re)\n            .nfa()\n            .only_utf8(false)\n            .build()\n            .map(|e| e.into_byte_regex_set())\n    }};\n}\n\nmacro_rules! regex_set {\n    ($res:expr) => {\n        regex_set_new!($res).unwrap()\n    };\n}\n\n// Must come before other module definitions.\ninclude!(\"macros_bytes.rs\");\ninclude!(\"macros.rs\");\n\nmod api;\nmod bytes;\nmod crazy;\nmod flags;\nmod fowler;\nmod multiline;\nmod noparse;\nmod regression;\nmod replace;\nmod set;\nmod suffix_reverse;\n#[cfg(feature = \"unicode\")]\nmod unicode;\n#[cfg(feature = \"unicode-perl\")]\nmod word_boundary;\n#[cfg(feature = \"unicode-perl\")]\nmod word_boundary_unicode;\n","traces":[{"line":11,"address":[5370103,5370832,5371328,5373575,5374247,5373015,5369367,5370096,5372007,5368784,5371783,5374471,5369360,5371335,5371671,5372336,5373792,5368791,5374135,5373351,5369712,5372567,5373904,5370295,5372448,5374128,5370839,5369904,5371888,5368976,5369911,5371664,5372343,5372791,5369552,5371024,5372112,5372672,5372896,5372455,5373008,5373120,5370480,5371104,5371552,5372224,5373127,5373463,5373680,5370288,5369719,5371223,5371559,5371031,5371447,5372000,5372119,5370487,5372231,5372560,5372679,5373239,5373456,5372784,5373568,5373687,5373911,5374016,5374023,5368592,5371440,5374352,5371216,5373799,5370944,5369559,5371111,5372903,5371776,5369168,5369175,5373232,5374359,5374464,5373344,5374240,5371895,5368983,5368599,5370951],"length":1,"stats":{"Line":1506},"fn_name":"{{closure}}"},{"line":28,"address":[5375696,5376480,5377159,5377264,5377271,5377831,5377824,5376263,5375255,5377047,5376935,5377152,5376823,5377495,5377488,5377712,5375367,5376256,5376816,5376375,5374695,5376704,5376144,5374576,5374919,5375808,5375584,5376599,5375472,5375143,5378160,5377040,5375360,5378048,5374688,5375031,5374583,5375703,5376032,5376487,5376711,5375024,5376368,5377607,5377719,5376592,5377600,5375815,5377936,5378167,5374800,5375136,5375479,5375591,5376151,5374807,5375248,5377376,5377383,5378055,5375927,5376928,5374912,5376039,5377943,5375920],"length":1,"stats":{"Line":66},"fn_name":"{{closure}}"}],"covered":2,"coverable":2},{"path":["/","usr","src","regex","tests","test_nfa_utf8bytes.rs"],"content":"#![cfg_attr(feature = \"pattern\", feature(pattern))]\n\nextern crate rand;\nextern crate regex;\n\nmacro_rules! regex_new {\n    ($re:expr) => {{\n        use regex::internal::ExecBuilder;\n        ExecBuilder::new($re).nfa().bytes(true).build().map(|e| e.into_regex())\n    }};\n}\n\nmacro_rules! regex {\n    ($re:expr) => {\n        regex_new!($re).unwrap()\n    };\n}\n\nmacro_rules! regex_set_new {\n    ($re:expr) => {{\n        use regex::internal::ExecBuilder;\n        ExecBuilder::new_many($re)\n            .nfa()\n            .bytes(true)\n            .build()\n            .map(|e| e.into_regex_set())\n    }};\n}\n\nmacro_rules! regex_set {\n    ($res:expr) => {\n        regex_set_new!($res).unwrap()\n    };\n}\n\n// Must come before other module definitions.\ninclude!(\"macros_str.rs\");\ninclude!(\"macros.rs\");\n\nmod api;\nmod api_str;\nmod crazy;\nmod flags;\nmod fowler;\nmod multiline;\nmod noparse;\nmod regression;\nmod replace;\nmod searcher;\nmod set;\nmod suffix_reverse;\n#[cfg(feature = \"unicode\")]\nmod unicode;\n#[cfg(feature = \"unicode-perl\")]\nmod word_boundary;\n#[cfg(feature = \"unicode-perl\")]\nmod word_boundary_unicode;\n","traces":[{"line":9,"address":[4395776,4395968,4395783,4396320,4395975,4396327],"length":1,"stats":{"Line":1456},"fn_name":"{{closure}}"},{"line":26,"address":[4259552,4259671,4257543,4257984,4259888,4257655,4256640,4258663,4258999,4259895,4260224,4257200,4258215,4258439,4259783,4260007,4258103,4259328,4256759,4256983,4257648,4258775,4260119,4257767,4257879,4257536,4259559,4258096,4257088,4259447,4258551,4257760,4258656,4259216,4259664,4260231,4257207,4258320,4256976,4257095,4258880,4257312,4260000,4256871,4258768,4258887,4260112,4258432,4256864,4257319,4258544,4257872,4259111,4259335,4256647,4259440,4256752,4259776,4258208,4257431,4257424,4259104,4257991,4258327,4259223,4258992],"length":1,"stats":{"Line":66},"fn_name":"{{closure}}"}],"covered":2,"coverable":2},{"path":["/","usr","src","regex","tests","unicode.rs"],"content":"mat!(uni_literal, r\"☃\", \"☃\", Some((0, 3)));\nmat!(uni_literal_plus, r\"☃+\", \"☃\", Some((0, 3)));\nmat!(uni_literal_casei_plus, r\"(?i)☃+\", \"☃\", Some((0, 3)));\nmat!(uni_class_plus, r\"[☃Ⅰ]+\", \"☃\", Some((0, 3)));\nmat!(uni_one, r\"\\pN\", \"Ⅰ\", Some((0, 3)));\nmat!(uni_mixed, r\"\\pN+\", \"Ⅰ1Ⅱ2\", Some((0, 8)));\nmat!(uni_not, r\"\\PN+\", \"abⅠ\", Some((0, 2)));\nmat!(uni_not_class, r\"[\\PN]+\", \"abⅠ\", Some((0, 2)));\nmat!(uni_not_class_neg, r\"[^\\PN]+\", \"abⅠ\", Some((2, 5)));\nmat!(uni_case, r\"(?i)Δ\", \"δ\", Some((0, 2)));\nmat!(uni_case_upper, r\"\\p{Lu}+\", \"ΛΘΓΔα\", Some((0, 8)));\nmat!(uni_case_upper_nocase_flag, r\"(?i)\\p{Lu}+\", \"ΛΘΓΔα\", Some((0, 10)));\nmat!(uni_case_upper_nocase, r\"\\p{L}+\", \"ΛΘΓΔα\", Some((0, 10)));\nmat!(uni_case_lower, r\"\\p{Ll}+\", \"ΛΘΓΔα\", Some((8, 10)));\n\n// Test the Unicode friendliness of Perl character classes.\nmat!(uni_perl_w, r\"\\w+\", \"dδd\", Some((0, 4)));\nmat!(uni_perl_w_not, r\"\\w+\", \"⥡\", None);\nmat!(uni_perl_w_neg, r\"\\W+\", \"⥡\", Some((0, 3)));\nmat!(uni_perl_d, r\"\\d+\", \"1२३9\", Some((0, 8)));\nmat!(uni_perl_d_not, r\"\\d+\", \"Ⅱ\", None);\nmat!(uni_perl_d_neg, r\"\\D+\", \"Ⅱ\", Some((0, 3)));\nmat!(uni_perl_s, r\"\\s+\", \" \", Some((0, 3)));\nmat!(uni_perl_s_not, r\"\\s+\", \"☃\", None);\nmat!(uni_perl_s_neg, r\"\\S+\", \"☃\", Some((0, 3)));\n\n// And do the same for word boundaries.\nmat!(uni_boundary_none, r\"\\d\\b\", \"6δ\", None);\nmat!(uni_boundary_ogham, r\"\\d\\b\", \"6 \", Some((0, 1)));\nmat!(uni_not_boundary_none, r\"\\d\\B\", \"6δ\", Some((0, 1)));\nmat!(uni_not_boundary_ogham, r\"\\d\\B\", \"6 \", None);\n\n// Test general categories.\n//\n// We should test more, but there's a lot. Write a script to generate more of\n// these tests.\nmat!(uni_class_gencat_cased_letter, r\"\\p{Cased_Letter}\", \"Ａ\", Some((0, 3)));\nmat!(\n    uni_class_gencat_close_punctuation,\n    r\"\\p{Close_Punctuation}\",\n    \"❯\",\n    Some((0, 3))\n);\nmat!(\n    uni_class_gencat_connector_punctuation,\n    r\"\\p{Connector_Punctuation}\",\n    \"⁀\",\n    Some((0, 3))\n);\nmat!(uni_class_gencat_control, r\"\\p{Control}\", \"\\u{9f}\", Some((0, 2)));\nmat!(\n    uni_class_gencat_currency_symbol,\n    r\"\\p{Currency_Symbol}\",\n    \"￡\",\n    Some((0, 3))\n);\nmat!(\n    uni_class_gencat_dash_punctuation,\n    r\"\\p{Dash_Punctuation}\",\n    \"〰\",\n    Some((0, 3))\n);\nmat!(uni_class_gencat_decimal_numer, r\"\\p{Decimal_Number}\", \"𑓙\", Some((0, 4)));\nmat!(\n    uni_class_gencat_enclosing_mark,\n    r\"\\p{Enclosing_Mark}\",\n    \"\\u{A672}\",\n    Some((0, 3))\n);\nmat!(\n    uni_class_gencat_final_punctuation,\n    r\"\\p{Final_Punctuation}\",\n    \"⸡\",\n    Some((0, 3))\n);\nmat!(uni_class_gencat_format, r\"\\p{Format}\", \"\\u{E007F}\", Some((0, 4)));\nmat!(\n    uni_class_gencat_initial_punctuation,\n    r\"\\p{Initial_Punctuation}\",\n    \"⸜\",\n    Some((0, 3))\n);\nmat!(uni_class_gencat_letter, r\"\\p{Letter}\", \"Έ\", Some((0, 2)));\nmat!(uni_class_gencat_letter_number, r\"\\p{Letter_Number}\", \"ↂ\", Some((0, 3)));\nmat!(\n    uni_class_gencat_line_separator,\n    r\"\\p{Line_Separator}\",\n    \"\\u{2028}\",\n    Some((0, 3))\n);\nmat!(\n    uni_class_gencat_lowercase_letter,\n    r\"\\p{Lowercase_Letter}\",\n    \"ϛ\",\n    Some((0, 2))\n);\nmat!(uni_class_gencat_mark, r\"\\p{Mark}\", \"\\u{E01EF}\", Some((0, 4)));\nmat!(uni_class_gencat_math, r\"\\p{Math}\", \"⋿\", Some((0, 3)));\nmat!(\n    uni_class_gencat_modifier_letter,\n    r\"\\p{Modifier_Letter}\",\n    \"𖭃\",\n    Some((0, 4))\n);\nmat!(\n    uni_class_gencat_modifier_symbol,\n    r\"\\p{Modifier_Symbol}\",\n    \"🏿\",\n    Some((0, 4))\n);\nmat!(\n    uni_class_gencat_nonspacing_mark,\n    r\"\\p{Nonspacing_Mark}\",\n    \"\\u{1E94A}\",\n    Some((0, 4))\n);\nmat!(uni_class_gencat_number, r\"\\p{Number}\", \"⓿\", Some((0, 3)));\nmat!(\n    uni_class_gencat_open_punctuation,\n    r\"\\p{Open_Punctuation}\",\n    \"｟\",\n    Some((0, 3))\n);\nmat!(uni_class_gencat_other, r\"\\p{Other}\", \"\\u{bc9}\", Some((0, 3)));\nmat!(uni_class_gencat_other_letter, r\"\\p{Other_Letter}\", \"ꓷ\", Some((0, 3)));\nmat!(uni_class_gencat_other_number, r\"\\p{Other_Number}\", \"㉏\", Some((0, 3)));\nmat!(\n    uni_class_gencat_other_punctuation,\n    r\"\\p{Other_Punctuation}\",\n    \"𞥞\",\n    Some((0, 4))\n);\nmat!(uni_class_gencat_other_symbol, r\"\\p{Other_Symbol}\", \"⅌\", Some((0, 3)));\nmat!(\n    uni_class_gencat_paragraph_separator,\n    r\"\\p{Paragraph_Separator}\",\n    \"\\u{2029}\",\n    Some((0, 3))\n);\nmat!(\n    uni_class_gencat_private_use,\n    r\"\\p{Private_Use}\",\n    \"\\u{10FFFD}\",\n    Some((0, 4))\n);\nmat!(uni_class_gencat_punctuation, r\"\\p{Punctuation}\", \"𑁍\", Some((0, 4)));\nmat!(uni_class_gencat_separator, r\"\\p{Separator}\", \"\\u{3000}\", Some((0, 3)));\nmat!(\n    uni_class_gencat_space_separator,\n    r\"\\p{Space_Separator}\",\n    \"\\u{205F}\",\n    Some((0, 3))\n);\nmat!(\n    uni_class_gencat_spacing_mark,\n    r\"\\p{Spacing_Mark}\",\n    \"\\u{16F7E}\",\n    Some((0, 4))\n);\nmat!(uni_class_gencat_symbol, r\"\\p{Symbol}\", \"⯈\", Some((0, 3)));\nmat!(\n    uni_class_gencat_titlecase_letter,\n    r\"\\p{Titlecase_Letter}\",\n    \"ῼ\",\n    Some((0, 3))\n);\nmat!(\n    uni_class_gencat_unassigned,\n    r\"\\p{Unassigned}\",\n    \"\\u{10FFFF}\",\n    Some((0, 4))\n);\nmat!(\n    uni_class_gencat_uppercase_letter,\n    r\"\\p{Uppercase_Letter}\",\n    \"Ꝋ\",\n    Some((0, 3))\n);\n\n// Test a smattering of properties.\nmat!(uni_class_prop_emoji1, r\"\\p{Emoji}\", \"\\u{23E9}\", Some((0, 3)));\nmat!(uni_class_prop_emoji2, r\"\\p{emoji}\", \"\\u{1F21A}\", Some((0, 4)));\nmat!(\n    uni_class_prop_picto1,\n    r\"\\p{extendedpictographic}\",\n    \"\\u{1FA6E}\",\n    Some((0, 4))\n);\nmat!(\n    uni_class_prop_picto2,\n    r\"\\p{extendedpictographic}\",\n    \"\\u{1FFFD}\",\n    Some((0, 4))\n);\n\n// grapheme_cluster_break\nmat!(\n    uni_class_gcb_prepend,\n    r\"\\p{grapheme_cluster_break=prepend}\",\n    \"\\u{11D46}\",\n    Some((0, 4))\n);\nmat!(\n    uni_class_gcb_ri1,\n    r\"\\p{gcb=regional_indicator}\",\n    \"\\u{1F1E6}\",\n    Some((0, 4))\n);\nmat!(uni_class_gcb_ri2, r\"\\p{gcb=ri}\", \"\\u{1F1E7}\", Some((0, 4)));\nmat!(\n    uni_class_gcb_ri3,\n    r\"\\p{gcb=regionalindicator}\",\n    \"\\u{1F1FF}\",\n    Some((0, 4))\n);\nmat!(uni_class_gcb_lvt, r\"\\p{gcb=lvt}\", \"\\u{C989}\", Some((0, 3)));\nmat!(uni_class_gcb_zwj, r\"\\p{gcb=zwj}\", \"\\u{200D}\", Some((0, 3)));\n\n// word_break\nmat!(uni_class_wb1, r\"\\p{word_break=Hebrew_Letter}\", \"\\u{FB46}\", Some((0, 3)));\nmat!(uni_class_wb2, r\"\\p{wb=hebrewletter}\", \"\\u{FB46}\", Some((0, 3)));\nmat!(uni_class_wb3, r\"\\p{wb=ExtendNumLet}\", \"\\u{FF3F}\", Some((0, 3)));\nmat!(uni_class_wb4, r\"\\p{wb=WSegSpace}\", \"\\u{3000}\", Some((0, 3)));\nmat!(uni_class_wb5, r\"\\p{wb=numeric}\", \"\\u{1E950}\", Some((0, 4)));\n\n// sentence_break\nmat!(uni_class_sb1, r\"\\p{sentence_break=Lower}\", \"\\u{0469}\", Some((0, 2)));\nmat!(uni_class_sb2, r\"\\p{sb=lower}\", \"\\u{0469}\", Some((0, 2)));\nmat!(uni_class_sb3, r\"\\p{sb=Close}\", \"\\u{FF60}\", Some((0, 3)));\nmat!(uni_class_sb4, r\"\\p{sb=Close}\", \"\\u{1F677}\", Some((0, 4)));\nmat!(uni_class_sb5, r\"\\p{sb=SContinue}\", \"\\u{FF64}\", Some((0, 3)));\n","traces":[{"line":1,"address":[6474932,6474894,6476308],"length":1,"stats":{"Line":13},"fn_name":null},{"line":2,"address":[6477022,6478436,6477060],"length":1,"stats":{"Line":13},"fn_name":null},{"line":3,"address":[6479150,6479188,6480564],"length":1,"stats":{"Line":13},"fn_name":null},{"line":4,"address":[6482692,6481278,6481316],"length":1,"stats":{"Line":13},"fn_name":null},{"line":5,"address":[6483406,6484820,6483444],"length":1,"stats":{"Line":13},"fn_name":null},{"line":6,"address":[6486948,6485572,6485534],"length":1,"stats":{"Line":13},"fn_name":null},{"line":7,"address":[6487700,6487662,6489076],"length":1,"stats":{"Line":13},"fn_name":null},{"line":8,"address":[6489790,6489828,6491204],"length":1,"stats":{"Line":13},"fn_name":null},{"line":9,"address":[6491956,6491918,6493332],"length":1,"stats":{"Line":13},"fn_name":null},{"line":10,"address":[6494084,6495460,6494046],"length":1,"stats":{"Line":13},"fn_name":null},{"line":11,"address":[6496174,6496212,6497588],"length":1,"stats":{"Line":13},"fn_name":null},{"line":12,"address":[6499716,6498302,6498340],"length":1,"stats":{"Line":13},"fn_name":null},{"line":13,"address":[6501844,6500468,6500430],"length":1,"stats":{"Line":13},"fn_name":null},{"line":14,"address":[6502596,6502558,6503972],"length":1,"stats":{"Line":13},"fn_name":null},{"line":17,"address":[6506100,6504686,6504724],"length":1,"stats":{"Line":13},"fn_name":null},{"line":18,"address":[6508172,6506814,6506852],"length":1,"stats":{"Line":13},"fn_name":null},{"line":19,"address":[6510292,6508878,6508916],"length":1,"stats":{"Line":13},"fn_name":null},{"line":20,"address":[6512420,6511006,6511044],"length":1,"stats":{"Line":13},"fn_name":null},{"line":21,"address":[6514492,6513134,6513172],"length":1,"stats":{"Line":13},"fn_name":null},{"line":22,"address":[6515198,6515236,6516612],"length":1,"stats":{"Line":13},"fn_name":null},{"line":23,"address":[6518740,6517326,6517364],"length":1,"stats":{"Line":13},"fn_name":null},{"line":24,"address":[6519454,6519492,6520812],"length":1,"stats":{"Line":13},"fn_name":null},{"line":25,"address":[6522932,6521518,6521556],"length":1,"stats":{"Line":13},"fn_name":null},{"line":28,"address":[6523646,6523684,6525004],"length":1,"stats":{"Line":13},"fn_name":null},{"line":29,"address":[6525710,6525748,6527124],"length":1,"stats":{"Line":13},"fn_name":null},{"line":30,"address":[6527838,6527876,6529252],"length":1,"stats":{"Line":13},"fn_name":null},{"line":31,"address":[6529966,6531324,6530004],"length":1,"stats":{"Line":13},"fn_name":null},{"line":37,"address":[6532030,6533444,6532068],"length":1,"stats":{"Line":13},"fn_name":null},{"line":42,"address":[6534196],"length":1,"stats":{"Line":8},"fn_name":null},{"line":48,"address":[6536324],"length":1,"stats":{"Line":8},"fn_name":null},{"line":50,"address":[6538452,6539828,6538414],"length":1,"stats":{"Line":13},"fn_name":null},{"line":55,"address":[6540580],"length":1,"stats":{"Line":8},"fn_name":null},{"line":61,"address":[6542708],"length":1,"stats":{"Line":8},"fn_name":null},{"line":63,"address":[6544836,6544798,6546212],"length":1,"stats":{"Line":13},"fn_name":null},{"line":68,"address":[6546964],"length":1,"stats":{"Line":8},"fn_name":null},{"line":74,"address":[6549092],"length":1,"stats":{"Line":8},"fn_name":null},{"line":76,"address":[6551182,6552596,6551220],"length":1,"stats":{"Line":13},"fn_name":null},{"line":81,"address":[6553348],"length":1,"stats":{"Line":8},"fn_name":null},{"line":83,"address":[6555438,6556852,6555476],"length":1,"stats":{"Line":13},"fn_name":null},{"line":84,"address":[6558980,6557566,6557604],"length":1,"stats":{"Line":13},"fn_name":null},{"line":89,"address":[6559732],"length":1,"stats":{"Line":8},"fn_name":null},{"line":95,"address":[6561860],"length":1,"stats":{"Line":8},"fn_name":null},{"line":97,"address":[6563988,6565364,6563950],"length":1,"stats":{"Line":13},"fn_name":null},{"line":98,"address":[6566116,6567492,6566078],"length":1,"stats":{"Line":13},"fn_name":null},{"line":103,"address":[6568244],"length":1,"stats":{"Line":8},"fn_name":null},{"line":109,"address":[6570372],"length":1,"stats":{"Line":8},"fn_name":null},{"line":115,"address":[6572500],"length":1,"stats":{"Line":8},"fn_name":null},{"line":117,"address":[6576004,6574628,6574590],"length":1,"stats":{"Line":13},"fn_name":null},{"line":122,"address":[6576756],"length":1,"stats":{"Line":8},"fn_name":null},{"line":124,"address":[6578846,6580260,6578884],"length":1,"stats":{"Line":13},"fn_name":null},{"line":125,"address":[6582388,6581012,6580974],"length":1,"stats":{"Line":13},"fn_name":null},{"line":126,"address":[6583140,6583102,6584516],"length":1,"stats":{"Line":13},"fn_name":null},{"line":131,"address":[6585268],"length":1,"stats":{"Line":8},"fn_name":null},{"line":133,"address":[6587358,6587396,6588772],"length":1,"stats":{"Line":13},"fn_name":null},{"line":138,"address":[6589524],"length":1,"stats":{"Line":8},"fn_name":null},{"line":144,"address":[6591652],"length":1,"stats":{"Line":8},"fn_name":null},{"line":146,"address":[6593780,6595156,6593742],"length":1,"stats":{"Line":13},"fn_name":null},{"line":147,"address":[6595908,6595870,6597284],"length":1,"stats":{"Line":13},"fn_name":null},{"line":152,"address":[6598036],"length":1,"stats":{"Line":8},"fn_name":null},{"line":158,"address":[6600164],"length":1,"stats":{"Line":8},"fn_name":null},{"line":160,"address":[6603668,6602254,6602292],"length":1,"stats":{"Line":13},"fn_name":null},{"line":165,"address":[6604420],"length":1,"stats":{"Line":8},"fn_name":null},{"line":171,"address":[6606548],"length":1,"stats":{"Line":8},"fn_name":null},{"line":177,"address":[6608676],"length":1,"stats":{"Line":8},"fn_name":null},{"line":181,"address":[6610766,6612180,6610804],"length":1,"stats":{"Line":13},"fn_name":null},{"line":182,"address":[6612894,6614308,6612932],"length":1,"stats":{"Line":13},"fn_name":null},{"line":187,"address":[6615060],"length":1,"stats":{"Line":8},"fn_name":null},{"line":193,"address":[6617188],"length":1,"stats":{"Line":8},"fn_name":null},{"line":201,"address":[6619316],"length":1,"stats":{"Line":8},"fn_name":null},{"line":207,"address":[6621444],"length":1,"stats":{"Line":8},"fn_name":null},{"line":209,"address":[6623572,6624948,6623534],"length":1,"stats":{"Line":13},"fn_name":null},{"line":214,"address":[6625700],"length":1,"stats":{"Line":8},"fn_name":null},{"line":216,"address":[6627828,6629204,6627790],"length":1,"stats":{"Line":13},"fn_name":null},{"line":217,"address":[6631332,6629918,6629956],"length":1,"stats":{"Line":13},"fn_name":null},{"line":220,"address":[6632046,6632084,6633460],"length":1,"stats":{"Line":13},"fn_name":null},{"line":221,"address":[6635588,6634174,6634212],"length":1,"stats":{"Line":13},"fn_name":null},{"line":222,"address":[6636340,6636302,6637716],"length":1,"stats":{"Line":13},"fn_name":null},{"line":223,"address":[6639844,6638430,6638468],"length":1,"stats":{"Line":13},"fn_name":null},{"line":224,"address":[6641972,6640558,6640596],"length":1,"stats":{"Line":13},"fn_name":null},{"line":227,"address":[6644100,6642686,6642724],"length":1,"stats":{"Line":13},"fn_name":null},{"line":228,"address":[6644814,6646228,6644852],"length":1,"stats":{"Line":13},"fn_name":null},{"line":229,"address":[6648356,6646980,6646942],"length":1,"stats":{"Line":13},"fn_name":null},{"line":230,"address":[6649070,6650484,6649108],"length":1,"stats":{"Line":13},"fn_name":null},{"line":231,"address":[6651236,6652612,6651198],"length":1,"stats":{"Line":13},"fn_name":null}],"covered":84,"coverable":84},{"path":["/","usr","src","regex","tests","word_boundary.rs"],"content":"// Many of these are cribbed from RE2's test suite.\n\nmatiter!(wb1, r\"\\b\", \"\");\nmatiter!(wb2, r\"\\b\", \"a\", (0, 0), (1, 1));\nmatiter!(wb3, r\"\\b\", \"ab\", (0, 0), (2, 2));\nmatiter!(wb4, r\"^\\b\", \"ab\", (0, 0));\nmatiter!(wb5, r\"\\b$\", \"ab\", (2, 2));\nmatiter!(wb6, r\"^\\b$\", \"ab\");\nmatiter!(wb7, r\"\\bbar\\b\", \"nobar bar foo bar\", (6, 9), (14, 17));\nmatiter!(wb8, r\"a\\b\", \"faoa x\", (3, 4));\nmatiter!(wb9, r\"\\bbar\", \"bar x\", (0, 3));\nmatiter!(wb10, r\"\\bbar\", \"foo\\nbar x\", (4, 7));\nmatiter!(wb11, r\"bar\\b\", \"foobar\", (3, 6));\nmatiter!(wb12, r\"bar\\b\", \"foobar\\nxxx\", (3, 6));\nmatiter!(wb13, r\"(foo|bar|[A-Z])\\b\", \"foo\", (0, 3));\nmatiter!(wb14, r\"(foo|bar|[A-Z])\\b\", \"foo\\n\", (0, 3));\nmatiter!(wb15, r\"\\b(foo|bar|[A-Z])\", \"foo\", (0, 3));\nmatiter!(wb16, r\"\\b(foo|bar|[A-Z])\\b\", \"X\", (0, 1));\nmatiter!(wb17, r\"\\b(foo|bar|[A-Z])\\b\", \"XY\");\nmatiter!(wb18, r\"\\b(foo|bar|[A-Z])\\b\", \"bar\", (0, 3));\nmatiter!(wb19, r\"\\b(foo|bar|[A-Z])\\b\", \"foo\", (0, 3));\nmatiter!(wb20, r\"\\b(foo|bar|[A-Z])\\b\", \"foo\\n\", (0, 3));\nmatiter!(wb21, r\"\\b(foo|bar|[A-Z])\\b\", \"ffoo bbar N x\", (10, 11));\nmatiter!(wb22, r\"\\b(fo|foo)\\b\", \"fo\", (0, 2));\nmatiter!(wb23, r\"\\b(fo|foo)\\b\", \"foo\", (0, 3));\nmatiter!(wb24, r\"\\b\\b\", \"\");\nmatiter!(wb25, r\"\\b\\b\", \"a\", (0, 0), (1, 1));\nmatiter!(wb26, r\"\\b$\", \"\");\nmatiter!(wb27, r\"\\b$\", \"x\", (1, 1));\nmatiter!(wb28, r\"\\b$\", \"y x\", (3, 3));\nmatiter!(wb29, r\"\\b.$\", \"x\", (0, 1));\nmatiter!(wb30, r\"^\\b(fo|foo)\\b\", \"fo\", (0, 2));\nmatiter!(wb31, r\"^\\b(fo|foo)\\b\", \"foo\", (0, 3));\nmatiter!(wb32, r\"^\\b$\", \"\");\nmatiter!(wb33, r\"^\\b$\", \"x\");\nmatiter!(wb34, r\"^\\b.$\", \"x\", (0, 1));\nmatiter!(wb35, r\"^\\b.\\b$\", \"x\", (0, 1));\nmatiter!(wb36, r\"^^^^^\\b$$$$$\", \"\");\nmatiter!(wb37, r\"^^^^^\\b.$$$$$\", \"x\", (0, 1));\nmatiter!(wb38, r\"^^^^^\\b$$$$$\", \"x\");\nmatiter!(wb39, r\"^^^^^\\b\\b\\b.\\b\\b\\b$$$$$\", \"x\", (0, 1));\nmatiter!(wb40, r\"\\b.+\\b\", \"$$abc$$\", (2, 5));\nmatiter!(wb41, r\"\\b\", \"a b c\", (0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5));\n\nmatiter!(nb1, r\"\\Bfoo\\B\", \"n foo xfoox that\", (7, 10));\nmatiter!(nb2, r\"a\\B\", \"faoa x\", (1, 2));\nmatiter!(nb3, r\"\\Bbar\", \"bar x\");\nmatiter!(nb4, r\"\\Bbar\", \"foo\\nbar x\");\nmatiter!(nb5, r\"bar\\B\", \"foobar\");\nmatiter!(nb6, r\"bar\\B\", \"foobar\\nxxx\");\nmatiter!(nb7, r\"(foo|bar|[A-Z])\\B\", \"foox\", (0, 3));\nmatiter!(nb8, r\"(foo|bar|[A-Z])\\B\", \"foo\\n\");\nmatiter!(nb9, r\"\\B\", \"\", (0, 0));\nmatiter!(nb10, r\"\\B\", \"x\");\nmatiter!(nb11, r\"\\B(foo|bar|[A-Z])\", \"foo\");\nmatiter!(nb12, r\"\\B(foo|bar|[A-Z])\\B\", \"xXy\", (1, 2));\nmatiter!(nb13, r\"\\B(foo|bar|[A-Z])\\B\", \"XY\");\nmatiter!(nb14, r\"\\B(foo|bar|[A-Z])\\B\", \"XYZ\", (1, 2));\nmatiter!(nb15, r\"\\B(foo|bar|[A-Z])\\B\", \"abara\", (1, 4));\nmatiter!(nb16, r\"\\B(foo|bar|[A-Z])\\B\", \"xfoo_\", (1, 4));\nmatiter!(nb17, r\"\\B(foo|bar|[A-Z])\\B\", \"xfoo\\n\");\nmatiter!(nb18, r\"\\B(foo|bar|[A-Z])\\B\", \"foo bar vNX\", (9, 10));\nmatiter!(nb19, r\"\\B(fo|foo)\\B\", \"xfoo\", (1, 3));\nmatiter!(nb20, r\"\\B(foo|fo)\\B\", \"xfooo\", (1, 4));\nmatiter!(nb21, r\"\\B\\B\", \"\", (0, 0));\nmatiter!(nb22, r\"\\B\\B\", \"x\");\nmatiter!(nb23, r\"\\B$\", \"\", (0, 0));\nmatiter!(nb24, r\"\\B$\", \"x\");\nmatiter!(nb25, r\"\\B$\", \"y x\");\nmatiter!(nb26, r\"\\B.$\", \"x\");\nmatiter!(nb27, r\"^\\B(fo|foo)\\B\", \"fo\");\nmatiter!(nb28, r\"^\\B(fo|foo)\\B\", \"foo\");\nmatiter!(nb29, r\"^\\B\", \"\", (0, 0));\nmatiter!(nb30, r\"^\\B\", \"x\");\nmatiter!(nb31, r\"^\\B\\B\", \"\", (0, 0));\nmatiter!(nb32, r\"^\\B\\B\", \"x\");\nmatiter!(nb33, r\"^\\B$\", \"\", (0, 0));\nmatiter!(nb34, r\"^\\B$\", \"x\");\nmatiter!(nb35, r\"^\\B.$\", \"x\");\nmatiter!(nb36, r\"^\\B.\\B$\", \"x\");\nmatiter!(nb37, r\"^^^^^\\B$$$$$\", \"\", (0, 0));\nmatiter!(nb38, r\"^^^^^\\B.$$$$$\", \"x\");\nmatiter!(nb39, r\"^^^^^\\B$$$$$\", \"x\");\n\n// These work for both Unicode and ASCII because all matches are reported as\n// byte offsets, and « and » do not correspond to word boundaries at either\n// the character or byte level.\nmatiter!(unicode1, r\"\\bx\\b\", \"«x\", (2, 3));\nmatiter!(unicode2, r\"\\bx\\b\", \"x»\", (0, 1));\n","traces":[{"line":3,"address":[8290266,8291039,8289787],"length":1,"stats":{"Line":5},"fn_name":null},{"line":4,"address":[8291710,8293061,8292288,8291748],"length":1,"stats":{"Line":13},"fn_name":null},{"line":5,"address":[8295093,8293742,8294320,8293780],"length":1,"stats":{"Line":13},"fn_name":null},{"line":6,"address":[8297077,8295774,8296304,8295812],"length":1,"stats":{"Line":13},"fn_name":null},{"line":7,"address":[8297796,8297758,8299061,8298288],"length":1,"stats":{"Line":13},"fn_name":null},{"line":8,"address":[8300218,8300991,8299746],"length":1,"stats":{"Line":5},"fn_name":null},{"line":9,"address":[8303013,8301662,8302240,8301700],"length":1,"stats":{"Line":13},"fn_name":null},{"line":10,"address":[8303694,8304224,8303732,8304997],"length":1,"stats":{"Line":13},"fn_name":null},{"line":11,"address":[8305678,8306208,8305716,8306981],"length":1,"stats":{"Line":13},"fn_name":null},{"line":12,"address":[8308965,8307662,8307700,8308192],"length":1,"stats":{"Line":13},"fn_name":null},{"line":13,"address":[8309646,8310176,8309684,8310949],"length":1,"stats":{"Line":13},"fn_name":null},{"line":14,"address":[8311630,8311668,8312933,8312160],"length":1,"stats":{"Line":13},"fn_name":null},{"line":15,"address":[8313652,8314144,8314917,8313614],"length":1,"stats":{"Line":13},"fn_name":null},{"line":16,"address":[8316128,8316901,8315598,8315636],"length":1,"stats":{"Line":13},"fn_name":null},{"line":17,"address":[8318885,8318112,8317582,8317620],"length":1,"stats":{"Line":13},"fn_name":null},{"line":18,"address":[8319566,8320096,8320869,8319604],"length":1,"stats":{"Line":13},"fn_name":null},{"line":19,"address":[8322026,8322799,8321554],"length":1,"stats":{"Line":5},"fn_name":null},{"line":20,"address":[8324773,8324000,8323470,8323508],"length":1,"stats":{"Line":13},"fn_name":null},{"line":21,"address":[8325492,8325984,8325454,8326757],"length":1,"stats":{"Line":13},"fn_name":null},{"line":22,"address":[8327438,8327968,8327476,8328741],"length":1,"stats":{"Line":13},"fn_name":null},{"line":23,"address":[8329460,8329422,8330725,8329952],"length":1,"stats":{"Line":13},"fn_name":null},{"line":24,"address":[8331936,8331406,8332709,8331444],"length":1,"stats":{"Line":13},"fn_name":null},{"line":25,"address":[8334693,8333920,8333390,8333428],"length":1,"stats":{"Line":13},"fn_name":null},{"line":26,"address":[8335371,8336623,8335850],"length":1,"stats":{"Line":5},"fn_name":null},{"line":27,"address":[8337332,8337294,8337872,8338645],"length":1,"stats":{"Line":13},"fn_name":null},{"line":28,"address":[8340575,8339323,8339802],"length":1,"stats":{"Line":5},"fn_name":null},{"line":29,"address":[8341246,8342549,8341776,8341284],"length":1,"stats":{"Line":13},"fn_name":null},{"line":30,"address":[8343230,8343268,8344533,8343760],"length":1,"stats":{"Line":13},"fn_name":null},{"line":31,"address":[8345214,8346517,8345252,8345744],"length":1,"stats":{"Line":13},"fn_name":null},{"line":32,"address":[8347198,8347236,8348501,8347728],"length":1,"stats":{"Line":13},"fn_name":null},{"line":33,"address":[8350485,8349220,8349182,8349712],"length":1,"stats":{"Line":13},"fn_name":null},{"line":34,"address":[8351642,8352415,8351163],"length":1,"stats":{"Line":5},"fn_name":null},{"line":35,"address":[8354335,8353090,8353562],"length":1,"stats":{"Line":5},"fn_name":null},{"line":36,"address":[8355044,8355536,8356309,8355006],"length":1,"stats":{"Line":13},"fn_name":null},{"line":37,"address":[8356990,8357520,8358293,8357028],"length":1,"stats":{"Line":13},"fn_name":null},{"line":38,"address":[8358971,8359450,8360223],"length":1,"stats":{"Line":5},"fn_name":null},{"line":39,"address":[8360894,8360932,8361424,8362197],"length":1,"stats":{"Line":13},"fn_name":null},{"line":40,"address":[8364127,8362882,8363354],"length":1,"stats":{"Line":5},"fn_name":null},{"line":41,"address":[8365328,8364836,8364798,8366101],"length":1,"stats":{"Line":13},"fn_name":null},{"line":42,"address":[8366782,8368085,8367312,8366820],"length":1,"stats":{"Line":13},"fn_name":null},{"line":43,"address":[8368766,8369536,8368804,8370309],"length":1,"stats":{"Line":13},"fn_name":null},{"line":45,"address":[8371028,8371520,8370990,8372293],"length":1,"stats":{"Line":13},"fn_name":null},{"line":46,"address":[8373504,8374277,8373012,8372974],"length":1,"stats":{"Line":13},"fn_name":null},{"line":47,"address":[8376207,8374962,8375434],"length":1,"stats":{"Line":5},"fn_name":null},{"line":48,"address":[8378127,8377354,8376882],"length":1,"stats":{"Line":5},"fn_name":null},{"line":49,"address":[8378802,8379274,8380047],"length":1,"stats":{"Line":5},"fn_name":null},{"line":50,"address":[8380722,8381194,8381967],"length":1,"stats":{"Line":5},"fn_name":null},{"line":51,"address":[8383941,8382676,8382638,8383168],"length":1,"stats":{"Line":13},"fn_name":null},{"line":52,"address":[8384626,8385098,8385871],"length":1,"stats":{"Line":5},"fn_name":null},{"line":53,"address":[8387072,8386580,8386535,8387845],"length":1,"stats":{"Line":13},"fn_name":null},{"line":54,"address":[8388530,8389002,8389775],"length":1,"stats":{"Line":5},"fn_name":null},{"line":55,"address":[8390922,8391695,8390450],"length":1,"stats":{"Line":5},"fn_name":null},{"line":56,"address":[8392366,8392404,8393669,8392896],"length":1,"stats":{"Line":13},"fn_name":null},{"line":57,"address":[8394354,8395599,8394826],"length":1,"stats":{"Line":5},"fn_name":null},{"line":58,"address":[8396308,8396270,8396800,8397573],"length":1,"stats":{"Line":13},"fn_name":null},{"line":59,"address":[8398254,8398784,8399557,8398292],"length":1,"stats":{"Line":13},"fn_name":null},{"line":60,"address":[8401541,8400276,8400238,8400768],"length":1,"stats":{"Line":13},"fn_name":null},{"line":61,"address":[8402698,8403471,8402226],"length":1,"stats":{"Line":5},"fn_name":null},{"line":62,"address":[8404672,8404142,8404180,8405445],"length":1,"stats":{"Line":13},"fn_name":null},{"line":63,"address":[8407429,8406164,8406656,8406126],"length":1,"stats":{"Line":13},"fn_name":null},{"line":64,"address":[8408148,8408110,8409413,8408640],"length":1,"stats":{"Line":13},"fn_name":null},{"line":65,"address":[8410132,8410624,8410087,8411397],"length":1,"stats":{"Line":13},"fn_name":null},{"line":66,"address":[8412554,8412082,8413327],"length":1,"stats":{"Line":5},"fn_name":null},{"line":67,"address":[8415301,8413991,8414528,8414036],"length":1,"stats":{"Line":13},"fn_name":null},{"line":68,"address":[8417231,8416458,8415986],"length":1,"stats":{"Line":5},"fn_name":null},{"line":69,"address":[8419151,8417906,8418378],"length":1,"stats":{"Line":5},"fn_name":null},{"line":70,"address":[8420298,8421071,8419826],"length":1,"stats":{"Line":5},"fn_name":null},{"line":71,"address":[8421746,8422218,8422991],"length":1,"stats":{"Line":5},"fn_name":null},{"line":72,"address":[8424138,8424911,8423666],"length":1,"stats":{"Line":5},"fn_name":null},{"line":73,"address":[8425575,8425620,8426885,8426112],"length":1,"stats":{"Line":13},"fn_name":null},{"line":74,"address":[8428042,8427570,8428815],"length":1,"stats":{"Line":5},"fn_name":null},{"line":75,"address":[8429524,8429479,8430789,8430016],"length":1,"stats":{"Line":13},"fn_name":null},{"line":76,"address":[8431474,8431946,8432719],"length":1,"stats":{"Line":5},"fn_name":null},{"line":77,"address":[8433920,8433383,8434693,8433428],"length":1,"stats":{"Line":13},"fn_name":null},{"line":78,"address":[8435378,8435850,8436623],"length":1,"stats":{"Line":5},"fn_name":null},{"line":79,"address":[8437770,8438543,8437298],"length":1,"stats":{"Line":5},"fn_name":null},{"line":80,"address":[8440463,8439218,8439690],"length":1,"stats":{"Line":5},"fn_name":null},{"line":81,"address":[8441127,8442437,8441172,8441664],"length":1,"stats":{"Line":13},"fn_name":null},{"line":82,"address":[8444367,8443122,8443594],"length":1,"stats":{"Line":5},"fn_name":null},{"line":83,"address":[8445042,8445514,8446287],"length":1,"stats":{"Line":5},"fn_name":null},{"line":88,"address":[8446958,8448261,8446996,8447488],"length":1,"stats":{"Line":13},"fn_name":null},{"line":89,"address":[8449472,8450245,8448942,8448980],"length":1,"stats":{"Line":13},"fn_name":null}],"covered":82,"coverable":82},{"path":["/","usr","src","regex","tests","word_boundary_ascii.rs"],"content":"// ASCII word boundaries are completely oblivious to Unicode characters.\n// For Unicode word boundaries, the tests are precisely inverted.\nmatiter!(ascii1, r\"(?-u:\\b)x(?-u:\\b)\", \"áxβ\", (2, 3));\nmatiter!(ascii2, r\"(?-u:\\B)x(?-u:\\B)\", \"áxβ\");\nmatiter!(ascii3, r\"(?-u:\\B)\", \"0\\u{7EF5E}\", (2, 2), (3, 3), (4, 4), (5, 5));\n\n// We still get Unicode word boundaries by default in byte regexes.\nmatiter!(unicode1, r\"\\bx\\b\", \"áxβ\");\nmatiter!(unicode2, r\"\\Bx\\B\", \"áxβ\", (2, 3));\n","traces":[{"line":3,"address":[8759433,8760681,8759908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4,"address":[8761885,8762658],"length":1,"stats":{"Line":0},"fn_name":null},{"line":5,"address":[8763433,8764825,8764052],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[8766802,8766029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[8768052,8768825,8767577],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":3,"coverable":5},{"path":["/","usr","src","regex","tests","word_boundary_unicode.rs"],"content":"// Unicode word boundaries know about Unicode characters.\n// For ASCII word boundaries, the tests are precisely inverted.\nmatiter!(unicode1, r\"\\bx\\b\", \"áxβ\");\nmatiter!(unicode2, r\"\\Bx\\B\", \"áxβ\", (2, 3));\n\nmatiter!(ascii1, r\"(?-u:\\b)x(?-u:\\b)\", \"áxβ\", (2, 3));\n","traces":[{"line":3,"address":[6654575,6653802,6653330],"length":1,"stats":{"Line":5},"fn_name":null},{"line":4,"address":[6655246,6655284,6656549,6655776],"length":1,"stats":{"Line":12},"fn_name":null},{"line":6,"address":[6657268,6657760,6658533,6657230],"length":1,"stats":{"Line":12},"fn_name":null}],"covered":3,"coverable":3}]}