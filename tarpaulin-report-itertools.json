{"files":[{"path":["/","home","kms","itertools","benches","bench1.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, Criterion};\nuse itertools::Itertools;\nuse itertools::free::cloned;\nuse itertools::iproduct;\n\nuse std::iter::repeat;\nuse std::cmp;\nuse std::ops::{Add, Range};\n\nmod extra;\n\nuse crate::extra::ZipSlices;\n\nfn slice_iter(c: &mut Criterion) {\n    let xs: Vec<_> = repeat(1i32).take(20).collect();\n\n    c.bench_function(\"slice iter\", move |b| {\n        b.iter(|| for elt in xs.iter() {\n            black_box(elt);\n        })\n    });\n}\n\nfn slice_iter_rev(c: &mut Criterion) {\n    let xs: Vec<_> = repeat(1i32).take(20).collect();\n\n    c.bench_function(\"slice iter rev\", move |b| {\n        b.iter(|| for elt in xs.iter().rev() {\n            black_box(elt);\n        })\n    });\n}\n\nfn zip_default_zip(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zip default zip\", move |b| {\n        b.iter(|| {\n            for (&x, &y) in xs.iter().zip(&ys) {\n                black_box(x);\n                black_box(y);\n            }\n        })\n    });\n}\n\nfn zipdot_i32_default_zip(c: &mut Criterion) {\n    let xs = vec![2; 1024];\n    let ys = vec![2; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot i32 default zip\", move |b| {\n        b.iter(|| {\n            let mut s = 0;\n            for (&x, &y) in xs.iter().zip(&ys) {\n                s += x * y;\n            }\n            s\n        })\n    });\n}\n\nfn zipdot_f32_default_zip(c: &mut Criterion) {\n    let xs = vec![2f32; 1024];\n    let ys = vec![2f32; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot f32 default zip\", move |b| {\n        b.iter(|| {\n            let mut s = 0.;\n            for (&x, &y) in xs.iter().zip(&ys) {\n                s += x * y;\n            }\n            s\n        })\n    });\n}\n\nfn zip_default_zip3(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n    let zs = vec![0; 766];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n    let zs = black_box(zs);\n\n    c.bench_function(\"zip default zip3\", move |b| {\n        b.iter(|| {\n            for ((&x, &y), &z) in xs.iter().zip(&ys).zip(&zs) {\n                black_box(x);\n                black_box(y);\n                black_box(z);\n            }\n        })\n    });\n}\n\nfn zip_slices_ziptuple(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n\n    c.bench_function(\"zip slices ziptuple\", move |b| {\n        b.iter(|| {\n            let xs = black_box(&xs);\n            let ys = black_box(&ys);\n            for (&x, &y) in itertools::multizip((xs, ys)) {\n                black_box(x);\n                black_box(y);\n            }\n        })\n    });\n}\n\nfn zipslices(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipslices\", move |b| {\n        b.iter(|| {\n            for (&x, &y) in ZipSlices::new(&xs, &ys) {\n                black_box(x);\n                black_box(y);\n            }\n        })\n    });\n}\n\nfn zipslices_mut(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n    let xs = black_box(xs);\n    let mut ys = black_box(ys);\n\n    c.bench_function(\"zipslices mut\", move |b| {\n        b.iter(|| {\n            for (&x, &mut y) in ZipSlices::from_slices(&xs[..], &mut ys[..]) {\n                black_box(x);\n                black_box(y);\n            }\n        })\n    });\n}\n\nfn zipdot_i32_zipslices(c: &mut Criterion) {\n    let xs = vec![2; 1024];\n    let ys = vec![2; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot i32 zipslices\", move |b| {\n        b.iter(|| {\n            let mut s = 0i32;\n            for (&x, &y) in ZipSlices::new(&xs, &ys) {\n                s += x * y;\n            }\n            s\n        })\n    });\n}\n\nfn zipdot_f32_zipslices(c: &mut Criterion) {\n    let xs = vec![2f32; 1024];\n    let ys = vec![2f32; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot f32 zipslices\", move |b| {\n        b.iter(|| {\n            let mut s = 0.;\n            for (&x, &y) in ZipSlices::new(&xs, &ys) {\n                s += x * y;\n            }\n            s\n        })\n    });\n}\n\nfn zip_checked_counted_loop(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zip checked counted loop\", move |b| {\n        b.iter(|| {\n            // Must slice to equal lengths, and then bounds checks are eliminated!\n            let len = cmp::min(xs.len(), ys.len());\n            let xs = &xs[..len];\n            let ys = &ys[..len];\n\n            for i in 0..len {\n                let x = xs[i];\n                let y = ys[i];\n                black_box(x);\n                black_box(y);\n            }\n        })\n    });\n}\n\nfn zipdot_i32_checked_counted_loop(c: &mut Criterion) {\n    let xs = vec![2; 1024];\n    let ys = vec![2; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot i32 checked counted loop\", move |b| {\n        b.iter(|| {\n            // Must slice to equal lengths, and then bounds checks are eliminated!\n            let len = cmp::min(xs.len(), ys.len());\n            let xs = &xs[..len];\n            let ys = &ys[..len];\n\n            let mut s = 0i32;\n\n            for i in 0..len {\n                s += xs[i] * ys[i];\n            }\n            s\n        })\n    });\n}\n\nfn zipdot_f32_checked_counted_loop(c: &mut Criterion) {\n    let xs = vec![2f32; 1024];\n    let ys = vec![2f32; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot f32 checked counted loop\", move |b| {\n        b.iter(|| {\n            // Must slice to equal lengths, and then bounds checks are eliminated!\n            let len = cmp::min(xs.len(), ys.len());\n            let xs = &xs[..len];\n            let ys = &ys[..len];\n\n            let mut s = 0.;\n\n            for i in 0..len {\n                s += xs[i] * ys[i];\n            }\n            s\n        })\n    });\n}\n\nfn zipdot_f32_checked_counted_unrolled_loop(c: &mut Criterion) {\n    let xs = vec![2f32; 1024];\n    let ys = vec![2f32; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot f32 checked counted unrolled loop\", move |b| {\n        b.iter(|| {\n            // Must slice to equal lengths, and then bounds checks are eliminated!\n            let len = cmp::min(xs.len(), ys.len());\n            let mut xs = &xs[..len];\n            let mut ys = &ys[..len];\n\n            let mut s = 0.;\n            let (mut p0, mut p1, mut p2, mut p3, mut p4, mut p5, mut p6, mut p7) =\n                (0., 0., 0., 0., 0., 0., 0., 0.);\n\n            // how to unroll and have bounds checks eliminated (by cristicbz)\n            // split sum into eight parts to enable vectorization (by bluss)\n            while xs.len() >= 8 {\n                p0 += xs[0] * ys[0];\n                p1 += xs[1] * ys[1];\n                p2 += xs[2] * ys[2];\n                p3 += xs[3] * ys[3];\n                p4 += xs[4] * ys[4];\n                p5 += xs[5] * ys[5];\n                p6 += xs[6] * ys[6];\n                p7 += xs[7] * ys[7];\n\n                xs = &xs[8..];\n                ys = &ys[8..];\n            }\n            s += p0 + p4;\n            s += p1 + p5;\n            s += p2 + p6;\n            s += p3 + p7;\n\n            for i in 0..xs.len() {\n                s += xs[i] * ys[i];\n            }\n            s\n        })\n    });\n}\n\nfn zip_unchecked_counted_loop(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zip unchecked counted loop\", move |b| {\n        b.iter(|| {\n            let len = cmp::min(xs.len(), ys.len());\n            for i in 0..len {\n                unsafe {\n                let x = *xs.get_unchecked(i);\n                let y = *ys.get_unchecked(i);\n                black_box(x);\n                black_box(y);\n                }\n            }\n        })\n    });\n}\n\nfn zipdot_i32_unchecked_counted_loop(c: &mut Criterion) {\n    let xs = vec![2; 1024];\n    let ys = vec![2; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot i32 unchecked counted loop\", move |b| {\n        b.iter(|| {\n            let len = cmp::min(xs.len(), ys.len());\n            let mut s = 0i32;\n            for i in 0..len {\n                unsafe {\n                let x = *xs.get_unchecked(i);\n                let y = *ys.get_unchecked(i);\n                s += x * y;\n                }\n            }\n            s\n        })\n    });\n}\n\nfn zipdot_f32_unchecked_counted_loop(c: &mut Criterion) {\n    let xs = vec![2.; 1024];\n    let ys = vec![2.; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot f32 unchecked counted loop\", move |b| {\n        b.iter(|| {\n            let len = cmp::min(xs.len(), ys.len());\n            let mut s = 0f32;\n            for i in 0..len {\n                unsafe {\n                let x = *xs.get_unchecked(i);\n                let y = *ys.get_unchecked(i);\n                s += x * y;\n                }\n            }\n            s\n        })\n    });\n}\n\nfn zip_unchecked_counted_loop3(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n    let zs = vec![0; 766];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n    let zs = black_box(zs);\n\n    c.bench_function(\"zip unchecked counted loop3\", move |b| {\n        b.iter(|| {\n            let len = cmp::min(xs.len(), cmp::min(ys.len(), zs.len()));\n            for i in 0..len {\n                unsafe {\n                let x = *xs.get_unchecked(i);\n                let y = *ys.get_unchecked(i);\n                let z = *zs.get_unchecked(i);\n                black_box(x);\n                black_box(y);\n                black_box(z);\n                }\n            }\n        })\n    });\n}\n\nfn group_by_lazy_1(c: &mut Criterion) {\n    let mut data = vec![0; 1024];\n    for (index, elt) in data.iter_mut().enumerate() {\n        *elt = index / 10;\n    }\n\n    let data = black_box(data);\n\n    c.bench_function(\"group by lazy 1\", move |b| {\n        b.iter(|| {\n            for (_key, group) in &data.iter().group_by(|elt| **elt) {\n                for elt in group {\n                    black_box(elt);\n                }\n            }\n        })\n    });\n}\n\nfn group_by_lazy_2(c: &mut Criterion) {\n    let mut data = vec![0; 1024];\n    for (index, elt) in data.iter_mut().enumerate() {\n        *elt = index / 2;\n    }\n\n    let data = black_box(data);\n\n    c.bench_function(\"group by lazy 2\", move |b| {\n        b.iter(|| {\n            for (_key, group) in &data.iter().group_by(|elt| **elt) {\n                for elt in group {\n                    black_box(elt);\n                }\n            }\n        })\n    });\n}\n\nfn slice_chunks(c: &mut Criterion) {\n    let data = vec![0; 1024];\n\n    let data = black_box(data);\n    let sz = black_box(10);\n\n    c.bench_function(\"slice chunks\", move |b| {\n        b.iter(|| {\n            for group in data.chunks(sz) {\n                for elt in group {\n                    black_box(elt);\n                }\n            }\n        })\n    });\n}\n\nfn chunks_lazy_1(c: &mut Criterion) {\n    let data = vec![0; 1024];\n\n    let data = black_box(data);\n    let sz = black_box(10);\n\n    c.bench_function(\"chunks lazy 1\", move |b| {\n        b.iter(|| {\n            for group in &data.iter().chunks(sz) {\n                for elt in group {\n                    black_box(elt);\n                }\n            }\n        })\n    });\n}\n\nfn equal(c: &mut Criterion) {\n    let data = vec![7; 1024];\n    let l = data.len();\n    let alpha = black_box(&data[1..]);\n    let beta = black_box(&data[..l - 1]);\n\n    c.bench_function(\"equal\", move |b| {\n        b.iter(|| {\n            itertools::equal(alpha, beta)\n        })\n    });\n}\n\nfn merge_default(c: &mut Criterion) {\n    let mut data1 = vec![0; 1024];\n    let mut data2 = vec![0; 800];\n    let mut x = 0;\n    for (_, elt) in data1.iter_mut().enumerate() {\n        *elt = x;\n        x += 1;\n    }\n\n    let mut y = 0;\n    for (i, elt) in data2.iter_mut().enumerate() {\n        *elt += y;\n        if i % 3 == 0 {\n            y += 3;\n        } else {\n            y += 0;\n        }\n    }\n    let data1 = black_box(data1);\n    let data2 = black_box(data2);\n\n    c.bench_function(\"merge default\", move |b| {\n        b.iter(|| {\n            data1.iter().merge(&data2).count()\n        })\n    });\n}\n\nfn merge_by_cmp(c: &mut Criterion) {\n    let mut data1 = vec![0; 1024];\n    let mut data2 = vec![0; 800];\n    let mut x = 0;\n    for (_, elt) in data1.iter_mut().enumerate() {\n        *elt = x;\n        x += 1;\n    }\n\n    let mut y = 0;\n    for (i, elt) in data2.iter_mut().enumerate() {\n        *elt += y;\n        if i % 3 == 0 {\n            y += 3;\n        } else {\n            y += 0;\n        }\n    }\n    let data1 = black_box(data1);\n    let data2 = black_box(data2);\n\n    c.bench_function(\"merge by cmp\", move |b| {\n        b.iter(|| {\n            data1.iter().merge_by(&data2, PartialOrd::le).count()\n        })\n    });\n}\n\nfn merge_by_lt(c: &mut Criterion) {\n    let mut data1 = vec![0; 1024];\n    let mut data2 = vec![0; 800];\n    let mut x = 0;\n    for (_, elt) in data1.iter_mut().enumerate() {\n        *elt = x;\n        x += 1;\n    }\n\n    let mut y = 0;\n    for (i, elt) in data2.iter_mut().enumerate() {\n        *elt += y;\n        if i % 3 == 0 {\n            y += 3;\n        } else {\n            y += 0;\n        }\n    }\n    let data1 = black_box(data1);\n    let data2 = black_box(data2);\n\n    c.bench_function(\"merge by lt\", move |b| {\n        b.iter(|| {\n            data1.iter().merge_by(&data2, |a, b| a <= b).count()\n        })\n    });\n}\n\nfn kmerge_default(c: &mut Criterion) {\n    let mut data1 = vec![0; 1024];\n    let mut data2 = vec![0; 800];\n    let mut x = 0;\n    for (_, elt) in data1.iter_mut().enumerate() {\n        *elt = x;\n        x += 1;\n    }\n\n    let mut y = 0;\n    for (i, elt) in data2.iter_mut().enumerate() {\n        *elt += y;\n        if i % 3 == 0 {\n            y += 3;\n        } else {\n            y += 0;\n        }\n    }\n    let data1 = black_box(data1);\n    let data2 = black_box(data2);\n    let its = &[data1.iter(), data2.iter()];\n\n    c.bench_function(\"kmerge default\", move |b| {\n        b.iter(|| {\n            its.iter().cloned().kmerge().count()\n        })\n    });\n}\n\nfn kmerge_tenway(c: &mut Criterion) {\n    let mut data = vec![0; 10240];\n\n    let mut state = 1729u16;\n    fn rng(state: &mut u16) -> u16 {\n        let new = state.wrapping_mul(31421) + 6927;\n        *state = new;\n        new\n    }\n\n    for elt in &mut data {\n        *elt = rng(&mut state);\n    }\n\n    let mut chunks = Vec::new();\n    let mut rest = &mut data[..];\n    while rest.len() > 0 {\n        let chunk_len = 1 + rng(&mut state) % 512;\n        let chunk_len = cmp::min(rest.len(), chunk_len as usize);\n        let (fst, tail) = {rest}.split_at_mut(chunk_len);\n        fst.sort();\n        chunks.push(fst.iter().cloned());\n        rest = tail;\n    }\n\n    // println!(\"Chunk lengths: {}\", chunks.iter().format_with(\", \", |elt, f| f(&elt.len())));\n\n    c.bench_function(\"kmerge tenway\", move |b| {\n        b.iter(|| {\n            chunks.iter().cloned().kmerge().count()\n        })\n    });\n}\n\nfn fast_integer_sum<I>(iter: I) -> I::Item\n    where I: IntoIterator,\n          I::Item: Default + Add<Output=I::Item>\n{\n    iter.into_iter().fold(<_>::default(), |x, y| x + y)\n}\n\nfn step_vec_2(c: &mut Criterion) {\n    let v = vec![0; 1024];\n\n    c.bench_function(\"step vec 2\", move |b| {\n        b.iter(|| {\n            fast_integer_sum(cloned(v.iter().step_by(2)))\n        })\n    });\n}\n\nfn step_vec_10(c: &mut Criterion) {\n    let v = vec![0; 1024];\n\n    c.bench_function(\"step vec 10\", move |b| {\n        b.iter(|| {\n            fast_integer_sum(cloned(v.iter().step_by(10)))\n        })\n    });\n}\n\nfn step_range_2(c: &mut Criterion) {\n    let v = black_box(0..1024);\n\n    c.bench_function(\"step range 2\", move |b| {\n        b.iter(|| {\n            fast_integer_sum(v.clone().step_by(2))\n        })\n    });\n}\n\nfn step_range_10(c: &mut Criterion) {\n    let v = black_box(0..1024);\n\n    c.bench_function(\"step range 10\", move |b| {\n        b.iter(|| {\n            fast_integer_sum(v.clone().step_by(10))\n        })\n    });\n}\n\nfn cartesian_product_iterator(c: &mut Criterion) {\n    let xs = vec![0; 16];\n\n    c.bench_function(\"cartesian product iterator\", move |b| {\n        b.iter(|| {\n            let mut sum = 0;\n            for (&x, &y, &z) in iproduct!(&xs, &xs, &xs) {\n                sum += x;\n                sum += y;\n                sum += z;\n            }\n            sum\n        })\n    });\n}\n\nfn cartesian_product_fold(c: &mut Criterion) {\n    let xs = vec![0; 16];\n\n    c.bench_function(\"cartesian product fold\", move |b| {\n        b.iter(|| {\n            let mut sum = 0;\n            iproduct!(&xs, &xs, &xs).fold((), |(), (&x, &y, &z)| {\n                sum += x;\n                sum += y;\n                sum += z;\n            });\n            sum\n        })\n    });\n}\n\nfn multi_cartesian_product_iterator(c: &mut Criterion) {\n    let xs = [vec![0; 16], vec![0; 16], vec![0; 16]];\n\n    c.bench_function(\"multi cartesian product iterator\", move |b| {\n        b.iter(|| {\n            let mut sum = 0;\n            for x in xs.iter().multi_cartesian_product() {\n                sum += x[0];\n                sum += x[1];\n                sum += x[2];\n            }\n            sum\n        })\n    });\n}\n\nfn multi_cartesian_product_fold(c: &mut Criterion) {\n    let xs = [vec![0; 16], vec![0; 16], vec![0; 16]];\n\n    c.bench_function(\"multi cartesian product fold\", move |b| {\n        b.iter(|| {\n            let mut sum = 0;\n            xs.iter().multi_cartesian_product().fold((), |(), x| {\n                sum += x[0];\n                sum += x[1];\n                sum += x[2];\n            });\n            sum\n        })\n    });\n}\n\nfn cartesian_product_nested_for(c: &mut Criterion) {\n    let xs = vec![0; 16];\n\n    c.bench_function(\"cartesian product nested for\", move |b| {\n        b.iter(|| {\n            let mut sum = 0;\n            for &x in &xs {\n                for &y in &xs {\n                    for &z in &xs {\n                        sum += x;\n                        sum += y;\n                        sum += z;\n                    }\n                }\n            }\n            sum\n        })\n    });\n}\n\nfn all_equal(c: &mut Criterion) {\n    let mut xs = vec![0; 5_000_000];\n    xs.extend(vec![1; 5_000_000]);\n\n    c.bench_function(\"all equal\", move |b| {\n        b.iter(|| xs.iter().all_equal())\n    });\n}\n\nfn all_equal_for(c: &mut Criterion) {\n    let mut xs = vec![0; 5_000_000];\n    xs.extend(vec![1; 5_000_000]);\n\n    c.bench_function(\"all equal for\", move |b| {\n        b.iter(|| {\n            for &x in &xs {\n                if x != xs[0] {\n                    return false;\n                }\n            }\n            true\n        })\n    });\n}\n\nfn all_equal_default(c: &mut Criterion) {\n    let mut xs = vec![0; 5_000_000];\n    xs.extend(vec![1; 5_000_000]);\n\n    c.bench_function(\"all equal default\", move |b| {\n        b.iter(|| xs.iter().dedup().nth(1).is_none())\n    });\n}\n\nconst PERM_COUNT: usize = 6;\n\nfn permutations_iter(c: &mut Criterion) {\n    struct NewIterator(Range<usize>);\n\n    impl Iterator for NewIterator {\n        type Item = usize;\n\n        fn next(&mut self) -> Option<Self::Item> {\n            self.0.next()\n        }\n    }\n\n    c.bench_function(\"permutations iter\", move |b| {\n        b.iter(|| {\n            for _ in NewIterator(0..PERM_COUNT).permutations(PERM_COUNT) {\n\n            }\n        })\n    });\n}\n\nfn permutations_range(c: &mut Criterion) {\n    c.bench_function(\"permutations range\", move |b| {\n        b.iter(|| {\n            for _ in (0..PERM_COUNT).permutations(PERM_COUNT) {\n\n            }\n        })\n    });\n}\n\nfn permutations_slice(c: &mut Criterion) {\n    let v = (0..PERM_COUNT).collect_vec();\n\n    c.bench_function(\"permutations slice\", move |b| {\n        b.iter(|| {\n            for _ in v.as_slice().iter().permutations(PERM_COUNT) {\n\n            }\n        })\n    });\n}\n\ncriterion_group!(\n    benches,\n    slice_iter,\n    slice_iter_rev,\n    zip_default_zip,\n    zipdot_i32_default_zip,\n    zipdot_f32_default_zip,\n    zip_default_zip3,\n    zip_slices_ziptuple,\n    zipslices,\n    zipslices_mut,\n    zipdot_i32_zipslices,\n    zipdot_f32_zipslices,\n    zip_checked_counted_loop,\n    zipdot_i32_checked_counted_loop,\n    zipdot_f32_checked_counted_loop,\n    zipdot_f32_checked_counted_unrolled_loop,\n    zip_unchecked_counted_loop,\n    zipdot_i32_unchecked_counted_loop,\n    zipdot_f32_unchecked_counted_loop,\n    zip_unchecked_counted_loop3,\n    group_by_lazy_1,\n    group_by_lazy_2,\n    slice_chunks,\n    chunks_lazy_1,\n    equal,\n    merge_default,\n    merge_by_cmp,\n    merge_by_lt,\n    kmerge_default,\n    kmerge_tenway,\n    step_vec_2,\n    step_vec_10,\n    step_range_2,\n    step_range_10,\n    cartesian_product_iterator,\n    cartesian_product_fold,\n    multi_cartesian_product_iterator,\n    multi_cartesian_product_fold,\n    cartesian_product_nested_for,\n    all_equal,\n    all_equal_for,\n    all_equal_default,\n    permutations_iter,\n    permutations_range,\n    permutations_slice,\n);\ncriterion_main!(benches);\n","traces":[{"line":794,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":795,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","kms","itertools","benches","extra","zipslices.rs"],"content":"use std::cmp;\n\n// Note: There are different ways to implement ZipSlices.\n// This version performed the best in benchmarks.\n//\n// I also implemented a version with three pointes (tptr, tend, uptr),\n// that mimiced slice::Iter and only checked bounds by using tptr == tend,\n// but that was inferior to this solution.\n\n/// An iterator which iterates two slices simultaneously.\n///\n/// `ZipSlices` acts like a double-ended `.zip()` iterator.\n///\n/// It was intended to be more efficient than `.zip()`, and it was, then\n/// rustc changed how it optimizes so it can not promise improved performance\n/// at this time.\n///\n/// Note that elements past the end of the shortest of the two slices are ignored.\n///\n/// Iterator element type for `ZipSlices<T, U>` is `(T::Item, U::Item)`. For example,\n/// for a `ZipSlices<&'a [A], &'b mut [B]>`, the element type is `(&'a A, &'b mut B)`.\n#[derive(Clone)]\npub struct ZipSlices<T, U> {\n    t: T,\n    u: U,\n    len: usize,\n    index: usize,\n}\n\nimpl<'a, 'b, A, B> ZipSlices<&'a [A], &'b [B]> {\n    /// Create a new `ZipSlices` from slices `a` and `b`.\n    ///\n    /// Act like a double-ended `.zip()` iterator, but more efficiently.\n    ///\n    /// Note that elements past the end of the shortest of the two slices are ignored.\n    #[inline(always)]\n    pub fn new(a: &'a [A], b: &'b [B]) -> Self {\n        let minl = cmp::min(a.len(), b.len());\n        ZipSlices {\n            t: a,\n            u: b,\n            len: minl,\n            index: 0,\n        }\n    }\n}\n\nimpl<T, U> ZipSlices<T, U>\n    where T: Slice,\n          U: Slice\n{\n    /// Create a new `ZipSlices` from slices `a` and `b`.\n    ///\n    /// Act like a double-ended `.zip()` iterator, but more efficiently.\n    ///\n    /// Note that elements past the end of the shortest of the two slices are ignored.\n    #[inline(always)]\n    pub fn from_slices(a: T, b: U) -> Self {\n        let minl = cmp::min(a.len(), b.len());\n        ZipSlices {\n            t: a,\n            u: b,\n            len: minl,\n            index: 0,\n        }\n    }\n}\n\nimpl<T, U> Iterator for ZipSlices<T, U>\n    where T: Slice,\n          U: Slice\n{\n    type Item = (T::Item, U::Item);\n\n    #[inline(always)]\n    fn next(&mut self) -> Option<Self::Item> {\n        unsafe {\n            if self.index >= self.len {\n                None\n            } else {\n                let i = self.index;\n                self.index += 1;\n                Some((\n                    self.t.get_unchecked(i),\n                    self.u.get_unchecked(i)))\n            }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let len = self.len - self.index;\n        (len, Some(len))\n    }\n}\n\nimpl<T, U> DoubleEndedIterator for ZipSlices<T, U>\n    where T: Slice,\n          U: Slice\n{\n    #[inline(always)]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        unsafe {\n            if self.index >= self.len {\n                None\n            } else {\n                self.len -= 1;\n                let i = self.len;\n                Some((\n                    self.t.get_unchecked(i),\n                    self.u.get_unchecked(i)))\n            }\n        }\n    }\n}\n\nimpl<T, U> ExactSizeIterator for ZipSlices<T, U>\n    where T: Slice,\n          U: Slice\n{}\n\nunsafe impl<T, U> Slice for ZipSlices<T, U>\n    where T: Slice,\n          U: Slice\n{\n    type Item = (T::Item, U::Item);\n\n    fn len(&self) -> usize {\n        self.len - self.index\n    }\n\n    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n        (self.t.get_unchecked(i),\n         self.u.get_unchecked(i))\n    }\n}\n\n/// A helper trait to let `ZipSlices` accept both `&[T]` and `&mut [T]`.\n///\n/// Unsafe trait because:\n///\n/// - Implementors must guarantee that `get_unchecked` is valid for all indices `0..len()`.\npub unsafe trait Slice {\n    /// The type of a reference to the slice's elements\n    type Item;\n    #[doc(hidden)]\n    fn len(&self) -> usize;\n    #[doc(hidden)]\n    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item;\n}\n\nunsafe impl<'a, T> Slice for &'a [T] {\n    type Item = &'a T;\n    #[inline(always)]\n    fn len(&self) -> usize { (**self).len() }\n    #[inline(always)]\n    unsafe fn get_unchecked(&mut self, i: usize) -> &'a T {\n        debug_assert!(i < self.len());\n        (**self).get_unchecked(i)\n    }\n}\n\nunsafe impl<'a, T> Slice for &'a mut [T] {\n    type Item = &'a mut T;\n    #[inline(always)]\n    fn len(&self) -> usize { (**self).len() }\n    #[inline(always)]\n    unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut T {\n        debug_assert!(i < self.len());\n        // override the lifetime constraints of &mut &'a mut [T]\n        (*(*self as *mut [T])).get_unchecked_mut(i)\n    }\n}\n\n#[test]\nfn zipslices() {\n\n    let xs = [1, 2, 3, 4, 5, 6];\n    let ys = [1, 2, 3, 7];\n    ::itertools::assert_equal(ZipSlices::new(&xs, &ys), xs.iter().zip(&ys));\n\n    let xs = [1, 2, 3, 4, 5, 6];\n    let mut ys = [0; 6];\n    for (x, y) in ZipSlices::from_slices(&xs[..], &mut ys[..]) {\n        *y = *x;\n    }\n    ::itertools::assert_equal(&xs, &ys);\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":34},{"path":["/","home","kms","itertools","benches","fold_specialization.rs"],"content":"use criterion::{criterion_group, criterion_main, Criterion};\nuse itertools::Itertools;\n\nstruct Unspecialized<I>(I);\n\nimpl<I> Iterator for Unspecialized<I>\nwhere I: Iterator\n{\n    type Item = I::Item;\n\n    #[inline(always)]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.0.next()\n    }\n\n    #[inline(always)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.0.size_hint()\n    }\n}\n\nmod specialization {\n    use super::*;\n\n    pub mod intersperse {\n        use super::*;\n\n        pub fn external(c: &mut Criterion)\n        {\n            let arr = [1; 1024];\n\n            c.bench_function(\"external\", move |b| {\n                b.iter(|| {\n                    let mut sum = 0;\n                    for &x in arr.iter().intersperse(&0) {\n                        sum += x;\n                    }\n                    sum\n                })\n            });\n        }\n\n        pub fn internal_specialized(c: &mut Criterion)\n        {\n            let arr = [1; 1024];\n\n            c.bench_function(\"internal specialized\", move |b| {\n                b.iter(|| {\n                    arr.iter().intersperse(&0).fold(0, |acc, x| acc + x)\n                })\n            });\n        }\n\n        pub fn internal_unspecialized(c: &mut Criterion)\n        {\n            let arr = [1; 1024];\n\n            c.bench_function(\"internal unspecialized\", move |b| {\n                b.iter(|| {\n                    Unspecialized(arr.iter().intersperse(&0)).fold(0, |acc, x| acc + x)\n                })\n            });\n        }\n    }\n}\n\ncriterion_group!(\n    benches,\n    specialization::intersperse::external,\n    specialization::intersperse::internal_specialized,\n    specialization::intersperse::internal_unspecialized,\n);\ncriterion_main!(benches);\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","kms","itertools","benches","tree_fold1.rs"],"content":"use criterion::{criterion_group, criterion_main, Criterion};\nuse itertools::{Itertools, cloned};\n\ntrait IterEx : Iterator {\n    // Another efficient implementation against which to compare,\n    // but needs `std` so is less desirable.\n    fn tree_fold1_vec<F>(self, mut f: F) -> Option<Self::Item>\n        where F: FnMut(Self::Item, Self::Item) -> Self::Item,\n              Self: Sized,\n    {\n        let hint = self.size_hint().0;\n        let cap = std::mem::size_of::<usize>() * 8 - hint.leading_zeros() as usize;\n        let mut stack = Vec::with_capacity(cap);\n        self.enumerate().for_each(|(mut i, mut x)| {\n            while (i & 1) != 0 {\n                x = f(stack.pop().unwrap(), x);\n                i >>= 1;\n            }\n            stack.push(x);\n        });\n        stack.into_iter().fold1(f)\n    }\n}\nimpl<T:Iterator> IterEx for T {}\n\nmacro_rules! def_benchs {\n    ($N:expr,\n     $FUN:ident,\n     $BENCH_NAME:ident,\n     ) => (\n        mod $BENCH_NAME {\n            use super::*;\n\n            pub fn sum(c: &mut Criterion) {\n                let v: Vec<u32> = (0.. $N).collect();\n\n                c.bench_function(&(stringify!($BENCH_NAME).replace('_', \" \") + \" sum\"), move |b| {\n                    b.iter(|| {\n                        cloned(&v).$FUN(|x, y| x + y)\n                    })\n                });\n            }\n\n            pub fn complex_iter(c: &mut Criterion) {\n                let u = (3..).take($N / 2);\n                let v = (5..).take($N / 2);\n                let it = u.chain(v);\n\n                c.bench_function(&(stringify!($BENCH_NAME).replace('_', \" \") + \" complex iter\"), move |b| {\n                    b.iter(|| {\n                        it.clone().map(|x| x as f32).$FUN(f32::atan2)\n                    })\n                });\n            }\n\n            pub fn string_format(c: &mut Criterion) {\n                // This goes quadratic with linear `fold1`, so use a smaller\n                // size to not waste too much time in travis.  The allocations\n                // in here are so expensive anyway that it'll still take\n                // way longer per iteration than the other two benchmarks.\n                let v: Vec<u32> = (0.. ($N/4)).collect();\n\n                c.bench_function(&(stringify!($BENCH_NAME).replace('_', \" \") + \" string format\"), move |b| {\n                    b.iter(|| {\n                        cloned(&v).map(|x| x.to_string()).$FUN(|x, y| format!(\"{} + {}\", x, y))\n                    })\n                });\n            }\n        }\n\n        criterion_group!(\n            $BENCH_NAME,\n            $BENCH_NAME::sum,\n            $BENCH_NAME::complex_iter,\n            $BENCH_NAME::string_format,\n        );\n    )\n}\n\ndef_benchs!{\n    10_000,\n    fold1,\n    fold1_10k,\n}\n\ndef_benchs!{\n    10_000,\n    tree_fold1,\n    tree_fold1_stack_10k,\n}\n\ndef_benchs!{\n    10_000,\n    tree_fold1_vec,\n    tree_fold1_vec_10k,\n}\n\ndef_benchs!{\n    100,\n    fold1,\n    fold1_100,\n}\n\ndef_benchs!{\n    100,\n    tree_fold1,\n    tree_fold1_stack_100,\n}\n\ndef_benchs!{\n    100,\n    tree_fold1_vec,\n    tree_fold1_vec_100,\n}\n\ndef_benchs!{\n    8,\n    fold1,\n    fold1_08,\n}\n\ndef_benchs!{\n    8,\n    tree_fold1,\n    tree_fold1_stack_08,\n}\n\ndef_benchs!{\n    8,\n    tree_fold1_vec,\n    tree_fold1_vec_08,\n}\n\ncriterion_main!(\n    fold1_10k,\n    tree_fold1_stack_10k,\n    tree_fold1_vec_10k,\n    fold1_100,\n    tree_fold1_stack_100,\n    tree_fold1_vec_100,\n    fold1_08,\n    tree_fold1_stack_08,\n    tree_fold1_vec_08,\n);\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":9},{"path":["/","home","kms","itertools","src","adaptors","mod.rs"],"content":"//! Licensed under the Apache License, Version 2.0\n//! http://www.apache.org/licenses/LICENSE-2.0 or the MIT license\n//! http://opensource.org/licenses/MIT, at your\n//! option. This file may not be copied, modified, or distributed\n//! except according to those terms.\n\nmod multi_product;\n#[cfg(feature = \"use_std\")]\npub use self::multi_product::*;\n\nuse std::fmt;\nuse std::mem::replace;\nuse std::iter::{Fuse, Peekable, FromIterator, FusedIterator};\nuse std::marker::PhantomData;\nuse crate::size_hint;\n\n/// An iterator adaptor that alternates elements from two iterators until both\n/// run out.\n///\n/// This iterator is *fused*.\n///\n/// See [`.interleave()`](../trait.Itertools.html#method.interleave) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Interleave<I, J> {\n    a: Fuse<I>,\n    b: Fuse<J>,\n    flag: bool,\n}\n\n/// Create an iterator that interleaves elements in `i` and `j`.\n///\n/// `IntoIterator` enabled version of `i.interleave(j)`.\n///\n/// ```\n/// use itertools::interleave;\n///\n/// for elt in interleave(&[1, 2, 3], &[2, 3, 4]) {\n///     /* loop body */\n/// }\n/// ```\npub fn interleave<I, J>(i: I, j: J) -> Interleave<<I as IntoIterator>::IntoIter, <J as IntoIterator>::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator<Item = I::Item>\n{\n    Interleave {\n        a: i.into_iter().fuse(),\n        b: j.into_iter().fuse(),\n        flag: false,\n    }\n}\n\nimpl<I, J> Iterator for Interleave<I, J>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.flag = !self.flag;\n        if self.flag {\n            match self.a.next() {\n                None => self.b.next(),\n                r => r,\n            }\n        } else {\n            match self.b.next() {\n                None => self.a.next(),\n                r => r,\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add(self.a.size_hint(), self.b.size_hint())\n    }\n}\n\n/// An iterator adaptor that alternates elements from the two iterators until\n/// one of them runs out.\n///\n/// This iterator is *fused*.\n///\n/// See [`.interleave_shortest()`](../trait.Itertools.html#method.interleave_shortest)\n/// for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct InterleaveShortest<I, J>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    it0: I,\n    it1: J,\n    phase: bool, // false ==> it0, true ==> it1\n}\n\n/// Create a new `InterleaveShortest` iterator.\npub fn interleave_shortest<I, J>(a: I, b: J) -> InterleaveShortest<I, J>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    InterleaveShortest {\n        it0: a,\n        it1: b,\n        phase: false,\n    }\n}\n\nimpl<I, J> Iterator for InterleaveShortest<I, J>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    type Item = I::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.phase {\n            false => match self.it0.next() {\n                None => None,\n                e => {\n                    self.phase = true;\n                    e\n                }\n            },\n            true => match self.it1.next() {\n                None => None,\n                e => {\n                    self.phase = false;\n                    e\n                }\n            },\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (curr_hint, next_hint) = {\n            let it0_hint = self.it0.size_hint();\n            let it1_hint = self.it1.size_hint();\n            if self.phase {\n                (it1_hint, it0_hint)\n            } else {\n                (it0_hint, it1_hint)\n            }\n        };\n        let (curr_lower, curr_upper) = curr_hint;\n        let (next_lower, next_upper) = next_hint;\n        let (combined_lower, combined_upper) =\n            size_hint::mul_scalar(size_hint::min(curr_hint, next_hint), 2);\n        let lower =\n            if curr_lower > next_lower {\n                combined_lower + 1\n            } else {\n                combined_lower\n            };\n        let upper = {\n            let extra_elem = match (curr_upper, next_upper) {\n                (_, None) => false,\n                (None, Some(_)) => true,\n                (Some(curr_max), Some(next_max)) => curr_max > next_max,\n            };\n            if extra_elem {\n                combined_upper.and_then(|x| x.checked_add(1))\n            } else {\n                combined_upper\n            }\n        };\n        (lower, upper)\n    }\n}\n\n#[derive(Clone, Debug)]\n/// An iterator adaptor that allows putting back a single\n/// item to the front of the iterator.\n///\n/// Iterator element type is `I::Item`.\npub struct PutBack<I>\n    where I: Iterator\n{\n    top: Option<I::Item>,\n    iter: I,\n}\n\n/// Create an iterator where you can put back a single item\npub fn put_back<I>(iterable: I) -> PutBack<I::IntoIter>\n    where I: IntoIterator\n{\n    PutBack {\n        top: None,\n        iter: iterable.into_iter(),\n    }\n}\n\nimpl<I> PutBack<I>\n    where I: Iterator\n{\n    /// put back value `value` (builder method)\n    pub fn with_value(mut self, value: I::Item) -> Self {\n        self.put_back(value);\n        self\n    }\n\n    /// Split the `PutBack` into its parts.\n    #[inline]\n    pub fn into_parts(self) -> (Option<I::Item>, I) {\n        let PutBack{top, iter} = self;\n        (top, iter)\n    }\n\n    /// Put back a single value to the front of the iterator.\n    ///\n    /// If a value is already in the put back slot, it is overwritten.\n    #[inline]\n    pub fn put_back(&mut self, x: I::Item) {\n        self.top = Some(x)\n    }\n}\n\nimpl<I> Iterator for PutBack<I>\n    where I: Iterator\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.top {\n            None => self.iter.next(),\n            ref mut some => some.take(),\n        }\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // Not ExactSizeIterator because size may be larger than usize\n        size_hint::add_scalar(self.iter.size_hint(), self.top.is_some() as usize)\n    }\n\n    fn count(self) -> usize {\n        self.iter.count() + (self.top.is_some() as usize)\n    }\n\n    fn last(self) -> Option<Self::Item> {\n        self.iter.last().or(self.top)\n    }\n\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        match self.top {\n            None => self.iter.nth(n),\n            ref mut some => {\n                if n == 0 {\n                    some.take()\n                } else {\n                    *some = None;\n                    self.iter.nth(n - 1)\n                }\n            }\n        }\n    }\n\n    fn all<G>(&mut self, mut f: G) -> bool\n        where G: FnMut(Self::Item) -> bool\n    {\n        if let Some(elt) = self.top.take() {\n            if !f(elt) {\n                return false;\n            }\n        }\n        self.iter.all(f)\n    }\n\n    fn fold<Acc, G>(mut self, init: Acc, mut f: G) -> Acc\n        where G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        let mut accum = init;\n        if let Some(elt) = self.top.take() {\n            accum = f(accum, elt);\n        }\n        self.iter.fold(accum, f)\n    }\n}\n\n#[derive(Debug, Clone)]\n/// An iterator adaptor that iterates over the cartesian product of\n/// the element sets of two iterators `I` and `J`.\n///\n/// Iterator element type is `(I::Item, J::Item)`.\n///\n/// See [`.cartesian_product()`](../trait.Itertools.html#method.cartesian_product) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Product<I, J>\n    where I: Iterator\n{\n    a: I,\n    a_cur: Option<I::Item>,\n    b: J,\n    b_orig: J,\n}\n\n/// Create a new cartesian product iterator\n///\n/// Iterator element type is `(I::Item, J::Item)`.\npub fn cartesian_product<I, J>(mut i: I, j: J) -> Product<I, J>\n    where I: Iterator,\n          J: Clone + Iterator,\n          I::Item: Clone\n{\n    Product {\n        a_cur: i.next(),\n        a: i,\n        b: j.clone(),\n        b_orig: j,\n    }\n}\n\nimpl<I, J> Iterator for Product<I, J>\n    where I: Iterator,\n          J: Clone + Iterator,\n          I::Item: Clone\n{\n    type Item = (I::Item, J::Item);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let elt_b = match self.b.next() {\n            None => {\n                self.b = self.b_orig.clone();\n                match self.b.next() {\n                    None => return None,\n                    Some(x) => {\n                        self.a_cur = self.a.next();\n                        x\n                    }\n                }\n            }\n            Some(x) => x\n        };\n        match self.a_cur {\n            None => None,\n            Some(ref a) => {\n                Some((a.clone(), elt_b))\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let has_cur = self.a_cur.is_some() as usize;\n        // Not ExactSizeIterator because size may be larger than usize\n        let (b_min, b_max) = self.b.size_hint();\n\n        // Compute a * b_orig + b for both lower and upper bound\n        size_hint::add(\n            size_hint::mul(self.a.size_hint(), self.b_orig.size_hint()),\n            (b_min * has_cur, b_max.map(move |x| x * has_cur)))\n    }\n\n    fn fold<Acc, G>(mut self, mut accum: Acc, mut f: G) -> Acc\n        where G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        // use a split loop to handle the loose a_cur as well as avoiding to\n        // clone b_orig at the end.\n        if let Some(mut a) = self.a_cur.take() {\n            let mut b = self.b;\n            loop {\n                accum = b.fold(accum, |acc, elt| f(acc, (a.clone(), elt)));\n\n                // we can only continue iterating a if we had a first element;\n                if let Some(next_a) = self.a.next() {\n                    b = self.b_orig.clone();\n                    a = next_a;\n                } else {\n                    break;\n                }\n            }\n        }\n        accum\n    }\n}\n\n/// A “meta iterator adaptor”. Its closure receives a reference to the iterator\n/// and may pick off as many elements as it likes, to produce the next iterator element.\n///\n/// Iterator element type is *X*, if the return type of `F` is *Option\\<X\\>*.\n///\n/// See [`.batching()`](../trait.Itertools.html#method.batching) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Batching<I, F> {\n    f: F,\n    iter: I,\n}\n\nimpl<I, F> fmt::Debug for Batching<I, F> where I: fmt::Debug {\n    debug_fmt_fields!(Batching, iter);\n}\n\n/// Create a new Batching iterator.\npub fn batching<I, F>(iter: I, f: F) -> Batching<I, F> {\n    Batching { f, iter }\n}\n\nimpl<B, F, I> Iterator for Batching<I, F>\n    where I: Iterator,\n          F: FnMut(&mut I) -> Option<B>\n{\n    type Item = B;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        (self.f)(&mut self.iter)\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // No information about closue behavior\n        (0, None)\n    }\n}\n\n/// An iterator adaptor that steps a number elements in the base iterator\n/// for each iteration.\n///\n/// The iterator steps by yielding the next element from the base iterator,\n/// then skipping forward *n-1* elements.\n///\n/// See [`.step()`](../trait.Itertools.html#method.step) for more information.\n#[deprecated(note=\"Use std .step_by() instead\", since=\"0.8\")]\n#[allow(deprecated)]\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Step<I> {\n    iter: Fuse<I>,\n    skip: usize,\n}\n\n/// Create a `Step` iterator.\n///\n/// **Panics** if the step is 0.\n#[allow(deprecated)]\npub fn step<I>(iter: I, step: usize) -> Step<I>\n    where I: Iterator\n{\n    assert!(step != 0);\n    Step {\n        iter: iter.fuse(),\n        skip: step - 1,\n    }\n}\n\n#[allow(deprecated)]\nimpl<I> Iterator for Step<I>\n    where I: Iterator\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let elt = self.iter.next();\n        if self.skip > 0 {\n            self.iter.nth(self.skip - 1);\n        }\n        elt\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, high) = self.iter.size_hint();\n        let div = |x: usize| {\n            if x == 0 {\n                0\n            } else {\n                1 + (x - 1) / (self.skip + 1)\n            }\n        };\n        (div(low), high.map(div))\n    }\n}\n\n// known size\n#[allow(deprecated)]\nimpl<I> ExactSizeIterator for Step<I>\n    where I: ExactSizeIterator\n{}\n\npub trait MergePredicate<T> {\n    fn merge_pred(&mut self, a: &T, b: &T) -> bool;\n}\n\n#[derive(Clone)]\npub struct MergeLte;\n\nimpl<T: PartialOrd> MergePredicate<T> for MergeLte {\n    fn merge_pred(&mut self, a: &T, b: &T) -> bool {\n        a <= b\n    }\n}\n\n/// An iterator adaptor that merges the two base iterators in ascending order.\n/// If both base iterators are sorted (ascending), the result is sorted.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.merge()`](../trait.Itertools.html#method.merge_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub type Merge<I, J> = MergeBy<I, J, MergeLte>;\n\n/// Create an iterator that merges elements in `i` and `j`.\n///\n/// `IntoIterator` enabled version of `i.merge(j)`.\n///\n/// ```\n/// use itertools::merge;\n///\n/// for elt in merge(&[1, 2, 3], &[2, 3, 4]) {\n///     /* loop body */\n/// }\n/// ```\npub fn merge<I, J>(i: I, j: J) -> Merge<<I as IntoIterator>::IntoIter, <J as IntoIterator>::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator<Item = I::Item>,\n          I::Item: PartialOrd\n{\n    merge_by_new(i, j, MergeLte)\n}\n\n/// An iterator adaptor that merges the two base iterators in ascending order.\n/// If both base iterators are sorted (ascending), the result is sorted.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.merge_by()`](../trait.Itertools.html#method.merge_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MergeBy<I, J, F>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    a: Peekable<I>,\n    b: Peekable<J>,\n    fused: Option<bool>,\n    cmp: F,\n}\n\nimpl<I, J, F> fmt::Debug for MergeBy<I, J, F>\n    where I: Iterator + fmt::Debug, J: Iterator<Item = I::Item> + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(MergeBy, a, b);\n}\n\nimpl<T, F: FnMut(&T, &T)->bool> MergePredicate<T> for F {\n    fn merge_pred(&mut self, a: &T, b: &T) -> bool {\n        self(a, b)\n    }\n}\n\n/// Create a `MergeBy` iterator.\npub fn merge_by_new<I, J, F>(a: I, b: J, cmp: F) -> MergeBy<I::IntoIter, J::IntoIter, F>\n    where I: IntoIterator,\n          J: IntoIterator<Item = I::Item>,\n          F: MergePredicate<I::Item>,\n{\n    MergeBy {\n        a: a.into_iter().peekable(),\n        b: b.into_iter().peekable(),\n        fused: None,\n        cmp,\n    }\n}\n\nimpl<I, J, F> Clone for MergeBy<I, J, F>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>,\n          Peekable<I>: Clone,\n          Peekable<J>: Clone,\n          F: Clone\n{\n    clone_fields!(a, b, fused, cmp);\n}\n\nimpl<I, J, F> Iterator for MergeBy<I, J, F>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>,\n          F: MergePredicate<I::Item>\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let less_than = match self.fused {\n            Some(lt) => lt,\n            None => match (self.a.peek(), self.b.peek()) {\n                (Some(a), Some(b)) => self.cmp.merge_pred(a, b),\n                (Some(_), None) => {\n                    self.fused = Some(true);\n                    true\n                }\n                (None, Some(_)) => {\n                    self.fused = Some(false);\n                    false\n                }\n                (None, None) => return None,\n            }\n        };\n        if less_than {\n            self.a.next()\n        } else {\n            self.b.next()\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // Not ExactSizeIterator because size may be larger than usize\n        size_hint::add(self.a.size_hint(), self.b.size_hint())\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct CoalesceCore<I, T>\n    where I: Iterator\n{\n    iter: I,\n    last: Option<T>,\n}\n\nimpl<I, T> CoalesceCore<I, T>\n    where I: Iterator\n{\n    fn next_with<F>(&mut self, mut f: F) -> Option<T>\n        where F: FnMut(T, I::Item) -> Result<T, (T, T)>\n    {\n        // this fuses the iterator\n        let mut last = match self.last.take() {\n            None => return None,\n            Some(x) => x,\n        };\n        for next in &mut self.iter {\n            match f(last, next) {\n                Ok(joined) => last = joined,\n                Err((last_, next_)) => {\n                    self.last = Some(next_);\n                    return Some(last_);\n                }\n            }\n        }\n\n        Some(last)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, hi) = size_hint::add_scalar(self.iter.size_hint(),\n                                              self.last.is_some() as usize);\n        ((low > 0) as usize, hi)\n    }\n}\n\n/// An iterator adaptor that may join together adjacent elements.\n///\n/// See [`.coalesce()`](../trait.Itertools.html#method.coalesce) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Coalesce<I, F>\n    where I: Iterator\n{\n    iter: CoalesceCore<I, I::Item>,\n    f: F,\n}\n\nimpl<I: Clone, F: Clone> Clone for Coalesce<I, F>\n    where I: Iterator,\n          I::Item: Clone\n{\n    clone_fields!(iter, f);\n}\n\nimpl<I, F> fmt::Debug for Coalesce<I, F>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(Coalesce, iter);\n}\n\n/// Create a new `Coalesce`.\npub fn coalesce<I, F>(mut iter: I, f: F) -> Coalesce<I, F>\n    where I: Iterator\n{\n    Coalesce {\n        iter: CoalesceCore {\n            last: iter.next(),\n            iter,\n        },\n        f,\n    }\n}\n\nimpl<I, F> Iterator for Coalesce<I, F>\n    where I: Iterator,\n          F: FnMut(I::Item, I::Item) -> Result<I::Item, (I::Item, I::Item)>\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next_with(&mut self.f)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\n/// An iterator adaptor that removes repeated duplicates, determining equality using a comparison function.\n///\n/// See [`.dedup_by()`](../trait.Itertools.html#method.dedup_by) or [`.dedup()`](../trait.Itertools.html#method.dedup) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct DedupBy<I, Pred>\n    where I: Iterator\n{\n    iter: CoalesceCore<I, I::Item>,\n    dedup_pred: Pred,\n}\n\npub trait DedupPredicate<T> { // TODO replace by Fn(&T, &T)->bool once Rust supports it\n    fn dedup_pair(&mut self, a: &T, b: &T) -> bool;\n}\n\n#[derive(Clone)]\npub struct DedupEq;\n\nimpl<T: PartialEq> DedupPredicate<T> for DedupEq {\n    fn dedup_pair(&mut self, a: &T, b: &T) -> bool {\n        a == b\n    }\n}\n\nimpl<T, F: FnMut(&T, &T)->bool> DedupPredicate<T> for F {\n    fn dedup_pair(&mut self, a: &T, b: &T) -> bool {\n        self(a, b)\n    }\n}\n\n/// An iterator adaptor that removes repeated duplicates.\n///\n/// See [`.dedup()`](../trait.Itertools.html#method.dedup) for more information.\npub type Dedup<I>=DedupBy<I, DedupEq>;\n\nimpl<I: Clone, Pred: Clone> Clone for DedupBy<I, Pred>\n    where I: Iterator,\n          I::Item: Clone,\n{\n    clone_fields!(iter, dedup_pred);\n}\n\n/// Create a new `DedupBy`.\npub fn dedup_by<I, Pred>(mut iter: I, dedup_pred: Pred) -> DedupBy<I, Pred>\n    where I: Iterator,\n{\n    DedupBy {\n        iter: CoalesceCore {\n            last: iter.next(),\n            iter,\n        },\n        dedup_pred,\n    }\n}\n\n/// Create a new `Dedup`.\npub fn dedup<I>(iter: I) -> Dedup<I>\n    where I: Iterator\n{\n    dedup_by(iter, DedupEq)\n}\n\nimpl<I, Pred> fmt::Debug for DedupBy<I, Pred>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(Dedup, iter);\n}\n\nimpl<I, Pred> Iterator for DedupBy<I, Pred>\n    where I: Iterator,\n          Pred: DedupPredicate<I::Item>,\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let ref mut dedup_pred = self.dedup_pred;\n        self.iter.next_with(|x, y| {\n            if dedup_pred.dedup_pair(&x, &y) { Ok(x) } else { Err((x, y)) }\n        })\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn fold<Acc, G>(self, mut accum: Acc, mut f: G) -> Acc\n        where G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        if let Some(mut last) = self.iter.last {\n            let mut dedup_pred = self.dedup_pred;\n            accum = self.iter.iter.fold(accum, |acc, elt| {\n                if dedup_pred.dedup_pair(&elt, &last) {\n                    acc\n                } else {\n                    f(acc, replace(&mut last, elt))\n                }\n            });\n            f(accum, last)\n        } else {\n            accum\n        }\n    }\n}\n\n/// An iterator adaptor that removes repeated duplicates, while keeping a count of how many\n/// repeated elements were present. This will determine equality using a comparison function.\n///\n/// See [`.dedup_by_with_count()`](../trait.Itertools.html#method.dedup_by_with_count) or\n/// [`.dedup_with_count()`](../trait.Itertools.html#method.dedup_with_count) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct DedupByWithCount<I, Pred>\n    where I: Iterator\n{\n    iter: CoalesceCore<I, (usize, I::Item)>,\n    dedup_pred: Pred,\n}\n\n/// An iterator adaptor that removes repeated duplicates, while keeping a count of how many\n/// repeated elements were present.\n///\n/// See [`.dedup_with_count()`](../trait.Itertools.html#method.dedup_with_count) for more information.\npub type DedupWithCount<I> = DedupByWithCount<I, DedupEq>;\n\n/// Create a new `DedupByWithCount`.\npub fn dedup_by_with_count<I, Pred>(mut iter: I, dedup_pred: Pred) -> DedupByWithCount<I, Pred>\n    where I: Iterator,\n{\n    DedupByWithCount {\n        iter: CoalesceCore {\n            last: iter.next().map(|v| (1, v)),\n            iter,\n        },\n        dedup_pred,\n    }\n}\n\n/// Create a new `DedupWithCount`.\npub fn dedup_with_count<I>(iter: I) -> DedupWithCount<I>\n    where I: Iterator\n{\n    dedup_by_with_count(iter, DedupEq)\n}\n\nimpl<I, Pred> fmt::Debug for DedupByWithCount<I, Pred>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(Dedup, iter);\n}\n\nimpl<I: Clone, Pred: Clone> Clone for DedupByWithCount<I, Pred>\n    where I: Iterator,\n          I::Item: Clone,\n{\n    clone_fields!(iter, dedup_pred);\n}\n\nimpl<I, Pred> Iterator for DedupByWithCount<I, Pred>\n    where I: Iterator,\n          Pred: DedupPredicate<I::Item>,\n{\n    type Item = (usize, I::Item);\n\n    fn next(&mut self) -> Option<(usize, I::Item)> {\n        let ref mut dedup_pred = self.dedup_pred;\n        self.iter.next_with(|(c, x), y| {\n            if dedup_pred.dedup_pair(&x, &y) { Ok((c + 1, x)) } else { Err(((c, x), (1, y))) }\n        })\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\nimpl<I: Iterator, Pred: DedupPredicate<I::Item>> FusedIterator for DedupByWithCount<I, Pred> {}\n\n/// An iterator adaptor that borrows from a `Clone`-able iterator\n/// to only pick off elements while the predicate returns `true`.\n///\n/// See [`.take_while_ref()`](../trait.Itertools.html#method.take_while_ref) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct TakeWhileRef<'a, I: 'a, F> {\n    iter: &'a mut I,\n    f: F,\n}\n\nimpl<'a, I, F> fmt::Debug for TakeWhileRef<'a, I, F>\n    where I: Iterator + fmt::Debug,\n{\n    debug_fmt_fields!(TakeWhileRef, iter);\n}\n\n/// Create a new `TakeWhileRef` from a reference to clonable iterator.\npub fn take_while_ref<I, F>(iter: &mut I, f: F) -> TakeWhileRef<I, F>\n    where I: Iterator + Clone\n{\n    TakeWhileRef { iter, f }\n}\n\nimpl<'a, I, F> Iterator for TakeWhileRef<'a, I, F>\n    where I: Iterator + Clone,\n          F: FnMut(&I::Item) -> bool\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let old = self.iter.clone();\n        match self.iter.next() {\n            None => None,\n            Some(elt) => {\n                if (self.f)(&elt) {\n                    Some(elt)\n                } else {\n                    *self.iter = old;\n                    None\n                }\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, hi) = self.iter.size_hint();\n        (0, hi)\n    }\n}\n\n/// An iterator adaptor that filters `Option<A>` iterator elements\n/// and produces `A`. Stops on the first `None` encountered.\n///\n/// See [`.while_some()`](../trait.Itertools.html#method.while_some) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct WhileSome<I> {\n    iter: I,\n}\n\n/// Create a new `WhileSome<I>`.\npub fn while_some<I>(iter: I) -> WhileSome<I> {\n    WhileSome { iter }\n}\n\nimpl<I, A> Iterator for WhileSome<I>\n    where I: Iterator<Item = Option<A>>\n{\n    type Item = A;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.iter.next() {\n            None | Some(None) => None,\n            Some(elt) => elt,\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let sh = self.iter.size_hint();\n        (0, sh.1)\n    }\n}\n\n/// An iterator to iterate through all combinations in a `Clone`-able iterator that produces tuples\n/// of a specific size.\n///\n/// See [`.tuple_combinations()`](../trait.Itertools.html#method.tuple_combinations) for more\n/// information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct TupleCombinations<I, T>\n    where I: Iterator,\n          T: HasCombination<I>\n{\n    iter: T::Combination,\n    _mi: PhantomData<I>,\n    _mt: PhantomData<T>\n}\n\npub trait HasCombination<I>: Sized {\n    type Combination: From<I> + Iterator<Item = Self>;\n}\n\n/// Create a new `TupleCombinations` from a clonable iterator.\npub fn tuple_combinations<T, I>(iter: I) -> TupleCombinations<I, T>\n    where I: Iterator + Clone,\n          I::Item: Clone,\n          T: HasCombination<I>,\n{\n    TupleCombinations {\n        iter: T::Combination::from(iter),\n        _mi: PhantomData,\n        _mt: PhantomData,\n    }\n}\n\nimpl<I, T> Iterator for TupleCombinations<I, T>\n    where I: Iterator,\n          T: HasCombination<I>,\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next()\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct Tuple1Combination<I> {\n    iter: I,\n}\n\nimpl<I> From<I> for Tuple1Combination<I> {\n    fn from(iter: I) -> Self {\n        Tuple1Combination { iter }\n    }\n}\n\nimpl<I: Iterator> Iterator for Tuple1Combination<I> {\n    type Item = (I::Item,);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(|x| (x,))\n    }\n}\n\nimpl<I: Iterator> HasCombination<I> for (I::Item,) {\n    type Combination = Tuple1Combination<I>;\n}\n\nmacro_rules! impl_tuple_combination {\n    ($C:ident $P:ident ; $A:ident, $($I:ident),* ; $($X:ident)*) => (\n        #[derive(Clone, Debug)]\n        pub struct $C<I: Iterator> {\n            item: Option<I::Item>,\n            iter: I,\n            c: $P<I>,\n        }\n\n        impl<I: Iterator + Clone> From<I> for $C<I> {\n            fn from(mut iter: I) -> Self {\n                $C {\n                    item: iter.next(),\n                    iter: iter.clone(),\n                    c: $P::from(iter),\n                }\n            }\n        }\n\n        impl<I: Iterator + Clone> From<I> for $C<Fuse<I>> {\n            fn from(iter: I) -> Self {\n                let mut iter = iter.fuse();\n                $C {\n                    item: iter.next(),\n                    iter: iter.clone(),\n                    c: $P::from(iter),\n                }\n            }\n        }\n\n        impl<I, $A> Iterator for $C<I>\n            where I: Iterator<Item = $A> + Clone,\n                  I::Item: Clone\n        {\n            type Item = ($($I),*);\n\n            fn next(&mut self) -> Option<Self::Item> {\n                if let Some(($($X),*,)) = self.c.next() {\n                    let z = self.item.clone().unwrap();\n                    Some((z, $($X),*))\n                } else {\n                    self.item = self.iter.next();\n                    self.item.clone().and_then(|z| {\n                        self.c = $P::from(self.iter.clone());\n                        self.c.next().map(|($($X),*,)| (z, $($X),*))\n                    })\n                }\n            }\n        }\n\n        impl<I, $A> HasCombination<I> for ($($I),*)\n            where I: Iterator<Item = $A> + Clone,\n                  I::Item: Clone\n        {\n            type Combination = $C<Fuse<I>>;\n        }\n    )\n}\n\nimpl_tuple_combination!(Tuple2Combination Tuple1Combination ; A, A, A ; a);\nimpl_tuple_combination!(Tuple3Combination Tuple2Combination ; A, A, A, A ; a b);\nimpl_tuple_combination!(Tuple4Combination Tuple3Combination ; A, A, A, A, A; a b c);\n\n/// An iterator adapter to apply `Into` conversion to each element.\n///\n/// See [`.map_into()`](../trait.Itertools.html#method.map_into) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MapInto<I, R> {\n    iter: I,\n    _res: PhantomData<R>,\n}\n\n/// Create a new [`MapInto`](struct.MapInto.html) iterator.\npub fn map_into<I, R>(iter: I) -> MapInto<I, R> {\n    MapInto {\n        iter,\n        _res: PhantomData,\n    }\n}\n\nimpl<I, R> Iterator for MapInto<I, R>\n    where I: Iterator,\n          I::Item: Into<R>,\n{\n    type Item = R;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter\n            .next()\n            .map(|i| i.into())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn fold<Acc, Fold>(self, init: Acc, mut fold_f: Fold) -> Acc\n        where Fold: FnMut(Acc, Self::Item) -> Acc,\n    {\n        self.iter.fold(init, move |acc, v| fold_f(acc, v.into()))\n    }\n}\n\nimpl<I, R> DoubleEndedIterator for MapInto<I, R>\n    where I: DoubleEndedIterator,\n          I::Item: Into<R>,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.iter\n            .next_back()\n            .map(|i| i.into())\n    }\n}\n\nimpl<I, R> ExactSizeIterator for MapInto<I, R>\nwhere\n    I: ExactSizeIterator,\n    I::Item: Into<R>,\n{}\n\n/// An iterator adapter to apply a transformation within a nested `Result`.\n///\n/// See [`.map_results()`](../trait.Itertools.html#method.map_results) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MapResults<I, F> {\n    iter: I,\n    f: F\n}\n\n/// Create a new `MapResults` iterator.\npub fn map_results<I, F, T, U, E>(iter: I, f: F) -> MapResults<I, F>\n    where I: Iterator<Item = Result<T, E>>,\n          F: FnMut(T) -> U,\n{\n    MapResults {\n        iter,\n        f,\n    }\n}\n\nimpl<I, F, T, U, E> Iterator for MapResults<I, F>\n    where I: Iterator<Item = Result<T, E>>,\n          F: FnMut(T) -> U,\n{\n    type Item = Result<U, E>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(|v| v.map(&mut self.f))\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn fold<Acc, Fold>(self, init: Acc, mut fold_f: Fold) -> Acc\n        where Fold: FnMut(Acc, Self::Item) -> Acc,\n    {\n        let mut f = self.f;\n        self.iter.fold(init, move |acc, v| fold_f(acc, v.map(&mut f)))\n    }\n\n    fn collect<C>(self) -> C\n        where C: FromIterator<Self::Item>\n    {\n        let mut f = self.f;\n        self.iter.map(move |v| v.map(&mut f)).collect()\n    }\n}\n\n/// An iterator adapter to get the positions of each element that matches a predicate.\n///\n/// See [`.positions()`](../trait.Itertools.html#method.positions) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Positions<I, F> {\n    iter: I,\n    f: F,\n    count: usize,\n}\n\n/// Create a new `Positions` iterator.\npub fn positions<I, F>(iter: I, f: F) -> Positions<I, F>\n    where I: Iterator,\n          F: FnMut(I::Item) -> bool,\n{\n    Positions {\n        iter,\n        f,\n        count: 0\n    }\n}\n\nimpl<I, F> Iterator for Positions<I, F>\n    where I: Iterator,\n          F: FnMut(I::Item) -> bool,\n{\n    type Item = usize;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        while let Some(v) = self.iter.next() {\n            let i = self.count;\n            self.count = i + 1;\n            if (self.f)(v) {\n                return Some(i);\n            }\n        }\n        None\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (0, self.iter.size_hint().1)\n    }\n}\n\nimpl<I, F> DoubleEndedIterator for Positions<I, F>\n    where I: DoubleEndedIterator + ExactSizeIterator,\n          F: FnMut(I::Item) -> bool,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        while let Some(v) = self.iter.next_back() {\n            if (self.f)(v) {\n                return Some(self.count + self.iter.len())\n            }\n        }\n        None\n    }\n}\n\n/// An iterator adapter to apply a mutating function to each element before yielding it.\n///\n/// See [`.update()`](../trait.Itertools.html#method.update) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Update<I, F> {\n    iter: I,\n    f: F,\n}\n\n/// Create a new `Update` iterator.\npub fn update<I, F>(iter: I, f: F) -> Update<I, F>\nwhere\n    I: Iterator,\n    F: FnMut(&mut I::Item),\n{\n    Update { iter, f }\n}\n\nimpl<I, F> Iterator for Update<I, F>\nwhere\n    I: Iterator,\n    F: FnMut(&mut I::Item),\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if let Some(mut v) = self.iter.next() {\n            (self.f)(&mut v);\n            Some(v)\n        } else {\n            None\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn fold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n        where G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        let mut f = self.f;\n        self.iter.fold(init, move |acc, mut v| { f(&mut v); g(acc, v) })\n    }\n\n    // if possible, re-use inner iterator specializations in collect\n    fn collect<C>(self) -> C\n        where C: FromIterator<Self::Item>\n    {\n        let mut f = self.f;\n        self.iter.map(move |mut v| { f(&mut v); v }).collect()\n    }\n}\n\nimpl<I, F> ExactSizeIterator for Update<I, F>\nwhere\n    I: ExactSizeIterator,\n    F: FnMut(&mut I::Item),\n{}\n\nimpl<I, F> DoubleEndedIterator for Update<I, F>\nwhere\n    I: DoubleEndedIterator,\n    F: FnMut(&mut I::Item),\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        if let Some(mut v) = self.iter.next_back() {\n            (self.f)(&mut v);\n            Some(v)\n        } else {\n            None\n        }\n    }\n}\n","traces":[{"line":42,"address":[5537150,5537424,5537056,5537563],"length":1,"stats":{"Line":3},"fn_name":"interleave<quick::Iter<i16, quick::Inexact>,quick::Iter<i16, quick::Inexact>>"},{"line":47,"address":[5537464,5537066],"length":1,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[5537165,5537578,5537618,5537242],"length":1,"stats":{"Line":6},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[5539776,5539856],"length":1,"stats":{"Line":5},"fn_name":"interleave_shortest<core::slice::Iter<()>,core::slice::Iter<()>>"},{"line":116,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":185,"address":[4243017,4242576,4242912,4242702,4242736,4242874],"length":1,"stats":{"Line":11},"fn_name":"put_back<alloc::vec::IntoIter<i32>>"},{"line":190,"address":[4242938,4242755,4242591],"length":1,"stats":{"Line":11},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[5538786,5539104,5538720,5539164],"length":1,"stats":{"Line":8},"fn_name":"cartesian_product<quick::Iter<u16, quick::Inexact>,quick::Iter<u16, quick::Inexact>>"},{"line":306,"address":[5539114,5538730,5539183],"length":1,"stats":{"Line":9},"fn_name":null},{"line":308,"address":[5539298,5538861],"length":1,"stats":{"Line":8},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":353,"address":[5518960,5519055],"length":1,"stats":{"Line":1},"fn_name":"fold<itertools::adaptors::Product<quick::Iter<u16, quick::Inexact>, quick::Iter<u16, quick::Inexact>>,quick::Iter<u16, quick::Inexact>,(),closure-0>"},{"line":358,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":394,"address":[4232640],"length":1,"stats":{"Line":2},"fn_name":"batching<core::slice::Iter<core::option::Option<i32>>,closure-0>"},{"line":404,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[5544816,5545712,5545936,5544752,5545040,5545328,5545648,5545992,5545109,5545387],"length":1,"stats":{"Line":7},"fn_name":"step<core::ops::range::Range<usize>>"},{"line":438,"address":[5544774,5545948,5545343,5545670,5545067],"length":1,"stats":{"Line":7},"fn_name":null},{"line":440,"address":[5545121,5544828,5545399,5545724,5546004],"length":1,"stats":{"Line":7},"fn_name":null},{"line":441,"address":[5546076,5545473,5544998,5545183,5545781,5545894,5546178,5544885,5545285,5545601],"length":1,"stats":{"Line":7},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":511,"address":[5546384,5546480],"length":1,"stats":{"Line":3},"fn_name":"merge<quick::Iter<u16, quick::Inexact>,quick::Iter<u16, quick::Inexact>>"},{"line":516,"address":[5546502,5546391],"length":1,"stats":{"Line":3},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":550,"address":[5538319,5538224,5537856,5537959],"length":1,"stats":{"Line":5},"fn_name":"merge_by_new<core::slice::Iter<i16>,&alloc::vec::Vec<i16>,itertools::adaptors::MergeLte>"},{"line":556,"address":[5537881,5538234],"length":1,"stats":{"Line":5},"fn_name":null},{"line":557,"address":[5538352,5538037,5538426,5537992],"length":1,"stats":{"Line":10},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":582,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":585,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":589,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":596,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":597,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":599,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":620,"address":[5543289,5541600,5539984,5540841,5541657,5543232,5540040,5542416,5540784,5542473],"length":1,"stats":{"Line":11},"fn_name":"next_with<quick::Iter<i16, quick::Exact>,i16,closure-0>"},{"line":624,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":626,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":628,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":631,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":632,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":641,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":643,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":692,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":693,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":726,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":727,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":744,"address":[5546864,5547168,5546754,5546704,5546914,5547214,5547070,5547024,5546601,5546544],"length":1,"stats":{"Line":9},"fn_name":"dedup_by<quick::Iter<i16, quick::Exact>,itertools::adaptors::DedupEq>"},{"line":748,"address":[5547092,5547236,5546936,5546623,5546776],"length":1,"stats":{"Line":9},"fn_name":null},{"line":757,"address":[5546272,5546336,5546224],"length":1,"stats":{"Line":4},"fn_name":"dedup<core::slice::Iter<i32>>"},{"line":760,"address":[5546294,5546353,5546241],"length":1,"stats":{"Line":4},"fn_name":null},{"line":776,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":777,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":778,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":779,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":783,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":784,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":787,"address":[4770346,4770272,4769840,4769914],"length":1,"stats":{"Line":2},"fn_name":"fold<core::slice::Iter<i32>,itertools::adaptors::DedupEq,(),closure-0>"},{"line":790,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":791,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":792,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":793,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":794,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":796,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":799,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":801,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":826,"address":[4784672,4784864,4784911,4784719,4785103,4785056],"length":1,"stats":{"Line":3},"fn_name":"dedup_by_with_count<core::slice::Iter<(i32, i32)>,closure-1>"},{"line":830,"address":[4784959,4784767,4785151],"length":1,"stats":{"Line":3},"fn_name":null},{"line":839,"address":[4783680],"length":1,"stats":{"Line":1},"fn_name":"dedup_with_count<core::slice::Iter<i32>>"},{"line":842,"address":[4783697],"length":1,"stats":{"Line":1},"fn_name":null},{"line":865,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":866,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":867,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":868,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":872,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":873,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":896,"address":[5538608],"length":1,"stats":{"Line":1},"fn_name":"take_while_ref<core::slice::Iter<u8>,closure-0>"},{"line":908,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":909,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":910,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":911,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":912,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":913,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":914,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":916,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":917,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":923,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":924,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":925,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":940,"address":[5537776],"length":1,"stats":{"Line":2},"fn_name":"while_some<core::iter::adapters::Map<alloc::vec::IntoIter<itertools::adaptors::multi_product::MultiProductIter<quick::Iter<i32, quick::Inexact>>>, closure-0>>"},{"line":949,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":950,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":951,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":952,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":956,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":957,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":958,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":983,"address":[5539568,5539664],"length":1,"stats":{"Line":3},"fn_name":"tuple_combinations<(&u8, &u8),core::slice::Iter<u8>>"},{"line":989,"address":[5539671,5539585],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1001,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1002,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1012,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1020,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1021,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1049,"address":[5532720,5532783,5532288,5532362],"length":1,"stats":{"Line":3},"fn_name":"from<quick::Iter<i16, quick::Inexact>>"},{"line":1050,"address":[5532377,5532740,5532298,5532798],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1052,"address":[5532390,5532811],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1053,"address":[5532832,5532436],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1054,"address":[5532443,5532839],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1065,"address":[5527814,5527264,5527216,5527760],"length":1,"stats":{"Line":3},"fn_name":"next<core::iter::adapters::Fuse<quick::Iter<i16, quick::Inexact>>,i16>"},{"line":1066,"address":[5527772,5527452,5527558,5527225,5527276,5527878,5527833,5527314,5528060,5527985],"length":1,"stats":{"Line":15},"fn_name":null},{"line":1067,"address":[5527329,5527400,5527940,5527896],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1068,"address":[5527405,5527945],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1070,"address":[5527457,5528124,5527289,5527604,5527854,5527990],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1071,"address":[5528137,5527627,5528272,5528319,5527467,5528000,5528640,5528694],"length":1,"stats":{"Line":9},"fn_name":"{{closure}}<core::iter::adapters::Fuse<quick::Iter<i16, quick::Inexact>>,i16>"},{"line":1072,"address":[5528549,5528344,5528289,5528657,5528716,5528811],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1073,"address":[5528361,5528730,5528974,5528909,5528960,5528575,5528837,5528896],"length":1,"stats":{"Line":10},"fn_name":"{{closure}}<core::iter::adapters::Fuse<core::slice::Iter<u8>>,&u8>"},{"line":1116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":235,"coverable":306},{"path":["/","home","kms","itertools","src","adaptors","multi_product.rs"],"content":"#![cfg(feature = \"use_std\")]\n\nuse crate::size_hint;\nuse crate::Itertools;\n\n#[derive(Clone)]\n/// An iterator adaptor that iterates over the cartesian product of\n/// multiple iterators of type `I`.\n///\n/// An iterator element type is `Vec<I>`.\n///\n/// See [`.multi_cartesian_product()`](../trait.Itertools.html#method.multi_cartesian_product)\n/// for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MultiProduct<I>(Vec<MultiProductIter<I>>)\n    where I: Iterator + Clone,\n          I::Item: Clone;\n\n/// Create a new cartesian product iterator over an arbitrary number\n/// of iterators of the same type.\n///\n/// Iterator element is of type `Vec<H::Item::Item>`.\npub fn multi_cartesian_product<H>(iters: H) -> MultiProduct<<H::Item as IntoIterator>::IntoIter>\n    where H: Iterator,\n          H::Item: IntoIterator,\n          <H::Item as IntoIterator>::IntoIter: Clone,\n          <H::Item as IntoIterator>::Item: Clone\n{\n    MultiProduct(iters.map(|i| MultiProductIter::new(i.into_iter())).collect())\n}\n\n#[derive(Clone, Debug)]\n/// Holds the state of a single iterator within a MultiProduct.\nstruct MultiProductIter<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    cur: Option<I::Item>,\n    iter: I,\n    iter_orig: I,\n}\n\n/// Holds the current state during an iteration of a MultiProduct.\n#[derive(Debug)]\nenum MultiProductIterState {\n    StartOfIter,\n    MidIter { on_first_iter: bool },\n}\n\nimpl<I> MultiProduct<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    /// Iterates the rightmost iterator, then recursively iterates iterators\n    /// to the left if necessary.\n    ///\n    /// Returns true if the iteration succeeded, else false.\n    fn iterate_last(\n        multi_iters: &mut [MultiProductIter<I>],\n        mut state: MultiProductIterState\n    ) -> bool {\n        use self::MultiProductIterState::*;\n\n        if let Some((last, rest)) = multi_iters.split_last_mut() {\n            let on_first_iter = match state {\n                StartOfIter => {\n                    let on_first_iter = !last.in_progress();\n                    state = MidIter { on_first_iter };\n                    on_first_iter\n                },\n                MidIter { on_first_iter } => on_first_iter\n            };\n\n            if !on_first_iter {\n                last.iterate();\n            }\n\n            if last.in_progress() {\n                true\n            } else if MultiProduct::iterate_last(rest, state) {\n                last.reset();\n                last.iterate();\n                // If iterator is None twice consecutively, then iterator is\n                // empty; whole product is empty.\n                last.in_progress()\n            } else {\n                false\n            }\n        } else {\n            // Reached end of iterator list. On initialisation, return true.\n            // At end of iteration (final iterator finishes), finish.\n            match state {\n                StartOfIter => false,\n                MidIter { on_first_iter } => on_first_iter\n            }\n        }\n    }\n\n    /// Returns the unwrapped value of the next iteration.\n    fn curr_iterator(&self) -> Vec<I::Item> {\n        self.0.iter().map(|multi_iter| {\n            multi_iter.cur.clone().unwrap()\n        }).collect()\n    }\n\n    /// Returns true if iteration has started and has not yet finished; false\n    /// otherwise.\n    fn in_progress(&self) -> bool {\n        if let Some(last) = self.0.last() {\n            last.in_progress()\n        } else {\n            false\n        }\n    }\n}\n\nimpl<I> MultiProductIter<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    fn new(iter: I) -> Self {\n        MultiProductIter {\n            cur: None,\n            iter: iter.clone(),\n            iter_orig: iter\n        }\n    }\n\n    /// Iterate the managed iterator.\n    fn iterate(&mut self) {\n        self.cur = self.iter.next();\n    }\n\n    /// Reset the managed iterator.\n    fn reset(&mut self) {\n        self.iter = self.iter_orig.clone();\n    }\n\n    /// Returns true if the current iterator has been started and has not yet\n    /// finished; false otherwise.\n    fn in_progress(&self) -> bool {\n        self.cur.is_some()\n    }\n}\n\nimpl<I> Iterator for MultiProduct<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    type Item = Vec<I::Item>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if MultiProduct::iterate_last(\n            &mut self.0,\n            MultiProductIterState::StartOfIter\n        ) {\n            Some(self.curr_iterator())\n        } else {\n            None\n        }\n    }\n\n    fn count(self) -> usize {\n        if self.0.len() == 0 {\n            return 0;\n        }\n\n        if !self.in_progress() {\n            return self.0.into_iter().fold(1, |acc, multi_iter| {\n                acc * multi_iter.iter.count()\n            });\n        }\n\n        self.0.into_iter().fold(\n            0,\n            |acc, MultiProductIter { iter, iter_orig, cur: _ }| {\n                let total_count = iter_orig.count();\n                let cur_count = iter.count();\n                acc * total_count + cur_count\n            }\n        )\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // Not ExactSizeIterator because size may be larger than usize\n        if self.0.len() == 0 {\n            return (0, Some(0));\n        }\n\n        if !self.in_progress() {\n            return self.0.iter().fold((1, Some(1)), |acc, multi_iter| {\n                size_hint::mul(acc, multi_iter.iter.size_hint())\n            });\n        }\n\n        self.0.iter().fold(\n            (0, Some(0)),\n            |acc, &MultiProductIter { ref iter, ref iter_orig, cur: _ }| {\n                let cur_size = iter.size_hint();\n                let total_size = iter_orig.size_hint();\n                size_hint::add(size_hint::mul(acc, total_size), cur_size)\n            }\n        )\n    }\n\n    fn last(self) -> Option<Self::Item> {\n        let iter_count = self.0.len();\n\n        let lasts: Self::Item = self.0.into_iter()\n            .map(|multi_iter| multi_iter.iter.last())\n            .while_some()\n            .collect();\n\n        if lasts.len() == iter_count {\n            Some(lasts)\n        } else {\n            None\n        }\n    }\n}\n","traces":[{"line":23,"address":[4751472],"length":1,"stats":{"Line":1},"fn_name":"multi_cartesian_product<quick::ShiftRange<quick::Inexact>>"},{"line":29,"address":[4751612,4751600,4751482],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}<quick::ShiftRange<quick::Inexact>>"},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":61,"coverable":73},{"path":["/","home","kms","itertools","src","combinations.rs"],"content":"use std::fmt;\n\nuse super::lazy_buffer::LazyBuffer;\n\n/// An iterator to iterate through all the `k`-length combinations in an iterator.\n///\n/// See [`.combinations()`](../trait.Itertools.html#method.combinations) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Combinations<I: Iterator> {\n    indices: Vec<usize>,\n    pool: LazyBuffer<I>,\n    first: bool,\n}\n\nimpl<I> Clone for Combinations<I>\n    where I: Clone + Iterator,\n          I::Item: Clone,\n{\n    clone_fields!(indices, pool, first);\n}\n\nimpl<I> fmt::Debug for Combinations<I>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(Combinations, indices, pool, first);\n}\n\n/// Create a new `Combinations` from a clonable iterator.\npub fn combinations<I>(iter: I, k: usize) -> Combinations<I>\n    where I: Iterator\n{\n    let mut pool: LazyBuffer<I> = LazyBuffer::new(iter);\n\n    for _ in 0..k {\n        if !pool.get_next() {\n            break;\n        }\n    }\n\n    Combinations {\n        indices: (0..k).collect(),\n        pool,\n        first: true,\n    }\n}\n\nimpl<I> Iterator for Combinations<I>\n    where I: Iterator,\n          I::Item: Clone\n{\n    type Item = Vec<I::Item>;\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.first {\n            if self.pool.is_done() {\n                return None;\n            }\n            self.first = false;\n        } else if self.indices.len() == 0 {\n            return None;\n        } else {\n            // Scan from the end, looking for an index to increment\n            let mut i: usize = self.indices.len() - 1;\n\n            // Check if we need to consume more from the iterator\n            if self.indices[i] == self.pool.len() - 1 {\n                self.pool.get_next(); // may change pool size\n            }\n\n            while self.indices[i] == i + self.pool.len() - self.indices.len() {\n                if i > 0 {\n                    i -= 1;\n                } else {\n                    // Reached the last combination\n                    return None;\n                }\n            }\n\n            // Increment index, and reset the ones to its right\n            self.indices[i] += 1;\n            for j in i+1..self.indices.len() {\n                self.indices[j] = self.indices[j - 1] + 1;\n            }\n        }\n\n        // Create result vector based on the indices\n        Some(self.indices.iter().map(|i| self.pool[*i].clone()).collect())\n    }\n}\n","traces":[{"line":30,"address":[4209948,4209888],"length":1,"stats":{"Line":3},"fn_name":"combinations<adaptors_no_collect::PanickingCounter>"},{"line":33,"address":[4209913],"length":1,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[4210065,4210259,4209963],"length":1,"stats":{"Line":10},"fn_name":null},{"line":36,"address":[4210178,4210253],"length":1,"stats":{"Line":8},"fn_name":null},{"line":37,"address":[4210264],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[4210189],"length":1,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":54,"address":[4208034,4209027,4208145],"length":1,"stats":{"Line":7},"fn_name":null},{"line":55,"address":[4208091],"length":1,"stats":{"Line":3},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[4208431],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":6},"fn_name":null}],"covered":24,"coverable":24},{"path":["/","home","kms","itertools","src","combinations_with_replacement.rs"],"content":"use std::fmt;\n\nuse super::lazy_buffer::LazyBuffer;\n\n/// An iterator to iterate through all the `n`-length combinations in an iterator, with replacement.\n///\n/// See [`.combinations_with_replacement()`](../trait.Itertools.html#method.combinations_with_replacement) for more information.\n#[derive(Clone)]\npub struct CombinationsWithReplacement<I>\nwhere\n    I: Iterator,\n    I::Item: Clone,\n{\n    k: usize,\n    indices: Vec<usize>,\n    // The current known max index value. This increases as pool grows.\n    max_index: usize,\n    pool: LazyBuffer<I>,\n    first: bool,\n}\n\nimpl<I> fmt::Debug for CombinationsWithReplacement<I>\nwhere\n    I: Iterator + fmt::Debug,\n    I::Item: fmt::Debug + Clone,\n{\n    debug_fmt_fields!(Combinations, k, indices, max_index, pool, first);\n}\n\nimpl<I> CombinationsWithReplacement<I>\nwhere\n    I: Iterator,\n    I::Item: Clone,\n{\n    /// Map the current mask over the pool to get an output combination\n    fn current(&self) -> Vec<I::Item> {\n        self.indices.iter().map(|i| self.pool[*i].clone()).collect()\n    }\n}\n\n/// Create a new `CombinationsWithReplacement` from a clonable iterator.\npub fn combinations_with_replacement<I>(iter: I, k: usize) -> CombinationsWithReplacement<I>\nwhere\n    I: Iterator,\n    I::Item: Clone,\n{\n    let indices: Vec<usize> = vec![0; k];\n    let pool: LazyBuffer<I> = LazyBuffer::new(iter);\n\n    CombinationsWithReplacement {\n        k,\n        indices,\n        max_index: 0,\n        pool,\n        first: true,\n    }\n}\n\nimpl<I> Iterator for CombinationsWithReplacement<I>\nwhere\n    I: Iterator,\n    I::Item: Clone,\n{\n    type Item = Vec<I::Item>;\n    fn next(&mut self) -> Option<Self::Item> {\n        // If this is the first iteration, return early\n        if self.first {\n            // In empty edge cases, stop iterating immediately\n            return if self.k != 0 && !self.pool.get_next() {\n                None\n            // Otherwise, yield the initial state\n            } else {\n                self.first = false;\n                Some(self.current())\n            };\n        }\n\n        // Check if we need to consume more from the iterator\n        // This will run while we increment our first index digit\n        if self.pool.get_next() {\n            self.max_index = self.pool.len() - 1;\n        }\n\n        // Work out where we need to update our indices\n        let mut increment: Option<(usize, usize)> = None;\n        for (i, indices_int) in self.indices.iter().enumerate().rev() {\n            if indices_int < &self.max_index {\n                increment = Some((i, indices_int + 1));\n                break;\n            }\n        }\n\n        match increment {\n            // If we can update the indices further\n            Some((increment_from, increment_value)) => {\n                // We need to update the rightmost non-max value\n                // and all those to the right\n                for indices_index in increment_from..self.indices.len() {\n                    self.indices[indices_index] = increment_value\n                }\n                Some(self.current())\n            }\n            // Otherwise, we're done\n            None => None,\n        }\n    }\n}\n","traces":[{"line":36,"address":[4249376],"length":1,"stats":{"Line":2},"fn_name":"current<adaptors_no_collect::PanickingCounter>"},{"line":37,"address":[4249534,4249388,4249520],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}<adaptors_no_collect::PanickingCounter>"},{"line":42,"address":[4249053,4248976],"length":1,"stats":{"Line":2},"fn_name":"combinations_with_replacement<adaptors_no_collect::PanickingCounter>"},{"line":47,"address":[4249001],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[4249068],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[4247408],"length":1,"stats":{"Line":2},"fn_name":"next<adaptors_no_collect::PanickingCounter>"},{"line":67,"address":[4247426],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[4247522,4247695,4247490,4247650],"length":1,"stats":{"Line":6},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[4247713,4248823,4248793],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":87,"address":[4248127,4248204],"length":1,"stats":{"Line":4},"fn_name":null},{"line":88,"address":[4248215],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[4248369],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":24,"coverable":24},{"path":["/","home","kms","itertools","src","concat_impl.rs"],"content":"use crate::Itertools;\n\n/// Combine all an iterator's elements into one element by using `Extend`.\n///\n/// `IntoIterator`-enabled version of `.concat()`\n///\n/// This combinator will extend the first item with each of the rest of the\n/// items of the iterator. If the iterator is empty, the default value of\n/// `I::Item` is returned.\n///\n/// ```rust\n/// use itertools::concat;\n/// \n/// let input = vec![vec![1], vec![2, 3], vec![4, 5, 6]];\n/// assert_eq!(concat(input), vec![1, 2, 3, 4, 5, 6]);\n/// ```\npub fn concat<I>(iterable: I) -> I::Item\n    where I: IntoIterator,\n          I::Item: Extend<<<I as IntoIterator>::Item as IntoIterator>::Item> + IntoIterator + Default\n{\n    iterable.into_iter().fold1(|mut a, b| { a.extend(b); a }).unwrap_or_else(|| <_>::default())\n}\n","traces":[{"line":17,"address":[4858416,4858528],"length":1,"stats":{"Line":2},"fn_name":"concat<alloc::vec::IntoIter<alloc::vec::Vec<i32>>>"},{"line":21,"address":[4858816,4858684,4858423,4858652,4858960,4858640,4858972,4858828,4858672,4858535],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}<alloc::vec::IntoIter<alloc::vec::Vec<i32>>>"}],"covered":2,"coverable":2},{"path":["/","home","kms","itertools","src","cons_tuples_impl.rs"],"content":"\nmacro_rules! impl_cons_iter(\n    ($_A:ident, $_B:ident, ) => (); // stop\n\n    ($A:ident, $($B:ident,)*) => (\n        impl_cons_iter!($($B,)*);\n        #[allow(non_snake_case)]\n        impl<X, Iter, $($B),*> Iterator for ConsTuples<Iter, (($($B,)*), X)>\n            where Iter: Iterator<Item = (($($B,)*), X)>,\n        {\n            type Item = ($($B,)* X, );\n            fn next(&mut self) -> Option<Self::Item> {\n                self.iter.next().map(|(($($B,)*), x)| ($($B,)* x, ))\n            }\n\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.iter.size_hint()\n            }\n            fn fold<Acc, Fold>(self, accum: Acc, mut f: Fold) -> Acc\n                where Fold: FnMut(Acc, Self::Item) -> Acc,\n            {\n                self.iter.fold(accum, move |acc, (($($B,)*), x)| f(acc, ($($B,)* x, )))\n            }\n        }\n\n        #[allow(non_snake_case)]\n        impl<X, Iter, $($B),*> DoubleEndedIterator for ConsTuples<Iter, (($($B,)*), X)>\n            where Iter: DoubleEndedIterator<Item = (($($B,)*), X)>,\n        {\n            fn next_back(&mut self) -> Option<Self::Item> {\n                self.iter.next().map(|(($($B,)*), x)| ($($B,)* x, ))\n            }\n        }\n\n    );\n);\n\nimpl_cons_iter!(A, B, C, D, E, F, G, H,);\n\n/// An iterator that maps an iterator of tuples like\n/// `((A, B), C)` to an iterator of `(A, B, C)`.\n///\n/// Used by the `iproduct!()` macro.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Debug)]\npub struct ConsTuples<I, J>\n    where I: Iterator<Item=J>,\n{\n    iter: I,\n}\n\nimpl<I, J> Clone for ConsTuples<I, J>\n    where I: Clone + Iterator<Item=J>,\n{\n    clone_fields!(iter);\n}\n\n/// Create an iterator that maps for example iterators of\n/// `((A, B), C)` to `(A, B, C)`.\npub fn cons_tuples<I, J>(iterable: I) -> ConsTuples<I, J>\n    where I: Iterator<Item=J>\n{\n    ConsTuples { iter: iterable.into_iter() }\n}\n","traces":[{"line":12,"address":[5052128],"length":1,"stats":{"Line":4},"fn_name":"next<u16,itertools::adaptors::Product<itertools::adaptors::Product<quick::Iter<u16, quick::Inexact>, quick::Iter<u16, quick::Inexact>>, quick::Iter<u16, quick::Inexact>>,u16,u16>"},{"line":13,"address":[5052136,5052208,5052245],"length":1,"stats":{"Line":12},"fn_name":"{{closure}}<u16,itertools::adaptors::Product<itertools::adaptors::Product<quick::Iter<u16, quick::Inexact>, quick::Iter<u16, quick::Inexact>>, quick::Iter<u16, quick::Inexact>>,u16,u16>"},{"line":16,"address":[5052336],"length":1,"stats":{"Line":2},"fn_name":"size_hint<u16,itertools::adaptors::Product<itertools::adaptors::Product<quick::Iter<u16, quick::Inexact>, quick::Iter<u16, quick::Inexact>>, quick::Iter<u16, quick::Inexact>>,u16,u16>"},{"line":17,"address":[5052348],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[5051872],"length":1,"stats":{"Line":1},"fn_name":"fold<u16,itertools::adaptors::Product<itertools::adaptors::Product<quick::Iter<u16, quick::Inexact>, quick::Iter<u16, quick::Inexact>>, quick::Iter<u16, quick::Inexact>>,u16,u16,(),closure-1>"},{"line":22,"address":[5051884,5051968,5052009],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}<u16,itertools::adaptors::Product<itertools::adaptors::Product<quick::Iter<u16, quick::Inexact>, quick::Iter<u16, quick::Inexact>>, quick::Iter<u16, quick::Inexact>>,u16,u16,(),closure-1>"},{"line":60,"address":[5052544],"length":1,"stats":{"Line":4},"fn_name":"cons_tuples<itertools::adaptors::Product<itertools::adaptors::Product<quick::Iter<u16, quick::Inexact>, quick::Iter<u16, quick::Inexact>>, quick::Iter<u16, quick::Inexact>>,((u16, u16), u16)>"},{"line":63,"address":[5052554],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":8,"coverable":8},{"path":["/","home","kms","itertools","src","diff.rs"],"content":"//! \"Diff\"ing iterators for caching elements to sequential collections without requiring the new\n//! elements' iterator to be `Clone`.\n//!\n//! - [**Diff**](./enum.Diff.html) (produced by the [**diff_with**](./fn.diff_with.html) function)\n//! describes the difference between two non-`Clone` iterators `I` and `J` after breaking ASAP from\n//! a lock-step comparison.\n\nuse crate::free::put_back;\nuse crate::structs::PutBack;\n\n/// A type returned by the [`diff_with`](./fn.diff_with.html) function.\n///\n/// `Diff` represents the way in which the elements yielded by the iterator `I` differ to some\n/// iterator `J`.\npub enum Diff<I, J>\n    where I: Iterator,\n          J: Iterator\n{\n    /// The index of the first non-matching element along with both iterator's remaining elements\n    /// starting with the first mis-match.\n    FirstMismatch(usize, PutBack<I>, PutBack<J>),\n    /// The total number of elements that were in `J` along with the remaining elements of `I`.\n    Shorter(usize, PutBack<I>),\n    /// The total number of elements that were in `I` along with the remaining elements of `J`.\n    Longer(usize, PutBack<J>),\n}\n\n/// Compares every element yielded by both `i` and `j` with the given function in lock-step and\n/// returns a `Diff` which describes how `j` differs from `i`.\n///\n/// If the number of elements yielded by `j` is less than the number of elements yielded by `i`,\n/// the number of `j` elements yielded will be returned along with `i`'s remaining elements as\n/// `Diff::Shorter`.\n///\n/// If the two elements of a step differ, the index of those elements along with the remaining\n/// elements of both `i` and `j` are returned as `Diff::FirstMismatch`.\n///\n/// If `i` becomes exhausted before `j` becomes exhausted, the number of elements in `i` along with\n/// the remaining `j` elements will be returned as `Diff::Longer`.\npub fn diff_with<I, J, F>(i: I, j: J, is_equal: F)\n    -> Option<Diff<I::IntoIter, J::IntoIter>>\n    where I: IntoIterator,\n          J: IntoIterator,\n          F: Fn(&I::Item, &J::Item) -> bool\n{\n    let mut i = i.into_iter();\n    let mut j = j.into_iter();\n    let mut idx = 0;\n    while let Some(i_elem) = i.next() {\n        match j.next() {\n            None => return Some(Diff::Shorter(idx, put_back(i).with_value(i_elem))),\n            Some(j_elem) => if !is_equal(&i_elem, &j_elem) {\n                let remaining_i = put_back(i).with_value(i_elem);\n                let remaining_j = put_back(j).with_value(j_elem);\n                return Some(Diff::FirstMismatch(idx, remaining_i, remaining_j));\n            },\n        }\n        idx += 1;\n    }\n    j.next().map(|j_elem| Diff::Longer(idx, put_back(j).with_value(j_elem)))\n}\n","traces":[{"line":40,"address":[4761936,4762156,4760076,4757996,4759856,4757776],"length":1,"stats":{"Line":3},"fn_name":"diff_with<core::slice::Iter<i32>,core::iter::adapters::Map<alloc::vec::IntoIter<f64>, closure-0>,closure-1>"},{"line":46,"address":[4757799,4759879,4761959],"length":1,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[4757937,4760017,4762097,4762189,4760109,4758029],"length":1,"stats":{"Line":6},"fn_name":null},{"line":48,"address":[4760117,4758037,4762197],"length":1,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[4762217,4761743,4759389,4759478,4759134,4758217,4760137,4761214,4762377,4763294,4763823,4761558,4759541,4759663,4758057,4761469,4761621,4763549,4763638,4760297,4763701],"length":1,"stats":{"Line":11},"fn_name":null},{"line":50,"address":[4762307,4762410,4760227,4758147,4758250,4760330],"length":1,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[4762352,4760397,4758192,4758317,4762412,4760332,4760272,4762477,4758252],"length":1,"stats":{"Line":5},"fn_name":null},{"line":52,"address":[4762663,4758503,4760583],"length":1,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[4760703,4758623,4762783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[4762861,4760781,4758701],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[4763221,4759061,4760887,4758807,4761141,4762967],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[4761870,4763258,4763765,4761178,4763950,4761685,4759790,4759098,4759605],"length":1,"stats":{"Line":6},"fn_name":null},{"line":60,"address":[4764272,4764286,4764016,4764542,4764030,4759175,4761255,4763335,4764528],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}<core::slice::Iter<i32>,core::iter::adapters::Map<alloc::vec::IntoIter<f64>, closure-0>,closure-1>"}],"covered":13,"coverable":13},{"path":["/","home","kms","itertools","src","either_or_both.rs"],"content":"use crate::EitherOrBoth::*;\n\nuse either::Either;\n\n/// Value that either holds a single A or B, or both.\n#[derive(Clone, PartialEq, Eq, Hash, Debug)]\npub enum EitherOrBoth<A, B> {\n    /// Both values are present.\n    Both(A, B),\n    /// Only the left value of type `A` is present.\n    Left(A),\n    /// Only the right value of type `B` is present.\n    Right(B),\n}\n\nimpl<A, B> EitherOrBoth<A, B> {\n    /// If `Left`, or `Both`, return true, otherwise, return false.\n    pub fn has_left(&self) -> bool {\n        self.as_ref().left().is_some()\n    }\n\n    /// If `Right`, or `Both`, return true, otherwise, return false.\n    pub fn has_right(&self) -> bool {\n        self.as_ref().right().is_some()\n    }\n\n    /// If Left, return true otherwise, return false.\n    /// Exclusive version of [`has_left`].\n    pub fn is_left(&self) -> bool {\n        match *self {\n            Left(_) => true,\n            _ => false,\n        }\n    }\n\n    /// If Right, return true otherwise, return false.\n    /// Exclusive version of [`has_right`].\n    pub fn is_right(&self) -> bool {\n        match *self {\n            Right(_) => true,\n            _ => false,\n        }\n    }\n\n    /// If Right, return true otherwise, return false.\n    /// Equivalent to `self.as_ref().both().is_some()`.\n    pub fn is_both(&self) -> bool {\n        self.as_ref().both().is_some()\n    }\n\n    /// If `Left`, or `Both`, return `Some` with the left value, otherwise, return `None`.\n    pub fn left(self) -> Option<A> {\n        match self {\n            Left(left) | Both(left, _) => Some(left),\n            _ => None,\n        }\n    }\n\n    /// If `Right`, or `Both`, return `Some` with the right value, otherwise, return `None`.\n    pub fn right(self) -> Option<B> {\n        match self {\n            Right(right) | Both(_, right) => Some(right),\n            _ => None,\n        }\n    }\n\n    /// If Both, return `Some` tuple containing left and right.\n    pub fn both(self) -> Option<(A, B)> {\n        match self {\n            Both(a, b) => Some((a, b)),\n            _ => None,\n        }\n    }\n\n    /// Converts from `&EitherOrBoth<A, B>` to `EitherOrBoth<&A, &B>`.\n    pub fn as_ref(&self) -> EitherOrBoth<&A, &B> {\n        match *self {\n            Left(ref left) => Left(left),\n            Right(ref right) => Right(right),\n            Both(ref left, ref right) => Both(left, right),\n        }\n    }\n\n    /// Converts from `&mut EitherOrBoth<A, B>` to `EitherOrBoth<&mut A, &mut B>`.\n    pub fn as_mut(&mut self) -> EitherOrBoth<&mut A, &mut B> {\n        match *self {\n            Left(ref mut left) => Left(left),\n            Right(ref mut right) => Right(right),\n            Both(ref mut left, ref mut right) => Both(left, right),\n        }\n    }\n\n    /// Convert `EitherOrBoth<A, B>` to `EitherOrBoth<B, A>`.\n    pub fn flip(self) -> EitherOrBoth<B, A> {\n        match self {\n            Left(a) => Right(a),\n            Right(b) => Left(b),\n            Both(a, b) => Both(b, a),\n        }\n    }\n\n    /// Apply the function `f` on the value `a` in `Left(a)` or `Both(a, b)` variants. If it is\n    /// present rewrapping the result in `self`'s original variant.\n    pub fn map_left<F, M>(self, f: F) -> EitherOrBoth<M, B>\n    where\n        F: FnOnce(A) -> M,\n    {\n        match self {\n            Both(a, b) => Both(f(a), b),\n            Left(a) => Left(f(a)),\n            Right(b) => Right(b),\n        }\n    }\n\n    /// Apply the function `f` on the value `b` in `Right(b)` or `Both(a, b)` variants.\n    /// If it is present rewrapping the result in `self`'s original variant.\n    pub fn map_right<F, M>(self, f: F) -> EitherOrBoth<A, M>\n    where\n        F: FnOnce(B) -> M,\n    {\n        match self {\n            Left(a) => Left(a),\n            Right(b) => Right(f(b)),\n            Both(a, b) => Both(a, f(b)),\n        }\n    }\n\n    /// Apply the functions `f` and `g` on the value `a` and `b` respectively;\n    /// found in `Left(a)`, `Right(b)`, or `Both(a, b)` variants.\n    /// The Result is rewrapped `self`'s original variant.\n    pub fn map_any<F, L, G, R>(self, f: F, g: G) -> EitherOrBoth<L, R>\n    where\n        F: FnOnce(A) -> L,\n        G: FnOnce(B) -> R,\n    {\n        match self {\n            Left(a) => Left(f(a)),\n            Right(b) => Right(g(b)),\n            Both(a, b) => Both(f(a), g(b)),\n        }\n    }\n\n    /// Apply the function `f` on the value `b` in `Right(b)` or `Both(a, _)` variants if it is\n    /// present.\n    pub fn left_and_then<F, L>(self, f: F) -> EitherOrBoth<L, B>\n    where\n        F: FnOnce(A) -> EitherOrBoth<L, B>,\n    {\n        match self {\n            Left(a) | Both(a, _) => f(a),\n            Right(b) => Right(b),\n        }\n    }\n\n    /// Apply the function `f` on the value `a`\n    /// in `Left(a)` or `Both(a, _)` variants if it is present.\n    pub fn right_and_then<F, R>(self, f: F) -> EitherOrBoth<A, R>\n    where\n        F: FnOnce(B) -> EitherOrBoth<A, R>,\n    {\n        match self {\n            Left(a) => Left(a),\n            Right(b) | Both(_, b) => f(b),\n        }\n    }\n}\n\nimpl<T> EitherOrBoth<T, T> {\n    /// Return either value of left, right, or the product of `f` applied where `Both` are present.\n    pub fn reduce<F>(self, f: F) -> T\n    where\n        F: FnOnce(T, T) -> T,\n    {\n        match self {\n            Left(a) => a,\n            Right(b) => b,\n            Both(a, b) => f(a, b),\n        }\n    }\n}\n\nimpl<A, B> Into<Option<Either<A, B>>> for EitherOrBoth<A, B> {\n    fn into(self) -> Option<Either<A, B>> {\n        match self {\n            EitherOrBoth::Left(l) => Some(Either::Left(l)),\n            EitherOrBoth::Right(r) => Some(Either::Right(r)),\n            _ => None,\n        }\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":8,"coverable":68},{"path":["/","home","kms","itertools","src","exactly_one_err.rs"],"content":"use std::iter::ExactSizeIterator;\n\nuse crate::size_hint;\n\n/// Iterator returned for the error case of `IterTools::exactly_one()`\n/// This iterator yields exactly the same elements as the input iterator.\n///\n/// During the execution of exactly_one the iterator must be mutated.  This wrapper\n/// effectively \"restores\" the state of the input iterator when it's handed back.\n///\n/// This is very similar to PutBackN except this iterator only supports 0-2 elements and does not\n/// use a `Vec`.\n#[derive(Debug, Clone)]\npub struct ExactlyOneError<I>\nwhere\n    I: Iterator,\n{\n    first_two: (Option<I::Item>, Option<I::Item>),\n    inner: I,\n}\n\nimpl<I> ExactlyOneError<I>\nwhere\n    I: Iterator,\n{\n    /// Creates a new `ExactlyOneErr` iterator.\n    pub(crate) fn new(first_two: (Option<I::Item>, Option<I::Item>), inner: I) -> Self {\n        Self { first_two, inner }\n    }\n}\n\nimpl<I> Iterator for ExactlyOneError<I>\nwhere\n    I: Iterator,\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.first_two\n            .0\n            .take()\n            .or_else(|| self.first_two.1.take())\n            .or_else(|| self.inner.next())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let mut additional_len = 0;\n        if self.first_two.0.is_some() {\n            additional_len += 1;\n        }\n        if self.first_two.1.is_some() {\n            additional_len += 1;\n        }\n        size_hint::add_scalar(self.inner.size_hint(), additional_len)\n    }\n}\n\nimpl<I> ExactSizeIterator for ExactlyOneError<I> where I: ExactSizeIterator {}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[5868660,5868800,5868809],"length":1,"stats":{"Line":12},"fn_name":"{{closure}}<core::iter::adapters::Cloned<core::slice::Iter<i32>>>"},{"line":43,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":5,"coverable":13},{"path":["/","home","kms","itertools","src","format.rs"],"content":"use std::fmt;\nuse std::cell::RefCell;\n\n/// Format all iterator elements lazily, separated by `sep`.\n///\n/// The format value can only be formatted once, after that the iterator is\n/// exhausted.\n///\n/// See [`.format_with()`](../trait.Itertools.html#method.format_with) for more information.\n#[derive(Clone)]\npub struct FormatWith<'a, I, F> {\n    sep: &'a str,\n    /// FormatWith uses interior mutability because Display::fmt takes &self.\n    inner: RefCell<Option<(I, F)>>,\n}\n\n/// Format all iterator elements lazily, separated by `sep`.\n///\n/// The format value can only be formatted once, after that the iterator is\n/// exhausted.\n///\n/// See [`.format()`](../trait.Itertools.html#method.format)\n/// for more information.\n#[derive(Clone)]\npub struct Format<'a, I> {\n    sep: &'a str,\n    /// Format uses interior mutability because Display::fmt takes &self.\n    inner: RefCell<Option<I>>,\n}\n\npub fn new_format<'a, I, F>(iter: I, separator: &'a str, f: F) -> FormatWith<'a, I, F>\n    where I: Iterator,\n          F: FnMut(I::Item, &mut dyn FnMut(&dyn fmt::Display) -> fmt::Result) -> fmt::Result\n{\n    FormatWith {\n        sep: separator,\n        inner: RefCell::new(Some((iter, f))),\n    }\n}\n\npub fn new_format_default<'a, I>(iter: I, separator: &'a str) -> Format<'a, I>\n    where I: Iterator,\n{\n    Format {\n        sep: separator,\n        inner: RefCell::new(Some(iter)),\n    }\n}\n\nimpl<'a, I, F> fmt::Display for FormatWith<'a, I, F>\n    where I: Iterator,\n          F: FnMut(I::Item, &mut dyn  FnMut(&dyn fmt::Display) -> fmt::Result) -> fmt::Result\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let (mut iter, mut format) = match self.inner.borrow_mut().take() {\n            Some(t) => t,\n            None => panic!(\"FormatWith: was already formatted once\"),\n        };\n\n        if let Some(fst) = iter.next() {\n            format(fst, &mut |disp: &dyn fmt::Display| disp.fmt(f))?;\n            for elt in iter {\n                if self.sep.len() > 0 {\n\n                    f.write_str(self.sep)?;\n                }\n                format(elt, &mut |disp: &dyn fmt::Display| disp.fmt(f))?;\n            }\n        }\n        Ok(())\n    }\n}\n\nimpl<'a, I> Format<'a, I>\n    where I: Iterator,\n{\n    fn format<F>(&self, f: &mut fmt::Formatter, mut cb: F) -> fmt::Result\n        where F: FnMut(&I::Item, &mut fmt::Formatter) -> fmt::Result,\n    {\n        let mut iter = match self.inner.borrow_mut().take() {\n            Some(t) => t,\n            None => panic!(\"Format: was already formatted once\"),\n        };\n\n        if let Some(fst) = iter.next() {\n            cb(&fst, f)?;\n            for elt in iter {\n                if self.sep.len() > 0 {\n                    f.write_str(self.sep)?;\n                }\n                cb(&elt, f)?;\n            }\n        }\n        Ok(())\n    }\n}\n\nmacro_rules! impl_format {\n    ($($fmt_trait:ident)*) => {\n        $(\n            impl<'a, I> fmt::$fmt_trait for Format<'a, I>\n                where I: Iterator,\n                      I::Item: fmt::$fmt_trait,\n            {\n                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                    self.format(f, fmt::$fmt_trait::fmt)\n                }\n            }\n        )*\n    }\n}\n\nimpl_format!{Display Debug\n             UpperExp LowerExp UpperHex LowerHex Octal Binary Pointer}\n","traces":[{"line":41,"address":[4912592,4912768],"length":1,"stats":{"Line":2},"fn_name":"new_format_default<core::slice::Iter<f64>>"},{"line":46,"address":[4912629,4912805],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[4907696,4909398,4911030,4907766,4910960,4909328],"length":1,"stats":{"Line":3},"fn_name":"format<core::slice::Iter<i32>,fn(&&i32, &mut core::fmt::Formatter) -> core::result::Result<(), core::fmt::Error>>"},{"line":80,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[4907552,4907600,4907648],"length":1,"stats":{"Line":3},"fn_name":"fmt<core::slice::Iter<i32>>"},{"line":106,"address":[4907662,4907566,4907614],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":14,"coverable":26},{"path":["/","home","kms","itertools","src","free.rs"],"content":"//! Free functions that create iterator adaptors or call iterator methods.\n//!\n//! The benefit of free functions is that they accept any `IntoIterator` as\n//! argument, so the resulting code may be easier to read.\n\n#[cfg(feature = \"use_std\")]\nuse std::fmt::Display;\nuse std::iter::{self, Zip};\n#[cfg(feature = \"use_std\")]\ntype VecIntoIter<T> = ::std::vec::IntoIter<T>;\n\n#[cfg(feature = \"use_std\")]\nuse crate::Itertools;\n\npub use crate::adaptors::{\n    interleave,\n    merge,\n    put_back,\n};\n#[cfg(feature = \"use_std\")]\npub use crate::put_back_n_impl::put_back_n;\n#[cfg(feature = \"use_std\")]\npub use crate::multipeek_impl::multipeek;\n#[cfg(feature = \"use_std\")]\npub use crate::peek_nth::peek_nth;\n#[cfg(feature = \"use_std\")]\npub use crate::kmerge_impl::kmerge;\npub use crate::zip_eq_impl::zip_eq;\npub use crate::merge_join::merge_join_by;\n#[cfg(feature = \"use_std\")]\npub use crate::rciter_impl::rciter;\n\n/// Iterate `iterable` with a running index.\n///\n/// `IntoIterator` enabled version of `.enumerate()`.\n///\n/// ```\n/// use itertools::enumerate;\n///\n/// for (i, elt) in enumerate(&[1, 2, 3]) {\n///     /* loop body */\n/// }\n/// ```\npub fn enumerate<I>(iterable: I) -> iter::Enumerate<I::IntoIter>\n    where I: IntoIterator\n{\n    iterable.into_iter().enumerate()\n}\n\n/// Iterate `iterable` in reverse.\n///\n/// `IntoIterator` enabled version of `.rev()`.\n///\n/// ```\n/// use itertools::rev;\n///\n/// for elt in rev(&[1, 2, 3]) {\n///     /* loop body */\n/// }\n/// ```\npub fn rev<I>(iterable: I) -> iter::Rev<I::IntoIter>\n    where I: IntoIterator,\n          I::IntoIter: DoubleEndedIterator\n{\n    iterable.into_iter().rev()\n}\n\n/// Iterate `i` and `j` in lock step.\n///\n/// `IntoIterator` enabled version of `i.zip(j)`.\n///\n/// ```\n/// use itertools::zip;\n///\n/// let data = [1, 2, 3, 4, 5];\n/// for (a, b) in zip(&data, &data[1..]) {\n///     /* loop body */\n/// }\n/// ```\npub fn zip<I, J>(i: I, j: J) -> Zip<I::IntoIter, J::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator\n{\n    i.into_iter().zip(j)\n}\n\n/// Create an iterator that first iterates `i` and then `j`.\n///\n/// `IntoIterator` enabled version of `i.chain(j)`.\n///\n/// ```\n/// use itertools::chain;\n///\n/// for elt in chain(&[1, 2, 3], &[4]) {\n///     /* loop body */\n/// }\n/// ```\npub fn chain<I, J>(i: I, j: J) -> iter::Chain<<I as IntoIterator>::IntoIter, <J as IntoIterator>::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator<Item = I::Item>\n{\n    i.into_iter().chain(j)\n}\n\n/// Create an iterator that clones each element from &T to T\n///\n/// `IntoIterator` enabled version of `i.cloned()`.\n///\n/// ```\n/// use itertools::cloned;\n///\n/// assert_eq!(cloned(b\"abc\").next(), Some(b'a'));\n/// ```\npub fn cloned<'a, I, T: 'a>(iterable: I) -> iter::Cloned<I::IntoIter>\n    where I: IntoIterator<Item=&'a T>,\n          T: Clone,\n{\n    iterable.into_iter().cloned()\n}\n\n/// Perform a fold operation over the iterable.\n///\n/// `IntoIterator` enabled version of `i.fold(init, f)`\n///\n/// ```\n/// use itertools::fold;\n///\n/// assert_eq!(fold(&[1., 2., 3.], 0., |a, &b| f32::max(a, b)), 3.);\n/// ```\npub fn fold<I, B, F>(iterable: I, init: B, f: F) -> B\n    where I: IntoIterator,\n          F: FnMut(B, I::Item) -> B\n{\n    iterable.into_iter().fold(init, f)\n}\n\n/// Test whether the predicate holds for all elements in the iterable.\n///\n/// `IntoIterator` enabled version of `i.all(f)`\n///\n/// ```\n/// use itertools::all;\n///\n/// assert!(all(&[1, 2, 3], |elt| *elt > 0));\n/// ```\npub fn all<I, F>(iterable: I, f: F) -> bool\n    where I: IntoIterator,\n          F: FnMut(I::Item) -> bool\n{\n    iterable.into_iter().all(f)\n}\n\n/// Test whether the predicate holds for any elements in the iterable.\n///\n/// `IntoIterator` enabled version of `i.any(f)`\n///\n/// ```\n/// use itertools::any;\n///\n/// assert!(any(&[0, -1, 2], |elt| *elt > 0));\n/// ```\npub fn any<I, F>(iterable: I, f: F) -> bool\n    where I: IntoIterator,\n          F: FnMut(I::Item) -> bool\n{\n    iterable.into_iter().any(f)\n}\n\n/// Return the maximum value of the iterable.\n///\n/// `IntoIterator` enabled version of `i.max()`.\n///\n/// ```\n/// use itertools::max;\n///\n/// assert_eq!(max(0..10), Some(9));\n/// ```\npub fn max<I>(iterable: I) -> Option<I::Item>\n    where I: IntoIterator,\n          I::Item: Ord\n{\n    iterable.into_iter().max()\n}\n\n/// Return the minimum value of the iterable.\n///\n/// `IntoIterator` enabled version of `i.min()`.\n///\n/// ```\n/// use itertools::min;\n///\n/// assert_eq!(min(0..10), Some(0));\n/// ```\npub fn min<I>(iterable: I) -> Option<I::Item>\n    where I: IntoIterator,\n          I::Item: Ord\n{\n    iterable.into_iter().min()\n}\n\n\n/// Combine all iterator elements into one String, seperated by `sep`.\n///\n/// `IntoIterator` enabled version of `iterable.join(sep)`.\n///\n/// ```\n/// use itertools::join;\n///\n/// assert_eq!(join(&[1, 2, 3], \", \"), \"1, 2, 3\");\n/// ```\n#[cfg(feature = \"use_std\")]\npub fn join<I>(iterable: I, sep: &str) -> String\n    where I: IntoIterator,\n          I::Item: Display\n{\n    iterable.into_iter().join(sep)\n}\n\n/// Sort all iterator elements into a new iterator in ascending order.\n///\n/// `IntoIterator` enabled version of [`iterable.sorted()`][1].\n///\n/// [1]: trait.Itertools.html#method.sorted\n///\n/// ```\n/// use itertools::sorted;\n/// use itertools::assert_equal;\n///\n/// assert_equal(sorted(\"rust\".chars()), \"rstu\".chars());\n/// ```\n#[cfg(feature = \"use_std\")]\npub fn sorted<I>(iterable: I) -> VecIntoIter<I::Item>\n    where I: IntoIterator,\n          I::Item: Ord\n{\n    iterable.into_iter().sorted()\n}\n\n","traces":[{"line":44,"address":[5001808],"length":1,"stats":{"Line":1},"fn_name":"enumerate<&alloc::vec::Vec<u8>>"},{"line":47,"address":[5001820],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[5001584,5001472],"length":1,"stats":{"Line":1},"fn_name":"zip<&[i32],&[i32]>"},{"line":84,"address":[5001499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[5001728,5001648],"length":1,"stats":{"Line":3},"fn_name":"cloned<&alloc::vec::Vec<i8>,i8>"},{"line":118,"address":[5001737,5001657],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","kms","itertools","src","group_map.rs"],"content":"#![cfg(feature = \"use_std\")]\n\nuse std::collections::HashMap;\nuse std::hash::Hash;\nuse std::iter::Iterator;\n\n/// Return a `HashMap` of keys mapped to a list of their corresponding values.\n///\n/// See [`.into_group_map()`](../trait.Itertools.html#method.into_group_map)\n/// for more information.\npub fn into_group_map<I, K, V>(iter: I) -> HashMap<K, Vec<V>>\n    where I: Iterator<Item=(K, V)>,\n          K: Hash + Eq,\n{\n    let mut lookup = HashMap::new();\n\n    for (key, val) in iter {\n        lookup.entry(key).or_insert(Vec::new()).push(val);\n    }\n\n    lookup\n}","traces":[{"line":11,"address":[5811312,5811400],"length":1,"stats":{"Line":1},"fn_name":"into_group_map<core::iter::adapters::Map<alloc::vec::IntoIter<u8>, closure-0>,u8,u8>"},{"line":15,"address":[5811322],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[5812031,5811537,5811889,5811415,5812114],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[5811762,5812083,5812138],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[5811899],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":5,"coverable":5},{"path":["/","home","kms","itertools","src","groupbylazy.rs"],"content":"use std::cell::{Cell, RefCell};\nuse std::vec;\n\n/// A trait to unify FnMut for GroupBy with the chunk key in IntoChunks\ntrait KeyFunction<A> {\n    type Key;\n    fn call_mut(&mut self, arg: A) -> Self::Key;\n}\n\nimpl<'a, A, K, F: ?Sized> KeyFunction<A> for F\n    where F: FnMut(A) -> K\n{\n    type Key = K;\n    #[inline]\n    fn call_mut(&mut self, arg: A) -> Self::Key {\n        (*self)(arg)\n    }\n}\n\n\n/// ChunkIndex acts like the grouping key function for IntoChunks\n#[derive(Debug)]\nstruct ChunkIndex {\n    size: usize,\n    index: usize,\n    key: usize,\n}\n\nimpl ChunkIndex {\n    #[inline(always)]\n    fn new(size: usize) -> Self {\n        ChunkIndex {\n            size,\n            index: 0,\n            key: 0,\n        }\n    }\n}\n\nimpl<'a, A> KeyFunction<A> for ChunkIndex {\n    type Key = usize;\n    #[inline(always)]\n    fn call_mut(&mut self, _arg: A) -> Self::Key {\n        if self.index == self.size {\n            self.key += 1;\n            self.index = 0;\n        }\n        self.index += 1;\n        self.key\n    }\n}\n\n\nstruct GroupInner<K, I, F>\n    where I: Iterator\n{\n    key: F,\n    iter: I,\n    current_key: Option<K>,\n    current_elt: Option<I::Item>,\n    /// flag set if iterator is exhausted\n    done: bool,\n    /// Index of group we are currently buffering or visiting\n    top_group: usize,\n    /// Least index for which we still have elements buffered\n    oldest_buffered_group: usize,\n    /// Group index for `buffer[0]` -- the slots\n    /// bottom_group..oldest_buffered_group are unused and will be erased when\n    /// that range is large enough.\n    bottom_group: usize,\n    /// Buffered groups, from `bottom_group` (index 0) to `top_group`.\n    buffer: Vec<vec::IntoIter<I::Item>>,\n    /// index of last group iter that was dropped, usize::MAX == none\n    dropped_group: usize,\n}\n\nimpl<K, I, F> GroupInner<K, I, F>\n    where I: Iterator,\n          F: for<'a> KeyFunction<&'a I::Item, Key=K>,\n          K: PartialEq,\n{\n    /// `client`: Index of group that requests next element\n    #[inline(always)]\n    fn step(&mut self, client: usize) -> Option<I::Item> {\n        /*\n        println!(\"client={}, bottom_group={}, oldest_buffered_group={}, top_group={}, buffers=[{}]\",\n                 client, self.bottom_group, self.oldest_buffered_group,\n                 self.top_group,\n                 self.buffer.iter().map(|elt| elt.len()).format(\", \"));\n        */\n        if client < self.oldest_buffered_group {\n            None\n        } else if client < self.top_group ||\n            (client == self.top_group &&\n             self.buffer.len() > self.top_group - self.bottom_group)\n        {\n            self.lookup_buffer(client)\n        } else if self.done {\n            None\n        } else if self.top_group == client {\n            self.step_current()\n        } else {\n            self.step_buffering(client)\n        }\n    }\n\n    #[inline(never)]\n    fn lookup_buffer(&mut self, client: usize) -> Option<I::Item> {\n        // if `bufidx` doesn't exist in self.buffer, it might be empty\n        let bufidx = client - self.bottom_group;\n        if client < self.oldest_buffered_group {\n            return None;\n        }\n        let elt = self.buffer.get_mut(bufidx).and_then(|queue| queue.next());\n        if elt.is_none() && client == self.oldest_buffered_group {\n            // FIXME: VecDeque is unfortunately not zero allocation when empty,\n            // so we do this job manually.\n            // `bottom_group..oldest_buffered_group` is unused, and if it's large enough, erase it.\n            self.oldest_buffered_group += 1;\n            // skip forward further empty queues too\n            while self.buffer.get(self.oldest_buffered_group - self.bottom_group)\n                             .map_or(false, |buf| buf.len() == 0)\n            {\n                self.oldest_buffered_group += 1;\n            }\n\n            let nclear = self.oldest_buffered_group - self.bottom_group;\n            if nclear > 0 && nclear >= self.buffer.len() / 2 {\n                let mut i = 0;\n                self.buffer.retain(|buf| {\n                    i += 1;\n                    debug_assert!(buf.len() == 0 || i > nclear);\n                    i > nclear\n                });\n                self.bottom_group = self.oldest_buffered_group;\n            }\n        }\n        elt\n    }\n\n    /// Take the next element from the iterator, and set the done\n    /// flag if exhausted. Must not be called after done.\n    #[inline(always)]\n    fn next_element(&mut self) -> Option<I::Item> {\n        debug_assert!(!self.done);\n        match self.iter.next() {\n            None => { self.done = true; None }\n            otherwise => otherwise,\n        }\n    }\n\n\n    #[inline(never)]\n    fn step_buffering(&mut self, client: usize) -> Option<I::Item> {\n        // requested a later group -- walk through the current group up to\n        // the requested group index, and buffer the elements (unless\n        // the group is marked as dropped).\n        // Because the `Groups` iterator is always the first to request\n        // each group index, client is the next index efter top_group.\n        debug_assert!(self.top_group + 1 == client);\n        let mut group = Vec::new();\n\n        if let Some(elt) = self.current_elt.take() {\n            if self.top_group != self.dropped_group {\n                group.push(elt);\n            }\n        }\n        let mut first_elt = None; // first element of the next group\n\n        while let Some(elt) = self.next_element() {\n            let key = self.key.call_mut(&elt);\n            match self.current_key.take() {\n                None => {}\n                Some(old_key) => if old_key != key {\n                    self.current_key = Some(key);\n                    first_elt = Some(elt);\n                    break;\n                },\n            }\n            self.current_key = Some(key);\n            if self.top_group != self.dropped_group {\n                group.push(elt);\n            }\n        }\n\n        if self.top_group != self.dropped_group {\n            self.push_next_group(group);\n        }\n        if first_elt.is_some() {\n            self.top_group += 1;\n            debug_assert!(self.top_group == client);\n        }\n        first_elt\n    }\n\n    fn push_next_group(&mut self, group: Vec<I::Item>) {\n        // When we add a new buffered group, fill up slots between oldest_buffered_group and top_group\n        while self.top_group - self.bottom_group > self.buffer.len() {\n            if self.buffer.is_empty() {\n                self.bottom_group += 1;\n                self.oldest_buffered_group += 1;\n            } else {\n                self.buffer.push(Vec::new().into_iter());\n            }\n        }\n        self.buffer.push(group.into_iter());\n        debug_assert!(self.top_group + 1 - self.bottom_group == self.buffer.len());\n    }\n\n    /// This is the immediate case, where we use no buffering\n    #[inline]\n    fn step_current(&mut self) -> Option<I::Item> {\n        debug_assert!(!self.done);\n        if let elt @ Some(..) = self.current_elt.take() {\n            return elt;\n        }\n        match self.next_element() {\n            None => None,\n            Some(elt) => {\n                let key = self.key.call_mut(&elt);\n                match self.current_key.take() {\n                    None => {}\n                    Some(old_key) => if old_key != key {\n                        self.current_key = Some(key);\n                        self.current_elt = Some(elt);\n                        self.top_group += 1;\n                        return None;\n                    },\n                }\n                self.current_key = Some(key);\n                Some(elt)\n            }\n        }\n    }\n\n    /// Request the just started groups' key.\n    ///\n    /// `client`: Index of group\n    ///\n    /// **Panics** if no group key is available.\n    fn group_key(&mut self, client: usize) -> K {\n        // This can only be called after we have just returned the first\n        // element of a group.\n        // Perform this by simply buffering one more element, grabbing the\n        // next key.\n        debug_assert!(!self.done);\n        debug_assert!(client == self.top_group);\n        debug_assert!(self.current_key.is_some());\n        debug_assert!(self.current_elt.is_none());\n        let old_key = self.current_key.take().unwrap();\n        if let Some(elt) = self.next_element() {\n            let key = self.key.call_mut(&elt);\n            if old_key != key {\n                self.top_group += 1;\n            }\n            self.current_key = Some(key);\n            self.current_elt = Some(elt);\n        }\n        old_key\n    }\n}\n\nimpl<K, I, F> GroupInner<K, I, F>\n    where I: Iterator,\n{\n    /// Called when a group is dropped\n    fn drop_group(&mut self, client: usize) {\n        // It's only useful to track the maximal index\n        if self.dropped_group == !0 || client > self.dropped_group {\n            self.dropped_group = client;\n        }\n    }\n}\n\n/// `GroupBy` is the storage for the lazy grouping operation.\n///\n/// If the groups are consumed in their original order, or if each\n/// group is dropped without keeping it around, then `GroupBy` uses\n/// no allocations. It needs allocations only if several group iterators\n/// are alive at the same time.\n///\n/// This type implements `IntoIterator` (it is **not** an iterator\n/// itself), because the group iterators need to borrow from this\n/// value. It should be stored in a local variable or temporary and\n/// iterated.\n///\n/// See [`.group_by()`](../trait.Itertools.html#method.group_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct GroupBy<K, I, F>\n    where I: Iterator,\n{\n    inner: RefCell<GroupInner<K, I, F>>,\n    // the group iterator's current index. Keep this in the main value\n    // so that simultaneous iterators all use the same state.\n    index: Cell<usize>,\n}\n\n/// Create a new\npub fn new<K, J, F>(iter: J, f: F) -> GroupBy<K, J::IntoIter, F>\n    where J: IntoIterator,\n          F: FnMut(&J::Item) -> K,\n{\n    GroupBy {\n        inner: RefCell::new(GroupInner {\n            key: f,\n            iter: iter.into_iter(),\n            current_key: None,\n            current_elt: None,\n            done: false,\n            top_group: 0,\n            oldest_buffered_group: 0,\n            bottom_group: 0,\n            buffer: Vec::new(),\n            dropped_group: !0,\n        }),\n        index: Cell::new(0),\n    }\n}\n\nimpl<K, I, F> GroupBy<K, I, F>\n    where I: Iterator,\n{\n    /// `client`: Index of group that requests next element\n    fn step(&self, client: usize) -> Option<I::Item>\n        where F: FnMut(&I::Item) -> K,\n              K: PartialEq,\n    {\n        self.inner.borrow_mut().step(client)\n    }\n\n    /// `client`: Index of group\n    fn drop_group(&self, client: usize) {\n        self.inner.borrow_mut().drop_group(client)\n    }\n}\n\nimpl<'a, K, I, F> IntoIterator for &'a GroupBy<K, I, F>\n    where I: Iterator,\n          I::Item: 'a,\n          F: FnMut(&I::Item) -> K,\n          K: PartialEq\n{\n    type Item = (K, Group<'a, K, I, F>);\n    type IntoIter = Groups<'a, K, I, F>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        Groups { parent: self }\n    }\n}\n\n\n/// An iterator that yields the Group iterators.\n///\n/// Iterator element type is `(K, Group)`:\n/// the group's key `K` and the group's iterator.\n///\n/// See [`.group_by()`](../trait.Itertools.html#method.group_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Groups<'a, K: 'a, I: 'a, F: 'a>\n    where I: Iterator,\n          I::Item: 'a\n{\n    parent: &'a GroupBy<K, I, F>,\n}\n\nimpl<'a, K, I, F> Iterator for Groups<'a, K, I, F>\n    where I: Iterator,\n          I::Item: 'a,\n          F: FnMut(&I::Item) -> K,\n          K: PartialEq\n{\n    type Item = (K, Group<'a, K, I, F>);\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let index = self.parent.index.get();\n        self.parent.index.set(index + 1);\n        let inner = &mut *self.parent.inner.borrow_mut();\n        inner.step(index).map(|elt| {\n            let key = inner.group_key(index);\n            (key, Group {\n                parent: self.parent,\n                index,\n                first: Some(elt),\n            })\n        })\n    }\n}\n\n/// An iterator for the elements in a single group.\n///\n/// Iterator element type is `I::Item`.\npub struct Group<'a, K: 'a, I: 'a, F: 'a>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    parent: &'a GroupBy<K, I, F>,\n    index: usize,\n    first: Option<I::Item>,\n}\n\nimpl<'a, K, I, F> Drop for Group<'a, K, I, F>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    fn drop(&mut self) {\n        self.parent.drop_group(self.index);\n    }\n}\n\nimpl<'a, K, I, F> Iterator for Group<'a, K, I, F>\n    where I: Iterator,\n          I::Item: 'a,\n          F: FnMut(&I::Item) -> K,\n          K: PartialEq,\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        if let elt @ Some(..) = self.first.take() {\n            return elt;\n        }\n        self.parent.step(self.index)\n    }\n}\n\n///// IntoChunks /////\n\n/// Create a new\npub fn new_chunks<J>(iter: J, size: usize) -> IntoChunks<J::IntoIter>\n    where J: IntoIterator,\n{\n    IntoChunks {\n        inner: RefCell::new(GroupInner {\n            key: ChunkIndex::new(size),\n            iter: iter.into_iter(),\n            current_key: None,\n            current_elt: None,\n            done: false,\n            top_group: 0,\n            oldest_buffered_group: 0,\n            bottom_group: 0,\n            buffer: Vec::new(),\n            dropped_group: !0,\n        }),\n        index: Cell::new(0),\n    }\n}\n\n\n/// `ChunkLazy` is the storage for a lazy chunking operation.\n///\n/// `IntoChunks` behaves just like `GroupBy`: it is iterable, and\n/// it only buffers if several chunk iterators are alive at the same time.\n///\n/// This type implements `IntoIterator` (it is **not** an iterator\n/// itself), because the chunk iterators need to borrow from this\n/// value. It should be stored in a local variable or temporary and\n/// iterated.\n///\n/// Iterator element type is `Chunk`, each chunk's iterator.\n///\n/// See [`.chunks()`](../trait.Itertools.html#method.chunks) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct IntoChunks<I>\n    where I: Iterator,\n{\n    inner: RefCell<GroupInner<usize, I, ChunkIndex>>,\n    // the chunk iterator's current index. Keep this in the main value\n    // so that simultaneous iterators all use the same state.\n    index: Cell<usize>,\n}\n\n\nimpl<I> IntoChunks<I>\n    where I: Iterator,\n{\n    /// `client`: Index of chunk that requests next element\n    fn step(&self, client: usize) -> Option<I::Item> {\n        self.inner.borrow_mut().step(client)\n    }\n\n    /// `client`: Index of chunk\n    fn drop_group(&self, client: usize) {\n        self.inner.borrow_mut().drop_group(client)\n    }\n}\n\nimpl<'a, I> IntoIterator for &'a IntoChunks<I>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    type Item = Chunk<'a, I>;\n    type IntoIter = Chunks<'a, I>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        Chunks {\n            parent: self,\n        }\n    }\n}\n\n\n/// An iterator that yields the Chunk iterators.\n///\n/// Iterator element type is `Chunk`.\n///\n/// See [`.chunks()`](../trait.Itertools.html#method.chunks) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Chunks<'a, I: 'a>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    parent: &'a IntoChunks<I>,\n}\n\nimpl<'a, I> Iterator for Chunks<'a, I>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    type Item = Chunk<'a, I>;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let index = self.parent.index.get();\n        self.parent.index.set(index + 1);\n        let inner = &mut *self.parent.inner.borrow_mut();\n        inner.step(index).map(|elt| {\n            Chunk {\n                parent: self.parent,\n                index,\n                first: Some(elt),\n            }\n        })\n    }\n}\n\n/// An iterator for the elements in a single chunk.\n///\n/// Iterator element type is `I::Item`.\npub struct Chunk<'a, I: 'a>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    parent: &'a IntoChunks<I>,\n    index: usize,\n    first: Option<I::Item>,\n}\n\nimpl<'a, I> Drop for Chunk<'a, I>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    fn drop(&mut self) {\n        self.parent.drop_group(self.index);\n    }\n}\n\nimpl<'a, I> Iterator for Chunk<'a, I>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        if let elt @ Some(..) = self.first.take() {\n            return elt;\n        }\n        self.parent.step(self.index)\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":79},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":74},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":83},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":73},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":73},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":168,"address":[5494787,5496895,5492675,5498995,5501444],"length":1,"stats":{"Line":10},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":76},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":57},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":299,"address":[5510852,5511728,5511843,5510387,5510272,5511363,5511248,5510752],"length":1,"stats":{"Line":18},"fn_name":"new<u8,core::slice::Iter<u8>,closure-0>"},{"line":304,"address":[5511867,5510871,5510411,5511387],"length":1,"stats":{"Line":18},"fn_name":null},{"line":316,"address":[5511592,5510616,5511116,5512072],"length":1,"stats":{"Line":18},"fn_name":null},{"line":324,"address":[5475424,5477056,5475463,5475968,5477095,5476512,5476548,5476007],"length":1,"stats":{"Line":17},"fn_name":"step<u8,core::slice::Iter<u8>,closure-0>"},{"line":328,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":430,"address":[5473738,5473632],"length":1,"stats":{"Line":2},"fn_name":"new_chunks<core::slice::Iter<u8>>"},{"line":434,"address":[5473657,5473852],"length":1,"stats":{"Line":4},"fn_name":null},{"line":446,"address":[5474075],"length":1,"stats":{"Line":2},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":151,"coverable":157},{"path":["/","home","kms","itertools","src","impl_macros.rs"],"content":"//! \n//! Implementation's internal macros\n\nmacro_rules! debug_fmt_fields {\n    ($tyname:ident, $($($field:ident).+),*) => {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            f.debug_struct(stringify!($tyname))\n                $(\n              .field(stringify!($($field).+), &self.$($field).+)\n              )*\n              .finish()\n        }\n    }\n}\n\nmacro_rules! clone_fields {\n    ($($field:ident),*) => {\n        fn clone(&self) -> Self {\n            Self {\n                $($field: self.$field.clone(),)*\n            }\n        }\n    }\n}\n","traces":[{"line":18,"address":[4251264,4251216],"length":1,"stats":{"Line":5},"fn_name":"clone<alloc::vec::IntoIter<usize>,alloc::vec::IntoIter<usize>,fn(&usize, &usize) -> core::cmp::Ordering>"},{"line":19,"address":[4251332],"length":1,"stats":{"Line":5},"fn_name":null},{"line":20,"address":[4251279,4251231],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","home","kms","itertools","src","intersperse.rs"],"content":"use std::iter::Fuse;\nuse super::size_hint;\n\n#[derive(Clone)]\n/// An iterator adaptor to insert a particular value\n/// between each element of the adapted iterator.\n///\n/// Iterator element type is `I::Item`\n///\n/// This iterator is *fused*.\n///\n/// See [`.intersperse()`](../trait.Itertools.html#method.intersperse) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Debug)]\npub struct Intersperse<I>\n    where I: Iterator\n{\n    element: I::Item,\n    iter: Fuse<I>,\n    peek: Option<I::Item>,\n}\n\n/// Create a new Intersperse iterator\npub fn intersperse<I>(iter: I, elt: I::Item) -> Intersperse<I>\n    where I: Iterator\n{\n    let mut iter = iter.fuse();\n    Intersperse {\n        peek: iter.next(),\n        iter,\n        element: elt,\n    }\n}\n\nimpl<I> Iterator for Intersperse<I>\n    where I: Iterator,\n          I::Item: Clone\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.peek.is_some() {\n            self.peek.take()\n        } else {\n            self.peek = self.iter.next();\n            if self.peek.is_some() {\n                Some(self.element.clone())\n            } else {\n                None\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // 2 * SH + { 1 or 0 }\n        let has_peek = self.peek.is_some() as usize;\n        let sh = self.iter.size_hint();\n        size_hint::add_scalar(size_hint::add(sh, sh), has_peek)\n    }\n\n    fn fold<B, F>(mut self, init: B, mut f: F) -> B where\n        Self: Sized, F: FnMut(B, Self::Item) -> B,\n    {\n        let mut accum = init;\n        \n        if let Some(x) = self.peek.take() {\n            accum = f(accum, x);\n        }\n\n        let element = &self.element;\n\n        self.iter.fold(accum,\n            |accum, x| {\n                let accum = f(accum, element.clone());\n                let accum = f(accum, x);\n                accum\n        })\n    }\n}\n","traces":[{"line":24,"address":[4210103,4210032],"length":1,"stats":{"Line":5},"fn_name":"intersperse<core::ops::range::Range<i32>>"},{"line":27,"address":[4210051],"length":1,"stats":{"Line":5},"fn_name":null},{"line":29,"address":[5434093,5434307],"length":1,"stats":{"Line":5},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":42,"address":[5433662,5433577,5433721,5433434,5433492,5433353],"length":1,"stats":{"Line":14},"fn_name":null},{"line":43,"address":[5433635,5433409],"length":1,"stats":{"Line":4},"fn_name":null},{"line":45,"address":[4209194,4209315,4209250],"length":1,"stats":{"Line":15},"fn_name":null},{"line":46,"address":[5433526,5433453,5433666,5433680,5433761,5433788,5433553,5433438],"length":1,"stats":{"Line":14},"fn_name":null},{"line":47,"address":[4209269],"length":1,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[4209259],"length":1,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[4208159,4207391,4207712,4208096,4207328,4207775],"length":1,"stats":{"Line":3},"fn_name":"fold<core::ops::range::Range<i32>,(),closure-0>"},{"line":64,"address":[4208105,4207721,4207337],"length":1,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[4207362,4207406,4208212,4208174,4207746,4207828,4208130,4207790,4207444],"length":1,"stats":{"Line":9},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[4207948,4208332,4207564],"length":1,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[4208383,4207615,4207953,4207569,4207999,4208337],"length":1,"stats":{"Line":6},"fn_name":null},{"line":73,"address":[4208928,4208368,4208480,4209029,4207600,4208704,4207984,4208805,4208581],"length":1,"stats":{"Line":5},"fn_name":"{{closure}}<core::ops::range::Range<i32>,(),closure-0>"},{"line":74,"address":[4208826,4208493,4208651,4208717,4208941,4208602,4209050,4209099,4208875],"length":1,"stats":{"Line":4},"fn_name":null},{"line":75,"address":[4208831,4209055,4208607],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":23,"coverable":24},{"path":["/","home","kms","itertools","src","kmerge_impl.rs"],"content":"use crate::size_hint;\nuse crate::Itertools;\n\nuse std::mem::replace;\nuse std::fmt;\n\n/// Head element and Tail iterator pair\n///\n/// `PartialEq`, `Eq`, `PartialOrd` and `Ord` are implemented by comparing sequences based on\n/// first items (which are guaranteed to exist).\n///\n/// The meanings of `PartialOrd` and `Ord` are reversed so as to turn the heap used in\n/// `KMerge` into a min-heap.\n#[derive(Debug)]\nstruct HeadTail<I>\n    where I: Iterator\n{\n    head: I::Item,\n    tail: I,\n}\n\nimpl<I> HeadTail<I>\n    where I: Iterator\n{\n    /// Constructs a `HeadTail` from an `Iterator`. Returns `None` if the `Iterator` is empty.\n    fn new(mut it: I) -> Option<HeadTail<I>> {\n        let head = it.next();\n        head.map(|h| {\n            HeadTail {\n                head: h,\n                tail: it,\n            }\n        })\n    }\n\n    /// Get the next element and update `head`, returning the old head in `Some`.\n    ///\n    /// Returns `None` when the tail is exhausted (only `head` then remains).\n    fn next(&mut self) -> Option<I::Item> {\n        if let Some(next) = self.tail.next() {\n            Some(replace(&mut self.head, next))\n        } else {\n            None\n        }\n    }\n\n    /// Hints at the size of the sequence, same as the `Iterator` method.\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add_scalar(self.tail.size_hint(), 1)\n    }\n}\n\nimpl<I> Clone for HeadTail<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    clone_fields!(head, tail);\n}\n\n/// Make `data` a heap (min-heap w.r.t the sorting).\nfn heapify<T, S>(data: &mut [T], mut less_than: S)\n    where S: FnMut(&T, &T) -> bool\n{\n    for i in (0..data.len() / 2).rev() {\n        sift_down(data, i, &mut less_than);\n    }\n}\n\n/// Sift down element at `index` (`heap` is a min-heap wrt the ordering)\nfn sift_down<T, S>(heap: &mut [T], index: usize, mut less_than: S)\n    where S: FnMut(&T, &T) -> bool\n{\n    debug_assert!(index <= heap.len());\n    let mut pos = index;\n    let mut child = 2 * pos + 1;\n    // the `pos` conditional is to avoid a bounds check\n    while pos < heap.len() && child < heap.len() {\n        let right = child + 1;\n\n        // pick the smaller of the two children\n        if right < heap.len() && less_than(&heap[right], &heap[child]) {\n            child = right;\n        }\n\n        // sift down is done if we are already in order\n        if !less_than(&heap[child], &heap[pos]) {\n            return;\n        }\n        heap.swap(pos, child);\n        pos = child;\n        child = 2 * pos + 1;\n    }\n}\n\n/// An iterator adaptor that merges an abitrary number of base iterators in ascending order.\n/// If all base iterators are sorted (ascending), the result is sorted.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.kmerge()`](../trait.Itertools.html#method.kmerge) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub type KMerge<I> = KMergeBy<I, KMergeByLt>;\n\npub trait KMergePredicate<T> {\n    fn kmerge_pred(&mut self, a: &T, b: &T) -> bool;\n}\n\n#[derive(Clone)]\npub struct KMergeByLt;\n\nimpl<T: PartialOrd> KMergePredicate<T> for KMergeByLt {\n    fn kmerge_pred(&mut self, a: &T, b: &T) -> bool {\n        a < b\n    }\n}\n\nimpl<T, F: FnMut(&T, &T)->bool> KMergePredicate<T> for F {\n    fn kmerge_pred(&mut self, a: &T, b: &T) -> bool {\n        self(a, b)\n    }\n}\n\n/// Create an iterator that merges elements of the contained iterators using\n/// the ordering function.\n///\n/// Equivalent to `iterable.into_iter().kmerge()`.\n///\n/// ```\n/// use itertools::kmerge;\n///\n/// for elt in kmerge(vec![vec![0, 2, 4], vec![1, 3, 5], vec![6, 7]]) {\n///     /* loop body */\n/// }\n/// ```\npub fn kmerge<I>(iterable: I) -> KMerge<<I::Item as IntoIterator>::IntoIter>\n    where I: IntoIterator,\n          I::Item: IntoIterator,\n          <<I as IntoIterator>::Item as IntoIterator>::Item: PartialOrd\n{\n    kmerge_by(iterable, KMergeByLt)\n}\n\n/// An iterator adaptor that merges an abitrary number of base iterators\n/// according to an ordering function.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.kmerge_by()`](../trait.Itertools.html#method.kmerge_by) for more\n/// information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct KMergeBy<I, F>\n    where I: Iterator,\n{\n    heap: Vec<HeadTail<I>>,\n    less_than: F,\n}\n\nimpl<I, F> fmt::Debug for KMergeBy<I, F>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(KMergeBy, heap);\n}\n\n/// Create an iterator that merges elements of the contained iterators.\n///\n/// Equivalent to `iterable.into_iter().kmerge_by(less_than)`.\npub fn kmerge_by<I, F>(iterable: I, mut less_than: F)\n    -> KMergeBy<<I::Item as IntoIterator>::IntoIter, F>\n    where I: IntoIterator,\n          I::Item: IntoIterator,\n          F: KMergePredicate<<<I as IntoIterator>::Item as IntoIterator>::Item>,\n{\n    let iter = iterable.into_iter();\n    let (lower, _) = iter.size_hint();\n    let mut heap: Vec<_> = Vec::with_capacity(lower);\n    heap.extend(iter.filter_map(|it| HeadTail::new(it.into_iter())));\n    heapify(&mut heap, |a, b| less_than.kmerge_pred(&a.head, &b.head));\n    KMergeBy { heap, less_than }\n}\n\nimpl<I, F> Clone for KMergeBy<I, F>\n    where I: Iterator + Clone,\n          I::Item: Clone,\n          F: Clone,\n{\n    clone_fields!(heap, less_than);\n}\n\nimpl<I, F> Iterator for KMergeBy<I, F>\n    where I: Iterator,\n          F: KMergePredicate<I::Item>\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.heap.is_empty() {\n            return None;\n        }\n        let result = if let Some(next) = self.heap[0].next() {\n            next\n        } else {\n            self.heap.swap_remove(0).head\n        };\n        let less_than = &mut self.less_than;\n        sift_down(&mut self.heap, 0, |a, b| less_than.kmerge_pred(&a.head, &b.head));\n        Some(result)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.heap.iter()\n                 .map(|i| i.size_hint())\n                 .fold1(size_hint::add)\n                 .unwrap_or((0, Some(0)))\n    }\n}\n","traces":[{"line":26,"address":[4704560,4704420,4704368,4704616],"length":1,"stats":{"Line":5},"fn_name":"new<quick::Iter<i16, quick::Inexact>>"},{"line":27,"address":[4704633,4704437,4704375,4704567],"length":1,"stats":{"Line":10},"fn_name":null},{"line":28,"address":[4704648,4704752,4704848,4704452],"length":1,"stats":{"Line":10},"fn_name":"{{closure}}<alloc::vec::IntoIter<i16>>"},{"line":29,"address":[4704891,4704804],"length":1,"stats":{"Line":5},"fn_name":null},{"line":30,"address":[4704860,4704764],"length":1,"stats":{"Line":5},"fn_name":null},{"line":31,"address":[4704769,4704865],"length":1,"stats":{"Line":5},"fn_name":null},{"line":39,"address":[4705197,4705152,4704928,4704969],"length":1,"stats":{"Line":4},"fn_name":"next<quick::Iter<i16, quick::Inexact>>"},{"line":40,"address":[4704981,4705161,4705001,4704937,4705209,4705229],"length":1,"stats":{"Line":13},"fn_name":null},{"line":41,"address":[4705018,4705246],"length":1,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[4705388],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[4705920,4706972,4706928,4706256,4706636,4705628,4706300,4706592,4705584,4705964],"length":1,"stats":{"Line":11},"fn_name":"heapify<itertools::kmerge_impl::HeadTail<alloc::vec::IntoIter<i16>>,closure-1>"},{"line":64,"address":[4706558,4705984,4706222,4705886,4706656,4706820,4707156,4705812,4706278,4705942,4705698,4707230,4706370,4706614,4706484,4705606,4706894,4705648,4706034,4706148,4706706,4706950,4707042,4706992,4706320],"length":1,"stats":{"Line":42},"fn_name":null},{"line":65,"address":[4707200,4705856,4706864,4706192,4706528],"length":1,"stats":{"Line":9},"fn_name":null},{"line":70,"address":[4713648,4721008,4724038,4716678,4710704,4712176,4718150,4722566,4719622,4715206,4722480,4718064,4723952,4713734,4712262,4716592,4715120,4719536,4710790,4721094],"length":1,"stats":{"Line":16},"fn_name":"sift_down<itertools::kmerge_impl::HeadTail<alloc::vec::IntoIter<i16>>,&mut closure-1>"},{"line":73,"address":[4715237,4713765,4719575,4723991,4719653,4710743,4712215,4716631,4718103,4721047,4710821,4712293,4713687,4715159,4721125,4722597,4724069,4718181,4722519,4716709],"length":1,"stats":{"Line":32},"fn_name":null},{"line":74,"address":[4719671,4716727,4710839,4721143,4722615,4713783,4712311,4715255,4718199,4724087],"length":1,"stats":{"Line":16},"fn_name":null},{"line":75,"address":[4725143,4720727,4712327,4713880,4713359,4719255,4721159,4715271,4719768,4719687,4717783,4715352,4722712,4710936,4724103,4711895,4721240,4716824,4722631,4716311,4718296,4713799,4723671,4714831,4716743,4710855,4724184,4722199,4712408,4718215],"length":1,"stats":{"Line":32},"fn_name":null},{"line":77,"address":[4715394,4725116,4723644,4716284,4714804,4721282,4719228,4719810,4717756,4712450,4713922,4720700,4716866,4722754,4713332,4718338,4711868,4722172,4724226,4710978],"length":1,"stats":{"Line":29},"fn_name":null},{"line":78,"address":[4716371,4724403,4718515,4719315,4723731,4722931,4720787,4712627,4717043,4725203,4714891,4715571,4722259,4711155,4711955,4717843,4714099,4713419,4719987,4721459],"length":1,"stats":{"Line":16},"fn_name":null},{"line":81,"address":[4715621,4711205,4714921,4716401,4718565,4724453,4722289,4717093,4714149,4711985,4720817,4721509,4722981,4725233,4713449,4712677,4719345,4717873,4720037,4723761],"length":1,"stats":{"Line":16},"fn_name":null},{"line":82,"address":[4720345,4711513,4724761,4715929,4712981,4717401,4718873,4723289,4721817,4714453],"length":1,"stats":{"Line":12},"fn_name":null},{"line":86,"address":[4712044,4715945,4717932,4723305,4723820,4725292,4717417,4714469,4720876,4716460,4722348,4711529,4724777,4718889,4721833,4720361,4714980,4712997,4713508,4719404],"length":1,"stats":{"Line":15},"fn_name":null},{"line":89,"address":[4720559,4714663,4716143,4723503,4719087,4713191,4722031,4711727,4717615,4724975],"length":1,"stats":{"Line":12},"fn_name":null},{"line":90,"address":[4716192,4720608,4713240,4717664,4725024,4711776,4714712,4722080,4719136,4723552],"length":1,"stats":{"Line":13},"fn_name":null},{"line":91,"address":[4717994,4719532,4712106,4719466,4725420,4719152,4715042,4713256,4722410,4711792,4716588,4722476,4721004,4720938,4725040,4712172,4713570,4717680,4723568,4716522,4718060,4714728,4723882,4722096,4725354,4713636,4715108,4720624,4723948,4716208],"length":1,"stats":{"Line":13},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":135,"address":[4705520,4705456],"length":1,"stats":{"Line":7},"fn_name":"kmerge<alloc::vec::Vec<alloc::vec::Vec<i16>>>"},{"line":140,"address":[4705463,4705527],"length":1,"stats":{"Line":7},"fn_name":null},{"line":168,"address":[4709312,4707354,4708893,4708800,4709402,4707869,4708288,4707264,4707776,4708381],"length":1,"stats":{"Line":10},"fn_name":"kmerge_by<alloc::vec::Vec<alloc::vec::Vec<i16>>,itertools::kmerge_impl::KMergeByLt>"},{"line":174,"address":[4708298,4708810,4707274,4707786,4709322],"length":1,"stats":{"Line":10},"fn_name":null},{"line":175,"address":[4709419,4708398,4709395,4707371,4707886,4708374,4708886,4707862,4708910,4707347],"length":1,"stats":{"Line":20},"fn_name":null},{"line":176,"address":[4707381,4707899,4708923,4709429,4708411],"length":1,"stats":{"Line":10},"fn_name":null},{"line":177,"address":[4707401,4710012,4710096,4710352,4708431,4709449,4709904,4710528,4710000,4710108,4710540,4709916,4707919,4708943,4710364],"length":1,"stats":{"Line":33},"fn_name":"{{closure}}<alloc::vec::IntoIter<alloc::vec::Vec<i16>>,closure-0>"},{"line":178,"address":[4710467,4708025,4710291,4710448,4707507,4709049,4710192,4708537,4710211,4709555,4710624,4709824,4709843,4710272,4710643],"length":1,"stats":{"Line":29},"fn_name":"{{closure}}<alloc::vec::Vec<quick::Iter<i16, quick::Inexact>>,itertools::kmerge_impl::KMergeByLt>"},{"line":196,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":52,"coverable":53},{"path":["/","home","kms","itertools","src","lazy_buffer.rs"],"content":"use std::ops::Index;\n\n#[derive(Debug, Clone)]\npub struct LazyBuffer<I: Iterator> {\n    pub it: I,\n    done: bool,\n    buffer: Vec<I::Item>,\n}\n\nimpl<I> LazyBuffer<I>\nwhere\n    I: Iterator,\n{\n    pub fn new(it: I) -> LazyBuffer<I> {\n        LazyBuffer {\n            it,\n            done: false,\n            buffer: Vec::new(),\n        }\n    }\n\n    pub fn len(&self) -> usize {\n        self.buffer.len()\n    }\n\n    pub fn is_done(&self) -> bool {\n        self.done\n    }\n\n    pub fn get_next(&mut self) -> bool {\n        if self.done {\n            return false;\n        }\n        let next_item = self.it.next();\n        match next_item {\n            Some(x) => {\n                self.buffer.push(x);\n                true\n            }\n            None => {\n                self.done = true;\n                false\n            }\n        }\n    }\n}\n\nimpl<I, J> Index<J> for LazyBuffer<I>\nwhere\n    I: Iterator,\n    I::Item: Sized,\n    Vec<I::Item>: Index<J>\n{\n    type Output = <Vec<I::Item> as Index<J>>::Output;\n\n    fn index(&self, _index: J) -> &Self::Output {\n        self.buffer.index(_index)\n    }\n}\n","traces":[{"line":14,"address":[4762768,4762640,4762480,4762320,4762447,4762608],"length":1,"stats":{"Line":8},"fn_name":"new<core::ops::range::Range<usize>>"},{"line":18,"address":[4762347,4762523,4762683],"length":1,"stats":{"Line":8},"fn_name":null},{"line":22,"address":[4207552],"length":1,"stats":{"Line":5},"fn_name":"len<adaptors_no_collect::PanickingCounter>"},{"line":23,"address":[4207561],"length":1,"stats":{"Line":5},"fn_name":null},{"line":26,"address":[4207760],"length":1,"stats":{"Line":3},"fn_name":"is_done<adaptors_no_collect::PanickingCounter>"},{"line":27,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":30,"address":[4207792,4207817],"length":1,"stats":{"Line":7},"fn_name":"get_next<adaptors_no_collect::PanickingCounter>"},{"line":31,"address":[4763321,4762809,4763048],"length":1,"stats":{"Line":7},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[4207829],"length":1,"stats":{"Line":8},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":36,"address":[4207873,4207906],"length":1,"stats":{"Line":17},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":38,"address":[4763197,4763468,4762964],"length":1,"stats":{"Line":8},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":5},"fn_name":null}],"covered":18,"coverable":19},{"path":["/","home","kms","itertools","src","lib.rs"],"content":"#![warn(missing_docs)]\n#![crate_name=\"itertools\"]\n#![cfg_attr(not(feature = \"use_std\"), no_std)]\n\n//! Extra iterator adaptors, functions and macros.\n//!\n//! To extend [`Iterator`] with methods in this crate, import\n//! the [`Itertools` trait](./trait.Itertools.html):\n//!\n//! ```\n//! use itertools::Itertools;\n//! ```\n//!\n//! Now, new methods like [`interleave`](./trait.Itertools.html#method.interleave)\n//! are available on all iterators:\n//!\n//! ```\n//! use itertools::Itertools;\n//!\n//! let it = (1..3).interleave(vec![-1, -2]);\n//! itertools::assert_equal(it, vec![1, -1, 2, -2]);\n//! ```\n//!\n//! Most iterator methods are also provided as functions (with the benefit\n//! that they convert parameters using [`IntoIterator`]):\n//!\n//! ```\n//! use itertools::interleave;\n//!\n//! for elt in interleave(&[1, 2, 3], &[2, 3, 4]) {\n//!     /* loop body */\n//! }\n//! ```\n//!\n//! ## Crate Features\n//!\n//! - `use_std`\n//!   - Enabled by default.\n//!   - Disable to compile itertools using `#![no_std]`. This disables\n//!     any items that depend on collections (like `group_by`, `unique`,\n//!     `kmerge`, `join` and many more).\n//!\n//! ## Rust Version\n//!\n//! This version of itertools requires Rust 1.32 or later.\n//!\n//! [`Iterator`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html\n#![doc(html_root_url=\"https://docs.rs/itertools/0.8/\")]\n\n#[cfg(not(feature = \"use_std\"))]\nextern crate core as std;\n\npub use either::Either;\n\n#[cfg(feature = \"use_std\")]\nuse std::collections::HashMap;\nuse std::iter::{IntoIterator, once};\nuse std::cmp::Ordering;\nuse std::fmt;\n#[cfg(feature = \"use_std\")]\nuse std::hash::Hash;\n#[cfg(feature = \"use_std\")]\nuse std::fmt::Write;\n#[cfg(feature = \"use_std\")]\ntype VecIntoIter<T> = ::std::vec::IntoIter<T>;\n#[cfg(feature = \"use_std\")]\nuse std::iter::FromIterator;\n\n#[macro_use]\nmod impl_macros;\n\n// for compatibility with no std and macros\n#[doc(hidden)]\npub use std::iter as __std_iter;\n\n/// The concrete iterator types.\npub mod structs {\n    pub use crate::adaptors::{\n        Dedup,\n        DedupBy,\n        DedupWithCount,\n        DedupByWithCount,\n        Interleave,\n        InterleaveShortest,\n        Product,\n        PutBack,\n        Batching,\n        MapInto,\n        MapResults,\n        Merge,\n        MergeBy,\n        TakeWhileRef,\n        WhileSome,\n        Coalesce,\n        TupleCombinations,\n        Positions,\n        Update,\n    };\n    #[allow(deprecated)]\n    pub use crate::adaptors::Step;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::adaptors::MultiProduct;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::combinations::Combinations;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::combinations_with_replacement::CombinationsWithReplacement;\n    pub use crate::cons_tuples_impl::ConsTuples;\n    pub use crate::exactly_one_err::ExactlyOneError;\n    pub use crate::format::{Format, FormatWith};\n    #[cfg(feature = \"use_std\")]\n    pub use crate::groupbylazy::{IntoChunks, Chunk, Chunks, GroupBy, Group, Groups};\n    pub use crate::intersperse::Intersperse;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::kmerge_impl::{KMerge, KMergeBy};\n    pub use crate::merge_join::MergeJoinBy;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::multipeek_impl::MultiPeek;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::peek_nth::PeekNth;\n    pub use crate::pad_tail::PadUsing;\n    pub use crate::peeking_take_while::PeekingTakeWhile;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::permutations::Permutations;\n    pub use crate::process_results_impl::ProcessResults;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::put_back_n_impl::PutBackN;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::rciter_impl::RcIter;\n    pub use crate::repeatn::RepeatN;\n    #[allow(deprecated)]\n    pub use crate::sources::{RepeatCall, Unfold, Iterate};\n    #[cfg(feature = \"use_std\")]\n    pub use crate::tee::Tee;\n    pub use crate::tuple_impl::{TupleBuffer, TupleWindows, CircularTupleWindows, Tuples};\n    #[cfg(feature = \"use_std\")]\n    pub use crate::unique_impl::{Unique, UniqueBy};\n    pub use crate::with_position::WithPosition;\n    pub use crate::zip_eq_impl::ZipEq;\n    pub use crate::zip_longest::ZipLongest;\n    pub use crate::ziptuple::Zip;\n}\n\n/// Traits helpful for using certain `Itertools` methods in generic contexts.\npub mod traits {\n    pub use crate::tuple_impl::HomogeneousTuple;\n}\n\n#[allow(deprecated)]\npub use crate::structs::*;\npub use crate::concat_impl::concat;\npub use crate::cons_tuples_impl::cons_tuples;\npub use crate::diff::diff_with;\npub use crate::diff::Diff;\n#[cfg(feature = \"use_std\")]\npub use crate::kmerge_impl::{kmerge_by};\npub use crate::minmax::MinMaxResult;\npub use crate::peeking_take_while::PeekingNext;\npub use crate::process_results_impl::process_results;\npub use crate::repeatn::repeat_n;\n#[allow(deprecated)]\npub use crate::sources::{repeat_call, unfold, iterate};\npub use crate::with_position::Position;\npub use crate::ziptuple::multizip;\nmod adaptors;\nmod either_or_both;\npub use crate::either_or_both::EitherOrBoth;\n#[doc(hidden)]\npub mod free;\n#[doc(inline)]\npub use crate::free::*;\nmod concat_impl;\nmod cons_tuples_impl;\n#[cfg(feature = \"use_std\")]\nmod combinations;\n#[cfg(feature = \"use_std\")]\nmod combinations_with_replacement;\nmod exactly_one_err;\nmod diff;\nmod format;\n#[cfg(feature = \"use_std\")]\nmod group_map;\n#[cfg(feature = \"use_std\")]\nmod groupbylazy;\nmod intersperse;\n#[cfg(feature = \"use_std\")]\nmod kmerge_impl;\n#[cfg(feature = \"use_std\")]\nmod lazy_buffer;\nmod merge_join;\nmod minmax;\n#[cfg(feature = \"use_std\")]\nmod multipeek_impl;\nmod pad_tail;\n#[cfg(feature = \"use_std\")]\nmod peek_nth;\nmod peeking_take_while;\n#[cfg(feature = \"use_std\")]\nmod permutations;\nmod process_results_impl;\n#[cfg(feature = \"use_std\")]\nmod put_back_n_impl;\n#[cfg(feature = \"use_std\")]\nmod rciter_impl;\nmod repeatn;\nmod size_hint;\nmod sources;\n#[cfg(feature = \"use_std\")]\nmod tee;\nmod tuple_impl;\n#[cfg(feature = \"use_std\")]\nmod unique_impl;\nmod with_position;\nmod zip_eq_impl;\nmod zip_longest;\nmod ziptuple;\n\n#[macro_export]\n/// Create an iterator over the “cartesian product” of iterators.\n///\n/// Iterator element type is like `(A, B, ..., E)` if formed\n/// from iterators `(I, J, ..., M)` with element types `I::Item = A`, `J::Item = B`, etc.\n///\n/// ```\n/// # use itertools::iproduct;\n/// #\n/// # fn main() {\n/// // Iterate over the coordinates of a 4 x 4 x 4 grid\n/// // from (0, 0, 0), (0, 0, 1), .., (0, 1, 0), (0, 1, 1), .. etc until (3, 3, 3)\n/// for (i, j, k) in iproduct!(0..4, 0..4, 0..4) {\n///    // ..\n/// }\n/// # }\n/// ```\nmacro_rules! iproduct {\n    (@flatten $I:expr,) => (\n        $I\n    );\n    (@flatten $I:expr, $J:expr, $($K:expr,)*) => (\n        iproduct!(@flatten $crate::cons_tuples(iproduct!($I, $J)), $($K,)*)\n    );\n    ($I:expr) => (\n        $crate::__std_iter::IntoIterator::into_iter($I)\n    );\n    ($I:expr, $J:expr) => (\n        $crate::Itertools::cartesian_product(iproduct!($I), iproduct!($J))\n    );\n    ($I:expr, $J:expr, $($K:expr),+) => (\n        iproduct!(@flatten iproduct!($I, $J), $($K,)+)\n    );\n}\n\n#[macro_export]\n/// Create an iterator running multiple iterators in lockstep.\n///\n/// The `izip!` iterator yields elements until any subiterator\n/// returns `None`.\n///\n/// This is a version of the standard ``.zip()`` that's supporting more than\n/// two iterators. The iterator element type is a tuple with one element\n/// from each of the input iterators. Just like ``.zip()``, the iteration stops\n/// when the shortest of the inputs reaches its end.\n///\n/// **Note:** The result of this macro is in the general case an iterator\n/// composed of repeated `.zip()` and a `.map()`; it has an anonymous type.\n/// The special cases of one and two arguments produce the equivalent of\n/// `$a.into_iter()` and `$a.into_iter().zip($b)` respectively.\n///\n/// Prefer this macro `izip!()` over [`multizip`] for the performance benefits\n/// of using the standard library `.zip()`.\n///\n/// [`multizip`]: fn.multizip.html\n///\n/// ```\n/// # use itertools::izip;\n/// #\n/// # fn main() {\n///\n/// // iterate over three sequences side-by-side\n/// let mut results = [0, 0, 0, 0];\n/// let inputs = [3, 7, 9, 6];\n///\n/// for (r, index, input) in izip!(&mut results, 0..10, &inputs) {\n///     *r = index * 10 + input;\n/// }\n///\n/// assert_eq!(results, [0 + 3, 10 + 7, 29, 36]);\n/// # }\n/// ```\nmacro_rules! izip {\n    // @closure creates a tuple-flattening closure for .map() call. usage:\n    // @closure partial_pattern => partial_tuple , rest , of , iterators\n    // eg. izip!( @closure ((a, b), c) => (a, b, c) , dd , ee )\n    ( @closure $p:pat => $tup:expr ) => {\n        |$p| $tup\n    };\n\n    // The \"b\" identifier is a different identifier on each recursion level thanks to hygiene.\n    ( @closure $p:pat => ( $($tup:tt)* ) , $_iter:expr $( , $tail:expr )* ) => {\n        izip!(@closure ($p, b) => ( $($tup)*, b ) $( , $tail )*)\n    };\n\n    // unary\n    ($first:expr $(,)*) => {\n        $crate::__std_iter::IntoIterator::into_iter($first)\n    };\n\n    // binary\n    ($first:expr, $second:expr $(,)*) => {\n        izip!($first)\n            .zip($second)\n    };\n\n    // n-ary where n > 2\n    ( $first:expr $( , $rest:expr )* $(,)* ) => {\n        izip!($first)\n            $(\n                .zip($rest)\n            )*\n            .map(\n                izip!(@closure a => (a) $( , $rest )*)\n            )\n    };\n}\n\n/// An [`Iterator`] blanket implementation that provides extra adaptors and\n/// methods.\n///\n/// This trait defines a number of methods. They are divided into two groups:\n///\n/// * *Adaptors* take an iterator and parameter as input, and return\n/// a new iterator value. These are listed first in the trait. An example\n/// of an adaptor is [`.interleave()`](#method.interleave)\n///\n/// * *Regular methods* are those that don't return iterators and instead\n/// return a regular value of some other kind.\n/// [`.next_tuple()`](#method.next_tuple) is an example and the first regular\n/// method in the list.\n///\n/// [`Iterator`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html\npub trait Itertools : Iterator {\n    // adaptors\n\n    /// Alternate elements from two iterators until both have run out.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = (1..7).interleave(vec![-1, -2]);\n    /// itertools::assert_equal(it, vec![1, -1, 2, -2, 3, 4, 5, 6]);\n    /// ```\n    fn interleave<J>(self, other: J) -> Interleave<Self, J::IntoIter>\n        where J: IntoIterator<Item = Self::Item>,\n              Self: Sized\n    {\n        interleave(self, other)\n    }\n\n    /// Alternate elements from two iterators until at least one of them has run\n    /// out.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = (1..7).interleave_shortest(vec![-1, -2]);\n    /// itertools::assert_equal(it, vec![1, -1, 2, -2, 3]);\n    /// ```\n    fn interleave_shortest<J>(self, other: J) -> InterleaveShortest<Self, J::IntoIter>\n        where J: IntoIterator<Item = Self::Item>,\n              Self: Sized\n    {\n        adaptors::interleave_shortest(self, other.into_iter())\n    }\n\n    /// An iterator adaptor to insert a particular value\n    /// between each element of the adapted iterator.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// itertools::assert_equal((0..3).intersperse(8), vec![0, 8, 1, 8, 2]);\n    /// ```\n    fn intersperse(self, element: Self::Item) -> Intersperse<Self>\n        where Self: Sized,\n              Self::Item: Clone\n    {\n        intersperse::intersperse(self, element)\n    }\n\n    /// Create an iterator which iterates over both this and the specified\n    /// iterator simultaneously, yielding pairs of two optional elements.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// As long as neither input iterator is exhausted yet, it yields two values\n    /// via `EitherOrBoth::Both`.\n    ///\n    /// When the parameter iterator is exhausted, it only yields a value from the\n    /// `self` iterator via `EitherOrBoth::Left`.\n    ///\n    /// When the `self` iterator is exhausted, it only yields a value from the\n    /// parameter iterator via `EitherOrBoth::Right`.\n    ///\n    /// When both iterators return `None`, all further invocations of `.next()`\n    /// will return `None`.\n    ///\n    /// Iterator element type is\n    /// [`EitherOrBoth<Self::Item, J::Item>`](enum.EitherOrBoth.html).\n    ///\n    /// ```rust\n    /// use itertools::EitherOrBoth::{Both, Right};\n    /// use itertools::Itertools;\n    /// let it = (0..1).zip_longest(1..3);\n    /// itertools::assert_equal(it, vec![Both(0, 1), Right(2)]);\n    /// ```\n    #[inline]\n    fn zip_longest<J>(self, other: J) -> ZipLongest<Self, J::IntoIter>\n        where J: IntoIterator,\n              Self: Sized\n    {\n        zip_longest::zip_longest(self, other.into_iter())\n    }\n\n    /// Create an iterator which iterates over both this and the specified\n    /// iterator simultaneously, yielding pairs of elements.\n    ///\n    /// **Panics** if the iterators reach an end and they are not of equal\n    /// lengths.\n    #[inline]\n    fn zip_eq<J>(self, other: J) -> ZipEq<Self, J::IntoIter>\n        where J: IntoIterator,\n              Self: Sized\n    {\n        zip_eq(self, other)\n    }\n\n    /// A “meta iterator adaptor”. Its closure receives a reference to the\n    /// iterator and may pick off as many elements as it likes, to produce the\n    /// next iterator element.\n    ///\n    /// Iterator element type is `B`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // An adaptor that gathers elements in pairs\n    /// let pit = (0..4).batching(|it| {\n    ///            match it.next() {\n    ///                None => None,\n    ///                Some(x) => match it.next() {\n    ///                    None => None,\n    ///                    Some(y) => Some((x, y)),\n    ///                }\n    ///            }\n    ///        });\n    ///\n    /// itertools::assert_equal(pit, vec![(0, 1), (2, 3)]);\n    /// ```\n    ///\n    fn batching<B, F>(self, f: F) -> Batching<Self, F>\n        where F: FnMut(&mut Self) -> Option<B>,\n              Self: Sized\n    {\n        adaptors::batching(self, f)\n    }\n\n    /// Return an *iterable* that can group iterator elements.\n    /// Consecutive elements that map to the same key (“runs”), are assigned\n    /// to the same group.\n    ///\n    /// `GroupBy` is the storage for the lazy grouping operation.\n    ///\n    /// If the groups are consumed in order, or if each group's iterator is\n    /// dropped without keeping it around, then `GroupBy` uses no\n    /// allocations.  It needs allocations only if several group iterators\n    /// are alive at the same time.\n    ///\n    /// This type implements `IntoIterator` (it is **not** an iterator\n    /// itself), because the group iterators need to borrow from this\n    /// value. It should be stored in a local variable or temporary and\n    /// iterated.\n    ///\n    /// Iterator element type is `(K, Group)`: the group's key and the\n    /// group iterator.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // group data into runs of larger than zero or not.\n    /// let data = vec![1, 3, -2, -2, 1, 0, 1, 2];\n    /// // groups:     |---->|------>|--------->|\n    ///\n    /// // Note: The `&` is significant here, `GroupBy` is iterable\n    /// // only by reference. You can also call `.into_iter()` explicitly.\n    /// let mut data_grouped = Vec::new();\n    /// for (key, group) in &data.into_iter().group_by(|elt| *elt >= 0) {\n    ///     data_grouped.push((key, group.collect()));\n    /// }\n    /// assert_eq!(data_grouped, vec![(true, vec![1, 3]), (false, vec![-2, -2]), (true, vec![1, 0, 1, 2])]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn group_by<K, F>(self, key: F) -> GroupBy<K, Self, F>\n        where Self: Sized,\n              F: FnMut(&Self::Item) -> K,\n              K: PartialEq,\n    {\n        groupbylazy::new(self, key)\n    }\n\n    /// Return an *iterable* that can chunk the iterator.\n    ///\n    /// Yield subiterators (chunks) that each yield a fixed number elements,\n    /// determined by `size`. The last chunk will be shorter if there aren't\n    /// enough elements.\n    ///\n    /// `IntoChunks` is based on `GroupBy`: it is iterable (implements\n    /// `IntoIterator`, **not** `Iterator`), and it only buffers if several\n    /// chunk iterators are alive at the same time.\n    ///\n    /// Iterator element type is `Chunk`, each chunk's iterator.\n    ///\n    /// **Panics** if `size` is 0.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![1, 1, 2, -2, 6, 0, 3, 1];\n    /// //chunk size=3 |------->|-------->|--->|\n    ///\n    /// // Note: The `&` is significant here, `IntoChunks` is iterable\n    /// // only by reference. You can also call `.into_iter()` explicitly.\n    /// for chunk in &data.into_iter().chunks(3) {\n    ///     // Check that the sum of each chunk is 4.\n    ///     assert_eq!(4, chunk.sum());\n    /// }\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn chunks(self, size: usize) -> IntoChunks<Self>\n        where Self: Sized,\n    {\n        assert!(size != 0);\n        groupbylazy::new_chunks(self, size)\n    }\n\n    /// Return an iterator over all contiguous windows producing tuples of\n    /// a specific size (up to 4).\n    ///\n    /// `tuple_windows` clones the iterator elements so that they can be\n    /// part of successive windows, this makes it most suited for iterators\n    /// of references and other values that are cheap to copy.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// let mut v = Vec::new();\n    /// for (a, b) in (1..5).tuple_windows() {\n    ///     v.push((a, b));\n    /// }\n    /// assert_eq!(v, vec![(1, 2), (2, 3), (3, 4)]);\n    ///\n    /// let mut it = (1..5).tuple_windows();\n    /// assert_eq!(Some((1, 2, 3)), it.next());\n    /// assert_eq!(Some((2, 3, 4)), it.next());\n    /// assert_eq!(None, it.next());\n    ///\n    /// // this requires a type hint\n    /// let it = (1..5).tuple_windows::<(_, _, _)>();\n    /// itertools::assert_equal(it, vec![(1, 2, 3), (2, 3, 4)]);\n    ///\n    /// // you can also specify the complete type\n    /// use itertools::TupleWindows;\n    /// use std::ops::Range;\n    ///\n    /// let it: TupleWindows<Range<u32>, (u32, u32, u32)> = (1..5).tuple_windows();\n    /// itertools::assert_equal(it, vec![(1, 2, 3), (2, 3, 4)]);\n    /// ```\n    fn tuple_windows<T>(self) -> TupleWindows<Self, T>\n        where Self: Sized + Iterator<Item = T::Item>,\n              T: traits::HomogeneousTuple,\n              T::Item: Clone\n    {\n        tuple_impl::tuple_windows(self)\n    }\n\n    /// Return an iterator over all windows, wrapping back to the first\n    /// elements when the window would otherwise exceed the length of the\n    /// iterator, producing tuples of a specific size (up to 4).\n    ///\n    /// `circular_tuple_windows` clones the iterator elements so that they can be\n    /// part of successive windows, this makes it most suited for iterators\n    /// of references and other values that are cheap to copy.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// let mut v = Vec::new();\n    /// for (a, b) in (1..5).circular_tuple_windows() {\n    ///     v.push((a, b));\n    /// }\n    /// assert_eq!(v, vec![(1, 2), (2, 3), (3, 4), (4, 1)]);\n    ///\n    /// let mut it = (1..5).circular_tuple_windows();\n    /// assert_eq!(Some((1, 2, 3)), it.next());\n    /// assert_eq!(Some((2, 3, 4)), it.next());\n    /// assert_eq!(Some((3, 4, 1)), it.next());\n    /// assert_eq!(Some((4, 1, 2)), it.next());\n    /// assert_eq!(None, it.next());\n    ///\n    /// // this requires a type hint\n    /// let it = (1..5).circular_tuple_windows::<(_, _, _)>();\n    /// itertools::assert_equal(it, vec![(1, 2, 3), (2, 3, 4), (3, 4, 1), (4, 1, 2)]);\n    /// ```\n    fn circular_tuple_windows<T>(self) -> CircularTupleWindows<Self, T>\n        where Self: Sized + Clone + Iterator<Item = T::Item> + ExactSizeIterator,\n              T: tuple_impl::TupleCollect + Clone,\n              T::Item: Clone\n    {\n        tuple_impl::circular_tuple_windows(self)\n    }\n    /// Return an iterator that groups the items in tuples of a specific size\n    /// (up to 4).\n    ///\n    /// See also the method [`.next_tuple()`](#method.next_tuple).\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// let mut v = Vec::new();\n    /// for (a, b) in (1..5).tuples() {\n    ///     v.push((a, b));\n    /// }\n    /// assert_eq!(v, vec![(1, 2), (3, 4)]);\n    ///\n    /// let mut it = (1..7).tuples();\n    /// assert_eq!(Some((1, 2, 3)), it.next());\n    /// assert_eq!(Some((4, 5, 6)), it.next());\n    /// assert_eq!(None, it.next());\n    ///\n    /// // this requires a type hint\n    /// let it = (1..7).tuples::<(_, _, _)>();\n    /// itertools::assert_equal(it, vec![(1, 2, 3), (4, 5, 6)]);\n    ///\n    /// // you can also specify the complete type\n    /// use itertools::Tuples;\n    /// use std::ops::Range;\n    ///\n    /// let it: Tuples<Range<u32>, (u32, u32, u32)> = (1..7).tuples();\n    /// itertools::assert_equal(it, vec![(1, 2, 3), (4, 5, 6)]);\n    /// ```\n    ///\n    /// See also [`Tuples::into_buffer`](structs/struct.Tuples.html#method.into_buffer).\n    fn tuples<T>(self) -> Tuples<Self, T>\n        where Self: Sized + Iterator<Item = T::Item>,\n              T: traits::HomogeneousTuple\n    {\n        tuple_impl::tuples(self)\n    }\n\n    /// Split into an iterator pair that both yield all elements from\n    /// the original iterator.\n    ///\n    /// **Note:** If the iterator is clonable, prefer using that instead\n    /// of using this method. It is likely to be more efficient.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// let xs = vec![0, 1, 2, 3];\n    ///\n    /// let (mut t1, t2) = xs.into_iter().tee();\n    /// itertools::assert_equal(t1.next(), Some(0));\n    /// itertools::assert_equal(t2, 0..4);\n    /// itertools::assert_equal(t1, 1..4);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn tee(self) -> (Tee<Self>, Tee<Self>)\n        where Self: Sized,\n              Self::Item: Clone\n    {\n        tee::new(self)\n    }\n\n    /// Return an iterator adaptor that steps `n` elements in the base iterator\n    /// for each iteration.\n    ///\n    /// The iterator steps by yielding the next element from the base iterator,\n    /// then skipping forward `n - 1` elements.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// **Panics** if the step is 0.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = (0..8).step(3);\n    /// itertools::assert_equal(it, vec![0, 3, 6]);\n    /// ```\n    #[deprecated(note=\"Use std .step_by() instead\", since=\"0.8\")]\n    #[allow(deprecated)]\n    fn step(self, n: usize) -> Step<Self>\n        where Self: Sized\n    {\n        adaptors::step(self, n)\n    }\n\n    /// Convert each item of the iterator using the `Into` trait.\n    ///\n    /// ```rust\n    /// use itertools::Itertools;\n    ///\n    /// (1i32..42i32).map_into::<f64>().collect_vec();\n    /// ```\n    fn map_into<R>(self) -> MapInto<Self, R>\n        where Self: Sized,\n              Self::Item: Into<R>,\n    {\n        adaptors::map_into(self)\n    }\n\n    /// Return an iterator adaptor that applies the provided closure\n    /// to every `Result::Ok` value. `Result::Err` values are\n    /// unchanged.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let input = vec![Ok(41), Err(false), Ok(11)];\n    /// let it = input.into_iter().map_results(|i| i + 1);\n    /// itertools::assert_equal(it, vec![Ok(42), Err(false), Ok(12)]);\n    /// ```\n    fn map_results<F, T, U, E>(self, f: F) -> MapResults<Self, F>\n        where Self: Iterator<Item = Result<T, E>> + Sized,\n              F: FnMut(T) -> U,\n    {\n        adaptors::map_results(self, f)\n    }\n\n    /// Return an iterator adaptor that merges the two base iterators in\n    /// ascending order.  If both base iterators are sorted (ascending), the\n    /// result is sorted.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a = (0..11).step(3);\n    /// let b = (0..11).step(5);\n    /// let it = a.merge(b);\n    /// itertools::assert_equal(it, vec![0, 0, 3, 5, 6, 9, 10]);\n    /// ```\n    fn merge<J>(self, other: J) -> Merge<Self, J::IntoIter>\n        where Self: Sized,\n              Self::Item: PartialOrd,\n              J: IntoIterator<Item = Self::Item>\n    {\n        merge(self, other)\n    }\n\n    /// Return an iterator adaptor that merges the two base iterators in order.\n    /// This is much like `.merge()` but allows for a custom ordering.\n    ///\n    /// This can be especially useful for sequences of tuples.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a = (0..).zip(\"bc\".chars());\n    /// let b = (0..).zip(\"ad\".chars());\n    /// let it = a.merge_by(b, |x, y| x.1 <= y.1);\n    /// itertools::assert_equal(it, vec![(0, 'a'), (0, 'b'), (1, 'c'), (1, 'd')]);\n    /// ```\n\n    fn merge_by<J, F>(self, other: J, is_first: F) -> MergeBy<Self, J::IntoIter, F>\n        where Self: Sized,\n              J: IntoIterator<Item = Self::Item>,\n              F: FnMut(&Self::Item, &Self::Item) -> bool\n    {\n        adaptors::merge_by_new(self, other.into_iter(), is_first)\n    }\n\n    /// Create an iterator that merges items from both this and the specified\n    /// iterator in ascending order.\n    ///\n    /// It chooses whether to pair elements based on the `Ordering` returned by the\n    /// specified compare function. At any point, inspecting the tip of the\n    /// iterators `I` and `J` as items `i` of type `I::Item` and `j` of type\n    /// `J::Item` respectively, the resulting iterator will:\n    ///\n    /// - Emit `EitherOrBoth::Left(i)` when `i < j`,\n    ///   and remove `i` from its source iterator\n    /// - Emit `EitherOrBoth::Right(j)` when `i > j`,\n    ///   and remove `j` from its source iterator\n    /// - Emit `EitherOrBoth::Both(i, j)` when  `i == j`,\n    ///   and remove both `i` and `j` from their respective source iterators\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// use itertools::EitherOrBoth::{Left, Right, Both};\n    ///\n    /// let ki = (0..10).step(3);\n    /// let ku = (0..10).step(5);\n    /// let ki_ku = ki.merge_join_by(ku, |i, j| i.cmp(j)).map(|either| {\n    ///     match either {\n    ///         Left(_) => \"Ki\",\n    ///         Right(_) => \"Ku\",\n    ///         Both(_, _) => \"KiKu\"\n    ///     }\n    /// });\n    ///\n    /// itertools::assert_equal(ki_ku, vec![\"KiKu\", \"Ki\", \"Ku\", \"Ki\", \"Ki\"]);\n    /// ```\n    #[inline]\n    fn merge_join_by<J, F>(self, other: J, cmp_fn: F) -> MergeJoinBy<Self, J::IntoIter, F>\n        where J: IntoIterator,\n              F: FnMut(&Self::Item, &J::Item) -> std::cmp::Ordering,\n              Self: Sized\n    {\n        merge_join_by(self, other, cmp_fn)\n    }\n\n    /// Return an iterator adaptor that flattens an iterator of iterators by\n    /// merging them in ascending order.\n    ///\n    /// If all base iterators are sorted (ascending), the result is sorted.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a = (0..6).step(3);\n    /// let b = (1..6).step(3);\n    /// let c = (2..6).step(3);\n    /// let it = vec![a, b, c].into_iter().kmerge();\n    /// itertools::assert_equal(it, vec![0, 1, 2, 3, 4, 5]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn kmerge(self) -> KMerge<<Self::Item as IntoIterator>::IntoIter>\n        where Self: Sized,\n              Self::Item: IntoIterator,\n              <Self::Item as IntoIterator>::Item: PartialOrd,\n    {\n        kmerge(self)\n    }\n\n    /// Return an iterator adaptor that flattens an iterator of iterators by\n    /// merging them according to the given closure.\n    ///\n    /// The closure `first` is called with two elements *a*, *b* and should\n    /// return `true` if *a* is ordered before *b*.\n    ///\n    /// If all base iterators are sorted according to `first`, the result is\n    /// sorted.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a = vec![-1f64, 2., 3., -5., 6., -7.];\n    /// let b = vec![0., 2., -4.];\n    /// let mut it = vec![a, b].into_iter().kmerge_by(|a, b| a.abs() < b.abs());\n    /// assert_eq!(it.next(), Some(0.));\n    /// assert_eq!(it.last(), Some(-7.));\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn kmerge_by<F>(self, first: F)\n        -> KMergeBy<<Self::Item as IntoIterator>::IntoIter, F>\n        where Self: Sized,\n              Self::Item: IntoIterator,\n              F: FnMut(&<Self::Item as IntoIterator>::Item,\n                       &<Self::Item as IntoIterator>::Item) -> bool\n    {\n        kmerge_by(self, first)\n    }\n\n    /// Return an iterator adaptor that iterates over the cartesian product of\n    /// the element sets of two iterators `self` and `J`.\n    ///\n    /// Iterator element type is `(Self::Item, J::Item)`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = (0..2).cartesian_product(\"αβ\".chars());\n    /// itertools::assert_equal(it, vec![(0, 'α'), (0, 'β'), (1, 'α'), (1, 'β')]);\n    /// ```\n    fn cartesian_product<J>(self, other: J) -> Product<Self, J::IntoIter>\n        where Self: Sized,\n              Self::Item: Clone,\n              J: IntoIterator,\n              J::IntoIter: Clone\n    {\n        adaptors::cartesian_product(self, other.into_iter())\n    }\n\n    /// Return an iterator adaptor that iterates over the cartesian product of\n    /// all subiterators returned by meta-iterator `self`.\n    ///\n    /// All provided iterators must yield the same `Item` type. To generate\n    /// the product of iterators yielding multiple types, use the\n    /// [`iproduct`](macro.iproduct.html) macro instead.\n    ///\n    ///\n    /// The iterator element type is `Vec<T>`, where `T` is the iterator element\n    /// of the subiterators.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// let mut multi_prod = (0..3).map(|i| (i * 2)..(i * 2 + 2))\n    ///     .multi_cartesian_product();\n    /// assert_eq!(multi_prod.next(), Some(vec![0, 2, 4]));\n    /// assert_eq!(multi_prod.next(), Some(vec![0, 2, 5]));\n    /// assert_eq!(multi_prod.next(), Some(vec![0, 3, 4]));\n    /// assert_eq!(multi_prod.next(), Some(vec![0, 3, 5]));\n    /// assert_eq!(multi_prod.next(), Some(vec![1, 2, 4]));\n    /// assert_eq!(multi_prod.next(), Some(vec![1, 2, 5]));\n    /// assert_eq!(multi_prod.next(), Some(vec![1, 3, 4]));\n    /// assert_eq!(multi_prod.next(), Some(vec![1, 3, 5]));\n    /// assert_eq!(multi_prod.next(), None);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn multi_cartesian_product(self) -> MultiProduct<<Self::Item as IntoIterator>::IntoIter>\n        where Self: Iterator + Sized,\n              Self::Item: IntoIterator,\n              <Self::Item as IntoIterator>::IntoIter: Clone,\n              <Self::Item as IntoIterator>::Item: Clone\n    {\n        adaptors::multi_cartesian_product(self)\n    }\n\n    /// Return an iterator adaptor that uses the passed-in closure to\n    /// optionally merge together consecutive elements.\n    ///\n    /// The closure `f` is passed two elements, `previous` and `current` and may\n    /// return either (1) `Ok(combined)` to merge the two values or\n    /// (2) `Err((previous', current'))` to indicate they can't be merged.\n    /// In (2), the value `previous'` is emitted by the iterator.\n    /// Either (1) `combined` or (2) `current'` becomes the previous value\n    /// when coalesce continues with the next pair of elements to merge. The\n    /// value that remains at the end is also emitted by the iterator.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // sum same-sign runs together\n    /// let data = vec![-1., -2., -3., 3., 1., 0., -1.];\n    /// itertools::assert_equal(data.into_iter().coalesce(|x, y|\n    ///         if (x >= 0.) == (y >= 0.) {\n    ///             Ok(x + y)\n    ///         } else {\n    ///             Err((x, y))\n    ///         }),\n    ///         vec![-6., 4., -1.]);\n    /// ```\n    fn coalesce<F>(self, f: F) -> Coalesce<Self, F>\n        where Self: Sized,\n              F: FnMut(Self::Item, Self::Item)\n                       -> Result<Self::Item, (Self::Item, Self::Item)>\n    {\n        adaptors::coalesce(self, f)\n    }\n\n    /// Remove duplicates from sections of consecutive identical elements.\n    /// If the iterator is sorted, all elements will be unique.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![1., 1., 2., 3., 3., 2., 2.];\n    /// itertools::assert_equal(data.into_iter().dedup(),\n    ///                         vec![1., 2., 3., 2.]);\n    /// ```\n    fn dedup(self) -> Dedup<Self>\n        where Self: Sized,\n              Self::Item: PartialEq,\n    {\n        adaptors::dedup(self)\n    }\n\n    /// Remove duplicates from sections of consecutive identical elements,\n    /// determining equality using a comparison function.\n    /// If the iterator is sorted, all elements will be unique.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![(0, 1.), (1, 1.), (0, 2.), (0, 3.), (1, 3.), (1, 2.), (2, 2.)];\n    /// itertools::assert_equal(data.into_iter().dedup_by(|x, y| x.1 == y.1),\n    ///                         vec![(0, 1.), (0, 2.), (0, 3.), (1, 2.)]);\n    /// ```\n    fn dedup_by<Cmp>(self, cmp: Cmp) -> DedupBy<Self, Cmp>\n        where Self: Sized,\n              Cmp: FnMut(&Self::Item, &Self::Item)->bool,\n    {\n        adaptors::dedup_by(self, cmp)\n    }\n\n    /// Remove duplicates from sections of consecutive identical elements, while keeping a count of\n    /// how many repeated elements were present.\n    /// If the iterator is sorted, all elements will be unique.\n    ///\n    /// Iterator element type is `(usize, Self::Item)`.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![1., 1., 2., 3., 3., 2., 2.];\n    /// itertools::assert_equal(data.into_iter().dedup_with_count(),\n    ///                         vec![(2, 1.), (1, 2.), (2, 3.), (2, 2.)]);\n    /// ```\n    fn dedup_with_count(self) -> DedupWithCount<Self>\n        where Self: Sized,\n    {\n        adaptors::dedup_with_count(self)\n    }\n\n    /// Remove duplicates from sections of consecutive identical elements, while keeping a count of\n    /// how many repeated elements were present.\n    /// This will determine equality using a comparison function.\n    /// If the iterator is sorted, all elements will be unique.\n    ///\n    /// Iterator element type is `(usize, Self::Item)`.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![(0, 1.), (1, 1.), (0, 2.), (0, 3.), (1, 3.), (1, 2.), (2, 2.)];\n    /// itertools::assert_equal(data.into_iter().dedup_by_with_count(|x, y| x.1 == y.1),\n    ///                         vec![(2, (0, 1.)), (1, (0, 2.)), (2, (0, 3.)), (2, (1, 2.))]);\n    /// ```\n    fn dedup_by_with_count<Cmp>(self, cmp: Cmp) -> DedupByWithCount<Self, Cmp>\n        where Self: Sized,\n              Cmp: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        adaptors::dedup_by_with_count(self, cmp)\n    }\n\n    /// Return an iterator adaptor that filters out elements that have\n    /// already been produced once during the iteration. Duplicates\n    /// are detected using hash and equality.\n    ///\n    /// Clones of visited elements are stored in a hash set in the\n    /// iterator.\n    ///\n    /// The iterator is stable, returning the non-duplicate items in the order\n    /// in which they occur in the adapted iterator. In a set of duplicate\n    /// items, the first item encountered is the item retained.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![10, 20, 30, 20, 40, 10, 50];\n    /// itertools::assert_equal(data.into_iter().unique(),\n    ///                         vec![10, 20, 30, 40, 50]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn unique(self) -> Unique<Self>\n        where Self: Sized,\n              Self::Item: Clone + Eq + Hash\n    {\n        unique_impl::unique(self)\n    }\n\n    /// Return an iterator adaptor that filters out elements that have\n    /// already been produced once during the iteration.\n    ///\n    /// Duplicates are detected by comparing the key they map to\n    /// with the keying function `f` by hash and equality.\n    /// The keys are stored in a hash set in the iterator.\n    ///\n    /// The iterator is stable, returning the non-duplicate items in the order\n    /// in which they occur in the adapted iterator. In a set of duplicate\n    /// items, the first item encountered is the item retained.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![\"a\", \"bb\", \"aa\", \"c\", \"ccc\"];\n    /// itertools::assert_equal(data.into_iter().unique_by(|s| s.len()),\n    ///                         vec![\"a\", \"bb\", \"ccc\"]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn unique_by<V, F>(self, f: F) -> UniqueBy<Self, V, F>\n        where Self: Sized,\n              V: Eq + Hash,\n              F: FnMut(&Self::Item) -> V\n    {\n        unique_impl::unique_by(self, f)\n    }\n\n    /// Return an iterator adaptor that borrows from this iterator and\n    /// takes items while the closure `accept` returns `true`.\n    ///\n    /// This adaptor can only be used on iterators that implement `PeekingNext`\n    /// like `.peekable()`, `put_back` and a few other collection iterators.\n    ///\n    /// The last and rejected element (first `false`) is still available when\n    /// `peeking_take_while` is done.\n    ///\n    ///\n    /// See also [`.take_while_ref()`](#method.take_while_ref)\n    /// which is a similar adaptor.\n    fn peeking_take_while<F>(&mut self, accept: F) -> PeekingTakeWhile<Self, F>\n        where Self: Sized + PeekingNext,\n              F: FnMut(&Self::Item) -> bool,\n    {\n        peeking_take_while::peeking_take_while(self, accept)\n    }\n\n    /// Return an iterator adaptor that borrows from a `Clone`-able iterator\n    /// to only pick off elements while the predicate `accept` returns `true`.\n    ///\n    /// It uses the `Clone` trait to restore the original iterator so that the\n    /// last and rejected element (first `false`) is still available when\n    /// `take_while_ref` is done.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut hexadecimals = \"0123456789abcdef\".chars();\n    ///\n    /// let decimals = hexadecimals.take_while_ref(|c| c.is_numeric())\n    ///                            .collect::<String>();\n    /// assert_eq!(decimals, \"0123456789\");\n    /// assert_eq!(hexadecimals.next(), Some('a'));\n    ///\n    /// ```\n    fn take_while_ref<F>(&mut self, accept: F) -> TakeWhileRef<Self, F>\n        where Self: Clone,\n              F: FnMut(&Self::Item) -> bool\n    {\n        adaptors::take_while_ref(self, accept)\n    }\n\n    /// Return an iterator adaptor that filters `Option<A>` iterator elements\n    /// and produces `A`. Stops on the first `None` encountered.\n    ///\n    /// Iterator element type is `A`, the unwrapped element.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // List all hexadecimal digits\n    /// itertools::assert_equal(\n    ///     (0..).map(|i| std::char::from_digit(i, 16)).while_some(),\n    ///     \"0123456789abcdef\".chars());\n    ///\n    /// ```\n    fn while_some<A>(self) -> WhileSome<Self>\n        where Self: Sized + Iterator<Item = Option<A>>\n    {\n        adaptors::while_some(self)\n    }\n\n    /// Return an iterator adaptor that iterates over the combinations of the\n    /// elements from an iterator.\n    ///\n    /// Iterator element can be any homogeneous tuple of type `Self::Item` with\n    /// size up to 4.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut v = Vec::new();\n    /// for (a, b) in (1..5).tuple_combinations() {\n    ///     v.push((a, b));\n    /// }\n    /// assert_eq!(v, vec![(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]);\n    ///\n    /// let mut it = (1..5).tuple_combinations();\n    /// assert_eq!(Some((1, 2, 3)), it.next());\n    /// assert_eq!(Some((1, 2, 4)), it.next());\n    /// assert_eq!(Some((1, 3, 4)), it.next());\n    /// assert_eq!(Some((2, 3, 4)), it.next());\n    /// assert_eq!(None, it.next());\n    ///\n    /// // this requires a type hint\n    /// let it = (1..5).tuple_combinations::<(_, _, _)>();\n    /// itertools::assert_equal(it, vec![(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]);\n    ///\n    /// // you can also specify the complete type\n    /// use itertools::TupleCombinations;\n    /// use std::ops::Range;\n    ///\n    /// let it: TupleCombinations<Range<u32>, (u32, u32, u32)> = (1..5).tuple_combinations();\n    /// itertools::assert_equal(it, vec![(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]);\n    /// ```\n    fn tuple_combinations<T>(self) -> TupleCombinations<Self, T>\n        where Self: Sized + Clone,\n              Self::Item: Clone,\n              T: adaptors::HasCombination<Self>,\n    {\n        adaptors::tuple_combinations(self)\n    }\n\n    /// Return an iterator adaptor that iterates over the `k`-length combinations of\n    /// the elements from an iterator.\n    ///\n    /// Iterator element type is `Vec<Self::Item>`. The iterator produces a new Vec per iteration,\n    /// and clones the iterator elements.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = (1..5).combinations(3);\n    /// itertools::assert_equal(it, vec![\n    ///     vec![1, 2, 3],\n    ///     vec![1, 2, 4],\n    ///     vec![1, 3, 4],\n    ///     vec![2, 3, 4],\n    /// ]);\n    /// ```\n    ///\n    /// Note: Combinations does not take into account the equality of the iterated values.\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = vec![1, 2, 2].into_iter().combinations(2);\n    /// itertools::assert_equal(it, vec![\n    ///     vec![1, 2], // Note: these are the same\n    ///     vec![1, 2], // Note: these are the same\n    ///     vec![2, 2],\n    /// ]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn combinations(self, k: usize) -> Combinations<Self>\n        where Self: Sized,\n              Self::Item: Clone\n    {\n        combinations::combinations(self, k)\n    }\n\n    /// Return an iterator that iterates over the `k`-length combinations of\n    /// the elements from an iterator, with replacement.\n    ///\n    /// Iterator element type is `Vec<Self::Item>`. The iterator produces a new Vec per iteration,\n    /// and clones the iterator elements.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = (1..4).combinations_with_replacement(2);\n    /// itertools::assert_equal(it, vec![\n    ///     vec![1, 1],\n    ///     vec![1, 2],\n    ///     vec![1, 3],\n    ///     vec![2, 2],\n    ///     vec![2, 3],\n    ///     vec![3, 3],\n    /// ]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn combinations_with_replacement(self, k: usize) -> CombinationsWithReplacement<Self>\n    where\n        Self: Sized,\n        Self::Item: Clone,\n    {\n        combinations_with_replacement::combinations_with_replacement(self, k)\n    }\n\n    /// Return an iterator adaptor that iterates over all k-permutations of the\n    /// elements from an iterator.\n    ///\n    /// Iterator element type is `Vec<Self::Item>` with length `k`. The iterator\n    /// produces a new Vec per iteration, and clones the iterator elements.\n    ///\n    /// If `k` is greater than the length of the input iterator, the resultant\n    /// iterator adaptor will be empty.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let perms = (5..8).permutations(2);\n    /// itertools::assert_equal(perms, vec![\n    ///     vec![5, 6],\n    ///     vec![5, 7],\n    ///     vec![6, 5],\n    ///     vec![6, 7],\n    ///     vec![7, 5],\n    ///     vec![7, 6],\n    /// ]);\n    /// ```\n    ///\n    /// Note: Permutations does not take into account the equality of the iterated values.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = vec![2, 2].into_iter().permutations(2);\n    /// itertools::assert_equal(it, vec![\n    ///     vec![2, 2], // Note: these are the same\n    ///     vec![2, 2], // Note: these are the same\n    /// ]);\n    /// ```\n    ///\n    /// Note: The source iterator is collected lazily, and will not be\n    /// re-iterated if the permutations adaptor is completed and re-iterated.\n    #[cfg(feature = \"use_std\")]\n    fn permutations(self, k: usize) -> Permutations<Self>\n        where Self: Sized,\n              Self::Item: Clone\n    {\n        permutations::permutations(self, k)\n    }\n\n    /// Return an iterator adaptor that pads the sequence to a minimum length of\n    /// `min` by filling missing elements using a closure `f`.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = (0..5).pad_using(10, |i| 2*i);\n    /// itertools::assert_equal(it, vec![0, 1, 2, 3, 4, 10, 12, 14, 16, 18]);\n    ///\n    /// let it = (0..10).pad_using(5, |i| 2*i);\n    /// itertools::assert_equal(it, vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n    ///\n    /// let it = (0..5).pad_using(10, |i| 2*i).rev();\n    /// itertools::assert_equal(it, vec![18, 16, 14, 12, 10, 4, 3, 2, 1, 0]);\n    /// ```\n    fn pad_using<F>(self, min: usize, f: F) -> PadUsing<Self, F>\n        where Self: Sized,\n              F: FnMut(usize) -> Self::Item\n    {\n        pad_tail::pad_using(self, min, f)\n    }\n\n    /// Return an iterator adaptor that wraps each element in a `Position` to\n    /// ease special-case handling of the first or last elements.\n    ///\n    /// Iterator element type is\n    /// [`Position<Self::Item>`](enum.Position.html)\n    ///\n    /// ```\n    /// use itertools::{Itertools, Position};\n    ///\n    /// let it = (0..4).with_position();\n    /// itertools::assert_equal(it,\n    ///                         vec![Position::First(0),\n    ///                              Position::Middle(1),\n    ///                              Position::Middle(2),\n    ///                              Position::Last(3)]);\n    ///\n    /// let it = (0..1).with_position();\n    /// itertools::assert_equal(it, vec![Position::Only(0)]);\n    /// ```\n    fn with_position(self) -> WithPosition<Self>\n        where Self: Sized,\n    {\n        with_position::with_position(self)\n    }\n\n    /// Return an iterator adaptor that yields the indices of all elements\n    /// satisfying a predicate, counted from the start of the iterator.\n    ///\n    /// Equivalent to `iter.enumerate().filter(|(_, v)| predicate(v)).map(|(i, _)| i)`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![1, 2, 3, 3, 4, 6, 7, 9];\n    /// itertools::assert_equal(data.iter().positions(|v| v % 2 == 0), vec![1, 4, 5]);\n    ///\n    /// itertools::assert_equal(data.iter().positions(|v| v % 2 == 1).rev(), vec![7, 6, 3, 2, 0]);\n    /// ```\n    fn positions<P>(self, predicate: P) -> Positions<Self, P>\n        where Self: Sized,\n              P: FnMut(Self::Item) -> bool,\n    {\n        adaptors::positions(self, predicate)\n    }\n\n    /// Return an iterator adaptor that applies a mutating function\n    /// to each element before yielding it.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let input = vec![vec![1], vec![3, 2, 1]];\n    /// let it = input.into_iter().update(|mut v| v.push(0));\n    /// itertools::assert_equal(it, vec![vec![1, 0], vec![3, 2, 1, 0]]);\n    /// ```\n    fn update<F>(self, updater: F) -> Update<Self, F>\n        where Self: Sized,\n              F: FnMut(&mut Self::Item),\n    {\n        adaptors::update(self, updater)\n    }\n\n    // non-adaptor methods\n    /// Advances the iterator and returns the next items grouped in a tuple of\n    /// a specific size (up to 4).\n    ///\n    /// If there are enough elements to be grouped in a tuple, then the tuple is\n    /// returned inside `Some`, otherwise `None` is returned.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut iter = 1..5;\n    ///\n    /// assert_eq!(Some((1, 2)), iter.next_tuple());\n    /// ```\n    fn next_tuple<T>(&mut self) -> Option<T>\n        where Self: Sized + Iterator<Item = T::Item>,\n              T: traits::HomogeneousTuple\n    {\n        T::collect_from_iter_no_buf(self)\n    }\n\n    /// Collects all items from the iterator into a tuple of a specific size\n    /// (up to 4).\n    ///\n    /// If the number of elements inside the iterator is **exactly** equal to\n    /// the tuple size, then the tuple is returned inside `Some`, otherwise\n    /// `None` is returned.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let iter = 1..3;\n    ///\n    /// if let Some((x, y)) = iter.collect_tuple() {\n    ///     assert_eq!((x, y), (1, 2))\n    /// } else {\n    ///     panic!(\"Expected two elements\")\n    /// }\n    /// ```\n    fn collect_tuple<T>(mut self) -> Option<T>\n        where Self: Sized + Iterator<Item = T::Item>,\n              T: traits::HomogeneousTuple\n    {\n        match self.next_tuple() {\n            elt @ Some(_) => match self.next() {\n                Some(_) => None,\n                None => elt,\n            },\n            _ => None\n        }\n    }\n\n\n    /// Find the position and value of the first element satisfying a predicate.\n    ///\n    /// The iterator is not advanced past the first element found.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let text = \"Hα\";\n    /// assert_eq!(text.chars().find_position(|ch| ch.is_lowercase()), Some((1, 'α')));\n    /// ```\n    fn find_position<P>(&mut self, mut pred: P) -> Option<(usize, Self::Item)>\n        where P: FnMut(&Self::Item) -> bool\n    {\n        let mut index = 0usize;\n        for elt in self {\n            if pred(&elt) {\n                return Some((index, elt));\n            }\n            index += 1;\n        }\n        None\n    }\n\n    /// Check whether all elements compare equal.\n    ///\n    /// Empty iterators are considered to have equal elements:\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![1, 1, 1, 2, 2, 3, 3, 3, 4, 5, 5];\n    /// assert!(!data.iter().all_equal());\n    /// assert!(data[0..3].iter().all_equal());\n    /// assert!(data[3..5].iter().all_equal());\n    /// assert!(data[5..8].iter().all_equal());\n    ///\n    /// let data : Option<usize> = None;\n    /// assert!(data.into_iter().all_equal());\n    /// ```\n    fn all_equal(&mut self) -> bool\n        where Self: Sized,\n              Self::Item: PartialEq,\n    {\n        match self.next() {\n            None => true,\n            Some(a) => self.all(|x| a == x),\n        }\n    }\n\n    /// Consume the first `n` elements from the iterator eagerly,\n    /// and return the same iterator again.\n    ///\n    /// It works similarly to *.skip(* `n` *)* except it is eager and\n    /// preserves the iterator type.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut iter = \"αβγ\".chars().dropping(2);\n    /// itertools::assert_equal(iter, \"γ\".chars());\n    /// ```\n    ///\n    /// *Fusing notes: if the iterator is exhausted by dropping,\n    /// the result of calling `.next()` again depends on the iterator implementation.*\n    fn dropping(mut self, n: usize) -> Self\n        where Self: Sized\n    {\n        if n > 0 {\n            self.nth(n - 1);\n        }\n        self\n    }\n\n    /// Consume the last `n` elements from the iterator eagerly,\n    /// and return the same iterator again.\n    ///\n    /// This is only possible on double ended iterators. `n` may be\n    /// larger than the number of elements.\n    ///\n    /// Note: This method is eager, dropping the back elements immediately and\n    /// preserves the iterator type.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let init = vec![0, 3, 6, 9].into_iter().dropping_back(1);\n    /// itertools::assert_equal(init, vec![0, 3, 6]);\n    /// ```\n    fn dropping_back(mut self, n: usize) -> Self\n        where Self: Sized,\n              Self: DoubleEndedIterator\n    {\n        if n > 0 {\n            (&mut self).rev().nth(n - 1);\n        }\n        self\n    }\n\n    /// Run the closure `f` eagerly on each element of the iterator.\n    ///\n    /// Consumes the iterator until its end.\n    ///\n    /// ```\n    /// use std::sync::mpsc::channel;\n    /// use itertools::Itertools;\n    ///\n    /// let (tx, rx) = channel();\n    ///\n    /// // use .foreach() to apply a function to each value -- sending it\n    /// (0..5).map(|x| x * 2 + 1).foreach(|x| { tx.send(x).unwrap(); } );\n    ///\n    /// drop(tx);\n    ///\n    /// itertools::assert_equal(rx.iter(), vec![1, 3, 5, 7, 9]);\n    /// ```\n    #[deprecated(note=\"Use .for_each() instead\", since=\"0.8\")]\n    fn foreach<F>(self, f: F)\n        where F: FnMut(Self::Item),\n              Self: Sized,\n    {\n        self.for_each(f)\n    }\n\n    /// Combine all an iterator's elements into one element by using `Extend`.\n    ///\n    /// This combinator will extend the first item with each of the rest of the\n    /// items of the iterator. If the iterator is empty, the default value of\n    /// `I::Item` is returned.\n    ///\n    /// ```rust\n    /// use itertools::Itertools;\n    ///\n    /// let input = vec![vec![1], vec![2, 3], vec![4, 5, 6]];\n    /// assert_eq!(input.into_iter().concat(),\n    ///            vec![1, 2, 3, 4, 5, 6]);\n    /// ```\n    fn concat(self) -> Self::Item\n        where Self: Sized,\n              Self::Item: Extend<<<Self as Iterator>::Item as IntoIterator>::Item> + IntoIterator + Default\n    {\n        concat(self)\n    }\n\n    /// `.collect_vec()` is simply a type specialization of `.collect()`,\n    /// for convenience.\n    #[cfg(feature = \"use_std\")]\n    fn collect_vec(self) -> Vec<Self::Item>\n        where Self: Sized\n    {\n        self.collect()\n    }\n\n    /// `.try_collect()` is more convenient way of writing\n    /// `.collect::<Result<_, _>>()`\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::{fs, io};\n    /// use itertools::Itertools;\n    ///\n    /// fn process_dir_entries(entries: &[fs::DirEntry]) {\n    ///     // ...\n    /// }\n    ///\n    /// fn do_stuff() -> std::io::Result<()> {\n    ///     let entries: Vec<_> = fs::read_dir(\".\")?.try_collect()?;\n    ///     process_dir_entries(&entries);\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn try_collect<T, U, E>(self) -> Result<U, E>\n    where\n        Self: Sized + Iterator<Item = Result<T, E>>,\n        Result<U, E>: FromIterator<Result<T, E>>,\n    {\n        self.collect()\n    }\n\n    /// Assign to each reference in `self` from the `from` iterator,\n    /// stopping at the shortest of the two iterators.\n    ///\n    /// The `from` iterator is queried for its next element before the `self`\n    /// iterator, and if either is exhausted the method is done.\n    ///\n    /// Return the number of elements written.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut xs = [0; 4];\n    /// xs.iter_mut().set_from(1..);\n    /// assert_eq!(xs, [1, 2, 3, 4]);\n    /// ```\n    #[inline]\n    fn set_from<'a, A: 'a, J>(&mut self, from: J) -> usize\n        where Self: Iterator<Item = &'a mut A>,\n              J: IntoIterator<Item = A>\n    {\n        let mut count = 0;\n        for elt in from {\n            match self.next() {\n                None => break,\n                Some(ptr) => *ptr = elt,\n            }\n            count += 1;\n        }\n        count\n    }\n\n    /// Combine all iterator elements into one String, separated by `sep`.\n    ///\n    /// Use the `Display` implementation of each element.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// assert_eq!([\"a\", \"b\", \"c\"].iter().join(\", \"), \"a, b, c\");\n    /// assert_eq!([1, 2, 3].iter().join(\", \"), \"1, 2, 3\");\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn join(&mut self, sep: &str) -> String\n        where Self::Item: std::fmt::Display\n    {\n        match self.next() {\n            None => String::new(),\n            Some(first_elt) => {\n                // estimate lower bound of capacity needed\n                let (lower, _) = self.size_hint();\n                let mut result = String::with_capacity(sep.len() * lower);\n                write!(&mut result, \"{}\", first_elt).unwrap();\n                for elt in self {\n                    result.push_str(sep);\n                    write!(&mut result, \"{}\", elt).unwrap();\n                }\n                result\n            }\n        }\n    }\n\n    /// Format all iterator elements, separated by `sep`.\n    ///\n    /// All elements are formatted (any formatting trait)\n    /// with `sep` inserted between each element.\n    ///\n    /// **Panics** if the formatter helper is formatted more than once.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = [1.1, 2.71828, -3.];\n    /// assert_eq!(\n    ///     format!(\"{:.2}\", data.iter().format(\", \")),\n    ///            \"1.10, 2.72, -3.00\");\n    /// ```\n    fn format(self, sep: &str) -> Format<Self>\n        where Self: Sized,\n    {\n        format::new_format_default(self, sep)\n    }\n\n    /// Format all iterator elements, separated by `sep`.\n    ///\n    /// This is a customizable version of `.format()`.\n    ///\n    /// The supplied closure `format` is called once per iterator element,\n    /// with two arguments: the element and a callback that takes a\n    /// `&Display` value, i.e. any reference to type that implements `Display`.\n    ///\n    /// Using `&format_args!(...)` is the most versatile way to apply custom\n    /// element formatting. The callback can be called multiple times if needed.\n    ///\n    /// **Panics** if the formatter helper is formatted more than once.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = [1.1, 2.71828, -3.];\n    /// let data_formatter = data.iter().format_with(\", \", |elt, f| f(&format_args!(\"{:.2}\", elt)));\n    /// assert_eq!(format!(\"{}\", data_formatter),\n    ///            \"1.10, 2.72, -3.00\");\n    ///\n    /// // .format_with() is recursively composable\n    /// let matrix = [[1., 2., 3.],\n    ///               [4., 5., 6.]];\n    /// let matrix_formatter = matrix.iter().format_with(\"\\n\", |row, f| {\n    ///                                 f(&row.iter().format_with(\", \", |elt, g| g(&elt)))\n    ///                              });\n    /// assert_eq!(format!(\"{}\", matrix_formatter),\n    ///            \"1, 2, 3\\n4, 5, 6\");\n    ///\n    ///\n    /// ```\n    fn format_with<F>(self, sep: &str, format: F) -> FormatWith<Self, F>\n        where Self: Sized,\n              F: FnMut(Self::Item, &mut dyn FnMut(&dyn fmt::Display) -> fmt::Result) -> fmt::Result,\n    {\n        format::new_format(self, sep, format)\n    }\n\n    /// Fold `Result` values from an iterator.\n    ///\n    /// Only `Ok` values are folded. If no error is encountered, the folded\n    /// value is returned inside `Ok`. Otherwise, the operation terminates\n    /// and returns the first `Err` value it encounters. No iterator elements are\n    /// consumed after the first error.\n    ///\n    /// The first accumulator value is the `start` parameter.\n    /// Each iteration passes the accumulator value and the next value inside `Ok`\n    /// to the fold function `f` and its return value becomes the new accumulator value.\n    ///\n    /// For example the sequence *Ok(1), Ok(2), Ok(3)* will result in a\n    /// computation like this:\n    ///\n    /// ```ignore\n    /// let mut accum = start;\n    /// accum = f(accum, 1);\n    /// accum = f(accum, 2);\n    /// accum = f(accum, 3);\n    /// ```\n    ///\n    /// With a `start` value of 0 and an addition as folding function,\n    /// this effectively results in *((0 + 1) + 2) + 3*\n    ///\n    /// ```\n    /// use std::ops::Add;\n    /// use itertools::Itertools;\n    ///\n    /// let values = [1, 2, -2, -1, 2, 1];\n    /// assert_eq!(\n    ///     values.iter()\n    ///           .map(Ok::<_, ()>)\n    ///           .fold_results(0, Add::add),\n    ///     Ok(3)\n    /// );\n    /// assert!(\n    ///     values.iter()\n    ///           .map(|&x| if x >= 0 { Ok(x) } else { Err(\"Negative number\") })\n    ///           .fold_results(0, Add::add)\n    ///           .is_err()\n    /// );\n    /// ```\n    fn fold_results<A, E, B, F>(&mut self, mut start: B, mut f: F) -> Result<B, E>\n        where Self: Iterator<Item = Result<A, E>>,\n              F: FnMut(B, A) -> B\n    {\n        for elt in self {\n            match elt {\n                Ok(v) => start = f(start, v),\n                Err(u) => return Err(u),\n            }\n        }\n        Ok(start)\n    }\n\n    /// Fold `Option` values from an iterator.\n    ///\n    /// Only `Some` values are folded. If no `None` is encountered, the folded\n    /// value is returned inside `Some`. Otherwise, the operation terminates\n    /// and returns `None`. No iterator elements are consumed after the `None`.\n    ///\n    /// This is the `Option` equivalent to `fold_results`.\n    ///\n    /// ```\n    /// use std::ops::Add;\n    /// use itertools::Itertools;\n    ///\n    /// let mut values = vec![Some(1), Some(2), Some(-2)].into_iter();\n    /// assert_eq!(values.fold_options(5, Add::add), Some(5 + 1 + 2 - 2));\n    ///\n    /// let mut more_values = vec![Some(2), None, Some(0)].into_iter();\n    /// assert!(more_values.fold_options(0, Add::add).is_none());\n    /// assert_eq!(more_values.next().unwrap(), Some(0));\n    /// ```\n    fn fold_options<A, B, F>(&mut self, mut start: B, mut f: F) -> Option<B>\n        where Self: Iterator<Item = Option<A>>,\n              F: FnMut(B, A) -> B\n    {\n        for elt in self {\n            match elt {\n                Some(v) => start = f(start, v),\n                None => return None,\n            }\n        }\n        Some(start)\n    }\n\n    /// Accumulator of the elements in the iterator.\n    ///\n    /// Like `.fold()`, without a base case. If the iterator is\n    /// empty, return `None`. With just one element, return it.\n    /// Otherwise elements are accumulated in sequence using the closure `f`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// assert_eq!((0..10).fold1(|x, y| x + y).unwrap_or(0), 45);\n    /// assert_eq!((0..0).fold1(|x, y| x * y), None);\n    /// ```\n    fn fold1<F>(mut self, f: F) -> Option<Self::Item>\n        where F: FnMut(Self::Item, Self::Item) -> Self::Item,\n              Self: Sized,\n    {\n        self.next().map(move |x| self.fold(x, f))\n    }\n\n    /// Accumulate the elements in the iterator in a tree-like manner.\n    ///\n    /// You can think of it as, while there's more than one item, repeatedly\n    /// combining adjacent items.  It does so in bottom-up-merge-sort order,\n    /// however, so that it needs only logarithmic stack space.\n    ///\n    /// This produces a call tree like the following (where the calls under\n    /// an item are done after reading that item):\n    ///\n    /// ```text\n    /// 1 2 3 4 5 6 7\n    /// │ │ │ │ │ │ │\n    /// └─f └─f └─f │\n    ///   │   │   │ │\n    ///   └───f   └─f\n    ///       │     │\n    ///       └─────f\n    /// ```\n    ///\n    /// Which, for non-associative functions, will typically produce a different\n    /// result than the linear call tree used by `fold1`:\n    ///\n    /// ```text\n    /// 1 2 3 4 5 6 7\n    /// │ │ │ │ │ │ │\n    /// └─f─f─f─f─f─f\n    /// ```\n    ///\n    /// If `f` is associative, prefer the normal `fold1` instead.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // The same tree as above\n    /// let num_strings = (1..8).map(|x| x.to_string());\n    /// assert_eq!(num_strings.tree_fold1(|x, y| format!(\"f({}, {})\", x, y)),\n    ///     Some(String::from(\"f(f(f(1, 2), f(3, 4)), f(f(5, 6), 7))\")));\n    ///\n    /// // Like fold1, an empty iterator produces None\n    /// assert_eq!((0..0).tree_fold1(|x, y| x * y), None);\n    ///\n    /// // tree_fold1 matches fold1 for associative operations...\n    /// assert_eq!((0..10).tree_fold1(|x, y| x + y),\n    ///     (0..10).fold1(|x, y| x + y));\n    /// // ...but not for non-associative ones\n    /// assert_ne!((0..10).tree_fold1(|x, y| x - y),\n    ///     (0..10).fold1(|x, y| x - y));\n    /// ```\n    fn tree_fold1<F>(mut self, mut f: F) -> Option<Self::Item>\n        where F: FnMut(Self::Item, Self::Item) -> Self::Item,\n              Self: Sized,\n    {\n        type State<T> = Result<T, Option<T>>;\n\n        fn inner0<T, II, FF>(it: &mut II, f: &mut FF) -> State<T>\n            where\n                II: Iterator<Item = T>,\n                FF: FnMut(T, T) -> T\n        {\n            // This function could be replaced with `it.next().ok_or(None)`,\n            // but half the useful tree_fold1 work is combining adjacent items,\n            // so put that in a form that LLVM is more likely to optimize well.\n\n            let a =\n                if let Some(v) = it.next() { v }\n                else { return Err(None) };\n            let b =\n                if let Some(v) = it.next() { v }\n                else { return Err(Some(a)) };\n            Ok(f(a, b))\n        }\n\n        fn inner<T, II, FF>(stop: usize, it: &mut II, f: &mut FF) -> State<T>\n            where\n                II: Iterator<Item = T>,\n                FF: FnMut(T, T) -> T\n        {\n            let mut x = inner0(it, f)?;\n            for height in 0..stop {\n                // Try to get another tree the same size with which to combine it,\n                // creating a new tree that's twice as big for next time around.\n                let next =\n                    if height == 0 {\n                        inner0(it, f)\n                    } else {\n                        inner(height, it, f)\n                    };\n                match next {\n                    Ok(y) => x = f(x, y),\n\n                    // If we ran out of items, combine whatever we did manage\n                    // to get.  It's better combined with the current value\n                    // than something in a parent frame, because the tree in\n                    // the parent is always as least as big as this one.\n                    Err(None) => return Err(Some(x)),\n                    Err(Some(y)) => return Err(Some(f(x, y))),\n                }\n            }\n            Ok(x)\n        }\n\n        match inner(usize::max_value(), &mut self, &mut f) {\n            Err(x) => x,\n            _ => unreachable!(),\n        }\n    }\n\n    /// An iterator method that applies a function, producing a single, final value.\n    ///\n    /// `fold_while()` is basically equivalent to `fold()` but with additional support for\n    /// early exit via short-circuiting.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// use itertools::FoldWhile::{Continue, Done};\n    ///\n    /// let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    ///\n    /// let mut result = 0;\n    ///\n    /// // for loop:\n    /// for i in &numbers {\n    ///     if *i > 5 {\n    ///         break;\n    ///     }\n    ///     result = result + i;\n    /// }\n    ///\n    /// // fold:\n    /// let result2 = numbers.iter().fold(0, |acc, x| {\n    ///     if *x > 5 { acc } else { acc + x }\n    /// });\n    ///\n    /// // fold_while:\n    /// let result3 = numbers.iter().fold_while(0, |acc, x| {\n    ///     if *x > 5 { Done(acc) } else { Continue(acc + x) }\n    /// }).into_inner();\n    ///\n    /// // they're the same\n    /// assert_eq!(result, result2);\n    /// assert_eq!(result2, result3);\n    /// ```\n    ///\n    /// The big difference between the computations of `result2` and `result3` is that while\n    /// `fold()` called the provided closure for every item of the callee iterator,\n    /// `fold_while()` actually stopped iterating as soon as it encountered `Fold::Done(_)`.\n    #[deprecated(note=\"Use .try_fold() instead\", since=\"0.8\")]\n    fn fold_while<B, F>(&mut self, init: B, mut f: F) -> FoldWhile<B>\n        where Self: Sized,\n              F: FnMut(B, Self::Item) -> FoldWhile<B>\n    {\n        let mut acc = init;\n        while let Some(item) = self.next() {\n            match f(acc, item) {\n                FoldWhile::Continue(res) => acc = res,\n                res @ FoldWhile::Done(_) => return res,\n            }\n        }\n        FoldWhile::Continue(acc)\n    }\n\n    /// Iterate over the entire iterator and add all the elements.\n    ///\n    /// An empty iterator returns `None`, otherwise `Some(sum)`.\n    ///\n    /// # Panics\n    ///\n    /// When calling `sum1()` and a primitive integer type is being returned, this\n    /// method will panic if the computation overflows and debug assertions are\n    /// enabled.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let empty_sum = (1..1).sum1::<i32>();\n    /// assert_eq!(empty_sum, None);\n    ///\n    /// let nonempty_sum = (1..11).sum1::<i32>();\n    /// assert_eq!(nonempty_sum, Some(55));\n    /// ```\n    fn sum1<S>(mut self) -> Option<S>\n        where Self: Sized,\n              S: std::iter::Sum<Self::Item>,\n    {\n        self.next()\n            .map(|first| once(first).chain(self).sum())\n    }\n\n    /// Iterate over the entire iterator and multiply all the elements.\n    ///\n    /// An empty iterator returns `None`, otherwise `Some(product)`.\n    ///\n    /// # Panics\n    ///\n    /// When calling `product1()` and a primitive integer type is being returned,\n    /// method will panic if the computation overflows and debug assertions are\n    /// enabled.\n    ///\n    /// # Examples\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let empty_product = (1..1).product1::<i32>();\n    /// assert_eq!(empty_product, None);\n    ///\n    /// let nonempty_product = (1..11).product1::<i32>();\n    /// assert_eq!(nonempty_product, Some(3628800));\n    /// ```\n    fn product1<P>(mut self) -> Option<P>\n        where Self: Sized,\n              P: std::iter::Product<Self::Item>,\n    {\n        self.next()\n            .map(|first| once(first).chain(self).product())\n    }\n\n\n    /// Sort all iterator elements into a new iterator in ascending order.\n    ///\n    /// **Note:** This consumes the entire iterator, uses the\n    /// `slice::sort()` method and returns the result as a new\n    /// iterator that owns its elements.\n    ///\n    /// The sorted iterator, if directly collected to a `Vec`, is converted\n    /// without any extra copying or allocation cost.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // sort the letters of the text in ascending order\n    /// let text = \"bdacfe\";\n    /// itertools::assert_equal(text.chars().sorted(),\n    ///                         \"abcdef\".chars());\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn sorted(self) -> VecIntoIter<Self::Item>\n        where Self: Sized,\n              Self::Item: Ord\n    {\n        // Use .sort() directly since it is not quite identical with\n        // .sort_by(Ord::cmp)\n        let mut v = Vec::from_iter(self);\n        v.sort();\n        v.into_iter()\n    }\n\n    /// Sort all iterator elements into a new iterator in ascending order.\n    ///\n    /// **Note:** This consumes the entire iterator, uses the\n    /// `slice::sort_by()` method and returns the result as a new\n    /// iterator that owns its elements.\n    ///\n    /// The sorted iterator, if directly collected to a `Vec`, is converted\n    /// without any extra copying or allocation cost.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // sort people in descending order by age\n    /// let people = vec![(\"Jane\", 20), (\"John\", 18), (\"Jill\", 30), (\"Jack\", 27)];\n    ///\n    /// let oldest_people_first = people\n    ///     .into_iter()\n    ///     .sorted_by(|a, b| Ord::cmp(&b.1, &a.1))\n    ///     .map(|(person, _age)| person);\n    ///\n    /// itertools::assert_equal(oldest_people_first,\n    ///                         vec![\"Jill\", \"Jack\", \"Jane\", \"John\"]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn sorted_by<F>(self, cmp: F) -> VecIntoIter<Self::Item>\n        where Self: Sized,\n              F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n    {\n        let mut v = Vec::from_iter(self);\n        v.sort_by(cmp);\n        v.into_iter()\n    }\n\n    /// Sort all iterator elements into a new iterator in ascending order.\n    ///\n    /// **Note:** This consumes the entire iterator, uses the\n    /// `slice::sort_by_key()` method and returns the result as a new\n    /// iterator that owns its elements.\n    ///\n    /// The sorted iterator, if directly collected to a `Vec`, is converted\n    /// without any extra copying or allocation cost.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // sort people in descending order by age\n    /// let people = vec![(\"Jane\", 20), (\"John\", 18), (\"Jill\", 30), (\"Jack\", 27)];\n    ///\n    /// let oldest_people_first = people\n    ///     .into_iter()\n    ///     .sorted_by_key(|x| -x.1)\n    ///     .map(|(person, _age)| person);\n    ///\n    /// itertools::assert_equal(oldest_people_first,\n    ///                         vec![\"Jill\", \"Jack\", \"Jane\", \"John\"]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn sorted_by_key<K, F>(self, f: F) -> VecIntoIter<Self::Item>\n        where Self: Sized,\n              K: Ord,\n              F: FnMut(&Self::Item) -> K,\n    {\n        let mut v = Vec::from_iter(self);\n        v.sort_by_key(f);\n        v.into_iter()\n    }\n\n    /// Collect all iterator elements into one of two\n    /// partitions. Unlike `Iterator::partition`, each partition may\n    /// have a distinct type.\n    ///\n    /// ```\n    /// use itertools::{Itertools, Either};\n    ///\n    /// let successes_and_failures = vec![Ok(1), Err(false), Err(true), Ok(2)];\n    ///\n    /// let (successes, failures): (Vec<_>, Vec<_>) = successes_and_failures\n    ///     .into_iter()\n    ///     .partition_map(|r| {\n    ///         match r {\n    ///             Ok(v) => Either::Left(v),\n    ///             Err(v) => Either::Right(v),\n    ///         }\n    ///     });\n    ///\n    /// assert_eq!(successes, [1, 2]);\n    /// assert_eq!(failures, [false, true]);\n    /// ```\n    fn partition_map<A, B, F, L, R>(self, mut predicate: F) -> (A, B)\n        where Self: Sized,\n              F: FnMut(Self::Item) -> Either<L, R>,\n              A: Default + Extend<L>,\n              B: Default + Extend<R>,\n    {\n        let mut left = A::default();\n        let mut right = B::default();\n\n        self.for_each(|val| match predicate(val) {\n            Either::Left(v) => left.extend(Some(v)),\n            Either::Right(v) => right.extend(Some(v)),\n        });\n\n        (left, right)\n    }\n\n    /// Return a `HashMap` of keys mapped to `Vec`s of values. Keys and values\n    /// are taken from `(Key, Value)` tuple pairs yielded by the input iterator.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![(0, 10), (2, 12), (3, 13), (0, 20), (3, 33), (2, 42)];\n    /// let lookup = data.into_iter().into_group_map();\n    ///\n    /// assert_eq!(lookup[&0], vec![10, 20]);\n    /// assert_eq!(lookup.get(&1), None);\n    /// assert_eq!(lookup[&2], vec![12, 42]);\n    /// assert_eq!(lookup[&3], vec![13, 33]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn into_group_map<K, V>(self) -> HashMap<K, Vec<V>>\n        where Self: Iterator<Item=(K, V)> + Sized,\n              K: Hash + Eq,\n    {\n        group_map::into_group_map(self)\n    }\n\n    /// Return the minimum and maximum elements in the iterator.\n    ///\n    /// The return type `MinMaxResult` is an enum of three variants:\n    ///\n    /// - `NoElements` if the iterator is empty.\n    /// - `OneElement(x)` if the iterator has exactly one element.\n    /// - `MinMax(x, y)` is returned otherwise, where `x <= y`. Two\n    ///    values are equal if and only if there is more than one\n    ///    element in the iterator and all elements are equal.\n    ///\n    /// On an iterator of length `n`, `minmax` does `1.5 * n` comparisons,\n    /// and so is faster than calling `min` and `max` separately which does\n    /// `2 * n` comparisons.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// use itertools::MinMaxResult::{NoElements, OneElement, MinMax};\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().minmax(), NoElements);\n    ///\n    /// let a = [1];\n    /// assert_eq!(a.iter().minmax(), OneElement(&1));\n    ///\n    /// let a = [1, 2, 3, 4, 5];\n    /// assert_eq!(a.iter().minmax(), MinMax(&1, &5));\n    ///\n    /// let a = [1, 1, 1, 1];\n    /// assert_eq!(a.iter().minmax(), MinMax(&1, &1));\n    /// ```\n    ///\n    /// The elements can be floats but no particular result is guaranteed\n    /// if an element is NaN.\n    fn minmax(self) -> MinMaxResult<Self::Item>\n        where Self: Sized, Self::Item: PartialOrd\n    {\n        minmax::minmax_impl(self, |_| (), |x, y, _, _| x < y)\n    }\n\n    /// Return the minimum and maximum element of an iterator, as determined by\n    /// the specified function.\n    ///\n    /// The return value is a variant of `MinMaxResult` like for `minmax()`.\n    ///\n    /// For the minimum, the first minimal element is returned.  For the maximum,\n    /// the last maximal element wins.  This matches the behavior of the standard\n    /// `Iterator::min()` and `Iterator::max()` methods.\n    ///\n    /// The keys can be floats but no particular result is guaranteed\n    /// if a key is NaN.\n    fn minmax_by_key<K, F>(self, key: F) -> MinMaxResult<Self::Item>\n        where Self: Sized, K: PartialOrd, F: FnMut(&Self::Item) -> K\n    {\n        minmax::minmax_impl(self, key, |_, _, xk, yk| xk < yk)\n    }\n\n    /// Return the minimum and maximum element of an iterator, as determined by\n    /// the specified comparison function.\n    ///\n    /// The return value is a variant of `MinMaxResult` like for `minmax()`.\n    ///\n    /// For the minimum, the first minimal element is returned.  For the maximum,\n    /// the last maximal element wins.  This matches the behavior of the standard\n    /// `Iterator::min()` and `Iterator::max()` methods.\n    fn minmax_by<F>(self, mut compare: F) -> MinMaxResult<Self::Item>\n        where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering\n    {\n        minmax::minmax_impl(\n            self,\n            |_| (),\n            |x, y, _, _| Ordering::Less == compare(x, y)\n        )\n    }\n\n    /// Return the position of the maximum element in the iterator.\n    ///\n    /// If several elements are equally maximum, the position of the\n    /// last of them is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_max(), None);\n    ///\n    /// let a = [-3, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_max(), Some(3));\n    ///\n    /// let a = [1, 1, -1, -1];\n    /// assert_eq!(a.iter().position_max(), Some(1));\n    /// ```\n    fn position_max(self) -> Option<usize>\n        where Self: Sized, Self::Item: Ord\n    {\n        self.enumerate()\n            .max_by(|x, y| Ord::cmp(&x.1, &y.1))\n            .map(|x| x.0)\n    }\n\n    /// Return the position of the maximum element in the iterator, as\n    /// determined by the specified function.\n    ///\n    /// If several elements are equally maximum, the position of the\n    /// last of them is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_max_by_key(|x| x.abs()), None);\n    ///\n    /// let a = [-3_i32, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_max_by_key(|x| x.abs()), Some(4));\n    ///\n    /// let a = [1_i32, 1, -1, -1];\n    /// assert_eq!(a.iter().position_max_by_key(|x| x.abs()), Some(3));\n    /// ```\n    fn position_max_by_key<K, F>(self, mut key: F) -> Option<usize>\n        where Self: Sized, K: Ord, F: FnMut(&Self::Item) -> K\n    {\n        self.enumerate()\n            .max_by(|x, y| Ord::cmp(&key(&x.1), &key(&y.1)))\n            .map(|x| x.0)\n    }\n\n    /// Return the position of the maximum element in the iterator, as\n    /// determined by the specified comparison function.\n    ///\n    /// If several elements are equally maximum, the position of the\n    /// last of them is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_max_by(|x, y| x.cmp(y)), None);\n    ///\n    /// let a = [-3_i32, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_max_by(|x, y| x.cmp(y)), Some(3));\n    ///\n    /// let a = [1_i32, 1, -1, -1];\n    /// assert_eq!(a.iter().position_max_by(|x, y| x.cmp(y)), Some(1));\n    /// ```\n    fn position_max_by<F>(self, mut compare: F) -> Option<usize>\n        where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering\n    {\n        self.enumerate()\n            .max_by(|x, y| compare(&x.1, &y.1))\n            .map(|x| x.0)\n    }\n\n    /// Return the position of the minimum element in the iterator.\n    ///\n    /// If several elements are equally minimum, the position of the\n    /// first of them is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_min(), None);\n    ///\n    /// let a = [-3, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_min(), Some(4));\n    ///\n    /// let a = [1, 1, -1, -1];\n    /// assert_eq!(a.iter().position_min(), Some(2));\n    /// ```\n    fn position_min(self) -> Option<usize>\n        where Self: Sized, Self::Item: Ord\n    {\n        self.enumerate()\n            .min_by(|x, y| Ord::cmp(&x.1, &y.1))\n            .map(|x| x.0)\n    }\n\n    /// Return the position of the minimum element in the iterator, as\n    /// determined by the specified function.\n    ///\n    /// If several elements are equally minimum, the position of the\n    /// first of them is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_min_by_key(|x| x.abs()), None);\n    ///\n    /// let a = [-3_i32, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_min_by_key(|x| x.abs()), Some(1));\n    ///\n    /// let a = [1_i32, 1, -1, -1];\n    /// assert_eq!(a.iter().position_min_by_key(|x| x.abs()), Some(0));\n    /// ```\n    fn position_min_by_key<K, F>(self, mut key: F) -> Option<usize>\n        where Self: Sized, K: Ord, F: FnMut(&Self::Item) -> K\n    {\n        self.enumerate()\n            .min_by(|x, y| Ord::cmp(&key(&x.1), &key(&y.1)))\n            .map(|x| x.0)\n    }\n\n    /// Return the position of the minimum element in the iterator, as\n    /// determined by the specified comparison function.\n    ///\n    /// If several elements are equally minimum, the position of the\n    /// first of them is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_min_by(|x, y| x.cmp(y)), None);\n    ///\n    /// let a = [-3_i32, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_min_by(|x, y| x.cmp(y)), Some(4));\n    ///\n    /// let a = [1_i32, 1, -1, -1];\n    /// assert_eq!(a.iter().position_min_by(|x, y| x.cmp(y)), Some(2));\n    /// ```\n    fn position_min_by<F>(self, mut compare: F) -> Option<usize>\n        where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering\n    {\n        self.enumerate()\n            .min_by(|x, y| compare(&x.1, &y.1))\n            .map(|x| x.0)\n    }\n\n    /// Return the positions of the minimum and maximum elements in\n    /// the iterator.\n    ///\n    /// The return type [`MinMaxResult`] is an enum of three variants:\n    ///\n    /// - `NoElements` if the iterator is empty.\n    /// - `OneElement(xpos)` if the iterator has exactly one element.\n    /// - `MinMax(xpos, ypos)` is returned otherwise, where the\n    ///    element at `xpos` ≤ the element at `ypos`. While the\n    ///    referenced elements themselves may be equal, `xpos` cannot\n    ///    be equal to `ypos`.\n    ///\n    /// On an iterator of length `n`, `position_minmax` does `1.5 * n`\n    /// comparisons, and so is faster than calling `positon_min` and\n    /// `position_max` separately which does `2 * n` comparisons.\n    ///\n    /// For the minimum, if several elements are equally minimum, the\n    /// position of the first of them is returned. For the maximum, if\n    /// several elements are equally maximum, the position of the last\n    /// of them is returned.\n    ///\n    /// The elements can be floats but no particular result is\n    /// guaranteed if an element is NaN.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// use itertools::MinMaxResult::{NoElements, OneElement, MinMax};\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_minmax(), NoElements);\n    ///\n    /// let a = [10];\n    /// assert_eq!(a.iter().position_minmax(), OneElement(0));\n    ///\n    /// let a = [-3, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_minmax(), MinMax(4, 3));\n    ///\n    /// let a = [1, 1, -1, -1];\n    /// assert_eq!(a.iter().position_minmax(), MinMax(2, 1));\n    /// ```\n    ///\n    /// [`MinMaxResult`]: enum.MinMaxResult.html\n    fn position_minmax(self) -> MinMaxResult<usize>\n        where Self: Sized, Self::Item: PartialOrd\n    {\n        use crate::MinMaxResult::{NoElements, OneElement, MinMax};\n        match minmax::minmax_impl(self.enumerate(), |_| (), |x, y, _, _| x.1 < y.1) {\n            NoElements => NoElements,\n            OneElement(x) => OneElement(x.0),\n            MinMax(x, y) => MinMax(x.0, y.0),\n        }\n    }\n\n    /// Return the postions of the minimum and maximum elements of an\n    /// iterator, as determined by the specified function.\n    ///\n    /// The return value is a variant of [`MinMaxResult`] like for\n    /// [`position_minmax`].\n    ///\n    /// For the minimum, if several elements are equally minimum, the\n    /// position of the first of them is returned. For the maximum, if\n    /// several elements are equally maximum, the position of the last\n    /// of them is returned.\n    ///\n    /// The keys can be floats but no particular result is guaranteed\n    /// if a key is NaN.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// use itertools::MinMaxResult::{NoElements, OneElement, MinMax};\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_minmax_by_key(|x| x.abs()), NoElements);\n    ///\n    /// let a = [10_i32];\n    /// assert_eq!(a.iter().position_minmax_by_key(|x| x.abs()), OneElement(0));\n    ///\n    /// let a = [-3_i32, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_minmax_by_key(|x| x.abs()), MinMax(1, 4));\n    ///\n    /// let a = [1_i32, 1, -1, -1];\n    /// assert_eq!(a.iter().position_minmax_by_key(|x| x.abs()), MinMax(0, 3));\n    /// ```\n    ///\n    /// [`MinMaxResult`]: enum.MinMaxResult.html\n    /// [`position_minmax`]: #method.position_minmax\n    fn position_minmax_by_key<K, F>(self, mut key: F) -> MinMaxResult<usize>\n        where Self: Sized, K: PartialOrd, F: FnMut(&Self::Item) -> K\n    {\n        use crate::MinMaxResult::{NoElements, OneElement, MinMax};\n        match self.enumerate().minmax_by_key(|e| key(&e.1)) {\n            NoElements => NoElements,\n            OneElement(x) => OneElement(x.0),\n            MinMax(x, y) => MinMax(x.0, y.0),\n        }\n    }\n\n    /// Return the postions of the minimum and maximum elements of an\n    /// iterator, as determined by the specified comparison function.\n    ///\n    /// The return value is a variant of [`MinMaxResult`] like for\n    /// [`position_minmax`].\n    ///\n    /// For the minimum, if several elements are equally minimum, the\n    /// position of the first of them is returned. For the maximum, if\n    /// several elements are equally maximum, the position of the last\n    /// of them is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// use itertools::MinMaxResult::{NoElements, OneElement, MinMax};\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_minmax_by(|x, y| x.cmp(y)), NoElements);\n    ///\n    /// let a = [10_i32];\n    /// assert_eq!(a.iter().position_minmax_by(|x, y| x.cmp(y)), OneElement(0));\n    ///\n    /// let a = [-3_i32, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_minmax_by(|x, y| x.cmp(y)), MinMax(4, 3));\n    ///\n    /// let a = [1_i32, 1, -1, -1];\n    /// assert_eq!(a.iter().position_minmax_by(|x, y| x.cmp(y)), MinMax(2, 1));\n    /// ```\n    ///\n    /// [`MinMaxResult`]: enum.MinMaxResult.html\n    /// [`position_minmax`]: #method.position_minmax\n    fn position_minmax_by<F>(self, mut compare: F) -> MinMaxResult<usize>\n        where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering\n    {\n        use crate::MinMaxResult::{NoElements, OneElement, MinMax};\n        match self.enumerate().minmax_by(|x, y| compare(&x.1, &y.1)) {\n            NoElements => NoElements,\n            OneElement(x) => OneElement(x.0),\n            MinMax(x, y) => MinMax(x.0, y.0),\n        }\n    }\n\n    /// If the iterator yields exactly one element, that element will be returned, otherwise\n    /// an error will be returned containing an iterator that has the same output as the input\n    /// iterator.\n    ///\n    /// This provides an additional layer of validation over just calling `Iterator::next()`.\n    /// If your assumption that there should only be one element yielded is false this provides\n    /// the opportunity to detect and handle that, preventing errors at a distance.\n    ///\n    /// # Examples\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// assert_eq!((0..10).filter(|&x| x == 2).exactly_one().unwrap(), 2);\n    /// assert!((0..10).filter(|&x| x > 1 && x < 4).exactly_one().unwrap_err().eq(2..4));\n    /// assert!((0..10).filter(|&x| x > 1 && x < 5).exactly_one().unwrap_err().eq(2..5));\n    /// assert!((0..10).filter(|&_| false).exactly_one().unwrap_err().eq(0..0));\n    /// ```\n    fn exactly_one(mut self) -> Result<Self::Item, ExactlyOneError<Self>>\n    where\n        Self: Sized,\n    {\n        match self.next() {\n            Some(first) => {\n                match self.next() {\n                    Some(second) => {\n                        Err(ExactlyOneError::new((Some(first), Some(second)), self))\n                    }\n                    None => {\n                        Ok(first)\n                    }\n                }\n            }\n            None => Err(ExactlyOneError::new((None, None), self)),\n        }\n    }\n\n    /// An iterator adaptor that allows the user to peek at multiple `.next()`\n    /// values without advancing the base iterator.\n    ///\n    /// # Examples\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut iter = (0..10).multipeek();\n    /// assert_eq!(iter.peek(), Some(&0));\n    /// assert_eq!(iter.peek(), Some(&1));\n    /// assert_eq!(iter.peek(), Some(&2));\n    /// assert_eq!(iter.next(), Some(0));\n    /// assert_eq!(iter.peek(), Some(&1));\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn multipeek(self) -> MultiPeek<Self>\n    where\n        Self: Sized,\n    {\n        multipeek_impl::multipeek(self)\n    }\n}\n\nimpl<T: ?Sized> Itertools for T where T: Iterator { }\n\n/// Return `true` if both iterables produce equal sequences\n/// (elements pairwise equal and sequences of the same length),\n/// `false` otherwise.\n///\n/// This is an `IntoIterator` enabled function that is similar to the standard\n/// library method `Iterator::eq`.\n///\n/// ```\n/// assert!(itertools::equal(vec![1, 2, 3], 1..4));\n/// assert!(!itertools::equal(&[0, 0], &[0, 0, 0]));\n/// ```\npub fn equal<I, J>(a: I, b: J) -> bool\n    where I: IntoIterator,\n          J: IntoIterator,\n          I::Item: PartialEq<J::Item>\n{\n    let mut ia = a.into_iter();\n    let mut ib = b.into_iter();\n    loop {\n        match ia.next() {\n            Some(x) => match ib.next() {\n                Some(y) => if x != y { return false; },\n                None => return false,\n            },\n            None => return ib.next().is_none()\n        }\n    }\n}\n\n/// Assert that two iterables produce equal sequences, with the same\n/// semantics as *equal(a, b)*.\n///\n/// **Panics** on assertion failure with a message that shows the\n/// two iteration elements.\n///\n/// ```ignore\n/// assert_equal(\"exceed\".split('c'), \"excess\".split('c'));\n/// // ^PANIC: panicked at 'Failed assertion Some(\"eed\") == Some(\"ess\") for iteration 1',\n/// ```\npub fn assert_equal<I, J>(a: I, b: J)\n    where I: IntoIterator,\n          J: IntoIterator,\n          I::Item: fmt::Debug + PartialEq<J::Item>,\n          J::Item: fmt::Debug,\n{\n    let mut ia = a.into_iter();\n    let mut ib = b.into_iter();\n    let mut i = 0;\n    loop {\n        match (ia.next(), ib.next()) {\n            (None, None) => return,\n            (a, b) => {\n                let equal = match (&a, &b) {\n                    (&Some(ref a), &Some(ref b)) => a == b,\n                    _ => false,\n                };\n                assert!(equal, \"Failed assertion {a:?} == {b:?} for iteration {i}\",\n                        i=i, a=a, b=b);\n                i += 1;\n            }\n        }\n    }\n}\n\n/// Partition a sequence using predicate `pred` so that elements\n/// that map to `true` are placed before elements which map to `false`.\n///\n/// The order within the partitions is arbitrary.\n///\n/// Return the index of the split point.\n///\n/// ```\n/// use itertools::partition;\n///\n/// # // use repeated numbers to not promise any ordering\n/// let mut data = [7, 1, 1, 7, 1, 1, 7];\n/// let split_index = partition(&mut data, |elt| *elt >= 3);\n///\n/// assert_eq!(data, [7, 7, 7, 1, 1, 1, 1]);\n/// assert_eq!(split_index, 3);\n/// ```\npub fn partition<'a, A: 'a, I, F>(iter: I, mut pred: F) -> usize\n    where I: IntoIterator<Item = &'a mut A>,\n          I::IntoIter: DoubleEndedIterator,\n          F: FnMut(&A) -> bool\n{\n    let mut split_index = 0;\n    let mut iter = iter.into_iter();\n    'main: while let Some(front) = iter.next() {\n        if !pred(front) {\n            loop {\n                match iter.next_back() {\n                    Some(back) => if pred(back) {\n                        std::mem::swap(front, back);\n                        break;\n                    },\n                    None => break 'main,\n                }\n            }\n        }\n        split_index += 1;\n    }\n    split_index\n}\n\n/// An enum used for controlling the execution of `.fold_while()`.\n///\n/// See [`.fold_while()`](trait.Itertools.html#method.fold_while) for more information.\n#[derive(Copy, Clone, Debug, Eq, PartialEq)]\npub enum FoldWhile<T> {\n    /// Continue folding with this value\n    Continue(T),\n    /// Fold is complete and will return this value\n    Done(T),\n}\n\nimpl<T> FoldWhile<T> {\n    /// Return the value in the continue or done.\n    pub fn into_inner(self) -> T {\n        match self {\n            FoldWhile::Continue(x) | FoldWhile::Done(x) => x,\n        }\n    }\n\n    /// Return true if `self` is `Done`, false if it is `Continue`.\n    pub fn is_done(&self) -> bool {\n        match *self {\n            FoldWhile::Continue(_) => false,\n            FoldWhile::Done(_) => true,\n        }\n    }\n}\n","traces":[{"line":355,"address":[5248000,5248096],"length":1,"stats":{"Line":2},"fn_name":"interleave<quick::Iter<i16, quick::Inexact>,quick::Iter<i16, quick::Inexact>>"},{"line":359,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":373,"address":[4862976,4863100],"length":1,"stats":{"Line":5},"fn_name":"interleave_shortest<core::slice::Iter<()>,&alloc::vec::Vec<()>>"},{"line":377,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":392,"address":[4217728],"length":1,"stats":{"Line":5},"fn_name":"intersperse<core::ops::range::Range<i32>>"},{"line":396,"address":[4217747],"length":1,"stats":{"Line":5},"fn_name":null},{"line":426,"address":[4232688,4232823],"length":1,"stats":{"Line":8},"fn_name":"zip_longest<itertools::adaptors::Batching<core::slice::Iter<core::option::Option<i32>>, closure-0>,core::iter::adapters::Cloned<core::slice::Iter<i32>>>"},{"line":430,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[4229040],"length":1,"stats":{"Line":2},"fn_name":"batching<core::slice::Iter<core::option::Option<i32>>,i32,closure-0>"},{"line":473,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":511,"address":[4864064,4864016,4863968],"length":1,"stats":{"Line":18},"fn_name":"group_by<core::slice::Iter<u8>,u8,closure-0>"},{"line":516,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":547,"address":[4863440,4863504],"length":1,"stats":{"Line":2},"fn_name":"chunks<core::slice::Iter<u8>>"},{"line":550,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":585,"address":[4862672,4862720,4862768,4862624],"length":1,"stats":{"Line":8},"fn_name":"tuple_windows<core::slice::Iter<u8>,(&u8, &u8)>"},{"line":590,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[4863728,4863680,4863824,4863776],"length":1,"stats":{"Line":8},"fn_name":"tuples<core::slice::Iter<u8>,(&u8, &u8)>"},{"line":662,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":683,"address":[4863168],"length":1,"stats":{"Line":3},"fn_name":"tee<core::slice::Iter<u8>>"},{"line":687,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":708,"address":[5249760,5249840],"length":1,"stats":{"Line":7},"fn_name":"step<quick::Iter<i16, quick::Inexact>>"},{"line":711,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":743,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":760,"address":[4863376],"length":1,"stats":{"Line":3},"fn_name":"merge<core::slice::Iter<i16>,&alloc::vec::Vec<i16>>"},{"line":765,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":784,"address":[4301984,4302200],"length":1,"stats":{"Line":2},"fn_name":"merge_by<alloc::collections::btree::map::IntoIter<&str, i32>,alloc::collections::btree::map::IntoIter<&str, i32>,closure-0>"},{"line":789,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":824,"address":[4308320],"length":1,"stats":{"Line":1},"fn_name":"merge_join_by<alloc::vec::IntoIter<usize>,alloc::vec::IntoIter<usize>,fn(&usize, &usize) -> core::cmp::Ordering>"},{"line":829,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":849,"address":[4257888,4257936,4257984,4257808,4258032],"length":1,"stats":{"Line":5},"fn_name":"kmerge<core::iter::adapters::Map<alloc::vec::IntoIter<i32>, closure-0>>"},{"line":854,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":878,"address":[4687344,4687424,4687264],"length":1,"stats":{"Line":3},"fn_name":"kmerge_by<alloc::vec::IntoIter<alloc::vec::Vec<i16>>,closure-0>"},{"line":885,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":899,"address":[5249403,5249296],"length":1,"stats":{"Line":8},"fn_name":"cartesian_product<quick::Iter<u16, quick::Inexact>,quick::Iter<u16, quick::Inexact>>"},{"line":905,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":934,"address":[5249680],"length":1,"stats":{"Line":1},"fn_name":"multi_cartesian_product<quick::ShiftRange<quick::Inexact>>"},{"line":940,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":976,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":993,"address":[4863328,4863280],"length":1,"stats":{"Line":4},"fn_name":"dedup<core::slice::Iter<u8>>"},{"line":997,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1015,"address":[4863920,4863872],"length":1,"stats":{"Line":5},"fn_name":"dedup_by<core::slice::Iter<(i32, i32)>,closure-1>"},{"line":1019,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1037,"address":[4578016],"length":1,"stats":{"Line":1},"fn_name":"dedup_with_count<core::slice::Iter<i32>>"},{"line":1040,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1059,"address":[4578112,4578064],"length":1,"stats":{"Line":2},"fn_name":"dedup_by_with_count<core::slice::Iter<(i32, i32)>,closure-0>"},{"line":1063,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1085,"address":[5250080],"length":1,"stats":{"Line":4},"fn_name":"unique<quick::Iter<i8, quick::Inexact>>"},{"line":1089,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1111,"address":[4258400],"length":1,"stats":{"Line":3},"fn_name":"unique_by<core::iter::adapters::Rev<core::slice::Iter<&str>>,alloc::string::String,closure-1>"},{"line":1116,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1131,"address":[4209808,4209840],"length":1,"stats":{"Line":9},"fn_name":"peeking_take_while<itertools::adaptors::PutBack<core::ops::range::Range<i32>>,closure-0>"},{"line":1135,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1156,"address":[4862864],"length":1,"stats":{"Line":1},"fn_name":"take_while_ref<core::slice::Iter<u8>,closure-0>"},{"line":1160,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1177,"address":[6298720],"length":1,"stats":{"Line":2},"fn_name":"while_some<core::iter::adapters::Map<alloc::vec::IntoIter<itertools::adaptors::multi_product::MultiProductIter<quick::Iter<i32, quick::Inexact>>>, closure-0>,i32>"},{"line":1180,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1216,"address":[4862928],"length":1,"stats":{"Line":3},"fn_name":"tuple_combinations<core::slice::Iter<u8>,(&u8, &u8)>"},{"line":1221,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1254,"address":[4243376],"length":1,"stats":{"Line":3},"fn_name":"combinations<adaptors_no_collect::PanickingCounter>"},{"line":1258,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1281,"address":[4243504],"length":1,"stats":{"Line":2},"fn_name":"combinations_with_replacement<adaptors_no_collect::PanickingCounter>"},{"line":1286,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1327,"address":[5045648],"length":1,"stats":{"Line":5},"fn_name":"permutations<core::ops::range::Range<usize>>"},{"line":1331,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1351,"address":[5250400,5250480],"length":1,"stats":{"Line":6},"fn_name":"pad_using<quick::Iter<i8, quick::Inexact>,closure-0>"},{"line":1355,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1377,"address":[4862816],"length":1,"stats":{"Line":2},"fn_name":"with_position<core::slice::Iter<u8>>"},{"line":1380,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1434,"address":[5248192],"length":1,"stats":{"Line":3},"fn_name":"next_tuple<quick::Iter<i16, quick::Inexact>,(i16, i16, i16)>"},{"line":1438,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1459,"address":[5248959,5248928],"length":1,"stats":{"Line":2},"fn_name":"collect_tuple<quick::Iter<i16, quick::Inexact>,(i16, i16, i16)>"},{"line":1463,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":1464,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1465,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1466,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1468,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1483,"address":[4325565,4325488],"length":1,"stats":{"Line":1},"fn_name":"find_position<Iterator,closure-1>"},{"line":1486,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1487,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1488,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1489,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1491,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1493,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1512,"address":[4208832,4208867],"length":1,"stats":{"Line":2},"fn_name":"all_equal<core::str::Chars>"},{"line":1516,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1517,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1518,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1537,"address":[5250144,5250181],"length":1,"stats":{"Line":2},"fn_name":"dropping<quick::Iter<i8, quick::Inexact>>"},{"line":1540,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1541,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1543,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1565,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1566,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1568,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1589,"address":[4217248],"length":1,"stats":{"Line":2},"fn_name":"foreach<core::slice::Iter<i32>,closure-0>"},{"line":1593,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1609,"address":[5029312,5029392],"length":1,"stats":{"Line":2},"fn_name":"concat<alloc::vec::IntoIter<alloc::vec::Vec<()>>>"},{"line":1613,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1619,"address":[4778480],"length":1,"stats":{"Line":9},"fn_name":"collect_vec<itertools::permutations::Permutations<core::ops::range::Range<usize>>>"},{"line":1622,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1651,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1670,"address":[4218090,4217456,4218016,4217524],"length":1,"stats":{"Line":2},"fn_name":"set_from<core::slice::IterMut<i32>,i32,core::ops::range::Range<i32>>"},{"line":1674,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1675,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1676,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1677,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1678,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1680,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1682,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1696,"address":[4578160,4578248],"length":1,"stats":{"Line":1},"fn_name":"join<core::slice::Iter<i32>>"},{"line":1699,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1700,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1701,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1703,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1704,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1705,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1706,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1707,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1708,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1710,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1730,"address":[4579760,4579680],"length":1,"stats":{"Line":2},"fn_name":"format<core::slice::Iter<i32>>"},{"line":1733,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1772,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1821,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1822,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1823,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1824,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1827,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1853,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1854,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1855,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1856,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1859,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1874,"address":[6300432,6300032,6300489,6300089,6300240,6300306],"length":1,"stats":{"Line":7},"fn_name":"fold1<core::iter::adapters::Cloned<core::slice::Iter<f64>>,fn(f64, f64) -> f64>"},{"line":1878,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":1929,"address":[6298528,6298512],"length":1,"stats":{"Line":3},"fn_name":"tree_fold1<core::iter::adapters::Cloned<core::slice::Iter<f64>>,fn(f64, f64) -> f64>"},{"line":1933,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1935,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1936,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1937,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1938,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1944,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1945,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1946,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1947,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1948,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1949,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1950,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1953,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1954,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1955,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1956,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1958,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":1959,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1962,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1963,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1964,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1966,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1968,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1969,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1975,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1976,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1979,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1982,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1983,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1984,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2028,"address":[5028144,5028203],"length":1,"stats":{"Line":1},"fn_name":"fold_while<alloc::vec::IntoIter<i32>,i32,closure-0>"},{"line":2032,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2033,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":2034,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2035,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2036,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2039,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2063,"address":[4281296,4281340],"length":1,"stats":{"Line":1},"fn_name":"sum1<core::iter::adapters::Cloned<core::slice::Iter<i32>>,i32>"},{"line":2067,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2068,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":2091,"address":[4281564,4281520],"length":1,"stats":{"Line":1},"fn_name":"product1<core::iter::adapters::Cloned<core::slice::Iter<i32>>,i32>"},{"line":2095,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2096,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":2124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2153,"address":[4258224,4258128],"length":1,"stats":{"Line":2},"fn_name":"sorted_by<core::iter::adapters::Cloned<core::slice::Iter<i32>>,closure-0>"},{"line":2157,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2158,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":2159,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2186,"address":[4257392,4257296],"length":1,"stats":{"Line":2},"fn_name":"sorted_by_key<core::iter::adapters::Cloned<core::slice::Iter<i32>>,i32,closure-0>"},{"line":2191,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2192,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":2193,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2249,"address":[6299952],"length":1,"stats":{"Line":1},"fn_name":"into_group_map<core::iter::adapters::Map<alloc::vec::IntoIter<u8>, closure-0>,u8,u8>"},{"line":2253,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2291,"address":[4863632],"length":1,"stats":{"Line":5},"fn_name":"minmax<core::slice::Iter<quick::Val>>"},{"line":2294,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":2308,"address":[4577968],"length":1,"stats":{"Line":1},"fn_name":"minmax_by_key<core::slice::Iter<test_std::minmax::Val>,u32,closure-0>"},{"line":2311,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":2322,"address":[4580661,4580608],"length":1,"stats":{"Line":1},"fn_name":"minmax_by<core::slice::Iter<test_std::minmax::Val>,closure-1>"},{"line":2325,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2326,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2327,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2328,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":2354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2439,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2465,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2466,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2493,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2494,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2495,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2545,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2546,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2547,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2548,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2549,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2591,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2592,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2593,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2594,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2595,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2634,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2635,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2636,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2637,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2638,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2659,"address":[6298800,6298893],"length":1,"stats":{"Line":5},"fn_name":"exactly_one<core::iter::adapters::Cloned<core::slice::Iter<i32>>>"},{"line":2663,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":2664,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":2665,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":2666,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":2667,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":2669,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2670,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2674,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":2697,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2714,"address":[5444128,5448513,5446272,5438016,5458153,5454832,5450573,5455025,5448352,5445307,5442080,5449497,5456960,5457143,5460261,5438153,5442238,5447473,5452640,5436992,5449360,5443231,5453792,5439161,5444277,5452780,5440205,5441072,5440064,5441233,5445152,5443088,5446409,5447312,5450400,5451737,5453910,5455936,5437135,5456077,5458016,5451600,5439024,5435888,5459024,5436028,5459205,5460112,5461168,5461305],"length":1,"stats":{"Line":25},"fn_name":"equal<core::iter::adapters::Map<core::slice::Windows<u8>, closure-0>,itertools::tuple_impl::TupleWindows<core::slice::Iter<u8>, (&u8, &u8)>>"},{"line":2719,"address":[5453809,5455948,5436999,5443095,5441079,5446279,5440076,5451607,5447319,5448359,5442087,5450407,5459041,5458023,5438023,5454849,5456972,5460119,5445159,5461175,5449367,5444135,5439031,5435895,5452647],"length":1,"stats":{"Line":25},"fn_name":null},{"line":2720,"address":[5451681,5452721,5435969,5442170,5458097,5439105,5445236,5444209,5441153,5447393,5450514,5443169,5456027,5453930,5438097,5437073,5457051,5460193,5449441,5459125,5446353,5440155,5461249,5448433,5453875,5454933],"length":1,"stats":{"Line":26},"fn_name":null},{"line":2721,"address":[5437855,5455777,5456092,5461011,5457865,5441921,5442926,5444997,5447488,5448193,5439176,5458871,5453948,5455040,5436043,5444292,5452795,5440923,5451752,5453630,5445322,5454679,5437150,5452485,5456799,5459957,5460276,5461320,5446121,5450239,5462047,5459220,5451443,5438871,5450588,5458168,5438168,5442253,5439903,5440220,5446424,5436842,5447151,5449201,5449512,5443981,5443246,5441248,5457158,5448528],"length":1,"stats":{"Line":50},"fn_name":null},{"line":2722,"address":[5448564,5457193,5438199,5440232,5441357,5452928,5458199,5439309,5461380,5437179,5441260,5438260,5447531,5451764,5449572,5456188,5439193,5456127,5438180,5445358,5457165,5445334,5442362,5457254,5459265,5440312,5440251,5448637,5451854,5453970,5454054,5452807,5461337,5446557,5441284,5442265,5444321,5452844,5455047,5444312,5451793,5444377,5442289,5437235,5455146,5443266,5436163,5460371,5450731,5459227,5443285,5446484,5456099,5458260,5436055,5447600,5455085,5446441,5436079,5460296,5439236,5449645,5453989,5448540,5459326,5460315,5461453,5447500,5458180,5450647,5443341,5450610,5437170,5445442,5449529],"length":1,"stats":{"Line":52},"fn_name":null},{"line":2723,"address":[5441473,5436108,5447709,5448639,5445444,5439425,5455101,5447557,5461569,5437345,5446559,5450874,5442478,5447602,5448593,5448753,5438215,5437187,5440416,5450733,5436306,5459430,5440267,5456190,5436165,5441359,5443451,5455250,5444329,5445585,5446673,5438262,5457358,5454162,5460373,5457256,5460481,5455148,5451809,5458262,5443293,5460323,5454005,5451958,5444379,5452930,5453071,5449647,5456143,5459328,5461409,5438364,5459281,5439311,5449601,5440314,5442364,5445387,5449761,5437237,5439265,5450676,5441313,5444487,5452873,5454056,5442318,5446513,5457209,5458215,5458364,5443343,5451856,5461455,5456292],"length":1,"stats":{"Line":52},"fn_name":null},{"line":2724,"address":[5442562,5445697,5460441,5454164,5441439,5443453,5444599,5440376,5453183,5455252,5437347,5439427,5453073,5441557,5438366,5454122,5447674,5452054,5455210,5456388,5459390,5446639,5457360,5448837,5460483,5457318,5449763,5461535,5436418,5442444,5445543,5448719,5457454,5450986,5436308,5449845,5447795,5444489,5446757,5456294,5442480,5448755,5449727,5438324,5450832,5453029,5458324,5437457,5450876,5437305,5444447,5439509,5443411,5461571,5455346,5443563,5458460,5460593,5461653,5451960,5440418,5459526,5451918,5454258,5440512,5436264,5438460,5459432,5439391,5456252,5441475,5445587,5458366,5447711,5446675],"length":1,"stats":{"Line":50},"fn_name":null},{"line":2725,"address":[5451948,5441463,5439415,5448743,5447699,5449751,5436296,5450864,5445575,5440406,5443441,5444477,5453061,5455240,5458354,5459420,5457348,5446663,5454152,5460471,5437335,5442468,5438354,5461559,5456282],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2727,"address":[5453300,5454385,5442342,5446537,5448930,5455131,5443331,5441337,5458245,5443683,5440297,5438245,5458577,5452908,5447582,5441650,5455463,5456173,5444719,5460361,5461433,5445814,5438577,5437225,5437577,5449625,5436143,5457239,5436535,5451839,5449948,5459311,5459643,5450711,5446860,5444367,5448617,5460713,5439612,5440629,5445422,5447895,5454030,5456505,5457571,5461756,5452171,5439289,5442655,5451113],"length":1,"stats":{"Line":52},"fn_name":null},{"line":2742,"address":[4229584,4229729],"length":1,"stats":{"Line":49},"fn_name":"assert_equal<itertools::zip_longest::ZipLongest<itertools::adaptors::Batching<core::slice::Iter<core::option::Option<i32>>, closure-0>, core::iter::adapters::Cloned<core::slice::Iter<i32>>>,alloc::vec::Vec<itertools::either_or_both::EitherOrBoth<i32, i32>>>"},{"line":2748,"address":[4229591],"length":1,"stats":{"Line":49},"fn_name":null},{"line":2749,"address":[4229670],"length":1,"stats":{"Line":69},"fn_name":null},{"line":2750,"address":[4229744],"length":1,"stats":{"Line":49},"fn_name":null},{"line":2751,"address":[4229755,4230691],"length":1,"stats":{"Line":100},"fn_name":null},{"line":2752,"address":[4229775,4229914,4229813],"length":1,"stats":{"Line":100},"fn_name":null},{"line":2753,"address":[4229884,4229925],"length":1,"stats":{"Line":102},"fn_name":null},{"line":2754,"address":[4229984],"length":1,"stats":{"Line":51},"fn_name":null},{"line":2755,"address":[4230044,4230176,4230228],"length":1,"stats":{"Line":102},"fn_name":null},{"line":2756,"address":[4230076,4230182],"length":1,"stats":{"Line":102},"fn_name":null},{"line":2757,"address":[4230168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2759,"address":[4230237],"length":1,"stats":{"Line":51},"fn_name":null},{"line":2760,"address":[4230418,4230470,4230328],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2761,"address":[4230833,4230682,4230250,4230863],"length":1,"stats":{"Line":103},"fn_name":null},{"line":2784,"address":[5464800,5464865],"length":1,"stats":{"Line":4},"fn_name":"partition<i32,&mut alloc::vec::Vec<i32>,closure-0>"},{"line":2789,"address":[5464812],"length":1,"stats":{"Line":4},"fn_name":null},{"line":2790,"address":[5464821],"length":1,"stats":{"Line":4},"fn_name":null},{"line":2791,"address":[5464882,5464863,5464914,5465193],"length":1,"stats":{"Line":16},"fn_name":null},{"line":2792,"address":[5465147,5464954],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2793,"address":[5465125],"length":1,"stats":{"Line":3},"fn_name":null},{"line":2794,"address":[5465005,5465057],"length":1,"stats":{"Line":4},"fn_name":null},{"line":2795,"address":[5465030,5465059],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2796,"address":[5465127],"length":1,"stats":{"Line":4},"fn_name":null},{"line":2799,"address":[5465055],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2803,"address":[5465161,5465253],"length":1,"stats":{"Line":4},"fn_name":null},{"line":2805,"address":[5465149],"length":1,"stats":{"Line":4},"fn_name":null},{"line":2821,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2822,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2823,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":2828,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2829,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2830,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2831,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":212,"coverable":298},{"path":["/","home","kms","itertools","src","merge_join.rs"],"content":"use std::cmp::Ordering;\nuse std::iter::Fuse;\nuse std::fmt;\n\nuse super::adaptors::{PutBack, put_back};\nuse crate::either_or_both::EitherOrBoth;\n\n/// Return an iterator adaptor that merge-joins items from the two base iterators in ascending order.\n///\n/// See [`.merge_join_by()`](trait.Itertools.html#method.merge_join_by) for more information.\npub fn merge_join_by<I, J, F>(left: I, right: J, cmp_fn: F)\n    -> MergeJoinBy<I::IntoIter, J::IntoIter, F>\n    where I: IntoIterator,\n          J: IntoIterator,\n          F: FnMut(&I::Item, &J::Item) -> Ordering\n{\n    MergeJoinBy {\n        left: put_back(left.into_iter().fuse()),\n        right: put_back(right.into_iter().fuse()),\n        cmp_fn,\n    }\n}\n\n/// An iterator adaptor that merge-joins items from the two base iterators in ascending order.\n///\n/// See [`.merge_join_by()`](../trait.Itertools.html#method.merge_join_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MergeJoinBy<I: Iterator, J: Iterator, F> {\n    left: PutBack<Fuse<I>>,\n    right: PutBack<Fuse<J>>,\n    cmp_fn: F\n}\n\nimpl<I, J, F> Clone for MergeJoinBy<I, J, F>\n    where I: Iterator,\n          J: Iterator,\n          PutBack<Fuse<I>>: Clone,\n          PutBack<Fuse<J>>: Clone,\n          F: Clone,\n{\n    clone_fields!(left, right, cmp_fn);\n}\n\nimpl<I, J, F> fmt::Debug for MergeJoinBy<I, J, F>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n          J: Iterator + fmt::Debug,\n          J::Item: fmt::Debug,\n{\n    debug_fmt_fields!(MergeJoinBy, left, right);\n}\n\nimpl<I, J, F> Iterator for MergeJoinBy<I, J, F>\n    where I: Iterator,\n          J: Iterator,\n          F: FnMut(&I::Item, &J::Item) -> Ordering\n{\n    type Item = EitherOrBoth<I::Item, J::Item>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match (self.left.next(), self.right.next()) {\n            (None, None) => None,\n            (Some(left), None) =>\n                Some(EitherOrBoth::Left(left)),\n            (None, Some(right)) =>\n                Some(EitherOrBoth::Right(right)),\n            (Some(left), Some(right)) => {\n                match (self.cmp_fn)(&left, &right) {\n                    Ordering::Equal =>\n                        Some(EitherOrBoth::Both(left, right)),\n                    Ordering::Less => {\n                        self.right.put_back(right);\n                        Some(EitherOrBoth::Left(left))\n                    },\n                    Ordering::Greater => {\n                        self.left.put_back(left);\n                        Some(EitherOrBoth::Right(right))\n                    }\n                }\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (a_lower, a_upper) = self.left.size_hint();\n        let (b_lower, b_upper) = self.right.size_hint();\n\n        let lower = ::std::cmp::max(a_lower, b_lower);\n\n        let upper = match (a_upper, b_upper) {\n            (Some(x), Some(y)) => x.checked_add(y),\n            _ => None,\n        };\n\n        (lower, upper)\n    }\n\n    fn count(mut self) -> usize {\n        let mut count = 0;\n        loop {\n            match (self.left.next(), self.right.next()) {\n                (None, None) => break count,\n                (Some(_left), None) => break count + 1 + self.left.into_parts().1.count(),\n                (None, Some(_right)) => break count + 1 + self.right.into_parts().1.count(),\n                (Some(left), Some(right)) => {\n                    count += 1;\n                    match (self.cmp_fn)(&left, &right) {\n                        Ordering::Equal => {}\n                        Ordering::Less => self.right.put_back(right),\n                        Ordering::Greater => self.left.put_back(left),\n                    }\n                }\n            }\n        }\n    }\n\n    fn last(mut self) -> Option<Self::Item> {\n        let mut previous_element = None;\n        loop {\n            match (self.left.next(), self.right.next()) {\n                (None, None) => break previous_element,\n                (Some(left), None) => {\n                    break Some(EitherOrBoth::Left(\n                        self.left.into_parts().1.last().unwrap_or(left),\n                    ))\n                }\n                (None, Some(right)) => {\n                    break Some(EitherOrBoth::Right(\n                        self.right.into_parts().1.last().unwrap_or(right),\n                    ))\n                }\n                (Some(left), Some(right)) => {\n                    previous_element = match (self.cmp_fn)(&left, &right) {\n                        Ordering::Equal => Some(EitherOrBoth::Both(left, right)),\n                        Ordering::Less => {\n                            self.right.put_back(right);\n                            Some(EitherOrBoth::Left(left))\n                        }\n                        Ordering::Greater => {\n                            self.left.put_back(left);\n                            Some(EitherOrBoth::Right(right))\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n        loop {\n            if n == 0 {\n                break self.next();\n            }\n            n -= 1;\n            match (self.left.next(), self.right.next()) {\n                (None, None) => break None,\n                (Some(_left), None) => break self.left.nth(n).map(EitherOrBoth::Left),\n                (None, Some(_right)) => break self.right.nth(n).map(EitherOrBoth::Right),\n                (Some(left), Some(right)) => match (self.cmp_fn)(&left, &right) {\n                    Ordering::Equal => {}\n                    Ordering::Less => self.right.put_back(right),\n                    Ordering::Greater => self.left.put_back(left),\n                },\n            }\n        }\n    }\n}\n","traces":[{"line":11,"address":[4251456,4251566],"length":1,"stats":{"Line":9},"fn_name":"merge_join_by<alloc::vec::IntoIter<usize>,alloc::vec::IntoIter<usize>,fn(&usize, &usize) -> core::cmp::Ordering>"},{"line":18,"address":[4251466,4251609],"length":1,"stats":{"Line":18},"fn_name":null},{"line":19,"address":[4251703,4251616],"length":1,"stats":{"Line":18},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":51,"coverable":74},{"path":["/","home","kms","itertools","src","minmax.rs"],"content":"\n/// `MinMaxResult` is an enum returned by `minmax`. See `Itertools::minmax()` for\n/// more detail.\n#[derive(Copy, Clone, PartialEq, Debug)]\npub enum MinMaxResult<T> {\n    /// Empty iterator\n    NoElements,\n\n    /// Iterator with one element, so the minimum and maximum are the same\n    OneElement(T),\n\n    /// More than one element in the iterator, the first element is not larger\n    /// than the second\n    MinMax(T, T)\n}\n\nimpl<T: Clone> MinMaxResult<T> {\n    /// `into_option` creates an `Option` of type `(T, T)`. The returned `Option`\n    /// has variant `None` if and only if the `MinMaxResult` has variant\n    /// `NoElements`. Otherwise `Some((x, y))` is returned where `x <= y`.\n    /// If the `MinMaxResult` has variant `OneElement(x)`, performing this\n    /// operation will make one clone of `x`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::MinMaxResult::{self, NoElements, OneElement, MinMax};\n    ///\n    /// let r: MinMaxResult<i32> = NoElements;\n    /// assert_eq!(r.into_option(), None);\n    ///\n    /// let r = OneElement(1);\n    /// assert_eq!(r.into_option(), Some((1, 1)));\n    ///\n    /// let r = MinMax(1, 2);\n    /// assert_eq!(r.into_option(), Some((1, 2)));\n    /// ```\n    pub fn into_option(self) -> Option<(T,T)> {\n        match self {\n            MinMaxResult::NoElements => None,\n            MinMaxResult::OneElement(x) => Some((x.clone(), x)),\n            MinMaxResult::MinMax(x, y) => Some((x, y))\n        }\n    }\n}\n\n/// Implementation guts for `minmax` and `minmax_by_key`.\npub fn minmax_impl<I, K, F, L>(mut it: I, mut key_for: F,\n                               mut lt: L) -> MinMaxResult<I::Item>\n    where I: Iterator,\n          F: FnMut(&I::Item) -> K,\n          L: FnMut(&I::Item, &I::Item, &K, &K) -> bool,\n{\n    let (mut min, mut max, mut min_key, mut max_key) = match it.next() {\n        None => return MinMaxResult::NoElements,\n        Some(x) => {\n            match it.next() {\n                None => return MinMaxResult::OneElement(x),\n                Some(y) => {\n                    let xk = key_for(&x);\n                    let yk = key_for(&y);\n                    if !lt(&y, &x, &yk, &xk) {(x, y, xk, yk)} else {(y, x, yk, xk)}\n                }\n            }\n        }\n    };\n\n    loop {\n        // `first` and `second` are the two next elements we want to look\n        // at.  We first compare `first` and `second` (#1). The smaller one\n        // is then compared to current minimum (#2). The larger one is\n        // compared to current maximum (#3). This way we do 3 comparisons\n        // for 2 elements.\n        let first = match it.next() {\n            None => break,\n            Some(x) => x\n        };\n        let second = match it.next() {\n            None => {\n                let first_key = key_for(&first);\n                if lt(&first, &min, &first_key, &min_key) {\n                    min = first;\n                } else if !lt(&first, &max, &first_key, &max_key) {\n                    max = first;\n                }\n                break;\n            }\n            Some(x) => x\n        };\n        let first_key = key_for(&first);\n        let second_key = key_for(&second);\n        if !lt(&second, &first, &second_key, &first_key) {\n            if lt(&first, &min, &first_key, &min_key) {\n                min = first;\n                min_key = first_key;\n            }\n            if !lt(&second, &max, &second_key, &max_key) {\n                max = second;\n                max_key = second_key;\n            }\n        } else {\n            if lt(&second, &min, &second_key, &min_key) {\n                min = second;\n                min_key = second_key;\n            }\n            if !lt(&first, &max, &first_key, &max_key) {\n                max = first;\n                max_key = first_key;\n            }\n        }\n    }\n\n    MinMaxResult::MinMax(min, max)\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[5208688,5205232,5208817,5205373],"length":1,"stats":{"Line":7},"fn_name":"minmax_impl<core::iter::adapters::Cloned<core::slice::Iter<f64>>,(),closure-0,closure-1>"},{"line":54,"address":[5207898,5208884,5205453,5205396,5208837,5211352,5205258,5208714],"length":1,"stats":{"Line":19},"fn_name":null},{"line":55,"address":[5205463,5208853,5205430,5208894],"length":1,"stats":{"Line":9},"fn_name":null},{"line":56,"address":[5205511,5208959],"length":1,"stats":{"Line":6},"fn_name":null},{"line":57,"address":[5209049,5205553,5208999,5205628],"length":1,"stats":{"Line":6},"fn_name":null},{"line":58,"address":[5209024,5209051,5205611,5205630],"length":1,"stats":{"Line":8},"fn_name":null},{"line":59,"address":[5205702,5209138],"length":1,"stats":{"Line":5},"fn_name":null},{"line":60,"address":[5209162,5205728],"length":1,"stats":{"Line":5},"fn_name":null},{"line":61,"address":[5209201,5205767],"length":1,"stats":{"Line":6},"fn_name":null},{"line":62,"address":[5209245,5205811,5209358,5209368,5205924,5205934],"length":1,"stats":{"Line":14},"fn_name":null},{"line":68,"address":[5207999,5207777,5211462,5211210],"length":1,"stats":{"Line":10},"fn_name":null},{"line":74,"address":[5206155,5206218,5209644,5209594],"length":1,"stats":{"Line":5},"fn_name":null},{"line":75,"address":[5209619,5209656,5206201,5206230],"length":1,"stats":{"Line":7},"fn_name":null},{"line":76,"address":[5206235,5209665],"length":1,"stats":{"Line":5},"fn_name":null},{"line":78,"address":[5209798,5209762,5206323,5208014,5211477,5206366],"length":1,"stats":{"Line":10},"fn_name":null},{"line":79,"address":[5206346,5209770],"length":1,"stats":{"Line":5},"fn_name":null},{"line":80,"address":[5206376,5209808],"length":1,"stats":{"Line":5},"fn_name":null},{"line":81,"address":[5206738,5206415,5209963,5206531,5211528,5210166,5208073,5209847],"length":1,"stats":{"Line":16},"fn_name":null},{"line":82,"address":[5211507,5208050,5206654,5210086],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[5208101,5206694,5209979,5210124,5211554,5206547],"length":1,"stats":{"Line":13},"fn_name":null},{"line":84,"address":[5208078,5206702,5210132,5211533],"length":1,"stats":{"Line":6},"fn_name":null},{"line":86,"address":[5210202,5206774],"length":1,"stats":{"Line":5},"fn_name":null},{"line":88,"address":[5210211,5206779],"length":1,"stats":{"Line":5},"fn_name":null},{"line":90,"address":[5206862,5208127,5210303,5211580],"length":1,"stats":{"Line":10},"fn_name":null},{"line":91,"address":[5206878,5210319],"length":1,"stats":{"Line":5},"fn_name":null},{"line":92,"address":[5207698,5210366,5206925,5207484,5210921,5211131],"length":1,"stats":{"Line":12},"fn_name":null},{"line":93,"address":[5211708,5207168,5208257,5210609],"length":1,"stats":{"Line":5},"fn_name":null},{"line":94,"address":[5208226,5207285,5210726,5211679],"length":1,"stats":{"Line":4},"fn_name":null},{"line":95,"address":[5211700,5208249],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[5207329,5211742,5208293,5210768],"length":1,"stats":{"Line":5},"fn_name":null},{"line":98,"address":[5211713,5210887,5207448,5208262],"length":1,"stats":{"Line":4},"fn_name":null},{"line":99,"address":[5211734,5208285],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[5207050,5207493,5210491,5210930,5211776,5208329],"length":1,"stats":{"Line":10},"fn_name":null},{"line":103,"address":[5207499,5208298,5211747,5210936],"length":1,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[5208321,5211768],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[5210978,5208365,5211810,5207543],"length":1,"stats":{"Line":8},"fn_name":null},{"line":107,"address":[5207662,5208334,5211097,5211781],"length":1,"stats":{"Line":8},"fn_name":null},{"line":108,"address":[5208357,5211802],"length":1,"stats":{"Line":4},"fn_name":null},{"line":113,"address":[5206083,5209526],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":43,"coverable":44},{"path":["/","home","kms","itertools","src","multipeek_impl.rs"],"content":"use std::iter::Fuse;\nuse std::collections::VecDeque;\nuse crate::size_hint;\nuse crate::PeekingNext;\n\n/// See [`multipeek()`](../fn.multipeek.html) for more information.\n#[derive(Clone, Debug)]\npub struct MultiPeek<I>\n    where I: Iterator\n{\n    iter: Fuse<I>,\n    buf: VecDeque<I::Item>,\n    index: usize,\n}\n\n/// An iterator adaptor that allows the user to peek at multiple `.next()`\n/// values without advancing the base iterator.\npub fn multipeek<I>(iterable: I) -> MultiPeek<I::IntoIter>\n    where I: IntoIterator\n{\n    MultiPeek {\n        iter: iterable.into_iter().fuse(),\n        buf: VecDeque::new(),\n        index: 0,\n    }\n}\n\nimpl<I> MultiPeek<I>\n    where I: Iterator\n{\n    /// Reset the peeking “cursor”\n    pub fn reset_peek(&mut self) {\n        self.index = 0;\n    }\n}\n\nimpl<I: Iterator> MultiPeek<I> {\n    /// Works exactly like `.next()` with the only difference that it doesn't\n    /// advance itself. `.peek()` can be called multiple times, to peek\n    /// further ahead.\n    pub fn peek(&mut self) -> Option<&I::Item> {\n        let ret = if self.index < self.buf.len() {\n            Some(&self.buf[self.index])\n        } else {\n            match self.iter.next() {\n                Some(x) => {\n                    self.buf.push_back(x);\n                    Some(&self.buf[self.index])\n                }\n                None => return None,\n            }\n        };\n\n        self.index += 1;\n        ret\n    }\n}\n\nimpl<I> PeekingNext for MultiPeek<I>\n    where I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool\n    {\n        if self.buf.is_empty() {\n            if let Some(r) = self.peek() {\n                if !accept(r) { return None }\n            }\n        } else {\n            if let Some(r) = self.buf.get(0) {\n                if !accept(r) { return None }\n            }\n        }\n        self.next()\n    }\n}\n\nimpl<I> Iterator for MultiPeek<I>\n    where I: Iterator\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.index = 0;\n        self.buf.pop_front().or_else(|| self.iter.next())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add_scalar(self.iter.size_hint(), self.buf.len())\n    }\n}\n\n// Same size\nimpl<I> ExactSizeIterator for MultiPeek<I>\n    where I: ExactSizeIterator\n{}\n\n\n","traces":[{"line":18,"address":[5332160,5332231],"length":1,"stats":{"Line":5},"fn_name":"multipeek<quick::Iter<u16, quick::Exact>>"},{"line":22,"address":[5332243,5332182],"length":1,"stats":{"Line":10},"fn_name":null},{"line":23,"address":[5332263],"length":1,"stats":{"Line":5},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":43,"address":[5228049,5228465,5227649],"length":1,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[5331846,5331941],"length":1,"stats":{"Line":4},"fn_name":null},{"line":46,"address":[5331943,5331914],"length":1,"stats":{"Line":8},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[5331930,5332029],"length":1,"stats":{"Line":6},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[5224384,5224816,5224861,5225725,5226112,5225680,5225293,5226544,5226589,5226976,5227021,5226157,5224429,5225248],"length":1,"stats":{"Line":7},"fn_name":"peeking_next<core::iter::adapters::Map<core::slice::Iter<u8>, closure-0>,closure-6>"},{"line":65,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":27,"coverable":27},{"path":["/","home","kms","itertools","src","pad_tail.rs"],"content":"use std::iter::Fuse;\nuse crate::size_hint;\n\n/// An iterator adaptor that pads a sequence to a minimum length by filling\n/// missing elements using a closure.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.pad_using()`](../trait.Itertools.html#method.pad_using) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct PadUsing<I, F> {\n    iter: Fuse<I>,\n    min: usize,\n    pos: usize,\n    filler: F,\n}\n\n/// Create a new **PadUsing** iterator.\npub fn pad_using<I, F>(iter: I, min: usize, filler: F) -> PadUsing<I, F>\n    where I: Iterator,\n          F: FnMut(usize) -> I::Item\n{\n    PadUsing {\n        iter: iter.fuse(),\n        min,\n        pos: 0,\n        filler,\n    }\n}\n\nimpl<I, F> Iterator for PadUsing<I, F>\n    where I: Iterator,\n          F: FnMut(usize) -> I::Item\n{\n    type Item = I::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.iter.next() {\n            None => {\n                if self.pos < self.min {\n                    let e = Some((self.filler)(self.pos));\n                    self.pos += 1;\n                    e\n                } else {\n                    None\n                }\n            },\n            e => {\n                self.pos += 1;\n                e\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let tail = self.min.saturating_sub(self.pos);\n        size_hint::max(self.iter.size_hint(), (tail, Some(tail)))\n    }\n}\n\nimpl<I, F> DoubleEndedIterator for PadUsing<I, F>\n    where I: DoubleEndedIterator + ExactSizeIterator,\n          F: FnMut(usize) -> I::Item\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        if self.min == 0 {\n            self.iter.next_back()\n        } else if self.iter.len() >= self.min {\n            self.min -= 1;\n            self.iter.next_back()\n        } else {\n            self.min -= 1;\n            Some((self.filler)(self.min))\n        }\n    }\n}\n\nimpl<I, F> ExactSizeIterator for PadUsing<I, F>\n    where I: ExactSizeIterator,\n          F: FnMut(usize) -> I::Item\n{}\n","traces":[{"line":20,"address":[4260016,4260307,4260176,4260434,4260147,4260336],"length":1,"stats":{"Line":6},"fn_name":"pad_using<alloc::vec::IntoIter<usize>,closure-1>"},{"line":25,"address":[5337819,5337484,5337644],"length":1,"stats":{"Line":6},"fn_name":null},{"line":39,"address":[5336103,5336528,5336064,5335584,5335630,5336567],"length":1,"stats":{"Line":6},"fn_name":"next<quick::Iter<i8, quick::Exact>,closure-0>"},{"line":40,"address":[5336745,5336281,5336537,5336073,5335593,5335807],"length":1,"stats":{"Line":12},"fn_name":null},{"line":41,"address":[5336115,5336579,5335642],"length":1,"stats":{"Line":6},"fn_name":null},{"line":42,"address":[5335803,5336161,5336600,5336277,5336741,5336625,5335687,5335663,5336136],"length":1,"stats":{"Line":17},"fn_name":null},{"line":43,"address":[5336163,5335689,5336627],"length":1,"stats":{"Line":5},"fn_name":null},{"line":44,"address":[5336484,5336209,5336010,5335735,5336673,5336948],"length":1,"stats":{"Line":5},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":47,"address":[4259496,4259000,4258541],"length":1,"stats":{"Line":6},"fn_name":null},{"line":50,"address":[5336750,5336286,5335812],"length":1,"stats":{"Line":5},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":57,"address":[5336992,5337152,5337312],"length":1,"stats":{"Line":3},"fn_name":"size_hint<quick::Iter<i8, quick::Exact>,closure-0>"},{"line":58,"address":[5337004,5337164,5337324],"length":1,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":16,"coverable":24},{"path":["/","home","kms","itertools","src","peek_nth.rs"],"content":"use crate::size_hint;\nuse crate::PeekingNext;\nuse std::collections::VecDeque;\nuse std::iter::Fuse;\n\n/// See [`peek_nth()`](../fn.peek_nth.html) for more information.\n#[derive(Clone, Debug)]\npub struct PeekNth<I>\nwhere\n    I: Iterator,\n{\n    iter: Fuse<I>,\n    buf: VecDeque<I::Item>,\n}\n\n/// A drop-in replacement for `std::iter::Peekable` which adds a `peek_nth`\n/// method allowing the user to `peek` at a value several iterations forward\n/// without advancing the base iterator.\n///\n/// This differs from `multipeek` in that subsequent calls to `peek` or\n/// `peek_nth` will always return the same value until `next` is called\n/// (making `reset_peek` unnecessary).\npub fn peek_nth<I>(iterable: I) -> PeekNth<I::IntoIter>\nwhere\n    I: IntoIterator,\n{\n    PeekNth {\n        iter: iterable.into_iter().fuse(),\n        buf: VecDeque::new(),\n    }\n}\n\nimpl<I> PeekNth<I>\nwhere\n    I: Iterator,\n{\n    /// Works exactly like the `peek` method in `std::iter::Peekable`\n    pub fn peek(&mut self) -> Option<&I::Item> {\n        self.peek_nth(0)\n    }\n\n    /// Returns a reference to the `nth` value without advancing the iterator.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```rust\n    /// use itertools::peek_nth;\n    ///\n    /// let xs = vec![1,2,3];\n    /// let mut iter = peek_nth(xs.iter());\n    ///\n    /// assert_eq!(iter.peek_nth(0), Some(&&1));\n    /// assert_eq!(iter.next(), Some(&1));\n    ///\n    /// // The iterator does not advance even if we call `peek_nth` multiple times\n    /// assert_eq!(iter.peek_nth(0), Some(&&2));\n    /// assert_eq!(iter.peek_nth(1), Some(&&3));\n    /// assert_eq!(iter.next(), Some(&2));\n    ///\n    /// // Calling `peek_nth` past the end of the iterator will return `None`\n    /// assert_eq!(iter.peek_nth(1), None);\n    /// ```\n    pub fn peek_nth(&mut self, n: usize) -> Option<&I::Item> {\n        let unbuffered_items = (n + 1).saturating_sub(self.buf.len());\n\n        self.buf.extend(self.iter.by_ref().take(unbuffered_items));\n\n        self.buf.get(n)\n    }\n}\n\nimpl<I> Iterator for PeekNth<I>\nwhere\n    I: Iterator,\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.buf.pop_front().or_else(|| self.iter.next())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add_scalar(self.iter.size_hint(), self.buf.len())\n    }\n}\n\nimpl<I> ExactSizeIterator for PeekNth<I> where I: ExactSizeIterator {}\n\nimpl<I> PeekingNext for PeekNth<I>\nwhere\n    I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n    where\n        F: FnOnce(&Self::Item) -> bool,\n    {\n        self.peek().filter(|item| accept(item))?;\n        self.next()\n    }\n}\n","traces":[{"line":23,"address":[4293960,4293520,4293904,4293712,4293576,4293768],"length":1,"stats":{"Line":4},"fn_name":"peek_nth<core::iter::adapters::Map<core::slice::Iter<u8>, closure-1>>"},{"line":28,"address":[4293537,4293729,4293780,4293588,4293921,4293972],"length":1,"stats":{"Line":8},"fn_name":null},{"line":29,"address":[4864871],"length":1,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[4292992],"length":1,"stats":{"Line":1},"fn_name":"peek<core::iter::adapters::Map<core::slice::Iter<u8>, closure-0>>"},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[4293040,4293280],"length":1,"stats":{"Line":3},"fn_name":"peek_nth<core::iter::adapters::Map<core::slice::Iter<u8>, closure-1>>"},{"line":66,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[4293126,4293366],"length":1,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[4864704],"length":1,"stats":{"Line":3},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[4292761,4292649,4292800,4292848,4292809,4292537,4292857,4292425,4292752],"length":1,"stats":{"Line":12},"fn_name":"{{closure}}<core::iter::adapters::Map<core::slice::Iter<u8>, closure-0>>"},{"line":84,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[4289952,4291040,4290532,4290768,4290804,4290260,4289988,4291312,4290496,4291348,4291584,4291076,4290224,4291620],"length":1,"stats":{"Line":7},"fn_name":"peeking_next<core::iter::adapters::Map<core::slice::Iter<u8>, closure-0>,closure-1>"},{"line":99,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":5},"fn_name":null}],"covered":16,"coverable":16},{"path":["/","home","kms","itertools","src","peeking_take_while.rs"],"content":"use std::iter::Peekable;\nuse crate::PutBack;\n#[cfg(feature = \"use_std\")]\nuse crate::PutBackN;\n\n/// An iterator that allows peeking at an element before deciding to accept it.\n///\n/// See [`.peeking_take_while()`](trait.Itertools.html#method.peeking_take_while)\n/// for more information.\n///\n/// This is implemented by peeking adaptors like peekable and put back,\n/// but also by a few iterators that can be peeked natively, like the slice’s\n/// by reference iterator (`std::slice::Iter`).\npub trait PeekingNext : Iterator {\n    /// Pass a reference to the next iterator element to the closure `accept`;\n    /// if `accept` returns true, return it as the next element,\n    /// else None.\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool;\n}\n\nimpl<I> PeekingNext for Peekable<I>\n    where I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool\n    {\n        if let Some(r) = self.peek() {\n            if !accept(r) {\n                return None;\n            }\n        }\n        self.next()\n    }\n}\n\nimpl<I> PeekingNext for PutBack<I>\n    where I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool\n    {\n        if let Some(r) = self.next() {\n            if !accept(&r) {\n                self.put_back(r);\n                return None;\n            }\n            Some(r)\n        } else {\n            None\n        }\n    }\n}\n\n#[cfg(feature = \"use_std\")]\nimpl<I> PeekingNext for PutBackN<I>\n    where I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool\n    {\n        if let Some(r) = self.next() {\n            if !accept(&r) {\n                self.put_back(r);\n                return None;\n            }\n            Some(r)\n        } else {\n            None\n        }\n    }\n}\n\n/// An iterator adaptor that takes items while a closure returns `true`.\n///\n/// See [`.peeking_take_while()`](../trait.Itertools.html#method.peeking_take_while)\n/// for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct PeekingTakeWhile<'a, I: 'a, F>\n    where I: Iterator,\n{\n    iter: &'a mut I,\n    f: F,\n}\n\n/// Create a PeekingTakeWhile\npub fn peeking_take_while<I, F>(iter: &mut I, f: F) -> PeekingTakeWhile<I, F>\n    where I: Iterator,\n{\n    PeekingTakeWhile {\n        iter,\n        f,\n    }\n}\n\nimpl<'a, I, F> Iterator for PeekingTakeWhile<'a, I, F>\n    where I: PeekingNext,\n          F: FnMut(&I::Item) -> bool,\n\n{\n    type Item = I::Item;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.peeking_next(&mut self.f)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, hi) = self.iter.size_hint();\n        (0, hi)\n    }\n}\n\n// Some iterators are so lightweight we can simply clone them to save their\n// state and use that for peeking.\nmacro_rules! peeking_next_by_clone {\n    ([$($typarm:tt)*] $type_:ty) => {\n        impl<$($typarm)*> PeekingNext for $type_ {\n            fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n                where F: FnOnce(&Self::Item) -> bool\n            {\n                let saved_state = self.clone();\n                if let Some(r) = self.next() {\n                    if !accept(&r) {\n                        *self = saved_state;\n                    } else {\n                        return Some(r)\n                    }\n                }\n                None\n            }\n        }\n    }\n}\n\npeeking_next_by_clone! { ['a, T] ::std::slice::Iter<'a, T> }\npeeking_next_by_clone! { ['a] ::std::str::Chars<'a> }\npeeking_next_by_clone! { ['a] ::std::str::CharIndices<'a> }\npeeking_next_by_clone! { ['a] ::std::str::Bytes<'a> }\npeeking_next_by_clone! { ['a, T] ::std::option::Iter<'a, T> }\npeeking_next_by_clone! { ['a, T] ::std::result::Iter<'a, T> }\npeeking_next_by_clone! { [T] ::std::iter::Empty<T> }\n#[cfg(feature = \"use_std\")]\npeeking_next_by_clone! { ['a, T] ::std::collections::linked_list::Iter<'a, T> }\n#[cfg(feature = \"use_std\")]\npeeking_next_by_clone! { ['a, T] ::std::collections::vec_deque::Iter<'a, T> }\n\n// cloning a Rev has no extra overhead; peekable and put backs are never DEI.\npeeking_next_by_clone! { [I: Clone + PeekingNext + DoubleEndedIterator]\n                         ::std::iter::Rev<I> }\n","traces":[{"line":25,"address":[4241545,4241504],"length":1,"stats":{"Line":1},"fn_name":"peeking_next<core::ops::range::Range<i32>,&mut closure-0>"},{"line":28,"address":[4241518,4241648,4241566],"length":1,"stats":{"Line":3},"fn_name":null},{"line":29,"address":[4241602],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[4241650],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[4241671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[4209104,4208742,4208688,4209158],"length":1,"stats":{"Line":2},"fn_name":"peeking_next<core::ops::range::Range<i32>,&mut closure-0>"},{"line":43,"address":[4208758,4208702,4209174,4209211,4208795,4209118],"length":1,"stats":{"Line":5},"fn_name":null},{"line":44,"address":[4208818,4209234],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[4239206,4239622,4239568,4239152],"length":1,"stats":{"Line":2},"fn_name":"peeking_next<core::ops::range::Range<i32>,&mut closure-0>"},{"line":62,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[4238560,4238656,4238592,4238624,4238688,4238720,4238816,4238752,4238784],"length":1,"stats":{"Line":9},"fn_name":"peeking_take_while<itertools::put_back_n_impl::PutBackN<core::ops::range::Range<i32>>,closure-1>"},{"line":102,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[4230398,4230656,4230352,4230702],"length":1,"stats":{"Line":4},"fn_name":"peeking_next<i32,&mut closure-1>"},{"line":120,"address":[4230366,4230415,4230719,4230670],"length":1,"stats":{"Line":8},"fn_name":null},{"line":121,"address":[4230876,4230572,4230734,4230430],"length":1,"stats":{"Line":6},"fn_name":null},{"line":122,"address":[4230796,4230492],"length":1,"stats":{"Line":4},"fn_name":null},{"line":123,"address":[4230854,4230550],"length":1,"stats":{"Line":3},"fn_name":null},{"line":125,"address":[4230842,4230538],"length":1,"stats":{"Line":4},"fn_name":null},{"line":128,"address":[4230888,4230584],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":29,"coverable":32},{"path":["/","home","kms","itertools","src","permutations.rs"],"content":"use std::fmt;\nuse std::iter::once;\n\nuse super::lazy_buffer::LazyBuffer;\n\n/// An iterator adaptor that iterates through all the `k`-permutations of the\n/// elements from an iterator.\n///\n/// See [`.permutations()`](../trait.Itertools.html#method.permutations) for\n/// more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Permutations<I: Iterator> {\n    vals: LazyBuffer<I>,\n    state: PermutationState,\n}\n\nimpl<I> Clone for Permutations<I>\n    where I: Clone + Iterator,\n          I::Item: Clone,\n{\n    clone_fields!(vals, state);\n}\n\n#[derive(Clone, Debug)]\nenum PermutationState {\n    StartUnknownLen {\n        k: usize,\n    },\n    OngoingUnknownLen {\n        k: usize,\n        min_n: usize,\n    },\n    Complete(CompleteState),\n    Empty,\n}\n\n#[derive(Clone, Debug)]\nenum CompleteState {\n    Start {\n        n: usize,\n        k: usize,\n    },\n    Ongoing {\n        indices: Vec<usize>,\n        cycles: Vec<usize>,\n    }\n}\n\nenum CompleteStateRemaining {\n    Known(usize),\n    Overflow,\n}\n\nimpl<I> fmt::Debug for Permutations<I>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(Permutations, vals, state);\n}\n\npub fn permutations<I: Iterator>(iter: I, k: usize) -> Permutations<I> {\n    let mut vals = LazyBuffer::new(iter);\n\n    if k == 0 {\n        // Special case, yields single empty vec; `n` is irrelevant\n        let state = PermutationState::Complete(CompleteState::Start { n: 0, k: 0 });\n\n        return Permutations {\n            vals,\n            state\n        };\n    }\n\n    let mut enough_vals = true;\n\n    while vals.len() < k {\n        if !vals.get_next() {\n            enough_vals = false;\n            break;\n        }\n    }\n\n    let state = if enough_vals {\n        PermutationState::StartUnknownLen { k }\n    } else {\n        PermutationState::Empty\n    };\n\n    Permutations {\n        vals,\n        state\n    }\n}\n\nimpl<I> Iterator for Permutations<I>\nwhere\n    I: Iterator,\n    I::Item: Clone\n{\n    type Item = Vec<I::Item>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.advance();\n\n        let &mut Permutations { ref vals, ref state } = self;\n\n        match state {\n            &PermutationState::StartUnknownLen { .. } => panic!(\"unexpected iterator state\"),\n            &PermutationState::OngoingUnknownLen { k, min_n } => {\n                let latest_idx = min_n - 1;\n                let indices = (0..(k - 1)).chain(once(latest_idx));\n\n                Some(indices.map(|i| vals[i].clone()).collect())\n            }\n            &PermutationState::Complete(CompleteState::Start { .. }) => None,\n            &PermutationState::Complete(CompleteState::Ongoing { ref indices, ref cycles }) => {\n                let k = cycles.len();\n\n                Some(indices[0..k].iter().map(|&i| vals[i].clone()).collect())\n            },\n            &PermutationState::Empty => None\n        }\n    }\n\n    fn count(self) -> usize {\n        let Permutations { vals, state } = self;\n\n        fn from_complete(complete_state: CompleteState) -> usize {\n            match complete_state.remaining() {\n                CompleteStateRemaining::Known(count) => count,\n                CompleteStateRemaining::Overflow => {\n                    panic!(\"Iterator count greater than usize::MAX\");\n                }\n            }\n        }\n\n        match state {\n            PermutationState::StartUnknownLen { k } => {\n                let n = vals.len() + vals.it.count();\n                let complete_state = CompleteState::Start { n, k };\n\n                from_complete(complete_state)\n            }\n            PermutationState::OngoingUnknownLen { k, min_n } => {\n                let prev_iteration_count = min_n - k + 1;\n                let n = vals.len() + vals.it.count();\n                let complete_state = CompleteState::Start { n, k };\n\n                from_complete(complete_state) - prev_iteration_count\n            },\n            PermutationState::Complete(state) => from_complete(state),\n            PermutationState::Empty => 0\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        match self.state {\n            PermutationState::StartUnknownLen { .. } |\n            PermutationState::OngoingUnknownLen { .. } => (0, None), // TODO can we improve this lower bound?\n            PermutationState::Complete(ref state) => match state.remaining() {\n                CompleteStateRemaining::Known(count) => (count, Some(count)),\n                CompleteStateRemaining::Overflow => (::std::usize::MAX, None)\n            }\n            PermutationState::Empty => (0, Some(0))\n        }\n    }\n}\n\nimpl<I> Permutations<I>\nwhere\n    I: Iterator,\n    I::Item: Clone\n{\n    fn advance(&mut self) {\n        let &mut Permutations { ref mut vals, ref mut state } = self;\n\n        *state = match state {\n            &mut PermutationState::StartUnknownLen { k } => {\n                PermutationState::OngoingUnknownLen { k, min_n: k }\n            }\n            &mut PermutationState::OngoingUnknownLen { k, min_n } => {\n                if vals.get_next() {\n                    PermutationState::OngoingUnknownLen { k, min_n: min_n + 1 }\n                } else {\n                    let n = min_n;\n                    let prev_iteration_count = n - k + 1;\n                    let mut complete_state = CompleteState::Start { n, k };\n\n                    // Advance the complete-state iterator to the correct point\n                    for _ in 0..(prev_iteration_count + 1) {\n                        complete_state.advance();\n                    }\n\n                    PermutationState::Complete(complete_state)\n                }\n            }\n            &mut PermutationState::Complete(ref mut state) => {\n                state.advance();\n\n                return;\n            }\n            &mut PermutationState::Empty => { return; }\n        };\n    }\n}\n\nimpl CompleteState {\n    fn advance(&mut self) {\n        *self = match self {\n            &mut CompleteState::Start { n, k } => {\n                let indices = (0..n).collect();\n                let cycles = ((n - k)..n).rev().collect();\n\n                CompleteState::Ongoing {\n                    cycles,\n                    indices\n                }\n            },\n            &mut CompleteState::Ongoing { ref mut indices, ref mut cycles } => {\n                let n = indices.len();\n                let k = cycles.len();\n\n                for i in (0..k).rev() {\n                    if cycles[i] == 0 {\n                        cycles[i] = n - i - 1;\n\n                        let to_push = indices.remove(i);\n                        indices.push(to_push);\n                    } else {\n                        let swap_index = n - cycles[i];\n                        indices.swap(i, swap_index);\n\n                        cycles[i] -= 1;\n                        return;\n                    }\n                }\n\n                CompleteState::Start { n, k }\n            }\n        }\n    }\n\n    fn remaining(&self) -> CompleteStateRemaining {\n        use self::CompleteStateRemaining::{Known, Overflow};\n\n        match self {\n            &CompleteState::Start { n, k } => {\n                if n < k {\n                    return Known(0);\n                }\n\n                let count: Option<usize> = (n - k + 1..n + 1).fold(Some(1), |acc, i| {\n                    acc.and_then(|acc| acc.checked_mul(i))\n                });\n\n                match count {\n                    Some(count) => Known(count),\n                    None => Overflow\n                }\n            }\n            &CompleteState::Ongoing { ref indices, ref cycles } => {\n                let mut count: usize = 0;\n\n                for (i, &c) in cycles.iter().enumerate() {\n                    let radix = indices.len() - i;\n                    let next_count = count.checked_mul(radix)\n                        .and_then(|count| count.checked_add(c));\n\n                    count = match next_count {\n                        Some(count) => count,\n                        None => { return Overflow; }\n                    };\n                }\n\n                Known(count)\n            }\n        }\n    }\n}\n","traces":[{"line":61,"address":[4773143,4774482,4773815,4773072,4774416,4773744],"length":1,"stats":{"Line":5},"fn_name":"permutations<core::iter::adapters::Take<quick::Iter<i32, quick::Inexact>>>"},{"line":62,"address":[4774444,4773087,4773759],"length":1,"stats":{"Line":5},"fn_name":null},{"line":64,"address":[4774497,4773830,4773158],"length":1,"stats":{"Line":5},"fn_name":null},{"line":66,"address":[4773179,4773851,4774521],"length":1,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[4774046,4773374,4774719],"length":1,"stats":{"Line":4},"fn_name":null},{"line":69,"address":[4773274,4774616,4773946],"length":1,"stats":{"Line":4},"fn_name":null},{"line":70,"address":[4773319,4774664,4773991],"length":1,"stats":{"Line":4},"fn_name":null},{"line":74,"address":[4773838,4773166,4774508],"length":1,"stats":{"Line":4},"fn_name":null},{"line":76,"address":[4774864,4773846,4773507,4774516,4774129,4774179,4773174,4773457,4774808],"length":1,"stats":{"Line":12},"fn_name":null},{"line":77,"address":[4774158,4773486,4774843],"length":1,"stats":{"Line":4},"fn_name":null},{"line":78,"address":[4773509,4774181,4774866],"length":1,"stats":{"Line":3},"fn_name":null},{"line":83,"address":[4774874,4774896,4774189,4774211,4773539,4773517],"length":1,"stats":{"Line":7},"fn_name":null},{"line":86,"address":[4774199,4773527,4774884],"length":1,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[4542398,4542368],"length":1,"stats":{"Line":1},"fn_name":"from_complete"},{"line":129,"address":[4542415,4542487,4542372],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[4542430,4542489],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[4542457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[4772092,4772428],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[4542544,4542582],"length":1,"stats":{"Line":2},"fn_name":"advance"},{"line":209,"address":[4543832,4543060,4543359,4542597],"length":1,"stats":{"Line":6},"fn_name":null},{"line":210,"address":[4542599,4542559],"length":1,"stats":{"Line":4},"fn_name":null},{"line":211,"address":[4542639],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[4542824,4544042,4542697],"length":1,"stats":{"Line":4},"fn_name":null},{"line":214,"address":[4542952],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[4542856],"length":1,"stats":{"Line":2},"fn_name":null},{"line":216,"address":[4542904],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[4543065],"length":1,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[4543109],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[4543131],"length":1,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[4543364,4543153,4543650],"length":1,"stats":{"Line":3},"fn_name":null},{"line":224,"address":[4543414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[4543497,4543922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[4543598],"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[4543628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[4543982,4543452,4543665],"length":1,"stats":{"Line":2},"fn_name":null},{"line":231,"address":[4543698],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[4543754,4544012],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[4543315],"length":1,"stats":{"Line":2},"fn_name":null},{"line":243,"address":[4544128],"length":1,"stats":{"Line":1},"fn_name":"remaining"},{"line":246,"address":[4544508,4544160],"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[4544162,4544140],"length":1,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[4544193],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[4544240],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[4542048],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":253,"address":[4541984,4542072,4541998],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":256,"address":[4544466],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[4544440,4544470],"length":1,"stats":{"Line":2},"fn_name":null},{"line":258,"address":[4544457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[4544513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[4544551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[4544792,4544563,4545110],"length":1,"stats":{"Line":2},"fn_name":null},{"line":265,"address":[4544893,4545115],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[4544955,4545002],"length":1,"stats":{"Line":2},"fn_name":null},{"line":267,"address":[4542142,4542128],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":269,"address":[4545102,4545076],"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[4545078,4545045],"length":1,"stats":{"Line":2},"fn_name":null},{"line":271,"address":[4545062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[4544765],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":104,"coverable":113},{"path":["/","home","kms","itertools","src","process_results_impl.rs"],"content":"\n/// An iterator that produces only the `T` values as long as the\n/// inner iterator produces `Ok(T)`.\n///\n/// Used by [`process_results`](../fn.process_results.html), see its docs\n/// for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Debug)]\npub struct ProcessResults<'a, I, E: 'a> {\n    error: &'a mut Result<(), E>,\n    iter: I,\n}\n\nimpl<'a, I, T, E> Iterator for ProcessResults<'a, I, E>\n    where I: Iterator<Item = Result<T, E>>\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.iter.next() {\n            Some(Ok(x)) => Some(x),\n            Some(Err(e)) => {\n                *self.error = Err(e);\n                None\n            }\n            None => None,\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, hi) = self.iter.size_hint();\n        (0, hi)\n    }\n}\n\n/// “Lift” a function of the values of an iterator so that it can process\n/// an iterator of `Result` values instead.\n///\n/// `iterable` is an iterator or iterable with `Result<T, E>` elements, where\n/// `T` is the value type and `E` the error type.\n///\n/// `processor` is a closure that receives an adapted version of the iterable\n/// as the only argument — the adapted iterator produces elements of type `T`,\n/// as long as the original iterator produces `Ok` values.\n///\n/// If the original iterable produces an error at any point, the adapted\n/// iterator ends and the `process_results` function will return the\n/// error iself.\n///\n/// Otherwise, the return value from the closure is returned wrapped\n/// inside `Ok`.\n///\n/// # Example\n///\n/// ```\n/// use itertools::process_results;\n///\n/// type R = Result<i32, &'static str>;\n///\n/// let first_values: Vec<R> = vec![Ok(1), Ok(0), Ok(3)];\n/// let second_values: Vec<R> = vec![Ok(2), Ok(1), Err(\"overflow\")];\n///\n/// // “Lift” the iterator .max() method to work on the values in Results using process_results\n///\n/// let first_max = process_results(first_values, |iter| iter.max().unwrap_or(0));\n/// let second_max = process_results(second_values, |iter| iter.max().unwrap_or(0));\n///\n/// assert_eq!(first_max, Ok(3));\n/// assert!(second_max.is_err());\n/// ```\npub fn process_results<I, F, T, E, R>(iterable: I, processor: F) -> Result<R, E>\n    where I: IntoIterator<Item = Result<T, E>>,\n          F: FnOnce(ProcessResults<I::IntoIter, E>) -> R\n{\n    let iter = iterable.into_iter();\n    let mut error = Ok(());\n\n    let result = processor(ProcessResults { error: &mut error, iter });\n\n    error.map(|_| result)\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","home","kms","itertools","src","put_back_n_impl.rs"],"content":"use crate::size_hint;\n\n/// An iterator adaptor that allows putting multiple\n/// items in front of the iterator.\n///\n/// Iterator element type is `I::Item`.\n#[derive(Debug, Clone)]\npub struct PutBackN<I: Iterator> {\n    top: Vec<I::Item>,\n    iter: I,\n}\n\n/// Create an iterator where you can put back multiple values to the front\n/// of the iteration.\n///\n/// Iterator element type is `I::Item`.\npub fn put_back_n<I>(iterable: I) -> PutBackN<I::IntoIter>\n    where I: IntoIterator\n{\n    PutBackN {\n        top: Vec::new(),\n        iter: iterable.into_iter(),\n    }\n}\n\nimpl<I: Iterator> PutBackN<I> {\n    /// Puts x in front of the iterator.\n    /// The values are yielded in order of the most recently put back\n    /// values first.\n    ///\n    /// ```rust\n    /// use itertools::put_back_n;\n    ///\n    /// let mut it = put_back_n(1..5);\n    /// it.next();\n    /// it.put_back(1);\n    /// it.put_back(0);\n    ///\n    /// assert!(itertools::equal(it, 0..5));\n    /// ```\n    #[inline]\n    pub fn put_back(&mut self, x: I::Item) {\n        self.top.push(x);\n    }\n}\n\nimpl<I: Iterator> Iterator for PutBackN<I> {\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.top.pop().or_else(|| self.iter.next())\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add_scalar(self.iter.size_hint(), self.top.len())\n    }\n}\n\n","traces":[{"line":17,"address":[4240034,4239984],"length":1,"stats":{"Line":3},"fn_name":"put_back_n<core::ops::range::Range<i32>>"},{"line":21,"address":[5814250],"length":1,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[5814305],"length":1,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[4240192],"length":1,"stats":{"Line":3},"fn_name":"put_back<core::ops::range::Range<i32>>"},{"line":43,"address":[4240205],"length":1,"stats":{"Line":3},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","kms","itertools","src","rciter_impl.rs"],"content":"\nuse std::iter::IntoIterator;\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n/// A wrapper for `Rc<RefCell<I>>`, that implements the `Iterator` trait.\n#[derive(Debug)]\npub struct RcIter<I> {\n    /// The boxed iterator.\n    pub rciter: Rc<RefCell<I>>,\n}\n\n/// Return an iterator inside a `Rc<RefCell<_>>` wrapper.\n///\n/// The returned `RcIter` can be cloned, and each clone will refer back to the\n/// same original iterator.\n///\n/// `RcIter` allows doing interesting things like using `.zip()` on an iterator with\n/// itself, at the cost of runtime borrow checking which may have a performance\n/// penalty.\n///\n/// Iterator element type is `Self::Item`.\n///\n/// ```\n/// use itertools::rciter;\n/// use itertools::zip;\n///\n/// // In this example a range iterator is created and we iterate it using\n/// // three separate handles (two of them given to zip).\n/// // We also use the IntoIterator implementation for `&RcIter`.\n///\n/// let mut iter = rciter(0..9);\n/// let mut z = zip(&iter, &iter);\n///\n/// assert_eq!(z.next(), Some((0, 1)));\n/// assert_eq!(z.next(), Some((2, 3)));\n/// assert_eq!(z.next(), Some((4, 5)));\n/// assert_eq!(iter.next(), Some(6));\n/// assert_eq!(z.next(), Some((7, 8)));\n/// assert_eq!(z.next(), None);\n/// ```\n///\n/// **Panics** in iterator methods if a borrow error is encountered in the\n/// iterator methods. It can only happen if the `RcIter` is reentered in\n/// `.next()`, i.e. if it somehow participates in an “iterator knot”\n/// where it is an adaptor of itself.\npub fn rciter<I>(iterable: I) -> RcIter<I::IntoIter>\n    where I: IntoIterator\n{\n    RcIter { rciter: Rc::new(RefCell::new(iterable.into_iter())) }\n}\n\nimpl<I> Clone for RcIter<I> {\n    #[inline]\n    clone_fields!(rciter);\n}\n\nimpl<A, I> Iterator for RcIter<I>\n    where I: Iterator<Item = A>\n{\n    type Item = A;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.rciter.borrow_mut().next()\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // To work sanely with other API that assume they own an iterator,\n        // so it can't change in other places, we can't guarantee as much\n        // in our size_hint. Other clones may drain values under our feet.\n        let (_, hi) = self.rciter.borrow().size_hint();\n        (0, hi)\n    }\n}\n\nimpl<I> DoubleEndedIterator for RcIter<I>\n    where I: DoubleEndedIterator\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.rciter.borrow_mut().next_back()\n    }\n}\n\n/// Return an iterator from `&RcIter<I>` (by simply cloning it).\nimpl<'a, I> IntoIterator for &'a RcIter<I>\n    where I: Iterator\n{\n    type Item = I::Item;\n    type IntoIter = RcIter<I>;\n\n    fn into_iter(self) -> RcIter<I> {\n        self.clone()\n    }\n}\n","traces":[{"line":47,"address":[4700016,4699920],"length":1,"stats":{"Line":3},"fn_name":"rciter<core::ops::range::Range<i32>>"},{"line":50,"address":[5548548],"length":1,"stats":{"Line":3},"fn_name":null},{"line":63,"address":[4699620,4699744,4699568,4699796],"length":1,"stats":{"Line":3},"fn_name":"next<i32,core::iter::adapters::Cloned<core::slice::Iter<i32>>>"},{"line":64,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":68,"address":[5548381,5548304],"length":1,"stats":{"Line":1},"fn_name":"size_hint<i16,quick::Iter<i16, quick::Inexact>>"},{"line":72,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":9,"coverable":11},{"path":["/","home","kms","itertools","src","repeatn.rs"],"content":"\n/// An iterator that produces *n* repetitions of an element.\n///\n/// See [`repeat_n()`](../fn.repeat_n.html) for more information.\n#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n#[derive(Clone, Debug)]\npub struct RepeatN<A> {\n    elt: Option<A>,\n    n: usize,\n}\n\n/// Create an iterator that produces `n` repetitions of `element`.\npub fn repeat_n<A>(element: A, n: usize) -> RepeatN<A>\n    where A: Clone,\n{\n    if n == 0 {\n        RepeatN { elt: None, n, }\n    } else {\n        RepeatN { elt: Some(element), n, }\n    }\n}\n\nimpl<A> Iterator for RepeatN<A>\n    where A: Clone\n{\n    type Item = A;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.n > 1 {\n            self.n -= 1;\n            self.elt.as_ref().cloned()\n        } else {\n            self.n = 0;\n            self.elt.take()\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (self.n, Some(self.n))\n    }\n}\n\nimpl<A> DoubleEndedIterator for RepeatN<A>\n    where A: Clone\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.next()\n    }\n}\n\nimpl<A> ExactSizeIterator for RepeatN<A>\n    where A: Clone\n{}\n","traces":[{"line":13,"address":[4958464],"length":1,"stats":{"Line":3},"fn_name":"repeat_n<i32>"},{"line":16,"address":[4316291,4316390,4316473,4316209],"length":1,"stats":{"Line":6},"fn_name":null},{"line":19,"address":[4958507],"length":1,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[4315920,4315728],"length":1,"stats":{"Line":3},"fn_name":"next<&str>"},{"line":29,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":30,"address":[4958350,4958380,4958251],"length":1,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":11,"coverable":13},{"path":["/","home","kms","itertools","src","size_hint.rs"],"content":"//! Arithmetic on **Iterator** *.size_hint()* values.\n//!\n\nuse std::usize;\nuse std::cmp;\n\n/// **SizeHint** is the return type of **Iterator::size_hint()**.\npub type SizeHint = (usize, Option<usize>);\n\n/// Add **SizeHint** correctly.\n#[inline]\npub fn add(a: SizeHint, b: SizeHint) -> SizeHint {\n    let min = a.0.checked_add(b.0).unwrap_or(usize::MAX);\n    let max = match (a.1, b.1) {\n        (Some(x), Some(y)) => x.checked_add(y),\n        _ => None,\n    };\n\n    (min, max)\n}\n\n/// Add **x** correctly to a **SizeHint**.\n#[inline]\npub fn add_scalar(sh: SizeHint, x: usize) -> SizeHint {\n    let (mut low, mut hi) = sh;\n    low = low.saturating_add(x);\n    hi = hi.and_then(|elt| elt.checked_add(x));\n    (low, hi)\n}\n\n/// Sbb **x** correctly to a **SizeHint**.\n#[inline]\n#[allow(dead_code)]\npub fn sub_scalar(sh: SizeHint, x: usize) -> SizeHint {\n    let (mut low, mut hi) = sh;\n    low = low.saturating_sub(x);\n    hi = hi.map(|elt| elt.saturating_sub(x));\n    (low, hi)\n}\n\n\n/// Multiply **SizeHint** correctly\n///\n/// ```ignore\n/// use std::usize;\n/// use itertools::size_hint;\n///\n/// assert_eq!(size_hint::mul((3, Some(4)), (3, Some(4))),\n///            (9, Some(16)));\n///\n/// assert_eq!(size_hint::mul((3, Some(4)), (usize::MAX, None)),\n///            (usize::MAX, None));\n///\n/// assert_eq!(size_hint::mul((3, None), (0, Some(0))),\n///            (0, Some(0)));\n/// ```\n#[inline]\npub fn mul(a: SizeHint, b: SizeHint) -> SizeHint {\n    let low = a.0.checked_mul(b.0).unwrap_or(usize::MAX);\n    let hi = match (a.1, b.1) {\n        (Some(x), Some(y)) => x.checked_mul(y),\n        (Some(0), None) | (None, Some(0)) => Some(0),\n        _ => None,\n    };\n    (low, hi)\n}\n\n/// Multiply **x** correctly with a **SizeHint**.\n#[inline]\npub fn mul_scalar(sh: SizeHint, x: usize) -> SizeHint {\n    let (mut low, mut hi) = sh;\n    low = low.saturating_mul(x);\n    hi = hi.and_then(|elt| elt.checked_mul(x));\n    (low, hi)\n}\n\n/// Return the maximum\n#[inline]\npub fn max(a: SizeHint, b: SizeHint) -> SizeHint {\n    let (a_lower, a_upper) = a;\n    let (b_lower, b_upper) = b;\n\n    let lower = cmp::max(a_lower, b_lower);\n\n    let upper = match (a_upper, b_upper) {\n        (Some(x), Some(y)) => Some(cmp::max(x, y)),\n        _ => None,\n    };\n\n    (lower, upper)\n}\n\n/// Return the minimum\n#[inline]\npub fn min(a: SizeHint, b: SizeHint) -> SizeHint {\n    let (a_lower, a_upper) = a;\n    let (b_lower, b_upper) = b;\n    let lower = cmp::min(a_lower, b_lower);\n    let upper = match (a_upper, b_upper) {\n        (Some(u1), Some(u2)) => Some(cmp::min(u1, u2)),\n        _ => a_upper.or(b_upper),\n    };\n    (lower, upper)\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":27,"address":[4541470,4541456],"length":1,"stats":{"Line":17},"fn_name":"{{closure}}"},{"line":28,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[4541520,4541534],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[4541568,4541582],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":38,"coverable":43},{"path":["/","home","kms","itertools","src","sources.rs"],"content":"//! Iterators that are sources (produce elements from parameters,\n//! not from another iterator).\n#![allow(deprecated)]\n\nuse std::fmt;\nuse std::mem;\n\n/// See [`repeat_call`](../fn.repeat_call.html) for more information.\n#[derive(Clone)]\n#[deprecated(note=\"Use std repeat_with() instead\", since=\"0.8\")]\npub struct RepeatCall<F> {\n    f: F,\n}\n\nimpl<F> fmt::Debug for RepeatCall<F>\n{\n    debug_fmt_fields!(RepeatCall, );\n}\n\n/// An iterator source that produces elements indefinitely by calling\n/// a given closure.\n///\n/// Iterator element type is the return type of the closure.\n///\n/// ```\n/// use itertools::repeat_call;\n/// use itertools::Itertools;\n/// use std::collections::BinaryHeap;\n///\n/// let mut heap = BinaryHeap::from(vec![2, 5, 3, 7, 8]);\n///\n/// // extract each element in sorted order\n/// for element in repeat_call(|| heap.pop()).while_some() {\n///     print!(\"{}\", element);\n/// }\n///\n/// itertools::assert_equal(\n///     repeat_call(|| 1).take(5),\n///     vec![1, 1, 1, 1, 1]\n/// );\n/// ```\n#[deprecated(note=\"Use std repeat_with() instead\", since=\"0.8\")]\npub fn repeat_call<F, A>(function: F) -> RepeatCall<F>\n    where F: FnMut() -> A\n{\n    RepeatCall { f: function }\n}\n\nimpl<A, F> Iterator for RepeatCall<F>\n    where F: FnMut() -> A\n{\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        Some((self.f)())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (usize::max_value(), None)\n    }\n}\n\n/// Creates a new unfold source with the specified closure as the \"iterator\n/// function\" and an initial state to eventually pass to the closure\n///\n/// `unfold` is a general iterator builder: it has a mutable state value,\n/// and a closure with access to the state that produces the next value.\n///\n/// This more or less equivalent to a regular struct with an `Iterator`\n/// implementation, and is useful for one-off iterators.\n///\n/// ```\n/// // an iterator that yields sequential Fibonacci numbers,\n/// // and stops at the maximum representable value.\n///\n/// use itertools::unfold;\n///\n/// let (mut x1, mut x2) = (1u32, 1u32);\n/// let mut fibonacci = unfold((), move |_| {\n///     // Attempt to get the next Fibonacci number\n///     let next = x1.saturating_add(x2);\n///\n///     // Shift left: ret <- x1 <- x2 <- next\n///     let ret = x1;\n///     x1 = x2;\n///     x2 = next;\n///\n///     // If addition has saturated at the maximum, we are finished\n///     if ret == x1 && ret > 1 {\n///         return None;\n///     }\n///\n///     Some(ret)\n/// });\n///\n/// itertools::assert_equal(fibonacci.by_ref().take(8),\n///                         vec![1, 1, 2, 3, 5, 8, 13, 21]);\n/// assert_eq!(fibonacci.last(), Some(2_971_215_073))\n/// ```\npub fn unfold<A, St, F>(initial_state: St, f: F) -> Unfold<St, F>\n    where F: FnMut(&mut St) -> Option<A>\n{\n    Unfold {\n        f,\n        state: initial_state,\n    }\n}\n\nimpl<St, F> fmt::Debug for Unfold<St, F>\n    where St: fmt::Debug,\n{\n    debug_fmt_fields!(Unfold, state);\n}\n\n/// See [`unfold`](../fn.unfold.html) for more information.\n#[derive(Clone)]\n#[must_use = \"iterators are lazy and do nothing unless consumed\"]\npub struct Unfold<St, F> {\n    f: F,\n    /// Internal state that will be passed to the closure on the next iteration\n    pub state: St,\n}\n\nimpl<A, St, F> Iterator for Unfold<St, F>\n    where F: FnMut(&mut St) -> Option<A>\n{\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        (self.f)(&mut self.state)\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // no possible known bounds at this point\n        (0, None)\n    }\n}\n\n/// An iterator that infinitely applies function to value and yields results.\n///\n/// This `struct` is created by the [`iterate()`] function. See its documentation for more.\n///\n/// [`iterate()`]: ../fn.iterate.html\n#[derive(Clone)]\n#[must_use = \"iterators are lazy and do nothing unless consumed\"]\npub struct Iterate<St, F> {\n    state: St,\n    f: F,\n}\n\nimpl<St, F> fmt::Debug for Iterate<St, F>\n    where St: fmt::Debug,\n{\n    debug_fmt_fields!(Iterate, state);\n}\n\nimpl<St, F> Iterator for Iterate<St, F>\n    where F: FnMut(&St) -> St\n{\n    type Item = St;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let next_state = (self.f)(&self.state);\n        Some(mem::replace(&mut self.state, next_state))\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (usize::max_value(), None)\n    }\n}\n\n/// Creates a new iterator that infinitely applies function to value and yields results.\n///\n/// ```\n/// use itertools::iterate;\n///\n/// itertools::assert_equal(iterate(1, |&i| i * 3).take(5), vec![1, 3, 9, 27, 81]);\n/// ```\npub fn iterate<St, F>(initial_value: St, f: F) -> Iterate<St, F>\n    where F: FnMut(&St) -> St\n{\n    Iterate {\n        state: initial_value,\n        f,\n    }\n}\n","traces":[{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":13},{"path":["/","home","kms","itertools","src","tee.rs"],"content":"use super::size_hint;\n\nuse std::cell::RefCell;\nuse std::collections::VecDeque;\nuse std::rc::Rc;\n\n/// Common buffer object for the two tee halves\n#[derive(Debug)]\nstruct TeeBuffer<A, I> {\n    backlog: VecDeque<A>,\n    iter: I,\n    /// The owner field indicates which id should read from the backlog\n    owner: bool,\n}\n\n/// One half of an iterator pair where both return the same elements.\n///\n/// See [`.tee()`](../trait.Itertools.html#method.tee) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Debug)]\npub struct Tee<I>\n    where I: Iterator\n{\n    rcbuffer: Rc<RefCell<TeeBuffer<I::Item, I>>>,\n    id: bool,\n}\n\npub fn new<I>(iter: I) -> (Tee<I>, Tee<I>)\n    where I: Iterator\n{\n    let buffer = TeeBuffer{backlog: VecDeque::new(), iter, owner: false};\n    let t1 = Tee{rcbuffer: Rc::new(RefCell::new(buffer)), id: true};\n    let t2 = Tee{rcbuffer: t1.rcbuffer.clone(), id: false};\n    (t1, t2)\n}\n\nimpl<I> Iterator for Tee<I>\n    where I: Iterator,\n          I::Item: Clone\n{\n    type Item = I::Item;\n    fn next(&mut self) -> Option<Self::Item> {\n        // .borrow_mut may fail here -- but only if the user has tied some kind of weird\n        // knot where the iterator refers back to itself.\n        let mut buffer = self.rcbuffer.borrow_mut();\n        if buffer.owner == self.id {\n            match buffer.backlog.pop_front() {\n                None => {}\n                some_elt => return some_elt,\n            }\n        }\n        match buffer.iter.next() {\n            None => None,\n            Some(elt) => {\n                buffer.backlog.push_back(elt.clone());\n                buffer.owner = !self.id;\n                Some(elt)\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let buffer = self.rcbuffer.borrow();\n        let sh = buffer.iter.size_hint();\n\n        if buffer.owner == self.id {\n            let log_len = buffer.backlog.len();\n            size_hint::add_scalar(sh, log_len)\n        } else {\n            sh\n        }\n    }\n}\n\nimpl<I> ExactSizeIterator for Tee<I>\n    where I: ExactSizeIterator,\n          I::Item: Clone\n{}\n","traces":[{"line":28,"address":[4957264,4957768,4957712,4957325],"length":1,"stats":{"Line":3},"fn_name":"new<core::slice::Iter<u8>>"},{"line":31,"address":[4957722,4957284,4957783,4957340],"length":1,"stats":{"Line":6},"fn_name":null},{"line":32,"address":[4957396,4957873],"length":1,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[4957997,4957520],"length":1,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[4958030,4957551],"length":1,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[4954928,4955712,4955787,4955003],"length":1,"stats":{"Line":3},"fn_name":"next<itertools::adaptors::DedupBy<core::slice::Iter<u8>, itertools::adaptors::DedupEq>>"},{"line":45,"address":[4955724,4955785,4955807,4955023,4954940,4955001],"length":1,"stats":{"Line":9},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":47,"address":[4955099,4955883],"length":1,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[4955145,4955929],"length":1,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":53,"address":[4956079,4955291,4956106,4955318],"length":1,"stats":{"Line":6},"fn_name":null},{"line":54,"address":[4956120,4955332],"length":1,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":57,"address":[4955516,4956304],"length":1,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":24,"coverable":24},{"path":["/","home","kms","itertools","src","tuple_impl.rs"],"content":"//! Some iterator that produces tuples\n\nuse std::iter::Fuse;\nuse std::iter::Take;\nuse std::iter::Cycle;\nuse std::marker::PhantomData;\n\n// `HomogeneousTuple` is a public facade for `TupleCollect`, allowing\n// tuple-related methods to be used by clients in generic contexts, while\n// hiding the implementation details of `TupleCollect`.\n// See https://github.com/rust-itertools/itertools/issues/387\n\n/// Implemented for homogeneous tuples of size up to 4.\npub trait HomogeneousTuple\n    : TupleCollect\n{}\n\nimpl<T: TupleCollect> HomogeneousTuple for T {}\n\n/// An iterator over a incomplete tuple.\n///\n/// See [`.tuples()`](../trait.Itertools.html#method.tuples) and\n/// [`Tuples::into_buffer()`](struct.Tuples.html#method.into_buffer).\n#[derive(Clone, Debug)]\npub struct TupleBuffer<T>\n    where T: HomogeneousTuple\n{\n    cur: usize,\n    buf: T::Buffer,\n}\n\nimpl<T> TupleBuffer<T>\n    where T: HomogeneousTuple\n{\n    fn new(buf: T::Buffer) -> Self {\n        TupleBuffer {\n            cur: 0,\n            buf,\n        }\n    }\n}\n\nimpl<T> Iterator for TupleBuffer<T>\n    where T: HomogeneousTuple\n{\n    type Item = T::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let s = self.buf.as_mut();\n        if let Some(ref mut item) = s.get_mut(self.cur) {\n            self.cur += 1;\n            item.take()\n        } else {\n            None\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let buffer = &self.buf.as_ref()[self.cur..];\n        let len = if buffer.len() == 0 {\n            0\n        } else {\n            buffer.iter()\n                  .position(|x| x.is_none())\n                  .unwrap_or(buffer.len())\n        };\n        (len, Some(len))\n    }\n}\n\nimpl<T> ExactSizeIterator for TupleBuffer<T>\n    where T: HomogeneousTuple\n{\n}\n\n/// An iterator that groups the items in tuples of a specific size.\n///\n/// See [`.tuples()`](../trait.Itertools.html#method.tuples) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Tuples<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    iter: Fuse<I>,\n    buf: T::Buffer,\n}\n\n/// Create a new tuples iterator.\npub fn tuples<I, T>(iter: I) -> Tuples<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    Tuples {\n        iter: iter.fuse(),\n        buf: Default::default(),\n    }\n}\n\nimpl<I, T> Iterator for Tuples<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        T::collect_from_iter(&mut self.iter, &mut self.buf)\n    }\n}\n\nimpl<I, T> Tuples<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    /// Return a buffer with the produced items that was not enough to be grouped in a tuple.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut iter = (0..5).tuples();\n    /// assert_eq!(Some((0, 1, 2)), iter.next());\n    /// assert_eq!(None, iter.next());\n    /// itertools::assert_equal(vec![3, 4], iter.into_buffer());\n    /// ```\n    pub fn into_buffer(self) -> TupleBuffer<T> {\n        TupleBuffer::new(self.buf)\n    }\n}\n\n\n/// An iterator over all contiguous windows that produces tuples of a specific size.\n///\n/// See [`.tuple_windows()`](../trait.Itertools.html#method.tuple_windows) for more\n/// information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Clone, Debug)]\npub struct TupleWindows<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    iter: I,\n    last: Option<T>,\n}\n\n/// Create a new tuple windows iterator.\npub fn tuple_windows<I, T>(mut iter: I) -> TupleWindows<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple,\n          T::Item: Clone\n{\n    use std::iter::once;\n\n    let mut last = None;\n    if T::num_items() != 1 {\n        // put in a duplicate item in front of the tuple; this simplifies\n        // .next() function.\n        if let Some(item) = iter.next() {\n            let iter = once(item.clone()).chain(once(item)).chain(&mut iter);\n            last = T::collect_from_iter_no_buf(iter);\n        }\n    }\n\n    TupleWindows {\n        last,\n        iter,\n    }\n}\n\nimpl<I, T> Iterator for TupleWindows<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple + Clone,\n          T::Item: Clone\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if T::num_items() == 1 {\n            return T::collect_from_iter_no_buf(&mut self.iter)\n        }\n        if let Some(ref mut last) = self.last {\n            if let Some(new) = self.iter.next() {\n                last.left_shift_push(new);\n                return Some(last.clone());\n            }\n        }\n        None\n    }\n}\n\n/// An iterator over all windows,wrapping back to the first elements when the\n/// window would otherwise exceed the length of the iterator, producing tuples\n/// of a specific size.\n///\n/// See [`.circular_tuple_windows()`](../trait.Itertools.html#method.circular_tuple_windows) for more\n/// information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Debug)]\npub struct CircularTupleWindows<I, T: Clone>\n    where I: Iterator<Item = T::Item> + Clone,\n          T: TupleCollect + Clone\n{\n    iter: Take<TupleWindows<Cycle<I>, T>>,\n    phantom_data: PhantomData<T>\n}\n\npub fn circular_tuple_windows<I, T>(iter: I) -> CircularTupleWindows<I, T>\n    where I: Iterator<Item = T::Item> + Clone + ExactSizeIterator,\n          T: TupleCollect + Clone,\n          T::Item: Clone\n{\n    let len = iter.len();\n    let iter = tuple_windows(iter.cycle()).take(len);\n\n    CircularTupleWindows {\n        iter: iter,\n        phantom_data: PhantomData{}\n    }\n}\n\nimpl<I, T> Iterator for CircularTupleWindows<I, T>\n    where I: Iterator<Item = T::Item> + Clone,\n          T: TupleCollect + Clone,\n          T::Item: Clone\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next()\n    }\n}\n\npub trait TupleCollect: Sized {\n    type Item;\n    type Buffer: Default + AsRef<[Option<Self::Item>]> + AsMut<[Option<Self::Item>]>;\n\n    fn collect_from_iter<I>(iter: I, buf: &mut Self::Buffer) -> Option<Self>\n        where I: IntoIterator<Item = Self::Item>;\n\n    fn collect_from_iter_no_buf<I>(iter: I) -> Option<Self>\n        where I: IntoIterator<Item = Self::Item>;\n\n    fn num_items() -> usize;\n\n    fn left_shift_push(&mut self, item: Self::Item);\n}\n\nmacro_rules! impl_tuple_collect {\n    ($N:expr; $A:ident ; $($X:ident),* ; $($Y:ident),* ; $($Y_rev:ident),*) => (\n        impl<$A> TupleCollect for ($($X),*,) {\n            type Item = $A;\n            type Buffer = [Option<$A>; $N - 1];\n\n            #[allow(unused_assignments, unused_mut)]\n            fn collect_from_iter<I>(iter: I, buf: &mut Self::Buffer) -> Option<Self>\n                where I: IntoIterator<Item = $A>\n            {\n                let mut iter = iter.into_iter();\n                $(\n                    let mut $Y = None;\n                )*\n\n                loop {\n                    $(\n                        $Y = iter.next();\n                        if $Y.is_none() {\n                            break\n                        }\n                    )*\n                    return Some(($($Y.unwrap()),*,))\n                }\n\n                let mut i = 0;\n                let mut s = buf.as_mut();\n                $(\n                    if i < s.len() {\n                        s[i] = $Y;\n                        i += 1;\n                    }\n                )*\n                return None;\n            }\n\n            #[allow(unused_assignments)]\n            fn collect_from_iter_no_buf<I>(iter: I) -> Option<Self>\n                where I: IntoIterator<Item = $A>\n            {\n                let mut iter = iter.into_iter();\n                loop {\n                    $(\n                        let $Y = if let Some($Y) = iter.next() {\n                            $Y\n                        } else {\n                            break;\n                        };\n                    )*\n                    return Some(($($Y),*,))\n                }\n\n                return None;\n            }\n\n            fn num_items() -> usize {\n                $N\n            }\n\n            fn left_shift_push(&mut self, item: $A) {\n                use std::mem::replace;\n\n                let &mut ($(ref mut $Y),*,) = self;\n                let tmp = item;\n                $(\n                    let tmp = replace($Y_rev, tmp);\n                )*\n                drop(tmp);\n            }\n        }\n    )\n}\n\nimpl_tuple_collect!(1; A; A; a; a);\nimpl_tuple_collect!(2; A; A, A; a, b; b, a);\nimpl_tuple_collect!(3; A; A, A, A; a, b, c; c, b, a);\nimpl_tuple_collect!(4; A; A, A, A, A; a, b, c, d; d, c, b, a);\n","traces":[{"line":35,"address":[4745408],"length":1,"stats":{"Line":5},"fn_name":"new<(&u8, &u8, &u8, &u8)>"},{"line":48,"address":[4725664],"length":1,"stats":{"Line":5},"fn_name":"next<(&u8, &u8, &u8, &u8)>"},{"line":49,"address":[4725673],"length":1,"stats":{"Line":5},"fn_name":null},{"line":50,"address":[4725700,4725762,4725830],"length":1,"stats":{"Line":13},"fn_name":null},{"line":51,"address":[4725774,4725842,4725872],"length":1,"stats":{"Line":5},"fn_name":"size_hint<(&u8, &u8, &u8, &u8)>"},{"line":52,"address":[4725812],"length":1,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[4725753],"length":1,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[4725872],"length":1,"stats":{"Line":0},"fn_name":"size_hint<(&u8, &u8, &u8, &u8)>"},{"line":59,"address":[4725887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[4726208,4726222],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}<(&u8, &u8, &u8, &u8)>"},{"line":65,"address":[4726082],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[4726128],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[4745828,4745488,4745776,4745936,4745648,4745540,4745699,4745987],"length":1,"stats":{"Line":8},"fn_name":"tuples<core::slice::Iter<u8>,(&u8, &u8)>"},{"line":95,"address":[4745953,4745665,4745793,4745505],"length":1,"stats":{"Line":8},"fn_name":null},{"line":96,"address":[4746004,4745552,4745711,4745571,4745845],"length":1,"stats":{"Line":10},"fn_name":null},{"line":106,"address":[4725424,4725472,4725536,4725600],"length":1,"stats":{"Line":8},"fn_name":"next<core::slice::Iter<u8>,(&u8)>"},{"line":107,"address":[4725545,4725612,4725484,4725433],"length":1,"stats":{"Line":8},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":146,"address":[4744640,4742379,4742304,4744715,4743856,4743099,4743931,4743024],"length":1,"stats":{"Line":8},"fn_name":"tuple_windows<core::slice::Iter<u8>,(&u8, &u8)>"},{"line":153,"address":[4742324,4744660,4743044,4743876],"length":1,"stats":{"Line":8},"fn_name":null},{"line":154,"address":[4742367,4742399,4744735,4743119,4745205,4743734,4744703,4743087,4743951,4744522,4743919,4742899],"length":1,"stats":{"Line":22},"fn_name":null},{"line":157,"address":[4743966,4742414,4744750,4743134],"length":1,"stats":{"Line":6},"fn_name":null},{"line":158,"address":[4744912,4742839,4743296,4744065,4744849,4743233,4745155,4742576,4742513,4744128,4743642,4744443],"length":1,"stats":{"Line":12},"fn_name":null},{"line":159,"address":[4744465,4745182,4745011,4742678,4743398,4742866,4743664,4744227],"length":1,"stats":{"Line":12},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[4737860,4729730,4731072,4737728,4733700,4731150,4733584,4729680],"length":1,"stats":{"Line":8},"fn_name":"collect_from_iter<&u8,&mut core::iter::adapters::Fuse<core::slice::Iter<u8>>>"},{"line":257,"address":[4731095,4729697,4733610,4737754],"length":1,"stats":{"Line":8},"fn_name":null},{"line":259,"address":[4737875,4731165,4729745,4733715],"length":1,"stats":{"Line":8},"fn_name":null},{"line":264,"address":[4739450,4731984,4738211,4731336,4733948,4731350,4731292,4738077,4739597,4733881,4731213,4734015,4733928,4729781,4734912,4738191,4738258,4734961,4738144,4733783,4733995,4732030,4739548,4739499,4730150,4738124,4729767,4735010,4738278,4737963],"length":1,"stats":{"Line":60},"fn_name":null},{"line":265,"address":[4734035,4739580,4732059,4738231,4734944,4731367,4735042,4738298,4731309,4738164,4739531,4738097,4732016,4739482,4730173,4739629,4734993,4729798,4733968,4733901],"length":1,"stats":{"Line":40},"fn_name":null},{"line":266,"address":[4731348,4738273,4733943,4734010,4734085,4738206,4738348,4738139,4731414],"length":1,"stats":{"Line":12},"fn_name":null},{"line":269,"address":[4734090,4731386,4734054,4738317,4729811,4738353,4729875,4731419],"length":1,"stats":{"Line":16},"fn_name":null},{"line":272,"address":[4729836,4733798,4731228,4737978],"length":1,"stats":{"Line":8},"fn_name":null},{"line":273,"address":[4729848,4738686,4731240,4729936,4737990,4733810,4734340,4731586],"length":1,"stats":{"Line":16},"fn_name":null},{"line":275,"address":[4739205,4739047,4734364,4738889,4734522,4734680,4738710,4731768,4731610,4729957],"length":1,"stats":{"Line":20},"fn_name":null},{"line":276,"address":[4739698,4735427,4740367,4732190,4738778,4738945,4739103,4735098,4740152,4740451,4740033,4732309,4734736,4735189,4730200,4734578,4739914,4735555,4731824,4730013,4735308,4739261,4735636,4731666,4734420,4732099,4732437,4739795,4740286,4730287],"length":1,"stats":{"Line":18},"fn_name":null},{"line":277,"address":[4734822,4739734,4739347,4731910,4739189,4732248,4730411,4734506,4738873,4730092,4734664,4735525,4730230,4740091,4731752,4735687,4739853,4732407,4735366,4732485,4735247,4739031,4740334,4739972,4740256,4730381,4732129,4735128,4740502,4740418,4735603],"length":1,"stats":{"Line":24},"fn_name":null},{"line":280,"address":[4731926,4734846,4730108,4739371],"length":1,"stats":{"Line":8},"fn_name":null},{"line":284,"address":[4730624,4730442,4733040,4740653,4736848,4741471,4735760,4740608,4732604,4730416,4730684,4732544,4736378,4741408,4733069,4735805,4736911,4736352],"length":1,"stats":{"Line":11},"fn_name":"collect_from_iter_no_buf<&u8,&mut core::slice::Iter<u8>>"},{"line":287,"address":[4736361,4733052,4732551,4736858,4730631,4730425,4740623,4735775,4741418],"length":1,"stats":{"Line":11},"fn_name":null},{"line":290,"address":[4732624,4742059,4740948,4741930,4741688,4737251,4733321,4741150,4737213,4736461,4741892,4740713,4736713,4740745,4741194,4736512,4741569,4737009,4736185,4737358,4741027,4742015,4741172,4736395,4730765,4735992,4736093,4736542,4736600,4740808,4741531,4732699,4737090,4737128,4735897,4732780,4730459,4736163,4735865,4735960,4733155,4733123,4737336,4735825,4736061,4736931,4740910,4730482,4733086,4730727,4732818,4733214,4736431,4741065,4740673,4741491,4736686,4741811,4742037,4732908,4741773,4733246,4730514,4736971,4730704,4732661,4736630,4741650,4740840],"length":1,"stats":{"Line":81},"fn_name":null},{"line":291,"address":[4741704,4733165,4736471,4736640,4741081,4741827,4741946,4741585,4740755,4732715,4732834,4736002,4736103,4740964,4740850,4735907,4737025,4730524,4733256,4737267,4730781,4736552,4737144],"length":1,"stats":{"Line":27},"fn_name":null},{"line":293,"address":[4732878,4737314,4741753,4733291,4732764,4736584,4736667,4737074,4740795,4741010,4741014,4741128,4740890,4736588,4741634,4736503,4736141,4736046,4740894,4741757,4741880,4741993,4737197,4741876,4736042,4737193,4735947,4733201],"length":1,"stats":{"Line":9},"fn_name":null},{"line":296,"address":[4741211,4737375,4736201,4730578,4730844,4732925,4742075,4733335,4736735],"length":1,"stats":{"Line":11},"fn_name":null},{"line":299,"address":[4730820,4730557,4733098,4735842,4736412,4741508,4740690,4732636,4736948],"length":1,"stats":{"Line":6},"fn_name":null},{"line":302,"address":[4742288,4737536,4730896,4733424],"length":1,"stats":{"Line":8},"fn_name":"num_items<&u8>"},{"line":306,"address":[4730960,4729600,4733440,4737552],"length":1,"stats":{"Line":6},"fn_name":"left_shift_push<&u8>"},{"line":309,"address":[4730973,4733453,4729613,4737565],"length":1,"stats":{"Line":6},"fn_name":null},{"line":310,"address":[4733492,4737619,4730997,4729622],"length":1,"stats":{"Line":6},"fn_name":null},{"line":312,"address":[4733502,4731007,4737629,4729632],"length":1,"stats":{"Line":6},"fn_name":null},{"line":314,"address":[4729652,4731047,4737709,4733562],"length":1,"stats":{"Line":6},"fn_name":null}],"covered":61,"coverable":64},{"path":["/","home","kms","itertools","src","unique_impl.rs"],"content":"\nuse std::collections::HashMap;\nuse std::collections::hash_map::{Entry};\nuse std::hash::Hash;\nuse std::fmt;\n\n/// An iterator adapter to filter out duplicate elements.\n///\n/// See [`.unique_by()`](../trait.Itertools.html#method.unique) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct UniqueBy<I: Iterator, V, F> {\n    iter: I,\n    // Use a hashmap for the entry API\n    used: HashMap<V, ()>,\n    f: F,\n}\n\nimpl<I, V, F> fmt::Debug for UniqueBy<I, V, F>\n    where I: Iterator + fmt::Debug,\n          V: fmt::Debug + Hash + Eq,\n{\n    debug_fmt_fields!(UniqueBy, iter, used);\n}\n\n/// Create a new `UniqueBy` iterator.\npub fn unique_by<I, V, F>(iter: I, f: F) -> UniqueBy<I, V, F>\n    where V: Eq + Hash,\n          F: FnMut(&I::Item) -> V,\n          I: Iterator,\n{\n    UniqueBy {\n        iter,\n        used: HashMap::new(),\n        f,\n    }\n}\n\n// count the number of new unique keys in iterable (`used` is the set already seen)\nfn count_new_keys<I, K>(mut used: HashMap<K, ()>, iterable: I) -> usize\n    where I: IntoIterator<Item=K>,\n          K: Hash + Eq,\n{\n    let iter = iterable.into_iter();\n    let current_used = used.len();\n    used.extend(iter.map(|key| (key, ())));\n    used.len() - current_used\n}\n\nimpl<I, V, F> Iterator for UniqueBy<I, V, F>\n    where I: Iterator,\n          V: Eq + Hash,\n          F: FnMut(&I::Item) -> V\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        while let Some(v) = self.iter.next() {\n            let key = (self.f)(&v);\n            if self.used.insert(key, ()).is_none() {\n                return Some(v);\n            }\n        }\n        None\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, hi) = self.iter.size_hint();\n        ((low > 0 && self.used.is_empty()) as usize, hi)\n    }\n\n    fn count(self) -> usize {\n        let mut key_f = self.f;\n        count_new_keys(self.used, self.iter.map(move |elt| key_f(&elt)))\n    }\n}\n\nimpl<I, V, F> DoubleEndedIterator for UniqueBy<I, V, F>\n    where I: DoubleEndedIterator,\n          V: Eq + Hash,\n          F: FnMut(&I::Item) -> V\n{\n    fn next_back(&mut self) -> Option<I::Item> {\n        while let Some(v) = self.iter.next_back() {\n            let key = (self.f)(&v);\n            if self.used.insert(key, ()).is_none() {\n                return Some(v);\n            }\n        }\n        None\n    }\n}\n\nimpl<I> Iterator for Unique<I>\n    where I: Iterator,\n          I::Item: Eq + Hash + Clone\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        while let Some(v) = self.iter.iter.next() {\n            if let Entry::Vacant(entry) = self.iter.used.entry(v) {\n                let elt = entry.key().clone();\n                entry.insert(());\n                return Some(elt);\n            }\n        }\n        None\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, hi) = self.iter.iter.size_hint();\n        ((low > 0 && self.iter.used.is_empty()) as usize, hi)\n    }\n\n    fn count(self) -> usize {\n        count_new_keys(self.iter.used, self.iter.iter)\n    }\n}\n\nimpl<I> DoubleEndedIterator for Unique<I>\n    where I: DoubleEndedIterator,\n          I::Item: Eq + Hash + Clone\n{\n    fn next_back(&mut self) -> Option<I::Item> {\n        while let Some(v) = self.iter.iter.next_back() {\n            if let Entry::Vacant(entry) = self.iter.used.entry(v) {\n                let elt = entry.key().clone();\n                entry.insert(());\n                return Some(elt);\n            }\n        }\n        None\n    }\n}\n\n/// An iterator adapter to filter out duplicate elements.\n///\n/// See [`.unique()`](../trait.Itertools.html#method.unique) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Unique<I: Iterator> {\n    iter: UniqueBy<I, I::Item, ()>,\n}\n\nimpl<I> fmt::Debug for Unique<I>\n    where I: Iterator + fmt::Debug,\n          I::Item: Hash + Eq + fmt::Debug,\n{\n    debug_fmt_fields!(Unique, iter);\n}\n\npub fn unique<I>(iter: I) -> Unique<I>\n    where I: Iterator,\n          I::Item: Eq + Hash,\n{\n    Unique {\n        iter: UniqueBy {\n            iter,\n            used: HashMap::new(),\n            f: (),\n        }\n    }\n}\n","traces":[{"line":27,"address":[4593916,4594236,4594076,4593952,4594112,4593792],"length":1,"stats":{"Line":3},"fn_name":"unique_by<core::slice::Iter<&str>,alloc::string::String,closure-0>"},{"line":34,"address":[4593992,4593832,4594152],"length":1,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[4960825,4960768],"length":1,"stats":{"Line":1},"fn_name":"count_new_keys<core::iter::adapters::Cloned<core::slice::Iter<i8>>,i8>"},{"line":44,"address":[4960785,4960842],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[4960867,4960896],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[4960901,4961120,4961133],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}<core::iter::adapters::Cloned<core::slice::Iter<i8>>,i8>"},{"line":47,"address":[4960960,4961076],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[4960040,4959560,4959520,4960000],"length":1,"stats":{"Line":3},"fn_name":"next<quick::Iter<i8, quick::Inexact>>"},{"line":102,"address":[4959934,4960307,4959827,4959532,4959575,4959853,4960333,4960391,4960414,4960055,4959911,4960012],"length":1,"stats":{"Line":11},"fn_name":null},{"line":103,"address":[4959605,4960146,4959666,4960085],"length":1,"stats":{"Line":6},"fn_name":null},{"line":104,"address":[4959699,4960179],"length":1,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[4959735,4960215],"length":1,"stats":{"Line":3},"fn_name":null},{"line":106,"address":[4959778,4960258,4959932,4960412],"length":1,"stats":{"Line":6},"fn_name":null},{"line":109,"address":[4959846,4960326],"length":1,"stats":{"Line":3},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[4961152,4961550,4961334,4961376],"length":1,"stats":{"Line":4},"fn_name":"unique<core::iter::adapters::Cloned<core::slice::Iter<i8>>>"},{"line":160,"address":[4961225,4961434],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":40,"coverable":46},{"path":["/","home","kms","itertools","src","with_position.rs"],"content":"use std::iter::{Fuse,Peekable};\n\n/// An iterator adaptor that wraps each element in an [`Position`](../enum.Position.html).\n///\n/// Iterator element type is `Position<I::Item>`.\n///\n/// See [`.with_position()`](../trait.Itertools.html#method.with_position) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct WithPosition<I>\n    where I: Iterator,\n{\n    handled_first: bool,\n    peekable: Peekable<Fuse<I>>,\n}\n\nimpl<I> Clone for WithPosition<I>\n    where I: Clone + Iterator,\n          I::Item: Clone,\n{\n    clone_fields!(handled_first, peekable);\n}\n\n/// Create a new `WithPosition` iterator.\npub fn with_position<I>(iter: I) -> WithPosition<I>\n    where I: Iterator,\n{\n    WithPosition {\n        handled_first: false,\n        peekable: iter.fuse().peekable(),\n    }\n}\n\n/// A value yielded by `WithPosition`.\n/// Indicates the position of this element in the iterator results.\n///\n/// See [`.with_position()`](trait.Itertools.html#method.with_position) for more information.\n#[derive(Copy, Clone, Debug, PartialEq)]\npub enum Position<T> {\n    /// This is the first element.\n    First(T),\n    /// This is neither the first nor the last element.\n    Middle(T),\n    /// This is the last element.\n    Last(T),\n    /// This is the only element.\n    Only(T),\n}\n\nimpl<T> Position<T> {\n    /// Return the inner value.\n    pub fn into_inner(self) -> T {\n        match self {\n            Position::First(x) |\n            Position::Middle(x) |\n            Position::Last(x) |\n            Position::Only(x) => x,\n        }\n    }\n}\n\nimpl<I: Iterator> Iterator for WithPosition<I> {\n    type Item = Position<I::Item>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.peekable.next() {\n            Some(item) => {\n                if !self.handled_first {\n                    // Haven't seen the first item yet, and there is one to give.\n                    self.handled_first = true;\n                    // Peek to see if this is also the last item,\n                    // in which case tag it as `Only`.\n                    match self.peekable.peek() {\n                        Some(_) => Some(Position::First(item)),\n                        None => Some(Position::Only(item)),\n                    }\n                } else {\n                    // Have seen the first item, and there's something left.\n                    // Peek to see if this is the last item.\n                    match self.peekable.peek() {\n                        Some(_) => Some(Position::Middle(item)),\n                        None => Some(Position::Last(item)),\n                    }\n                }\n            }\n            // Iterator is finished.\n            None => None,\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.peekable.size_hint()\n    }\n}\n\nimpl<I> ExactSizeIterator for WithPosition<I>\n    where I: ExactSizeIterator,\n{ }\n","traces":[{"line":24,"address":[5956208,5956096],"length":1,"stats":{"Line":2},"fn_name":"with_position<quick::Iter<u8, quick::Exact>>"},{"line":29,"address":[5956225,5956118],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[5954976,5955472,5955424,5955015],"length":1,"stats":{"Line":2},"fn_name":"next<quick::Iter<u8, quick::Exact>>"},{"line":65,"address":[5955436,5955048,5954985,5955518],"length":1,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":16,"coverable":22},{"path":["/","home","kms","itertools","src","zip_eq_impl.rs"],"content":"use super::size_hint;\n\n/// An iterator which iterates two other iterators simultaneously\n///\n/// See [`.zip_eq()`](../trait.Itertools.html#method.zip_eq) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct ZipEq<I, J> {\n    a: I,\n    b: J,\n}\n\n/// Iterate `i` and `j` in lock step.\n///\n/// **Panics** if the iterators are not of the same length.\n///\n/// `IntoIterator` enabled version of `i.zip_eq(j)`.\n///\n/// ```\n/// use itertools::zip_eq;\n///\n/// let data = [1, 2, 3, 4, 5];\n/// for (a, b) in zip_eq(&data[..data.len() - 1], &data[1..]) {\n///     /* loop body */\n/// }\n/// ```\npub fn zip_eq<I, J>(i: I, j: J) -> ZipEq<I::IntoIter, J::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator\n{\n    ZipEq {\n        a: i.into_iter(),\n        b: j.into_iter(),\n    }\n}\n\nimpl<I, J> Iterator for ZipEq<I, J>\n    where I: Iterator,\n          J: Iterator\n{\n    type Item = (I::Item, J::Item);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match (self.a.next(), self.b.next()) {\n            (None, None) => None,\n            (Some(a), Some(b)) => Some((a, b)),\n            (None, Some(_)) | (Some(_), None) =>\n            panic!(\"itertools: .zip_eq() reached end of one iterator before the other\")\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::min(self.a.size_hint(), self.b.size_hint())\n    }\n}\n\nimpl<I, J> ExactSizeIterator for ZipEq<I, J>\n    where I: ExactSizeIterator,\n          J: ExactSizeIterator\n{}\n","traces":[{"line":27,"address":[4219888,4219664,4219772,4219996],"length":1,"stats":{"Line":3},"fn_name":"zip_eq<&[i32; 0],&[i32; 3]>"},{"line":32,"address":[4219905,4219681],"length":1,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[4219736,4219960],"length":1,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":7,"coverable":11},{"path":["/","home","kms","itertools","src","zip_longest.rs"],"content":"use std::cmp::Ordering::{Equal, Greater, Less};\nuse super::size_hint;\nuse std::iter::Fuse;\n\nuse crate::either_or_both::EitherOrBoth;\n\n// ZipLongest originally written by SimonSapin,\n// and dedicated to itertools https://github.com/rust-lang/rust/pull/19283\n\n/// An iterator which iterates two other iterators simultaneously\n///\n/// This iterator is *fused*.\n///\n/// See [`.zip_longest()`](../trait.Itertools.html#method.zip_longest) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct ZipLongest<T, U> {\n    a: Fuse<T>,\n    b: Fuse<U>,\n}\n\n/// Create a new `ZipLongest` iterator.\npub fn zip_longest<T, U>(a: T, b: U) -> ZipLongest<T, U> \n    where T: Iterator,\n          U: Iterator\n{\n    ZipLongest {\n        a: a.fuse(),\n        b: b.fuse(),\n    }\n}\n\nimpl<T, U> Iterator for ZipLongest<T, U>\n    where T: Iterator,\n          U: Iterator\n{\n    type Item = EitherOrBoth<T::Item, U::Item>;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        match (self.a.next(), self.b.next()) {\n            (None, None) => None,\n            (Some(a), None) => Some(EitherOrBoth::Left(a)),\n            (None, Some(b)) => Some(EitherOrBoth::Right(b)),\n            (Some(a), Some(b)) => Some(EitherOrBoth::Both(a, b)),\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::max(self.a.size_hint(), self.b.size_hint())\n    }\n}\n\nimpl<T, U> DoubleEndedIterator for ZipLongest<T, U>\n    where T: DoubleEndedIterator + ExactSizeIterator,\n          U: DoubleEndedIterator + ExactSizeIterator\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        match self.a.len().cmp(&self.b.len()) {\n            Equal => match (self.a.next_back(), self.b.next_back()) {\n                (None, None) => None,\n                (Some(a), Some(b)) => Some(EitherOrBoth::Both(a, b)),\n                // These can only happen if .len() is inconsistent with .next_back()\n                (Some(a), None) => Some(EitherOrBoth::Left(a)),\n                (None, Some(b)) => Some(EitherOrBoth::Right(b)),\n            },\n            Greater => self.a.next_back().map(EitherOrBoth::Left),\n            Less => self.b.next_back().map(EitherOrBoth::Right),\n        }\n    }\n}\n\nimpl<T, U> ExactSizeIterator for ZipLongest<T, U>\n    where T: ExactSizeIterator,\n          U: ExactSizeIterator\n{}\n","traces":[{"line":23,"address":[5350592,5350703,5351463,5351344,5350950,5351120,5350816,5351238],"length":1,"stats":{"Line":8},"fn_name":"zip_longest<itertools::adaptors::DedupBy<quick::Iter<i16, quick::Exact>, itertools::adaptors::DedupEq>,quick::Iter<i16, quick::Exact>>"},{"line":28,"address":[5350826,5351366,5350614,5351157],"length":1,"stats":{"Line":8},"fn_name":null},{"line":29,"address":[4213255,4213028,4213479,4212807],"length":1,"stats":{"Line":8},"fn_name":null},{"line":40,"address":[4211258,4210746,4210688,4211200],"length":1,"stats":{"Line":6},"fn_name":"next<core::iter::adapters::Map<core::slice::Iter<i32>, closure-0>,core::iter::adapters::Map<core::slice::Iter<i32>, closure-1>>"},{"line":41,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":42,"address":[5347081,5347989,5348015,5346405,5348137,5347487,5347461,5346431,5346933,5346959,5347609,5346553],"length":1,"stats":{"Line":18},"fn_name":null},{"line":43,"address":[4210995,4211378,4210866,4211507],"length":1,"stats":{"Line":10},"fn_name":null},{"line":44,"address":[5347026,5346498,5347554,5348082],"length":1,"stats":{"Line":5},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":50,"address":[5348480,5348384,5348576],"length":1,"stats":{"Line":5},"fn_name":"size_hint<quick::Iter<i16, quick::Exact>,itertools::adaptors::DedupBy<quick::Iter<i16, quick::Exact>, itertools::adaptors::DedupEq>>"},{"line":51,"address":[5348588,5348492,5348396],"length":1,"stats":{"Line":5},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":63,"address":[4212192,4212225,4212398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":17,"coverable":20},{"path":["/","home","kms","itertools","src","ziptuple.rs"],"content":"use super::size_hint;\n\n/// See [`multizip`](../fn.multizip.html) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Zip<T> {\n    t: T,\n}\n\n/// An iterator that generalizes *.zip()* and allows running multiple iterators in lockstep.\n///\n/// The iterator `Zip<(I, J, ..., M)>` is formed from a tuple of iterators (or values that\n/// implement `IntoIterator`) and yields elements\n/// until any of the subiterators yields `None`.\n///\n/// The iterator element type is a tuple like like `(A, B, ..., E)` where `A` to `E` are the\n/// element types of the subiterator.\n///\n/// **Note:** The result of this macro is a value of a named type (`Zip<(I, J,\n/// ..)>` of each component iterator `I, J, ...`) if each component iterator is\n/// nameable.\n///\n/// Prefer [`izip!()`] over `multizip` for the performance benefits of using the\n/// standard library `.zip()`. Prefer `multizip` if a nameable type is needed.\n///\n/// [`izip!()`]: macro.izip.html\n///\n/// ```\n/// use itertools::multizip;\n///\n/// // iterate over three sequences side-by-side\n/// let mut results = [0, 0, 0, 0];\n/// let inputs = [3, 7, 9, 6];\n///\n/// for (r, index, input) in multizip((&mut results, 0..10, &inputs)) {\n///     *r = index * 10 + input;\n/// }\n///\n/// assert_eq!(results, [0 + 3, 10 + 7, 29, 36]);\n/// ```\npub fn multizip<T, U>(t: U) -> Zip<T>\n    where Zip<T>: From<U>,\n          Zip<T>: Iterator,\n{\n    Zip::from(t)\n}\n\nmacro_rules! impl_zip_iter {\n    ($($B:ident),*) => (\n        #[allow(non_snake_case)]\n        impl<$($B: IntoIterator),*> From<($($B,)*)> for Zip<($($B::IntoIter,)*)> {\n            fn from(t: ($($B,)*)) -> Self {\n                let ($($B,)*) = t;\n                Zip { t: ($($B.into_iter(),)*) }\n            }\n        }\n\n        #[allow(non_snake_case)]\n        #[allow(unused_assignments)]\n        impl<$($B),*> Iterator for Zip<($($B,)*)>\n            where\n            $(\n                $B: Iterator,\n            )*\n        {\n            type Item = ($($B::Item,)*);\n\n            fn next(&mut self) -> Option<Self::Item>\n            {\n                let ($(ref mut $B,)*) = self.t;\n\n                // NOTE: Just like iter::Zip, we check the iterators\n                // for None in order. We may finish unevenly (some\n                // iterators gave n + 1 elements, some only n).\n                $(\n                    let $B = match $B.next() {\n                        None => return None,\n                        Some(elt) => elt\n                    };\n                )*\n                Some(($($B,)*))\n            }\n\n            fn size_hint(&self) -> (usize, Option<usize>)\n            {\n                let sh = (::std::usize::MAX, None);\n                let ($(ref $B,)*) = self.t;\n                $(\n                    let sh = size_hint::min($B.size_hint(), sh);\n                )*\n                sh\n            }\n        }\n\n        #[allow(non_snake_case)]\n        impl<$($B),*> ExactSizeIterator for Zip<($($B,)*)> where\n            $(\n                $B: ExactSizeIterator,\n            )*\n        { }\n    );\n}\n\nimpl_zip_iter!(A);\nimpl_zip_iter!(A, B);\nimpl_zip_iter!(A, B, C);\nimpl_zip_iter!(A, B, C, D);\nimpl_zip_iter!(A, B, C, D, E);\nimpl_zip_iter!(A, B, C, D, E, F);\nimpl_zip_iter!(A, B, C, D, E, F, G);\nimpl_zip_iter!(A, B, C, D, E, F, G, H);\n","traces":[{"line":41,"address":[4321152,4321072,4321232],"length":1,"stats":{"Line":7},"fn_name":"multizip<(core::ops::range::Range<i32>, core::ops::range::Range<i32>, core::ops::range::Range<i8>, core::slice::Iter<isize>),(core::ops::range::Range<i32>, core::ops::range::Range<i32>, core::ops::range::Range<i8>, core::slice::Iter<isize>)>"},{"line":45,"address":[4954855,4954791,4954727],"length":1,"stats":{"Line":7},"fn_name":null},{"line":52,"address":[4595024,4595274],"length":1,"stats":{"Line":7},"fn_name":"from<itertools::groupbylazy::Group<char, core::str::Chars, closure-3>,itertools::groupbylazy::Group<char, core::str::Chars, closure-3>,itertools::groupbylazy::Group<char, core::str::Chars, closure-3>,itertools::groupbylazy::Group<char, core::str::Chars, closure-3>>"},{"line":53,"address":[4953722,4954218,4953226],"length":1,"stats":{"Line":7},"fn_name":null},{"line":54,"address":[4595156,4595321],"length":1,"stats":{"Line":7},"fn_name":null},{"line":68,"address":[4951493,4950432,4950928,4950501,4950997,4951424],"length":1,"stats":{"Line":7},"fn_name":"next<itertools::adaptors::DedupBy<quick::Iter<i16, quick::Exact>, itertools::adaptors::DedupEq>,quick::Iter<i16, quick::Exact>,quick::Iter<i16, quick::Exact>>"},{"line":70,"address":[4316559,4317119,4317887],"length":1,"stats":{"Line":7},"fn_name":null},{"line":76,"address":[4951686,4950479,4950634,4950772,4950799,4950724,4951268,4950975,4951025,4951764,4951791,4951716,4951521,4950529,4950603,4951130,4951220,4950694,4951295,4951471,4951099,4951626,4951190,4951595],"length":1,"stats":{"Line":39},"fn_name":null},{"line":77,"address":[4950513,4950531,4950636,4950726,4950550,4951700,4951143,4951628,4951222,4951505,4951727,4951132,4951542,4951718,4950708,4951046,4951204,4951009,4951231,4951114,4950647,4951610,4951523,4950735,4950618,4951639,4951027],"length":1,"stats":{"Line":52},"fn_name":null},{"line":78,"address":[4951145,4950649,4950737,4951729,4951233,4951050,4951546,4950554,4951641],"length":1,"stats":{"Line":21},"fn_name":null},{"line":81,"address":[4950825,4951321,4951817],"length":1,"stats":{"Line":5},"fn_name":null},{"line":84,"address":[4951920,4952784,4952352],"length":1,"stats":{"Line":3},"fn_name":"size_hint<quick::Iter<i16, quick::Exact>,quick::Iter<i16, quick::Exact>,quick::Iter<i16, quick::Exact>>"},{"line":86,"address":[4951935,4952367,4952799],"length":1,"stats":{"Line":3},"fn_name":null},{"line":87,"address":[4952405,4951973,4952837],"length":1,"stats":{"Line":3},"fn_name":null},{"line":89,"address":[4952881,4952017,4952449],"length":1,"stats":{"Line":3},"fn_name":null},{"line":91,"address":[4952288,4952720,4953152],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":16,"coverable":16},{"path":["/","home","kms","itertools","tests","adaptors_no_collect.rs"],"content":"use itertools::Itertools;\n\nstruct PanickingCounter {\n    curr: usize,\n    max: usize,\n}\n\nimpl Iterator for PanickingCounter {\n    type Item = ();\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.curr += 1;\n\n        if self.curr == self.max {\n            panic!(\n                \"Input iterator reached maximum of {} suggesting collection by adaptor\",\n                self.max\n            );\n        }\n\n        Some(())\n    }\n}\n\nfn no_collect_test<A, T>(to_adaptor: T)\n    where A: Iterator, T: Fn(PanickingCounter) -> A\n{\n    let counter = PanickingCounter { curr: 0, max: 10_000 };\n    let adaptor = to_adaptor(counter);\n\n    for _ in adaptor.take(5) {}\n}\n\n#[test]\nfn permutations_no_collect() {\n    no_collect_test(|iter| iter.permutations(5))\n}\n\n#[test]\nfn combinations_no_collect() {\n    no_collect_test(|iter| iter.combinations(5))\n}\n\n#[test]\nfn combinations_with_replacement_no_collect() {\n    no_collect_test(|iter| iter.combinations_with_replacement(5))\n}","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[4244304,4245008,4245100,4243568,4244384,4243660],"length":1,"stats":{"Line":3},"fn_name":"no_collect_test<itertools::permutations::Permutations<adaptors_no_collect::PanickingCounter>,closure-0>"},{"line":28,"address":[4243575,4244311,4245015],"length":1,"stats":{"Line":3},"fn_name":null},{"line":29,"address":[4244337,4245041,4243601],"length":1,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[4243818,4244399,4243675,4245589,4244510,4245115,4244860,4244168,4245239],"length":1,"stats":{"Line":6},"fn_name":null},{"line":35,"address":[4255568],"length":1,"stats":{"Line":3},"fn_name":"permutations_no_collect"},{"line":36,"address":[4245760,4245782],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":40,"address":[4245824,4245829],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":41,"address":[4245878,4245856],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":45,"address":[4245925,4245920],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":46,"address":[4245952,4245974],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"}],"covered":13,"coverable":16},{"path":["/","home","kms","itertools","tests","fold_specialization.rs"],"content":"use itertools::Itertools;\n\n#[test]\nfn specialization_intersperse() {\n    let mut iter = (1..2).intersperse(0);\n    iter.clone().for_each(|x| assert_eq!(Some(x), iter.next()));\n\n    let mut iter = (1..3).intersperse(0);\n    iter.clone().for_each(|x| assert_eq!(Some(x), iter.next()));\n\n    let mut iter = (1..4).intersperse(0);\n    iter.clone().for_each(|x| assert_eq!(Some(x), iter.next()));\n}\n","traces":[{"line":4,"address":[4211920,4211965],"length":1,"stats":{"Line":3},"fn_name":"specialization_intersperse"},{"line":5,"address":[4211929],"length":1,"stats":{"Line":1},"fn_name":null},{"line":6,"address":[4211990],"length":1,"stats":{"Line":3},"fn_name":null},{"line":8,"address":[4212036],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[4212084],"length":1,"stats":{"Line":3},"fn_name":null},{"line":11,"address":[4212136],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[4212205],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","kms","itertools","tests","merge_join.rs"],"content":"use itertools::EitherOrBoth;\nuse itertools::free::merge_join_by;\n\n#[test]\nfn empty() {\n    let left: Vec<u32> = vec![];\n    let right: Vec<u32> = vec![];\n    let expected_result: Vec<EitherOrBoth<u32, u32>> = vec![];\n    let actual_result = merge_join_by(left, right, |l, r| l.cmp(r))\n        .collect::<Vec<_>>();\n    assert_eq!(expected_result, actual_result);\n}\n\n#[test]\nfn left_only() {\n    let left: Vec<u32> = vec![1,2,3];\n    let right: Vec<u32> = vec![];\n    let expected_result: Vec<EitherOrBoth<u32, u32>> = vec![\n        EitherOrBoth::Left(1),\n        EitherOrBoth::Left(2),\n        EitherOrBoth::Left(3)\n    ];\n    let actual_result = merge_join_by(left, right, |l, r| l.cmp(r))\n        .collect::<Vec<_>>();\n    assert_eq!(expected_result, actual_result);\n}\n\n#[test]\nfn right_only() {\n    let left: Vec<u32> = vec![];\n    let right: Vec<u32> = vec![1,2,3];\n    let expected_result: Vec<EitherOrBoth<u32, u32>> = vec![\n        EitherOrBoth::Right(1),\n        EitherOrBoth::Right(2),\n        EitherOrBoth::Right(3)\n    ];\n    let actual_result = merge_join_by(left, right, |l, r| l.cmp(r))\n        .collect::<Vec<_>>();\n    assert_eq!(expected_result, actual_result);\n}\n\n#[test]\nfn first_left_then_right() {\n    let left: Vec<u32> = vec![1,2,3];\n    let right: Vec<u32> = vec![4,5,6];\n    let expected_result: Vec<EitherOrBoth<u32, u32>> = vec![\n        EitherOrBoth::Left(1),\n        EitherOrBoth::Left(2),\n        EitherOrBoth::Left(3),\n        EitherOrBoth::Right(4),\n        EitherOrBoth::Right(5),\n        EitherOrBoth::Right(6)\n    ];\n    let actual_result = merge_join_by(left, right, |l, r| l.cmp(r))\n        .collect::<Vec<_>>();\n    assert_eq!(expected_result, actual_result);\n}\n\n#[test]\nfn first_right_then_left() {\n    let left: Vec<u32> = vec![4,5,6];\n    let right: Vec<u32> = vec![1,2,3];\n    let expected_result: Vec<EitherOrBoth<u32, u32>> = vec![\n        EitherOrBoth::Right(1),\n        EitherOrBoth::Right(2),\n        EitherOrBoth::Right(3),\n        EitherOrBoth::Left(4),\n        EitherOrBoth::Left(5),\n        EitherOrBoth::Left(6)\n    ];\n    let actual_result = merge_join_by(left, right, |l, r| l.cmp(r))\n        .collect::<Vec<_>>();\n    assert_eq!(expected_result, actual_result);\n}\n\n#[test]\nfn interspersed_left_and_right() {\n    let left: Vec<u32> = vec![1,3,5];\n    let right: Vec<u32> = vec![2,4,6];\n    let expected_result: Vec<EitherOrBoth<u32, u32>> = vec![\n        EitherOrBoth::Left(1),\n        EitherOrBoth::Right(2),\n        EitherOrBoth::Left(3),\n        EitherOrBoth::Right(4),\n        EitherOrBoth::Left(5),\n        EitherOrBoth::Right(6)\n    ];\n    let actual_result = merge_join_by(left, right, |l, r| l.cmp(r))\n        .collect::<Vec<_>>();\n    assert_eq!(expected_result, actual_result);\n}\n\n#[test]\nfn overlapping_left_and_right() {\n    let left: Vec<u32> = vec![1,3,4,6];\n    let right: Vec<u32> = vec![2,3,4,5];\n    let expected_result: Vec<EitherOrBoth<u32, u32>> = vec![\n        EitherOrBoth::Left(1),\n        EitherOrBoth::Right(2),\n        EitherOrBoth::Both(3, 3),\n        EitherOrBoth::Both(4, 4),\n        EitherOrBoth::Right(5),\n        EitherOrBoth::Left(6)\n    ];\n    let actual_result = merge_join_by(left, right, |l, r| l.cmp(r))\n        .collect::<Vec<_>>();\n    assert_eq!(expected_result, actual_result);\n}\n","traces":[{"line":5,"address":[4240896,4240952],"length":1,"stats":{"Line":3},"fn_name":"empty"},{"line":6,"address":[4240907,4240967],"length":1,"stats":{"Line":2},"fn_name":null},{"line":7,"address":[4241033,4240984],"length":1,"stats":{"Line":2},"fn_name":null},{"line":8,"address":[4241050],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[4231664,4231683],"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":11,"address":[4241381,4241250],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[4241856,4241937],"length":1,"stats":{"Line":3},"fn_name":"left_only"},{"line":16,"address":[4241863,4241952],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[4241969,4242018],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[4242036,4242107],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4242041],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[4242063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[4242085],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[4231744,4231763],"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":25,"address":[4242353,4242484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[4231792,4231797],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":30,"address":[4243031,4242971],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[4243049,4243110],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[4243128,4243199],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[4243133],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[4243155],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[4243177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[4231843,4231824],"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":39,"address":[4243445,4243576],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4231877,4231872],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":44,"address":[4244055,4244144],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[4244162,4244223],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[4244241,4244378],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[4244246],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[4244268],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[4244290],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[4244312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[4244334],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[4244356],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[4231923,4231904],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":56,"address":[4244821,4244690],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4231952,4231957],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":61,"address":[4245303,4245392],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[4245471,4245410],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[4245626,4245489],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[4245494],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[4245516],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[4245538],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[4245560],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[4245582],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[4245604],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[4231984,4232003],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":73,"address":[4246069,4245938],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[4232032,4232037],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":78,"address":[4246551,4246640],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[4246719,4246658],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[4246737,4246874],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[4246742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[4246764],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[4246786],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[4246808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[4246830],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[4246852],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[4232083,4232064],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":90,"address":[4247186,4247317],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[4232112,4232117],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":95,"address":[4247895,4247799],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[4247913,4247989],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[4248007,4248166],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[4248012],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[4248034],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[4248056],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[4248089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[4248122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[4248144],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[4232144,4232163],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":107,"address":[4248609,4248478],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":72,"coverable":72},{"path":["/","home","kms","itertools","tests","peeking_take_while.rs"],"content":"use itertools::Itertools;\nuse itertools::{put_back, put_back_n};\n\n#[test]\nfn peeking_take_while_peekable() {\n    let mut r = (0..10).peekable();\n    r.peeking_take_while(|x| *x <= 3).count();\n    assert_eq!(r.next(), Some(4));\n}\n\n#[test]\nfn peeking_take_while_put_back() {\n    let mut r = put_back(0..10);\n    r.peeking_take_while(|x| *x <= 3).count();\n    assert_eq!(r.next(), Some(4));\n    r.peeking_take_while(|_| true).count();\n    assert_eq!(r.next(), None);\n}\n\n#[test]\nfn peeking_take_while_put_back_n() {\n    let mut r = put_back_n(6..10);\n    for elt in (0..6).rev() {\n        r.put_back(elt);\n    }\n    r.peeking_take_while(|x| *x <= 3).count();\n    assert_eq!(r.next(), Some(4));\n    r.peeking_take_while(|_| true).count();\n    assert_eq!(r.next(), None);\n}\n\n#[test]\nfn peeking_take_while_slice_iter() {\n    let v = [1, 2, 3, 4, 5, 6];\n    let mut r = v.iter();\n    r.peeking_take_while(|x| **x <= 3).count();\n    assert_eq!(r.next(), Some(&4));\n    r.peeking_take_while(|_| true).count();\n    assert_eq!(r.next(), None);\n}\n\n#[test]\nfn peeking_take_while_slice_iter_rev() {\n    let v = [1, 2, 3, 4, 5, 6];\n    let mut r = v.iter().rev();\n    r.peeking_take_while(|x| **x >= 3).count();\n    assert_eq!(r.next(), Some(&2));\n    r.peeking_take_while(|_| true).count();\n    assert_eq!(r.next(), None);\n}\n","traces":[{"line":5,"address":[4220048],"length":1,"stats":{"Line":3},"fn_name":"peeking_take_while_peekable"},{"line":6,"address":[4220055],"length":1,"stats":{"Line":1},"fn_name":null},{"line":7,"address":[4227693,4227680],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":8,"address":[4220211,4220119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[4227733,4227728],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":13,"address":[4220487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[4227760,4227773],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":15,"address":[4220551,4220682],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[4227821,4227808,4227833],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":17,"address":[4221101,4220976],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[4227845,4227840],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":22,"address":[4221399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[4221465,4221579,4221698,4221764],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[4221742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[4221777,4221683],"length":1,"stats":{"Line":4},"fn_name":null},{"line":27,"address":[4221792,4221964],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[4221949,4222271],"length":1,"stats":{"Line":4},"fn_name":null},{"line":29,"address":[4222286,4222441],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[4222768],"length":1,"stats":{"Line":3},"fn_name":"peeking_take_while_slice_iter"},{"line":34,"address":[4222775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[4222833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[4222851],"length":1,"stats":{"Line":3},"fn_name":null},{"line":37,"address":[4222876,4223012],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[4222992,4223296],"length":1,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[4223425,4223301],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4223712],"length":1,"stats":{"Line":3},"fn_name":"peeking_take_while_slice_iter_rev"},{"line":44,"address":[4223719],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[4223773],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[4223832],"length":1,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[4224002,4223860],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[4223979,4224286],"length":1,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[4224291,4224418],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":32,"coverable":32},{"path":["/","home","kms","itertools","tests","quick.rs"],"content":"//! The purpose of these tests is to cover corner cases of iterators\n//! and adaptors.\n//!\n//! In particular we test the tedious size_hint and exact size correctness.\n\nuse quickcheck as qc;\nuse std::default::Default;\nuse std::ops::Range;\nuse std::cmp::{max, min, Ordering};\nuse std::collections::HashSet;\nuse itertools::Itertools;\nuse itertools::{\n    multizip,\n    EitherOrBoth,\n    iproduct,\n    izip,\n};\nuse itertools::free::{\n    cloned,\n    enumerate,\n    multipeek,\n    peek_nth,\n    put_back,\n    put_back_n,\n    rciter,\n    zip,\n    zip_eq,\n};\n\nuse rand::Rng;\nuse rand::seq::SliceRandom;\nuse quickcheck::TestResult;\n\n/// Trait for size hint modifier types\ntrait HintKind: Copy + Send + qc::Arbitrary {\n    fn loosen_bounds(&self, org_hint: (usize, Option<usize>)) -> (usize, Option<usize>);\n}\n\n/// Exact size hint variant that leaves hints unchanged\n#[derive(Clone, Copy, Debug)]\nstruct Exact {}\n\nimpl HintKind for Exact {\n    fn loosen_bounds(&self, org_hint: (usize, Option<usize>)) -> (usize, Option<usize>) {\n        org_hint\n    }\n}\n\nimpl qc::Arbitrary for Exact {\n    fn arbitrary<G: qc::Gen>(_: &mut G) -> Self {\n        Exact {}\n    }\n}\n\n/// Inexact size hint variant to simulate imprecise (but valid) size hints\n///\n/// Will always decrease the lower bound and increase the upper bound\n/// of the size hint by set amounts.\n#[derive(Clone, Copy, Debug)]\nstruct Inexact {\n    underestimate: usize,\n    overestimate: usize,\n}\n\nimpl HintKind for Inexact {\n    fn loosen_bounds(&self, org_hint: (usize, Option<usize>)) -> (usize, Option<usize>) {\n        let (org_lower, org_upper) = org_hint;\n        (org_lower.saturating_sub(self.underestimate),\n         org_upper.and_then(move |x| x.checked_add(self.overestimate)))\n    }\n}\n\nimpl qc::Arbitrary for Inexact {\n    fn arbitrary<G: qc::Gen>(g: &mut G) -> Self {\n        let ue_value = usize::arbitrary(g);\n        let oe_value = usize::arbitrary(g);\n        // Compensate for quickcheck using extreme values too rarely\n        let ue_choices = &[0, ue_value, usize::max_value()];\n        let oe_choices = &[0, oe_value, usize::max_value()];\n        Inexact {\n            underestimate: *ue_choices.choose(g).unwrap(),\n            overestimate: *oe_choices.choose(g).unwrap(),\n        }\n    }\n\n    fn shrink(&self) -> Box<dyn Iterator<Item=Self>> {\n        let underestimate_value = self.underestimate;\n        let overestimate_value = self.overestimate;\n        Box::new(\n            underestimate_value.shrink().flat_map(move |ue_value|\n                overestimate_value.shrink().map(move |oe_value|\n                    Inexact {\n                        underestimate: ue_value,\n                        overestimate: oe_value,\n                    }\n                )\n            )\n        )\n    }\n}\n\n/// Our base iterator that we can impl Arbitrary for\n///\n/// By default we'll return inexact bounds estimates for size_hint\n/// to make tests harder to pass.\n///\n/// NOTE: Iter is tricky and is not fused, to help catch bugs.\n/// At the end it will return None once, then return Some(0),\n/// then return None again.\n#[derive(Clone, Debug)]\nstruct Iter<T, SK: HintKind = Inexact> {\n    iterator: Range<T>,\n    // fuse/done flag\n    fuse_flag: i32,\n    hint_kind: SK,\n}\n\nimpl<T, HK> Iter<T, HK> where HK: HintKind\n{\n    fn new(it: Range<T>, hint_kind: HK) -> Self {\n        Iter {\n            iterator: it,\n            fuse_flag: 0,\n            hint_kind,\n        }\n    }\n}\n\nimpl<T, HK> Iterator for Iter<T, HK>\n    where Range<T>: Iterator,\n          <Range<T> as Iterator>::Item: Default,\n          HK: HintKind,\n{\n    type Item = <Range<T> as Iterator>::Item;\n\n    fn next(&mut self) -> Option<Self::Item>\n    {\n        let elt = self.iterator.next();\n        if elt.is_none() {\n            self.fuse_flag += 1;\n            // check fuse flag\n            if self.fuse_flag == 2 {\n                return Some(Default::default())\n            }\n        }\n        elt\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>)\n    {\n        let org_hint = self.iterator.size_hint();\n        self.hint_kind.loosen_bounds(org_hint)\n    }\n}\n\nimpl<T, HK> DoubleEndedIterator for Iter<T, HK>\n    where Range<T>: DoubleEndedIterator,\n          <Range<T> as Iterator>::Item: Default,\n          HK: HintKind\n{\n    fn next_back(&mut self) -> Option<Self::Item> { self.iterator.next_back() }\n}\n\nimpl<T> ExactSizeIterator for Iter<T, Exact> where Range<T>: ExactSizeIterator,\n    <Range<T> as Iterator>::Item: Default,\n{ }\n\nimpl<T, HK> qc::Arbitrary for Iter<T, HK>\n    where T: qc::Arbitrary,\n          HK: HintKind,\n{\n    fn arbitrary<G: qc::Gen>(g: &mut G) -> Self\n    {\n        Iter::new(T::arbitrary(g)..T::arbitrary(g), HK::arbitrary(g))\n    }\n\n    fn shrink(&self) -> Box<dyn Iterator<Item=Iter<T, HK>>>\n    {\n        let r = self.iterator.clone();\n        let hint_kind = self.hint_kind;\n        Box::new(\n            r.start.shrink().flat_map(move |a|\n                r.end.shrink().map(move |b|\n                    Iter::new(a.clone()..b, hint_kind)\n                )\n            )\n        )\n    }\n}\n\n/// A meta-iterator which yields `Iter<i32>`s whose start/endpoints are\n/// increased or decreased linearly on each iteration.\n#[derive(Clone, Debug)]\nstruct ShiftRange<HK = Inexact> {\n    range_start: i32,\n    range_end: i32,\n    start_step: i32,\n    end_step: i32,\n    iter_count: u32,\n    hint_kind: HK,\n}\n\nimpl<HK> Iterator for ShiftRange<HK> where HK: HintKind {\n    type Item = Iter<i32, HK>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.iter_count == 0 {\n            return None;\n        }\n\n        let iter = Iter::new(self.range_start..self.range_end, self.hint_kind);\n\n        self.range_start += self.start_step;\n        self.range_end += self.end_step;\n        self.iter_count -= 1;\n\n        Some(iter)\n    }\n}\n\nimpl ExactSizeIterator for ShiftRange<Exact> { }\n\nimpl<HK> qc::Arbitrary for ShiftRange<HK>\n    where HK: HintKind\n{\n    fn arbitrary<G: qc::Gen>(g: &mut G) -> Self {\n        const MAX_STARTING_RANGE_DIFF: i32 = 32;\n        const MAX_STEP_MODULO: i32 = 8;\n        const MAX_ITER_COUNT: u32 = 3;\n\n        let range_start = qc::Arbitrary::arbitrary(g);\n        let range_end = range_start + g.gen_range(0, MAX_STARTING_RANGE_DIFF + 1);\n        let start_step = g.gen_range(-MAX_STEP_MODULO, MAX_STEP_MODULO + 1);\n        let end_step = g.gen_range(-MAX_STEP_MODULO, MAX_STEP_MODULO + 1);\n        let iter_count = g.gen_range(0, MAX_ITER_COUNT + 1);\n        let hint_kind = qc::Arbitrary::arbitrary(g);\n\n        ShiftRange {\n            range_start,\n            range_end,\n            start_step,\n            end_step,\n            iter_count,\n            hint_kind,\n        }\n    }\n}\n\nfn correct_count<I, F>(get_it: F) -> bool\nwhere\n    I: Iterator,\n    F: Fn() -> I\n{\n    let mut counts = vec![get_it().count()];\n\n    'outer: loop {\n        let mut it = get_it();\n\n        for _ in 0..(counts.len() - 1) {\n            if let None = it.next() {\n                panic!(\"Iterator shouldn't be finished, may not be deterministic\");\n            }\n        }\n\n        if let None = it.next() {\n            break 'outer;\n        }\n\n        counts.push(it.count());\n    }\n\n    let total_actual_count = counts.len() - 1;\n\n    for (i, returned_count) in counts.into_iter().enumerate() {\n        let actual_count = total_actual_count - i;\n        if actual_count != returned_count {\n            println!(\"Total iterations: {} True count: {} returned count: {}\", i, actual_count, returned_count);\n\n            return false;\n        }\n    }\n\n    true\n}\n\nfn correct_size_hint<I: Iterator>(mut it: I) -> bool {\n    // record size hint at each iteration\n    let initial_hint = it.size_hint();\n    let mut hints = Vec::with_capacity(initial_hint.0 + 1);\n    hints.push(initial_hint);\n    while let Some(_) = it.next() {\n        hints.push(it.size_hint())\n    }\n\n    let mut true_count = hints.len(); // start off +1 too much\n\n    // check all the size hints\n    for &(low, hi) in &hints {\n        true_count -= 1;\n        if low > true_count ||\n            (hi.is_some() && hi.unwrap() < true_count)\n        {\n            println!(\"True size: {:?}, size hint: {:?}\", true_count, (low, hi));\n            //println!(\"All hints: {:?}\", hints);\n            return false\n        }\n    }\n    true\n}\n\nfn exact_size<I: ExactSizeIterator>(mut it: I) -> bool {\n    // check every iteration\n    let (mut low, mut hi) = it.size_hint();\n    if Some(low) != hi { return false; }\n    while let Some(_) = it.next() {\n        let (xlow, xhi) = it.size_hint();\n        if low != xlow + 1 { return false; }\n        low = xlow;\n        hi = xhi;\n        if Some(low) != hi { return false; }\n    }\n    let (low, hi) = it.size_hint();\n    low == 0 && hi == Some(0)\n}\n\n// Exact size for this case, without ExactSizeIterator\nfn exact_size_for_this<I: Iterator>(mut it: I) -> bool {\n    // check every iteration\n    let (mut low, mut hi) = it.size_hint();\n    if Some(low) != hi { return false; }\n    while let Some(_) = it.next() {\n        let (xlow, xhi) = it.size_hint();\n        if low != xlow + 1 { return false; }\n        low = xlow;\n        hi = xhi;\n        if Some(low) != hi { return false; }\n    }\n    let (low, hi) = it.size_hint();\n    low == 0 && hi == Some(0)\n}\n\n/*\n * NOTE: Range<i8> is broken!\n * (all signed ranges are)\n#[quickcheck]\nfn size_range_i8(a: Iter<i8>) -> bool {\n    exact_size(a)\n}\n\n#[quickcheck]\nfn size_range_i16(a: Iter<i16>) -> bool {\n    exact_size(a)\n}\n\n#[quickcheck]\nfn size_range_u8(a: Iter<u8>) -> bool {\n    exact_size(a)\n}\n */\n\nmacro_rules! quickcheck {\n    // accept several property function definitions\n    // The property functions can use pattern matching and `mut` as usual\n    // in the function arguments, but the functions can not be generic.\n    {$($(#$attr:tt)* fn $fn_name:ident($($arg:tt)*) -> $ret:ty { $($code:tt)* })*} => (\n        $(\n            #[test]\n            $(#$attr)*\n            fn $fn_name() {\n                fn prop($($arg)*) -> $ret {\n                    $($code)*\n                }\n                ::quickcheck::quickcheck(quickcheck!(@fn prop [] $($arg)*));\n            }\n        )*\n    );\n    // parse argument list (with patterns allowed) into prop as fn(_, _) -> _\n    (@fn $f:ident [$($t:tt)*]) => {\n        $f as fn($($t),*) -> _\n    };\n    (@fn $f:ident [$($p:tt)*] : $($tail:tt)*) => {\n        quickcheck!(@fn $f [$($p)* _] $($tail)*)\n    };\n    (@fn $f:ident [$($p:tt)*] $t:tt $($tail:tt)*) => {\n        quickcheck!(@fn $f [$($p)*] $($tail)*)\n    };\n}\n\nquickcheck! {\n\n    fn size_product(a: Iter<u16>, b: Iter<u16>) -> bool {\n        correct_size_hint(a.cartesian_product(b))\n    }\n    fn size_product3(a: Iter<u16>, b: Iter<u16>, c: Iter<u16>) -> bool {\n        correct_size_hint(iproduct!(a, b, c))\n    }\n\n    fn correct_cartesian_product3(a: Iter<u16>, b: Iter<u16>, c: Iter<u16>,\n                                  take_manual: usize) -> ()\n    {\n        // test correctness of iproduct through regular iteration (take)\n        // and through fold.\n        let ac = a.clone();\n        let br = &b.clone();\n        let cr = &c.clone();\n        let answer: Vec<_> = ac.flat_map(move |ea| br.clone().flat_map(move |eb| cr.clone().map(move |ec| (ea, eb, ec)))).collect();\n        let mut product_iter = iproduct!(a, b, c);\n        let mut actual = Vec::new();\n\n        actual.extend((&mut product_iter).take(take_manual));\n        if actual.len() == take_manual {\n            product_iter.fold((), |(), elt| actual.push(elt));\n        }\n        assert_eq!(answer, actual);\n    }\n\n    fn size_multi_product(a: ShiftRange) -> bool {\n        correct_size_hint(a.multi_cartesian_product())\n    }\n    fn correct_multi_product3(a: ShiftRange, take_manual: usize) -> () {\n        // Fix no. of iterators at 3\n        let a = ShiftRange { iter_count: 3, ..a };\n\n        // test correctness of MultiProduct through regular iteration (take)\n        // and through fold.\n        let mut iters = a.clone();\n        let i0 = iters.next().unwrap();\n        let i1r = &iters.next().unwrap();\n        let i2r = &iters.next().unwrap();\n        let answer: Vec<_> = i0.flat_map(move |ei0| i1r.clone().flat_map(move |ei1| i2r.clone().map(move |ei2| vec![ei0, ei1, ei2]))).collect();\n        let mut multi_product = a.clone().multi_cartesian_product();\n        let mut actual = Vec::new();\n\n        actual.extend((&mut multi_product).take(take_manual));\n        if actual.len() == take_manual {\n            multi_product.fold((), |(), elt| actual.push(elt));\n        }\n        assert_eq!(answer, actual);\n\n        assert_eq!(answer.into_iter().last(), a.clone().multi_cartesian_product().last());\n    }\n\n    #[allow(deprecated)]\n    fn size_step(a: Iter<i16, Exact>, s: usize) -> bool {\n        let mut s = s;\n        if s == 0 {\n            s += 1; // never zero\n        }\n        let filt = a.clone().dedup();\n        correct_size_hint(filt.step(s)) &&\n            exact_size(a.step(s))\n    }\n\n    #[allow(deprecated)]\n    fn equal_step(a: Iter<i16>, s: usize) -> bool {\n        let mut s = s;\n        if s == 0 {\n            s += 1; // never zero\n        }\n        let mut i = 0;\n        itertools::equal(a.clone().step(s), a.filter(|_| {\n            let keep = i % s == 0;\n            i += 1;\n            keep\n        }))\n    }\n\n    #[allow(deprecated)]\n    fn equal_step_vec(a: Vec<i16>, s: usize) -> bool {\n        let mut s = s;\n        if s == 0 {\n            s += 1; // never zero\n        }\n        let mut i = 0;\n        itertools::equal(a.iter().step(s), a.iter().filter(|_| {\n            let keep = i % s == 0;\n            i += 1;\n            keep\n        }))\n    }\n\n    fn size_multipeek(a: Iter<u16, Exact>, s: u8) -> bool {\n        let mut it = multipeek(a);\n        // peek a few times\n        for _ in 0..s {\n            it.peek();\n        }\n        exact_size(it)\n    }\n\n    fn size_peek_nth(a: Iter<u16, Exact>, s: u8) -> bool {\n        let mut it = peek_nth(a);\n        // peek a few times\n        for n in 0..s {\n            it.peek_nth(n as usize);\n        }\n        exact_size(it)\n    }\n\n    fn equal_merge(a: Vec<i16>, b: Vec<i16>) -> bool {\n        let mut sa = a.clone();\n        let mut sb = b.clone();\n        sa.sort();\n        sb.sort();\n        let mut merged = sa.clone();\n        merged.extend(sb.iter().cloned());\n        merged.sort();\n        itertools::equal(&merged, sa.iter().merge(&sb))\n    }\n    fn size_merge(a: Iter<u16>, b: Iter<u16>) -> bool {\n        correct_size_hint(a.merge(b))\n    }\n    fn size_zip(a: Iter<i16, Exact>, b: Iter<i16, Exact>, c: Iter<i16, Exact>) -> bool {\n        let filt = a.clone().dedup();\n        correct_size_hint(multizip((filt, b.clone(), c.clone()))) &&\n            exact_size(multizip((a, b, c)))\n    }\n    fn size_zip_rc(a: Iter<i16>, b: Iter<i16>) -> bool {\n        let rc = rciter(a.clone());\n        correct_size_hint(multizip((&rc, &rc, b)))\n    }\n\n    fn size_zip_macro(a: Iter<i16, Exact>, b: Iter<i16, Exact>, c: Iter<i16, Exact>) -> bool {\n        let filt = a.clone().dedup();\n        correct_size_hint(izip!(filt, b.clone(), c.clone())) &&\n            exact_size(izip!(a, b, c))\n    }\n    fn equal_kmerge(a: Vec<i16>, b: Vec<i16>, c: Vec<i16>) -> bool {\n        use itertools::free::kmerge;\n        let mut sa = a.clone();\n        let mut sb = b.clone();\n        let mut sc = c.clone();\n        sa.sort();\n        sb.sort();\n        sc.sort();\n        let mut merged = sa.clone();\n        merged.extend(sb.iter().cloned());\n        merged.extend(sc.iter().cloned());\n        merged.sort();\n        itertools::equal(merged.into_iter(), kmerge(vec![sa, sb, sc]))\n    }\n\n    // Any number of input iterators\n    fn equal_kmerge_2(mut inputs: Vec<Vec<i16>>) -> bool {\n        use itertools::free::kmerge;\n        // sort the inputs\n        for input in &mut inputs {\n            input.sort();\n        }\n        let mut merged = inputs.concat();\n        merged.sort();\n        itertools::equal(merged.into_iter(), kmerge(inputs))\n    }\n\n    // Any number of input iterators\n    fn equal_kmerge_by_ge(mut inputs: Vec<Vec<i16>>) -> bool {\n        // sort the inputs\n        for input in &mut inputs {\n            input.sort();\n            input.reverse();\n        }\n        let mut merged = inputs.concat();\n        merged.sort();\n        merged.reverse();\n        itertools::equal(merged.into_iter(),\n                         inputs.into_iter().kmerge_by(|x, y| x >= y))\n    }\n\n    // Any number of input iterators\n    fn equal_kmerge_by_lt(mut inputs: Vec<Vec<i16>>) -> bool {\n        // sort the inputs\n        for input in &mut inputs {\n            input.sort();\n        }\n        let mut merged = inputs.concat();\n        merged.sort();\n        itertools::equal(merged.into_iter(),\n                         inputs.into_iter().kmerge_by(|x, y| x < y))\n    }\n\n    // Any number of input iterators\n    fn equal_kmerge_by_le(mut inputs: Vec<Vec<i16>>) -> bool {\n        // sort the inputs\n        for input in &mut inputs {\n            input.sort();\n        }\n        let mut merged = inputs.concat();\n        merged.sort();\n        itertools::equal(merged.into_iter(),\n                         inputs.into_iter().kmerge_by(|x, y| x <= y))\n    }\n    fn size_kmerge(a: Iter<i16>, b: Iter<i16>, c: Iter<i16>) -> bool {\n        use itertools::free::kmerge;\n        correct_size_hint(kmerge(vec![a, b, c]))\n    }\n    fn equal_zip_eq(a: Vec<i32>, b: Vec<i32>) -> bool {\n        let len = std::cmp::min(a.len(), b.len());\n        let a = &a[..len];\n        let b = &b[..len];\n        itertools::equal(zip_eq(a, b), zip(a, b))\n    }\n    fn size_zip_longest(a: Iter<i16, Exact>, b: Iter<i16, Exact>) -> bool {\n        let filt = a.clone().dedup();\n        let filt2 = b.clone().dedup();\n        correct_size_hint(filt.zip_longest(b.clone())) &&\n        correct_size_hint(a.clone().zip_longest(filt2)) &&\n            exact_size(a.zip_longest(b))\n    }\n    fn size_2_zip_longest(a: Iter<i16>, b: Iter<i16>) -> bool {\n        let it = a.clone().zip_longest(b.clone());\n        let jt = a.clone().zip_longest(b.clone());\n        itertools::equal(a.clone(),\n                         it.filter_map(|elt| match elt {\n                             EitherOrBoth::Both(x, _) => Some(x),\n                             EitherOrBoth::Left(x) => Some(x),\n                             _ => None,\n                         }\n                         ))\n            &&\n        itertools::equal(b.clone(),\n                         jt.filter_map(|elt| match elt {\n                             EitherOrBoth::Both(_, y) => Some(y),\n                             EitherOrBoth::Right(y) => Some(y),\n                             _ => None,\n                         }\n                         ))\n    }\n    fn size_interleave(a: Iter<i16>, b: Iter<i16>) -> bool {\n        correct_size_hint(a.interleave(b))\n    }\n    fn exact_interleave(a: Iter<i16, Exact>, b: Iter<i16, Exact>) -> bool {\n        exact_size_for_this(a.interleave(b))\n    }\n    fn size_interleave_shortest(a: Iter<i16>, b: Iter<i16>) -> bool {\n        correct_size_hint(a.interleave_shortest(b))\n    }\n    fn exact_interleave_shortest(a: Vec<()>, b: Vec<()>) -> bool {\n        exact_size_for_this(a.iter().interleave_shortest(&b))\n    }\n    fn size_intersperse(a: Iter<i16>, x: i16) -> bool {\n        correct_size_hint(a.intersperse(x))\n    }\n    fn equal_intersperse(a: Vec<i32>, x: i32) -> bool {\n        let mut inter = false;\n        let mut i = 0;\n        for elt in a.iter().cloned().intersperse(x) {\n            if inter {\n                if elt != x { return false }\n            } else {\n                if elt != a[i] { return false }\n                i += 1;\n            }\n            inter = !inter;\n        }\n        true\n    }\n\n    fn equal_combinations_2(a: Vec<u8>) -> bool {\n        let mut v = Vec::new();\n        for (i, x) in enumerate(&a) {\n            for y in &a[i + 1..] {\n                v.push((x, y));\n            }\n        }\n        itertools::equal(a.iter().tuple_combinations::<(_, _)>(), v)\n    }\n\n    fn collect_tuple_matches_size(a: Iter<i16>) -> bool {\n        let size = a.clone().count();\n        a.collect_tuple::<(_, _, _)>().is_some() == (size == 3)\n    }\n\n    fn correct_permutations(vals: HashSet<i32>, k: usize) -> () {\n        // Test permutations only on iterators of distinct integers, to prevent\n        // false positives.\n\n        const MAX_N: usize = 5;\n\n        let n = min(vals.len(), MAX_N);\n        let vals: HashSet<i32> = vals.into_iter().take(n).collect();\n\n        let perms = vals.iter().permutations(k);\n\n        let mut actual = HashSet::new();\n\n        for perm in perms {\n            assert_eq!(perm.len(), k);\n\n            let all_items_valid = perm.iter().all(|p| vals.contains(p));\n            assert!(all_items_valid, \"perm contains value not from input: {:?}\", perm);\n\n            // Check that all perm items are distinct\n            let distinct_len = {\n                let perm_set: HashSet<_> = perm.iter().collect();\n                perm_set.len()\n            };\n            assert_eq!(perm.len(), distinct_len);\n\n            // Check that the perm is new\n            assert!(actual.insert(perm.clone()), \"perm already encountered: {:?}\", perm);\n        }\n    }\n\n    fn permutations_lexic_order(a: usize, b: usize) -> () {\n        let a = a % 6;\n        let b = b % 6;\n\n        let n = max(a, b);\n        let k = min (a, b);\n\n        let expected_first: Vec<usize> = (0..k).collect();\n        let expected_last: Vec<usize> = ((n - k)..n).rev().collect();\n\n        let mut perms = (0..n).permutations(k);\n\n        let mut curr_perm = match perms.next() {\n            Some(p) => p,\n            None => { return; }\n        };\n\n        assert_eq!(expected_first, curr_perm);\n\n        while let Some(next_perm) = perms.next() {\n            assert!(\n                next_perm > curr_perm,\n                \"next perm isn't greater-than current; next_perm={:?} curr_perm={:?} n={}\",\n                next_perm, curr_perm, n\n            );\n\n            curr_perm = next_perm;\n        }\n\n        assert_eq!(expected_last, curr_perm);\n\n    }\n\n    fn permutations_count(n: usize, k: usize) -> bool {\n        let n = n % 6;\n\n        correct_count(|| (0..n).permutations(k))\n    }\n\n    fn permutations_size(a: Iter<i32>, k: usize) -> bool {\n        correct_size_hint(a.take(5).permutations(k))\n    }\n\n    fn permutations_k0_yields_once(n: usize) -> () {\n        let k = 0;\n        let expected: Vec<Vec<usize>> = vec![vec![]];\n        let actual = (0..n).permutations(k).collect_vec();\n\n        assert_eq!(expected, actual);\n    }\n}\n\nquickcheck! {\n    fn equal_dedup(a: Vec<i32>) -> bool {\n        let mut b = a.clone();\n        b.dedup();\n        itertools::equal(&b, a.iter().dedup())\n    }\n}\n\nquickcheck! {\n    fn equal_dedup_by(a: Vec<(i32, i32)>) -> bool {\n        let mut b = a.clone();\n        b.dedup_by(|x, y| x.0==y.0);\n        itertools::equal(&b, a.iter().dedup_by(|x, y| x.0==y.0))\n    }\n}\n\nquickcheck! {\n    fn size_dedup(a: Vec<i32>) -> bool {\n        correct_size_hint(a.iter().dedup())\n    }\n}\n\nquickcheck! {\n    fn size_dedup_by(a: Vec<(i32, i32)>) -> bool {\n        correct_size_hint(a.iter().dedup_by(|x, y| x.0==y.0))\n    }\n}\n\nquickcheck! {\n    fn exact_repeatn((n, x): (usize, i32)) -> bool {\n        let it = itertools::repeat_n(x, n);\n        exact_size(it)\n    }\n}\n\nquickcheck! {\n    fn size_put_back(a: Vec<u8>, x: Option<u8>) -> bool {\n        let mut it = put_back(a.into_iter());\n        match x {\n            Some(t) => it.put_back(t),\n            None => {}\n        }\n        correct_size_hint(it)\n    }\n}\n\nquickcheck! {\n    fn size_put_backn(a: Vec<u8>, b: Vec<u8>) -> bool {\n        let mut it = put_back_n(a.into_iter());\n        for elt in b {\n            it.put_back(elt)\n        }\n        correct_size_hint(it)\n    }\n}\n\nquickcheck! {\n    fn size_tee(a: Vec<u8>) -> bool {\n        let (mut t1, mut t2) = a.iter().tee();\n        t1.next();\n        t1.next();\n        t2.next();\n        exact_size(t1) && exact_size(t2)\n    }\n}\n\nquickcheck! {\n    fn size_tee_2(a: Vec<u8>) -> bool {\n        let (mut t1, mut t2) = a.iter().dedup().tee();\n        t1.next();\n        t1.next();\n        t2.next();\n        correct_size_hint(t1) && correct_size_hint(t2)\n    }\n}\n\nquickcheck! {\n    fn size_take_while_ref(a: Vec<u8>, stop: u8) -> bool {\n        correct_size_hint(a.iter().take_while_ref(|x| **x != stop))\n    }\n}\n\nquickcheck! {\n    fn equal_partition(a: Vec<i32>) -> bool {\n        let mut a = a;\n        let mut ap = a.clone();\n        let split_index = itertools::partition(&mut ap, |x| *x >= 0);\n        let parted = (0..split_index).all(|i| ap[i] >= 0) &&\n            (split_index..a.len()).all(|i| ap[i] < 0);\n\n        a.sort();\n        ap.sort();\n        parted && (a == ap)\n    }\n}\n\nquickcheck! {\n    fn size_combinations(it: Iter<i16>) -> bool {\n        correct_size_hint(it.tuple_combinations::<(_, _)>())\n    }\n}\n\nquickcheck! {\n    fn equal_combinations(it: Iter<i16>) -> bool {\n        let values = it.clone().collect_vec();\n        let mut cmb = it.tuple_combinations();\n        for i in 0..values.len() {\n            for j in i+1..values.len() {\n                let pair = (values[i], values[j]);\n                if pair != cmb.next().unwrap() {\n                    return false;\n                }\n            }\n        }\n        cmb.next() == None\n    }\n}\n\nquickcheck! {\n    fn size_pad_tail(it: Iter<i8>, pad: u8) -> bool {\n        correct_size_hint(it.clone().pad_using(pad as usize, |_| 0)) &&\n            correct_size_hint(it.dropping(1).rev().pad_using(pad as usize, |_| 0))\n    }\n}\n\nquickcheck! {\n    fn size_pad_tail2(it: Iter<i8, Exact>, pad: u8) -> bool {\n        exact_size(it.pad_using(pad as usize, |_| 0))\n    }\n}\n\nquickcheck! {\n    fn size_unique(it: Iter<i8>) -> bool {\n        correct_size_hint(it.unique())\n    }\n\n    fn count_unique(it: Vec<i8>, take_first: u8) -> () {\n        let answer = {\n            let mut v = it.clone();\n            v.sort(); v.dedup();\n            v.len()\n        };\n        let mut iter = cloned(&it).unique();\n        let first_count = (&mut iter).take(take_first as usize).count();\n        let rest_count = iter.count();\n        assert_eq!(answer, first_count + rest_count);\n    }\n}\n\nquickcheck! {\n    fn fuzz_group_by_lazy_1(it: Iter<u8>) -> bool {\n        let jt = it.clone();\n        let groups = it.group_by(|k| *k);\n        let res = itertools::equal(jt, groups.into_iter().flat_map(|(_, x)| x));\n        res\n    }\n}\n\nquickcheck! {\n    fn fuzz_group_by_lazy_2(data: Vec<u8>) -> bool {\n        let groups = data.iter().group_by(|k| *k / 10);\n        let res = itertools::equal(data.iter(), groups.into_iter().flat_map(|(_, x)| x));\n        res\n    }\n}\n\nquickcheck! {\n    fn fuzz_group_by_lazy_3(data: Vec<u8>) -> bool {\n        let grouper = data.iter().group_by(|k| *k / 10);\n        let groups = grouper.into_iter().collect_vec();\n        let res = itertools::equal(data.iter(), groups.into_iter().flat_map(|(_, x)| x));\n        res\n    }\n}\n\nquickcheck! {\n    fn fuzz_group_by_lazy_duo(data: Vec<u8>, order: Vec<(bool, bool)>) -> bool {\n        let grouper = data.iter().group_by(|k| *k / 3);\n        let mut groups1 = grouper.into_iter();\n        let mut groups2 = grouper.into_iter();\n        let mut elts = Vec::<&u8>::new();\n        let mut old_groups = Vec::new();\n\n        let tup1 = |(_, b)| b;\n        for &(ord, consume_now) in &order {\n            let iter = &mut [&mut groups1, &mut groups2][ord as usize];\n            match iter.next() {\n                Some((_, gr)) => if consume_now {\n                    for og in old_groups.drain(..) {\n                        elts.extend(og);\n                    }\n                    elts.extend(gr);\n                } else {\n                    old_groups.push(gr);\n                },\n                None => break,\n            }\n        }\n        for og in old_groups.drain(..) {\n            elts.extend(og);\n        }\n        for gr in groups1.map(&tup1) { elts.extend(gr); }\n        for gr in groups2.map(&tup1) { elts.extend(gr); }\n        itertools::assert_equal(&data, elts);\n        true\n    }\n}\n\nquickcheck! {\n    fn equal_chunks_lazy(a: Vec<u8>, size: u8) -> bool {\n        let mut size = size;\n        if size == 0 {\n            size += 1;\n        }\n        let chunks = a.iter().chunks(size as usize);\n        let it = a.chunks(size as usize);\n        for (a, b) in chunks.into_iter().zip(it) {\n            if !itertools::equal(a, b) {\n                return false;\n            }\n        }\n        true\n    }\n}\n\nquickcheck! {\n    fn equal_tuple_windows_1(a: Vec<u8>) -> bool {\n        let x = a.windows(1).map(|s| (&s[0], ));\n        let y = a.iter().tuple_windows::<(_,)>();\n        itertools::equal(x, y)\n    }\n\n    fn equal_tuple_windows_2(a: Vec<u8>) -> bool {\n        let x = a.windows(2).map(|s| (&s[0], &s[1]));\n        let y = a.iter().tuple_windows::<(_, _)>();\n        itertools::equal(x, y)\n    }\n\n    fn equal_tuple_windows_3(a: Vec<u8>) -> bool {\n        let x = a.windows(3).map(|s| (&s[0], &s[1], &s[2]));\n        let y = a.iter().tuple_windows::<(_, _, _)>();\n        itertools::equal(x, y)\n    }\n\n    fn equal_tuple_windows_4(a: Vec<u8>) -> bool {\n        let x = a.windows(4).map(|s| (&s[0], &s[1], &s[2], &s[3]));\n        let y = a.iter().tuple_windows::<(_, _, _, _)>();\n        itertools::equal(x, y)\n    }\n\n    fn equal_tuples_1(a: Vec<u8>) -> bool {\n        let x = a.chunks(1).map(|s| (&s[0], ));\n        let y = a.iter().tuples::<(_,)>();\n        itertools::equal(x, y)\n    }\n\n    fn equal_tuples_2(a: Vec<u8>) -> bool {\n        let x = a.chunks(2).filter(|s| s.len() == 2).map(|s| (&s[0], &s[1]));\n        let y = a.iter().tuples::<(_, _)>();\n        itertools::equal(x, y)\n    }\n\n    fn equal_tuples_3(a: Vec<u8>) -> bool {\n        let x = a.chunks(3).filter(|s| s.len() == 3).map(|s| (&s[0], &s[1], &s[2]));\n        let y = a.iter().tuples::<(_, _, _)>();\n        itertools::equal(x, y)\n    }\n\n    fn equal_tuples_4(a: Vec<u8>) -> bool {\n        let x = a.chunks(4).filter(|s| s.len() == 4).map(|s| (&s[0], &s[1], &s[2], &s[3]));\n        let y = a.iter().tuples::<(_, _, _, _)>();\n        itertools::equal(x, y)\n    }\n\n    fn exact_tuple_buffer(a: Vec<u8>) -> bool {\n        let mut iter = a.iter().tuples::<(_, _, _, _)>();\n        (&mut iter).last();\n        let buffer = iter.into_buffer();\n        assert_eq!(buffer.len(), a.len() % 4);\n        exact_size(buffer)\n    }\n}\n\n// with_position\nquickcheck! {\n    fn with_position_exact_size_1(a: Vec<u8>) -> bool {\n        exact_size_for_this(a.iter().with_position())\n    }\n    fn with_position_exact_size_2(a: Iter<u8, Exact>) -> bool {\n        exact_size_for_this(a.with_position())\n    }\n}\n\nquickcheck! {\n    fn correct_group_map_modulo_key(a: Vec<u8>, modulo: u8) -> () {\n        let modulo = if modulo == 0 { 1 } else { modulo }; // Avoid `% 0`\n        let count = a.len();\n        let lookup = a.into_iter().map(|i| (i % modulo, i)).into_group_map();\n\n        assert_eq!(lookup.values().flat_map(|vals| vals.iter()).count(), count);\n\n        for (&key, vals) in lookup.iter() {\n            assert!(vals.iter().all(|&val| val % modulo == key));\n        }\n    }\n}\n\n/// A peculiar type: Equality compares both tuple items, but ordering only the\n/// first item.  This is so we can check the stability property easily.\n#[derive(Clone, Debug, PartialEq, Eq)]\nstruct Val(u32, u32);\n\nimpl PartialOrd<Val> for Val {\n    fn partial_cmp(&self, other: &Val) -> Option<Ordering> {\n        self.0.partial_cmp(&other.0)\n    }\n}\n\nimpl Ord for Val {\n    fn cmp(&self, other: &Val) -> Ordering {\n        self.0.cmp(&other.0)\n    }\n}\n\nimpl qc::Arbitrary for Val {\n    fn arbitrary<G: qc::Gen>(g: &mut G) -> Self {\n        let (x, y) = <(u32, u32)>::arbitrary(g);\n        Val(x, y)\n    }\n    fn shrink(&self) -> Box<dyn Iterator<Item = Self>> {\n        Box::new((self.0, self.1).shrink().map(|(x, y)| Val(x, y)))\n    }\n}\n\nquickcheck! {\n    fn minmax(a: Vec<Val>) -> bool {\n        use itertools::MinMaxResult;\n\n\n        let minmax = a.iter().minmax();\n        let expected = match a.len() {\n            0 => MinMaxResult::NoElements,\n            1 => MinMaxResult::OneElement(&a[0]),\n            _ => MinMaxResult::MinMax(a.iter().min().unwrap(),\n                                      a.iter().max().unwrap()),\n        };\n        minmax == expected\n    }\n}\n\nquickcheck! {\n    fn minmax_f64(a: Vec<f64>) -> TestResult {\n        use itertools::MinMaxResult;\n\n        if a.iter().any(|x| x.is_nan()) {\n            return TestResult::discard();\n        }\n\n        let min = cloned(&a).fold1(f64::min);\n        let max = cloned(&a).fold1(f64::max);\n\n        let minmax = cloned(&a).minmax();\n        let expected = match a.len() {\n            0 => MinMaxResult::NoElements,\n            1 => MinMaxResult::OneElement(min.unwrap()),\n            _ => MinMaxResult::MinMax(min.unwrap(), max.unwrap()),\n        };\n        TestResult::from_bool(minmax == expected)\n    }\n}\n\nquickcheck! {\n    #[allow(deprecated)]\n    fn tree_fold1_f64(mut a: Vec<f64>) -> TestResult {\n        fn collapse_adjacent<F>(x: Vec<f64>, mut f: F) -> Vec<f64>\n            where F: FnMut(f64, f64) -> f64\n        {\n            let mut out = Vec::new();\n            for i in (0..x.len()).step(2) {\n                if i == x.len()-1 {\n                    out.push(x[i])\n                } else {\n                    out.push(f(x[i], x[i+1]));\n                }\n            }\n            out\n        }\n\n        if a.iter().any(|x| x.is_nan()) {\n            return TestResult::discard();\n        }\n\n        let actual = a.iter().cloned().tree_fold1(f64::atan2);\n\n        while a.len() > 1 {\n            a = collapse_adjacent(a, f64::atan2);\n        }\n        let expected = a.pop();\n\n        TestResult::from_bool(actual == expected)\n    }\n}\n\nquickcheck! {\n    fn exactly_one_i32(a: Vec<i32>) -> TestResult {\n        let ret = a.iter().cloned().exactly_one();\n        match a.len() {\n            1 => TestResult::from_bool(ret.unwrap() == a[0]),\n            _ => TestResult::from_bool(ret.unwrap_err().eq(a.iter().cloned())),\n        }\n    }\n}\n","traces":[{"line":1,"address":[5324373],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":136,"address":[5252982,5252464,5251744,5252740,5252944,5252260,5251780,5253184,5253220,5252224,5251984,5253446,5252022,5252704,5253408,5253648,5253684,5252502],"length":1,"stats":{"Line":9},"fn_name":"next<i8,quick::Inexact>"},{"line":138,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":149,"address":[5254656,5254432,5254320,5254208,5254096,5254544,5253872,5253984],"length":1,"stats":{"Line":8},"fn_name":"size_hint<i16,quick::Inexact>"},{"line":151,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":161,"address":[5254768,5254777],"length":1,"stats":{"Line":2},"fn_name":"next_back<i8,quick::Inexact>"},{"line":172,"address":[5255248,5255472,5256128,5254862,5256336,5255742,5255040,5255518,5255920,5256560,5256383,5255071,5255696,5255295,5254832,5255951,5256606,5256158],"length":1,"stats":{"Line":9},"fn_name":"arbitrary<u8,quick::Exact,quickcheck::arbitrary::StdThreadGen>"},{"line":174,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":177,"address":[5257120,5257175,5259008,5258096,5258704,5259065,5257456,5259401,5257815,5257760,5259344,5256839,5258457,5257511,5258759,5258400,5258153,5256784],"length":1,"stats":{"Line":0},"fn_name":"shrink<i8,quick::Inexact>"},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[5263718,5263632],"length":1,"stats":{"Line":1},"fn_name":"correct_count<itertools::permutations::Permutations<core::ops::range::Range<usize>>,closure-0>"},{"line":254,"address":[5263741,5263758,5265439,5263655],"length":1,"stats":{"Line":3},"fn_name":null},{"line":256,"address":[5264554],"length":1,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[5263833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[5263848,5264110,5265604,5264261],"length":1,"stats":{"Line":2},"fn_name":null},{"line":260,"address":[5264160],"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[5264210],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[5264270,5264100],"length":1,"stats":{"Line":2},"fn_name":null},{"line":269,"address":[5264382],"length":1,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[5264564,5264355,5265656],"length":1,"stats":{"Line":2},"fn_name":null},{"line":274,"address":[5264983,5264821,5264600,5264786],"length":1,"stats":{"Line":3},"fn_name":null},{"line":275,"address":[5264919,5265706,5265736],"length":1,"stats":{"Line":1},"fn_name":null},{"line":276,"address":[5264965],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[5264996],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[5265368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[5265421],"length":1,"stats":{"Line":1},"fn_name":null},{"line":286,"address":[5290089,5281113,5277248,5286240,5270832,5272137,5291384,5296464,5291344,5292633,5295200,5285017,5269536,5277289,5282336,5275952,5279849,5267024,5279808,5283705,5287577,5296508,5273395,5282377,5265785,5274656,5274697,5272096,5278585,5293929,5275993,5286275,5293888,5267065,5270873,5278544,5288784,5265744,5283664,5273360,5269577,5268272,5281072,5284976,5288825,5292592,5287536,5290048,5295241,5268313],"length":1,"stats":{"Line":25},"fn_name":"correct_size_hint<itertools::adaptors::Product<quick::Iter<u16, quick::Inexact>, quick::Iter<u16, quick::Inexact>>>"},{"line":288,"address":[5274679,5286260,5279831,5282359,5270855,5290071,5292615,5296501,5291377,5295223,5278567,5267047,5273380,5287559,5288807,5293911,5272119,5269559,5268295,5281095,5277271,5275975,5283687,5284999,5265767],"length":1,"stats":{"Line":25},"fn_name":null},{"line":289,"address":[5288888,5279693,5274541,5283720,5267080,5275845,5279912,5292709,5297631,5295304,5287592,5269423,5265800,5289935,5295256,5271983,5273410,5284859,5285080,5296523,5273247,5282453,5288678,5274712,5270726,5277142,5282392,5270888,5268328,5280958,5291236,5293781,5296581,5281128,5293992,5272152,5292648,5269653,5268166,5276008,5268376,5281176,5267128,5290165,5277365,5293944,5282222,5265848,5278600,5286348,5276069,5278437,5287640,5269592,5279864,5283768,5286290,5266920,5292477,5295083,5287421,5288840,5278648,5283551,5286125,5272200,5274773,5291399,5296349,5273468,5277304,5270936,5290104,5291447,5285032],"length":1,"stats":{"Line":50},"fn_name":null},{"line":290,"address":[5279919,5296588,5285087,5278655,5269660,5273475,5272207,5282460,5283775,5265855,5267135,5274780,5290172,5288895,5270943,5276076,5281183,5292716,5293999,5287647,5291454,5295311,5277372,5268383,5286355],"length":1,"stats":{"Line":25},"fn_name":null},{"line":291,"address":[5292902,5269740,5272421,5279974,5291531,5292929,5294257,5295366,5295391,5268438,5280105,5281369,5291629,5292796,5290252,5273653,5267316,5273706,5294230,5274835,5287828,5294054,5267190,5291509,5295496,5278867,5287727,5265910,5290357,5285167,5274860,5269874,5272394,5282672,5271157,5289109,5272262,5273560,5295523,5296787,5296763,5271023,5278840,5280132,5268463,5283855,5285142,5276156,5272287,5273530,5271130,5277558,5290384,5279999,5270998,5281238,5282699,5267215,5277452,5285272,5269715,5284006,5288950,5268570,5284033,5291653,5294079,5296643,5296665,5276290,5268597,5282515,5282540,5287852,5287702,5290227,5276131,5274966,5267340,5277585,5266094,5266067,5274993,5277427,5283830,5286440,5265935,5269847,5276263,5278710,5285299,5288975,5286533,5289082,5281396,5286586,5292771,5281263,5286410,5278735],"length":1,"stats":{"Line":75},"fn_name":null},{"line":292,"address":[5282642,5283976,5291599,5285242,5289052,5272364,5276233,5274936,5281339,5267286,5277528,5278810,5286503,5269817,5292872,5266037,5271100,5287798,5290327,5294200,5296733,5268540,5273623,5295466,5280075],"length":1,"stats":{"Line":25},"fn_name":null},{"line":295,"address":[5292939,5286596,5294267,5285287,5267350,5282687,5295533,5281406,5296775,5284021,5275003,5276300,5290372,5292917,5294245,5269862,5268585,5284043,5285309,5280120,5287862,5290394,5291641,5276278,5273694,5269884,5271145,5273716,5272431,5280142,5267328,5281384,5289097,5291663,5289119,5266104,5268607,5266082,5287840,5286574,5277573,5278877,5278855,5277595,5272409,5271167,5274981,5282709,5295511,5296797],"length":1,"stats":{"Line":50},"fn_name":null},{"line":298,"address":[5275146,5290826,5269900,5277738,5286736,5276732,5266120,5286612,5273732,5270027,5290537,5292095,5297229,5276443,5279020,5280158,5281549,5282852,5289551,5267493,5291806,5282725,5280285,5268623,5273856,5276316,5285741,5290410,5288005,5271310,5271599,5293371,5281422,5267782,5284186,5294699,5272447,5288294,5272574,5275435,5268750,5267366,5274145,5283141,5285325,5287025,5287878,5272863,5279309,5281838,5284059,5285452,5295549,5295965,5294283,5293082,5292955,5284475,5275019,5289262,5289135,5270316,5278027,5294410,5296940,5271183,5291679,5277611,5280574,5296813,5269039,5266536,5278893,5295676,5266247],"length":1,"stats":{"Line":50},"fn_name":null},{"line":299,"address":[5272035,5288090,5274593,5289987,5270112,5270778,5276528,5292529,5273941,5282274,5293833,5272659,5277823,5295135,5268835,5266972,5266332,5273299,5286821,5279745,5278489,5282937,5267578,5268218,5289347,5291288,5294495,5295761,5288730,5284911,5287473,5290622,5291891,5285537,5293167,5296401,5275231,5279105,5271395,5281010,5284271,5283603,5297683,5269475,5281634,5275897,5277194,5280370,5297025,5286177],"length":1,"stats":{"Line":25},"fn_name":null},{"line":300,"address":[5272703,5275336,5279210,5280414,5266437,5267743,5276693,5286926,5288134,5271500,5272764,5291996,5294600,5289391,5266497,5281678,5286986,5273985,5297130,5277928,5285702,5280535,5290727,5268940,5292056,5269000,5270217,5268879,5276633,5275275,5270156,5277988,5291935,5283042,5288255,5289452,5293272,5297069,5275396,5289512,5290666,5272824,5282981,5266376,5284315,5267622,5281799,5288195,5294660,5284436,5283102,5274106,5279149,5271439,5276572,5294539,5297190,5277867,5295866,5274046,5280475,5293211,5267683,5285642,5293332,5285581,5271560,5270277,5279270,5284376,5286865,5290787,5295926,5295805,5281739],"length":1,"stats":{"Line":75},"fn_name":null},{"line":301,"address":[5290704,5270194,5284353,5272840,5274122,5290739,5268952,5285718,5294577,5276610,5293284,5284452,5288207,5285619,5294676,5297142,5281751,5279286,5288172,5279187,5293348,5283019,5289464,5267660,5294612,5271477,5295878,5266414,5266449,5275412,5289528,5287002,5272776,5275313,5279222,5295843,5274023,5276645,5268917,5270293,5284388,5276709,5280487,5281716,5272741,5293249,5277905,5295942,5297206,5274058,5271576,5286903,5291973,5269016,5281815,5286938,5270229,5267695,5271512,5288271,5292008,5283054,5297107,5289429,5278004,5266513,5280551,5280452,5285654,5283118,5290803,5267759,5275348,5292072,5277940],"length":1,"stats":{"Line":50},"fn_name":null},{"line":303,"address":[5278032,5272868,5285746,5271604,5287030,5283146,5294704,5297234,5284480,5279314,5266541,5289556,5275440,5290831,5292100,5295970,5288299,5267787,5293376,5281843,5276737,5269044,5274150,5270321,5280579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[5279626,5288611,5282155,5274460,5266853,5268099,5277049,5293688,5291143,5292410,5275752,5269356,5278344,5280891,5284792,5286058,5289868,5296282,5273180,5270633,5283458,5287340,5271916,5297544,5295016],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[5272548,5276417,5287979,5293056,5278994,5267467,5281523,5285426,5280259,5296914,5266221,5268724,5270001,5291780,5295650,5277712,5271284,5273833,5294384,5275120,5282826,5284160,5286713,5289236,5290511],"length":1,"stats":{"Line":25},"fn_name":null},{"line":311,"address":[5297776,5302710,5299888,5297744,5301984,5299168,5304160,5303440,5298480,5301296,5301328,5300608,5299200,5298512,5303408,5300576,5302016,5302672,5304128,5299856],"length":1,"stats":{"Line":10},"fn_name":"exact_size<itertools::zip_longest::ZipLongest<quick::Iter<i16, quick::Exact>, quick::Iter<i16, quick::Exact>>>"},{"line":313,"address":[5304145,5298497,5297791,5299215,5299185,5299903,5300623,5304175,5302725,5301313,5302031,5303425,5303455,5297761,5298527,5300593,5301343,5302703,5299873,5302001],"length":1,"stats":{"Line":20},"fn_name":null},{"line":314,"address":[5298603,5299291,5297867,5304259,5297821,5297875,5300709,5304205,5300653,5302107,5300717,5299933,5302115,5304251,5303541,5301427,5302819,5299989,5303549,5299997,5302811,5301373,5302061,5298557,5303485,5299299,5298611,5302755,5301419,5299245],"length":1,"stats":{"Line":20},"fn_name":null},{"line":315,"address":[5304451,5302113,5304578,5302146,5300038,5297906,5300309,5300928,5298609,5303907,5300715,5303030,5302427,5304290,5303590,5298230,5300758,5298970,5298247,5302444,5303160,5299646,5299490,5304561,5298117,5301058,5300326,5300199,5303143,5298642,5298924,5304607,5299600,5301626,5297873,5303547,5301739,5299995,5299297,5301785,5301087,5303189,5302817,5301756,5298276,5304257,5301041,5298941,5302860,5300355,5303751,5303861,5301425,5299617,5299330,5302473,5298811,5301458,5302314,5303878],"length":1,"stats":{"Line":40},"fn_name":null},{"line":316,"address":[5300106,5299397,5304358,5300829,5302215,5303658,5298712,5301527,5298018,5302931],"length":1,"stats":{"Line":10},"fn_name":null},{"line":317,"address":[5301950,5304563,5298926,5300884,5302638,5299449,5302986,5298232,5303364,5300530,5299811,5303045,5299505,5300943,5303138,5302270,5299595,5300311,5302329,5301641,5303710,5303863,5304082,5304556,5298767,5298225,5303766,5304772,5300304,5298441,5298919,5301582,5299135,5303145,5303856,5298132,5301734,5301741,5304410,5300214,5304466,5301043,5299602,5298073,5301036,5298826,5302429,5300158,5301262,5302422],"length":1,"stats":{"Line":20},"fn_name":null},{"line":318,"address":[5300219,5302334,5299510,5300948,5298137,5301646,5303050,5303771,5298831,5304471],"length":1,"stats":{"Line":10},"fn_name":null},{"line":319,"address":[5300961,5301659,5300229,5299520,5298844,5303063,5303781,5298150,5302347,5304481],"length":1,"stats":{"Line":10},"fn_name":null},{"line":320,"address":[5298870,5298241,5300328,5303089,5304507,5298943,5301758,5300320,5303872,5304572,5302373,5303880,5303807,5303162,5299546,5299611,5298176,5300255,5301060,5302438,5301750,5303154,5302446,5298935,5299619,5301685,5301052,5304580,5300987,5298249],"length":1,"stats":{"Line":20},"fn_name":null},{"line":322,"address":[5301080,5302466,5303194,5300348,5298281,5298975,5302478,5301778,5300360,5301092,5303182,5299651,5301790,5298269,5299639,5303912,5304612,5304600,5303900,5298963],"length":1,"stats":{"Line":20},"fn_name":null},{"line":323,"address":[5301140,5301838,5303318,5299089,5303960,5304660,5302526,5300484,5299023,5303242,5302592,5301904,5304726,5299765,5300408,5301216,5304036,5298329,5299699,5298395],"length":1,"stats":{"Line":20},"fn_name":null},{"line":327,"address":[5306928,5305552,5306960,5304848,5306240,5306272,5304816,5305520],"length":1,"stats":{"Line":4},"fn_name":"exact_size_for_this<itertools::with_position::WithPosition<quick::Iter<u8, quick::Exact>>>"},{"line":329,"address":[5305537,5305567,5306945,5306257,5304863,5306975,5304833,5306287],"length":1,"stats":{"Line":8},"fn_name":null},{"line":330,"address":[5304947,5305597,5305654,5306371,5304939,5306363,5307005,5307051,5305646,5307059,5304893,5306317],"length":1,"stats":{"Line":8},"fn_name":null},{"line":331,"address":[5307251,5307378,5306572,5304978,5305311,5305685,5306369,5306702,5307361,5305883,5305155,5305996,5306013,5306042,5305282,5305265,5307057,5307407,5306402,5306731,5306685,5304945,5305652,5307090],"length":1,"stats":{"Line":16},"fn_name":null},{"line":332,"address":[5305062,5306473,5307158,5305784],"length":1,"stats":{"Line":4},"fn_name":null},{"line":333,"address":[5305898,5306587,5305267,5305839,5305476,5306680,5305114,5306528,5305998,5305991,5306687,5306896,5305260,5305170,5306207,5307356,5307266,5307363,5307572,5307210],"length":1,"stats":{"Line":8},"fn_name":null},{"line":334,"address":[5307271,5305903,5305175,5306592],"length":1,"stats":{"Line":4},"fn_name":null},{"line":335,"address":[5307281,5305916,5305185,5306605],"length":1,"stats":{"Line":4},"fn_name":null},{"line":336,"address":[5305284,5307380,5306007,5307372,5306704,5306015,5305276,5307307,5306631,5305211,5305942,5306696],"length":1,"stats":{"Line":8},"fn_name":null},{"line":338,"address":[5307412,5306736,5306035,5305304,5307400,5306724,5305316,5306047],"length":1,"stats":{"Line":8},"fn_name":null},{"line":339,"address":[5306784,5305364,5305430,5306095,5307526,5307460,5306161,5306850],"length":1,"stats":{"Line":8},"fn_name":null},{"line":369,"address":[5315968,5316704,5317429,5318597,5321749,5315205,5315877,5316096,5318069,5316640,5314656,5319877,5318000,5315365,5316896,5317040,5316517,5318277,5317845,5321216,5321637,5315717,5321669,5316608,5317013,5316613,5321632,5314224,5316672,5317637,5315328,5317909,5315392,5318005,5316736,5315397,5318101,5316128,5318128,5318592,5319136,5319872,5316544,5316768,5321221,5319456,5321664,5320293,5321253,5322704,5316709,5316512,5318272,5318784,5317296,5317493,5315712,5318752,5316581,5317461,5318912,5320288,5315296,5315301,5315744,5317488,5317269,5317301,5318133,5317072,5321248,5314661,5315232,5317104,5321184,5315781,5321744,5315749,5318064,5316741,5317872,5320000,5317557,5318757,5316069,5319141,5315333,5313717,5316549,5317552,5317077,5314229,5317397,5318096,5321157,5314192,5316677,5316864,5317525,5314688,5317840,5321189,5317877,5313685,5316133,5317632,5314949,5315360,5315237,5315776,5316869,5321152,5316160,5315264,5313744,5315200,5318917,5317109,5314197,5315269,5322709,5316576,5317456,5313749,5316165,5317424,5313712,5316901,5317904,5316101,5317392,5318789,5313680,5316064,5317045,5314944,5318432,5320005,5320672,5315973,5317520,5314693,5318437,5319461,5317008,5316773,5317264,5320677,5315872,5316645],"length":1,"stats":{"Line":225},"fn_name":"{{closure}}"},{"line":370,"address":[5803212,5772560,5803916,5773200,5780624,5771046,5777872,5791041,5790496,5805360,5796512,5795392,5766128,5792720,5804604,5791616,5804912,5772704,5809925,5797776,5802876,5788899,5777197,5804972,5771462,5808432,5779376,5766536,5806576,5792755,5795184,5803504,5767744,5781088,5806256,5775552,5785877,5785760,5788624,5778608,5808509,5802480,5806528,5792160,5780496,5777933,5779920,5781763,5788512,5773456,5782934,5790320,5806286,5770240,5809008,5790346,5790696,5767984,5776333,5803564,5789917,5778928,5770544,5775613,5782864,5789661,5778961,5776272,5774032,5806432,5796816,5793632,5777136,5801450,5803152,5771392,5804192,5797216,5771792,5791696,5801408,5809808,5797288,5802540,5769888,5793536,5774132,5810673,5809115,5780752,5782688,5802816,5790624,5796880,5770976,5804544,5788784,5810576,5780352,5773240,5781135,5790144,5792944,5796544,5766480,5794896,5771844,5795449,5797914,5789632,5781728,5789888,5803856,5793008,5780783,5790170,5792240,5790944,5795296,5770581,5767856,5765984,5793673,5805280,5780976,5804252],"length":1,"stats":{"Line":75},"fn_name":"prop"},{"line":373,"address":[5792145,5777857,5806513,5779361,5801393,5808993,5794881,5790481,5803137,5789617,5770225,5795281,5780737,5780337,5793521,5790929,5806417,5771777,5776257,5789873,5777121,5788609,5770529,5778593,5790305,5780961,5772545,5791601,5765969,5802465,5804529,5766465,5788497,5810561,5774017,5790129,5770961,5793617,5771377,5773441,5775537,5803841,5778913,5782673,5769873,5790609,5792929,5785745,5767729,5766113,5792705,5781713,5796801,5782849,5797761,5788769,5806241,5802801,5803489,5797201,5780609,5773185,5772689,5795169,5804897,5780481,5767841,5809793,5805265,5804177,5796497,5779905,5795377,5808417,5781073],"length":1,"stats":{"Line":75},"fn_name":null},{"line":392,"address":[5765991],"length":1,"stats":{"Line":1},"fn_name":null},{"line":395,"address":[5766135],"length":1,"stats":{"Line":1},"fn_name":null},{"line":403,"address":[5766495],"length":1,"stats":{"Line":1},"fn_name":null},{"line":404,"address":[5766551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":405,"address":[5766585],"length":1,"stats":{"Line":1},"fn_name":null},{"line":406,"address":[5313873,5313985,5313789,5313856,5313776,5313968],"length":1,"stats":{"Line":7},"fn_name":"{{closure}}"},{"line":407,"address":[5766762,5766901],"length":1,"stats":{"Line":2},"fn_name":null},{"line":408,"address":[5767044],"length":1,"stats":{"Line":1},"fn_name":null},{"line":410,"address":[5767051],"length":1,"stats":{"Line":1},"fn_name":null},{"line":411,"address":[5767241,5767135],"length":1,"stats":{"Line":2},"fn_name":null},{"line":412,"address":[5314121,5314080],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":414,"address":[5767251,5767362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":418,"address":[5767748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":422,"address":[5767871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":426,"address":[5767961],"length":1,"stats":{"Line":1},"fn_name":null},{"line":427,"address":[5767999],"length":1,"stats":{"Line":1},"fn_name":null},{"line":428,"address":[5768041],"length":1,"stats":{"Line":1},"fn_name":null},{"line":429,"address":[5768099],"length":1,"stats":{"Line":1},"fn_name":null},{"line":430,"address":[5314368,5314256,5314384,5314480,5314496,5314272],"length":1,"stats":{"Line":7},"fn_name":"{{closure}}"},{"line":431,"address":[5768335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":432,"address":[5768381],"length":1,"stats":{"Line":1},"fn_name":null},{"line":434,"address":[5768388],"length":1,"stats":{"Line":1},"fn_name":null},{"line":435,"address":[5768590,5768484],"length":1,"stats":{"Line":2},"fn_name":null},{"line":436,"address":[5314592,5314600],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":438,"address":[5768600,5768759],"length":1,"stats":{"Line":1},"fn_name":null},{"line":440,"address":[5768693,5769077],"length":1,"stats":{"Line":2},"fn_name":null},{"line":445,"address":[5769915],"length":1,"stats":{"Line":1},"fn_name":null},{"line":446,"address":[5769925],"length":1,"stats":{"Line":1},"fn_name":null},{"line":447,"address":[5769933,5770210,5770180],"length":1,"stats":{"Line":1},"fn_name":null},{"line":449,"address":[5769971],"length":1,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[5770129,5770017,5770174],"length":1,"stats":{"Line":3},"fn_name":null},{"line":451,"address":[5770071,5770153],"length":1,"stats":{"Line":2},"fn_name":null},{"line":456,"address":[5770252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":457,"address":[5770262],"length":1,"stats":{"Line":1},"fn_name":null},{"line":458,"address":[5770493,5770523,5770275],"length":1,"stats":{"Line":1},"fn_name":null},{"line":460,"address":[5770313],"length":1,"stats":{"Line":1},"fn_name":null},{"line":461,"address":[5314720],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":462,"address":[5314877,5314734],"length":1,"stats":{"Line":1},"fn_name":null},{"line":463,"address":[5314907,5314813,5314937],"length":1,"stats":{"Line":1},"fn_name":null},{"line":464,"address":[5314862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":470,"address":[5770556],"length":1,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[5770566,5770634],"length":1,"stats":{"Line":2},"fn_name":null},{"line":472,"address":[5770596,5770908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":474,"address":[5770648],"length":1,"stats":{"Line":1},"fn_name":null},{"line":475,"address":[5314976],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":476,"address":[5314990,5315133],"length":1,"stats":{"Line":1},"fn_name":null},{"line":477,"address":[5315163,5315069,5315193],"length":1,"stats":{"Line":1},"fn_name":null},{"line":478,"address":[5315118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":483,"address":[5771003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":485,"address":[5771277,5771061,5771247],"length":1,"stats":{"Line":2},"fn_name":null},{"line":486,"address":[5771270],"length":1,"stats":{"Line":1},"fn_name":null},{"line":488,"address":[5771168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":492,"address":[5771419],"length":1,"stats":{"Line":1},"fn_name":null},{"line":494,"address":[5771477,5771689,5771644],"length":1,"stats":{"Line":2},"fn_name":null},{"line":495,"address":[5771670],"length":1,"stats":{"Line":1},"fn_name":null},{"line":497,"address":[5771584],"length":1,"stats":{"Line":1},"fn_name":null},{"line":501,"address":[5771815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":502,"address":[5771875],"length":1,"stats":{"Line":1},"fn_name":null},{"line":503,"address":[5771972,5771912],"length":1,"stats":{"Line":2},"fn_name":null},{"line":504,"address":[5771994],"length":1,"stats":{"Line":1},"fn_name":null},{"line":505,"address":[5772056],"length":1,"stats":{"Line":1},"fn_name":null},{"line":506,"address":[5772071,5772147],"length":1,"stats":{"Line":2},"fn_name":null},{"line":507,"address":[5772189],"length":1,"stats":{"Line":1},"fn_name":null},{"line":508,"address":[5772243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":511,"address":[5772567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":514,"address":[5772756],"length":1,"stats":{"Line":1},"fn_name":null},{"line":515,"address":[5772802,5773169,5773182,5773009],"length":1,"stats":{"Line":3},"fn_name":null},{"line":516,"address":[5773148,5772879],"length":1,"stats":{"Line":2},"fn_name":null},{"line":519,"address":[5773207,5773255],"length":1,"stats":{"Line":2},"fn_name":null},{"line":520,"address":[5773275],"length":1,"stats":{"Line":1},"fn_name":null},{"line":524,"address":[5773508],"length":1,"stats":{"Line":1},"fn_name":null},{"line":525,"address":[5315465],"length":1,"stats":{"Line":4},"fn_name":null},{"line":526,"address":[5315609],"length":1,"stats":{"Line":3},"fn_name":null},{"line":530,"address":[5774147,5774039],"length":1,"stats":{"Line":2},"fn_name":null},{"line":531,"address":[5774171,5774223],"length":1,"stats":{"Line":2},"fn_name":null},{"line":532,"address":[5774247],"length":1,"stats":{"Line":1},"fn_name":null},{"line":533,"address":[5774262],"length":1,"stats":{"Line":1},"fn_name":null},{"line":534,"address":[5774320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":535,"address":[5774378],"length":1,"stats":{"Line":1},"fn_name":null},{"line":536,"address":[5774446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":537,"address":[5774469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":538,"address":[5774577],"length":1,"stats":{"Line":1},"fn_name":null},{"line":539,"address":[5774677],"length":1,"stats":{"Line":1},"fn_name":null},{"line":540,"address":[5774723,5775350],"length":1,"stats":{"Line":1},"fn_name":null},{"line":547,"address":[5775800,5775633,5775719,5775559],"length":1,"stats":{"Line":3},"fn_name":null},{"line":548,"address":[5775754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":550,"address":[5775823,5775702],"length":1,"stats":{"Line":2},"fn_name":null},{"line":551,"address":[5775838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":552,"address":[5776159,5775884],"length":1,"stats":{"Line":1},"fn_name":null},{"line":558,"address":[5776451,5776353,5776593,5776279],"length":1,"stats":{"Line":3},"fn_name":null},{"line":559,"address":[5776501],"length":1,"stats":{"Line":1},"fn_name":null},{"line":560,"address":[5776547],"length":1,"stats":{"Line":1},"fn_name":null},{"line":562,"address":[5776431,5776616],"length":1,"stats":{"Line":2},"fn_name":null},{"line":563,"address":[5776631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":564,"address":[5776677],"length":1,"stats":{"Line":1},"fn_name":null},{"line":565,"address":[5776723,5776880],"length":1,"stats":{"Line":2},"fn_name":null},{"line":566,"address":[5315808,5315827],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":572,"address":[5777217,5777384,5777143,5777303],"length":1,"stats":{"Line":3},"fn_name":null},{"line":573,"address":[5777338],"length":1,"stats":{"Line":1},"fn_name":null},{"line":575,"address":[5777286,5777407],"length":1,"stats":{"Line":2},"fn_name":null},{"line":576,"address":[5777422],"length":1,"stats":{"Line":1},"fn_name":null},{"line":577,"address":[5777468,5777625],"length":1,"stats":{"Line":2},"fn_name":null},{"line":578,"address":[5315904,5315923],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":584,"address":[5778039,5777879,5777953,5778120],"length":1,"stats":{"Line":3},"fn_name":null},{"line":585,"address":[5778074],"length":1,"stats":{"Line":1},"fn_name":null},{"line":587,"address":[5778143,5778022],"length":1,"stats":{"Line":2},"fn_name":null},{"line":588,"address":[5778158],"length":1,"stats":{"Line":1},"fn_name":null},{"line":589,"address":[5778204,5778361],"length":1,"stats":{"Line":2},"fn_name":null},{"line":590,"address":[5316000,5316019],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":594,"address":[5778615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":597,"address":[5778935,5778976,5779021],"length":1,"stats":{"Line":3},"fn_name":null},{"line":598,"address":[5779057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":599,"address":[5779114],"length":1,"stats":{"Line":1},"fn_name":null},{"line":600,"address":[5779177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":603,"address":[5779413],"length":1,"stats":{"Line":1},"fn_name":null},{"line":604,"address":[5779459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":605,"address":[5779659,5779505,5779849,5779883,5779896,5779709],"length":1,"stats":{"Line":5},"fn_name":null},{"line":606,"address":[5779673,5779775],"length":1,"stats":{"Line":2},"fn_name":null},{"line":607,"address":[5779582,5779862],"length":1,"stats":{"Line":2},"fn_name":null},{"line":610,"address":[5779927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":611,"address":[5779999],"length":1,"stats":{"Line":1},"fn_name":null},{"line":612,"address":[5780315,5780190,5780064,5780328],"length":1,"stats":{"Line":3},"fn_name":null},{"line":613,"address":[5316300,5316192,5316271],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":614,"address":[5316273,5316234],"length":1,"stats":{"Line":2},"fn_name":null},{"line":615,"address":[5316302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":616,"address":[5316264],"length":1,"stats":{"Line":1},"fn_name":null},{"line":620,"address":[5780286,5780098],"length":1,"stats":{"Line":2},"fn_name":null},{"line":621,"address":[5316352,5316431,5316460],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":622,"address":[5316394,5316433],"length":1,"stats":{"Line":2},"fn_name":null},{"line":623,"address":[5316462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":624,"address":[5316424],"length":1,"stats":{"Line":1},"fn_name":null},{"line":629,"address":[5780359],"length":1,"stats":{"Line":1},"fn_name":null},{"line":632,"address":[5780530],"length":1,"stats":{"Line":1},"fn_name":null},{"line":635,"address":[5780628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":638,"address":[5780866,5780766,5780805],"length":1,"stats":{"Line":3},"fn_name":null},{"line":641,"address":[5780985],"length":1,"stats":{"Line":1},"fn_name":null},{"line":644,"address":[5781099],"length":1,"stats":{"Line":1},"fn_name":null},{"line":645,"address":[5781104],"length":1,"stats":{"Line":1},"fn_name":null},{"line":646,"address":[5781118,5781203,5781613,5781397,5781150,5781343],"length":1,"stats":{"Line":5},"fn_name":null},{"line":647,"address":[5781494,5781441],"length":1,"stats":{"Line":2},"fn_name":null},{"line":648,"address":[5781481,5781496],"length":1,"stats":{"Line":1},"fn_name":null},{"line":650,"address":[5781448,5781585,5781556],"length":1,"stats":{"Line":2},"fn_name":null},{"line":651,"address":[5781678,5781560,5781596],"length":1,"stats":{"Line":2},"fn_name":null},{"line":653,"address":[5781601],"length":1,"stats":{"Line":1},"fn_name":null},{"line":655,"address":[5781618],"length":1,"stats":{"Line":1},"fn_name":null},{"line":659,"address":[5781735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":660,"address":[5781996,5781778,5782287,5781834],"length":1,"stats":{"Line":3},"fn_name":null},{"line":661,"address":[5782094,5782292,5782637,5782402],"length":1,"stats":{"Line":2},"fn_name":null},{"line":662,"address":[5782342],"length":1,"stats":{"Line":1},"fn_name":null},{"line":665,"address":[5781967,5782407],"length":1,"stats":{"Line":2},"fn_name":null},{"line":669,"address":[5782692],"length":1,"stats":{"Line":1},"fn_name":null},{"line":670,"address":[5782735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":679,"address":[5782949,5782879],"length":1,"stats":{"Line":2},"fn_name":null},{"line":680,"address":[5782997],"length":1,"stats":{"Line":1},"fn_name":null},{"line":682,"address":[5783153,5783209],"length":1,"stats":{"Line":2},"fn_name":null},{"line":684,"address":[5783225],"length":1,"stats":{"Line":1},"fn_name":null},{"line":686,"address":[5783232,5783402,5785520,5783380,5785346,5785594],"length":1,"stats":{"Line":5},"fn_name":null},{"line":687,"address":[5783670,5783832,5785568],"length":1,"stats":{"Line":2},"fn_name":null},{"line":689,"address":[5316814,5316800],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":690,"address":[5784366,5784311],"length":1,"stats":{"Line":1},"fn_name":null},{"line":694,"address":[5784332,5784544],"length":1,"stats":{"Line":2},"fn_name":null},{"line":695,"address":[5784594],"length":1,"stats":{"Line":1},"fn_name":null},{"line":697,"address":[5784811,5784660],"length":1,"stats":{"Line":1},"fn_name":null},{"line":700,"address":[5785184,5785137,5784801],"length":1,"stats":{"Line":2},"fn_name":null},{"line":705,"address":[5785783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":706,"address":[5785819],"length":1,"stats":{"Line":1},"fn_name":null},{"line":708,"address":[5785845],"length":1,"stats":{"Line":1},"fn_name":null},{"line":709,"address":[5785892],"length":1,"stats":{"Line":1},"fn_name":null},{"line":711,"address":[5785922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":712,"address":[5786109,5788336,5785980],"length":1,"stats":{"Line":2},"fn_name":null},{"line":714,"address":[5786144],"length":1,"stats":{"Line":1},"fn_name":null},{"line":716,"address":[5786227,5786310],"length":1,"stats":{"Line":1},"fn_name":null},{"line":717,"address":[5786252,5786316],"length":1,"stats":{"Line":2},"fn_name":null},{"line":718,"address":[5786496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":721,"address":[5786523,5786550,5788015],"length":1,"stats":{"Line":2},"fn_name":null},{"line":723,"address":[5786545,5787046,5788123,5788292,5786904],"length":1,"stats":{"Line":3},"fn_name":null},{"line":724,"address":[5787034,5787145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":725,"address":[5787013],"length":1,"stats":{"Line":1},"fn_name":null},{"line":730,"address":[5787079,5788182],"length":1,"stats":{"Line":1},"fn_name":null},{"line":733,"address":[5787657,5787542],"length":1,"stats":{"Line":1},"fn_name":null},{"line":738,"address":[5788526],"length":1,"stats":{"Line":1},"fn_name":null},{"line":740,"address":[5316928,5316940],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":744,"address":[5788636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":748,"address":[5788796],"length":1,"stats":{"Line":1},"fn_name":null},{"line":749,"address":[5788815,5788914],"length":1,"stats":{"Line":1},"fn_name":null},{"line":750,"address":[5788998],"length":1,"stats":{"Line":1},"fn_name":null},{"line":752,"address":[5789233,5789102],"length":1,"stats":{"Line":1},"fn_name":null},{"line":758,"address":[5789646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":759,"address":[5789678],"length":1,"stats":{"Line":1},"fn_name":null},{"line":760,"address":[5789731,5789702],"length":1,"stats":{"Line":2},"fn_name":null},{"line":766,"address":[5789902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":767,"address":[5317154,5317136],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":768,"address":[5317218,5317200],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":774,"address":[5790153,5790182,5790240],"length":1,"stats":{"Line":3},"fn_name":null},{"line":780,"address":[5317328,5317346],"length":1,"stats":{"Line":5},"fn_name":"{{closure}}"},{"line":785,"address":[5790509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":786,"address":[5790527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":787,"address":[5790546],"length":1,"stats":{"Line":1},"fn_name":null},{"line":793,"address":[5790711,5790644],"length":1,"stats":{"Line":2},"fn_name":null},{"line":794,"address":[5790777,5790750],"length":1,"stats":{"Line":1},"fn_name":null},{"line":795,"address":[5790752,5790734],"length":1,"stats":{"Line":2},"fn_name":null},{"line":798,"address":[5790779],"length":1,"stats":{"Line":1},"fn_name":null},{"line":804,"address":[5790951,5791056],"length":1,"stats":{"Line":2},"fn_name":null},{"line":805,"address":[5791293,5791064,5791357,5791240],"length":1,"stats":{"Line":3},"fn_name":null},{"line":806,"address":[5791337],"length":1,"stats":{"Line":1},"fn_name":null},{"line":808,"address":[5791362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":814,"address":[5791738,5791623],"length":1,"stats":{"Line":2},"fn_name":null},{"line":815,"address":[5791802],"length":1,"stats":{"Line":1},"fn_name":null},{"line":816,"address":[5791846],"length":1,"stats":{"Line":1},"fn_name":null},{"line":817,"address":[5791858],"length":1,"stats":{"Line":1},"fn_name":null},{"line":818,"address":[5791865,5791953],"length":1,"stats":{"Line":2},"fn_name":null},{"line":824,"address":[5792282,5792167],"length":1,"stats":{"Line":2},"fn_name":null},{"line":825,"address":[5792363],"length":1,"stats":{"Line":1},"fn_name":null},{"line":826,"address":[5792410],"length":1,"stats":{"Line":1},"fn_name":null},{"line":827,"address":[5792422],"length":1,"stats":{"Line":1},"fn_name":null},{"line":828,"address":[5792429,5792517],"length":1,"stats":{"Line":2},"fn_name":null},{"line":834,"address":[5317597,5317584],"length":1,"stats":{"Line":5},"fn_name":"{{closure}}"},{"line":840,"address":[5792951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":841,"address":[5792981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":842,"address":[5317677,5317664],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":843,"address":[5317712,5317726],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":844,"address":[5317776,5317790],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":846,"address":[5793188,5793320],"length":1,"stats":{"Line":2},"fn_name":null},{"line":847,"address":[5793327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":848,"address":[5793373,5793442],"length":1,"stats":{"Line":2},"fn_name":null},{"line":854,"address":[5793540],"length":1,"stats":{"Line":1},"fn_name":null},{"line":860,"address":[5793688,5793639],"length":1,"stats":{"Line":2},"fn_name":null},{"line":861,"address":[5793717],"length":1,"stats":{"Line":1},"fn_name":null},{"line":862,"address":[5794275,5794009,5793763,5793808,5793893],"length":1,"stats":{"Line":4},"fn_name":null},{"line":863,"address":[5794844,5794059,5794613,5794280],"length":1,"stats":{"Line":2},"fn_name":null},{"line":864,"address":[5794330],"length":1,"stats":{"Line":1},"fn_name":null},{"line":865,"address":[5794436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":866,"address":[5794618,5794674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":870,"address":[5794681,5793994],"length":1,"stats":{"Line":2},"fn_name":null},{"line":876,"address":[5317956,5317936,5317951],"length":1,"stats":{"Line":5},"fn_name":"{{closure}}"},{"line":877,"address":[5317983,5317988,5317968],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":883,"address":[5318052,5318047,5318032],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":889,"address":[5795300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":893,"address":[5795407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":894,"address":[5795431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":895,"address":[5795524,5795464,5795554],"length":1,"stats":{"Line":3},"fn_name":null},{"line":896,"address":[5795561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":898,"address":[5795621],"length":1,"stats":{"Line":1},"fn_name":null},{"line":899,"address":[5795671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":900,"address":[5795741],"length":1,"stats":{"Line":1},"fn_name":null},{"line":901,"address":[5796034,5796450,5795862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":907,"address":[5796519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":908,"address":[5318173,5318160],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":909,"address":[5318192,5318203],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":910,"address":[5796735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":916,"address":[5318318,5318304],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":917,"address":[5318363,5318352],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":918,"address":[5797097],"length":1,"stats":{"Line":1},"fn_name":null},{"line":924,"address":[5318464,5318478],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":925,"address":[5797342,5797386],"length":1,"stats":{"Line":2},"fn_name":null},{"line":926,"address":[5318512,5318523],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":927,"address":[5797599],"length":1,"stats":{"Line":1},"fn_name":null},{"line":933,"address":[5318624,5318638],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":934,"address":[5797995],"length":1,"stats":{"Line":1},"fn_name":null},{"line":935,"address":[5798060,5798028],"length":1,"stats":{"Line":2},"fn_name":null},{"line":936,"address":[5798076],"length":1,"stats":{"Line":1},"fn_name":null},{"line":937,"address":[5798083],"length":1,"stats":{"Line":1},"fn_name":null},{"line":939,"address":[5318672,5318683],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":940,"address":[5798114,5798185,5800666],"length":1,"stats":{"Line":3},"fn_name":null},{"line":941,"address":[5801228,5798315,5798415],"length":1,"stats":{"Line":2},"fn_name":null},{"line":942,"address":[5798431,5798497],"length":1,"stats":{"Line":1},"fn_name":null},{"line":943,"address":[5798454,5798499,5799120],"length":1,"stats":{"Line":3},"fn_name":null},{"line":944,"address":[5798647,5798714,5798787,5800553,5799052,5800659],"length":1,"stats":{"Line":5},"fn_name":null},{"line":945,"address":[5800593],"length":1,"stats":{"Line":1},"fn_name":null},{"line":947,"address":[5799057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":949,"address":[5798565],"length":1,"stats":{"Line":1},"fn_name":null},{"line":951,"address":[5799169],"length":1,"stats":{"Line":1},"fn_name":null},{"line":954,"address":[5798400,5799190,5799535,5799270,5800727,5800833],"length":1,"stats":{"Line":5},"fn_name":null},{"line":955,"address":[5800767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":957,"address":[5800840,5799924,5799540],"length":1,"stats":{"Line":2},"fn_name":null},{"line":958,"address":[5799947,5800318,5799891,5800994],"length":1,"stats":{"Line":2},"fn_name":null},{"line":959,"address":[5800255],"length":1,"stats":{"Line":1},"fn_name":null},{"line":966,"address":[5801420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":967,"address":[5801436,5801495],"length":1,"stats":{"Line":2},"fn_name":null},{"line":968,"address":[5801465,5802361],"length":1,"stats":{"Line":1},"fn_name":null},{"line":970,"address":[5801509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":971,"address":[5801595],"length":1,"stats":{"Line":1},"fn_name":null},{"line":972,"address":[5802087,5802351,5801673,5802201],"length":1,"stats":{"Line":3},"fn_name":null},{"line":973,"address":[5802273,5802057],"length":1,"stats":{"Line":2},"fn_name":null},{"line":974,"address":[5802092],"length":1,"stats":{"Line":0},"fn_name":null},{"line":977,"address":[5802036],"length":1,"stats":{"Line":1},"fn_name":null},{"line":983,"address":[5318839,5318816],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":984,"address":[5802584],"length":1,"stats":{"Line":1},"fn_name":null},{"line":985,"address":[5802663],"length":1,"stats":{"Line":1},"fn_name":null},{"line":989,"address":[5318967,5318944],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":990,"address":[5802920],"length":1,"stats":{"Line":1},"fn_name":null},{"line":991,"address":[5802999],"length":1,"stats":{"Line":1},"fn_name":null},{"line":995,"address":[5319168,5319196],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":996,"address":[5803256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":997,"address":[5803335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1001,"address":[5319488,5319516],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":1002,"address":[5803608],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1003,"address":[5803687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1007,"address":[5319904,5319927],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":1008,"address":[5803960],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1009,"address":[5804039],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1013,"address":[5320032,5320119,5320096,5320046],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":1014,"address":[5804313],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1015,"address":[5804395],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1019,"address":[5320384,5320412,5320334,5320320],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":1020,"address":[5804665],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1021,"address":[5804747],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1025,"address":[5320718,5320768,5320796,5320704],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":1026,"address":[5805033],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1027,"address":[5805115],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1031,"address":[5805287,5805402],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1032,"address":[5805430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1033,"address":[5805437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1034,"address":[5805529,5805753],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1035,"address":[5805691],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1042,"address":[5806298,5806356,5806260],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1045,"address":[5806451],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1051,"address":[5806591,5806543],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1052,"address":[5806615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1053,"address":[5321294,5321280],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1055,"address":[5321408,5321422],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":1057,"address":[5807728,5807466,5806995,5807331],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1058,"address":[5321502,5321488],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1069,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1070,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1075,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1076,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1081,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1082,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1083,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1085,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1086,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1095,"address":[5808447,5808563],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1096,"address":[5808652,5808706,5808578],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1097,"address":[5808595,5808640],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1098,"address":[5808669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1099,"address":[5808873,5808721,5808623],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1100,"address":[5808785],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1102,"address":[5808922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1110,"address":[5321696,5321710],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":1111,"address":[5809231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1114,"address":[5809214,5809291],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1115,"address":[5809345],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1117,"address":[5809426],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1118,"address":[5809468,5809559,5809621],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1119,"address":[5809547,5809497],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1120,"address":[5809564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1121,"address":[5809623,5809517],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1123,"address":[5809711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1130,"address":[5321824,5321867],"length":1,"stats":{"Line":1},"fn_name":"collapse_adjacent<fn(f64, f64) -> f64>"},{"line":1133,"address":[5321847],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1134,"address":[5321917,5322563,5322193,5321882,5322009],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1135,"address":[5322394,5322243,5322561,5322631],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1136,"address":[5322345],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1138,"address":[5322663,5322320,5322693,5322404],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1141,"address":[5322148],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1144,"address":[5321776,5321790],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":1145,"address":[5810024],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1148,"address":[5810082,5809995],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1150,"address":[5810196,5810370],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1151,"address":[5810257],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1153,"address":[5810380,5810239],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1155,"address":[5810419],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1161,"address":[5810713,5810594],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1162,"address":[5810755,5811013,5811161],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1163,"address":[5810864,5810784],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1164,"address":[5811026,5810790],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":452,"coverable":480},{"path":["/","home","kms","itertools","tests","specializations.rs"],"content":"use itertools::{EitherOrBoth, Itertools};\nuse std::fmt::Debug;\nuse std::ops::BitXor;\nuse quickcheck::quickcheck;\n\nstruct Unspecialized<I>(I);\nimpl<I> Iterator for Unspecialized<I>\nwhere\n    I: Iterator,\n{\n    type Item = I::Item;\n\n    #[inline(always)]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.0.next()\n    }\n\n    #[inline(always)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.0.size_hint()\n    }\n}\n\nfn check_specialized<'a, V, IterItem, Iter, F>(iterator: &Iter, mapper: F)\nwhere\n    V: Eq + Debug,\n    IterItem: 'a,\n    Iter: Iterator<Item = IterItem> + Clone + 'a,\n    F: Fn(Box<dyn Iterator<Item = IterItem> + 'a>) -> V,\n{\n    assert_eq!(\n        mapper(Box::new(Unspecialized(iterator.clone()))),\n        mapper(Box::new(iterator.clone()))\n    )\n}\n\nfn check_specialized_count_last_nth_sizeh<'a, IterItem, Iter>(\n    it: &Iter,\n    known_expected_size: Option<usize>,\n) where\n    IterItem: 'a + Eq + Debug,\n    Iter: Iterator<Item = IterItem> + Clone + 'a,\n{\n    let size = it.clone().count();\n    if let Some(expected_size) = known_expected_size {\n        assert_eq!(size, expected_size);\n    }\n    check_specialized(it, |i| i.count());\n    check_specialized(it, |i| i.last());\n    for n in 0..size + 2 {\n        check_specialized(it, |mut i| i.nth(n));\n    }\n    let mut it_sh = it.clone();\n    for n in 0..size + 2 {\n        let len = it_sh.clone().count();\n        let (min, max) = it_sh.size_hint();\n        assert_eq!((size - n.min(size)), len);\n        assert!(min <= len);\n        if let Some(max) = max {\n            assert!(len <= max);\n        }\n        it_sh.next();\n    }\n}\n\nfn check_specialized_fold_xor<'a, IterItem, Iter>(it: &Iter)\nwhere\n    IterItem: 'a\n        + BitXor\n        + Eq\n        + Debug\n        + BitXor<<IterItem as BitXor>::Output, Output = <IterItem as BitXor>::Output>\n        + Clone,\n    <IterItem as BitXor>::Output:\n        BitXor<Output = <IterItem as BitXor>::Output> + Eq + Debug + Clone,\n    Iter: Iterator<Item = IterItem> + Clone + 'a,\n{\n    check_specialized(it, |mut i| {\n        let first = i.next().map(|f| f.clone() ^ (f.clone() ^ f));\n        i.fold(first, |acc, v: IterItem| acc.map(move |a| v ^ a))\n    });\n}\n\nfn put_back_test(test_vec: Vec<i32>, known_expected_size: Option<usize>) {\n    {\n        // Lexical lifetimes support\n        let pb = itertools::put_back(test_vec.iter());\n        check_specialized_count_last_nth_sizeh(&pb, known_expected_size);\n        check_specialized_fold_xor(&pb);\n    }\n\n    let mut pb = itertools::put_back(test_vec.into_iter());\n    pb.put_back(1);\n    check_specialized_count_last_nth_sizeh(&pb, known_expected_size.map(|x| x + 1));\n    check_specialized_fold_xor(&pb)\n}\n\n#[test]\nfn put_back() {\n    put_back_test(vec![7, 4, 1], Some(3));\n}\n\nquickcheck! {\n    fn put_back_qc(test_vec: Vec<i32>) -> () {\n        put_back_test(test_vec, None)\n    }\n}\n\nfn merge_join_by_test(i1: Vec<usize>, i2: Vec<usize>, known_expected_size: Option<usize>) {\n    let i1 = i1.into_iter();\n    let i2 = i2.into_iter();\n    let mjb = i1.clone().merge_join_by(i2.clone(), std::cmp::Ord::cmp);\n    check_specialized_count_last_nth_sizeh(&mjb, known_expected_size);\n    // Rust 1.24 compatibility:\n    fn eob_left_z(eob: EitherOrBoth<usize, usize>) -> usize {\n        eob.left().unwrap_or(0)\n    }\n    fn eob_right_z(eob: EitherOrBoth<usize, usize>) -> usize {\n        eob.left().unwrap_or(0)\n    }\n    fn eob_both_z(eob: EitherOrBoth<usize, usize>) -> usize {\n        let (a, b) = eob.both().unwrap_or((0, 0));\n        assert_eq!(a, b);\n        a\n    }\n    check_specialized_fold_xor(&mjb.clone().map(eob_left_z));\n    check_specialized_fold_xor(&mjb.clone().map(eob_right_z));\n    check_specialized_fold_xor(&mjb.clone().map(eob_both_z));\n\n    // And the other way around\n    let mjb = i2.merge_join_by(i1, std::cmp::Ord::cmp);\n    check_specialized_count_last_nth_sizeh(&mjb, known_expected_size);\n    check_specialized_fold_xor(&mjb.clone().map(eob_left_z));\n    check_specialized_fold_xor(&mjb.clone().map(eob_right_z));\n    check_specialized_fold_xor(&mjb.clone().map(eob_both_z));\n}\n\n#[test]\nfn merge_join_by() {\n    let i1 = vec![1, 3, 5, 7, 8, 9];\n    let i2 = vec![0, 3, 4, 5];\n    merge_join_by_test(i1, i2, Some(8));\n}\n\nquickcheck! {\n    fn merge_join_by_qc(i1: Vec<usize>, i2: Vec<usize>) -> () {\n        merge_join_by_test(i1, i2, None)\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[4268160,4264400,4269062,4270032,4266214,4267216,4259952,4260800,4263525,4263488,4262624,4265296,4260832,4258950,4264368,4267184,4266176,4258000,4258912,4268128,4269024,4258037,4261696,4265264,4270064,4262592,4259920,4261733],"length":1,"stats":{"Line":19},"fn_name":"check_specialized<core::option::Option<itertools::either_or_both::EitherOrBoth<usize, usize>>,itertools::either_or_both::EitherOrBoth<usize, usize>,itertools::merge_join::MergeJoinBy<alloc::vec::IntoIter<usize>, alloc::vec::IntoIter<usize>, fn(&usize, &usize) -> core::cmp::Ordering>,closure-2>"},{"line":31,"address":[4269535,4263984,4264870,4264859,4268545,4266783,4265693,4263095,4266687,4261234,4263106,4259423,4260325,4260422,4261314,4267730,4267741,4265790,4260411,4270511,4264773,4259530,4258439,4259519,4265779,4267644,4262215,4269642,4270522,4263995,4258519,4268642,4270425,4269631,4258530,4263009,4261325,4263898,4262118,4262204,4266794,4268631],"length":1,"stats":{"Line":40},"fn_name":null},{"line":32,"address":[4267231,4270079,4261863,4258234,4260080,4265311,4266191,4269039,4260847,4267413,4259147,4262604,4262754,4270044,4266411,4264415,4258965,4269077,4258927,4263540,4264380,4262639,4266229,4268140,4268175,4258017,4268290,4269259,4263653,4263505,4260812,4258052,4265276,4261029,4261713,4267196,4265424,4270194,4264528,4259932,4261748,4259967],"length":1,"stats":{"Line":60},"fn_name":null},{"line":33,"address":[4259325,4259237,4263821,4265604,4266501,4267567,4268371,4267482,4268456,4264696,4269349,4269437,4261944,4262835,4260149,4270263,4270348,4258290,4266589,4258375,4260248,4261085,4262920,4261170,4262029,4264597,4263722,4265505],"length":1,"stats":{"Line":37},"fn_name":null},{"line":37,"address":[4273030,4270966,4270912,4275008,4275062,4272976],"length":1,"stats":{"Line":4},"fn_name":"check_specialized_count_last_nth_sizeh<itertools::either_or_both::EitherOrBoth<usize, usize>,itertools::merge_join::MergeJoinBy<alloc::vec::IntoIter<usize>, alloc::vec::IntoIter<usize>, fn(&usize, &usize) -> core::cmp::Ordering>>"},{"line":44,"address":[4275077,4270943,4273045,4273007,4275039,4270981],"length":1,"stats":{"Line":8},"fn_name":null},{"line":45,"address":[4271130,4273194,4275098,4271002,4273066,4275226],"length":1,"stats":{"Line":7},"fn_name":null},{"line":46,"address":[4273097,4271142,4275238,4275129,4271033,4273206],"length":1,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[4273504,4277139,4277184,4277120,4271440,4277075,4277203,4275536,4277056],"length":1,"stats":{"Line":11},"fn_name":"{{closure}}<&i32,itertools::adaptors::PutBack<core::slice::Iter<i32>>>"},{"line":49,"address":[4275549,4271453,4277248,4277312,4277376,4277270,4277395,4273517,4277331],"length":1,"stats":{"Line":12},"fn_name":"{{closure}}<itertools::either_or_both::EitherOrBoth<usize, usize>,itertools::merge_join::MergeJoinBy<alloc::vec::IntoIter<usize>, alloc::vec::IntoIter<usize>, fn(&usize, &usize) -> core::cmp::Ordering>>"},{"line":50,"address":[4271466,4271758,4272855,4273735,4274885,4273530,4273822,4275562,4275854,4271671,4275767,4276941],"length":1,"stats":{"Line":8},"fn_name":null},{"line":51,"address":[4271721,4277440,4277462,4273785,4275817,4277664,4277683,4277552,4277571],"length":1,"stats":{"Line":12},"fn_name":"{{closure}}<itertools::either_or_both::EitherOrBoth<usize, usize>,itertools::merge_join::MergeJoinBy<alloc::vec::IntoIter<usize>, alloc::vec::IntoIter<usize>, fn(&usize, &usize) -> core::cmp::Ordering>>"},{"line":53,"address":[4271648,4273712,4275744],"length":1,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[4273827,4273930,4272842,4272885,4276086,4275859,4274915,4274872,4271763,4271879,4274028,4276971,4276928,4275975,4271990],"length":1,"stats":{"Line":12},"fn_name":null},{"line":55,"address":[4272056,4274094,4276152],"length":1,"stats":{"Line":4},"fn_name":null},{"line":56,"address":[4274150,4276208,4272112],"length":1,"stats":{"Line":4},"fn_name":null},{"line":57,"address":[4276263,4272967,4274967,4277053,4274205,4272386,4272167,4276482,4272937,4274424,4274997,4277023],"length":1,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[4272350,4274747,4276446,4272709,4274388,4276805],"length":1,"stats":{"Line":4},"fn_name":null},{"line":59,"address":[4272696,4276838,4274780,4274734,4274823,4272785,4276792,4272742,4276881],"length":1,"stats":{"Line":12},"fn_name":null},{"line":60,"address":[4272758,4274825,4276854,4272787,4274796,4276883],"length":1,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[4274863,4276921,4272833],"length":1,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[4277792,4277824,4277808,4277776,4277840],"length":1,"stats":{"Line":8},"fn_name":"check_specialized_fold_xor<i32,itertools::adaptors::PutBack<alloc::vec::IntoIter<i32>>>"},{"line":78,"address":[4280213,4279991,4280407,4280160,4277829,4279744,4277813,4280352,4277797,4279520,4279790,4279575,4277781,4277845,4279936],"length":1,"stats":{"Line":16},"fn_name":"{{closure}}<usize,core::iter::adapters::Map<itertools::merge_join::MergeJoinBy<alloc::vec::IntoIter<usize>, alloc::vec::IntoIter<usize>, fn(&usize, &usize) -> core::cmp::Ordering>, fn(itertools::either_or_both::EitherOrBoth<usize, usize>) -> usize>>"},{"line":79,"address":[4278057,4278265,4280179,4280013,4279597,4278464,4277856,4278681,4277864,4279807,4280233,4278473,4278048,4278256,4278672,4279955,4280371,4279763,4280429,4279539],"length":1,"stats":{"Line":32},"fn_name":"{{closure}}<i32,itertools::adaptors::PutBack<alloc::vec::IntoIter<i32>>>"},{"line":80,"address":[4279200,4279384,4279464,4279838,4280050,4280264,4279360,4279280,4278880,4278940,4278976,4279304,4279142,4279221,4278894,4279072,4279086,4279440,4279634,4278928,4279120,4280466,4279037,4278990,4279024],"length":1,"stats":{"Line":37},"fn_name":"{{closure}}<usize,core::iter::adapters::Map<itertools::merge_join::MergeJoinBy<alloc::vec::IntoIter<usize>, alloc::vec::IntoIter<usize>, fn(&usize, &usize) -> core::cmp::Ordering>, fn(itertools::either_or_both::EitherOrBoth<usize, usize>) -> usize>>"},{"line":84,"address":[4210487,4210432],"length":1,"stats":{"Line":1},"fn_name":"put_back_test"},{"line":87,"address":[4210502,4210470],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[4210555],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[4210582],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[4210589],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[4210682],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[4210689,4210743],"length":1,"stats":{"Line":4},"fn_name":null},{"line":95,"address":[4210755],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[4213040],"length":1,"stats":{"Line":3},"fn_name":"put_back"},{"line":100,"address":[4213044],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[4213172],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[4210864,4211035],"length":1,"stats":{"Line":1},"fn_name":"merge_join_by_test"},{"line":110,"address":[4210881],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[4210975,4211050],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[4211058,4212060],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[4211161],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[4212336],"length":1,"stats":{"Line":2},"fn_name":"eob_left_z"},{"line":116,"address":[4212340],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[4212432],"length":1,"stats":{"Line":2},"fn_name":"eob_right_z"},{"line":119,"address":[4212436],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[4212528],"length":1,"stats":{"Line":2},"fn_name":"eob_both_z"},{"line":122,"address":[4212535],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[4212650,4212764],"length":1,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[4212744],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[4211202,4211243],"length":1,"stats":{"Line":4},"fn_name":null},{"line":127,"address":[4211311],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[4211405],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[4211483],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[4211582],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[4211623,4211664],"length":1,"stats":{"Line":4},"fn_name":null},{"line":134,"address":[4211732],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[4211826],"length":1,"stats":{"Line":2},"fn_name":null},{"line":139,"address":[4213232,4213331],"length":1,"stats":{"Line":3},"fn_name":"merge_join_by"},{"line":140,"address":[4213346,4213239],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[4213364],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[4213436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[4213620],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":64,"coverable":66},{"path":["/","home","kms","itertools","tests","test_core.rs"],"content":"//! Licensed under the Apache License, Version 2.0\n//! http://www.apache.org/licenses/LICENSE-2.0 or the MIT license\n//! http://opensource.org/licenses/MIT, at your\n//! option. This file may not be copied, modified, or distributed\n//! except according to those terms.\n#![no_std]\n\nuse core::iter;\nuse itertools as it;\nuse crate::it::Itertools;\nuse crate::it::interleave;\nuse crate::it::multizip;\nuse crate::it::free::put_back;\nuse crate::it::iproduct;\nuse crate::it::izip;\n\n#[test]\nfn product2() {\n    let s = \"αβ\";\n\n    let mut prod = iproduct!(s.chars(), 0..2);\n    assert!(prod.next() == Some(('α', 0)));\n    assert!(prod.next() == Some(('α', 1)));\n    assert!(prod.next() == Some(('β', 0)));\n    assert!(prod.next() == Some(('β', 1)));\n    assert!(prod.next() == None);\n}\n\n#[test]\nfn product_temporary() {\n    for (_x, _y, _z) in iproduct!(\n        [0, 1, 2].iter().cloned(),\n        [0, 1, 2].iter().cloned(),\n        [0, 1, 2].iter().cloned())\n    {\n        // ok\n    }\n}\n\n\n#[test]\nfn izip_macro() {\n    let mut zip = izip!(2..3);\n    assert!(zip.next() == Some(2));\n    assert!(zip.next().is_none());\n\n    let mut zip = izip!(0..3, 0..2, 0..2i8);\n    for i in 0..2 {\n        assert!((i as usize, i, i as i8) == zip.next().unwrap());\n    }\n    assert!(zip.next().is_none());\n\n    let xs: [isize; 0] = [];\n    let mut zip = izip!(0..3, 0..2, 0..2i8, &xs);\n    assert!(zip.next().is_none());\n}\n\n#[test]\nfn izip2() {\n    let _zip1: iter::Zip<_, _> = izip!(1.., 2..);\n    let _zip2: iter::Zip<_, _> = izip!(1.., 2.., );\n}\n\n#[test]\nfn izip3() {\n    let mut zip: iter::Map<iter::Zip<_, _>, _> = izip!(0..3, 0..2, 0..2i8);\n    for i in 0..2 {\n        assert!((i as usize, i, i as i8) == zip.next().unwrap());\n    }\n    assert!(zip.next().is_none());\n}\n\n#[test]\nfn multizip3() {\n    let mut zip = multizip((0..3, 0..2, 0..2i8));\n    for i in 0..2 {\n        assert!((i as usize, i, i as i8) == zip.next().unwrap());\n    }\n    assert!(zip.next().is_none());\n\n    let xs: [isize; 0] = [];\n    let mut zip = multizip((0..3, 0..2, 0..2i8, xs.iter()));\n    assert!(zip.next().is_none());\n\n    for (_, _, _, _, _) in multizip((0..3, 0..2, xs.iter(), &xs, xs.to_vec())) {\n        /* test compiles */\n    }\n}\n\n#[test]\nfn write_to() {\n    let xs = [7, 9, 8];\n    let mut ys = [0; 5];\n    let cnt = ys.iter_mut().set_from(xs.iter().map(|x| *x));\n    assert!(cnt == xs.len());\n    assert!(ys == [7, 9, 8, 0, 0]);\n\n    let cnt = ys.iter_mut().set_from(0..10);\n    assert!(cnt == ys.len());\n    assert!(ys == [0, 1, 2, 3, 4]);\n}\n\n#[test]\nfn test_interleave() {\n    let xs: [u8; 0]  = [];\n    let ys = [7u8, 9, 8, 10];\n    let zs = [2u8, 77];\n    let it = interleave(xs.iter(), ys.iter());\n    it::assert_equal(it, ys.iter());\n\n    let rs = [7u8, 2, 9, 77, 8, 10];\n    let it = interleave(ys.iter(), zs.iter());\n    it::assert_equal(it, rs.iter());\n}\n\n#[allow(deprecated)]\n#[test]\nfn foreach() {\n    let xs = [1i32, 2, 3];\n    let mut sum = 0;\n    xs.iter().foreach(|elt| sum += *elt);\n    assert!(sum == 6);\n}\n\n#[test]\nfn dropping() {\n    let xs = [1, 2, 3];\n    let mut it = xs.iter().dropping(2);\n    assert_eq!(it.next(), Some(&3));\n    assert!(it.next().is_none());\n    let mut it = xs.iter().dropping(5);\n    assert!(it.next().is_none());\n}\n\n#[test]\nfn batching() {\n    let xs = [0, 1, 2, 1, 3];\n    let ys = [(0, 1), (2, 1)];\n\n    // An iterator that gathers elements up in pairs\n    let pit = xs.iter().cloned().batching(|it| {\n               match it.next() {\n                   None => None,\n                   Some(x) => match it.next() {\n                       None => None,\n                       Some(y) => Some((x, y)),\n                   }\n               }\n           });\n    it::assert_equal(pit, ys.iter().cloned());\n}\n\n#[test]\nfn test_put_back() {\n    let xs = [0, 1, 1, 1, 2, 1, 3, 3];\n    let mut pb = put_back(xs.iter().cloned());\n    pb.next();\n    pb.put_back(1);\n    pb.put_back(0);\n    it::assert_equal(pb, xs.iter().cloned());\n}\n\n#[allow(deprecated)]\n#[test]\nfn step() {\n    it::assert_equal((0..10).step(1), 0..10);\n    it::assert_equal((0..10).step(2), (0..10).filter(|x: &i32| *x % 2 == 0));\n    it::assert_equal((0..10).step(10), 0..1);\n}\n\n#[allow(deprecated)]\n#[test]\nfn merge() {\n    it::assert_equal((0..10).step(2).merge((1..10).step(2)), 0..10);\n}\n\n\n#[test]\nfn repeatn() {\n    let s = \"α\";\n    let mut it = it::repeat_n(s, 3);\n    assert_eq!(it.len(), 3);\n    assert_eq!(it.next(), Some(s));\n    assert_eq!(it.next(), Some(s));\n    assert_eq!(it.next(), Some(s));\n    assert_eq!(it.next(), None);\n    assert_eq!(it.next(), None);\n}\n\n#[test]\nfn count_clones() {\n    // Check that RepeatN only clones N - 1 times.\n\n    use core::cell::Cell;\n    #[derive(PartialEq, Debug)]\n    struct Foo {\n        n: Cell<usize>\n    }\n\n    impl Clone for Foo\n    {\n        fn clone(&self) -> Self\n        {\n            let n = self.n.get();\n            self.n.set(n + 1);\n            Foo { n: Cell::new(n + 1) }\n        }\n    }\n\n\n    for n in 0..10 {\n        let f = Foo{n: Cell::new(0)};\n        let it = it::repeat_n(f, n);\n        // drain it\n        let last = it.last();\n        if n == 0 {\n            assert_eq!(last, None);\n        } else {\n            assert_eq!(last, Some(Foo{n: Cell::new(n - 1)}));\n        }\n    }\n}\n\n#[test]\nfn part() {\n    let mut data = [7, 1, 1, 9, 1, 1, 3];\n    let i = it::partition(&mut data, |elt| *elt >= 3);\n    assert_eq!(i, 3);\n    assert_eq!(data, [7, 3, 9, 1, 1, 1, 1]);\n\n    let i = it::partition(&mut data, |elt| *elt == 1);\n    assert_eq!(i, 4);\n    assert_eq!(data, [1, 1, 1, 1, 9, 3, 7]);\n\n    let mut data = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let i = it::partition(&mut data, |elt| *elt % 3 == 0);\n    assert_eq!(i, 3);\n    assert_eq!(data, [9, 6, 3, 4, 5, 2, 7, 8, 1]);\n}\n\n#[test]\nfn tree_fold1() {\n    for i in 0..100 {\n        assert_eq!((0..i).tree_fold1(|x, y| x + y), (0..i).fold1(|x, y| x + y));\n    }\n}\n\n#[test]\nfn exactly_one() {\n    assert_eq!((0..10).filter(|&x| x == 2).exactly_one().unwrap(), 2);\n    assert!((0..10).filter(|&x| x > 1 && x < 4).exactly_one().unwrap_err().eq(2..4));\n    assert!((0..10).filter(|&x| x > 1 && x < 5).exactly_one().unwrap_err().eq(2..5));\n    assert!((0..10).filter(|&_| false).exactly_one().unwrap_err().eq(0..0));\n}\n\n#[test]\nfn sum1() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq!(v[..0].iter().cloned().sum1::<i32>(), None);\n    assert_eq!(v[1..2].iter().cloned().sum1::<i32>(), Some(1));\n    assert_eq!(v[1..3].iter().cloned().sum1::<i32>(), Some(3));\n    assert_eq!(v.iter().cloned().sum1::<i32>(), Some(55));\n}\n\n#[test]\nfn product1() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq!(v[..0].iter().cloned().product1::<i32>(), None);\n    assert_eq!(v[..1].iter().cloned().product1::<i32>(), Some(0));\n    assert_eq!(v[1..3].iter().cloned().product1::<i32>(), Some(2));\n    assert_eq!(v[1..5].iter().cloned().product1::<i32>(), Some(24));\n}\n","traces":[{"line":18,"address":[4239328],"length":1,"stats":{"Line":3},"fn_name":"product2"},{"line":19,"address":[4239342],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[4239359],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[4239501,4239593],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[4239649,4239715,4239565],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[4239837,4239687,4239771],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[4239809,4239893,4239959],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[4239931,4240107,4240060,4240015],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[4282528,4282533],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":31,"address":[4240196,4240575,4240276,4240410],"length":1,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[4240126],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[4240218],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[4240352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[4240720],"length":1,"stats":{"Line":3},"fn_name":"izip_macro"},{"line":43,"address":[4240727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[4240769,4240858],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[4240907,4240999,4240830],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[4240934,4241048],"length":1,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[4241326,4241184,4241491],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[4241503,4241370],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[4241552,4241637,4241300],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[4241579,4241686],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[4241849,4241959,4241912],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[4241968],"length":1,"stats":{"Line":3},"fn_name":"izip2"},{"line":60,"address":[4241972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[4242019],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[4282789,4282784],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":66,"address":[4242087],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[4242270,4242409,4242571],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[4242583,4242453],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[4242721,4242674,4242632,4242386],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[4242911,4242736],"length":1,"stats":{"Line":3},"fn_name":"multizip3"},{"line":75,"address":[4242743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[4243227,4243065,4242926],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[4243239,4243109],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[4243042,4243411,4243288],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[4243319,4243460],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[4243721,4243593],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[4243645,4244054,4243772,4244097],"length":1,"stats":{"Line":3},"fn_name":null},{"line":91,"address":[4244336],"length":1,"stats":{"Line":3},"fn_name":"write_to"},{"line":92,"address":[4244343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[4244367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[4244402],"length":1,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[4244507,4244603],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[4244574,4244705,4244656],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[4244675,4244754],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[4244910,4244811],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[4244881,4245031,4244984,4244963],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[4245040],"length":1,"stats":{"Line":3},"fn_name":"test_interleave"},{"line":106,"address":[4245051],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[4245071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[4245081],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[4245159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[4245239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[4245287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[4245376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[4245472],"length":1,"stats":{"Line":3},"fn_name":"foreach"},{"line":119,"address":[4245476],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[4245500],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[4245508],"length":1,"stats":{"Line":3},"fn_name":null},{"line":122,"address":[4245566,4245592,4245633],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[4245648],"length":1,"stats":{"Line":3},"fn_name":"dropping"},{"line":127,"address":[4245655],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[4245685],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[4245749,4245894],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[4245868,4246199,4246263],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[4246226,4246327],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[4246348,4246411,4246460],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[4246464],"length":1,"stats":{"Line":3},"fn_name":"batching"},{"line":137,"address":[4246471],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[4246511],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[4246587],"length":1,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[4283217,4283262,4283275,4283382],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[4283247,4283269],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[4283331,4283277,4283318],"length":1,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[4283303,4283325],"length":1,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[4283333],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[4246671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[4246784],"length":1,"stats":{"Line":3},"fn_name":"test_put_back"},{"line":155,"address":[4246791],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[4246855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[4246928],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[4246938],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[4246955],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[4246965],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[4247088],"length":1,"stats":{"Line":3},"fn_name":"step"},{"line":166,"address":[4247095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[4247168],"length":1,"stats":{"Line":3},"fn_name":null},{"line":168,"address":[4247262],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[4247360],"length":1,"stats":{"Line":3},"fn_name":"merge"},{"line":174,"address":[4247367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[4247536],"length":1,"stats":{"Line":3},"fn_name":"repeatn"},{"line":180,"address":[4247550],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[4247570],"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[4247604,4247762],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[4248092,4247729,4248263],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[4248598,4248237,4248769],"length":1,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[4249104,4248743,4249275],"length":1,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[4249249,4249593,4249718],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[4249692,4250030,4250129],"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[4250432],"length":1,"stats":{"Line":3},"fn_name":"count_clones"},{"line":202,"address":[4251712],"length":1,"stats":{"Line":1},"fn_name":"clone"},{"line":204,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[4250439,4251670,4250585],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[4250639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[4250662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[4250691],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[4250752,4250897,4251362],"length":1,"stats":{"Line":3},"fn_name":null},{"line":217,"address":[4250806,4250902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[4251705,4250763,4251367,4251212,4251675],"length":1,"stats":{"Line":2},"fn_name":null},{"line":225,"address":[4252224],"length":1,"stats":{"Line":3},"fn_name":"part"},{"line":226,"address":[4252231],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[4252308],"length":1,"stats":{"Line":3},"fn_name":null},{"line":228,"address":[4252528,4252336],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[4252865,4252432,4252897],"length":1,"stats":{"Line":2},"fn_name":null},{"line":231,"address":[4252871],"length":1,"stats":{"Line":3},"fn_name":null},{"line":232,"address":[4253239,4253431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[4253899,4253335,4253768],"length":1,"stats":{"Line":2},"fn_name":null},{"line":235,"address":[4253774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[4253873],"length":1,"stats":{"Line":3},"fn_name":null},{"line":237,"address":[4254406,4254217],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[4254724,4254313,4254710],"length":1,"stats":{"Line":2},"fn_name":null},{"line":242,"address":[4255040],"length":1,"stats":{"Line":3},"fn_name":"tree_fold1"},{"line":243,"address":[4255047,4255141,4255343],"length":1,"stats":{"Line":2},"fn_name":null},{"line":244,"address":[4255167,4255348],"length":1,"stats":{"Line":5},"fn_name":null},{"line":249,"address":[4255664],"length":1,"stats":{"Line":3},"fn_name":"exactly_one"},{"line":250,"address":[4255912,4255671],"length":1,"stats":{"Line":3},"fn_name":null},{"line":251,"address":[4256217,4256380,4255858],"length":1,"stats":{"Line":4},"fn_name":null},{"line":252,"address":[4256322,4256429,4256592],"length":1,"stats":{"Line":4},"fn_name":null},{"line":253,"address":[4256534,4256641,4256761,4256810],"length":1,"stats":{"Line":4},"fn_name":null},{"line":257,"address":[4256816],"length":1,"stats":{"Line":3},"fn_name":"sum1"},{"line":258,"address":[4256830],"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[4257202,4256850],"length":1,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[4257832,4257553,4257120],"length":1,"stats":{"Line":2},"fn_name":null},{"line":261,"address":[4258410,4257750,4258183],"length":1,"stats":{"Line":2},"fn_name":null},{"line":262,"address":[4258374,4258875,4258725],"length":1,"stats":{"Line":2},"fn_name":null},{"line":266,"address":[4259184],"length":1,"stats":{"Line":3},"fn_name":"product1"},{"line":267,"address":[4259198],"length":1,"stats":{"Line":1},"fn_name":null},{"line":268,"address":[4259550,4259218],"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[4259901,4260180,4259488],"length":1,"stats":{"Line":2},"fn_name":null},{"line":270,"address":[4260531,4260810,4260098],"length":1,"stats":{"Line":2},"fn_name":null},{"line":271,"address":[4260728,4261131,4261306],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":144,"coverable":144},{"path":["/","home","kms","itertools","tests","test_std.rs"],"content":"use permutohedron;\nuse itertools as it;\nuse crate::it::Itertools;\nuse crate::it::multizip;\nuse crate::it::multipeek;\nuse crate::it::peek_nth;\nuse crate::it::free::rciter;\nuse crate::it::free::put_back_n;\nuse crate::it::FoldWhile;\nuse crate::it::cloned;\nuse crate::it::iproduct;\nuse crate::it::izip;\n\n#[test]\nfn product3() {\n    let prod = iproduct!(0..3, 0..2, 0..2);\n    assert_eq!(prod.size_hint(), (12, Some(12)));\n    let v = prod.collect_vec();\n    for i in 0..3 {\n        for j in 0..2 {\n            for k in 0..2 {\n                assert!((i, j, k) == v[(i * 2 * 2 + j * 2 + k) as usize]);\n            }\n        }\n    }\n    for (_, _, _, _) in iproduct!(0..3, 0..2, 0..2, 0..3) {\n        /* test compiles */\n    }\n}\n\n#[test]\nfn interleave_shortest() {\n    let v0: Vec<i32> = vec![0, 2, 4];\n    let v1: Vec<i32> = vec![1, 3, 5, 7];\n    let it = v0.into_iter().interleave_shortest(v1.into_iter());\n    assert_eq!(it.size_hint(), (6, Some(6)));\n    assert_eq!(it.collect_vec(), vec![0, 1, 2, 3, 4, 5]);\n\n    let v0: Vec<i32> = vec![0, 2, 4, 6, 8];\n    let v1: Vec<i32> = vec![1, 3, 5];\n    let it = v0.into_iter().interleave_shortest(v1.into_iter());\n    assert_eq!(it.size_hint(), (7, Some(7)));\n    assert_eq!(it.collect_vec(), vec![0, 1, 2, 3, 4, 5, 6]);\n\n    let i0 = ::std::iter::repeat(0);\n    let v1: Vec<_> = vec![1, 3, 5];\n    let it = i0.interleave_shortest(v1.into_iter());\n    assert_eq!(it.size_hint(), (7, Some(7)));\n\n    let v0: Vec<_> = vec![0, 2, 4];\n    let i1 = ::std::iter::repeat(1);\n    let it = v0.into_iter().interleave_shortest(i1);\n    assert_eq!(it.size_hint(), (6, Some(6)));\n}\n\n\n#[test]\nfn unique_by() {\n    let xs = [\"aaa\", \"bbbbb\", \"aa\", \"ccc\", \"bbbb\", \"aaaaa\", \"cccc\"];\n    let ys = [\"aaa\", \"bbbbb\", \"ccc\"];\n    it::assert_equal(ys.iter(), xs.iter().unique_by(|x| x[..2].to_string()));\n    it::assert_equal(ys.iter(), xs.iter().rev().unique_by(|x| x[..2].to_string()).rev());\n    let ys_rev = [\"cccc\", \"aaaaa\", \"bbbb\"];\n    it::assert_equal(ys_rev.iter(), xs.iter().unique_by(|x| x[..2].to_string()).rev());\n}\n\n#[test]\nfn unique() {\n    let xs = [0, 1, 2, 3, 2, 1, 3];\n    let ys = [0, 1, 2, 3];\n    it::assert_equal(ys.iter(), xs.iter().unique());\n    it::assert_equal(ys.iter(), xs.iter().rev().unique().rev());\n    let ys_rev = [3, 1, 2, 0];\n    it::assert_equal(ys_rev.iter(), xs.iter().unique().rev());\n\n    let xs = [0, 1];\n    let ys = [0, 1];\n    it::assert_equal(ys.iter(), xs.iter().unique());\n    it::assert_equal(ys.iter(), xs.iter().rev().unique().rev());\n    let ys_rev = [1, 0];\n    it::assert_equal(ys_rev.iter(), xs.iter().unique().rev());\n}\n\n#[test]\nfn intersperse() {\n    let xs = [\"a\", \"\", \"b\", \"c\"];\n    let v: Vec<&str> = xs.iter().map(|x| x.clone()).intersperse(\", \").collect();\n    let text: String = v.concat();\n    assert_eq!(text, \"a, , b, c\".to_string());\n\n    let ys = [0, 1, 2, 3];\n    let mut it = ys[..0].iter().map(|x| *x).intersperse(1);\n    assert!(it.next() == None);\n}\n\n#[test]\nfn dedup() {\n    let xs = [0, 1, 1, 1, 2, 1, 3, 3];\n    let ys = [0, 1, 2, 1, 3];\n    it::assert_equal(ys.iter(), xs.iter().dedup());\n    let xs = [0, 0, 0, 0, 0];\n    let ys = [0];\n    it::assert_equal(ys.iter(), xs.iter().dedup());\n\n    let xs = [0, 1, 1, 1, 2, 1, 3, 3];\n    let ys = [0, 1, 2, 1, 3];\n    let mut xs_d = Vec::new();\n    xs.iter().dedup().fold((), |(), &elt| xs_d.push(elt));\n    assert_eq!(&xs_d, &ys);\n}\n\n#[test]\nfn dedup_by() {\n    let xs = [(0, 0), (0, 1), (1, 1), (2, 1), (0, 2), (3, 1), (0, 3), (1, 3)];\n    let ys = [(0, 0), (0, 1), (0, 2), (3, 1), (0, 3)];\n    it::assert_equal(ys.iter(), xs.iter().dedup_by(|x, y| x.1==y.1));\n    let xs = [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)];\n    let ys = [(0, 1)];\n    it::assert_equal(ys.iter(), xs.iter().dedup_by(|x, y| x.0==y.0));\n\n    let xs = [(0, 0), (0, 1), (1, 1), (2, 1), (0, 2), (3, 1), (0, 3), (1, 3)];\n    let ys = [(0, 0), (0, 1), (0, 2), (3, 1), (0, 3)];\n    let mut xs_d = Vec::new();\n    xs.iter().dedup_by(|x, y| x.1==y.1).fold((), |(), &elt| xs_d.push(elt));\n    assert_eq!(&xs_d, &ys);\n}\n\n#[test]\nfn dedup_with_count() {\n    let xs: [i32; 8] = [0, 1, 1, 1, 2, 1, 3, 3];\n    let ys: [(usize, &i32); 5] = [(1, &0), (3, &1), (1, &2), (1, &1), (2, &3)];\n\n    it::assert_equal(ys.iter().cloned(), xs.iter().dedup_with_count());\n\n    let xs: [i32; 5] = [0, 0, 0, 0, 0];\n    let ys: [(usize, &i32); 1] = [(5, &0)];\n\n    it::assert_equal(ys.iter().cloned(), xs.iter().dedup_with_count());\n}\n\n\n#[test]\nfn dedup_by_with_count() {\n    let xs = [(0, 0), (0, 1), (1, 1), (2, 1), (0, 2), (3, 1), (0, 3), (1, 3)];\n    let ys = [(1, &(0, 0)), (3, &(0, 1)), (1, &(0, 2)), (1, &(3, 1)), (2, &(0, 3))];\n\n    it::assert_equal(ys.iter().cloned(), xs.iter().dedup_by_with_count(|x, y| x.1==y.1));\n\n    let xs = [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)];\n    let ys = [( 5, &(0, 1))];\n\n    it::assert_equal(ys.iter().cloned(), xs.iter().dedup_by_with_count(|x, y| x.0==y.0));\n}\n\n#[test]\nfn all_equal() {\n    assert!(\"\".chars().all_equal());\n    assert!(\"A\".chars().all_equal());\n    assert!(!\"AABBCCC\".chars().all_equal());\n    assert!(\"AAAAAAA\".chars().all_equal());\n    for (_key, mut sub) in &\"AABBCCC\".chars().group_by(|&x| x) {\n        assert!(sub.all_equal());\n    }\n}\n\n#[test]\nfn test_put_back_n() {\n    let xs = [0, 1, 1, 1, 2, 1, 3, 3];\n    let mut pb = put_back_n(xs.iter().cloned());\n    pb.next();\n    pb.next();\n    pb.put_back(1);\n    pb.put_back(0);\n    it::assert_equal(pb, xs.iter().cloned());\n}\n\n#[test]\nfn tee() {\n    let xs  = [0, 1, 2, 3];\n    let (mut t1, mut t2) = xs.iter().cloned().tee();\n    assert_eq!(t1.next(), Some(0));\n    assert_eq!(t2.next(), Some(0));\n    assert_eq!(t1.next(), Some(1));\n    assert_eq!(t1.next(), Some(2));\n    assert_eq!(t1.next(), Some(3));\n    assert_eq!(t1.next(), None);\n    assert_eq!(t2.next(), Some(1));\n    assert_eq!(t2.next(), Some(2));\n    assert_eq!(t1.next(), None);\n    assert_eq!(t2.next(), Some(3));\n    assert_eq!(t2.next(), None);\n    assert_eq!(t1.next(), None);\n    assert_eq!(t2.next(), None);\n\n    let (t1, t2) = xs.iter().cloned().tee();\n    it::assert_equal(t1, xs.iter().cloned());\n    it::assert_equal(t2, xs.iter().cloned());\n\n    let (t1, t2) = xs.iter().cloned().tee();\n    it::assert_equal(t1.zip(t2), xs.iter().cloned().zip(xs.iter().cloned()));\n}\n\n\n#[test]\nfn test_rciter() {\n    let xs = [0, 1, 1, 1, 2, 1, 3, 5, 6];\n\n    let mut r1 = rciter(xs.iter().cloned());\n    let mut r2 = r1.clone();\n    assert_eq!(r1.next(), Some(0));\n    assert_eq!(r2.next(), Some(1));\n    let mut z = r1.zip(r2);\n    assert_eq!(z.next(), Some((1, 1)));\n    assert_eq!(z.next(), Some((2, 1)));\n    assert_eq!(z.next(), Some((3, 5)));\n    assert_eq!(z.next(), None);\n\n    // test intoiterator\n    let r1 = rciter(0..5);\n    let mut z = izip!(&r1, r1);\n    assert_eq!(z.next(), Some((0, 1)));\n}\n\n#[allow(deprecated)]\n#[test]\nfn trait_pointers() {\n    struct ByRef<'r, I: ?Sized>(&'r mut I) ;\n\n    impl<'r, X, I: ?Sized> Iterator for ByRef<'r, I> where\n        I: 'r + Iterator<Item=X>\n    {\n        type Item = X;\n        fn next(&mut self) -> Option<Self::Item>\n        {\n            self.0.next()\n        }\n    }\n\n    let mut it = Box::new(0..10) as Box<dyn Iterator<Item=i32>>;\n    assert_eq!(it.next(), Some(0));\n\n    {\n        /* make sure foreach works on non-Sized */\n        let jt: &mut dyn Iterator<Item = i32> = &mut *it;\n        assert_eq!(jt.next(), Some(1));\n\n        {\n            let mut r = ByRef(jt);\n            assert_eq!(r.next(), Some(2));\n        }\n\n        assert_eq!(jt.find_position(|x| *x == 4), Some((1, 4)));\n        jt.foreach(|_| ());\n    }\n}\n\n#[test]\nfn merge_by() {\n    let odd : Vec<(u32, &str)> = vec![(1, \"hello\"), (3, \"world\"), (5, \"!\")];\n    let even = vec![(2, \"foo\"), (4, \"bar\"), (6, \"baz\")];\n    let expected = vec![(1, \"hello\"), (2, \"foo\"), (3, \"world\"), (4, \"bar\"), (5, \"!\"), (6, \"baz\")];\n    let results = odd.iter().merge_by(even.iter(), |a, b| a.0 <= b.0);\n    it::assert_equal(results, expected.iter());\n}\n\n#[test]\nfn merge_by_btree() {\n    use std::collections::BTreeMap;\n    let mut bt1 = BTreeMap::new();\n    bt1.insert(\"hello\", 1);\n    bt1.insert(\"world\", 3);\n    let mut bt2 = BTreeMap::new();\n    bt2.insert(\"foo\", 2);\n    bt2.insert(\"bar\", 4);\n    let results = bt1.into_iter().merge_by(bt2.into_iter(), |a, b| a.0 <= b.0 );\n    let expected = vec![(\"bar\", 4), (\"foo\", 2), (\"hello\", 1), (\"world\", 3)];\n    it::assert_equal(results, expected.into_iter());\n}\n\n#[allow(deprecated)]\n#[test]\nfn kmerge() {\n    let its = (0..4).map(|s| (s..10).step(4));\n\n    it::assert_equal(its.kmerge(), 0..10);\n}\n\n#[allow(deprecated)]\n#[test]\nfn kmerge_2() {\n    let its = vec![3, 2, 1, 0].into_iter().map(|s| (s..10).step(4));\n\n    it::assert_equal(its.kmerge(), 0..10);\n}\n\n#[test]\nfn kmerge_empty() {\n    let its = (0..4).map(|_| 0..0);\n    assert_eq!(its.kmerge().next(), None);\n}\n\n#[test]\nfn kmerge_size_hint() {\n    let its = (0..5).map(|_| (0..10));\n    assert_eq!(its.kmerge().size_hint(), (50, Some(50)));\n}\n\n#[test]\nfn kmerge_empty_size_hint() {\n    let its = (0..5).map(|_| (0..0));\n    assert_eq!(its.kmerge().size_hint(), (0, Some(0)));\n}\n\n#[test]\nfn join() {\n    let many = [1, 2, 3];\n    let one  = [1];\n    let none: Vec<i32> = vec![];\n\n    assert_eq!(many.iter().join(\", \"), \"1, 2, 3\");\n    assert_eq!( one.iter().join(\", \"), \"1\");\n    assert_eq!(none.iter().join(\", \"), \"\");\n}\n\n#[test]\nfn sorted_by() {\n    let sc = [3, 4, 1, 2].iter().cloned().sorted_by(|&a, &b| {\n        a.cmp(&b)\n    });\n    it::assert_equal(sc, vec![1, 2, 3, 4]);\n\n    let v = (0..5).sorted_by(|&a, &b| a.cmp(&b).reverse());\n    it::assert_equal(v, vec![4, 3, 2, 1, 0]);\n}\n\n#[test]\nfn sorted_by_key() {\n    let sc = [3, 4, 1, 2].iter().cloned().sorted_by_key(|&x| x);\n    it::assert_equal(sc, vec![1, 2, 3, 4]);\n\n    let v = (0..5).sorted_by_key(|&x| -x);\n    it::assert_equal(v, vec![4, 3, 2, 1, 0]);\n}\n\n#[test]\nfn test_multipeek() {\n    let nums = vec![1u8,2,3,4,5];\n\n    let mp = multipeek(nums.iter().map(|&x| x));\n    assert_eq!(nums, mp.collect::<Vec<_>>());\n\n    let mut mp = multipeek(nums.iter().map(|&x| x));\n    assert_eq!(mp.peek(), Some(&1));\n    assert_eq!(mp.next(), Some(1));\n    assert_eq!(mp.peek(), Some(&2));\n    assert_eq!(mp.peek(), Some(&3));\n    assert_eq!(mp.next(), Some(2));\n    assert_eq!(mp.peek(), Some(&3));\n    assert_eq!(mp.peek(), Some(&4));\n    assert_eq!(mp.peek(), Some(&5));\n    assert_eq!(mp.peek(), None);\n    assert_eq!(mp.next(), Some(3));\n    assert_eq!(mp.next(), Some(4));\n    assert_eq!(mp.peek(), Some(&5));\n    assert_eq!(mp.peek(), None);\n    assert_eq!(mp.next(), Some(5));\n    assert_eq!(mp.next(), None);\n    assert_eq!(mp.peek(), None);\n\n}\n\n#[test]\nfn test_multipeek_reset() {\n    let data = [1, 2, 3, 4];\n\n    let mut mp = multipeek(cloned(&data));\n    assert_eq!(mp.peek(), Some(&1));\n    assert_eq!(mp.next(), Some(1));\n    assert_eq!(mp.peek(), Some(&2));\n    assert_eq!(mp.peek(), Some(&3));\n    mp.reset_peek();\n    assert_eq!(mp.peek(), Some(&2));\n    assert_eq!(mp.next(), Some(2));\n}\n\n#[test]\nfn test_multipeek_peeking_next() {\n    use crate::it::PeekingNext;\n    let nums = vec![1u8,2,3,4,5,6,7];\n\n    let mut mp = multipeek(nums.iter().map(|&x| x));\n    assert_eq!(mp.peeking_next(|&x| x != 0), Some(1));\n    assert_eq!(mp.next(), Some(2));\n    assert_eq!(mp.peek(), Some(&3));\n    assert_eq!(mp.peek(), Some(&4));\n    assert_eq!(mp.peeking_next(|&x| x == 3), Some(3));\n    assert_eq!(mp.peek(), Some(&4));\n    assert_eq!(mp.peeking_next(|&x| x != 4), None);\n    assert_eq!(mp.peeking_next(|&x| x == 4), Some(4));\n    assert_eq!(mp.peek(), Some(&5));\n    assert_eq!(mp.peek(), Some(&6));\n    assert_eq!(mp.peeking_next(|&x| x != 5), None);\n    assert_eq!(mp.peek(), Some(&7));\n    assert_eq!(mp.peeking_next(|&x| x == 5), Some(5));\n    assert_eq!(mp.peeking_next(|&x| x == 6), Some(6));\n    assert_eq!(mp.peek(), Some(&7));\n    assert_eq!(mp.peek(), None);\n    assert_eq!(mp.next(), Some(7));\n    assert_eq!(mp.peek(), None);\n}\n\n#[test]\nfn test_peek_nth() {\n    let nums = vec![1u8,2,3,4,5];\n\n    let iter = peek_nth(nums.iter().map(|&x| x));\n    assert_eq!(nums, iter.collect::<Vec<_>>());\n\n    let mut iter = peek_nth(nums.iter().map(|&x| x));\n\n    assert_eq!(iter.peek_nth(0), Some(&1));\n    assert_eq!(iter.peek_nth(0), Some(&1));\n    assert_eq!(iter.next(), Some(1));\n\n    assert_eq!(iter.peek_nth(0), Some(&2));\n    assert_eq!(iter.peek_nth(1), Some(&3));\n    assert_eq!(iter.next(), Some(2));\n\n    assert_eq!(iter.peek_nth(0), Some(&3));\n    assert_eq!(iter.peek_nth(1), Some(&4));\n    assert_eq!(iter.peek_nth(2), Some(&5));\n    assert_eq!(iter.peek_nth(3), None);\n\n    assert_eq!(iter.next(), Some(3));\n    assert_eq!(iter.next(), Some(4));\n\n    assert_eq!(iter.peek_nth(0), Some(&5));\n    assert_eq!(iter.peek_nth(1), None);\n    assert_eq!(iter.next(), Some(5));\n    assert_eq!(iter.next(), None);\n\n    assert_eq!(iter.peek_nth(0), None);\n    assert_eq!(iter.peek_nth(1), None);\n}\n\n#[test]\nfn test_peek_nth_peeking_next() {\n    use it::PeekingNext;\n    let nums = vec![1u8,2,3,4,5,6,7];\n    let mut iter = peek_nth(nums.iter().map(|&x| x));\n\n    assert_eq!(iter.peeking_next(|&x| x != 0), Some(1));\n    assert_eq!(iter.next(), Some(2));\n\n    assert_eq!(iter.peek_nth(0), Some(&3));\n    assert_eq!(iter.peek_nth(1), Some(&4));\n    assert_eq!(iter.peeking_next(|&x| x == 3), Some(3));\n    assert_eq!(iter.peek(), Some(&4));\n\n    assert_eq!(iter.peeking_next(|&x| x != 4), None);\n    assert_eq!(iter.peeking_next(|&x| x == 4), Some(4));\n    assert_eq!(iter.peek_nth(0), Some(&5));\n    assert_eq!(iter.peek_nth(1), Some(&6));\n\n    assert_eq!(iter.peeking_next(|&x| x != 5), None);\n    assert_eq!(iter.peek(), Some(&5));\n\n    assert_eq!(iter.peeking_next(|&x| x == 5), Some(5));\n    assert_eq!(iter.peeking_next(|&x| x == 6), Some(6));\n    assert_eq!(iter.peek_nth(0), Some(&7));\n    assert_eq!(iter.peek_nth(1), None);\n    assert_eq!(iter.next(), Some(7));\n    assert_eq!(iter.peek(), None);\n}\n\n#[test]\nfn pad_using() {\n    it::assert_equal((0..0).pad_using(1, |_| 1), 1..2);\n\n    let v: Vec<usize> = vec![0, 1, 2];\n    let r = v.into_iter().pad_using(5, |n| n);\n    it::assert_equal(r, vec![0, 1, 2, 3, 4]);\n\n    let v: Vec<usize> = vec![0, 1, 2];\n    let r = v.into_iter().pad_using(1, |_| panic!());\n    it::assert_equal(r, vec![0, 1, 2]);\n}\n\n#[test]\nfn group_by() {\n    for (ch1, sub) in &\"AABBCCC\".chars().group_by(|&x| x) {\n        for ch2 in sub {\n            assert_eq!(ch1, ch2);\n        }\n    }\n\n    for (ch1, sub) in &\"AAABBBCCCCDDDD\".chars().group_by(|&x| x) {\n        for ch2 in sub {\n            assert_eq!(ch1, ch2);\n            if ch1 == 'C' {\n                break;\n            }\n        }\n    }\n\n    let toupper = |ch: &char| ch.to_uppercase().nth(0).unwrap();\n\n    // try all possible orderings\n    for indices in permutohedron::Heap::new(&mut [0, 1, 2, 3]) {\n        let groups = \"AaaBbbccCcDDDD\".chars().group_by(&toupper);\n        let mut subs = groups.into_iter().collect_vec();\n\n        for &idx in &indices[..] {\n            let (key, text) = match idx {\n                 0 => ('A', \"Aaa\".chars()),\n                 1 => ('B', \"Bbb\".chars()),\n                 2 => ('C', \"ccCc\".chars()),\n                 3 => ('D', \"DDDD\".chars()),\n                 _ => unreachable!(),\n            };\n            assert_eq!(key, subs[idx].0);\n            it::assert_equal(&mut subs[idx].1, text);\n        }\n    }\n\n    let groups = \"AAABBBCCCCDDDD\".chars().group_by(|&x| x);\n    let mut subs = groups.into_iter().map(|(_, g)| g).collect_vec();\n\n    let sd = subs.pop().unwrap();\n    let sc = subs.pop().unwrap();\n    let sb = subs.pop().unwrap();\n    let sa = subs.pop().unwrap();\n    for (a, b, c, d) in multizip((sa, sb, sc, sd)) {\n        assert_eq!(a, 'A');\n        assert_eq!(b, 'B');\n        assert_eq!(c, 'C');\n        assert_eq!(d, 'D');\n    }\n\n    // check that the key closure is called exactly n times\n    {\n        let mut ntimes = 0;\n        let text = \"AABCCC\";\n        for (_, sub) in &text.chars().group_by(|&x| { ntimes += 1; x}) {\n            for _ in sub {\n            }\n        }\n        assert_eq!(ntimes, text.len());\n    }\n\n    {\n        let mut ntimes = 0;\n        let text = \"AABCCC\";\n        for _ in &text.chars().group_by(|&x| { ntimes += 1; x}) {\n        }\n        assert_eq!(ntimes, text.len());\n    }\n\n    {\n        let text = \"ABCCCDEEFGHIJJKK\";\n        let gr = text.chars().group_by(|&x| x);\n        it::assert_equal(gr.into_iter().flat_map(|(_, sub)| sub), text.chars());\n    }\n}\n\n#[test]\nfn group_by_lazy_2() {\n    let data = vec![0, 1];\n    let groups = data.iter().group_by(|k| *k);\n    let gs = groups.into_iter().collect_vec();\n    it::assert_equal(data.iter(), gs.into_iter().flat_map(|(_k, g)| g));\n\n    let data = vec![0, 1, 1, 0, 0];\n    let groups = data.iter().group_by(|k| *k);\n    let mut gs = groups.into_iter().collect_vec();\n    gs[1..].reverse();\n    it::assert_equal(&[0, 0, 0, 1, 1], gs.into_iter().flat_map(|(_, g)| g));\n\n    let grouper = data.iter().group_by(|k| *k);\n    let mut groups = Vec::new();\n    for (k, group) in &grouper {\n        if *k == 1 {\n            groups.push(group);\n        }\n    }\n    it::assert_equal(&mut groups[0], &[1, 1]);\n\n    let data = vec![0, 0, 0, 1, 1, 0, 0, 2, 2, 3, 3];\n    let grouper = data.iter().group_by(|k| *k);\n    let mut groups = Vec::new();\n    for (i, (_, group)) in grouper.into_iter().enumerate() {\n        if i < 2 {\n            groups.push(group);\n        } else if i < 4 {\n            for _ in group {\n            }\n        } else {\n            groups.push(group);\n        }\n    }\n    it::assert_equal(&mut groups[0], &[0, 0, 0]);\n    it::assert_equal(&mut groups[1], &[1, 1]);\n    it::assert_equal(&mut groups[2], &[3, 3]);\n\n    // use groups as chunks\n    let data = vec![0, 0, 0, 1, 1, 0, 0, 2, 2, 3, 3];\n    let mut i = 0;\n    let grouper = data.iter().group_by(move |_| { let k = i / 3; i += 1; k });\n    for (i, group) in &grouper {\n        match i {\n            0 => it::assert_equal(group, &[0, 0, 0]),\n            1 => it::assert_equal(group, &[1, 1, 0]),\n            2 => it::assert_equal(group, &[0, 2, 2]),\n            3 => it::assert_equal(group, &[3, 3]),\n            _ => unreachable!(),\n        }\n    }\n}\n\n#[test]\nfn group_by_lazy_3() {\n    // test consuming each group on the lap after it was produced\n    let data = vec![0, 0, 0, 1, 1, 0, 0, 1, 1, 2, 2];\n    let grouper = data.iter().group_by(|elt| *elt);\n    let mut last = None;\n    for (key, group) in &grouper {\n        if let Some(gr) = last.take() {\n            for elt in gr {\n                assert!(elt != key && i32::abs(elt - key) == 1);\n            }\n        }\n        last = Some(group);\n    }\n}\n\n#[test]\nfn chunks() {\n    let data = vec![0, 0, 0, 1, 1, 0, 0, 2, 2, 3, 3];\n    let grouper = data.iter().chunks(3);\n    for (i, chunk) in grouper.into_iter().enumerate() {\n        match i {\n            0 => it::assert_equal(chunk, &[0, 0, 0]),\n            1 => it::assert_equal(chunk, &[1, 1, 0]),\n            2 => it::assert_equal(chunk, &[0, 2, 2]),\n            3 => it::assert_equal(chunk, &[3, 3]),\n            _ => unreachable!(),\n        }\n    }\n}\n\n#[test]\nfn concat_empty() {\n    let data: Vec<Vec<()>> = Vec::new();\n    assert_eq!(data.into_iter().concat(), Vec::new())\n}\n\n#[test]\nfn concat_non_empty() {\n    let data = vec![vec![1,2,3], vec![4,5,6], vec![7,8,9]];\n    assert_eq!(data.into_iter().concat(), vec![1,2,3,4,5,6,7,8,9])\n}\n\n#[test]\nfn combinations() {\n    assert!((1..3).combinations(5).next().is_none());\n\n    let it = (1..3).combinations(2);\n    it::assert_equal(it, vec![\n        vec![1, 2],\n        ]);\n\n    let it = (1..5).combinations(2);\n    it::assert_equal(it, vec![\n        vec![1, 2],\n        vec![1, 3],\n        vec![1, 4],\n        vec![2, 3],\n        vec![2, 4],\n        vec![3, 4],\n        ]);\n\n    it::assert_equal((0..0).tuple_combinations::<(_, _)>(), <Vec<_>>::new());\n    it::assert_equal((0..1).tuple_combinations::<(_, _)>(), <Vec<_>>::new());\n    it::assert_equal((0..2).tuple_combinations::<(_, _)>(), vec![(0, 1)]);\n\n    it::assert_equal((0..0).combinations(2), <Vec<Vec<_>>>::new());\n    it::assert_equal((0..1).combinations(1), vec![vec![0]]);\n    it::assert_equal((0..2).combinations(1), vec![vec![0], vec![1]]);\n    it::assert_equal((0..2).combinations(2), vec![vec![0, 1]]);\n}\n\n#[test]\nfn combinations_of_too_short() {\n    for i in 1..10 {\n        assert!((0..0).combinations(i).next().is_none());\n        assert!((0..i - 1).combinations(i).next().is_none());\n    }\n}\n\n\n#[test]\nfn combinations_zero() {\n    it::assert_equal((1..3).combinations(0), vec![vec![]]);\n    it::assert_equal((0..0).combinations(0), vec![vec![]]);\n}\n\n#[test]\nfn permutations_zero() {\n    it::assert_equal((1..3).permutations(0), vec![vec![]]);\n    it::assert_equal((0..0).permutations(0), vec![vec![]]);\n}\n\n#[test]\nfn combinations_with_replacement() {\n    // Pool smaller than n\n    it::assert_equal((0..1).combinations_with_replacement(2), vec![vec![0, 0]]);\n    // Pool larger than n\n    it::assert_equal(\n        (0..3).combinations_with_replacement(2),\n        vec![\n            vec![0, 0],\n            vec![0, 1],\n            vec![0, 2],\n            vec![1, 1],\n            vec![1, 2],\n            vec![2, 2],\n        ],\n    );\n    // Zero size\n    it::assert_equal(\n        (0..3).combinations_with_replacement(0),\n        vec![vec![]],\n    );\n    // Zero size on empty pool\n    it::assert_equal(\n        (0..0).combinations_with_replacement(0),\n        vec![vec![]],\n    );\n    // Empty pool\n    it::assert_equal(\n        (0..0).combinations_with_replacement(2),\n        <Vec<Vec<_>>>::new(),\n    );\n}\n\n#[test]\nfn diff_mismatch() {\n    let a = vec![1, 2, 3, 4];\n    let b = vec![1.0, 5.0, 3.0, 4.0];\n    let b_map = b.into_iter().map(|f| f as i32);\n    let diff = it::diff_with(a.iter(), b_map, |a, b| *a == b);\n\n    assert!(match diff {\n        Some(it::Diff::FirstMismatch(1, _, from_diff)) =>\n            from_diff.collect::<Vec<_>>() == vec![5, 3, 4],\n        _ => false,\n    });\n}\n\n#[test]\nfn diff_longer() {\n    let a = vec![1, 2, 3, 4];\n    let b = vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0];\n    let b_map = b.into_iter().map(|f| f as i32);\n    let diff = it::diff_with(a.iter(), b_map, |a, b| *a == b);\n\n    assert!(match diff {\n        Some(it::Diff::Longer(_, remaining)) =>\n            remaining.collect::<Vec<_>>() == vec![5, 6],\n        _ => false,\n    });\n}\n\n#[test]\nfn diff_shorter() {\n    let a = vec![1, 2, 3, 4];\n    let b = vec![1.0, 2.0];\n    let b_map = b.into_iter().map(|f| f as i32);\n    let diff = it::diff_with(a.iter(), b_map, |a, b| *a == b);\n\n    assert!(match diff {\n        Some(it::Diff::Shorter(len, _)) => len == 2,\n        _ => false,\n    });\n}\n\n#[test]\nfn minmax() {\n    use std::cmp::Ordering;\n    use crate::it::MinMaxResult;\n\n    // A peculiar type: Equality compares both tuple items, but ordering only the\n    // first item.  This is so we can check the stability property easily.\n    #[derive(Clone, Debug, PartialEq, Eq)]\n    struct Val(u32, u32);\n\n    impl PartialOrd<Val> for Val {\n        fn partial_cmp(&self, other: &Val) -> Option<Ordering> {\n            self.0.partial_cmp(&other.0)\n        }\n    }\n\n    impl Ord for Val {\n        fn cmp(&self, other: &Val) -> Ordering {\n            self.0.cmp(&other.0)\n        }\n    }\n\n    assert_eq!(None::<Option<u32>>.iter().minmax(), MinMaxResult::NoElements);\n\n    assert_eq!(Some(1u32).iter().minmax(), MinMaxResult::OneElement(&1));\n\n    let data = vec![Val(0, 1), Val(2, 0), Val(0, 2), Val(1, 0), Val(2, 1)];\n\n    let minmax = data.iter().minmax();\n    assert_eq!(minmax, MinMaxResult::MinMax(&Val(0, 1), &Val(2, 1)));\n\n    let (min, max) = data.iter().minmax_by_key(|v| v.1).into_option().unwrap();\n    assert_eq!(min, &Val(2, 0));\n    assert_eq!(max, &Val(0, 2));\n\n    let (min, max) = data.iter().minmax_by(|x, y| x.1.cmp(&y.1)).into_option().unwrap();\n    assert_eq!(min, &Val(2, 0));\n    assert_eq!(max, &Val(0, 2));\n}\n\n#[test]\nfn format() {\n    let data = [0, 1, 2, 3];\n    let ans1 = \"0, 1, 2, 3\";\n    let ans2 = \"0--1--2--3\";\n\n    let t1 = format!(\"{}\", data.iter().format(\", \"));\n    assert_eq!(t1, ans1);\n    let t2 = format!(\"{:?}\", data.iter().format(\"--\"));\n    assert_eq!(t2, ans2);\n\n    let dataf = [1.1, 2.71828, -22.];\n    let t3 = format!(\"{:.2e}\", dataf.iter().format(\", \"));\n    assert_eq!(t3, \"1.10e0, 2.72e0, -2.20e1\");\n}\n\n#[test]\nfn while_some() {\n    let ns = (1..10).map(|x| if x % 5 != 0 { Some(x) } else { None })\n                    .while_some();\n    it::assert_equal(ns, vec![1, 2, 3, 4]);\n}\n\n#[allow(deprecated)]\n#[test]\nfn fold_while() {\n    let mut iterations = 0;\n    let vec = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    let sum = vec.into_iter().fold_while(0, |acc, item| {\n        iterations += 1;\n        let new_sum = acc.clone() + item;\n        if new_sum <= 20 {\n            FoldWhile::Continue(new_sum)\n        } else {\n            FoldWhile::Done(acc)\n        }\n    }).into_inner();\n    assert_eq!(iterations, 6);\n    assert_eq!(sum, 15);\n}\n\n#[test]\nfn tree_fold1() {\n    let x = [\n        \"\",\n        \"0\",\n        \"0 1 x\",\n        \"0 1 x 2 x\",\n        \"0 1 x 2 3 x x\",\n        \"0 1 x 2 3 x x 4 x\",\n        \"0 1 x 2 3 x x 4 5 x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 9 x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 9 x 10 x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 9 x 10 11 x x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 9 x 10 11 x x 12 x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 9 x 10 11 x x 12 13 x x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 9 x 10 11 x x 12 13 x 14 x x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 9 x 10 11 x x 12 13 x 14 15 x x x x\",\n    ];\n    for (i, &s) in x.iter().enumerate() {\n        let expected = if s == \"\" { None } else { Some(s.to_string()) };\n        let num_strings = (0..i).map(|x| x.to_string());\n        let actual = num_strings.tree_fold1(|a, b| format!(\"{} {} x\", a, b));\n        assert_eq!(actual, expected);\n    }\n}\n","traces":[{"line":15,"address":[4328928,4328992],"length":1,"stats":{"Line":3},"fn_name":"product3"},{"line":16,"address":[4329007,4328935],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[4329236,4329430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[4329361],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[4330135,4329846,4329733,4329955],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[4330320,4329999,4330140],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[4330184,4330613,4330325],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[4330369,4330618,4331248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[4331117,4329901,4330659],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[4331408,4331548],"length":1,"stats":{"Line":3},"fn_name":"interleave_shortest"},{"line":33,"address":[4331415,4331563],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[4331666,4331581],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[4331674,4335983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[4331879,4332106],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[4332454,4331992],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[4333044],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[4333191,4333124],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[4336117,4333199],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[4333631,4333404],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4333979,4333517],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[4334568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[4334600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[4334648],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[4334879,4334760,4334946],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[4335248,4334895],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[4335261],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[4335283],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[4335392,4335535,4335511],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[4336544],"length":1,"stats":{"Line":3},"fn_name":"unique_by"},{"line":59,"address":[4336600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4336734],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[4336794],"length":1,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[4692448,4692465],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":63,"address":[4337071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[4337131],"length":1,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[4337264],"length":1,"stats":{"Line":3},"fn_name":"unique"},{"line":69,"address":[4337271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[4337348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[4337392],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[4337524],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[4337714],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[4337758],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[4337899],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[4337921],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[4337943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[4338051],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[4338205],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[4338227],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[4338522,4338368],"length":1,"stats":{"Line":3},"fn_name":"intersperse"},{"line":86,"address":[4338396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[4338483,4338553],"length":1,"stats":{"Line":4},"fn_name":null},{"line":88,"address":[4338648],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[4338860,4338720],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[4339203],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[4339247],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[4339474,4339389,4339495],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[4339648,4339834],"length":1,"stats":{"Line":3},"fn_name":"dedup"},{"line":98,"address":[4339655],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[4339743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[4339798,4339849],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[4339929],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[4339984],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[4339995],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[4340103],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[4340191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[4340246],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[4340272,4340340],"length":1,"stats":{"Line":4},"fn_name":null},{"line":109,"address":[4340379,4340522],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[4340864,4341560],"length":1,"stats":{"Line":3},"fn_name":"dedup_by"},{"line":114,"address":[4340871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[4341271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[4341575,4341521],"length":1,"stats":{"Line":4},"fn_name":null},{"line":117,"address":[4341658],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[4341908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[4341958],"length":1,"stats":{"Line":3},"fn_name":null},{"line":121,"address":[4342066],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[4342466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[4342716],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[4342810,4342742],"length":1,"stats":{"Line":6},"fn_name":null},{"line":125,"address":[4342849,4342992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[4343328],"length":1,"stats":{"Line":3},"fn_name":"dedup_with_count"},{"line":130,"address":[4343363],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[4343427],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[4343687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[4343824],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[4343879],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[4343931],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[4344080],"length":1,"stats":{"Line":3},"fn_name":"dedup_by_with_count"},{"line":144,"address":[4344122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[4344536],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[4344796],"length":1,"stats":{"Line":3},"fn_name":null},{"line":149,"address":[4344933],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[4345183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[4345235],"length":1,"stats":{"Line":3},"fn_name":null},{"line":156,"address":[4345376,4345419],"length":1,"stats":{"Line":3},"fn_name":"all_equal"},{"line":157,"address":[4345434,4345383,4345487],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[4345517,4345458,4345570],"length":1,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[4345541,4345600,4345655],"length":1,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[4345626,4345685,4345741],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[4346269,4346158,4345716,4345771,4346331,4346415],"length":1,"stats":{"Line":7},"fn_name":null},{"line":162,"address":[4346393,4346174,4346228],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[4346496,4346613],"length":1,"stats":{"Line":3},"fn_name":"test_put_back_n"},{"line":168,"address":[4346503],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[4346638,4346583],"length":1,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[4346686],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[4346698],"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[4346715],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[4346729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[4346943,4346736],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[4347170,4347024],"length":1,"stats":{"Line":3},"fn_name":"tee"},{"line":179,"address":[4347031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[4347201,4347131],"length":1,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[4347380,4347319,4347539],"length":1,"stats":{"Line":2},"fn_name":null},{"line":182,"address":[4348043,4347884,4347515],"length":1,"stats":{"Line":2},"fn_name":null},{"line":183,"address":[4348019,4348547,4348388],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[4348892,4349051,4348523],"length":1,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[4349555,4349027,4349396],"length":1,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[4349900,4350059,4349531],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[4350035,4350563,4350404],"length":1,"stats":{"Line":2},"fn_name":null},{"line":188,"address":[4350539,4350908,4351067],"length":1,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[4351571,4351043,4351412],"length":1,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[4351916,4351547,4352075],"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[4352420,4352579,4352051],"length":1,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[4352555,4352924,4353083],"length":1,"stats":{"Line":2},"fn_name":null},{"line":193,"address":[4353059,4353428,4353594],"length":1,"stats":{"Line":2},"fn_name":null},{"line":195,"address":[4353568,4353948],"length":1,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[4354078,4354211,4355052],"length":1,"stats":{"Line":2},"fn_name":null},{"line":197,"address":[4354289,4355093],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[4354472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[4354617,4355186,4354716],"length":1,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[4355545,4355376],"length":1,"stats":{"Line":3},"fn_name":"test_rciter"},{"line":206,"address":[4355383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[4355506,4355576],"length":1,"stats":{"Line":2},"fn_name":null},{"line":209,"address":[4355642],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[4355876,4355689],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[4356221,4355852,4356398],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[4356348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[4356909,4356752,4356877],"length":1,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[4356899,4357255,4357379],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[4357369,4357725,4357849],"length":1,"stats":{"Line":2},"fn_name":null},{"line":216,"address":[4357839,4358344,4358195],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[4358651,4358293],"length":1,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[4358675],"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[4358882,4358739,4358858],"length":1,"stats":{"Line":2},"fn_name":null},{"line":226,"address":[4359456,4359562],"length":1,"stats":{"Line":3},"fn_name":"trait_pointers"},{"line":233,"address":[4693680],"length":1,"stats":{"Line":1},"fn_name":"next<i32,Iterator>"},{"line":235,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":239,"address":[4359560,4359463,4359585],"length":1,"stats":{"Line":3},"fn_name":null},{"line":240,"address":[4359859,4359616,4359659],"length":1,"stats":{"Line":2},"fn_name":null},{"line":244,"address":[4359786],"length":1,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[4359818,4360204,4360395],"length":1,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[4360331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[4360734,4360889,4360371],"length":1,"stats":{"Line":2},"fn_name":null},{"line":252,"address":[4361199,4360855,4361317],"length":1,"stats":{"Line":4},"fn_name":null},{"line":253,"address":[4361291],"length":1,"stats":{"Line":3},"fn_name":null},{"line":258,"address":[4361664,4361943],"length":1,"stats":{"Line":3},"fn_name":"merge_by"},{"line":259,"address":[4361671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[4361968],"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[4362209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[4362637,4362724],"length":1,"stats":{"Line":4},"fn_name":null},{"line":263,"address":[4362803],"length":1,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[4363072,4363139],"length":1,"stats":{"Line":3},"fn_name":"merge_by_btree"},{"line":269,"address":[4363079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[4363154],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[4363183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[4363217],"length":1,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[4363224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[4363261],"length":1,"stats":{"Line":1},"fn_name":null},{"line":275,"address":[4364012,4363290],"length":1,"stats":{"Line":3},"fn_name":null},{"line":276,"address":[4363474],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[4363768,4364067],"length":1,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[4364208],"length":1,"stats":{"Line":3},"fn_name":"kmerge"},{"line":283,"address":[4364212],"length":1,"stats":{"Line":3},"fn_name":null},{"line":285,"address":[4364249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[4364320],"length":1,"stats":{"Line":3},"fn_name":"kmerge_2"},{"line":291,"address":[4364327],"length":1,"stats":{"Line":3},"fn_name":null},{"line":293,"address":[4364418],"length":1,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[4364544,4364590],"length":1,"stats":{"Line":3},"fn_name":"kmerge_empty"},{"line":298,"address":[4364551],"length":1,"stats":{"Line":3},"fn_name":null},{"line":299,"address":[4364605],"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[4365150,4365104],"length":1,"stats":{"Line":3},"fn_name":"kmerge_size_hint"},{"line":304,"address":[4365111],"length":1,"stats":{"Line":3},"fn_name":null},{"line":305,"address":[4365165],"length":1,"stats":{"Line":1},"fn_name":null},{"line":309,"address":[4365694,4365648],"length":1,"stats":{"Line":3},"fn_name":"kmerge_empty_size_hint"},{"line":310,"address":[4365655],"length":1,"stats":{"Line":3},"fn_name":null},{"line":311,"address":[4365709],"length":1,"stats":{"Line":1},"fn_name":null},{"line":315,"address":[4366279,4366192],"length":1,"stats":{"Line":3},"fn_name":"join"},{"line":316,"address":[4366203],"length":1,"stats":{"Line":1},"fn_name":null},{"line":317,"address":[4366236],"length":1,"stats":{"Line":1},"fn_name":null},{"line":318,"address":[4366247],"length":1,"stats":{"Line":1},"fn_name":null},{"line":320,"address":[4366307,4366423],"length":1,"stats":{"Line":2},"fn_name":null},{"line":321,"address":[4366910],"length":1,"stats":{"Line":1},"fn_name":null},{"line":322,"address":[4367460],"length":1,"stats":{"Line":1},"fn_name":null},{"line":326,"address":[4368308,4368112],"length":1,"stats":{"Line":3},"fn_name":"sorted_by"},{"line":327,"address":[4368126],"length":1,"stats":{"Line":3},"fn_name":null},{"line":328,"address":[4694505],"length":1,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[4368595,4368323,4368210],"length":1,"stats":{"Line":1},"fn_name":null},{"line":332,"address":[4368372],"length":1,"stats":{"Line":3},"fn_name":null},{"line":333,"address":[4368618,4368421],"length":1,"stats":{"Line":1},"fn_name":null},{"line":337,"address":[4368884,4368688],"length":1,"stats":{"Line":3},"fn_name":"sorted_by_key"},{"line":338,"address":[4368702],"length":1,"stats":{"Line":3},"fn_name":null},{"line":339,"address":[4368786,4368899,4369171],"length":1,"stats":{"Line":1},"fn_name":null},{"line":341,"address":[4368948],"length":1,"stats":{"Line":3},"fn_name":null},{"line":342,"address":[4368997,4369194],"length":1,"stats":{"Line":1},"fn_name":null},{"line":346,"address":[4369264,4369337],"length":1,"stats":{"Line":3},"fn_name":"test_multipeek"},{"line":347,"address":[4369277],"length":1,"stats":{"Line":1},"fn_name":null},{"line":349,"address":[4369453,4369360],"length":1,"stats":{"Line":4},"fn_name":null},{"line":350,"address":[4369507],"length":1,"stats":{"Line":1},"fn_name":null},{"line":352,"address":[4370083],"length":1,"stats":{"Line":3},"fn_name":null},{"line":353,"address":[4370372,4370410,4370223],"length":1,"stats":{"Line":2},"fn_name":null},{"line":354,"address":[4370386,4370755,4370908],"length":1,"stats":{"Line":2},"fn_name":null},{"line":355,"address":[4370890,4371254,4371394],"length":1,"stats":{"Line":2},"fn_name":null},{"line":356,"address":[4371740,4371886,4371376],"length":1,"stats":{"Line":2},"fn_name":null},{"line":357,"address":[4372384,4372231,4371862],"length":1,"stats":{"Line":2},"fn_name":null},{"line":358,"address":[4372730,4372366,4372870],"length":1,"stats":{"Line":2},"fn_name":null},{"line":359,"address":[4372852,4373216,4373356],"length":1,"stats":{"Line":2},"fn_name":null},{"line":360,"address":[4373338,4373702,4373842],"length":1,"stats":{"Line":2},"fn_name":null},{"line":361,"address":[4374334,4373824,4374188],"length":1,"stats":{"Line":2},"fn_name":null},{"line":362,"address":[4374310,4374679,4374838],"length":1,"stats":{"Line":2},"fn_name":null},{"line":363,"address":[4375183,4374814,4375336],"length":1,"stats":{"Line":2},"fn_name":null},{"line":364,"address":[4375822,4375682,4375318],"length":1,"stats":{"Line":2},"fn_name":null},{"line":365,"address":[4375804,4376314,4376168],"length":1,"stats":{"Line":2},"fn_name":null},{"line":366,"address":[4376818,4376290,4376659],"length":1,"stats":{"Line":2},"fn_name":null},{"line":367,"address":[4377163,4376794,4377307],"length":1,"stats":{"Line":2},"fn_name":null},{"line":368,"address":[4377292,4377740,4377614],"length":1,"stats":{"Line":2},"fn_name":null},{"line":373,"address":[4378210,4378128],"length":1,"stats":{"Line":3},"fn_name":"test_multipeek_reset"},{"line":374,"address":[4378135],"length":1,"stats":{"Line":1},"fn_name":null},{"line":376,"address":[4378225,4378179],"length":1,"stats":{"Line":2},"fn_name":null},{"line":377,"address":[4378262,4378411,4378449],"length":1,"stats":{"Line":2},"fn_name":null},{"line":378,"address":[4378947,4378425,4378794],"length":1,"stats":{"Line":2},"fn_name":null},{"line":379,"address":[4379293,4379433,4378929],"length":1,"stats":{"Line":2},"fn_name":null},{"line":380,"address":[4379415,4379779,4379911],"length":1,"stats":{"Line":2},"fn_name":null},{"line":381,"address":[4379901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":382,"address":[4380257,4380414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":383,"address":[4380720,4380396,4380856],"length":1,"stats":{"Line":2},"fn_name":null},{"line":387,"address":[4381200,4381281],"length":1,"stats":{"Line":3},"fn_name":"test_multipeek_peeking_next"},{"line":389,"address":[4381213],"length":1,"stats":{"Line":1},"fn_name":null},{"line":391,"address":[4381304,4381397],"length":1,"stats":{"Line":4},"fn_name":null},{"line":392,"address":[4381459,4381626,4381664],"length":1,"stats":{"Line":4},"fn_name":null},{"line":393,"address":[4382009,4382162,4381640],"length":1,"stats":{"Line":2},"fn_name":null},{"line":394,"address":[4382144,4382508,4382648],"length":1,"stats":{"Line":2},"fn_name":null},{"line":395,"address":[4382630,4382994,4383140],"length":1,"stats":{"Line":2},"fn_name":null},{"line":396,"address":[4383116,4383485,4383638],"length":1,"stats":{"Line":4},"fn_name":null},{"line":397,"address":[4383620,4384130,4383984],"length":1,"stats":{"Line":2},"fn_name":null},{"line":398,"address":[4384106,4384634,4384475],"length":1,"stats":{"Line":4},"fn_name":null},{"line":399,"address":[4385132,4384610,4384979],"length":1,"stats":{"Line":4},"fn_name":null},{"line":400,"address":[4385618,4385114,4385478],"length":1,"stats":{"Line":2},"fn_name":null},{"line":401,"address":[4385600,4385964,4386110],"length":1,"stats":{"Line":2},"fn_name":null},{"line":402,"address":[4386086,4386608,4386455],"length":1,"stats":{"Line":4},"fn_name":null},{"line":403,"address":[4387100,4386954,4386590],"length":1,"stats":{"Line":2},"fn_name":null},{"line":404,"address":[4387445,4387076,4387604],"length":1,"stats":{"Line":4},"fn_name":null},{"line":405,"address":[4387949,4387580,4388102],"length":1,"stats":{"Line":4},"fn_name":null},{"line":406,"address":[4388448,4388588,4388084],"length":1,"stats":{"Line":2},"fn_name":null},{"line":407,"address":[4388934,4388570,4389080],"length":1,"stats":{"Line":2},"fn_name":null},{"line":408,"address":[4389056,4389569,4389425],"length":1,"stats":{"Line":2},"fn_name":null},{"line":409,"address":[4389554,4389876,4390002],"length":1,"stats":{"Line":2},"fn_name":null},{"line":413,"address":[4390368,4390441],"length":1,"stats":{"Line":3},"fn_name":"test_peek_nth"},{"line":414,"address":[4390381],"length":1,"stats":{"Line":1},"fn_name":null},{"line":416,"address":[4390464,4390557],"length":1,"stats":{"Line":4},"fn_name":null},{"line":417,"address":[4390611],"length":1,"stats":{"Line":1},"fn_name":null},{"line":419,"address":[4391187],"length":1,"stats":{"Line":3},"fn_name":null},{"line":421,"address":[4391516,4391480,4391331],"length":1,"stats":{"Line":2},"fn_name":null},{"line":422,"address":[4391498,4392008,4391862],"length":1,"stats":{"Line":2},"fn_name":null},{"line":423,"address":[4392510,4391984,4392353],"length":1,"stats":{"Line":2},"fn_name":null},{"line":425,"address":[4392856,4393001,4392492],"length":1,"stats":{"Line":2},"fn_name":null},{"line":426,"address":[4392983,4393347,4393493],"length":1,"stats":{"Line":2},"fn_name":null},{"line":427,"address":[4393838,4393469,4393995],"length":1,"stats":{"Line":2},"fn_name":null},{"line":429,"address":[4393977,4394341,4394486],"length":1,"stats":{"Line":2},"fn_name":null},{"line":430,"address":[4394977,4394468,4394832],"length":1,"stats":{"Line":2},"fn_name":null},{"line":431,"address":[4395468,4394959,4395323],"length":1,"stats":{"Line":2},"fn_name":null},{"line":432,"address":[4395814,4395960,4395450],"length":1,"stats":{"Line":2},"fn_name":null},{"line":434,"address":[4396305,4396464,4395936],"length":1,"stats":{"Line":2},"fn_name":null},{"line":435,"address":[4396966,4396440,4396809],"length":1,"stats":{"Line":2},"fn_name":null},{"line":437,"address":[4396948,4397312,4397457],"length":1,"stats":{"Line":2},"fn_name":null},{"line":438,"address":[4397803,4397439,4397949],"length":1,"stats":{"Line":2},"fn_name":null},{"line":439,"address":[4398453,4397925,4398294],"length":1,"stats":{"Line":2},"fn_name":null},{"line":440,"address":[4398955,4398798,4398429],"length":1,"stats":{"Line":2},"fn_name":null},{"line":442,"address":[4398937,4399295,4399431],"length":1,"stats":{"Line":2},"fn_name":null},{"line":443,"address":[4399416,4399738,4399864],"length":1,"stats":{"Line":2},"fn_name":null},{"line":447,"address":[4400337,4400256],"length":1,"stats":{"Line":3},"fn_name":"test_peek_nth_peeking_next"},{"line":449,"address":[4400269],"length":1,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[4400360,4400453],"length":1,"stats":{"Line":4},"fn_name":null},{"line":452,"address":[4400515,4400682,4400720],"length":1,"stats":{"Line":4},"fn_name":null},{"line":453,"address":[4401222,4401065,4400696],"length":1,"stats":{"Line":2},"fn_name":null},{"line":455,"address":[4401568,4401713,4401204],"length":1,"stats":{"Line":2},"fn_name":null},{"line":456,"address":[4402205,4401695,4402059],"length":1,"stats":{"Line":2},"fn_name":null},{"line":457,"address":[4402550,4402181,4402703],"length":1,"stats":{"Line":4},"fn_name":null},{"line":458,"address":[4403195,4402685,4403049],"length":1,"stats":{"Line":2},"fn_name":null},{"line":460,"address":[4403540,4403699,4403171],"length":1,"stats":{"Line":4},"fn_name":null},{"line":461,"address":[4403675,4404201,4404044],"length":1,"stats":{"Line":4},"fn_name":null},{"line":462,"address":[4404692,4404547,4404183],"length":1,"stats":{"Line":2},"fn_name":null},{"line":463,"address":[4405038,4404674,4405184],"length":1,"stats":{"Line":2},"fn_name":null},{"line":465,"address":[4405529,4405160,4405682],"length":1,"stats":{"Line":4},"fn_name":null},{"line":466,"address":[4405664,4406028,4406174],"length":1,"stats":{"Line":2},"fn_name":null},{"line":468,"address":[4406678,4406519,4406150],"length":1,"stats":{"Line":4},"fn_name":null},{"line":469,"address":[4407180,4407023,4406654],"length":1,"stats":{"Line":4},"fn_name":null},{"line":470,"address":[4407162,4407526,4407671],"length":1,"stats":{"Line":2},"fn_name":null},{"line":471,"address":[4408163,4407653,4408017],"length":1,"stats":{"Line":2},"fn_name":null},{"line":472,"address":[4408646,4408139,4408502],"length":1,"stats":{"Line":2},"fn_name":null},{"line":473,"address":[4408953,4408631,4409079],"length":1,"stats":{"Line":2},"fn_name":null},{"line":477,"address":[4409440,4409504],"length":1,"stats":{"Line":3},"fn_name":"pad_using"},{"line":478,"address":[4409519,4409447],"length":1,"stats":{"Line":4},"fn_name":null},{"line":480,"address":[4409553],"length":1,"stats":{"Line":1},"fn_name":null},{"line":481,"address":[4409612],"length":1,"stats":{"Line":3},"fn_name":null},{"line":482,"address":[4410245,4409695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":484,"address":[4409893],"length":1,"stats":{"Line":1},"fn_name":null},{"line":485,"address":[4409955],"length":1,"stats":{"Line":1},"fn_name":null},{"line":486,"address":[4410271,4410050],"length":1,"stats":{"Line":1},"fn_name":null},{"line":490,"address":[4410352,4410467],"length":1,"stats":{"Line":3},"fn_name":"group_by"},{"line":491,"address":[4419825,4419945,4410887,4410482,4411542,4410372],"length":1,"stats":{"Line":7},"fn_name":null},{"line":492,"address":[4419879,4411052,4410905,4411000,4411191],"length":1,"stats":{"Line":4},"fn_name":null},{"line":493,"address":[4411196,4411096],"length":1,"stats":{"Line":1},"fn_name":null},{"line":497,"address":[4420121,4411991,4412677,4420001,4411554],"length":1,"stats":{"Line":6},"fn_name":null},{"line":498,"address":[4412104,4420055,4412659,4412009],"length":1,"stats":{"Line":4},"fn_name":null},{"line":499,"address":[4412321,4412187],"length":1,"stats":{"Line":1},"fn_name":null},{"line":500,"address":[4412302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":501,"address":[4412664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":506,"address":[4696222,4696208],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":509,"address":[4414580,4412915,4412682],"length":1,"stats":{"Line":2},"fn_name":null},{"line":510,"address":[4413180],"length":1,"stats":{"Line":1},"fn_name":null},{"line":511,"address":[4413254],"length":1,"stats":{"Line":1},"fn_name":null},{"line":513,"address":[4413518,4414562,4413408,4413323],"length":1,"stats":{"Line":3},"fn_name":null},{"line":514,"address":[4413814,4413897,4413731,4413977],"length":1,"stats":{"Line":4},"fn_name":null},{"line":515,"address":[4413653,4413571],"length":1,"stats":{"Line":2},"fn_name":null},{"line":516,"address":[4413736],"length":1,"stats":{"Line":1},"fn_name":null},{"line":517,"address":[4413819],"length":1,"stats":{"Line":1},"fn_name":null},{"line":518,"address":[4413899],"length":1,"stats":{"Line":1},"fn_name":null},{"line":521,"address":[4414186,4414023],"length":1,"stats":{"Line":1},"fn_name":null},{"line":522,"address":[4414152,4414532],"length":1,"stats":{"Line":2},"fn_name":null},{"line":526,"address":[4414585,4412881],"length":1,"stats":{"Line":4},"fn_name":null},{"line":527,"address":[4414694,4414622],"length":1,"stats":{"Line":4},"fn_name":null},{"line":529,"address":[4414717,4414762],"length":1,"stats":{"Line":2},"fn_name":null},{"line":530,"address":[4414786],"length":1,"stats":{"Line":1},"fn_name":null},{"line":531,"address":[4414840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":532,"address":[4414894],"length":1,"stats":{"Line":1},"fn_name":null},{"line":533,"address":[4414924,4415367,4415323,4416950],"length":1,"stats":{"Line":3},"fn_name":null},{"line":534,"address":[4415528,4415724],"length":1,"stats":{"Line":1},"fn_name":null},{"line":535,"address":[4415625,4416168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":536,"address":[4416612,4416069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":537,"address":[4416513,4416955],"length":1,"stats":{"Line":1},"fn_name":null},{"line":542,"address":[4417293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":543,"address":[4417305],"length":1,"stats":{"Line":1},"fn_name":null},{"line":544,"address":[4417813,4420288,4417332,4418007,4420394],"length":1,"stats":{"Line":6},"fn_name":null},{"line":545,"address":[4417823,4417918,4420328,4417967],"length":1,"stats":{"Line":3},"fn_name":null},{"line":548,"address":[4418240,4418012],"length":1,"stats":{"Line":1},"fn_name":null},{"line":552,"address":[4418159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":553,"address":[4418171],"length":1,"stats":{"Line":1},"fn_name":null},{"line":554,"address":[4418576,4418198,4419004,4420476,4419019],"length":1,"stats":{"Line":6},"fn_name":null},{"line":556,"address":[4419228,4419024],"length":1,"stats":{"Line":1},"fn_name":null},{"line":560,"address":[4419165],"length":1,"stats":{"Line":1},"fn_name":null},{"line":561,"address":[4419556,4419192],"length":1,"stats":{"Line":4},"fn_name":null},{"line":562,"address":[4419621,4420483,4419571],"length":1,"stats":{"Line":4},"fn_name":null},{"line":567,"address":[4420960,4421077],"length":1,"stats":{"Line":3},"fn_name":"group_by_lazy_2"},{"line":568,"address":[4420967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":569,"address":[4421201,4421100],"length":1,"stats":{"Line":4},"fn_name":null},{"line":570,"address":[4421216,4421269],"length":1,"stats":{"Line":2},"fn_name":null},{"line":571,"address":[4421285],"length":1,"stats":{"Line":3},"fn_name":null},{"line":573,"address":[4421506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":574,"address":[4421680,4421576],"length":1,"stats":{"Line":4},"fn_name":null},{"line":575,"address":[4421695,4421748],"length":1,"stats":{"Line":2},"fn_name":null},{"line":576,"address":[4421756],"length":1,"stats":{"Line":1},"fn_name":null},{"line":577,"address":[4421830],"length":1,"stats":{"Line":3},"fn_name":null},{"line":579,"address":[4421946],"length":1,"stats":{"Line":3},"fn_name":null},{"line":580,"address":[4422047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":581,"address":[4424978,4422563,4422103,4422062,4425088,4422144],"length":1,"stats":{"Line":5},"fn_name":null},{"line":582,"address":[4422531,4425058],"length":1,"stats":{"Line":2},"fn_name":null},{"line":583,"address":[4422468],"length":1,"stats":{"Line":1},"fn_name":null},{"line":586,"address":[4422568,4422453],"length":1,"stats":{"Line":2},"fn_name":null},{"line":588,"address":[4422600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":589,"address":[4422712,4422816],"length":1,"stats":{"Line":4},"fn_name":null},{"line":590,"address":[4422831],"length":1,"stats":{"Line":1},"fn_name":null},{"line":591,"address":[4423625,4422884,4422846,4425176,4425276,4422938],"length":1,"stats":{"Line":5},"fn_name":null},{"line":592,"address":[4423318,4423615,4425248],"length":1,"stats":{"Line":3},"fn_name":null},{"line":593,"address":[4423263],"length":1,"stats":{"Line":1},"fn_name":null},{"line":594,"address":[4423250,4423611],"length":1,"stats":{"Line":2},"fn_name":null},{"line":595,"address":[4423381,4423575,4423527],"length":1,"stats":{"Line":2},"fn_name":null},{"line":598,"address":[4423323],"length":1,"stats":{"Line":1},"fn_name":null},{"line":601,"address":[4423630,4423235],"length":1,"stats":{"Line":2},"fn_name":null},{"line":602,"address":[4423662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":603,"address":[4423706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":606,"address":[4423747],"length":1,"stats":{"Line":1},"fn_name":null},{"line":607,"address":[4423851],"length":1,"stats":{"Line":1},"fn_name":null},{"line":608,"address":[4423932,4423870],"length":1,"stats":{"Line":4},"fn_name":null},{"line":609,"address":[4425450,4424670,4425332,4423986,4424044],"length":1,"stats":{"Line":4},"fn_name":null},{"line":610,"address":[4424652,4424454,4424521,4424588],"length":1,"stats":{"Line":4},"fn_name":null},{"line":611,"address":[4425394,4424392],"length":1,"stats":{"Line":2},"fn_name":null},{"line":612,"address":[4424459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":613,"address":[4424526],"length":1,"stats":{"Line":1},"fn_name":null},{"line":614,"address":[4424590],"length":1,"stats":{"Line":1},"fn_name":null},{"line":621,"address":[4425872,4426017],"length":1,"stats":{"Line":3},"fn_name":"group_by_lazy_3"},{"line":623,"address":[4425879],"length":1,"stats":{"Line":1},"fn_name":null},{"line":624,"address":[4426108,4426037],"length":1,"stats":{"Line":4},"fn_name":null},{"line":625,"address":[4426115],"length":1,"stats":{"Line":1},"fn_name":null},{"line":626,"address":[4426202,4427581,4427189,4427091,4426132],"length":1,"stats":{"Line":4},"fn_name":null},{"line":627,"address":[4427171,4426521],"length":1,"stats":{"Line":2},"fn_name":null},{"line":628,"address":[4426597,4426794,4426969,4426743],"length":1,"stats":{"Line":3},"fn_name":null},{"line":629,"address":[4426860,4426974],"length":1,"stats":{"Line":1},"fn_name":null},{"line":632,"address":[4427290,4427464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":637,"address":[4427760,4427897],"length":1,"stats":{"Line":3},"fn_name":"chunks"},{"line":638,"address":[4427767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":639,"address":[4427917,4427993],"length":1,"stats":{"Line":2},"fn_name":null},{"line":640,"address":[4428005,4428815,4428932,4428061,4428743],"length":1,"stats":{"Line":4},"fn_name":null},{"line":641,"address":[4428527,4428661,4428594,4428725],"length":1,"stats":{"Line":4},"fn_name":null},{"line":642,"address":[4428879,4428465],"length":1,"stats":{"Line":2},"fn_name":null},{"line":643,"address":[4428532],"length":1,"stats":{"Line":1},"fn_name":null},{"line":644,"address":[4428599],"length":1,"stats":{"Line":1},"fn_name":null},{"line":645,"address":[4428663],"length":1,"stats":{"Line":1},"fn_name":null},{"line":652,"address":[4429072,4429091],"length":1,"stats":{"Line":3},"fn_name":"concat_empty"},{"line":653,"address":[4429079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":654,"address":[4429106,4429210,4429326],"length":1,"stats":{"Line":2},"fn_name":null},{"line":658,"address":[4429696,4429778],"length":1,"stats":{"Line":3},"fn_name":"concat_non_empty"},{"line":659,"address":[4429713,4429793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":660,"address":[4430395,4430371,4430062,4430269],"length":1,"stats":{"Line":3},"fn_name":null},{"line":664,"address":[4430816,4430948],"length":1,"stats":{"Line":3},"fn_name":"combinations"},{"line":665,"address":[4430823,4431118,4430973],"length":1,"stats":{"Line":2},"fn_name":null},{"line":667,"address":[4431062],"length":1,"stats":{"Line":1},"fn_name":null},{"line":668,"address":[4431337,4431148],"length":1,"stats":{"Line":1},"fn_name":null},{"line":669,"address":[4431277],"length":1,"stats":{"Line":1},"fn_name":null},{"line":672,"address":[4431450],"length":1,"stats":{"Line":1},"fn_name":null},{"line":673,"address":[4431891,4432023,4431957,4431693,4431825,4431759,4431504],"length":1,"stats":{"Line":1},"fn_name":null},{"line":674,"address":[4431633],"length":1,"stats":{"Line":1},"fn_name":null},{"line":675,"address":[4431718],"length":1,"stats":{"Line":1},"fn_name":null},{"line":676,"address":[4431784],"length":1,"stats":{"Line":1},"fn_name":null},{"line":677,"address":[4431850],"length":1,"stats":{"Line":1},"fn_name":null},{"line":678,"address":[4431916],"length":1,"stats":{"Line":1},"fn_name":null},{"line":679,"address":[4431982],"length":1,"stats":{"Line":1},"fn_name":null},{"line":682,"address":[4432259,4433735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":683,"address":[4432370,4433776],"length":1,"stats":{"Line":1},"fn_name":null},{"line":684,"address":[4433817,4432481],"length":1,"stats":{"Line":1},"fn_name":null},{"line":686,"address":[4432675,4433843],"length":1,"stats":{"Line":1},"fn_name":null},{"line":687,"address":[4432791,4433884],"length":1,"stats":{"Line":1},"fn_name":null},{"line":688,"address":[4433910,4433053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":689,"address":[4433936,4433399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":693,"address":[4434469,4434416],"length":1,"stats":{"Line":3},"fn_name":"combinations_of_too_short"},{"line":694,"address":[4434423,4434489,4434989,4434550],"length":1,"stats":{"Line":3},"fn_name":null},{"line":695,"address":[4434582,4434777],"length":1,"stats":{"Line":1},"fn_name":null},{"line":696,"address":[4434747,4434807,4434994],"length":1,"stats":{"Line":2},"fn_name":null},{"line":702,"address":[4435207,4435136],"length":1,"stats":{"Line":3},"fn_name":"combinations_zero"},{"line":703,"address":[4435665,4435232,4435147],"length":1,"stats":{"Line":2},"fn_name":null},{"line":704,"address":[4435402,4435688],"length":1,"stats":{"Line":1},"fn_name":null},{"line":708,"address":[4435879,4435808],"length":1,"stats":{"Line":3},"fn_name":"permutations_zero"},{"line":709,"address":[4436355,4435904,4435819],"length":1,"stats":{"Line":2},"fn_name":null},{"line":710,"address":[4436378,4436092],"length":1,"stats":{"Line":1},"fn_name":null},{"line":714,"address":[4436496,4436592],"length":1,"stats":{"Line":3},"fn_name":"combinations_with_replacement"},{"line":716,"address":[4436617,4436503,4438188],"length":1,"stats":{"Line":2},"fn_name":null},{"line":719,"address":[4436815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":720,"address":[4437242,4436887,4437308,4437044,4436978,4437176,4437110],"length":1,"stats":{"Line":1},"fn_name":null},{"line":721,"address":[4436918],"length":1,"stats":{"Line":1},"fn_name":null},{"line":722,"address":[4437003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":723,"address":[4437069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":724,"address":[4437135],"length":1,"stats":{"Line":1},"fn_name":null},{"line":725,"address":[4437201],"length":1,"stats":{"Line":1},"fn_name":null},{"line":726,"address":[4437267],"length":1,"stats":{"Line":1},"fn_name":null},{"line":731,"address":[4437548],"length":1,"stats":{"Line":1},"fn_name":null},{"line":732,"address":[4437692,4437615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":736,"address":[4437809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":737,"address":[4437876,4437951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":741,"address":[4438064],"length":1,"stats":{"Line":1},"fn_name":null},{"line":742,"address":[4438134],"length":1,"stats":{"Line":1},"fn_name":null},{"line":747,"address":[4438624,4438712],"length":1,"stats":{"Line":3},"fn_name":"diff_mismatch"},{"line":748,"address":[4438631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":749,"address":[4438737],"length":1,"stats":{"Line":1},"fn_name":null},{"line":750,"address":[4438829],"length":1,"stats":{"Line":3},"fn_name":null},{"line":751,"address":[4438911],"length":1,"stats":{"Line":3},"fn_name":null},{"line":753,"address":[4439403,4439465,4439209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":754,"address":[4439034,4439214],"length":1,"stats":{"Line":2},"fn_name":null},{"line":755,"address":[4439252,4439130],"length":1,"stats":{"Line":2},"fn_name":null},{"line":756,"address":[4439201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":761,"address":[4439888,4439976],"length":1,"stats":{"Line":3},"fn_name":"diff_longer"},{"line":762,"address":[4439895],"length":1,"stats":{"Line":1},"fn_name":null},{"line":763,"address":[4440001],"length":1,"stats":{"Line":1},"fn_name":null},{"line":764,"address":[4440124],"length":1,"stats":{"Line":3},"fn_name":null},{"line":765,"address":[4440206],"length":1,"stats":{"Line":3},"fn_name":null},{"line":767,"address":[4440742,4440504,4440680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":768,"address":[4440329,4440509],"length":1,"stats":{"Line":2},"fn_name":null},{"line":769,"address":[4440425,4440536],"length":1,"stats":{"Line":2},"fn_name":null},{"line":770,"address":[4440496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":775,"address":[4441168,4441248],"length":1,"stats":{"Line":3},"fn_name":"diff_shorter"},{"line":776,"address":[4441175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":777,"address":[4441273],"length":1,"stats":{"Line":1},"fn_name":null},{"line":778,"address":[4441337],"length":1,"stats":{"Line":3},"fn_name":null},{"line":779,"address":[4441413],"length":1,"stats":{"Line":3},"fn_name":null},{"line":781,"address":[4441653,4441610,4441600,4441625],"length":1,"stats":{"Line":2},"fn_name":null},{"line":782,"address":[4441526,4441612],"length":1,"stats":{"Line":2},"fn_name":null},{"line":783,"address":[4441602],"length":1,"stats":{"Line":0},"fn_name":null},{"line":788,"address":[4441856,4441824],"length":1,"stats":{"Line":3},"fn_name":"minmax"},{"line":798,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":799,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":804,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":805,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":809,"address":[4441838,4441871,4442024],"length":1,"stats":{"Line":2},"fn_name":null},{"line":811,"address":[4442327,4442003,4442719],"length":1,"stats":{"Line":2},"fn_name":null},{"line":813,"address":[4442456],"length":1,"stats":{"Line":1},"fn_name":null},{"line":815,"address":[4443030,4443134],"length":1,"stats":{"Line":2},"fn_name":null},{"line":816,"address":[4443149,4443281],"length":1,"stats":{"Line":1},"fn_name":null},{"line":818,"address":[4443255,4443635],"length":1,"stats":{"Line":4},"fn_name":null},{"line":819,"address":[4443993,4443799],"length":1,"stats":{"Line":1},"fn_name":null},{"line":820,"address":[4443905,4444338,4444378],"length":1,"stats":{"Line":2},"fn_name":null},{"line":822,"address":[4444352,4444732],"length":1,"stats":{"Line":4},"fn_name":null},{"line":823,"address":[4444884,4445069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":824,"address":[4444984,4445375,4445399],"length":1,"stats":{"Line":2},"fn_name":null},{"line":828,"address":[4446384,4446528],"length":1,"stats":{"Line":3},"fn_name":"format"},{"line":829,"address":[4446405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":830,"address":[4446449],"length":1,"stats":{"Line":1},"fn_name":null},{"line":831,"address":[4446469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":833,"address":[4446550,4446489],"length":1,"stats":{"Line":2},"fn_name":null},{"line":834,"address":[4446966,4446808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":835,"address":[4446940,4447304],"length":1,"stats":{"Line":2},"fn_name":null},{"line":836,"address":[4447568,4447780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":838,"address":[4447697],"length":1,"stats":{"Line":1},"fn_name":null},{"line":839,"address":[4448094,4447754],"length":1,"stats":{"Line":2},"fn_name":null},{"line":840,"address":[4448487,4448357],"length":1,"stats":{"Line":1},"fn_name":null},{"line":844,"address":[4448896],"length":1,"stats":{"Line":3},"fn_name":"while_some"},{"line":845,"address":[4448900],"length":1,"stats":{"Line":3},"fn_name":null},{"line":847,"address":[4448958],"length":1,"stats":{"Line":1},"fn_name":null},{"line":852,"address":[4449194,4449072],"length":1,"stats":{"Line":3},"fn_name":"fold_while"},{"line":853,"address":[4449079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":854,"address":[4449087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":855,"address":[4449209,4449329],"length":1,"stats":{"Line":3},"fn_name":null},{"line":856,"address":[4698489,4698353],"length":1,"stats":{"Line":1},"fn_name":null},{"line":857,"address":[4698393,4698549,4698519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":858,"address":[4698435,4698458],"length":1,"stats":{"Line":2},"fn_name":null},{"line":859,"address":[4698460],"length":1,"stats":{"Line":1},"fn_name":null},{"line":861,"address":[4698442],"length":1,"stats":{"Line":1},"fn_name":null},{"line":863,"address":[4449348,4449309],"length":1,"stats":{"Line":2},"fn_name":null},{"line":864,"address":[4449555,4449365],"length":1,"stats":{"Line":1},"fn_name":null},{"line":865,"address":[4449842,4449459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":869,"address":[4450664,4450144],"length":1,"stats":{"Line":3},"fn_name":"tree_fold1"},{"line":870,"address":[4450283],"length":1,"stats":{"Line":1},"fn_name":null},{"line":889,"address":[4450634,4450843,4451671,4450679],"length":1,"stats":{"Line":3},"fn_name":null},{"line":890,"address":[4450963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":891,"address":[4451086],"length":1,"stats":{"Line":3},"fn_name":null},{"line":892,"address":[4451173],"length":1,"stats":{"Line":3},"fn_name":null},{"line":893,"address":[4451230,4451361],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":529,"coverable":534},{"path":["/","home","kms","itertools","tests","tuples.rs"],"content":"use itertools::Itertools;\n\n#[test]\nfn tuples() {\n    let v = [1, 2, 3, 4, 5];\n    let mut iter = v.iter().cloned().tuples();\n    assert_eq!(Some((1,)), iter.next());\n    assert_eq!(Some((2,)), iter.next());\n    assert_eq!(Some((3,)), iter.next());\n    assert_eq!(Some((4,)), iter.next());\n    assert_eq!(Some((5,)), iter.next());\n    assert_eq!(None, iter.next());\n    assert_eq!(None, iter.into_buffer().next());\n\n    let mut iter = v.iter().cloned().tuples();\n    assert_eq!(Some((1, 2)), iter.next());\n    assert_eq!(Some((3, 4)), iter.next());\n    assert_eq!(None, iter.next());\n    itertools::assert_equal(vec![5], iter.into_buffer());\n\n    let mut iter = v.iter().cloned().tuples();\n    assert_eq!(Some((1, 2, 3)), iter.next());\n    assert_eq!(None, iter.next());\n    itertools::assert_equal(vec![4, 5], iter.into_buffer());\n\n    let mut iter = v.iter().cloned().tuples();\n    assert_eq!(Some((1, 2, 3, 4)), iter.next());\n    assert_eq!(None, iter.next());\n    itertools::assert_equal(vec![5], iter.into_buffer());\n}\n\n#[test]\nfn tuple_windows() {\n    let v = [1, 2, 3, 4, 5];\n\n    let mut iter = v.iter().cloned().tuple_windows();\n    assert_eq!(Some((1,)), iter.next());\n    assert_eq!(Some((2,)), iter.next());\n    assert_eq!(Some((3,)), iter.next());\n\n    let mut iter = v.iter().cloned().tuple_windows();\n    assert_eq!(Some((1, 2)), iter.next());\n    assert_eq!(Some((2, 3)), iter.next());\n    assert_eq!(Some((3, 4)), iter.next());\n    assert_eq!(Some((4, 5)), iter.next());\n    assert_eq!(None, iter.next());\n\n    let mut iter = v.iter().cloned().tuple_windows();\n    assert_eq!(Some((1, 2, 3)), iter.next());\n    assert_eq!(Some((2, 3, 4)), iter.next());\n    assert_eq!(Some((3, 4, 5)), iter.next());\n    assert_eq!(None, iter.next());\n\n    let mut iter = v.iter().cloned().tuple_windows();\n    assert_eq!(Some((1, 2, 3, 4)), iter.next());\n    assert_eq!(Some((2, 3, 4, 5)), iter.next());\n    assert_eq!(None, iter.next());\n\n    let v = [1, 2, 3];\n    let mut iter = v.iter().cloned().tuple_windows::<(_, _, _, _)>();\n    assert_eq!(None, iter.next());\n}\n\n#[test]\nfn next_tuple() {\n    let v = [1, 2, 3, 4, 5];\n    let mut iter = v.iter();\n    assert_eq!(iter.next_tuple().map(|(&x, &y)| (x, y)), Some((1, 2)));\n    assert_eq!(iter.next_tuple().map(|(&x, &y)| (x, y)), Some((3, 4)));\n    assert_eq!(iter.next_tuple::<(_, _)>(), None);\n}\n\n#[test]\nfn collect_tuple() {\n    let v = [1, 2];\n    let iter = v.iter().cloned();\n    assert_eq!(iter.collect_tuple(), Some((1, 2)));\n\n    let v = [1];\n    let iter = v.iter().cloned();\n    assert_eq!(iter.collect_tuple::<(_, _)>(), None);\n\n    let v = [1, 2, 3];\n    let iter = v.iter().cloned();\n    assert_eq!(iter.collect_tuple::<(_, _)>(), None);\n}\n","traces":[{"line":4,"address":[4235376,4235533],"length":1,"stats":{"Line":3},"fn_name":"tuples"},{"line":5,"address":[4235383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":6,"address":[4235564,4235494],"length":1,"stats":{"Line":2},"fn_name":null},{"line":7,"address":[4235630,4235817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[4236321,4236162,4235793],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9,"address":[4236825,4236666,4236297],"length":1,"stats":{"Line":2},"fn_name":null},{"line":10,"address":[4236801,4237170,4237329],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[4237833,4237305,4237674],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[4238371,4238178,4237809],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[4238305,4238717],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[4239275],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[4239392,4239531],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[4239869,4240001,4239521],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[4240493,4240339,4239991],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4240831,4243415,4240450],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[4240954],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[4241071,4241210],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[4241548,4241708,4241200],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[4242046,4241664,4243485],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[4242185],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[4242290,4242423],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[4242725,4242413,4242873],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[4243173,4243555,4242830],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[4243760],"length":1,"stats":{"Line":3},"fn_name":"tuple_windows"},{"line":34,"address":[4243767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[4243822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[4244088,4243933],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[4244064,4244398,4244527],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[4244976,4244503,4244837],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[4245295,4244934],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[4245496,4245345],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4245929,4245806,4245470],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[4245903,4246239,4246362],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[4246672,4246795,4246336],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[4246769,4247105,4247244],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[4247202,4247563],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[4247764,4247613],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[4248074,4247738,4248197],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[4248171,4248630,4248507],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[4248940,4248604,4249079],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[4249398,4249037],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[4249599,4249448],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[4249909,4250032,4249573],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[4250330,4250490,4250006],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[4250421],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4250779,4250454],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[4250944,4250817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[4251232],"length":1,"stats":{"Line":3},"fn_name":"next_tuple"},{"line":66,"address":[4251239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[4251307],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[4251521,4251328],"length":1,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[4251958,4251490,4251800],"length":1,"stats":{"Line":4},"fn_name":null},{"line":70,"address":[4251932,4252343,4252244],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[4252624],"length":1,"stats":{"Line":3},"fn_name":"collect_tuple"},{"line":75,"address":[4252631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[4252653],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[4252727,4252913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[4252860],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[4253208,4252871],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[4253229,4253425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[4253356],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[4253714,4253389],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[4253735,4253870],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":63,"coverable":63},{"path":["/","home","kms","itertools","tests","zip.rs"],"content":"use itertools::Itertools;\nuse itertools::EitherOrBoth::{Both, Left, Right};\nuse itertools::free::zip_eq;\n\n#[test]\nfn zip_longest_fused() {\n    let a = [Some(1), None, Some(3), Some(4)];\n    let b = [1, 2, 3];\n\n    let unfused = a.iter().batching(|it| *it.next().unwrap())\n        .zip_longest(b.iter().cloned());\n    itertools::assert_equal(unfused,\n                       vec![Both(1, 1), Right(2), Right(3)]);\n}\n\n#[test]\nfn test_zip_longest_size_hint() {\n    let c = (1..10).cycle();\n    let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let v2 = &[10, 11, 12];\n\n    assert_eq!(c.zip_longest(v.iter()).size_hint(), (std::usize::MAX, None));\n\n    assert_eq!(v.iter().zip_longest(v2.iter()).size_hint(), (10, Some(10)));\n}\n\n#[test]\nfn test_double_ended_zip_longest() {\n    let xs = [1, 2, 3, 4, 5, 6];\n    let ys = [1, 2, 3, 7];\n    let a = xs.iter().map(|&x| x);\n    let b = ys.iter().map(|&x| x);\n    let mut it = a.zip_longest(b);\n    assert_eq!(it.next(), Some(Both(1, 1)));\n    assert_eq!(it.next(), Some(Both(2, 2)));\n    assert_eq!(it.next_back(), Some(Left(6)));\n    assert_eq!(it.next_back(), Some(Left(5)));\n    assert_eq!(it.next_back(), Some(Both(4, 7)));\n    assert_eq!(it.next(), Some(Both(3, 3)));\n    assert_eq!(it.next(), None);\n}\n\n\n#[should_panic]\n#[test]\nfn zip_eq_panic1()\n{\n    let a = [1, 2];\n    let b = [1, 2, 3];\n\n    zip_eq(&a, &b).count();\n}\n\n#[should_panic]\n#[test]\nfn zip_eq_panic2()\n{\n    let a: [i32; 0] = [];\n    let b = [1, 2, 3];\n\n    zip_eq(&a, &b).count();\n}\n\n","traces":[{"line":6,"address":[4214016,4214021],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":7,"address":[4232887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[4233007],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[4214048,4214062],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":11,"address":[4233093],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[4233180,4233399],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[4233212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[4233440],"length":1,"stats":{"Line":3},"fn_name":"test_zip_longest_size_hint"},{"line":18,"address":[4233447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[4233510],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[4233530],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[4233793,4233538],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[4233757,4234263,4234072],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[4214144,4214149],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":29,"address":[4234551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[4234617],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[4214189,4214176],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":32,"address":[4214237,4214224],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":33,"address":[4234809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[4234854,4235005],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[4235438,4235315,4234979],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[4235748,4235412,4235871],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[4235845,4236181,4236304],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[4236614,4236278,4236731],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[4237134,4237017,4236705],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[4237108,4237420,4237519],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[4214277,4214272],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":48,"address":[4237812],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[4237828],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[4237852],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[4214304,4214309],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":59,"address":[4237892],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[4237916],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":33,"coverable":33}]}