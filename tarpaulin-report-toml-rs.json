{"files":[{"path":["/","usr","src","toml-rs","src","datetime.rs"],"content":"use std::error;\nuse std::fmt;\nuse std::str::{self, FromStr};\n\nuse serde::{de, ser};\n\n/// A parsed TOML datetime value\n///\n/// This structure is intended to represent the datetime primitive type that can\n/// be encoded into TOML documents. This type is a parsed version that contains\n/// all metadata internally.\n///\n/// Currently this type is intentionally conservative and only supports\n/// `to_string` as an accessor. Over time though it's intended that it'll grow\n/// more support!\n///\n/// Note that if you're using `Deserialize` to deserialize a TOML document, you\n/// can use this as a placeholder for where you're expecting a datetime to be\n/// specified.\n///\n/// Also note though that while this type implements `Serialize` and\n/// `Deserialize` it's only recommended to use this type with the TOML format,\n/// otherwise encoded in other formats it may look a little odd.\n#[derive(PartialEq, Clone)]\npub struct Datetime {\n    date: Option<Date>,\n    time: Option<Time>,\n    offset: Option<Offset>,\n}\n\n/// Error returned from parsing a `Datetime` in the `FromStr` implementation.\n#[derive(Debug, Clone)]\npub struct DatetimeParseError {\n    _private: (),\n}\n\n// Currently serde itself doesn't have a datetime type, so we map our `Datetime`\n// to a special valid in the serde data model. Namely one with thiese special\n// fields/struct names.\n//\n// In general the TOML encoder/decoder will catch this and not literally emit\n// these strings but rather emit datetimes as they're intended.\npub const FIELD: &str = \"$__toml_private_datetime\";\npub const NAME: &str = \"$__toml_private_Datetime\";\n\n#[derive(PartialEq, Clone)]\nstruct Date {\n    year: u16,\n    month: u8,\n    day: u8,\n}\n\n#[derive(PartialEq, Clone)]\nstruct Time {\n    hour: u8,\n    minute: u8,\n    second: u8,\n    nanosecond: u32,\n}\n\n#[derive(PartialEq, Clone)]\nenum Offset {\n    Z,\n    Custom { hours: i8, minutes: u8 },\n}\n\nimpl fmt::Debug for Datetime {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(self, f)\n    }\n}\n\nimpl fmt::Display for Datetime {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if let Some(ref date) = self.date {\n            write!(f, \"{}\", date)?;\n        }\n        if let Some(ref time) = self.time {\n            if self.date.is_some() {\n                write!(f, \"T\")?;\n            }\n            write!(f, \"{}\", time)?;\n        }\n        if let Some(ref offset) = self.offset {\n            write!(f, \"{}\", offset)?;\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for Date {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{:04}-{:02}-{:02}\", self.year, self.month, self.day)\n    }\n}\n\nimpl fmt::Display for Time {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{:02}:{:02}:{:02}\", self.hour, self.minute, self.second)?;\n        if self.nanosecond != 0 {\n            let s = format!(\"{:09}\", self.nanosecond);\n            write!(f, \".{}\", s.trim_end_matches('0'))?;\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for Offset {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            Offset::Z => write!(f, \"Z\"),\n            Offset::Custom { hours, minutes } => write!(f, \"{:+03}:{:02}\", hours, minutes),\n        }\n    }\n}\n\nimpl FromStr for Datetime {\n    type Err = DatetimeParseError;\n\n    fn from_str(date: &str) -> Result<Datetime, DatetimeParseError> {\n        // Accepted formats:\n        //\n        // 0000-00-00T00:00:00.00Z\n        // 0000-00-00T00:00:00.00\n        // 0000-00-00\n        // 00:00:00.00\n        if date.len() < 3 {\n            return Err(DatetimeParseError { _private: () });\n        }\n        let mut offset_allowed = true;\n        let mut chars = date.chars();\n\n        // First up, parse the full date if we can\n        let full_date = if chars.clone().nth(2) == Some(':') {\n            offset_allowed = false;\n            None\n        } else {\n            let y1 = u16::from(digit(&mut chars)?);\n            let y2 = u16::from(digit(&mut chars)?);\n            let y3 = u16::from(digit(&mut chars)?);\n            let y4 = u16::from(digit(&mut chars)?);\n\n            match chars.next() {\n                Some('-') => {}\n                _ => return Err(DatetimeParseError { _private: () }),\n            }\n\n            let m1 = digit(&mut chars)?;\n            let m2 = digit(&mut chars)?;\n\n            match chars.next() {\n                Some('-') => {}\n                _ => return Err(DatetimeParseError { _private: () }),\n            }\n\n            let d1 = digit(&mut chars)?;\n            let d2 = digit(&mut chars)?;\n\n            let date = Date {\n                year: y1 * 1000 + y2 * 100 + y3 * 10 + y4,\n                month: m1 * 10 + m2,\n                day: d1 * 10 + d2,\n            };\n\n            if date.month < 1 || date.month > 12 {\n                return Err(DatetimeParseError { _private: () });\n            }\n            if date.day < 1 || date.day > 31 {\n                return Err(DatetimeParseError { _private: () });\n            }\n\n            Some(date)\n        };\n\n        // Next parse the \"partial-time\" if available\n        let next = chars.clone().next();\n        let partial_time = if full_date.is_some()\n            && (next == Some('T') || next == Some('t') || next == Some(' '))\n        {\n            chars.next();\n            true\n        } else {\n            full_date.is_none()\n        };\n\n        let time = if partial_time {\n            let h1 = digit(&mut chars)?;\n            let h2 = digit(&mut chars)?;\n            match chars.next() {\n                Some(':') => {}\n                _ => return Err(DatetimeParseError { _private: () }),\n            }\n            let m1 = digit(&mut chars)?;\n            let m2 = digit(&mut chars)?;\n            match chars.next() {\n                Some(':') => {}\n                _ => return Err(DatetimeParseError { _private: () }),\n            }\n            let s1 = digit(&mut chars)?;\n            let s2 = digit(&mut chars)?;\n\n            let mut nanosecond = 0;\n            if chars.clone().next() == Some('.') {\n                chars.next();\n                let whole = chars.as_str();\n\n                let mut end = whole.len();\n                for (i, byte) in whole.bytes().enumerate() {\n                    match byte {\n                        b'0'..=b'9' => {\n                            if i < 9 {\n                                let p = 10_u32.pow(8 - i as u32);\n                                nanosecond += p * u32::from(byte - b'0');\n                            }\n                        }\n                        _ => {\n                            end = i;\n                            break;\n                        }\n                    }\n                }\n                if end == 0 {\n                    return Err(DatetimeParseError { _private: () });\n                }\n                chars = whole[end..].chars();\n            }\n\n            let time = Time {\n                hour: h1 * 10 + h2,\n                minute: m1 * 10 + m2,\n                second: s1 * 10 + s2,\n                nanosecond,\n            };\n\n            if time.hour > 24 {\n                return Err(DatetimeParseError { _private: () });\n            }\n            if time.minute > 59 {\n                return Err(DatetimeParseError { _private: () });\n            }\n            if time.second > 59 {\n                return Err(DatetimeParseError { _private: () });\n            }\n            if time.nanosecond > 999_999_999 {\n                return Err(DatetimeParseError { _private: () });\n            }\n\n            Some(time)\n        } else {\n            offset_allowed = false;\n            None\n        };\n\n        // And finally, parse the offset\n        let offset = if offset_allowed {\n            let next = chars.clone().next();\n            if next == Some('Z') || next == Some('z') {\n                chars.next();\n                Some(Offset::Z)\n            } else if next.is_none() {\n                None\n            } else {\n                let sign = match next {\n                    Some('+') => 1,\n                    Some('-') => -1,\n                    _ => return Err(DatetimeParseError { _private: () }),\n                };\n                chars.next();\n                let h1 = digit(&mut chars)? as i8;\n                let h2 = digit(&mut chars)? as i8;\n                match chars.next() {\n                    Some(':') => {}\n                    _ => return Err(DatetimeParseError { _private: () }),\n                }\n                let m1 = digit(&mut chars)?;\n                let m2 = digit(&mut chars)?;\n\n                Some(Offset::Custom {\n                    hours: sign * (h1 * 10 + h2),\n                    minutes: m1 * 10 + m2,\n                })\n            }\n        } else {\n            None\n        };\n\n        // Return an error if we didn't hit eof, otherwise return our parsed\n        // date\n        if chars.next().is_some() {\n            return Err(DatetimeParseError { _private: () });\n        }\n\n        Ok(Datetime {\n            date: full_date,\n            time,\n            offset,\n        })\n    }\n}\n\nfn digit(chars: &mut str::Chars<'_>) -> Result<u8, DatetimeParseError> {\n    match chars.next() {\n        Some(c) if '0' <= c && c <= '9' => Ok(c as u8 - b'0'),\n        _ => Err(DatetimeParseError { _private: () }),\n    }\n}\n\nimpl ser::Serialize for Datetime {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: ser::Serializer,\n    {\n        use serde::ser::SerializeStruct;\n\n        let mut s = serializer.serialize_struct(NAME, 1)?;\n        s.serialize_field(FIELD, &self.to_string())?;\n        s.end()\n    }\n}\n\nimpl<'de> de::Deserialize<'de> for Datetime {\n    fn deserialize<D>(deserializer: D) -> Result<Datetime, D::Error>\n    where\n        D: de::Deserializer<'de>,\n    {\n        struct DatetimeVisitor;\n\n        impl<'de> de::Visitor<'de> for DatetimeVisitor {\n            type Value = Datetime;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n                formatter.write_str(\"a TOML datetime\")\n            }\n\n            fn visit_map<V>(self, mut visitor: V) -> Result<Datetime, V::Error>\n            where\n                V: de::MapAccess<'de>,\n            {\n                let value = visitor.next_key::<DatetimeKey>()?;\n                if value.is_none() {\n                    return Err(de::Error::custom(\"datetime key not found\"));\n                }\n                let v: DatetimeFromString = visitor.next_value()?;\n                Ok(v.value)\n            }\n        }\n\n        static FIELDS: [&str; 1] = [FIELD];\n        deserializer.deserialize_struct(NAME, &FIELDS, DatetimeVisitor)\n    }\n}\n\nstruct DatetimeKey;\n\nimpl<'de> de::Deserialize<'de> for DatetimeKey {\n    fn deserialize<D>(deserializer: D) -> Result<DatetimeKey, D::Error>\n    where\n        D: de::Deserializer<'de>,\n    {\n        struct FieldVisitor;\n\n        impl<'de> de::Visitor<'de> for FieldVisitor {\n            type Value = ();\n\n            fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n                formatter.write_str(\"a valid datetime field\")\n            }\n\n            fn visit_str<E>(self, s: &str) -> Result<(), E>\n            where\n                E: de::Error,\n            {\n                if s == FIELD {\n                    Ok(())\n                } else {\n                    Err(de::Error::custom(\"expected field with custom name\"))\n                }\n            }\n        }\n\n        deserializer.deserialize_identifier(FieldVisitor)?;\n        Ok(DatetimeKey)\n    }\n}\n\npub struct DatetimeFromString {\n    pub value: Datetime,\n}\n\nimpl<'de> de::Deserialize<'de> for DatetimeFromString {\n    fn deserialize<D>(deserializer: D) -> Result<DatetimeFromString, D::Error>\n    where\n        D: de::Deserializer<'de>,\n    {\n        struct Visitor;\n\n        impl<'de> de::Visitor<'de> for Visitor {\n            type Value = DatetimeFromString;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n                formatter.write_str(\"string containing a datetime\")\n            }\n\n            fn visit_str<E>(self, s: &str) -> Result<DatetimeFromString, E>\n            where\n                E: de::Error,\n            {\n                match s.parse() {\n                    Ok(date) => Ok(DatetimeFromString { value: date }),\n                    Err(e) => Err(de::Error::custom(e)),\n                }\n            }\n        }\n\n        deserializer.deserialize_str(Visitor)\n    }\n}\n\nimpl fmt::Display for DatetimeParseError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        \"failed to parse datetime\".fmt(f)\n    }\n}\n\nimpl error::Error for DatetimeParseError {}\n","traces":[{"line":68,"address":[5418096],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":69,"address":[5418110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[5418144],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":75,"address":[5418167,5418449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[5418234,5418451,5418481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[5418506,5418958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[5418710,5418550],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[5418712,5418587],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[5418749,5418960],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[5419000,5419269],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[5419060,5419271],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[5419299],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[5419312],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":93,"address":[5419342],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[5419921,5419712],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":99,"address":[5419742,5419951,5420267,5420297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[5420966,5420257],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[5420321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[5420906,5420540,5420961,5420637],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[5420968],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[5421008],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":110,"address":[5421188,5421262,5421448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[5421195,5421031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[5421069,5421279],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[5421472],"length":1,"stats":{"Line":0},"fn_name":"from_str"},{"line":127,"address":[5421506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[5421618],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[5421563],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[5421587],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[5421648,5421783,5423891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[5421765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[5421773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[5421736,5421795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[5421943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[5422123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[5422303],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[5422483],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[5422553,5422507],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[5422545],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[5422563,5422731],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[5422894,5422767,5422695],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[5422865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[5422927,5422973],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[5422965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[5423151,5422983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[5423187,5423115,5423334],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[5423300,5423371,5428326],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[5428506,5423561],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[5423626,5428566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[5423728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[5423800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[5423811,5423780],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[5423901],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[5423853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[5423917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[5424116,5423958,5424034,5424293],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[5424135,5424066,5424001],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[5424272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[5424285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[5424247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[5426724,5424297,5424326],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[5424331,5424499],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[5424664,5424463,5424537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[5424635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[5424743,5424697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[5424735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[5424753,5424921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[5424957,5425084,5424885],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[5425055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[5425163,5425117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[5425155],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[5425341,5425173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[5425524,5425305,5425377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[5425475],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[5425501,5425553],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[5425617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[5425630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[5425691],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[5426231,5425720],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[5425994,5425944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[5426024],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[5426042,5428626],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[5428656,5426110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[5426006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[5426014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[5425967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[5426302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[5426323,5426236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[5428746,5426371],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[5426427,5428806],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[5428866,5426483],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[5426581],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[5426611],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[5426591],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[5426642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[5426622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[5426673],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[5426650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[5426734],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[5426681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[5424307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[5424315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[5428023,5426742,5426760],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[5426773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[5428021,5426814,5426991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[5426940],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[5426953],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[5426920,5427000,5427050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[5427042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[5427110,5427120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[5427010,5427071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[5427112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[5427063,5427122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[5427129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[5427283,5427142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[5427316,5427431,5427256],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[5427405],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[5427510,5427464],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[5427502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[5427661,5427520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[5427694,5427634,5427830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[5427963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[5428926,5427783,5427865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[5427913,5429016,5429076],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[5426752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[5428025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[5428315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[5428167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[5428075],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[5428105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[5428135],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[5429088],"length":1,"stats":{"Line":0},"fn_name":"digit"},{"line":302,"address":[5429097,5429142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[5429279,5429110,5429249,5429144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[5429137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[5035980,5035888],"length":1,"stats":{"Line":0},"fn_name":"serialize<&mut toml::ser::Serializer>"},{"line":315,"address":[5035921,5035995,5036243,5036143,5036275],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[5036116,5036296,5036596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[5036620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[5429280],"length":1,"stats":{"Line":0},"fn_name":"expecting"},{"line":332,"address":[5429301],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[5429344],"length":1,"stats":{"Line":0},"fn_name":"expecting"},{"line":366,"address":[5429365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[5036976,5036816,5036896],"length":1,"stats":{"Line":0},"fn_name":"deserialize<toml::de::StrDeserializer>"},{"line":397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[5429408],"length":1,"stats":{"Line":0},"fn_name":"expecting"},{"line":401,"address":[5429429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[5037056],"length":1,"stats":{"Line":0},"fn_name":"visit_str<toml::de::Error>"},{"line":408,"address":[5037082,5037140,5037270],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[5037142,5037106],"length":1,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[5037125,5037281],"length":1,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[5036823,5036906,5036983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[5429472],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":421,"address":[5429493],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":175},{"path":["/","usr","src","toml-rs","src","de.rs"],"content":"//! Deserializing TOML into Rust structures.\n//!\n//! This module contains all the Serde support for deserializing TOML documents\n//! into Rust structures. Note that some top-level functions here are also\n//! provided at the top of the crate.\n\nuse std::borrow::Cow;\nuse std::collections::HashMap;\nuse std::error;\nuse std::f64;\nuse std::fmt;\nuse std::iter;\nuse std::marker::PhantomData;\nuse std::str;\nuse std::vec;\n\nuse serde::de;\nuse serde::de::value::BorrowedStrDeserializer;\nuse serde::de::IntoDeserializer;\n\nuse crate::datetime;\nuse crate::spanned;\nuse crate::tokens::{Error as TokenError, Span, Token, Tokenizer};\n\n/// Type Alias for a TOML Table pair\ntype TablePair<'a> = ((Span, Cow<'a, str>), Value<'a>);\n\n/// Deserializes a byte slice into a type.\n///\n/// This function will attempt to interpret `bytes` as UTF-8 data and then\n/// deserialize `T` from the TOML document provided.\npub fn from_slice<'de, T>(bytes: &'de [u8]) -> Result<T, Error>\nwhere\n    T: de::Deserialize<'de>,\n{\n    match str::from_utf8(bytes) {\n        Ok(s) => from_str(s),\n        Err(e) => Err(Error::custom(None, e.to_string())),\n    }\n}\n\n/// Deserializes a string into a type.\n///\n/// This function will attempt to interpret `s` as a TOML document and\n/// deserialize `T` from the document.\n///\n/// # Examples\n///\n/// ```\n/// use serde_derive::Deserialize;\n///\n/// #[derive(Deserialize)]\n/// struct Config {\n///     title: String,\n///     owner: Owner,\n/// }\n///\n/// #[derive(Deserialize)]\n/// struct Owner {\n///     name: String,\n/// }\n///\n/// fn main() {\n///     let config: Config = toml::from_str(r#\"\n///         title = 'TOML Example'\n///\n///         [owner]\n///         name = 'Lisa'\n///     \"#).unwrap();\n///\n///     assert_eq!(config.title, \"TOML Example\");\n///     assert_eq!(config.owner.name, \"Lisa\");\n/// }\n/// ```\npub fn from_str<'de, T>(s: &'de str) -> Result<T, Error>\nwhere\n    T: de::Deserialize<'de>,\n{\n    let mut d = Deserializer::new(s);\n    let ret = T::deserialize(&mut d)?;\n    d.end()?;\n    Ok(ret)\n}\n\n/// Errors that can occur when deserializing a type.\n#[derive(Debug, PartialEq, Eq, Clone)]\npub struct Error {\n    inner: Box<ErrorInner>,\n}\n\n#[derive(Debug, PartialEq, Eq, Clone)]\nstruct ErrorInner {\n    kind: ErrorKind,\n    line: Option<usize>,\n    col: usize,\n    at: Option<usize>,\n    message: String,\n    key: Vec<String>,\n}\n\n/// Errors that can occur when deserializing a type.\n#[derive(Debug, PartialEq, Eq, Clone)]\nenum ErrorKind {\n    /// EOF was reached when looking for a value\n    UnexpectedEof,\n\n    /// An invalid character not allowed in a string was found\n    InvalidCharInString(char),\n\n    /// An invalid character was found as an escape\n    InvalidEscape(char),\n\n    /// An invalid character was found in a hex escape\n    InvalidHexEscape(char),\n\n    /// An invalid escape value was specified in a hex escape in a string.\n    ///\n    /// Valid values are in the plane of unicode codepoints.\n    InvalidEscapeValue(u32),\n\n    /// A newline in a string was encountered when one was not allowed.\n    NewlineInString,\n\n    /// An unexpected character was encountered, typically when looking for a\n    /// value.\n    Unexpected(char),\n\n    /// An unterminated string was found where EOF was found before the ending\n    /// EOF mark.\n    UnterminatedString,\n\n    /// A newline was found in a table key.\n    NewlineInTableKey,\n\n    /// A number failed to parse\n    NumberInvalid,\n\n    /// A date or datetime was invalid\n    DateInvalid,\n\n    /// Wanted one sort of token, but found another.\n    Wanted {\n        /// Expected token type\n        expected: &'static str,\n        /// Actually found token type\n        found: &'static str,\n    },\n\n    /// A duplicate table definition was found.\n    DuplicateTable(String),\n\n    /// A previously defined table was redefined as an array.\n    RedefineAsArray,\n\n    /// An empty table key was found.\n    EmptyTableKey,\n\n    /// Multiline strings are not allowed for key\n    MultilineStringKey,\n\n    /// A custom error which could be generated when deserializing a particular\n    /// type.\n    Custom,\n\n    /// A tuple with a certain number of elements was expected but something\n    /// else was found.\n    ExpectedTuple(usize),\n\n    /// Expected table keys to be in increasing tuple index order, but something\n    /// else was found.\n    ExpectedTupleIndex {\n        /// Expected index.\n        expected: usize,\n        /// Key that was specified.\n        found: String,\n    },\n\n    /// An empty table was expected but entries were found\n    ExpectedEmptyTable,\n\n    /// Dotted key attempted to extend something that is not a table.\n    DottedKeyInvalidType,\n\n    /// An unexpected key was encountered.\n    ///\n    /// Used when deserializing a struct with a limited set of fields.\n    UnexpectedKeys {\n        /// The unexpected keys.\n        keys: Vec<String>,\n        /// Keys that may be specified.\n        available: &'static [&'static str],\n    },\n\n    #[doc(hidden)]\n    __Nonexhaustive,\n}\n\n/// Deserialization implementation for TOML.\npub struct Deserializer<'a> {\n    require_newline_after_table: bool,\n    allow_duplciate_after_longer_table: bool,\n    input: &'a str,\n    tokens: Tokenizer<'a>,\n}\n\nimpl<'de, 'b> de::Deserializer<'de> for &'b mut Deserializer<'de> {\n    type Error = Error;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        let mut tables = self.tables()?;\n        let table_indices = build_table_indices(&tables);\n        let table_pindices = build_table_pindices(&tables);\n\n        let res = visitor.visit_map(MapVisitor {\n            values: Vec::new().into_iter().peekable(),\n            next_value: None,\n            depth: 0,\n            cur: 0,\n            cur_parent: 0,\n            max: tables.len(),\n            table_indices: &table_indices,\n            table_pindices: &table_pindices,\n            tables: &mut tables,\n            array: false,\n            de: self,\n        });\n        res.map_err(|mut err| {\n            // Errors originating from this library (toml), have an offset\n            // attached to them already. Other errors, like those originating\n            // from serde (like \"missing field\") or from a custom deserializer,\n            // do not have offsets on them. Here, we do a best guess at their\n            // location, by attributing them to the \"current table\" (the last\n            // item in `tables`).\n            err.fix_offset(|| tables.last().map(|table| table.at));\n            err.fix_linecol(|at| self.to_linecol(at));\n            err\n        })\n    }\n\n    // Called when the type to deserialize is an enum, as opposed to a field in the type.\n    fn deserialize_enum<V>(\n        self,\n        _name: &'static str,\n        _variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        let (value, name) = self.string_or_table()?;\n        match value.e {\n            E::String(val) => visitor.visit_enum(val.into_deserializer()),\n            E::InlineTable(values) => {\n                if values.len() != 1 {\n                    Err(Error::from_kind(\n                        Some(value.start),\n                        ErrorKind::Wanted {\n                            expected: \"exactly 1 element\",\n                            found: if values.is_empty() {\n                                \"zero elements\"\n                            } else {\n                                \"more than 1 element\"\n                            },\n                        },\n                    ))\n                } else {\n                    visitor.visit_enum(InlineTableDeserializer {\n                        values: values.into_iter(),\n                        next_value: None,\n                    })\n                }\n            }\n            E::DottedTable(_) => visitor.visit_enum(DottedTableDeserializer {\n                name: name.expect(\"Expected table header to be passed.\"),\n                value,\n            }),\n            e => Err(Error::from_kind(\n                Some(value.start),\n                ErrorKind::Wanted {\n                    expected: \"string or table\",\n                    found: e.type_name(),\n                },\n            )),\n        }\n    }\n\n    fn deserialize_struct<V>(\n        self,\n        name: &'static str,\n        fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        if name == spanned::NAME && fields == [spanned::START, spanned::END, spanned::VALUE] {\n            let start = 0;\n            let end = self.input.len();\n\n            let res = visitor.visit_map(SpannedDeserializer {\n                phantom_data: PhantomData,\n                start: Some(start),\n                value: Some(self),\n                end: Some(end),\n            });\n            return res;\n        }\n\n        self.deserialize_any(visitor)\n    }\n\n    serde::forward_to_deserialize_any! {\n        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string seq\n        bytes byte_buf map unit newtype_struct\n        ignored_any unit_struct tuple_struct tuple option identifier\n    }\n}\n\n// Builds a datastructure that allows for efficient sublinear lookups.\n// The returned HashMap contains a mapping from table header (like [a.b.c])\n// to list of tables with that precise name. The tables are being identified\n// by their index in the passed slice. We use a list as the implementation\n// uses this data structure for arrays as well as tables,\n// so if any top level [[name]] array contains multiple entries,\n// there are multiple entires in the list.\n// The lookup is performed in the `SeqAccess` implementation of `MapVisitor`.\n// The lists are ordered, which we exploit in the search code by using\n// bisection.\nfn build_table_indices<'de>(tables: &[Table<'de>]) -> HashMap<Vec<Cow<'de, str>>, Vec<usize>> {\n    let mut res = HashMap::new();\n    for (i, table) in tables.iter().enumerate() {\n        let header = table.header.iter().map(|v| v.1.clone()).collect::<Vec<_>>();\n        res.entry(header).or_insert_with(Vec::new).push(i);\n    }\n    res\n}\n\n// Builds a datastructure that allows for efficient sublinear lookups.\n// The returned HashMap contains a mapping from table header (like [a.b.c])\n// to list of tables whose name at least starts with the specified\n// name. So searching for [a.b] would give both [a.b.c.d] as well as [a.b.e].\n// The tables are being identified by their index in the passed slice.\n//\n// A list is used for two reasons: First, the implementation also\n// stores arrays in the same data structure and any top level array\n// of size 2 or greater creates multiple entries in the list with the\n// same shared name. Second, there can be multiple tables sharing\n// the same prefix.\n//\n// The lookup is performed in the `MapAccess` implementation of `MapVisitor`.\n// The lists are ordered, which we exploit in the search code by using\n// bisection.\nfn build_table_pindices<'de>(tables: &[Table<'de>]) -> HashMap<Vec<Cow<'de, str>>, Vec<usize>> {\n    let mut res = HashMap::new();\n    for (i, table) in tables.iter().enumerate() {\n        let header = table.header.iter().map(|v| v.1.clone()).collect::<Vec<_>>();\n        for len in 0..=header.len() {\n            res.entry(header[..len].to_owned())\n                .or_insert_with(Vec::new)\n                .push(i);\n        }\n    }\n    res\n}\n\nfn headers_equal<'a, 'b>(hdr_a: &[(Span, Cow<'a, str>)], hdr_b: &[(Span, Cow<'b, str>)]) -> bool {\n    if hdr_a.len() != hdr_b.len() {\n        return false;\n    }\n    hdr_a.iter().zip(hdr_b.iter()).all(|(h1, h2)| h1.1 == h2.1)\n}\n\nstruct Table<'a> {\n    at: usize,\n    header: Vec<(Span, Cow<'a, str>)>,\n    values: Option<Vec<TablePair<'a>>>,\n    array: bool,\n}\n\nstruct MapVisitor<'de, 'b> {\n    values: iter::Peekable<vec::IntoIter<TablePair<'de>>>,\n    next_value: Option<TablePair<'de>>,\n    depth: usize,\n    cur: usize,\n    cur_parent: usize,\n    max: usize,\n    table_indices: &'b HashMap<Vec<Cow<'de, str>>, Vec<usize>>,\n    table_pindices: &'b HashMap<Vec<Cow<'de, str>>, Vec<usize>>,\n    tables: &'b mut [Table<'de>],\n    array: bool,\n    de: &'b mut Deserializer<'de>,\n}\n\nimpl<'de, 'b> de::MapAccess<'de> for MapVisitor<'de, 'b> {\n    type Error = Error;\n\n    fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Error>\n    where\n        K: de::DeserializeSeed<'de>,\n    {\n        if self.cur_parent == self.max || self.cur == self.max {\n            return Ok(None);\n        }\n\n        loop {\n            assert!(self.next_value.is_none());\n            if let Some((key, value)) = self.values.next() {\n                let ret = seed.deserialize(StrDeserializer::spanned(key.clone()))?;\n                self.next_value = Some((key, value));\n                return Ok(Some(ret));\n            }\n\n            let next_table = {\n                let prefix_stripped = self.tables[self.cur_parent].header[..self.depth]\n                    .iter()\n                    .map(|v| v.1.clone())\n                    .collect::<Vec<_>>();\n                self.table_pindices\n                    .get(&prefix_stripped)\n                    .and_then(|entries| {\n                        let start = entries.binary_search(&self.cur).unwrap_or_else(|v| v);\n                        if start == entries.len() || entries[start] < self.cur {\n                            return None;\n                        }\n                        entries[start..]\n                            .iter()\n                            .filter_map(|i| if *i < self.max { Some(*i) } else { None })\n                            .map(|i| (i, &self.tables[i]))\n                            .find(|(_, table)| table.values.is_some())\n                            .map(|p| p.0)\n                    })\n            };\n\n            let pos = match next_table {\n                Some(pos) => pos,\n                None => return Ok(None),\n            };\n            self.cur = pos;\n\n            // Test to see if we're duplicating our parent's table, and if so\n            // then this is an error in the toml format\n            if self.cur_parent != pos {\n                if headers_equal(\n                    &self.tables[self.cur_parent].header,\n                    &self.tables[pos].header,\n                ) {\n                    let at = self.tables[pos].at;\n                    let name = self.tables[pos]\n                        .header\n                        .iter()\n                        .map(|k| k.1.to_owned())\n                        .collect::<Vec<_>>()\n                        .join(\".\");\n                    return Err(self.de.error(at, ErrorKind::DuplicateTable(name)));\n                }\n\n                // If we're here we know we should share the same prefix, and if\n                // the longer table was defined first then we want to narrow\n                // down our parent's length if possible to ensure that we catch\n                // duplicate tables defined afterwards.\n                if !self.de.allow_duplciate_after_longer_table {\n                    let parent_len = self.tables[self.cur_parent].header.len();\n                    let cur_len = self.tables[pos].header.len();\n                    if cur_len < parent_len {\n                        self.cur_parent = pos;\n                    }\n                }\n            }\n\n            let table = &mut self.tables[pos];\n\n            // If we're not yet at the appropriate depth for this table then we\n            // just next the next portion of its header and then continue\n            // decoding.\n            if self.depth != table.header.len() {\n                let key = &table.header[self.depth];\n                let key = seed.deserialize(StrDeserializer::spanned(key.clone()))?;\n                return Ok(Some(key));\n            }\n\n            // Rule out cases like:\n            //\n            //      [[foo.bar]]\n            //      [[foo]]\n            if table.array {\n                let kind = ErrorKind::RedefineAsArray;\n                return Err(self.de.error(table.at, kind));\n            }\n\n            self.values = table\n                .values\n                .take()\n                .expect(\"Unable to read table values\")\n                .into_iter()\n                .peekable();\n        }\n    }\n\n    fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Error>\n    where\n        V: de::DeserializeSeed<'de>,\n    {\n        if let Some((k, v)) = self.next_value.take() {\n            match seed.deserialize(ValueDeserializer::new(v)) {\n                Ok(v) => return Ok(v),\n                Err(mut e) => {\n                    e.add_key_context(&k.1);\n                    return Err(e);\n                }\n            }\n        }\n\n        let array =\n            self.tables[self.cur].array && self.depth == self.tables[self.cur].header.len() - 1;\n        self.cur += 1;\n        let res = seed.deserialize(MapVisitor {\n            values: Vec::new().into_iter().peekable(),\n            next_value: None,\n            depth: self.depth + if array { 0 } else { 1 },\n            cur_parent: self.cur - 1,\n            cur: 0,\n            max: self.max,\n            array,\n            table_indices: &*self.table_indices,\n            table_pindices: &*self.table_pindices,\n            tables: &mut *self.tables,\n            de: &mut *self.de,\n        });\n        res.map_err(|mut e| {\n            e.add_key_context(&self.tables[self.cur - 1].header[self.depth].1);\n            e\n        })\n    }\n}\n\nimpl<'de, 'b> de::SeqAccess<'de> for MapVisitor<'de, 'b> {\n    type Error = Error;\n\n    fn next_element_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Error>\n    where\n        K: de::DeserializeSeed<'de>,\n    {\n        assert!(self.next_value.is_none());\n        assert!(self.values.next().is_none());\n\n        if self.cur_parent == self.max {\n            return Ok(None);\n        }\n\n        let header_stripped = self.tables[self.cur_parent]\n            .header\n            .iter()\n            .map(|v| v.1.clone())\n            .collect::<Vec<_>>();\n        let start_idx = self.cur_parent + 1;\n        let next = self\n            .table_indices\n            .get(&header_stripped)\n            .and_then(|entries| {\n                let start = entries.binary_search(&start_idx).unwrap_or_else(|v| v);\n                if start == entries.len() || entries[start] < start_idx {\n                    return None;\n                }\n                entries[start..]\n                    .iter()\n                    .filter_map(|i| if *i < self.max { Some(*i) } else { None })\n                    .map(|i| (i, &self.tables[i]))\n                    .find(|(_, table)| table.array)\n                    .map(|p| p.0)\n            })\n            .unwrap_or(self.max);\n\n        let ret = seed.deserialize(MapVisitor {\n            values: self.tables[self.cur_parent]\n                .values\n                .take()\n                .expect(\"Unable to read table values\")\n                .into_iter()\n                .peekable(),\n            next_value: None,\n            depth: self.depth + 1,\n            cur_parent: self.cur_parent,\n            max: next,\n            cur: 0,\n            array: false,\n            table_indices: &*self.table_indices,\n            table_pindices: &*self.table_pindices,\n            tables: &mut self.tables,\n            de: &mut self.de,\n        })?;\n        self.cur_parent = next;\n        Ok(Some(ret))\n    }\n}\n\nimpl<'de, 'b> de::Deserializer<'de> for MapVisitor<'de, 'b> {\n    type Error = Error;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        if self.array {\n            visitor.visit_seq(self)\n        } else {\n            visitor.visit_map(self)\n        }\n    }\n\n    // `None` is interpreted as a missing field so be sure to implement `Some`\n    // as a present field.\n    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        visitor.visit_some(self)\n    }\n\n    fn deserialize_newtype_struct<V>(\n        self,\n        _name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        visitor.visit_newtype_struct(self)\n    }\n\n    fn deserialize_struct<V>(\n        mut self,\n        name: &'static str,\n        fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        if name == spanned::NAME\n            && fields == [spanned::START, spanned::END, spanned::VALUE]\n            && !(self.array && !self.values.peek().is_none())\n        {\n            // TODO we can't actually emit spans here for the *entire* table/array\n            // due to the format that toml uses. Setting the start and end to 0 is\n            // *detectable* (and no reasonable span would look like that),\n            // it would be better to expose this in the API via proper\n            // ADTs like Option<T>.\n            let start = 0;\n            let end = 0;\n\n            let res = visitor.visit_map(SpannedDeserializer {\n                phantom_data: PhantomData,\n                start: Some(start),\n                value: Some(self),\n                end: Some(end),\n            });\n            return res;\n        }\n\n        self.deserialize_any(visitor)\n    }\n\n    fn deserialize_enum<V>(\n        self,\n        _name: &'static str,\n        _variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        if self.tables.len() != 1 {\n            return Err(Error::custom(\n                Some(self.cur),\n                \"enum table must contain exactly one table\".into(),\n            ));\n        }\n        let table = &mut self.tables[0];\n        let values = table.values.take().expect(\"table has no values?\");\n        if table.header.is_empty() {\n            return Err(self.de.error(self.cur, ErrorKind::EmptyTableKey));\n        }\n        let name = table.header[table.header.len() - 1].1.to_owned();\n        visitor.visit_enum(DottedTableDeserializer {\n            name,\n            value: Value {\n                e: E::DottedTable(values),\n                start: 0,\n                end: 0,\n            },\n        })\n    }\n\n    serde::forward_to_deserialize_any! {\n        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string seq\n        bytes byte_buf map unit identifier\n        ignored_any unit_struct tuple_struct tuple\n    }\n}\n\nstruct StrDeserializer<'a> {\n    span: Option<Span>,\n    key: Cow<'a, str>,\n}\n\nimpl<'a> StrDeserializer<'a> {\n    fn spanned(inner: (Span, Cow<'a, str>)) -> StrDeserializer<'a> {\n        StrDeserializer {\n            span: Some(inner.0),\n            key: inner.1,\n        }\n    }\n    fn new(key: Cow<'a, str>) -> StrDeserializer<'a> {\n        StrDeserializer { span: None, key }\n    }\n}\n\nimpl<'a, 'b> de::IntoDeserializer<'a, Error> for StrDeserializer<'a> {\n    type Deserializer = Self;\n\n    fn into_deserializer(self) -> Self::Deserializer {\n        self\n    }\n}\n\nimpl<'de> de::Deserializer<'de> for StrDeserializer<'de> {\n    type Error = Error;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        match self.key {\n            Cow::Borrowed(s) => visitor.visit_borrowed_str(s),\n            Cow::Owned(s) => visitor.visit_string(s),\n        }\n    }\n\n    fn deserialize_struct<V>(\n        self,\n        name: &'static str,\n        fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        if name == spanned::NAME && fields == [spanned::START, spanned::END, spanned::VALUE] {\n            if let Some(span) = self.span {\n                return visitor.visit_map(SpannedDeserializer {\n                    phantom_data: PhantomData,\n                    start: Some(span.start),\n                    value: Some(StrDeserializer::new(self.key)),\n                    end: Some(span.end),\n                });\n            }\n        }\n        self.deserialize_any(visitor)\n    }\n\n    serde::forward_to_deserialize_any! {\n        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string seq\n        bytes byte_buf map option unit newtype_struct\n        ignored_any unit_struct tuple_struct tuple enum identifier\n    }\n}\n\nstruct ValueDeserializer<'a> {\n    value: Value<'a>,\n    validate_struct_keys: bool,\n}\n\nimpl<'a> ValueDeserializer<'a> {\n    fn new(value: Value<'a>) -> ValueDeserializer<'a> {\n        ValueDeserializer {\n            value,\n            validate_struct_keys: false,\n        }\n    }\n\n    fn with_struct_key_validation(mut self) -> Self {\n        self.validate_struct_keys = true;\n        self\n    }\n}\n\nimpl<'de> de::Deserializer<'de> for ValueDeserializer<'de> {\n    type Error = Error;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        let start = self.value.start;\n        let res = match self.value.e {\n            E::Integer(i) => visitor.visit_i64(i),\n            E::Boolean(b) => visitor.visit_bool(b),\n            E::Float(f) => visitor.visit_f64(f),\n            E::String(Cow::Borrowed(s)) => visitor.visit_borrowed_str(s),\n            E::String(Cow::Owned(s)) => visitor.visit_string(s),\n            E::Datetime(s) => visitor.visit_map(DatetimeDeserializer {\n                date: s,\n                visited: false,\n            }),\n            E::Array(values) => {\n                let mut s = de::value::SeqDeserializer::new(values.into_iter());\n                let ret = visitor.visit_seq(&mut s)?;\n                s.end()?;\n                Ok(ret)\n            }\n            E::InlineTable(values) | E::DottedTable(values) => {\n                visitor.visit_map(InlineTableDeserializer {\n                    values: values.into_iter(),\n                    next_value: None,\n                })\n            }\n        };\n        res.map_err(|mut err| {\n            // Attribute the error to whatever value returned the error.\n            err.fix_offset(|| Some(start));\n            err\n        })\n    }\n\n    fn deserialize_struct<V>(\n        self,\n        name: &'static str,\n        fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        if name == datetime::NAME && fields == [datetime::FIELD] {\n            if let E::Datetime(s) = self.value.e {\n                return visitor.visit_map(DatetimeDeserializer {\n                    date: s,\n                    visited: false,\n                });\n            }\n        }\n\n        if self.validate_struct_keys {\n            match self.value.e {\n                E::InlineTable(ref values) | E::DottedTable(ref values) => {\n                    let extra_fields = values\n                        .iter()\n                        .filter_map(|key_value| {\n                            let (ref key, ref _val) = *key_value;\n                            if !fields.contains(&&*(key.1)) {\n                                Some(key.clone())\n                            } else {\n                                None\n                            }\n                        })\n                        .collect::<Vec<_>>();\n\n                    if !extra_fields.is_empty() {\n                        return Err(Error::from_kind(\n                            Some(self.value.start),\n                            ErrorKind::UnexpectedKeys {\n                                keys: extra_fields\n                                    .iter()\n                                    .map(|k| k.1.to_string())\n                                    .collect::<Vec<_>>(),\n                                available: fields,\n                            },\n                        ));\n                    }\n                }\n                _ => {}\n            }\n        }\n\n        if name == spanned::NAME && fields == [spanned::START, spanned::END, spanned::VALUE] {\n            let start = self.value.start;\n            let end = self.value.end;\n\n            return visitor.visit_map(SpannedDeserializer {\n                phantom_data: PhantomData,\n                start: Some(start),\n                value: Some(self.value),\n                end: Some(end),\n            });\n        }\n\n        self.deserialize_any(visitor)\n    }\n\n    // `None` is interpreted as a missing field so be sure to implement `Some`\n    // as a present field.\n    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        visitor.visit_some(self)\n    }\n\n    fn deserialize_enum<V>(\n        self,\n        _name: &'static str,\n        _variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        match self.value.e {\n            E::String(val) => visitor.visit_enum(val.into_deserializer()),\n            E::InlineTable(values) => {\n                if values.len() != 1 {\n                    Err(Error::from_kind(\n                        Some(self.value.start),\n                        ErrorKind::Wanted {\n                            expected: \"exactly 1 element\",\n                            found: if values.is_empty() {\n                                \"zero elements\"\n                            } else {\n                                \"more than 1 element\"\n                            },\n                        },\n                    ))\n                } else {\n                    visitor.visit_enum(InlineTableDeserializer {\n                        values: values.into_iter(),\n                        next_value: None,\n                    })\n                }\n            }\n            e => Err(Error::from_kind(\n                Some(self.value.start),\n                ErrorKind::Wanted {\n                    expected: \"string or inline table\",\n                    found: e.type_name(),\n                },\n            )),\n        }\n    }\n\n    fn deserialize_newtype_struct<V>(\n        self,\n        _name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        visitor.visit_newtype_struct(self)\n    }\n\n    serde::forward_to_deserialize_any! {\n        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string seq\n        bytes byte_buf map unit identifier\n        ignored_any unit_struct tuple_struct tuple\n    }\n}\n\nimpl<'de, 'b> de::IntoDeserializer<'de, Error> for MapVisitor<'de, 'b> {\n    type Deserializer = MapVisitor<'de, 'b>;\n\n    fn into_deserializer(self) -> Self::Deserializer {\n        self\n    }\n}\n\nimpl<'de, 'b> de::IntoDeserializer<'de, Error> for &'b mut Deserializer<'de> {\n    type Deserializer = Self;\n\n    fn into_deserializer(self) -> Self::Deserializer {\n        self\n    }\n}\n\nimpl<'de> de::IntoDeserializer<'de, Error> for Value<'de> {\n    type Deserializer = ValueDeserializer<'de>;\n\n    fn into_deserializer(self) -> Self::Deserializer {\n        ValueDeserializer::new(self)\n    }\n}\n\nstruct SpannedDeserializer<'de, T: de::IntoDeserializer<'de, Error>> {\n    phantom_data: PhantomData<&'de ()>,\n    start: Option<usize>,\n    end: Option<usize>,\n    value: Option<T>,\n}\n\nimpl<'de, T> de::MapAccess<'de> for SpannedDeserializer<'de, T>\nwhere\n    T: de::IntoDeserializer<'de, Error>,\n{\n    type Error = Error;\n\n    fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Error>\n    where\n        K: de::DeserializeSeed<'de>,\n    {\n        if self.start.is_some() {\n            seed.deserialize(BorrowedStrDeserializer::new(spanned::START))\n                .map(Some)\n        } else if self.end.is_some() {\n            seed.deserialize(BorrowedStrDeserializer::new(spanned::END))\n                .map(Some)\n        } else if self.value.is_some() {\n            seed.deserialize(BorrowedStrDeserializer::new(spanned::VALUE))\n                .map(Some)\n        } else {\n            Ok(None)\n        }\n    }\n\n    fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Error>\n    where\n        V: de::DeserializeSeed<'de>,\n    {\n        if let Some(start) = self.start.take() {\n            seed.deserialize(start.into_deserializer())\n        } else if let Some(end) = self.end.take() {\n            seed.deserialize(end.into_deserializer())\n        } else if let Some(value) = self.value.take() {\n            seed.deserialize(value.into_deserializer())\n        } else {\n            panic!(\"next_value_seed called before next_key_seed\")\n        }\n    }\n}\n\nstruct DatetimeDeserializer<'a> {\n    visited: bool,\n    date: &'a str,\n}\n\nimpl<'de> de::MapAccess<'de> for DatetimeDeserializer<'de> {\n    type Error = Error;\n\n    fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Error>\n    where\n        K: de::DeserializeSeed<'de>,\n    {\n        if self.visited {\n            return Ok(None);\n        }\n        self.visited = true;\n        seed.deserialize(DatetimeFieldDeserializer).map(Some)\n    }\n\n    fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Error>\n    where\n        V: de::DeserializeSeed<'de>,\n    {\n        seed.deserialize(StrDeserializer::new(self.date.into()))\n    }\n}\n\nstruct DatetimeFieldDeserializer;\n\nimpl<'de> de::Deserializer<'de> for DatetimeFieldDeserializer {\n    type Error = Error;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        visitor.visit_borrowed_str(datetime::FIELD)\n    }\n\n    serde::forward_to_deserialize_any! {\n        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string seq\n        bytes byte_buf map struct option unit newtype_struct\n        ignored_any unit_struct tuple_struct tuple enum identifier\n    }\n}\n\nstruct DottedTableDeserializer<'a> {\n    name: Cow<'a, str>,\n    value: Value<'a>,\n}\n\nimpl<'de> de::EnumAccess<'de> for DottedTableDeserializer<'de> {\n    type Error = Error;\n    type Variant = TableEnumDeserializer<'de>;\n\n    fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>\n    where\n        V: de::DeserializeSeed<'de>,\n    {\n        let (name, value) = (self.name, self.value);\n        seed.deserialize(StrDeserializer::new(name))\n            .map(|val| (val, TableEnumDeserializer { value }))\n    }\n}\n\nstruct InlineTableDeserializer<'a> {\n    values: vec::IntoIter<TablePair<'a>>,\n    next_value: Option<Value<'a>>,\n}\n\nimpl<'de> de::MapAccess<'de> for InlineTableDeserializer<'de> {\n    type Error = Error;\n\n    fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Error>\n    where\n        K: de::DeserializeSeed<'de>,\n    {\n        let (key, value) = match self.values.next() {\n            Some(pair) => pair,\n            None => return Ok(None),\n        };\n        self.next_value = Some(value);\n        seed.deserialize(StrDeserializer::spanned(key)).map(Some)\n    }\n\n    fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Error>\n    where\n        V: de::DeserializeSeed<'de>,\n    {\n        let value = self.next_value.take().expect(\"Unable to read table values\");\n        seed.deserialize(ValueDeserializer::new(value))\n    }\n}\n\nimpl<'de> de::EnumAccess<'de> for InlineTableDeserializer<'de> {\n    type Error = Error;\n    type Variant = TableEnumDeserializer<'de>;\n\n    fn variant_seed<V>(mut self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>\n    where\n        V: de::DeserializeSeed<'de>,\n    {\n        let (key, value) = match self.values.next() {\n            Some(pair) => pair,\n            None => {\n                return Err(Error::from_kind(\n                    None, // FIXME: How do we get an offset here?\n                    ErrorKind::Wanted {\n                        expected: \"table with exactly 1 entry\",\n                        found: \"empty table\",\n                    },\n                ));\n            }\n        };\n\n        seed.deserialize(StrDeserializer::new(key.1))\n            .map(|val| (val, TableEnumDeserializer { value }))\n    }\n}\n\n/// Deserializes table values into enum variants.\nstruct TableEnumDeserializer<'a> {\n    value: Value<'a>,\n}\n\nimpl<'de> de::VariantAccess<'de> for TableEnumDeserializer<'de> {\n    type Error = Error;\n\n    fn unit_variant(self) -> Result<(), Self::Error> {\n        match self.value.e {\n            E::InlineTable(values) | E::DottedTable(values) => {\n                if values.is_empty() {\n                    Ok(())\n                } else {\n                    Err(Error::from_kind(\n                        Some(self.value.start),\n                        ErrorKind::ExpectedEmptyTable,\n                    ))\n                }\n            }\n            e => Err(Error::from_kind(\n                Some(self.value.start),\n                ErrorKind::Wanted {\n                    expected: \"table\",\n                    found: e.type_name(),\n                },\n            )),\n        }\n    }\n\n    fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Self::Error>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        seed.deserialize(ValueDeserializer::new(self.value))\n    }\n\n    fn tuple_variant<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        match self.value.e {\n            E::InlineTable(values) | E::DottedTable(values) => {\n                let tuple_values = values\n                    .into_iter()\n                    .enumerate()\n                    .map(|(index, (key, value))| match key.1.parse::<usize>() {\n                        Ok(key_index) if key_index == index => Ok(value),\n                        Ok(_) | Err(_) => Err(Error::from_kind(\n                            Some(key.0.start),\n                            ErrorKind::ExpectedTupleIndex {\n                                expected: index,\n                                found: key.1.to_string(),\n                            },\n                        )),\n                    })\n                    // Fold all values into a `Vec`, or return the first error.\n                    .fold(Ok(Vec::with_capacity(len)), |result, value_result| {\n                        result.and_then(move |mut tuple_values| match value_result {\n                            Ok(value) => {\n                                tuple_values.push(value);\n                                Ok(tuple_values)\n                            }\n                            // `Result<de::Value, Self::Error>` to `Result<Vec<_>, Self::Error>`\n                            Err(e) => Err(e),\n                        })\n                    })?;\n\n                if tuple_values.len() == len {\n                    de::Deserializer::deserialize_seq(\n                        ValueDeserializer::new(Value {\n                            e: E::Array(tuple_values),\n                            start: self.value.start,\n                            end: self.value.end,\n                        }),\n                        visitor,\n                    )\n                } else {\n                    Err(Error::from_kind(\n                        Some(self.value.start),\n                        ErrorKind::ExpectedTuple(len),\n                    ))\n                }\n            }\n            e => Err(Error::from_kind(\n                Some(self.value.start),\n                ErrorKind::Wanted {\n                    expected: \"table\",\n                    found: e.type_name(),\n                },\n            )),\n        }\n    }\n\n    fn struct_variant<V>(\n        self,\n        fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        de::Deserializer::deserialize_struct(\n            ValueDeserializer::new(self.value).with_struct_key_validation(),\n            \"\", // TODO: this should be the variant name\n            fields,\n            visitor,\n        )\n    }\n}\n\nimpl<'a> Deserializer<'a> {\n    /// Creates a new deserializer which will be deserializing the string\n    /// provided.\n    pub fn new(input: &'a str) -> Deserializer<'a> {\n        Deserializer {\n            tokens: Tokenizer::new(input),\n            input,\n            require_newline_after_table: true,\n            allow_duplciate_after_longer_table: false,\n        }\n    }\n\n    /// The `Deserializer::end` method should be called after a value has been\n    /// fully deserialized.  This allows the `Deserializer` to validate that the\n    /// input stream is at the end or that it only has trailing\n    /// whitespace/comments.\n    pub fn end(&mut self) -> Result<(), Error> {\n        Ok(())\n    }\n\n    /// Historical versions of toml-rs accidentally allowed a newline after a\n    /// table definition, but the TOML spec requires a newline after a table\n    /// definition header.\n    ///\n    /// This option can be set to `false` (the default is `true`) to emulate\n    /// this behavior for backwards compatibility with older toml-rs versions.\n    pub fn set_require_newline_after_table(&mut self, require: bool) {\n        self.require_newline_after_table = require;\n    }\n\n    /// Historical versions of toml-rs accidentally allowed a duplicate table\n    /// header after a longer table header was previously defined. This is\n    /// invalid according to the TOML spec, however.\n    ///\n    /// This option can be set to `true` (the default is `false`) to emulate\n    /// this behavior for backwards compatibility with older toml-rs versions.\n    pub fn set_allow_duplicate_after_longer_table(&mut self, allow: bool) {\n        self.allow_duplciate_after_longer_table = allow;\n    }\n\n    fn tables(&mut self) -> Result<Vec<Table<'a>>, Error> {\n        let mut tables = Vec::new();\n        let mut cur_table = Table {\n            at: 0,\n            header: Vec::new(),\n            values: None,\n            array: false,\n        };\n\n        while let Some(line) = self.line()? {\n            match line {\n                Line::Table {\n                    at,\n                    mut header,\n                    array,\n                } => {\n                    if !cur_table.header.is_empty() || cur_table.values.is_some() {\n                        tables.push(cur_table);\n                    }\n                    cur_table = Table {\n                        at,\n                        header: Vec::new(),\n                        values: Some(Vec::new()),\n                        array,\n                    };\n                    loop {\n                        let part = header.next().map_err(|e| self.token_error(e));\n                        match part? {\n                            Some(part) => cur_table.header.push(part),\n                            None => break,\n                        }\n                    }\n                }\n                Line::KeyValue(key, value) => {\n                    if cur_table.values.is_none() {\n                        cur_table.values = Some(Vec::new());\n                    }\n                    self.add_dotted_key(key, value, cur_table.values.as_mut().unwrap())?;\n                }\n            }\n        }\n        if !cur_table.header.is_empty() || cur_table.values.is_some() {\n            tables.push(cur_table);\n        }\n        Ok(tables)\n    }\n\n    fn line(&mut self) -> Result<Option<Line<'a>>, Error> {\n        loop {\n            self.eat_whitespace()?;\n            if self.eat_comment()? {\n                continue;\n            }\n            if self.eat(Token::Newline)? {\n                continue;\n            }\n            break;\n        }\n\n        match self.peek()? {\n            Some((_, Token::LeftBracket)) => self.table_header().map(Some),\n            Some(_) => self.key_value().map(Some),\n            None => Ok(None),\n        }\n    }\n\n    fn table_header(&mut self) -> Result<Line<'a>, Error> {\n        let start = self.tokens.current();\n        self.expect(Token::LeftBracket)?;\n        let array = self.eat(Token::LeftBracket)?;\n        let ret = Header::new(self.tokens.clone(), array, self.require_newline_after_table);\n        if self.require_newline_after_table {\n            self.tokens.skip_to_newline();\n        } else {\n            loop {\n                match self.next()? {\n                    Some((_, Token::RightBracket)) => {\n                        if array {\n                            self.eat(Token::RightBracket)?;\n                        }\n                        break;\n                    }\n                    Some((_, Token::Newline)) | None => break,\n                    _ => {}\n                }\n            }\n            self.eat_whitespace()?;\n        }\n        Ok(Line::Table {\n            at: start,\n            header: ret,\n            array,\n        })\n    }\n\n    fn key_value(&mut self) -> Result<Line<'a>, Error> {\n        let key = self.dotted_key()?;\n        self.eat_whitespace()?;\n        self.expect(Token::Equals)?;\n        self.eat_whitespace()?;\n\n        let value = self.value()?;\n        self.eat_whitespace()?;\n        if !self.eat_comment()? {\n            self.eat_newline_or_eof()?;\n        }\n\n        Ok(Line::KeyValue(key, value))\n    }\n\n    fn value(&mut self) -> Result<Value<'a>, Error> {\n        let at = self.tokens.current();\n        let value = match self.next()? {\n            Some((Span { start, end }, Token::String { val, .. })) => Value {\n                e: E::String(val),\n                start,\n                end,\n            },\n            Some((Span { start, end }, Token::Keylike(\"true\"))) => Value {\n                e: E::Boolean(true),\n                start,\n                end,\n            },\n            Some((Span { start, end }, Token::Keylike(\"false\"))) => Value {\n                e: E::Boolean(false),\n                start,\n                end,\n            },\n            Some((span, Token::Keylike(key))) => self.number_or_date(span, key)?,\n            Some((span, Token::Plus)) => self.number_leading_plus(span)?,\n            Some((Span { start, .. }, Token::LeftBrace)) => {\n                self.inline_table().map(|(Span { end, .. }, table)| Value {\n                    e: E::InlineTable(table),\n                    start,\n                    end,\n                })?\n            }\n            Some((Span { start, .. }, Token::LeftBracket)) => {\n                self.array().map(|(Span { end, .. }, array)| Value {\n                    e: E::Array(array),\n                    start,\n                    end,\n                })?\n            }\n            Some(token) => {\n                return Err(self.error(\n                    at,\n                    ErrorKind::Wanted {\n                        expected: \"a value\",\n                        found: token.1.describe(),\n                    },\n                ))\n            }\n            None => return Err(self.eof()),\n        };\n        Ok(value)\n    }\n\n    fn number_or_date(&mut self, span: Span, s: &'a str) -> Result<Value<'a>, Error> {\n        if s.contains('T')\n            || s.contains('t')\n            || (s.len() > 1 && s[1..].contains('-') && !s.contains(\"e-\") && !s.contains(\"E-\"))\n        {\n            self.datetime(span, s, false)\n                .map(|(Span { start, end }, d)| Value {\n                    e: E::Datetime(d),\n                    start,\n                    end,\n                })\n        } else if self.eat(Token::Colon)? {\n            self.datetime(span, s, true)\n                .map(|(Span { start, end }, d)| Value {\n                    e: E::Datetime(d),\n                    start,\n                    end,\n                })\n        } else {\n            self.number(span, s)\n        }\n    }\n\n    /// Returns a string or table value type.\n    ///\n    /// Used to deserialize enums. Unit enums may be represented as a string or a table, all other\n    /// structures (tuple, newtype, struct) must be represented as a table.\n    fn string_or_table(&mut self) -> Result<(Value<'a>, Option<Cow<'a, str>>), Error> {\n        match self.peek()? {\n            Some((span, Token::LeftBracket)) => {\n                let tables = self.tables()?;\n                if tables.len() != 1 {\n                    return Err(Error::from_kind(\n                        Some(span.start),\n                        ErrorKind::Wanted {\n                            expected: \"exactly 1 table\",\n                            found: if tables.is_empty() {\n                                \"zero tables\"\n                            } else {\n                                \"more than 1 table\"\n                            },\n                        },\n                    ));\n                }\n\n                let table = tables\n                    .into_iter()\n                    .next()\n                    .expect(\"Expected exactly one table\");\n                let header = table\n                    .header\n                    .last()\n                    .expect(\"Expected at least one header value for table.\");\n\n                let start = table.at;\n                let end = table\n                    .values\n                    .as_ref()\n                    .and_then(|values| values.last())\n                    .map(|&(_, ref val)| val.end)\n                    .unwrap_or_else(|| header.1.len());\n                Ok((\n                    Value {\n                        e: E::DottedTable(table.values.unwrap_or_else(Vec::new)),\n                        start,\n                        end,\n                    },\n                    Some(header.1.clone()),\n                ))\n            }\n            Some(_) => self.value().map(|val| (val, None)),\n            None => Err(self.eof()),\n        }\n    }\n\n    fn number(&mut self, Span { start, end }: Span, s: &'a str) -> Result<Value<'a>, Error> {\n        let to_integer = |f| Value {\n            e: E::Integer(f),\n            start,\n            end,\n        };\n        if s.starts_with(\"0x\") {\n            self.integer(&s[2..], 16).map(to_integer)\n        } else if s.starts_with(\"0o\") {\n            self.integer(&s[2..], 8).map(to_integer)\n        } else if s.starts_with(\"0b\") {\n            self.integer(&s[2..], 2).map(to_integer)\n        } else if s.contains('e') || s.contains('E') {\n            self.float(s, None).map(|f| Value {\n                e: E::Float(f),\n                start,\n                end,\n            })\n        } else if self.eat(Token::Period)? {\n            let at = self.tokens.current();\n            match self.next()? {\n                Some((Span { start, end }, Token::Keylike(after))) => {\n                    self.float(s, Some(after)).map(|f| Value {\n                        e: E::Float(f),\n                        start,\n                        end,\n                    })\n                }\n                _ => Err(self.error(at, ErrorKind::NumberInvalid)),\n            }\n        } else if s == \"inf\" {\n            Ok(Value {\n                e: E::Float(f64::INFINITY),\n                start,\n                end,\n            })\n        } else if s == \"-inf\" {\n            Ok(Value {\n                e: E::Float(f64::NEG_INFINITY),\n                start,\n                end,\n            })\n        } else if s == \"nan\" {\n            Ok(Value {\n                e: E::Float(f64::NAN),\n                start,\n                end,\n            })\n        } else if s == \"-nan\" {\n            Ok(Value {\n                e: E::Float(-f64::NAN),\n                start,\n                end,\n            })\n        } else {\n            self.integer(s, 10).map(to_integer)\n        }\n    }\n\n    fn number_leading_plus(&mut self, Span { start, .. }: Span) -> Result<Value<'a>, Error> {\n        let start_token = self.tokens.current();\n        match self.next()? {\n            Some((Span { end, .. }, Token::Keylike(s))) => self.number(Span { start, end }, s),\n            _ => Err(self.error(start_token, ErrorKind::NumberInvalid)),\n        }\n    }\n\n    fn integer(&self, s: &'a str, radix: u32) -> Result<i64, Error> {\n        let allow_sign = radix == 10;\n        let allow_leading_zeros = radix != 10;\n        let (prefix, suffix) = self.parse_integer(s, allow_sign, allow_leading_zeros, radix)?;\n        let start = self.tokens.substr_offset(s);\n        if suffix != \"\" {\n            return Err(self.error(start, ErrorKind::NumberInvalid));\n        }\n        i64::from_str_radix(&prefix.replace(\"_\", \"\").trim_start_matches('+'), radix)\n            .map_err(|_e| self.error(start, ErrorKind::NumberInvalid))\n    }\n\n    fn parse_integer(\n        &self,\n        s: &'a str,\n        allow_sign: bool,\n        allow_leading_zeros: bool,\n        radix: u32,\n    ) -> Result<(&'a str, &'a str), Error> {\n        let start = self.tokens.substr_offset(s);\n\n        let mut first = true;\n        let mut first_zero = false;\n        let mut underscore = false;\n        let mut end = s.len();\n        for (i, c) in s.char_indices() {\n            let at = i + start;\n            if i == 0 && (c == '+' || c == '-') && allow_sign {\n                continue;\n            }\n\n            if c == '0' && first {\n                first_zero = true;\n            } else if c.is_digit(radix) {\n                if !first && first_zero && !allow_leading_zeros {\n                    return Err(self.error(at, ErrorKind::NumberInvalid));\n                }\n                underscore = false;\n            } else if c == '_' && first {\n                return Err(self.error(at, ErrorKind::NumberInvalid));\n            } else if c == '_' && !underscore {\n                underscore = true;\n            } else {\n                end = i;\n                break;\n            }\n            first = false;\n        }\n        if first || underscore {\n            return Err(self.error(start, ErrorKind::NumberInvalid));\n        }\n        Ok((&s[..end], &s[end..]))\n    }\n\n    fn float(&mut self, s: &'a str, after_decimal: Option<&'a str>) -> Result<f64, Error> {\n        let (integral, mut suffix) = self.parse_integer(s, true, false, 10)?;\n        let start = self.tokens.substr_offset(integral);\n\n        let mut fraction = None;\n        if let Some(after) = after_decimal {\n            if suffix != \"\" {\n                return Err(self.error(start, ErrorKind::NumberInvalid));\n            }\n            let (a, b) = self.parse_integer(after, false, true, 10)?;\n            fraction = Some(a);\n            suffix = b;\n        }\n\n        let mut exponent = None;\n        if suffix.starts_with('e') || suffix.starts_with('E') {\n            let (a, b) = if suffix.len() == 1 {\n                self.eat(Token::Plus)?;\n                match self.next()? {\n                    Some((_, Token::Keylike(s))) => self.parse_integer(s, false, true, 10)?,\n                    _ => return Err(self.error(start, ErrorKind::NumberInvalid)),\n                }\n            } else {\n                self.parse_integer(&suffix[1..], true, true, 10)?\n            };\n            if b != \"\" {\n                return Err(self.error(start, ErrorKind::NumberInvalid));\n            }\n            exponent = Some(a);\n        } else if !suffix.is_empty() {\n            return Err(self.error(start, ErrorKind::NumberInvalid));\n        }\n\n        let mut number = integral\n            .trim_start_matches('+')\n            .chars()\n            .filter(|c| *c != '_')\n            .collect::<String>();\n        if let Some(fraction) = fraction {\n            number.push_str(\".\");\n            number.extend(fraction.chars().filter(|c| *c != '_'));\n        }\n        if let Some(exponent) = exponent {\n            number.push_str(\"E\");\n            number.extend(exponent.chars().filter(|c| *c != '_'));\n        }\n        number\n            .parse()\n            .map_err(|_e| self.error(start, ErrorKind::NumberInvalid))\n            .and_then(|n: f64| {\n                if n.is_finite() {\n                    Ok(n)\n                } else {\n                    Err(self.error(start, ErrorKind::NumberInvalid))\n                }\n            })\n    }\n\n    fn datetime(\n        &mut self,\n        mut span: Span,\n        date: &'a str,\n        colon_eaten: bool,\n    ) -> Result<(Span, &'a str), Error> {\n        let start = self.tokens.substr_offset(date);\n\n        // Check for space separated date and time.\n        let mut lookahead = self.tokens.clone();\n        if let Ok(Some((_, Token::Whitespace(\" \")))) = lookahead.next() {\n            // Check if hour follows.\n            if let Ok(Some((_, Token::Keylike(_)))) = lookahead.next() {\n                self.next()?; // skip space\n                self.next()?; // skip keylike hour\n            }\n        }\n\n        if colon_eaten || self.eat(Token::Colon)? {\n            // minutes\n            match self.next()? {\n                Some((_, Token::Keylike(_))) => {}\n                _ => return Err(self.error(start, ErrorKind::DateInvalid)),\n            }\n            // Seconds\n            self.expect(Token::Colon)?;\n            match self.next()? {\n                Some((Span { end, .. }, Token::Keylike(_))) => {\n                    span.end = end;\n                }\n                _ => return Err(self.error(start, ErrorKind::DateInvalid)),\n            }\n            // Fractional seconds\n            if self.eat(Token::Period)? {\n                match self.next()? {\n                    Some((Span { end, .. }, Token::Keylike(_))) => {\n                        span.end = end;\n                    }\n                    _ => return Err(self.error(start, ErrorKind::DateInvalid)),\n                }\n            }\n\n            // offset\n            if self.eat(Token::Plus)? {\n                match self.next()? {\n                    Some((Span { end, .. }, Token::Keylike(_))) => {\n                        span.end = end;\n                    }\n                    _ => return Err(self.error(start, ErrorKind::DateInvalid)),\n                }\n            }\n            if self.eat(Token::Colon)? {\n                match self.next()? {\n                    Some((Span { end, .. }, Token::Keylike(_))) => {\n                        span.end = end;\n                    }\n                    _ => return Err(self.error(start, ErrorKind::DateInvalid)),\n                }\n            }\n        }\n\n        let end = self.tokens.current();\n        Ok((span, &self.tokens.input()[start..end]))\n    }\n\n    // TODO(#140): shouldn't buffer up this entire table in memory, it'd be\n    // great to defer parsing everything until later.\n    fn inline_table(&mut self) -> Result<(Span, Vec<TablePair<'a>>), Error> {\n        let mut ret = Vec::new();\n        self.eat_whitespace()?;\n        if let Some(span) = self.eat_spanned(Token::RightBrace)? {\n            return Ok((span, ret));\n        }\n        loop {\n            let key = self.dotted_key()?;\n            self.eat_whitespace()?;\n            self.expect(Token::Equals)?;\n            self.eat_whitespace()?;\n            let value = self.value()?;\n            self.add_dotted_key(key, value, &mut ret)?;\n\n            self.eat_whitespace()?;\n            if let Some(span) = self.eat_spanned(Token::RightBrace)? {\n                return Ok((span, ret));\n            }\n            self.expect(Token::Comma)?;\n            self.eat_whitespace()?;\n        }\n    }\n\n    // TODO(#140): shouldn't buffer up this entire array in memory, it'd be\n    // great to defer parsing everything until later.\n    fn array(&mut self) -> Result<(Span, Vec<Value<'a>>), Error> {\n        let mut ret = Vec::new();\n\n        let intermediate = |me: &mut Deserializer<'_>| {\n            loop {\n                me.eat_whitespace()?;\n                if !me.eat(Token::Newline)? && !me.eat_comment()? {\n                    break;\n                }\n            }\n            Ok(())\n        };\n\n        loop {\n            intermediate(self)?;\n            if let Some(span) = self.eat_spanned(Token::RightBracket)? {\n                return Ok((span, ret));\n            }\n            let value = self.value()?;\n            ret.push(value);\n            intermediate(self)?;\n            if !self.eat(Token::Comma)? {\n                break;\n            }\n        }\n        intermediate(self)?;\n        let span = self.expect_spanned(Token::RightBracket)?;\n        Ok((span, ret))\n    }\n\n    fn table_key(&mut self) -> Result<(Span, Cow<'a, str>), Error> {\n        self.tokens.table_key().map_err(|e| self.token_error(e))\n    }\n\n    fn dotted_key(&mut self) -> Result<Vec<(Span, Cow<'a, str>)>, Error> {\n        let mut result = Vec::new();\n        result.push(self.table_key()?);\n        self.eat_whitespace()?;\n        while self.eat(Token::Period)? {\n            self.eat_whitespace()?;\n            result.push(self.table_key()?);\n            self.eat_whitespace()?;\n        }\n        Ok(result)\n    }\n\n    /// Stores a value in the appropriate hierachical structure positioned based on the dotted key.\n    ///\n    /// Given the following definition: `multi.part.key = \"value\"`, `multi` and `part` are\n    /// intermediate parts which are mapped to the relevant fields in the deserialized type's data\n    /// hierarchy.\n    ///\n    /// # Parameters\n    ///\n    /// * `key_parts`: Each segment of the dotted key, e.g. `part.one` maps to\n    ///                `vec![Cow::Borrowed(\"part\"), Cow::Borrowed(\"one\")].`\n    /// * `value`: The parsed value.\n    /// * `values`: The `Vec` to store the value in.\n    fn add_dotted_key(\n        &self,\n        mut key_parts: Vec<(Span, Cow<'a, str>)>,\n        value: Value<'a>,\n        values: &mut Vec<TablePair<'a>>,\n    ) -> Result<(), Error> {\n        let key = key_parts.remove(0);\n        if key_parts.is_empty() {\n            values.push((key, value));\n            return Ok(());\n        }\n        match values.iter_mut().find(|&&mut (ref k, _)| *k.1 == key.1) {\n            Some(&mut (\n                _,\n                Value {\n                    e: E::DottedTable(ref mut v),\n                    ..\n                },\n            )) => {\n                return self.add_dotted_key(key_parts, value, v);\n            }\n            Some(&mut (_, Value { start, .. })) => {\n                return Err(self.error(start, ErrorKind::DottedKeyInvalidType));\n            }\n            None => {}\n        }\n        // The start/end value is somewhat misleading here.\n        let table_values = Value {\n            e: E::DottedTable(Vec::new()),\n            start: value.start,\n            end: value.end,\n        };\n        values.push((key, table_values));\n        let last_i = values.len() - 1;\n        if let (\n            _,\n            Value {\n                e: E::DottedTable(ref mut v),\n                ..\n            },\n        ) = values[last_i]\n        {\n            self.add_dotted_key(key_parts, value, v)?;\n        }\n        Ok(())\n    }\n\n    fn eat_whitespace(&mut self) -> Result<(), Error> {\n        self.tokens\n            .eat_whitespace()\n            .map_err(|e| self.token_error(e))\n    }\n\n    fn eat_comment(&mut self) -> Result<bool, Error> {\n        self.tokens.eat_comment().map_err(|e| self.token_error(e))\n    }\n\n    fn eat_newline_or_eof(&mut self) -> Result<(), Error> {\n        self.tokens\n            .eat_newline_or_eof()\n            .map_err(|e| self.token_error(e))\n    }\n\n    fn eat(&mut self, expected: Token<'a>) -> Result<bool, Error> {\n        self.tokens.eat(expected).map_err(|e| self.token_error(e))\n    }\n\n    fn eat_spanned(&mut self, expected: Token<'a>) -> Result<Option<Span>, Error> {\n        self.tokens\n            .eat_spanned(expected)\n            .map_err(|e| self.token_error(e))\n    }\n\n    fn expect(&mut self, expected: Token<'a>) -> Result<(), Error> {\n        self.tokens\n            .expect(expected)\n            .map_err(|e| self.token_error(e))\n    }\n\n    fn expect_spanned(&mut self, expected: Token<'a>) -> Result<Span, Error> {\n        self.tokens\n            .expect_spanned(expected)\n            .map_err(|e| self.token_error(e))\n    }\n\n    fn next(&mut self) -> Result<Option<(Span, Token<'a>)>, Error> {\n        self.tokens.next().map_err(|e| self.token_error(e))\n    }\n\n    fn peek(&mut self) -> Result<Option<(Span, Token<'a>)>, Error> {\n        self.tokens.peek().map_err(|e| self.token_error(e))\n    }\n\n    fn eof(&self) -> Error {\n        self.error(self.input.len(), ErrorKind::UnexpectedEof)\n    }\n\n    fn token_error(&self, error: TokenError) -> Error {\n        match error {\n            TokenError::InvalidCharInString(at, ch) => {\n                self.error(at, ErrorKind::InvalidCharInString(ch))\n            }\n            TokenError::InvalidEscape(at, ch) => self.error(at, ErrorKind::InvalidEscape(ch)),\n            TokenError::InvalidEscapeValue(at, v) => {\n                self.error(at, ErrorKind::InvalidEscapeValue(v))\n            }\n            TokenError::InvalidHexEscape(at, ch) => self.error(at, ErrorKind::InvalidHexEscape(ch)),\n            TokenError::NewlineInString(at) => self.error(at, ErrorKind::NewlineInString),\n            TokenError::Unexpected(at, ch) => self.error(at, ErrorKind::Unexpected(ch)),\n            TokenError::UnterminatedString(at) => self.error(at, ErrorKind::UnterminatedString),\n            TokenError::NewlineInTableKey(at) => self.error(at, ErrorKind::NewlineInTableKey),\n            TokenError::Wanted {\n                at,\n                expected,\n                found,\n            } => self.error(at, ErrorKind::Wanted { expected, found }),\n            TokenError::EmptyTableKey(at) => self.error(at, ErrorKind::EmptyTableKey),\n            TokenError::MultilineStringKey(at) => self.error(at, ErrorKind::MultilineStringKey),\n        }\n    }\n\n    fn error(&self, at: usize, kind: ErrorKind) -> Error {\n        let mut err = Error::from_kind(Some(at), kind);\n        err.fix_linecol(|at| self.to_linecol(at));\n        err\n    }\n\n    /// Converts a byte offset from an error message to a (line, column) pair\n    ///\n    /// All indexes are 0-based.\n    fn to_linecol(&self, offset: usize) -> (usize, usize) {\n        let mut cur = 0;\n        // Use split_terminator instead of lines so that if there is a `\\r`,\n        // it is included in the offset calculation. The `+1` values below\n        // account for the `\\n`.\n        for (i, line) in self.input.split_terminator('\\n').enumerate() {\n            if cur + line.len() + 1 > offset {\n                return (i, offset - cur);\n            }\n            cur += line.len() + 1;\n        }\n        (self.input.lines().count(), 0)\n    }\n}\n\nimpl Error {\n    /// Produces a (line, column) pair of the position of the error if available\n    ///\n    /// All indexes are 0-based.\n    pub fn line_col(&self) -> Option<(usize, usize)> {\n        self.inner.line.map(|line| (line, self.inner.col))\n    }\n\n    fn from_kind(at: Option<usize>, kind: ErrorKind) -> Error {\n        Error {\n            inner: Box::new(ErrorInner {\n                kind,\n                line: None,\n                col: 0,\n                at,\n                message: String::new(),\n                key: Vec::new(),\n            }),\n        }\n    }\n\n    fn custom(at: Option<usize>, s: String) -> Error {\n        Error {\n            inner: Box::new(ErrorInner {\n                kind: ErrorKind::Custom,\n                line: None,\n                col: 0,\n                at,\n                message: s,\n                key: Vec::new(),\n            }),\n        }\n    }\n\n    pub(crate) fn add_key_context(&mut self, key: &str) {\n        self.inner.key.insert(0, key.to_string());\n    }\n\n    fn fix_offset<F>(&mut self, f: F)\n    where\n        F: FnOnce() -> Option<usize>,\n    {\n        // An existing offset is always better positioned than anything we\n        // might want to add later.\n        if self.inner.at.is_none() {\n            self.inner.at = f();\n        }\n    }\n\n    fn fix_linecol<F>(&mut self, f: F)\n    where\n        F: FnOnce(usize) -> (usize, usize),\n    {\n        if let Some(at) = self.inner.at {\n            let (line, col) = f(at);\n            self.inner.line = Some(line);\n            self.inner.col = col;\n        }\n    }\n}\n\nimpl std::convert::From<Error> for std::io::Error {\n    fn from(e: Error) -> Self {\n        std::io::Error::new(std::io::ErrorKind::InvalidData, e.to_string())\n    }\n}\n\nimpl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self.inner.kind {\n            ErrorKind::UnexpectedEof => \"unexpected eof encountered\".fmt(f)?,\n            ErrorKind::InvalidCharInString(c) => write!(\n                f,\n                \"invalid character in string: `{}`\",\n                c.escape_default().collect::<String>()\n            )?,\n            ErrorKind::InvalidEscape(c) => write!(\n                f,\n                \"invalid escape character in string: `{}`\",\n                c.escape_default().collect::<String>()\n            )?,\n            ErrorKind::InvalidHexEscape(c) => write!(\n                f,\n                \"invalid hex escape character in string: `{}`\",\n                c.escape_default().collect::<String>()\n            )?,\n            ErrorKind::InvalidEscapeValue(c) => write!(f, \"invalid escape value: `{}`\", c)?,\n            ErrorKind::NewlineInString => \"newline in string found\".fmt(f)?,\n            ErrorKind::Unexpected(ch) => write!(\n                f,\n                \"unexpected character found: `{}`\",\n                ch.escape_default().collect::<String>()\n            )?,\n            ErrorKind::UnterminatedString => \"unterminated string\".fmt(f)?,\n            ErrorKind::NewlineInTableKey => \"found newline in table key\".fmt(f)?,\n            ErrorKind::Wanted { expected, found } => {\n                write!(f, \"expected {}, found {}\", expected, found)?\n            }\n            ErrorKind::NumberInvalid => \"invalid number\".fmt(f)?,\n            ErrorKind::DateInvalid => \"invalid date\".fmt(f)?,\n            ErrorKind::DuplicateTable(ref s) => {\n                write!(f, \"redefinition of table `{}`\", s)?;\n            }\n            ErrorKind::RedefineAsArray => \"table redefined as array\".fmt(f)?,\n            ErrorKind::EmptyTableKey => \"empty table key found\".fmt(f)?,\n            ErrorKind::MultilineStringKey => \"multiline strings are not allowed for key\".fmt(f)?,\n            ErrorKind::Custom => self.inner.message.fmt(f)?,\n            ErrorKind::ExpectedTuple(l) => write!(f, \"expected table with length {}\", l)?,\n            ErrorKind::ExpectedTupleIndex {\n                expected,\n                ref found,\n            } => write!(f, \"expected table key `{}`, but was `{}`\", expected, found)?,\n            ErrorKind::ExpectedEmptyTable => \"expected empty table\".fmt(f)?,\n            ErrorKind::DottedKeyInvalidType => {\n                \"dotted key attempted to extend non-table type\".fmt(f)?\n            }\n            ErrorKind::UnexpectedKeys {\n                ref keys,\n                available,\n            } => write!(\n                f,\n                \"unexpected keys in table: `{:?}`, available keys: `{:?}`\",\n                keys, available\n            )?,\n            ErrorKind::__Nonexhaustive => panic!(),\n        }\n\n        if !self.inner.key.is_empty() {\n            write!(f, \" for key `\")?;\n            for (i, k) in self.inner.key.iter().enumerate() {\n                if i > 0 {\n                    write!(f, \".\")?;\n                }\n                write!(f, \"{}\", k)?;\n            }\n            write!(f, \"`\")?;\n        }\n\n        if let Some(line) = self.inner.line {\n            write!(f, \" at line {} column {}\", line + 1, self.inner.col + 1)?;\n        }\n\n        Ok(())\n    }\n}\n\nimpl error::Error for Error {}\n\nimpl de::Error for Error {\n    fn custom<T: fmt::Display>(msg: T) -> Error {\n        Error::custom(None, msg.to_string())\n    }\n}\n\nenum Line<'a> {\n    Table {\n        at: usize,\n        header: Header<'a>,\n        array: bool,\n    },\n    KeyValue(Vec<(Span, Cow<'a, str>)>, Value<'a>),\n}\n\nstruct Header<'a> {\n    first: bool,\n    array: bool,\n    require_newline_after_table: bool,\n    tokens: Tokenizer<'a>,\n}\n\nimpl<'a> Header<'a> {\n    fn new(tokens: Tokenizer<'a>, array: bool, require_newline_after_table: bool) -> Header<'a> {\n        Header {\n            first: true,\n            array,\n            tokens,\n            require_newline_after_table,\n        }\n    }\n\n    fn next(&mut self) -> Result<Option<(Span, Cow<'a, str>)>, TokenError> {\n        self.tokens.eat_whitespace()?;\n\n        if self.first || self.tokens.eat(Token::Period)? {\n            self.first = false;\n            self.tokens.eat_whitespace()?;\n            self.tokens.table_key().map(|t| t).map(Some)\n        } else {\n            self.tokens.expect(Token::RightBracket)?;\n            if self.array {\n                self.tokens.expect(Token::RightBracket)?;\n            }\n\n            self.tokens.eat_whitespace()?;\n            if self.require_newline_after_table && !self.tokens.eat_comment()? {\n                self.tokens.eat_newline_or_eof()?;\n            }\n            Ok(None)\n        }\n    }\n}\n\n#[derive(Debug)]\nstruct Value<'a> {\n    e: E<'a>,\n    start: usize,\n    end: usize,\n}\n\n#[derive(Debug)]\nenum E<'a> {\n    Integer(i64),\n    Float(f64),\n    Boolean(bool),\n    String(Cow<'a, str>),\n    Datetime(&'a str),\n    Array(Vec<Value<'a>>),\n    InlineTable(Vec<TablePair<'a>>),\n    DottedTable(Vec<TablePair<'a>>),\n}\n\nimpl<'a> E<'a> {\n    fn type_name(&self) -> &'static str {\n        match *self {\n            E::String(..) => \"string\",\n            E::Integer(..) => \"integer\",\n            E::Float(..) => \"float\",\n            E::Boolean(..) => \"boolean\",\n            E::Datetime(..) => \"datetime\",\n            E::Array(..) => \"array\",\n            E::InlineTable(..) => \"inline table\",\n            E::DottedTable(..) => \"dotted table\",\n        }\n    }\n}\n","traces":[{"line":75,"address":[4349360,4347556,4349412,4348128,4348180,4347504,4348736,4348788],"length":1,"stats":{"Line":5},"fn_name":"from_str<enum_external_deserialize::OuterStruct>"},{"line":79,"address":[4349386,4347530,4348154,4348762],"length":1,"stats":{"Line":6},"fn_name":null},{"line":80,"address":[4349003,4349427,4349627,4349567,4348195,4348395,4348335,4348943,4347571,4347771,4348803,4347711],"length":1,"stats":{"Line":7},"fn_name":null},{"line":81,"address":[4349651,4349546,4348922,4347795,4349169,4347690,4349027,4348314,4347937,4349793,4348419,4348561],"length":1,"stats":{"Line":10},"fn_name":null},{"line":82,"address":[4349174,4347942,4348566,4349798],"length":1,"stats":{"Line":5},"fn_name":null},{"line":209,"address":[4424048,4422704,4422780,4425376,4425452,4426704,4426780,4421442,4421376,4424124],"length":1,"stats":{"Line":3},"fn_name":"deserialize_any<serde::de::ignored_any::IgnoredAny>"},{"line":213,"address":[4422795,4426937,4424063,4422997,4425669,4424341,4425467,4421457,4422719,4421391,4421599,4422937,4424139,4424281,4426795,4426719,4426997,4425391,4421657,4425609],"length":1,"stats":{"Line":6},"fn_name":null},{"line":214,"address":[4421711,4425705,4426908,4423033,4427033,4424377,4421570,4422908,4425580,4424252],"length":1,"stats":{"Line":6},"fn_name":null},{"line":215,"address":[4421740,4423062,4425734,4427062,4424406],"length":1,"stats":{"Line":3},"fn_name":null},{"line":217,"address":[4423379,4425808,4423136,4424480,4422060,4421814,4424723,4426051,4427136,4427379],"length":1,"stats":{"Line":6},"fn_name":null},{"line":218,"address":[4425886,4424496,4425824,4421892,4427152,4421830,4423152,4423214,4427214,4424558],"length":1,"stats":{"Line":6},"fn_name":null},{"line":219,"address":[4427241,4424585,4421919,4423241,4425913],"length":1,"stats":{"Line":3},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[4421931,4425925,4427253,4424597,4423253],"length":1,"stats":{"Line":3},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[4423296,4424640,4421974,4425968,4427296],"length":1,"stats":{"Line":3},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[4423341,4424685,4427341,4426013,4422019],"length":1,"stats":{"Line":3},"fn_name":null},{"line":230,"address":[4422380,4428048,4428225,4428097,4428481,4428304,4428560,4427681,4426353,4428353,4428176,4425025,4428432,4423681,4428609],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}<enum_external_deserialize::_IMPL_DESERIALIZE_FOR_Val::{{impl}}::deserialize::__Visitor>"},{"line":237,"address":[4429328,4429392,4428896,4428976,4428985,4429337,4429465,4428688,4428323,4429401,4428697,4428825,4429360,4428451,4429056,4429065,4428195,4428905,4429424,4429456,4428579,4429433,4428067,4428816,4429369],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}<enum_external_deserialize::_IMPL_DESERIALIZE_FOR_OuterStruct::{{impl}}::deserialize::__Visitor>"},{"line":238,"address":[4428782,4429280,4429150,4429246,4428626,4429232,4429136,4428498,4428114,4428242,4428370,4428768,4429198,4429294,4429184],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}<serde::de::impls::{{impl}}::deserialize::VecVisitor<enum_external_deserialize::TheEnum>>"},{"line":239,"address":[4428149,4428405,4428277,4428533,4428661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[4429520,4429682],"length":1,"stats":{"Line":3},"fn_name":"deserialize_enum<enum_external_deserialize::_IMPL_DESERIALIZE_FOR_TheEnum::{{impl}}::deserialize::__Visitor>"},{"line":253,"address":[4430123,4429713,4429570,4430183],"length":1,"stats":{"Line":4},"fn_name":null},{"line":254,"address":[4431596,4430508,4431094,4431414],"length":1,"stats":{"Line":3},"fn_name":null},{"line":255,"address":[4431825,4430364,4430062],"length":1,"stats":{"Line":2},"fn_name":null},{"line":256,"address":[4430513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[4430558,4430927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[4430866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[4430679],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[4430796],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[4430707,4430767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[4430776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[4430747],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[4430940,4430593],"length":1,"stats":{"Line":2},"fn_name":null},{"line":271,"address":[4430609],"length":1,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[4430932],"length":1,"stats":{"Line":1},"fn_name":null},{"line":276,"address":[4431099,4431917,4431282,4431072,4431853],"length":1,"stats":{"Line":3},"fn_name":null},{"line":277,"address":[4431115],"length":1,"stats":{"Line":1},"fn_name":null},{"line":278,"address":[4431197],"length":1,"stats":{"Line":1},"fn_name":null},{"line":280,"address":[4431566,4430235,4431483],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[4430304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[4431419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[4430332],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[4432352,4432500,4433540,4433012,4432864,4433392],"length":1,"stats":{"Line":3},"fn_name":"deserialize_struct<enum_external_deserialize::_IMPL_DESERIALIZE_FOR_OuterStruct::{{impl}}::deserialize::__Visitor>"},{"line":299,"address":[4433031,4433559,4432519,4433430,4432390,4432902],"length":1,"stats":{"Line":6},"fn_name":null},{"line":300,"address":[4432563,4433075,4433603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[4432580,4433620,4433092],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[4433652,4433122,4432612,4432677,4433187,4433717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[4433130,4433660,4432620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[4432649,4433689,4433159],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[4433167,4433697,4432657],"length":1,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[4433278,4433822,4432782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[4433047,4432535,4433575],"length":1,"stats":{"Line":3},"fn_name":null},{"line":332,"address":[4776564,4776496],"length":1,"stats":{"Line":1},"fn_name":"build_table_indices"},{"line":333,"address":[4776522],"length":1,"stats":{"Line":1},"fn_name":null},{"line":334,"address":[4776857,4776579,4776655,4777159],"length":1,"stats":{"Line":3},"fn_name":null},{"line":335,"address":[4776923],"length":1,"stats":{"Line":3},"fn_name":null},{"line":336,"address":[4777047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":338,"address":[4776820],"length":1,"stats":{"Line":1},"fn_name":null},{"line":356,"address":[4777184,4777261],"length":1,"stats":{"Line":1},"fn_name":"build_table_pindices"},{"line":357,"address":[4777210],"length":1,"stats":{"Line":1},"fn_name":null},{"line":358,"address":[4778198,4777370,4777276,4777575],"length":1,"stats":{"Line":3},"fn_name":null},{"line":359,"address":[4777641],"length":1,"stats":{"Line":3},"fn_name":null},{"line":360,"address":[4777836,4778005,4778193,4777765],"length":1,"stats":{"Line":3},"fn_name":null},{"line":361,"address":[4778039],"length":1,"stats":{"Line":1},"fn_name":null},{"line":366,"address":[4777535],"length":1,"stats":{"Line":1},"fn_name":null},{"line":369,"address":[4778256],"length":1,"stats":{"Line":0},"fn_name":"headers_equal"},{"line":370,"address":[4778315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[4778390],"length":1,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[4778372,4778422],"length":1,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[4362348,4352592,4367148,4357580,4357392,4362160,4366960,4352780],"length":1,"stats":{"Line":3},"fn_name":"next_key_seed<core::marker::PhantomData<enum_external_deserialize::_IMPL_DESERIALIZE_FOR_Multi::{{impl}}::deserialize::__Field>>"},{"line":404,"address":[4352610,4357410,4362178,4366978],"length":1,"stats":{"Line":3},"fn_name":null},{"line":405,"address":[4352797,4367165,4357597,4362365],"length":1,"stats":{"Line":1},"fn_name":null},{"line":408,"address":[4371203,4366403,4361616,4367163,4352795,4362363,4356835,4357595],"length":1,"stats":{"Line":6},"fn_name":null},{"line":409,"address":[4362444,4367244,4352876,4357678],"length":1,"stats":{"Line":3},"fn_name":null},{"line":410,"address":[4353044,4367292,4367412,4367356,4357726,4357846,4362556,4352924,4352988,4357790,4362492,4362612],"length":1,"stats":{"Line":9},"fn_name":null},{"line":411,"address":[4358568,4358666,4361253,4363341,4353275,4353172,4357974,4368239,4367540,4353773,4362740,4356464,4367643,4366032,4362843,4368141,4370832,4353871,4363439,4358077],"length":1,"stats":{"Line":10},"fn_name":null},{"line":412,"address":[4356610,4361356,4367750,4370935,4370978,4356567,4366135,4366178,4362950,4358185,4353382,4361399],"length":1,"stats":{"Line":6},"fn_name":null},{"line":413,"address":[4366224,4356656,4371024,4361437],"length":1,"stats":{"Line":3},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[4366430,4358671,4353876,4368244,4371230,4361643,4356862,4363444],"length":1,"stats":{"Line":3},"fn_name":null},{"line":419,"address":[4373296,4374001,4373840,4373857,4373984,4373905,4373313,4373888],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}<core::marker::PhantomData<enum_external_deserialize::_IMPL_DESERIALIZE_FOR_OuterStruct::{{impl}}::deserialize::__Field>>"},{"line":421,"address":[4354257,4368559,4354191,4354133,4358986,4358928,4363701,4363759,4363825,4368501,4368625,4359052],"length":1,"stats":{"Line":10},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[4371760,4363751,4372256,4354183,4358978,4372800,4373344,4368551],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}<core::marker::PhantomData<enum_external_deserialize::_IMPL_DESERIALIZE_FOR_OuterStruct::{{impl}}::deserialize::__Field>>"},{"line":424,"address":[4374896,4371788,4374249,4374905,4374225,4372828,4374257,4375377,4374240,4374913,4374217,4375369,4374208,4373372,4375360,4372284],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}<core::marker::PhantomData<serde::de::ignored_any::IgnoredAny>>"},{"line":425,"address":[4371889,4372929,4372385,4373473],"length":1,"stats":{"Line":3},"fn_name":null},{"line":426,"address":[4373085,4373629,4372045,4372541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[4373198,4372502,4372006,4372085,4372158,4372610,4373154,4372114,4373669,4373046,4373590,4372581,4373742,4373698,4373125,4372654],"length":1,"stats":{"Line":13},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[4373146,4375392,4375406,4374304,4372106,4373690,4374590,4375166,4374318,4372602,4375152,4374576],"length":1,"stats":{"Line":11},"fn_name":"{{closure}}<core::marker::PhantomData<enum_external_deserialize::_IMPL_DESERIALIZE_FOR_Val::{{impl}}::deserialize::__Field>>"},{"line":431,"address":[4372150,4374928,4374942,4375534,4374400,4374414,4373190,4375520,4372646,4374686,4374672,4373734],"length":1,"stats":{"Line":12},"fn_name":"{{closure}}<core::marker::PhantomData<enum_external_deserialize::_IMPL_DESERIALIZE_FOR_OuterStruct::{{impl}}::deserialize::__Field>>"},{"line":432,"address":[4375072,4374830,4374816,4375280,4374142,4374128,4375294,4375086],"length":1,"stats":{"Line":8},"fn_name":"{{closure}}<core::marker::PhantomData<serde::de::ignored_any::IgnoredAny>>"},{"line":433,"address":[4374272,4374544,4374566,4374558,4374294,4375262,4375502,4375510,4374286,4375488,4375270,4375248],"length":1,"stats":{"Line":8},"fn_name":"{{closure}}<core::marker::PhantomData<serde::de::ignored_any::IgnoredAny>>"},{"line":437,"address":[4359145,4368716,4354348,4363916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[4359095,4363918,4354350,4354300,4363868,4359147,4368718,4368668],"length":1,"stats":{"Line":8},"fn_name":null},{"line":439,"address":[4359216,4368685,4354317,4363885,4354419,4359112,4363987,4368787],"length":1,"stats":{"Line":7},"fn_name":null},{"line":441,"address":[4354374,4359171,4363942,4368742],"length":1,"stats":{"Line":4},"fn_name":null},{"line":445,"address":[4360408,4365167,4355599,4368757,4359186,4363957,4354389,4369967],"length":1,"stats":{"Line":4},"fn_name":null},{"line":447,"address":[4363992,4361697,4356916,4359221,4368792,4371284,4354424,4366484],"length":1,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[4366518,4371318,4354545,4361731,4368913,4356950,4359342,4364113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[4356984,4361765,4366552,4371352,4354749,4359546,4369117,4364317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[4366589,4354834,4364402,4371389,4361802,4357021,4369202,4359631],"length":1,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[4372769,4373936,4372752,4374032,4374080,4374049,4374097,4373953],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}<core::marker::PhantomData<serde::de::ignored_any::IgnoredAny>>"},{"line":457,"address":[4369706,4360147,4364748,4364906,4355338,4355180,4369548,4359989],"length":1,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[4359511,4360406,4355597,4364282,4369082,4369965,4354714,4365165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[4366666,4355343,4357098,4360152,4364911,4369711,4371466,4361879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[4369825,4357129,4371497,4360266,4355457,4361910,4366697,4365025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[4369937,4360378,4365137,4355569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[4369942,4355574,4360383,4365142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[4365169,4357163,4366731,4355601,4371531,4360410,4369969,4361944],"length":1,"stats":{"Line":4},"fn_name":null},{"line":478,"address":[4365254,4355686,4370054,4360495],"length":1,"stats":{"Line":4},"fn_name":null},{"line":479,"address":[4365340,4370140,4360581,4355772],"length":1,"stats":{"Line":1},"fn_name":null},{"line":480,"address":[4355823,4371106,4365601,4360632,4370401,4370191,4365391,4356033,4356738,4366306,4361519,4360822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":481,"address":[4356001,4365569,4360789,4370369],"length":1,"stats":{"Line":1},"fn_name":null},{"line":488,"address":[4370120,4365320,4355752,4360561],"length":1,"stats":{"Line":3},"fn_name":null},{"line":489,"address":[4360920,4365699,4370499,4356131],"length":1,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[4360931,4356142,4365710,4370510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[4361547,4365830,4356102,4356262,4361051,4366334,4370470,4370630,4371134,4356766,4365670,4360891],"length":1,"stats":{"Line":6},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[4375664,4377856,4377965,4375750,4380208,4380317],"length":1,"stats":{"Line":3},"fn_name":"next_value_seed<core::marker::PhantomData<serde::de::ignored_any::IgnoredAny>>"},{"line":506,"address":[4377984,4380336,4380392,4375825,4375682,4377877,4378040,4375769,4380229],"length":1,"stats":{"Line":9},"fn_name":null},{"line":507,"address":[4377489,4376198,4378392,4380504,4380663,4378311,4376104,4378152,4380744,4382250,4379838,4375937],"length":1,"stats":{"Line":6},"fn_name":null},{"line":508,"address":[4378319,4380671,4376200,4378394,4380746,4376120],"length":1,"stats":{"Line":6},"fn_name":null},{"line":509,"address":[4378338,4380690,4376147],"length":1,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[4376163,4380706,4378583,4378354,4376254,4380979],"length":1,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[4376308,4381033,4378637],"length":1,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[4376545,4378666,4377556,4381062,4378879,4381275,4376326,4379905,4382317],"length":1,"stats":{"Line":2},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[4378836,4377656,4376690,4381420,4381232,4382414,4380002,4376499,4379024],"length":1,"stats":{"Line":2},"fn_name":null},{"line":519,"address":[4377070,4379401,4381797,4381440,4376713,4379044],"length":1,"stats":{"Line":2},"fn_name":null},{"line":520,"address":[4376729,4379060,4381456],"length":1,"stats":{"Line":1},"fn_name":null},{"line":521,"address":[4379133,4381529,4376802],"length":1,"stats":{"Line":1},"fn_name":null},{"line":522,"address":[4379196,4380052,4382464,4381541,4379145,4381592,4376814,4376865,4377706],"length":1,"stats":{"Line":2},"fn_name":null},{"line":523,"address":[4377759,4381648,4380105,4382517,4376921,4379252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[4376980,4379326,4381722,4381707,4376995,4379311],"length":1,"stats":{"Line":2},"fn_name":null},{"line":526,"address":[4379319,4381715,4376988],"length":1,"stats":{"Line":1},"fn_name":null},{"line":527,"address":[4379333,4377002,4381729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":528,"address":[4377009,4379340,4381736],"length":1,"stats":{"Line":1},"fn_name":null},{"line":529,"address":[4377016,4381743,4379347],"length":1,"stats":{"Line":1},"fn_name":null},{"line":530,"address":[4381757,4379361,4377030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":532,"address":[4382624,4377414,4382122,4379726,4383318,4383264,4382944,4382678,4382998],"length":1,"stats":{"Line":1},"fn_name":"{{closure}}<core::marker::PhantomData<serde::de::ignored_any::IgnoredAny>>"},{"line":533,"address":[4382751,4383507,4383391,4383335,4382958,4382867,4383071,4382695,4383015,4382638,4383187,4383278],"length":1,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[4382857,4383177,4383497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[4383584,4385983,4385888,4383679],"length":1,"stats":{"Line":0},"fn_name":"next_element_seed<core::marker::PhantomData<enum_external_deserialize::TheEnum>>"},{"line":546,"address":[4383603,4383701,4386005,4385907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[4383707,4383767,4386071,4386011],"length":1,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[4386164,4383860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[4383989,4386293],"length":1,"stats":{"Line":0},"fn_name":null},{"line":553,"address":[4384095,4386359,4383927,4385674,4386231,4387821],"length":1,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[4389024,4389072,4389041,4389089],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}<core::marker::PhantomData<enum_external_deserialize::TheEnum>>"},{"line":558,"address":[4387855,4385708,4384267,4386531],"length":1,"stats":{"Line":0},"fn_name":null},{"line":559,"address":[4386588,4384473,4386681,4384324,4384417,4386743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":562,"address":[4384393,4386657,4388032,4388528],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}<core::marker::PhantomData<enum_external_deserialize::TheEnum>>"},{"line":563,"address":[4388068,4389137,4389520,4389529,4389129,4389120,4388564,4389537],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}<core::marker::PhantomData<enum_external_deserialize::TheEnum>>"},{"line":564,"address":[4388161,4388657],"length":1,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[4388310,4388806],"length":1,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[4388356,4388767,4388881,4388925,4388429,4388385,4388271,4388852],"length":1,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[4389438,4388377,4389184,4389424,4389198,4388873],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}<core::marker::PhantomData<enum_external_deserialize::TheEnum>>"},{"line":570,"address":[4389694,4388917,4389680,4388421,4389280,4389294],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}<core::marker::PhantomData<enum_external_deserialize::TheEnum>>"},{"line":571,"address":[4389584,4389597,4389632,4389645],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}<core::marker::PhantomData<serde::de::ignored_any::IgnoredAny>>"},{"line":572,"address":[4389174,4389574,4389152,4389552,4389166,4389566],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}<core::marker::PhantomData<serde::de::ignored_any::IgnoredAny>>"},{"line":574,"address":[4386728,4384458],"length":1,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[4384889,4385242,4387627,4385480,4384512,4386788,4387165,4387504,4385274],"length":1,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[4386804,4387905,4384528,4385758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":582,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":583,"address":[4384734,4387010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[4387022,4384746,4387956,4385809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":585,"address":[4387081,4384805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":588,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":589,"address":[4384820,4387096],"length":1,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[4384827,4387103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[4384834,4387110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":592,"address":[4387124,4384848],"length":1,"stats":{"Line":0},"fn_name":null},{"line":594,"address":[4387559,4385338],"length":1,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[4385358,4387579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":602,"address":[4389824,4389984],"length":1,"stats":{"Line":0},"fn_name":"deserialize_any<serde::de::impls::{{impl}}::deserialize::VecVisitor<enum_external_deserialize::TheEnum>>"},{"line":606,"address":[4389834,4389961,4389991,4390106],"length":1,"stats":{"Line":0},"fn_name":null},{"line":607,"address":[4390059,4389912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[4389858,4390005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":619,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":622,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":643,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":651,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":652,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":655,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":656,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":657,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":660,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":663,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":666,"address":[4390208,4390326],"length":1,"stats":{"Line":1},"fn_name":"deserialize_enum<enum_external_deserialize::_IMPL_DESERIALIZE_FOR_TheEnum::{{impl}}::deserialize::__Visitor>"},{"line":675,"address":[4390250,4390346],"length":1,"stats":{"Line":2},"fn_name":null},{"line":676,"address":[4390483],"length":1,"stats":{"Line":0},"fn_name":null},{"line":677,"address":[4390415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":678,"address":[4390439],"length":1,"stats":{"Line":0},"fn_name":null},{"line":681,"address":[4391363,4390376,4390567],"length":1,"stats":{"Line":2},"fn_name":null},{"line":682,"address":[4390582],"length":1,"stats":{"Line":1},"fn_name":null},{"line":683,"address":[4390685],"length":1,"stats":{"Line":1},"fn_name":null},{"line":684,"address":[4390755,4390860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":686,"address":[4390870,4391409,4390722,4391439],"length":1,"stats":{"Line":2},"fn_name":null},{"line":687,"address":[4390950,4391142],"length":1,"stats":{"Line":2},"fn_name":null},{"line":688,"address":[4390958],"length":1,"stats":{"Line":1},"fn_name":null},{"line":689,"address":[4391070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":690,"address":[4390990],"length":1,"stats":{"Line":1},"fn_name":null},{"line":691,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":692,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":710,"address":[4778496],"length":1,"stats":{"Line":1},"fn_name":"spanned"},{"line":712,"address":[4778503],"length":1,"stats":{"Line":1},"fn_name":null},{"line":713,"address":[4778528],"length":1,"stats":{"Line":1},"fn_name":null},{"line":716,"address":[4778640],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":724,"address":[4778768],"length":1,"stats":{"Line":0},"fn_name":"into_deserializer"},{"line":725,"address":[4778772],"length":1,"stats":{"Line":0},"fn_name":null},{"line":732,"address":[4392623,4392672,4392239,4391520,4391863,4392431,4391663,4391904,4392288,4391712,4392047,4392096,4392480,4392815],"length":1,"stats":{"Line":6},"fn_name":"deserialize_any<enum_external_deserialize::_IMPL_DESERIALIZE_FOR_Multi::{{impl}}::deserialize::__FieldVisitor>"},{"line":736,"address":[4392768,4392811,4392235,4392576,4392192,4391795,4392384,4391616,4392427,4391849,4392000,4391659,4392043,4392619],"length":1,"stats":{"Line":6},"fn_name":null},{"line":737,"address":[4392298,4392490,4391623,4392583,4392391,4392007,4392682,4392775,4392199,4391719,4391914,4392106,4391802,4391530],"length":1,"stats":{"Line":12},"fn_name":null},{"line":738,"address":[4392521,4391740,4392137,4392713,4391945,4391561,4392329,4391856],"length":1,"stats":{"Line":0},"fn_name":null},{"line":742,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":751,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":752,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":753,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":754,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":755,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":756,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":757,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":761,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":777,"address":[4778800],"length":1,"stats":{"Line":2},"fn_name":"new"},{"line":784,"address":[4778896],"length":1,"stats":{"Line":1},"fn_name":"with_struct_key_validation"},{"line":785,"address":[4778900],"length":1,"stats":{"Line":1},"fn_name":null},{"line":786,"address":[4778904],"length":1,"stats":{"Line":1},"fn_name":null},{"line":793,"address":[4405504,4397760,4401445,4395504,4401728,4405226,4393984,4397487,4395776,4403414,4407230,4399486,4399760,4403696],"length":1,"stats":{"Line":6},"fn_name":"deserialize_any<serde::de::impls::BoolVisitor>"},{"line":797,"address":[4399767,4401738,4405514,4393994,4403706,4397770,4395786],"length":1,"stats":{"Line":6},"fn_name":null},{"line":798,"address":[4397105,4397226,4400478,4402040,4394571,4396301,4398267,4405714,4405626,4394485,4398173,4404857,4401938,4405669,4394340,4406835,4402084,4395986,4394397,4396132,4399212,4399997,4404109,4404008,4404978,4405917,4400130,4406011,4402141,4403030,4405816,4398353,4399930,4396387,4404283,4405860,4400376,4406956,4403818,4395941,4396203,4395256,4395898,4403151,4401052,4401176,4404197,4397925,4397970,4398116,4398072,4394296,4394194,4399884,4400190,4402235,4403906,4397882,4401850,4394149,4404052,4399091,4394106,4400266,4403861,4396088,4402321,4395135,4406097,4401893],"length":1,"stats":{"Line":10},"fn_name":null},{"line":799,"address":[4395951,4394035,4397811,4401779,4405555,4399811,4403871,4405679,4399943,4401903,4394159,4403747,4395827,4397935],"length":1,"stats":{"Line":8},"fn_name":null},{"line":800,"address":[4394258,4396050,4400073,4403970,4405778,4402002,4398034],"length":1,"stats":{"Line":2},"fn_name":null},{"line":801,"address":[4396098,4402050,4404018,4405826,4398082,4394306,4400143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":802,"address":[4397862,4396142,4395878,4394350,4398126,4400203,4403798,4399864,4401830,4402094,4405606,4404062,4405870,4394086],"length":1,"stats":{"Line":2},"fn_name":null},{"line":803,"address":[4398183,4402151,4405927,4396213,4400279,4404119,4394407],"length":1,"stats":{"Line":0},"fn_name":null},{"line":804,"address":[4400389,4402245,4406021,4396311,4394495,4404207,4398277],"length":1,"stats":{"Line":0},"fn_name":null},{"line":805,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":806,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":808,"address":[4398363,4400491,4396397,4402331,4404293,4406107,4394581],"length":1,"stats":{"Line":2},"fn_name":null},{"line":809,"address":[4404317,4398387,4394605,4396421,4400515,4406131,4402355],"length":1,"stats":{"Line":2},"fn_name":null},{"line":810,"address":[4400777,4396742,4394946,4406508,4394886,4404596,4406448,4402672,4398481,4400835,4398704,4400609,4398764,4404646,4394699,4396802,4402449,4406225,4396515,4402732,4404411],"length":1,"stats":{"Line":2},"fn_name":null},{"line":811,"address":[4404511,4398624,4406548,4406697,4402592,4402772,4404687,4398953,4398804,4394973,4396662,4396843,4406368,4394802,4396996,4400880,4400697,4402921],"length":1,"stats":{"Line":8},"fn_name":null},{"line":812,"address":[4395116,4397001,4404835,4406702,4401032,4402926,4398958],"length":1,"stats":{"Line":4},"fn_name":null},{"line":814,"address":[4394113,4399894,4401857,4399176,4404942,4395905,4395220,4401140,4403115,4397190,4405633,4406920,4403825,4397889],"length":1,"stats":{"Line":2},"fn_name":null},{"line":815,"address":[4403161,4395266,4397236,4404862,4404988,4406966,4399222,4397110,4401186,4395140,4406840,4401057,4403035,4399096],"length":1,"stats":{"Line":2},"fn_name":null},{"line":816,"address":[4397126,4399112,4395156,4401073,4403051,4404878,4406856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":817,"address":[4395258,4406958,4397228,4401178,4404980,4399214,4403153],"length":1,"stats":{"Line":1},"fn_name":null},{"line":821,"address":[4401331,4407744,4395398,4407984,4403293,4407697,4408017,4405120,4407098,4407824,4407937,4407584,4397368,4407664,4407617,4407857,4407537,4399354,4407777,4407504,4407904],"length":1,"stats":{"Line":11},"fn_name":"{{closure}}<enum_external_deserialize::_IMPL_DESERIALIZE_FOR_TheEnum::{{impl}}::deserialize::{{impl}}::visit_enum::__Visitor>"},{"line":823,"address":[4408073,4407517,4407677,4408304,4408352,4408217,4408256,4408361,4408208,4407597,4408265,4407757,4408121,4408313,4408160,4408112,4407997,4408064,4408169,4407837,4407917],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}<serde::de::impls::BoolVisitor>"},{"line":824,"address":[4407949,4408029,4407709,4407629,4407869,4407549,4407789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":828,"address":[4410432,4410627],"length":1,"stats":{"Line":1},"fn_name":"deserialize_struct<enum_external_deserialize::_IMPL_DESERIALIZE_FOR_TheEnum::{{impl}}::deserialize::{{impl}}::visit_enum::__Visitor>"},{"line":837,"address":[4410474,4410646,4410672],"length":1,"stats":{"Line":2},"fn_name":null},{"line":838,"address":[4410686],"length":1,"stats":{"Line":0},"fn_name":null},{"line":839,"address":[4410729,4410800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":840,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":841,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":846,"address":[4410832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":847,"address":[4411450,4410938,4410962],"length":1,"stats":{"Line":3},"fn_name":null},{"line":848,"address":[4410850,4410924,4410948],"length":1,"stats":{"Line":3},"fn_name":null},{"line":849,"address":[4411011,4410887,4410964],"length":1,"stats":{"Line":3},"fn_name":null},{"line":851,"address":[4411003,4412176],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}<enum_external_deserialize::_IMPL_DESERIALIZE_FOR_TheEnum::{{impl}}::deserialize::{{impl}}::visit_enum::__Visitor>"},{"line":852,"address":[4412202],"length":1,"stats":{"Line":1},"fn_name":null},{"line":853,"address":[4412228,4412359],"length":1,"stats":{"Line":2},"fn_name":null},{"line":854,"address":[4412361],"length":1,"stats":{"Line":1},"fn_name":null},{"line":856,"address":[4412351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":861,"address":[4411067],"length":1,"stats":{"Line":1},"fn_name":null},{"line":862,"address":[4411362,4411445],"length":1,"stats":{"Line":2},"fn_name":null},{"line":863,"address":[4411151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":864,"address":[4411303],"length":1,"stats":{"Line":1},"fn_name":null},{"line":865,"address":[4411175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":866,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":867,"address":[4412433,4412416],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}<enum_external_deserialize::_IMPL_DESERIALIZE_FOR_TheEnum::{{impl}}::deserialize::{{impl}}::visit_enum::__Visitor>"},{"line":868,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":869,"address":[4411287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":874,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":878,"address":[4411452],"length":1,"stats":{"Line":1},"fn_name":null},{"line":879,"address":[4411665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":880,"address":[4411677],"length":1,"stats":{"Line":0},"fn_name":null},{"line":882,"address":[4411689,4411856],"length":1,"stats":{"Line":0},"fn_name":null},{"line":883,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":884,"address":[4411697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":885,"address":[4411717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":886,"address":[4411836],"length":1,"stats":{"Line":0},"fn_name":null},{"line":890,"address":[4411560],"length":1,"stats":{"Line":1},"fn_name":null},{"line":899,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":902,"address":[4408720,4408877],"length":1,"stats":{"Line":2},"fn_name":"deserialize_enum<enum_external_deserialize::_IMPL_DESERIALIZE_FOR_TheEnum::{{impl}}::deserialize::__Visitor>"},{"line":911,"address":[4409740,4409922,4409161],"length":1,"stats":{"Line":2},"fn_name":null},{"line":912,"address":[4409001,4408762,4409153,4410025],"length":1,"stats":{"Line":2},"fn_name":null},{"line":913,"address":[4409166],"length":1,"stats":{"Line":2},"fn_name":null},{"line":914,"address":[4409573,4409203],"length":1,"stats":{"Line":2},"fn_name":null},{"line":915,"address":[4409512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":916,"address":[4409329],"length":1,"stats":{"Line":0},"fn_name":null},{"line":917,"address":[4409442],"length":1,"stats":{"Line":0},"fn_name":null},{"line":918,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":919,"address":[4409353,4409413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":920,"address":[4409422],"length":1,"stats":{"Line":0},"fn_name":null},{"line":922,"address":[4409393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":927,"address":[4409238,4409586],"length":1,"stats":{"Line":4},"fn_name":null},{"line":928,"address":[4409254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":929,"address":[4409578],"length":1,"stats":{"Line":2},"fn_name":null},{"line":933,"address":[4409809,4408892,4409718,4409892,4410053,4410117],"length":1,"stats":{"Line":2},"fn_name":null},{"line":934,"address":[4408940],"length":1,"stats":{"Line":0},"fn_name":null},{"line":935,"address":[4409745],"length":1,"stats":{"Line":0},"fn_name":null},{"line":936,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":937,"address":[4408964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":943,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":951,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":964,"address":[4778928],"length":1,"stats":{"Line":0},"fn_name":"into_deserializer"},{"line":965,"address":[4778932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":972,"address":[4778960],"length":1,"stats":{"Line":0},"fn_name":"into_deserializer"},{"line":973,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":980,"address":[4778976],"length":1,"stats":{"Line":1},"fn_name":"into_deserializer"},{"line":981,"address":[4778983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":998,"address":[4434187,4436395,4434832,4435659,4434096,4436304,4434923,4435568],"length":1,"stats":{"Line":0},"fn_name":"next_key_seed<&mut toml::de::Deserializer,core::marker::PhantomData<enum_external_deserialize::_IMPL_DESERIALIZE_FOR_Multi::{{impl}}::deserialize::__Field>>"},{"line":1002,"address":[4436102,4436414,4435678,4435366,4434206,4434339,4434942,4436547,4434114,4434850,4436322,4435811,4436838,4435075,4435586,4434630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1003,"address":[4434683,4434975,4436891,4434239,4435711,4436155,4436447,4435419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1004,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1005,"address":[4434348,4435820,4434477,4435084,4435213,4435949,4434953,4436836,4435689,4436425,4436685,4434628,4434217,4436556,4435364,4436100],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1006,"address":[4435441,4435113,4435849,4436585,4436913,4434705,4434377,4436177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1007,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1008,"address":[4434359,4435222,4435990,4434486,4434626,4435095,4436567,4436694,4434518,4435362,4435254,4435958,4436834,4435831,4436726,4436098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1009,"address":[4434727,4435992,4436199,4435256,4434520,4435463,4436935,4436728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1010,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1012,"address":[4436700,4435228,4434492,4435964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1016,"address":[4437040,4437141,4437872,4437957,4438949,4440640,4438848,4439781,4440725,4439680],"length":1,"stats":{"Line":0},"fn_name":"next_value_seed<&mut toml::de::Deserializer,core::marker::PhantomData<enum_external_deserialize::TheEnum>>"},{"line":1020,"address":[4440745,4438866,4437213,4440655,4440884,4437887,4439419,4439801,4438029,4437161,4440797,4437290,4439930,4437058,4439698,4437977,4440358,4439098,4438116,4438969,4439853,4441237,4439021,4437611,4438567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1021,"address":[4439462,4441280,4438610,4439034,4440401,4437226,4440810,4438042,4439866,4437654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1022,"address":[4438005,4439232,4437189,4440773,4439829,4439940,4437300,4438126,4437424,4438264,4439991,4440066,4440894,4438997,4440950,4439108,4437347,4438177,4439155,4441040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1023,"address":[4437676,4439168,4440966,4438632,4439484,4440004,4440423,4437360,4438190,4441302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1024,"address":[4438154,4439246,4441054,4440931,4437511,4441127,4439968,4438339,4438273,4439136,4440075,4437328,4437438,4439319,4440141],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1025,"address":[4437535,4438408,4439556,4437748,4440510,4438719,4439343,4441151,4441374,4440207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1027,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1040,"address":[4393408,4393520],"length":1,"stats":{"Line":0},"fn_name":"next_key_seed<core::marker::PhantomData<serde::de::ignored_any::IgnoredAny>>"},{"line":1044,"address":[4393532,4393420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1045,"address":[4393574,4393461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1047,"address":[4393446,4393558],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1048,"address":[4393450,4393502,4393562,4393609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1051,"address":[4393890,4393632,4393726,4393824],"length":1,"stats":{"Line":0},"fn_name":"next_value_seed<core::marker::PhantomData<i64>>"},{"line":1055,"address":[4393902,4393647,4393741,4393940,4393836,4393780],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1064,"address":[4433936,4433984],"length":1,"stats":{"Line":0},"fn_name":"deserialize_any<enum_external_deserialize::_IMPL_DESERIALIZE_FOR_TheEnum::{{impl}}::deserialize::{{impl}}::visit_enum::__FieldVisitor>"},{"line":1068,"address":[4433995,4433950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1087,"address":[4416010,4415616],"length":1,"stats":{"Line":1},"fn_name":"variant_seed<core::marker::PhantomData<enum_external_deserialize::_IMPL_DESERIALIZE_FOR_TheEnum::{{impl}}::deserialize::__Field>>"},{"line":1091,"address":[4415626],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1092,"address":[4416193,4415921,4416073,4416289],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1093,"address":[4416112,4416368,4416385],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}<core::marker::PhantomData<enum_external_deserialize::_IMPL_DESERIALIZE_FOR_TheEnum::{{impl}}::deserialize::__Field>>"},{"line":1105,"address":[4413807,4412639,4413712,4412544],"length":1,"stats":{"Line":1},"fn_name":"next_key_seed<core::marker::PhantomData<serde::de::ignored_any::IgnoredAny>>"},{"line":1109,"address":[4413896,4412562,4412954,4412728,4413730,4414122],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1110,"address":[4412654,4413822,4412730,4413898],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1111,"address":[4412680,4413848],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1113,"address":[4414591,4414232,4413411,4413064],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1114,"address":[4413499,4413264,4414679,4414436],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1117,"address":[4414880,4415320,4414954,4415248],"length":1,"stats":{"Line":1},"fn_name":"next_value_seed<core::marker::PhantomData<i64>>"},{"line":1121,"address":[4415263,4415335,4414969,4414898],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1122,"address":[4415375,4415009,4415545,4415180],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1130,"address":[4416528,4416615],"length":1,"stats":{"Line":1},"fn_name":"variant_seed<core::marker::PhantomData<enum_external_deserialize::_IMPL_DESERIALIZE_FOR_TheEnum::{{impl}}::deserialize::__Field>>"},{"line":1134,"address":[4416791,4417017,4416538],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1135,"address":[4416793,4416630],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1137,"address":[4416749,4417245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1138,"address":[4416672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1139,"address":[4416684],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1147,"address":[4417127,4417331,4417454,4417575],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1148,"address":[4417680,4417370,4417697],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}<core::marker::PhantomData<enum_external_deserialize::_IMPL_DESERIALIZE_FOR_TheEnum::{{impl}}::deserialize::__Field>>"},{"line":1160,"address":[4779056,4779126],"length":1,"stats":{"Line":1},"fn_name":"unit_variant"},{"line":1161,"address":[4779297,4779474,4779331,4779643],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1162,"address":[4779270,4779063,4779304],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1163,"address":[4779337,4779446,4779245],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1164,"address":[4779437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1166,"address":[4779406,4779453],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1167,"address":[4779380],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1168,"address":[4779398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1172,"address":[4779458,4779362,4779543,4779619,4779141],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1173,"address":[4779189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1174,"address":[4779479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1176,"address":[4779213],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1182,"address":[4421168,4421290],"length":1,"stats":{"Line":1},"fn_name":"newtype_variant_seed<core::marker::PhantomData<alloc::string::String>>"},{"line":1186,"address":[4421178,4421325,4421305],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1189,"address":[4417969,4417840],"length":1,"stats":{"Line":1},"fn_name":"tuple_variant<enum_external_deserialize::_IMPL_DESERIALIZE_FOR_TheEnum::{{impl}}::deserialize::{{impl}}::visit_enum::__Visitor>"},{"line":1193,"address":[4419044,4418173,4419221,4418207],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1194,"address":[4417858,4418146,4418180],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1195,"address":[4418267,4418409,4418225,4418346,4418088,4418438,4418537],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1198,"address":[4420169,4420017,4419778,4419760],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}<enum_external_deserialize::_IMPL_DESERIALIZE_FOR_TheEnum::{{impl}}::deserialize::{{impl}}::visit_enum::__Visitor>"},{"line":1199,"address":[4419995,4420174,4420019],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1200,"address":[4420277],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1201,"address":[4420176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1202,"address":[4420226],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1204,"address":[4420201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1209,"address":[4419632,4418295],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}<enum_external_deserialize::_IMPL_DESERIALIZE_FOR_TheEnum::{{impl}}::deserialize::{{impl}}::visit_enum::__Visitor>"},{"line":1210,"address":[4420747,4420448,4419650,4420536],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}<enum_external_deserialize::_IMPL_DESERIALIZE_FOR_TheEnum::{{impl}}::deserialize::{{impl}}::visit_enum::__Visitor>"},{"line":1211,"address":[4420458,4420548],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1212,"address":[4420584],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1213,"address":[4420651],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1216,"address":[4420508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1220,"address":[4419005,4418678,4418510],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1222,"address":[4418886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1223,"address":[4418793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1224,"address":[4418878],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1225,"address":[4418882],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1227,"address":[4418977],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1230,"address":[4419020,4418736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1231,"address":[4418688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1232,"address":[4418717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1236,"address":[4419191,4419113,4417984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1237,"address":[4418032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1238,"address":[4419049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1240,"address":[4418056],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1246,"address":[4421051,4420880],"length":1,"stats":{"Line":1},"fn_name":"struct_variant<enum_external_deserialize::_IMPL_DESERIALIZE_FOR_TheEnum::{{impl}}::deserialize::{{impl}}::visit_enum::__Visitor>"},{"line":1255,"address":[4420906],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1258,"address":[4421066],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1266,"address":[4779824],"length":1,"stats":{"Line":3},"fn_name":"new"},{"line":1268,"address":[4779841],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1279,"address":[4779936],"length":1,"stats":{"Line":1},"fn_name":"end"},{"line":1280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1289,"address":[4779952],"length":1,"stats":{"Line":0},"fn_name":"set_require_newline_after_table"},{"line":1290,"address":[4779969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1299,"address":[4779984],"length":1,"stats":{"Line":0},"fn_name":"set_allow_duplicate_after_longer_table"},{"line":1300,"address":[4780001],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1303,"address":[4780133,4780016],"length":1,"stats":{"Line":1},"fn_name":"tables"},{"line":1304,"address":[4780034],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1307,"address":[4780148],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1312,"address":[4780311,4780571,4783578,4780676,4783081],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1313,"address":[4782032,4780954],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1314,"address":[4780796],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1315,"address":[4780956],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1316,"address":[4780972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1317,"address":[4781020],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1319,"address":[4781253,4781034],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1320,"address":[4781146],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1322,"address":[4783086,4781346,4783147],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1324,"address":[4781255],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1325,"address":[4781274],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1328,"address":[4782027,4783142],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1329,"address":[4781518],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1330,"address":[4781576,4781902,4783311,4781814,4781692],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1331,"address":[4781788,4781904],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1336,"address":[4780816],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1337,"address":[4783504,4782041,4780928],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1338,"address":[4782066,4783390],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1340,"address":[4783509,4782147],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1344,"address":[4782618,4782821,4783583],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1345,"address":[4782714],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1347,"address":[4782823],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1350,"address":[4784114,4784064],"length":1,"stats":{"Line":1},"fn_name":"line"},{"line":1351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1352,"address":[4784102,4784229,4784134],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1353,"address":[4784252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1354,"address":[4784443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1356,"address":[4784407,4784448],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1357,"address":[4784614],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1362,"address":[4784966,4785054,4784594,4784989,4785100,4784850,4784619,4784666],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1363,"address":[4785004,4784971,4784826],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1364,"address":[4785069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1365,"address":[4784911],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1369,"address":[4785232,4785304],"length":1,"stats":{"Line":1},"fn_name":"table_header"},{"line":1370,"address":[4785250],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1371,"address":[4785319,4785465],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1372,"address":[4785491],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1373,"address":[4785699],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1374,"address":[4785829,4786634,4785799],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1375,"address":[4785815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1377,"address":[4785805,4786849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1378,"address":[4785902,4786106,4785834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1379,"address":[4786062,4786174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1380,"address":[4786243,4786474],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1381,"address":[4786337,4786252,4786818],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1383,"address":[4786476],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1389,"address":[4786831,4786500],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1391,"address":[4786689],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1393,"address":[4786636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1398,"address":[4786976,4787036],"length":1,"stats":{"Line":1},"fn_name":"key_value"},{"line":1399,"address":[4787051,4787235,4786994,4787179],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1400,"address":[4787164,4787283,4787453],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1401,"address":[4787458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1402,"address":[4787669],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1404,"address":[4788053,4787846],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1405,"address":[4788298,4788041,4788138],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1406,"address":[4788319,4788664],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1407,"address":[4788503],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1410,"address":[4788666],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1413,"address":[4789120,4789267],"length":1,"stats":{"Line":2},"fn_name":"value"},{"line":1414,"address":[4789138],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1415,"address":[4789282,4789530,4790344,4789773,4789565,4790618,4789474,4790885,4791471,4790214,4791178,4790084,4789204],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1417,"address":[4789871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1422,"address":[4790121],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1427,"address":[4790251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1431,"address":[4790623,4791946,4790349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1432,"address":[4790695,4790890],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1433,"address":[4790956],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1434,"address":[4790988,4791095,4791183],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1435,"address":[4921334],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1436,"address":[4921399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1440,"address":[4791249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1441,"address":[4791476,4791388,4791281],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1442,"address":[4921542],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1443,"address":[4921607],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1444,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1447,"address":[4791542],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1448,"address":[4791719,4791815,4791845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1449,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1450,"address":[4791655],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1451,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1452,"address":[4791638],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1456,"address":[4791786,4791826,4791863,4789575],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1458,"address":[4792015],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1461,"address":[4792304,4793055],"length":1,"stats":{"Line":1},"fn_name":"number_or_date"},{"line":1462,"address":[4792622,4792362,4793009,4793306,4792530,4792464],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1463,"address":[4792513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1464,"address":[4792641,4792449,4792562],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1466,"address":[4792938],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1467,"address":[4921847,4921897,4921840],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1468,"address":[4921882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1469,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1470,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1472,"address":[4793070,4793159,4793014,4792900,4793302],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1473,"address":[4793235],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1474,"address":[4921696,4921753,4921703],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1475,"address":[4921738],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1476,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1480,"address":[4793228],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1488,"address":[4793344,4793460],"length":1,"stats":{"Line":3},"fn_name":"string_or_table"},{"line":1489,"address":[4795416,4795590,4793791,4793659,4793362,4793715,4793475],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1490,"address":[4793770,4793793,4793635],"length":1,"stats":{"Line":7},"fn_name":null},{"line":1491,"address":[4795467,4793825,4793906,4794021],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1492,"address":[4793997,4794136],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1493,"address":[4794399,4794498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1494,"address":[4794220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1495,"address":[4794329],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1496,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1497,"address":[4794300,4794240],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1498,"address":[4794309],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1500,"address":[4794280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1506,"address":[4794549,4794503,4794142],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1510,"address":[4794622],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1511,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1515,"address":[4794730],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1516,"address":[4794746,4794838],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1517,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1519,"address":[4921993,4921984],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1520,"address":[4922057,4922048],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1521,"address":[4794830],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1522,"address":[4795161],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1523,"address":[4794992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1524,"address":[4794885],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1525,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1526,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1528,"address":[4795066,4795129],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1531,"address":[4795382],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1532,"address":[4793752,4795434],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1536,"address":[4795918,4795744,4795801],"length":1,"stats":{"Line":2},"fn_name":"number"},{"line":1538,"address":[4922321],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1542,"address":[4795849,4798713,4795940,4796134],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1543,"address":[4795995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1544,"address":[4796340,4798711,4796146,4795953],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1545,"address":[4796201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1546,"address":[4796159,4798709,4796352,4796536],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1547,"address":[4796397],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1548,"address":[4796812,4798707,4796541,4796358],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1549,"address":[4796677],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1550,"address":[4922583],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1551,"address":[4922594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1552,"address":[4922597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1554,"address":[4796635,4796817,4798720,4796961,4798705],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1555,"address":[4797044],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1556,"address":[4797074,4797682,4797289,4797146],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1557,"address":[4797244,4797418],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1558,"address":[4797498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1559,"address":[4922455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1560,"address":[4922466],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1561,"address":[4922469],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1564,"address":[4797700,4797361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1566,"address":[4797003,4797663,4798703,4797711,4797137,4797969],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1567,"address":[4797820],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1568,"address":[4797787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1569,"address":[4797804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1570,"address":[4797812],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1572,"address":[4798195,4797746,4797981,4798701],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1573,"address":[4798058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1574,"address":[4798025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1575,"address":[4798042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1576,"address":[4798050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1578,"address":[4797987,4798204,4798699,4798418],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1579,"address":[4798281],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1580,"address":[4798248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1581,"address":[4798265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1582,"address":[4798273],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1584,"address":[4798427,4798210,4798657,4798697],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1585,"address":[4798522],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1586,"address":[4798489],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1587,"address":[4798506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1588,"address":[4798514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1591,"address":[4798433,4798659],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1595,"address":[4798784,4798818,4798937],"length":1,"stats":{"Line":0},"fn_name":"number_leading_plus"},{"line":1596,"address":[4798826],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1597,"address":[4798956,4798877,4799124,4799349,4799074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1598,"address":[4799036,4799195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1599,"address":[4799377,4799147],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1603,"address":[4799629,4799456],"length":1,"stats":{"Line":1},"fn_name":"integer"},{"line":1604,"address":[4799502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1605,"address":[4799525],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1606,"address":[4799644,4799960,4799548],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1607,"address":[4799986],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1608,"address":[4800026],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1609,"address":[4800130],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1611,"address":[4800400,4800072,4800290,4800213],"length":1,"stats":{"Line":7},"fn_name":null},{"line":1612,"address":[4800376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1615,"address":[4800512],"length":1,"stats":{"Line":1},"fn_name":"parse_integer"},{"line":1622,"address":[4800585],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1624,"address":[4800674],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1625,"address":[4800682],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1626,"address":[4800690],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1627,"address":[4800714],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1628,"address":[4800727,4801682],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1629,"address":[4800944,4801009,4802065,4802035],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1630,"address":[4801022],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1631,"address":[4801169],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1634,"address":[4801672,4801174,4801243,4801162],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1635,"address":[4801235],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1636,"address":[4801252,4801387,4801224],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1637,"address":[4801276],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1638,"address":[4801464,4801392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1640,"address":[4801379],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1641,"address":[4801262,4801479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1642,"address":[4801532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1643,"address":[4801525,4801601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1644,"address":[4801664],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1646,"address":[4801651],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1647,"address":[4801659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1649,"address":[4801674],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1651,"address":[4800985,4801687],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1652,"address":[4801787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1654,"address":[4801729,4801859],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1657,"address":[4802191,4802080],"length":1,"stats":{"Line":0},"fn_name":"float"},{"line":1658,"address":[4802530,4802133,4802206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1659,"address":[4802559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1661,"address":[4802609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1662,"address":[4802621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1663,"address":[4802681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1664,"address":[4802793],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1666,"address":[4802741,4802876],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1667,"address":[4803243],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1668,"address":[4803307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1671,"address":[4803331],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1672,"address":[4805049,4803343,4805148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1673,"address":[4803506,4804862,4806000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1674,"address":[4803631],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1675,"address":[4804035,4803820,4803892],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1676,"address":[4803990,4805995,4804302,4804164],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1677,"address":[4804107,4804531],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1680,"address":[4803549,4804790,4804646,4804544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1682,"address":[4804928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1683,"address":[4805054],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1685,"address":[4804993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1686,"address":[4805142,4803473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1687,"address":[4805150],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1690,"address":[4805247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1693,"address":[4922752,4922765],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1695,"address":[4805377,4805580],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1696,"address":[4805437],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1697,"address":[4805520,4805484],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1699,"address":[4805770,4805586],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1700,"address":[4805646],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1701,"address":[4805693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1703,"address":[4805858,4805933,4805780],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1705,"address":[4805834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1706,"address":[4805909],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1707,"address":[4923051,4922967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1708,"address":[4923039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1710,"address":[4923063,4922991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1715,"address":[4806323,4806176],"length":1,"stats":{"Line":0},"fn_name":"datetime"},{"line":1721,"address":[4806249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1724,"address":[4806346],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1725,"address":[4807366,4806368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1727,"address":[4806553],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1728,"address":[4807017,4806647,4806957,4806700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1729,"address":[4807037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1733,"address":[4807389,4810674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1735,"address":[4807653,4807868,4807725],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1736,"address":[4807994,4807823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1737,"address":[4807940,4808048,4808097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1740,"address":[4808102,4810959],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1741,"address":[4808242,4808314,4808457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1742,"address":[4808583,4808412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1743,"address":[4808615],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1745,"address":[4808661,4808710,4808529],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1748,"address":[4811001,4808715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1749,"address":[4808891,4808963,4809106],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1750,"address":[4809061,4809232],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1751,"address":[4809264],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1753,"address":[4809359,4809310,4809178],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1758,"address":[4811048,4809364],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1759,"address":[4809649,4809577,4809788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1760,"address":[4809747,4809905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1761,"address":[4809937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1763,"address":[4809854,4809980,4810029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1766,"address":[4810034,4811053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1767,"address":[4810235,4810307,4810428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1768,"address":[4810545,4810390],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1769,"address":[4810577],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1771,"address":[4810620,4810669,4810494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1776,"address":[4810684],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1777,"address":[4810711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1782,"address":[4811440,4811533],"length":1,"stats":{"Line":2},"fn_name":"inline_table"},{"line":1783,"address":[4811458],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1784,"address":[4811556],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1785,"address":[4811847,4812052,4811759],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1786,"address":[4812084],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1788,"address":[4814730,4812262],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1789,"address":[4812506,4812431,4812280],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1790,"address":[4812699,4812530,4812416],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1791,"address":[4812704],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1792,"address":[4812915],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1793,"address":[4813518,4813098,4813449],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1794,"address":[4813542,4813691,4813293],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1796,"address":[4813704],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1797,"address":[4814152,4813953,4813865],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1798,"address":[4814184],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1800,"address":[4814362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1801,"address":[4814555],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1807,"address":[4815216,4815301],"length":1,"stats":{"Line":1},"fn_name":"array"},{"line":1808,"address":[4815234],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1810,"address":[4923133,4923088],"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":1811,"address":[4923689],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1812,"address":[4923248,4923153,4923121],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1813,"address":[4923708,4923281],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1814,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1817,"address":[4923694],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1820,"address":[4816867,4815316],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1821,"address":[4815546,4815498,4815326],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1822,"address":[4815548,4815835,4815636],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1823,"address":[4815867],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1825,"address":[4816355,4816424,4816061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1826,"address":[4816256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1827,"address":[4816641,4816456],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1828,"address":[4816646,4816844],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1829,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1832,"address":[4816888],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1833,"address":[4817073],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1834,"address":[4817302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1837,"address":[4817776],"length":1,"stats":{"Line":2},"fn_name":"table_key"},{"line":1838,"address":[4817788],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1841,"address":[4817872,4817927],"length":1,"stats":{"Line":1},"fn_name":"dotted_key"},{"line":1842,"address":[4817890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1843,"address":[4817955,4818005,4818197,4818235],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1844,"address":[4818242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1845,"address":[4819302,4818403],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1846,"address":[4818714],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1847,"address":[4818888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1848,"address":[4819141],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1850,"address":[4818605],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1865,"address":[4819456,4819579],"length":1,"stats":{"Line":1},"fn_name":"add_dotted_key"},{"line":1871,"address":[4819479,4819594],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1872,"address":[4819645,4819602],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1873,"address":[4819680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1874,"address":[4819935],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1876,"address":[4820006,4819651,4820196],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1877,"address":[4820124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1878,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1879,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1880,"address":[4820198,4820171],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1881,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1883,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1884,"address":[4820218],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1886,"address":[4820377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1887,"address":[4820397],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1889,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1893,"address":[4820149,4820458],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1894,"address":[4820506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1895,"address":[4820510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1897,"address":[4820578],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1898,"address":[4820834,4821615],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1899,"address":[4821256],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1900,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1901,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1902,"address":[4820925],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1903,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1905,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1907,"address":[4820958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1909,"address":[4821258],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1912,"address":[4821696],"length":1,"stats":{"Line":1},"fn_name":"eat_whitespace"},{"line":1913,"address":[4821739,4821705],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1915,"address":[4821729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1918,"address":[4821776],"length":1,"stats":{"Line":1},"fn_name":"eat_comment"},{"line":1919,"address":[4821788],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1922,"address":[4821872],"length":1,"stats":{"Line":1},"fn_name":"eat_newline_or_eof"},{"line":1923,"address":[4821881,4821915],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1925,"address":[4821905],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1928,"address":[4821952],"length":1,"stats":{"Line":1},"fn_name":"eat"},{"line":1929,"address":[4821967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1932,"address":[4822096],"length":1,"stats":{"Line":2},"fn_name":"eat_spanned"},{"line":1933,"address":[4822167,4822200,4822111],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1934,"address":[4822123],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1935,"address":[4822187],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1938,"address":[4822240],"length":1,"stats":{"Line":1},"fn_name":"expect"},{"line":1939,"address":[4822327,4822294,4822252],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1940,"address":[4822263],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1941,"address":[4822314],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1944,"address":[4822368],"length":1,"stats":{"Line":1},"fn_name":"expect_spanned"},{"line":1945,"address":[4822383,4822439,4822472],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1946,"address":[4822395],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1947,"address":[4822459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1950,"address":[4822512],"length":1,"stats":{"Line":2},"fn_name":"next"},{"line":1951,"address":[4822524],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1954,"address":[4822608],"length":1,"stats":{"Line":3},"fn_name":"peek"},{"line":1955,"address":[4822620],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1958,"address":[4822704],"length":1,"stats":{"Line":0},"fn_name":"eof"},{"line":1959,"address":[4822713],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1962,"address":[4822784],"length":1,"stats":{"Line":0},"fn_name":"token_error"},{"line":1963,"address":[4823184,4823321,4822897,4823030,4823107,4822962,4823441,4823381,4823244,4823638,4823581],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1964,"address":[4822904,4822799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1965,"address":[4822926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1967,"address":[4822972],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1968,"address":[4823040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1969,"address":[4823062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1971,"address":[4823117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1972,"address":[4823194],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1973,"address":[4823254],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1974,"address":[4823331],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1975,"address":[4823391],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1976,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1977,"address":[4823451],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1978,"address":[4823463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1979,"address":[4823487],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1980,"address":[4823511],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1981,"address":[4823588],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1982,"address":[4822842],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1986,"address":[4823747,4823664],"length":1,"stats":{"Line":0},"fn_name":"error"},{"line":1987,"address":[4823678],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1988,"address":[4823764],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1989,"address":[4823790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1995,"address":[4823824],"length":1,"stats":{"Line":0},"fn_name":"to_linecol"},{"line":1996,"address":[4823847],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2000,"address":[4823859,4824054,4824536],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2001,"address":[4824587,4824248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2002,"address":[4824392,4824445,4824647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2004,"address":[4824677,4824375,4824470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2006,"address":[4824029,4824541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2014,"address":[4824752],"length":1,"stats":{"Line":0},"fn_name":"line_col"},{"line":2015,"address":[4824764],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2018,"address":[4824816,4824933],"length":1,"stats":{"Line":1},"fn_name":"from_kind"},{"line":2020,"address":[4825188,4824964],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2031,"address":[4825607,4825280],"length":1,"stats":{"Line":2},"fn_name":"custom"},{"line":2033,"address":[4825605,4825381],"length":1,"stats":{"Line":4},"fn_name":null},{"line":2044,"address":[4825696],"length":1,"stats":{"Line":0},"fn_name":"add_key_context"},{"line":2045,"address":[4825715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2048,"address":[4344683,4346160,4345643,4344624,4346219,4345968,4346352,4345008,4345200,4344299,4345067,4344491,4345584,4345776,4344240,4346411,4344816,4344432,4344875,4345451,4345259,4345835,4345392,4346027],"length":1,"stats":{"Line":0},"fn_name":"fix_offset<closure-0>"},{"line":2054,"address":[4345790,4345598,4344638,4346174,4346043,4346366,4345022,4346427,4345275,4344699,4344254,4345406,4344315,4344507,4345659,4345982,4344446,4345467,4345214,4345851,4345083,4346235,4344830,4344891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2055,"address":[4346433,4344897,4345281,4344513,4345473,4345665,4346241,4345089,4344705,4346049,4345857,4344321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2059,"address":[4346736,4346544,4347312,4347120,4346928],"length":1,"stats":{"Line":0},"fn_name":"fix_linecol<closure-1>"},{"line":2063,"address":[4346558,4347477,4347093,4346750,4346901,4346709,4346942,4347326,4347134,4347285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2064,"address":[4346609,4347185,4346801,4346993,4347377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2065,"address":[4346854,4346662,4347238,4347430,4347046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2066,"address":[4347086,4346894,4346702,4347470,4347278],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2072,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2073,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2078,"address":[4825776,4825854],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":2079,"address":[4828251,4829620,4827706,4830845,4829067,4828946,4825989,4827310,4827585,4829378,4830169,4830724,4829741,4828158,4825899,4828372,4830603,4828825,4829499,4831291,4826462,4826886,4829867],"length":1,"stats":{"Line":4},"fn_name":null},{"line":2080,"address":[4825799,4825994,4825908,4826024],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2081,"address":[4826124,4826278,4826051,4826396],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2082,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2083,"address":[4826064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2084,"address":[4826071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2086,"address":[4826548,4826702,4826475,4826820],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2087,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2088,"address":[4826488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2089,"address":[4826495],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2091,"address":[4826972,4827244,4826899,4827126],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2092,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2093,"address":[4826912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2094,"address":[4826919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2096,"address":[4827330,4827590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2097,"address":[4827711,4827625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2098,"address":[4827747,4827820,4827974,4828092],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2099,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2100,"address":[4827760],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2101,"address":[4827767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2103,"address":[4828256,4828170],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2104,"address":[4828291,4828377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2105,"address":[4828420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2106,"address":[4828474,4828830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2108,"address":[4828951,4828865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2109,"address":[4828986,4829072],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2110,"address":[4829115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2111,"address":[4829383,4829133],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2113,"address":[4829418,4829504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2114,"address":[4829625,4829539],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2115,"address":[4829746,4829660],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2116,"address":[4829872,4829782],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2117,"address":[4829915,4830174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2119,"address":[4830217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2120,"address":[4830232],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2121,"address":[4830608,4830250],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2122,"address":[4830643,4830729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2124,"address":[4830850,4830764],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2127,"address":[4830893],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2128,"address":[4830911],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2129,"address":[4830945,4831293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2131,"address":[4830938],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2134,"address":[4825869],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2137,"address":[4831329,4832420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2138,"address":[4831558,4831378],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2139,"address":[4831521,4831848,4831604,4832312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2140,"address":[4832064,4831914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2141,"address":[4832066,4831929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2143,"address":[4832103,4832317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2145,"address":[4832422,4831789,4832353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2148,"address":[4832898,4832458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2149,"address":[4833021,4832900,4832495],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2152,"address":[4832928],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2159,"address":[4925744,4925778,4925856,4926026,4925894,4925984],"length":1,"stats":{"Line":2},"fn_name":"custom<toml::datetime::DatetimeParseError>"},{"line":2160,"address":[4925860,4925790,4925988,4926038,4925748,4925906],"length":1,"stats":{"Line":4},"fn_name":null},{"line":2181,"address":[4833088],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":2190,"address":[4833232],"length":1,"stats":{"Line":1},"fn_name":"next"},{"line":2191,"address":[4833515,4833365,4833250],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2193,"address":[4833531,4834181,4833350],"length":1,"stats":{"Line":3},"fn_name":null},{"line":2194,"address":[4833897],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2195,"address":[4833992,4833901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2196,"address":[4834137,4833971],"length":1,"stats":{"Line":4},"fn_name":null},{"line":2198,"address":[4833852,4834186,4834255],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2199,"address":[4834240,4834474],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2200,"address":[4834396,4834479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2203,"address":[4834620,4834705],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2204,"address":[4835186,4834690,4834838],"length":1,"stats":{"Line":3},"fn_name":null},{"line":2205,"address":[4835191,4835124],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2207,"address":[4835322],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2232,"address":[4835392],"length":1,"stats":{"Line":0},"fn_name":"type_name"},{"line":2233,"address":[4835574,4835479,4835551,4835451,4835505,4835597,4835528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2234,"address":[4835401,4835465],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2235,"address":[4835491],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2236,"address":[4835514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2237,"address":[4835537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2238,"address":[4835560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2239,"address":[4835583],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2240,"address":[4835606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2241,"address":[4835437],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":444,"coverable":989},{"path":["/","usr","src","toml-rs","src","macros.rs"],"content":"pub use serde::de::{Deserialize, IntoDeserializer};\n\nuse crate::value::{Array, Table, Value};\n\n/// Construct a [`toml::Value`] from TOML syntax.\n///\n/// [`toml::Value`]: value/enum.Value.html\n///\n/// ```rust\n/// fn main() {\n///     let cargo_toml = toml::toml! {\n///         [package]\n///         name = \"toml\"\n///         version = \"0.4.5\"\n///         authors = [\"Alex Crichton <alex@alexcrichton.com>\"]\n///\n///         [badges]\n///         travis-ci = { repository = \"alexcrichton/toml-rs\" }\n///\n///         [dependencies]\n///         serde = \"1.0\"\n///\n///         [dev-dependencies]\n///         serde_derive = \"1.0\"\n///         serde_json = \"1.0\"\n///     };\n///\n///     println!(\"{:#?}\", cargo_toml);\n/// }\n/// ```\n#[macro_export]\nmacro_rules! toml {\n    ($($toml:tt)+) => {{\n        let table = $crate::value::Table::new();\n        let mut root = $crate::Value::Table(table);\n        $crate::toml_internal!(@toplevel root [] $($toml)+);\n        root\n    }};\n}\n\n// TT-muncher to parse TOML syntax into a toml::Value.\n//\n//    @toplevel -- Parse tokens outside of an inline table or inline array. In\n//                 this state, `[table headers]` and `[[array headers]]` are\n//                 allowed and `key = value` pairs are not separated by commas.\n//\n//    @topleveldatetime -- Helper to parse a Datetime from string and insert it\n//                 into a table, continuing in the @toplevel state.\n//\n//    @path -- Turn a path segment into a string. Segments that look like idents\n//                 are stringified, while quoted segments like `\"cfg(windows)\"`\n//                 are not.\n//\n//    @value -- Parse the value part of a `key = value` pair, which may be a\n//                 primitive or inline table or inline array.\n//\n//    @table -- Parse the contents of an inline table, returning them as a\n//                 toml::Value::Table.\n//\n//    @tabledatetime -- Helper to parse a Datetime from string and insert it\n//                 into a table, continuing in the @table state.\n//\n//    @array -- Parse the contents of an inline array, returning them as a\n//                 toml::Value::Array.\n//\n//    @arraydatetime -- Helper to parse a Datetime from string and push it into\n//                 an array, continuing in the @array state.\n//\n//    @trailingcomma -- Helper to append a comma to a sequence of tokens if the\n//                 sequence is non-empty and does not already end in a trailing\n//                 comma.\n//\n#[macro_export]\n#[doc(hidden)]\nmacro_rules! toml_internal {\n    // Base case, no elements remaining.\n    (@toplevel $root:ident [$($path:tt)*]) => {};\n\n    // Parse negative number `key = -value`.\n    (@toplevel $root:ident [$($path:tt)*] $($($k:tt)-+).+ = - $v:tt $($rest:tt)*) => {\n        $crate::toml_internal!(@toplevel $root [$($path)*] $($($k)-+).+ = (-$v) $($rest)*);\n    };\n\n    // Parse positive number `key = +value`.\n    (@toplevel $root:ident [$($path:tt)*] $($($k:tt)-+).+ = + $v:tt $($rest:tt)*) => {\n        $crate::toml_internal!(@toplevel $root [$($path)*] $($($k)-+).+ = ($v) $($rest)*);\n    };\n\n    // Parse offset datetime `key = 1979-05-27T00:32:00.999999-07:00`.\n    (@toplevel $root:ident [$($path:tt)*] $($($k:tt)-+).+ = $yr:tt - $mo:tt - $dhr:tt : $min:tt : $sec:tt . $frac:tt - $tzh:tt : $tzm:tt $($rest:tt)*) => {\n        $crate::toml_internal!(@topleveldatetime $root [$($path)*] $($($k)-+).+ = ($yr - $mo - $dhr : $min : $sec . $frac - $tzh : $tzm) $($rest)*);\n    };\n    // Space instead of T.\n    (@toplevel $root:ident [$($path:tt)*] $($($k:tt)-+).+ = $yr:tt - $mo:tt - $day:tt $hr:tt : $min:tt : $sec:tt . $frac:tt - $tzh:tt : $tzm:tt $($rest:tt)*) => {\n        $crate::toml_internal!(@topleveldatetime $root [$($path)*] $($($k)-+).+ = ($yr - $mo - $day T $hr : $min : $sec . $frac - $tzh : $tzm) $($rest)*);\n    };\n\n    // Parse offset datetime `key = 1979-05-27T00:32:00-07:00`.\n    (@toplevel $root:ident [$($path:tt)*] $($($k:tt)-+).+ = $yr:tt - $mo:tt - $dhr:tt : $min:tt : $sec:tt - $tzh:tt : $tzm:tt $($rest:tt)*) => {\n        $crate::toml_internal!(@topleveldatetime $root [$($path)*] $($($k)-+).+ = ($yr - $mo - $dhr : $min : $sec - $tzh : $tzm) $($rest)*);\n    };\n    // Space instead of T.\n    (@toplevel $root:ident [$($path:tt)*] $($($k:tt)-+).+ = $yr:tt - $mo:tt - $day:tt $hr:tt : $min:tt : $sec:tt - $tzh:tt : $tzm:tt $($rest:tt)*) => {\n        $crate::toml_internal!(@topleveldatetime $root [$($path)*] $($($k)-+).+ = ($yr - $mo - $day T $hr : $min : $sec - $tzh : $tzm) $($rest)*);\n    };\n\n    // Parse local datetime `key = 1979-05-27T00:32:00.999999`.\n    (@toplevel $root:ident [$($path:tt)*] $($($k:tt)-+).+ = $yr:tt - $mo:tt - $dhr:tt : $min:tt : $sec:tt . $frac:tt $($rest:tt)*) => {\n        $crate::toml_internal!(@topleveldatetime $root [$($path)*] $($($k)-+).+ = ($yr - $mo - $dhr : $min : $sec . $frac) $($rest)*);\n    };\n    // Space instead of T.\n    (@toplevel $root:ident [$($path:tt)*] $($($k:tt)-+).+ = $yr:tt - $mo:tt - $day:tt $hr:tt : $min:tt : $sec:tt . $frac:tt $($rest:tt)*) => {\n        $crate::toml_internal!(@topleveldatetime $root [$($path)*] $($($k)-+).+ = ($yr - $mo - $day T $hr : $min : $sec . $frac) $($rest)*);\n    };\n\n    // Parse offset datetime `key = 1979-05-27T07:32:00Z` and local datetime `key = 1979-05-27T07:32:00`.\n    (@toplevel $root:ident [$($path:tt)*] $($($k:tt)-+).+ = $yr:tt - $mo:tt - $dhr:tt : $min:tt : $sec:tt $($rest:tt)*) => {\n        $crate::toml_internal!(@topleveldatetime $root [$($path)*] $($($k)-+).+ = ($yr - $mo - $dhr : $min : $sec) $($rest)*);\n    };\n    // Space instead of T.\n    (@toplevel $root:ident [$($path:tt)*] $($($k:tt)-+).+ = $yr:tt - $mo:tt - $day:tt $hr:tt : $min:tt : $sec:tt $($rest:tt)*) => {\n        $crate::toml_internal!(@topleveldatetime $root [$($path)*] $($($k)-+).+ = ($yr - $mo - $day T $hr : $min : $sec) $($rest)*);\n    };\n\n    // Parse local date `key = 1979-05-27`.\n    (@toplevel $root:ident [$($path:tt)*] $($($k:tt)-+).+ = $yr:tt - $mo:tt - $day:tt $($rest:tt)*) => {\n        $crate::toml_internal!(@topleveldatetime $root [$($path)*] $($($k)-+).+ = ($yr - $mo - $day) $($rest)*);\n    };\n\n    // Parse local time `key = 00:32:00.999999`.\n    (@toplevel $root:ident [$($path:tt)*] $($($k:tt)-+).+ = $hr:tt : $min:tt : $sec:tt . $frac:tt $($rest:tt)*) => {\n        $crate::toml_internal!(@topleveldatetime $root [$($path)*] $($($k)-+).+ = ($hr : $min : $sec . $frac) $($rest)*);\n    };\n\n    // Parse local time `key = 07:32:00`.\n    (@toplevel $root:ident [$($path:tt)*] $($($k:tt)-+).+ = $hr:tt : $min:tt : $sec:tt $($rest:tt)*) => {\n        $crate::toml_internal!(@topleveldatetime $root [$($path)*] $($($k)-+).+ = ($hr : $min : $sec) $($rest)*);\n    };\n\n    // Parse any other `key = value` including string, inline array, inline\n    // table, number, and boolean.\n    (@toplevel $root:ident [$($path:tt)*] $($($k:tt)-+).+ = $v:tt $($rest:tt)*) => {{\n        $crate::macros::insert_toml(\n            &mut $root,\n            &[$($path)* $(&concat!($(\"-\", $crate::toml_internal!(@path $k),)+)[1..], )+],\n            $crate::toml_internal!(@value $v));\n        $crate::toml_internal!(@toplevel $root [$($path)*] $($rest)*);\n    }};\n\n    // Parse array header `[[bin]]`.\n    (@toplevel $root:ident $oldpath:tt [[$($($path:tt)-+).+]] $($rest:tt)*) => {\n        $crate::macros::push_toml(\n            &mut $root,\n            &[$(&concat!($(\"-\", $crate::toml_internal!(@path $path),)+)[1..],)+]);\n        $crate::toml_internal!(@toplevel $root [$(&concat!($(\"-\", $crate::toml_internal!(@path $path),)+)[1..],)+] $($rest)*);\n    };\n\n    // Parse table header `[patch.crates-io]`.\n    (@toplevel $root:ident $oldpath:tt [$($($path:tt)-+).+] $($rest:tt)*) => {\n        $crate::macros::insert_toml(\n            &mut $root,\n            &[$(&concat!($(\"-\", $crate::toml_internal!(@path $path),)+)[1..],)+],\n            $crate::Value::Table($crate::value::Table::new()));\n        $crate::toml_internal!(@toplevel $root [$(&concat!($(\"-\", $crate::toml_internal!(@path $path),)+)[1..],)+] $($rest)*);\n    };\n\n    // Parse datetime from string and insert into table.\n    (@topleveldatetime $root:ident [$($path:tt)*] $($($k:tt)-+).+ = ($($datetime:tt)+) $($rest:tt)*) => {\n        $crate::macros::insert_toml(\n            &mut $root,\n            &[$($path)* $(&concat!($(\"-\", $crate::toml_internal!(@path $k),)+)[1..], )+],\n            $crate::Value::Datetime(concat!($(stringify!($datetime)),+).parse().unwrap()));\n        $crate::toml_internal!(@toplevel $root [$($path)*] $($rest)*);\n    };\n\n    // Turn a path segment into a string.\n    (@path $ident:ident) => {\n        stringify!($ident)\n    };\n\n    // For a path segment that is not an ident, expect that it is already a\n    // quoted string, like in `[target.\"cfg(windows)\".dependencies]`.\n    (@path $quoted:tt) => {\n        $quoted\n    };\n\n    // Construct a Value from an inline table.\n    (@value { $($inline:tt)* }) => {{\n        let mut table = $crate::Value::Table($crate::value::Table::new());\n        $crate::toml_internal!(@trailingcomma (@table table) $($inline)*);\n        table\n    }};\n\n    // Construct a Value from an inline array.\n    (@value [ $($inline:tt)* ]) => {{\n        let mut array = $crate::value::Array::new();\n        $crate::toml_internal!(@trailingcomma (@array array) $($inline)*);\n        $crate::Value::Array(array)\n    }};\n\n    (@value (-nan)) => {\n        $crate::Value::Float(-::std::f64::NAN)\n    };\n\n    (@value (nan)) => {\n        $crate::Value::Float(::std::f64::NAN)\n    };\n\n    (@value nan) => {\n        $crate::Value::Float(::std::f64::NAN)\n    };\n\n    (@value (-inf)) => {\n        $crate::Value::Float(::std::f64::NEG_INFINITY)\n    };\n\n    (@value (inf)) => {\n        $crate::Value::Float(::std::f64::INFINITY)\n    };\n\n    (@value inf) => {\n        $crate::Value::Float(::std::f64::INFINITY)\n    };\n\n    // Construct a Value from any other type, probably string or boolean or number.\n    (@value $v:tt) => {{\n        // TODO: Implement this with something like serde_json::to_value instead.\n        let de = $crate::macros::IntoDeserializer::<$crate::de::Error>::into_deserializer($v);\n        <$crate::Value as $crate::macros::Deserialize>::deserialize(de).unwrap()\n    }};\n\n    // Base case of inline table.\n    (@table $root:ident) => {};\n\n    // Parse negative number `key = -value`.\n    (@table $root:ident $($($k:tt)-+).+ = - $v:tt , $($rest:tt)*) => {\n        $crate::toml_internal!(@table $root $($($k)-+).+ = (-$v) , $($rest)*);\n    };\n\n    // Parse positive number `key = +value`.\n    (@table $root:ident $($($k:tt)-+).+ = + $v:tt , $($rest:tt)*) => {\n        $crate::toml_internal!(@table $root $($($k)-+).+ = ($v) , $($rest)*);\n    };\n\n    // Parse offset datetime `key = 1979-05-27T00:32:00.999999-07:00`.\n    (@table $root:ident $($($k:tt)-+).+ = $yr:tt - $mo:tt - $dhr:tt : $min:tt : $sec:tt . $frac:tt - $tzh:tt : $tzm:tt , $($rest:tt)*) => {\n        $crate::toml_internal!(@tabledatetime $root $($($k)-+).+ = ($yr - $mo - $dhr : $min : $sec . $frac - $tzh : $tzm) $($rest)*);\n    };\n    // Space instead of T.\n    (@table $root:ident $($($k:tt)-+).+ = $yr:tt - $mo:tt - $day:tt $hr:tt : $min:tt : $sec:tt . $frac:tt - $tzh:tt : $tzm:tt , $($rest:tt)*) => {\n        $crate::toml_internal!(@tabledatetime $root $($($k)-+).+ = ($yr - $mo - $day T $hr : $min : $sec . $frac - $tzh : $tzm) $($rest)*);\n    };\n\n    // Parse offset datetime `key = 1979-05-27T00:32:00-07:00`.\n    (@table $root:ident $($($k:tt)-+).+ = $yr:tt - $mo:tt - $dhr:tt : $min:tt : $sec:tt - $tzh:tt : $tzm:tt , $($rest:tt)*) => {\n        $crate::toml_internal!(@tabledatetime $root $($($k)-+).+ = ($yr - $mo - $dhr : $min : $sec - $tzh : $tzm) $($rest)*);\n    };\n    // Space instead of T.\n    (@table $root:ident $($($k:tt)-+).+ = $yr:tt - $mo:tt - $day:tt $hr:tt : $min:tt : $sec:tt - $tzh:tt : $tzm:tt , $($rest:tt)*) => {\n        $crate::toml_internal!(@tabledatetime $root $($($k)-+).+ = ($yr - $mo - $day T $hr : $min : $sec - $tzh : $tzm) $($rest)*);\n    };\n\n    // Parse local datetime `key = 1979-05-27T00:32:00.999999`.\n    (@table $root:ident $($($k:tt)-+).+ = $yr:tt - $mo:tt - $dhr:tt : $min:tt : $sec:tt . $frac:tt , $($rest:tt)*) => {\n        $crate::toml_internal!(@tabledatetime $root $($($k)-+).+ = ($yr - $mo - $dhr : $min : $sec . $frac) $($rest)*);\n    };\n    // Space instead of T.\n    (@table $root:ident $($($k:tt)-+).+ = $yr:tt - $mo:tt - $day:tt $hr:tt : $min:tt : $sec:tt . $frac:tt , $($rest:tt)*) => {\n        $crate::toml_internal!(@tabledatetime $root $($($k)-+).+ = ($yr - $mo - $day T $hr : $min : $sec . $frac) $($rest)*);\n    };\n\n    // Parse offset datetime `key = 1979-05-27T07:32:00Z` and local datetime `key = 1979-05-27T07:32:00`.\n    (@table $root:ident $($($k:tt)-+).+ = $yr:tt - $mo:tt - $dhr:tt : $min:tt : $sec:tt , $($rest:tt)*) => {\n        $crate::toml_internal!(@tabledatetime $root $($($k)-+).+ = ($yr - $mo - $dhr : $min : $sec) $($rest)*);\n    };\n    // Space instead of T.\n    (@table $root:ident $($($k:tt)-+).+ = $yr:tt - $mo:tt - $day:tt $hr:tt : $min:tt : $sec:tt , $($rest:tt)*) => {\n        $crate::toml_internal!(@tabledatetime $root $($($k)-+).+ = ($yr - $mo - $day T $hr : $min : $sec) $($rest)*);\n    };\n\n    // Parse local date `key = 1979-05-27`.\n    (@table $root:ident $($($k:tt)-+).+ = $yr:tt - $mo:tt - $day:tt , $($rest:tt)*) => {\n        $crate::toml_internal!(@tabledatetime $root $($($k)-+).+ = ($yr - $mo - $day) $($rest)*);\n    };\n\n    // Parse local time `key = 00:32:00.999999`.\n    (@table $root:ident $($($k:tt)-+).+ = $hr:tt : $min:tt : $sec:tt . $frac:tt , $($rest:tt)*) => {\n        $crate::toml_internal!(@tabledatetime $root $($($k)-+).+ = ($hr : $min : $sec . $frac) $($rest)*);\n    };\n\n    // Parse local time `key = 07:32:00`.\n    (@table $root:ident $($($k:tt)-+).+ = $hr:tt : $min:tt : $sec:tt , $($rest:tt)*) => {\n        $crate::toml_internal!(@tabledatetime $root $($($k)-+).+ = ($hr : $min : $sec) $($rest)*);\n    };\n\n    // Parse any other type, probably string or boolean or number.\n    (@table $root:ident $($($k:tt)-+).+ = $v:tt , $($rest:tt)*) => {\n        $crate::macros::insert_toml(\n            &mut $root,\n            &[$(&concat!($(\"-\", $crate::toml_internal!(@path $k),)+)[1..], )+],\n            $crate::toml_internal!(@value $v));\n        $crate::toml_internal!(@table $root $($rest)*);\n    };\n\n    // Parse a Datetime from string and continue in @table state.\n    (@tabledatetime $root:ident $($($k:tt)-+).+ = ($($datetime:tt)*) $($rest:tt)*) => {\n        $crate::macros::insert_toml(\n            &mut $root,\n            &[$(&concat!($(\"-\", $crate::toml_internal!(@path $k),)+)[1..], )+],\n            $crate::Value::Datetime(concat!($(stringify!($datetime)),+).parse().unwrap()));\n        $crate::toml_internal!(@table $root $($rest)*);\n    };\n\n    // Base case of inline array.\n    (@array $root:ident) => {};\n\n    // Parse negative number `-value`.\n    (@array $root:ident - $v:tt , $($rest:tt)*) => {\n        $crate::toml_internal!(@array $root (-$v) , $($rest)*);\n    };\n\n    // Parse positive number `+value`.\n    (@array $root:ident + $v:tt , $($rest:tt)*) => {\n        $crate::toml_internal!(@array $root ($v) , $($rest)*);\n    };\n\n    // Parse offset datetime `1979-05-27T00:32:00.999999-07:00`.\n    (@array $root:ident $yr:tt - $mo:tt - $dhr:tt : $min:tt : $sec:tt . $frac:tt - $tzh:tt : $tzm:tt , $($rest:tt)*) => {\n        $crate::toml_internal!(@arraydatetime $root ($yr - $mo - $dhr : $min : $sec . $frac - $tzh : $tzm) $($rest)*);\n    };\n    // Space instead of T.\n    (@array $root:ident $yr:tt - $mo:tt - $day:tt $hr:tt : $min:tt : $sec:tt . $frac:tt - $tzh:tt : $tzm:tt , $($rest:tt)*) => {\n        $crate::toml_internal!(@arraydatetime $root ($yr - $mo - $day T $hr : $min : $sec . $frac - $tzh : $tzm) $($rest)*);\n    };\n\n    // Parse offset datetime `1979-05-27T00:32:00-07:00`.\n    (@array $root:ident $yr:tt - $mo:tt - $dhr:tt : $min:tt : $sec:tt - $tzh:tt : $tzm:tt , $($rest:tt)*) => {\n        $crate::toml_internal!(@arraydatetime $root ($yr - $mo - $dhr : $min : $sec - $tzh : $tzm) $($rest)*);\n    };\n    // Space instead of T.\n    (@array $root:ident $yr:tt - $mo:tt - $day:tt $hr:tt : $min:tt : $sec:tt - $tzh:tt : $tzm:tt , $($rest:tt)*) => {\n        $crate::toml_internal!(@arraydatetime $root ($yr - $mo - $day T $hr : $min : $sec - $tzh : $tzm) $($rest)*);\n    };\n\n    // Parse local datetime `1979-05-27T00:32:00.999999`.\n    (@array $root:ident $yr:tt - $mo:tt - $dhr:tt : $min:tt : $sec:tt . $frac:tt , $($rest:tt)*) => {\n        $crate::toml_internal!(@arraydatetime $root ($yr - $mo - $dhr : $min : $sec . $frac) $($rest)*);\n    };\n    // Space instead of T.\n    (@array $root:ident $yr:tt - $mo:tt - $day:tt $hr:tt : $min:tt : $sec:tt . $frac:tt , $($rest:tt)*) => {\n        $crate::toml_internal!(@arraydatetime $root ($yr - $mo - $day T $hr : $min : $sec . $frac) $($rest)*);\n    };\n\n    // Parse offset datetime `1979-05-27T07:32:00Z` and local datetime `1979-05-27T07:32:00`.\n    (@array $root:ident $yr:tt - $mo:tt - $dhr:tt : $min:tt : $sec:tt , $($rest:tt)*) => {\n        $crate::toml_internal!(@arraydatetime $root ($yr - $mo - $dhr : $min : $sec) $($rest)*);\n    };\n    // Space instead of T.\n    (@array $root:ident $yr:tt - $mo:tt - $day:tt $hr:tt : $min:tt : $sec:tt , $($rest:tt)*) => {\n        $crate::toml_internal!(@arraydatetime $root ($yr - $mo - $day T $hr : $min : $sec) $($rest)*);\n    };\n\n    // Parse local date `1979-05-27`.\n    (@array $root:ident $yr:tt - $mo:tt - $day:tt , $($rest:tt)*) => {\n        $crate::toml_internal!(@arraydatetime $root ($yr - $mo - $day) $($rest)*);\n    };\n\n    // Parse local time `00:32:00.999999`.\n    (@array $root:ident $hr:tt : $min:tt : $sec:tt . $frac:tt , $($rest:tt)*) => {\n        $crate::toml_internal!(@arraydatetime $root ($hr : $min : $sec . $frac) $($rest)*);\n    };\n\n    // Parse local time `07:32:00`.\n    (@array $root:ident $hr:tt : $min:tt : $sec:tt , $($rest:tt)*) => {\n        $crate::toml_internal!(@arraydatetime $root ($hr : $min : $sec) $($rest)*);\n    };\n\n    // Parse any other type, probably string or boolean or number.\n    (@array $root:ident $v:tt , $($rest:tt)*) => {\n        $root.push($crate::toml_internal!(@value $v));\n        $crate::toml_internal!(@array $root $($rest)*);\n    };\n\n    // Parse a Datetime from string and continue in @array state.\n    (@arraydatetime $root:ident ($($datetime:tt)*) $($rest:tt)*) => {\n        $root.push($crate::Value::Datetime(concat!($(stringify!($datetime)),+).parse().unwrap()));\n        $crate::toml_internal!(@array $root $($rest)*);\n    };\n\n    // No trailing comma required if the tokens are empty.\n    (@trailingcomma ($($args:tt)*)) => {\n        $crate::toml_internal!($($args)*);\n    };\n\n    // Tokens end with a trailing comma, do not append another one.\n    (@trailingcomma ($($args:tt)*) ,) => {\n        $crate::toml_internal!($($args)* ,);\n    };\n\n    // Tokens end with something other than comma, append a trailing comma.\n    (@trailingcomma ($($args:tt)*) $last:tt) => {\n        $crate::toml_internal!($($args)* $last ,);\n    };\n\n    // Not yet at the last token.\n    (@trailingcomma ($($args:tt)*) $first:tt $($rest:tt)+) => {\n        $crate::toml_internal!(@trailingcomma ($($args)* $first) $($rest)+);\n    };\n}\n\n// Called when parsing a `key = value` pair.\n// Inserts an entry into the table at the given path.\npub fn insert_toml(root: &mut Value, path: &[&str], value: Value) {\n    *traverse(root, path) = value;\n}\n\n// Called when parsing an `[[array header]]`.\n// Pushes an empty table onto the array at the given path.\npub fn push_toml(root: &mut Value, path: &[&str]) {\n    let target = traverse(root, path);\n    if !target.is_array() {\n        *target = Value::Array(Array::new());\n    }\n    target\n        .as_array_mut()\n        .unwrap()\n        .push(Value::Table(Table::new()));\n}\n\nfn traverse<'a>(root: &'a mut Value, path: &[&str]) -> &'a mut Value {\n    let mut cur = root;\n    for &key in path {\n        // Lexical lifetimes :D\n        let cur1 = cur;\n        let cur2;\n\n        // From the TOML spec:\n        //\n        // > Each double-bracketed sub-table will belong to the most recently\n        // > defined table element above it.\n        if cur1.is_array() {\n            cur2 = cur1.as_array_mut().unwrap().last_mut().unwrap();\n        } else {\n            cur2 = cur1;\n        };\n\n        // We are about to index into this value, so it better be a table.\n        if !cur2.is_table() {\n            *cur2 = Value::Table(Table::new());\n        }\n\n        if !cur2.as_table().unwrap().contains_key(key) {\n            // Insert an empty table for the next loop iteration to point to.\n            let empty = Value::Table(Table::new());\n            cur2.as_table_mut().unwrap().insert(key.to_owned(), empty);\n        }\n\n        // Step into the current table.\n        cur = cur2.as_table_mut().unwrap().get_mut(key).unwrap();\n    }\n    cur\n}\n","traces":[{"line":413,"address":[4222192,4222267],"length":1,"stats":{"Line":0},"fn_name":"insert_toml"},{"line":414,"address":[4222279,4222211,4222371],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[4222432,4222699],"length":1,"stats":{"Line":0},"fn_name":"push_toml"},{"line":420,"address":[4222463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[4222486,4222754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[4222677,4222714,4222507],"length":1,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[4222562,4222659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[4222597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[4222784,4222860],"length":1,"stats":{"Line":0},"fn_name":"traverse"},{"line":431,"address":[4222823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[4222970,4222883,4222831,4223759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[4223019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[4223035,4223103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[4223113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[4223095],"length":1,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[4223226,4223879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[4223255,4223764],"length":1,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[4223326],"length":1,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[4223414],"length":1,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[4223475],"length":1,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[4223649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[4222954,4222815],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":22},{"path":["/","usr","src","toml-rs","src","map.rs"],"content":"// Copyright 2017 Serde Developers\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! A map of String to toml::Value.\n//!\n//! By default the map is backed by a [`BTreeMap`]. Enable the `preserve_order`\n//! feature of toml-rs to use [`LinkedHashMap`] instead.\n//!\n//! [`BTreeMap`]: https://doc.rust-lang.org/std/collections/struct.BTreeMap.html\n//! [`LinkedHashMap`]: https://docs.rs/linked-hash-map/*/linked_hash_map/struct.LinkedHashMap.html\n\nuse crate::value::Value;\nuse serde::{de, ser};\nuse std::borrow::Borrow;\nuse std::fmt::{self, Debug};\nuse std::hash::Hash;\nuse std::iter::FromIterator;\nuse std::ops;\n\n#[cfg(not(feature = \"preserve_order\"))]\nuse std::collections::{btree_map, BTreeMap};\n\n#[cfg(feature = \"preserve_order\")]\nuse indexmap::{self, IndexMap};\n\n/// Represents a TOML key/value type.\npub struct Map<K, V> {\n    map: MapImpl<K, V>,\n}\n\n#[cfg(not(feature = \"preserve_order\"))]\ntype MapImpl<K, V> = BTreeMap<K, V>;\n#[cfg(feature = \"preserve_order\")]\ntype MapImpl<K, V> = IndexMap<K, V>;\n\nimpl Map<String, Value> {\n    /// Makes a new empty Map.\n    #[inline]\n    pub fn new() -> Self {\n        Map {\n            map: MapImpl::new(),\n        }\n    }\n\n    #[cfg(not(feature = \"preserve_order\"))]\n    /// Makes a new empty Map with the given initial capacity.\n    #[inline]\n    pub fn with_capacity(capacity: usize) -> Self {\n        // does not support with_capacity\n        let _ = capacity;\n        Map {\n            map: BTreeMap::new(),\n        }\n    }\n\n    #[cfg(feature = \"preserve_order\")]\n    /// Makes a new empty Map with the given initial capacity.\n    #[inline]\n    pub fn with_capacity(capacity: usize) -> Self {\n        Map {\n            map: IndexMap::with_capacity(capacity),\n        }\n    }\n\n    /// Clears the map, removing all values.\n    #[inline]\n    pub fn clear(&mut self) {\n        self.map.clear()\n    }\n\n    /// Returns a reference to the value corresponding to the key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but the ordering\n    /// on the borrowed form *must* match the ordering on the key type.\n    #[inline]\n    pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&Value>\n    where\n        String: Borrow<Q>,\n        Q: Ord + Eq + Hash,\n    {\n        self.map.get(key)\n    }\n\n    /// Returns true if the map contains a value for the specified key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but the ordering\n    /// on the borrowed form *must* match the ordering on the key type.\n    #[inline]\n    pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool\n    where\n        String: Borrow<Q>,\n        Q: Ord + Eq + Hash,\n    {\n        self.map.contains_key(key)\n    }\n\n    /// Returns a mutable reference to the value corresponding to the key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but the ordering\n    /// on the borrowed form *must* match the ordering on the key type.\n    #[inline]\n    pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut Value>\n    where\n        String: Borrow<Q>,\n        Q: Ord + Eq + Hash,\n    {\n        self.map.get_mut(key)\n    }\n\n    /// Inserts a key-value pair into the map.\n    ///\n    /// If the map did not have this key present, `None` is returned.\n    ///\n    /// If the map did have this key present, the value is updated, and the old\n    /// value is returned. The key is not updated, though; this matters for\n    /// types that can be `==` without being identical.\n    #[inline]\n    pub fn insert(&mut self, k: String, v: Value) -> Option<Value> {\n        self.map.insert(k, v)\n    }\n\n    /// Removes a key from the map, returning the value at the key if the key\n    /// was previously in the map.\n    ///\n    /// The key may be any borrowed form of the map's key type, but the ordering\n    /// on the borrowed form *must* match the ordering on the key type.\n    #[inline]\n    pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<Value>\n    where\n        String: Borrow<Q>,\n        Q: Ord + Eq + Hash,\n    {\n        self.map.remove(key)\n    }\n\n    /// Gets the given key's corresponding entry in the map for in-place\n    /// manipulation.\n    pub fn entry<S>(&mut self, key: S) -> Entry<'_>\n    where\n        S: Into<String>,\n    {\n        #[cfg(feature = \"preserve_order\")]\n        use indexmap::map::Entry as EntryImpl;\n        #[cfg(not(feature = \"preserve_order\"))]\n        use std::collections::btree_map::Entry as EntryImpl;\n\n        match self.map.entry(key.into()) {\n            EntryImpl::Vacant(vacant) => Entry::Vacant(VacantEntry { vacant }),\n            EntryImpl::Occupied(occupied) => Entry::Occupied(OccupiedEntry { occupied }),\n        }\n    }\n\n    /// Returns the number of elements in the map.\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.map.len()\n    }\n\n    /// Returns true if the map contains no elements.\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.map.is_empty()\n    }\n\n    /// Gets an iterator over the entries of the map.\n    #[inline]\n    pub fn iter(&self) -> Iter<'_> {\n        Iter {\n            iter: self.map.iter(),\n        }\n    }\n\n    /// Gets a mutable iterator over the entries of the map.\n    #[inline]\n    pub fn iter_mut(&mut self) -> IterMut<'_> {\n        IterMut {\n            iter: self.map.iter_mut(),\n        }\n    }\n\n    /// Gets an iterator over the keys of the map.\n    #[inline]\n    pub fn keys(&self) -> Keys<'_> {\n        Keys {\n            iter: self.map.keys(),\n        }\n    }\n\n    /// Gets an iterator over the values of the map.\n    #[inline]\n    pub fn values(&self) -> Values<'_> {\n        Values {\n            iter: self.map.values(),\n        }\n    }\n}\n\nimpl Default for Map<String, Value> {\n    #[inline]\n    fn default() -> Self {\n        Map {\n            map: MapImpl::new(),\n        }\n    }\n}\n\nimpl Clone for Map<String, Value> {\n    #[inline]\n    fn clone(&self) -> Self {\n        Map {\n            map: self.map.clone(),\n        }\n    }\n}\n\nimpl PartialEq for Map<String, Value> {\n    #[inline]\n    fn eq(&self, other: &Self) -> bool {\n        self.map.eq(&other.map)\n    }\n}\n\n/// Access an element of this map. Panics if the given key is not present in the\n/// map.\nimpl<'a, Q: ?Sized> ops::Index<&'a Q> for Map<String, Value>\nwhere\n    String: Borrow<Q>,\n    Q: Ord + Eq + Hash,\n{\n    type Output = Value;\n\n    fn index(&self, index: &Q) -> &Value {\n        self.map.index(index)\n    }\n}\n\n/// Mutably access an element of this map. Panics if the given key is not\n/// present in the map.\nimpl<'a, Q: ?Sized> ops::IndexMut<&'a Q> for Map<String, Value>\nwhere\n    String: Borrow<Q>,\n    Q: Ord + Eq + Hash,\n{\n    fn index_mut(&mut self, index: &Q) -> &mut Value {\n        self.map.get_mut(index).expect(\"no entry found for key\")\n    }\n}\n\nimpl Debug for Map<String, Value> {\n    #[inline]\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        self.map.fmt(formatter)\n    }\n}\n\nimpl ser::Serialize for Map<String, Value> {\n    #[inline]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: ser::Serializer,\n    {\n        use serde::ser::SerializeMap;\n        let mut map = serializer.serialize_map(Some(self.len()))?;\n        for (k, v) in self {\n            map.serialize_key(k)?;\n            map.serialize_value(v)?;\n        }\n        map.end()\n    }\n}\n\nimpl<'de> de::Deserialize<'de> for Map<String, Value> {\n    #[inline]\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: de::Deserializer<'de>,\n    {\n        struct Visitor;\n\n        impl<'de> de::Visitor<'de> for Visitor {\n            type Value = Map<String, Value>;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n                formatter.write_str(\"a map\")\n            }\n\n            #[inline]\n            fn visit_unit<E>(self) -> Result<Self::Value, E>\n            where\n                E: de::Error,\n            {\n                Ok(Map::new())\n            }\n\n            #[inline]\n            fn visit_map<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>\n            where\n                V: de::MapAccess<'de>,\n            {\n                let mut values = Map::new();\n\n                while let Some((key, value)) = visitor.next_entry()? {\n                    values.insert(key, value);\n                }\n\n                Ok(values)\n            }\n        }\n\n        deserializer.deserialize_map(Visitor)\n    }\n}\n\nimpl FromIterator<(String, Value)> for Map<String, Value> {\n    fn from_iter<T>(iter: T) -> Self\n    where\n        T: IntoIterator<Item = (String, Value)>,\n    {\n        Map {\n            map: FromIterator::from_iter(iter),\n        }\n    }\n}\n\nimpl Extend<(String, Value)> for Map<String, Value> {\n    fn extend<T>(&mut self, iter: T)\n    where\n        T: IntoIterator<Item = (String, Value)>,\n    {\n        self.map.extend(iter);\n    }\n}\n\nmacro_rules! delegate_iterator {\n    (($name:ident $($generics:tt)*) => $item:ty) => {\n        impl $($generics)* Iterator for $name $($generics)* {\n            type Item = $item;\n            #[inline]\n            fn next(&mut self) -> Option<Self::Item> {\n                self.iter.next()\n            }\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.iter.size_hint()\n            }\n        }\n\n        impl $($generics)* DoubleEndedIterator for $name $($generics)* {\n            #[inline]\n            fn next_back(&mut self) -> Option<Self::Item> {\n                self.iter.next_back()\n            }\n        }\n\n        impl $($generics)* ExactSizeIterator for $name $($generics)* {\n            #[inline]\n            fn len(&self) -> usize {\n                self.iter.len()\n            }\n        }\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\n/// A view into a single entry in a map, which may either be vacant or occupied.\n/// This enum is constructed from the [`entry`] method on [`Map`].\n///\n/// [`entry`]: struct.Map.html#method.entry\n/// [`Map`]: struct.Map.html\npub enum Entry<'a> {\n    /// A vacant Entry.\n    Vacant(VacantEntry<'a>),\n    /// An occupied Entry.\n    Occupied(OccupiedEntry<'a>),\n}\n\n/// A vacant Entry. It is part of the [`Entry`] enum.\n///\n/// [`Entry`]: enum.Entry.html\npub struct VacantEntry<'a> {\n    vacant: VacantEntryImpl<'a>,\n}\n\n/// An occupied Entry. It is part of the [`Entry`] enum.\n///\n/// [`Entry`]: enum.Entry.html\npub struct OccupiedEntry<'a> {\n    occupied: OccupiedEntryImpl<'a>,\n}\n\n#[cfg(not(feature = \"preserve_order\"))]\ntype VacantEntryImpl<'a> = btree_map::VacantEntry<'a, String, Value>;\n#[cfg(feature = \"preserve_order\")]\ntype VacantEntryImpl<'a> = indexmap::map::VacantEntry<'a, String, Value>;\n\n#[cfg(not(feature = \"preserve_order\"))]\ntype OccupiedEntryImpl<'a> = btree_map::OccupiedEntry<'a, String, Value>;\n#[cfg(feature = \"preserve_order\")]\ntype OccupiedEntryImpl<'a> = indexmap::map::OccupiedEntry<'a, String, Value>;\n\nimpl<'a> Entry<'a> {\n    /// Returns a reference to this entry's key.\n    pub fn key(&self) -> &String {\n        match *self {\n            Entry::Vacant(ref e) => e.key(),\n            Entry::Occupied(ref e) => e.key(),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the default if empty, and\n    /// returns a mutable reference to the value in the entry.\n    pub fn or_insert(self, default: Value) -> &'a mut Value {\n        match self {\n            Entry::Vacant(entry) => entry.insert(default),\n            Entry::Occupied(entry) => entry.into_mut(),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the result of the default\n    /// function if empty, and returns a mutable reference to the value in the\n    /// entry.\n    pub fn or_insert_with<F>(self, default: F) -> &'a mut Value\n    where\n        F: FnOnce() -> Value,\n    {\n        match self {\n            Entry::Vacant(entry) => entry.insert(default()),\n            Entry::Occupied(entry) => entry.into_mut(),\n        }\n    }\n}\n\nimpl<'a> VacantEntry<'a> {\n    /// Gets a reference to the key that would be used when inserting a value\n    /// through the VacantEntry.\n    #[inline]\n    pub fn key(&self) -> &String {\n        self.vacant.key()\n    }\n\n    /// Sets the value of the entry with the VacantEntry's key, and returns a\n    /// mutable reference to it.\n    #[inline]\n    pub fn insert(self, value: Value) -> &'a mut Value {\n        self.vacant.insert(value)\n    }\n}\n\nimpl<'a> OccupiedEntry<'a> {\n    /// Gets a reference to the key in the entry.\n    #[inline]\n    pub fn key(&self) -> &String {\n        self.occupied.key()\n    }\n\n    /// Gets a reference to the value in the entry.\n    #[inline]\n    pub fn get(&self) -> &Value {\n        self.occupied.get()\n    }\n\n    /// Gets a mutable reference to the value in the entry.\n    #[inline]\n    pub fn get_mut(&mut self) -> &mut Value {\n        self.occupied.get_mut()\n    }\n\n    /// Converts the entry into a mutable reference to its value.\n    #[inline]\n    pub fn into_mut(self) -> &'a mut Value {\n        self.occupied.into_mut()\n    }\n\n    /// Sets the value of the entry with the `OccupiedEntry`'s key, and returns\n    /// the entry's old value.\n    #[inline]\n    pub fn insert(&mut self, value: Value) -> Value {\n        self.occupied.insert(value)\n    }\n\n    /// Takes the value of the entry out of the map, and returns it.\n    #[inline]\n    pub fn remove(self) -> Value {\n        self.occupied.remove()\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\nimpl<'a> IntoIterator for &'a Map<String, Value> {\n    type Item = (&'a String, &'a Value);\n    type IntoIter = Iter<'a>;\n    #[inline]\n    fn into_iter(self) -> Self::IntoIter {\n        Iter {\n            iter: self.map.iter(),\n        }\n    }\n}\n\n/// An iterator over a toml::Map's entries.\npub struct Iter<'a> {\n    iter: IterImpl<'a>,\n}\n\n#[cfg(not(feature = \"preserve_order\"))]\ntype IterImpl<'a> = btree_map::Iter<'a, String, Value>;\n#[cfg(feature = \"preserve_order\")]\ntype IterImpl<'a> = indexmap::map::Iter<'a, String, Value>;\n\ndelegate_iterator!((Iter<'a>) => (&'a String, &'a Value));\n\n//////////////////////////////////////////////////////////////////////////////\n\nimpl<'a> IntoIterator for &'a mut Map<String, Value> {\n    type Item = (&'a String, &'a mut Value);\n    type IntoIter = IterMut<'a>;\n    #[inline]\n    fn into_iter(self) -> Self::IntoIter {\n        IterMut {\n            iter: self.map.iter_mut(),\n        }\n    }\n}\n\n/// A mutable iterator over a toml::Map's entries.\npub struct IterMut<'a> {\n    iter: IterMutImpl<'a>,\n}\n\n#[cfg(not(feature = \"preserve_order\"))]\ntype IterMutImpl<'a> = btree_map::IterMut<'a, String, Value>;\n#[cfg(feature = \"preserve_order\")]\ntype IterMutImpl<'a> = indexmap::map::IterMut<'a, String, Value>;\n\ndelegate_iterator!((IterMut<'a>) => (&'a String, &'a mut Value));\n\n//////////////////////////////////////////////////////////////////////////////\n\nimpl IntoIterator for Map<String, Value> {\n    type Item = (String, Value);\n    type IntoIter = IntoIter;\n    #[inline]\n    fn into_iter(self) -> Self::IntoIter {\n        IntoIter {\n            iter: self.map.into_iter(),\n        }\n    }\n}\n\n/// An owning iterator over a toml::Map's entries.\npub struct IntoIter {\n    iter: IntoIterImpl,\n}\n\n#[cfg(not(feature = \"preserve_order\"))]\ntype IntoIterImpl = btree_map::IntoIter<String, Value>;\n#[cfg(feature = \"preserve_order\")]\ntype IntoIterImpl = indexmap::map::IntoIter<String, Value>;\n\ndelegate_iterator!((IntoIter) => (String, Value));\n\n//////////////////////////////////////////////////////////////////////////////\n\n/// An iterator over a toml::Map's keys.\npub struct Keys<'a> {\n    iter: KeysImpl<'a>,\n}\n\n#[cfg(not(feature = \"preserve_order\"))]\ntype KeysImpl<'a> = btree_map::Keys<'a, String, Value>;\n#[cfg(feature = \"preserve_order\")]\ntype KeysImpl<'a> = indexmap::map::Keys<'a, String, Value>;\n\ndelegate_iterator!((Keys<'a>) => &'a String);\n\n//////////////////////////////////////////////////////////////////////////////\n\n/// An iterator over a toml::Map's values.\npub struct Values<'a> {\n    iter: ValuesImpl<'a>,\n}\n\n#[cfg(not(feature = \"preserve_order\"))]\ntype ValuesImpl<'a> = btree_map::Values<'a, String, Value>;\n#[cfg(feature = \"preserve_order\")]\ntype ValuesImpl<'a> = indexmap::map::Values<'a, String, Value>;\n\ndelegate_iterator!((Values<'a>) => &'a Value);\n","traces":[{"line":44,"address":[5037312],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":46,"address":[5037319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[5037392],"length":1,"stats":{"Line":0},"fn_name":"with_capacity"},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[5037404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[5037472],"length":1,"stats":{"Line":0},"fn_name":"clear"},{"line":73,"address":[5037477],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[5255136],"length":1,"stats":{"Line":0},"fn_name":"get<str>"},{"line":86,"address":[5255155],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[5255184,5255232],"length":1,"stats":{"Line":0},"fn_name":"contains_key<alloc::string::String>"},{"line":99,"address":[5255251,5255198],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[5255280],"length":1,"stats":{"Line":0},"fn_name":"get_mut<str>"},{"line":112,"address":[5255299],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[5037488],"length":1,"stats":{"Line":0},"fn_name":"insert"},{"line":124,"address":[5037500],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[5037600],"length":1,"stats":{"Line":0},"fn_name":"len"},{"line":161,"address":[5037609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[5037632],"length":1,"stats":{"Line":0},"fn_name":"is_empty"},{"line":167,"address":[5037641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[5037680],"length":1,"stats":{"Line":0},"fn_name":"iter"},{"line":174,"address":[5037692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[5037760],"length":1,"stats":{"Line":0},"fn_name":"iter_mut"},{"line":182,"address":[5037772],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[5037840],"length":1,"stats":{"Line":0},"fn_name":"keys"},{"line":190,"address":[5037852],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[5037920],"length":1,"stats":{"Line":0},"fn_name":"values"},{"line":198,"address":[5037932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[5038000],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":207,"address":[5038007],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[5038080],"length":1,"stats":{"Line":0},"fn_name":"clone"},{"line":216,"address":[5038092],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[5038160],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":224,"address":[5038174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[5038208],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":257,"address":[5038222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[5038256],"length":1,"stats":{"Line":0},"fn_name":"expecting"},{"line":289,"address":[5038277],"length":1,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[5040224,5039696,5040048,5040368,5039872],"length":1,"stats":{"Line":0},"fn_name":"next"},{"line":345,"address":[5040233,5040377,5039705,5040065,5039881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[5040096,5039920,5040400,5039744,5040256],"length":1,"stats":{"Line":0},"fn_name":"size_hint"},{"line":349,"address":[5040417,5040113,5039761,5039937,5040273],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[5040448,5039792,5039968,5040144,5040304],"length":1,"stats":{"Line":0},"fn_name":"next_back"},{"line":356,"address":[5039801,5040161,5040313,5040457,5039977],"length":1,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[5040336,5040192,5040016,5039840,5040480],"length":1,"stats":{"Line":0},"fn_name":"len"},{"line":363,"address":[5039849,5040345,5040025,5040489,5040201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[5038320],"length":1,"stats":{"Line":0},"fn_name":"key"},{"line":410,"address":[5038414,5038426,5038375],"length":1,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[5038329,5038382],"length":1,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[5038349,5038421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[5038448,5038768],"length":1,"stats":{"Line":0},"fn_name":"or_insert"},{"line":419,"address":[5038766,5038455,5038793,5038603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[5038471,5038610],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[5038496,5038788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[5038928],"length":1,"stats":{"Line":0},"fn_name":"key"},{"line":444,"address":[5038937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[5038960],"length":1,"stats":{"Line":0},"fn_name":"insert"},{"line":451,"address":[5038967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[5039088],"length":1,"stats":{"Line":0},"fn_name":"key"},{"line":459,"address":[5039097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[5039120],"length":1,"stats":{"Line":0},"fn_name":"get"},{"line":465,"address":[5039129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[5039152],"length":1,"stats":{"Line":0},"fn_name":"get_mut"},{"line":471,"address":[5039161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[5039184],"length":1,"stats":{"Line":0},"fn_name":"into_mut"},{"line":477,"address":[5039188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[5039264],"length":1,"stats":{"Line":0},"fn_name":"insert"},{"line":484,"address":[5039276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[5039344],"length":1,"stats":{"Line":0},"fn_name":"remove"},{"line":490,"address":[5039351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[5039424],"length":1,"stats":{"Line":0},"fn_name":"into_iter"},{"line":502,"address":[5039436],"length":1,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[5039504],"length":1,"stats":{"Line":0},"fn_name":"into_iter"},{"line":527,"address":[5039516],"length":1,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[5039584],"length":1,"stats":{"Line":0},"fn_name":"into_iter"},{"line":552,"address":[5039591],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":105},{"path":["/","usr","src","toml-rs","src","ser.rs"],"content":"//! Serializing Rust structures into TOML.\n//!\n//! This module contains all the Serde support for serializing Rust structures\n//! into TOML documents (as strings). Note that some top-level functions here\n//! are also provided at the top of the crate.\n//!\n//! Note that the TOML format has a restriction that if a table itself contains\n//! tables, all keys with non-table values must be emitted first. This is\n//! typically easy to ensure happens when you're defining a `struct` as you can\n//! reorder the fields manually, but when working with maps (such as `BTreeMap`\n//! or `HashMap`) this can lead to serialization errors. In those situations you\n//! may use the `tables_last` function in this module like so:\n//!\n//! ```rust\n//! # use serde_derive::Serialize;\n//! # use std::collections::HashMap;\n//! #[derive(Serialize)]\n//! struct Manifest {\n//!     package: Package,\n//!     #[serde(serialize_with = \"toml::ser::tables_last\")]\n//!     dependencies: HashMap<String, Dependency>,\n//! }\n//! # type Package = String;\n//! # type Dependency = String;\n//! # fn main() {}\n//! ```\n\nuse std::cell::Cell;\nuse std::error;\nuse std::fmt::{self, Write};\nuse std::marker;\nuse std::rc::Rc;\n\nuse crate::datetime;\nuse serde::ser;\n\n/// Serialize the given data structure as a TOML byte vector.\n///\n/// Serialization can fail if `T`'s implementation of `Serialize` decides to\n/// fail, if `T` contains a map with non-string keys, or if `T` attempts to\n/// serialize an unsupported datatype such as an enum, tuple, or tuple struct.\npub fn to_vec<T: ?Sized>(value: &T) -> Result<Vec<u8>, Error>\nwhere\n    T: ser::Serialize,\n{\n    to_string(value).map(|e| e.into_bytes())\n}\n\n/// Serialize the given data structure as a String of TOML.\n///\n/// Serialization can fail if `T`'s implementation of `Serialize` decides to\n/// fail, if `T` contains a map with non-string keys, or if `T` attempts to\n/// serialize an unsupported datatype such as an enum, tuple, or tuple struct.\n///\n/// # Examples\n///\n/// ```\n/// use serde_derive::Serialize;\n///\n/// #[derive(Serialize)]\n/// struct Config {\n///     database: Database,\n/// }\n///\n/// #[derive(Serialize)]\n/// struct Database {\n///     ip: String,\n///     port: Vec<u16>,\n///     connection_max: u32,\n///     enabled: bool,\n/// }\n///\n/// fn main() {\n///     let config = Config {\n///         database: Database {\n///             ip: \"192.168.1.1\".to_string(),\n///             port: vec![8001, 8002, 8003],\n///             connection_max: 5000,\n///             enabled: false,\n///         },\n///     };\n///\n///     let toml = toml::to_string(&config).unwrap();\n///     println!(\"{}\", toml)\n/// }\n/// ```\npub fn to_string<T: ?Sized>(value: &T) -> Result<String, Error>\nwhere\n    T: ser::Serialize,\n{\n    let mut dst = String::with_capacity(128);\n    value.serialize(&mut Serializer::new(&mut dst))?;\n    Ok(dst)\n}\n\n/// Serialize the given data structure as a \"pretty\" String of TOML.\n///\n/// This is identical to `to_string` except the output string has a more\n/// \"pretty\" output. See `Serializer::pretty` for more details.\npub fn to_string_pretty<T: ?Sized>(value: &T) -> Result<String, Error>\nwhere\n    T: ser::Serialize,\n{\n    let mut dst = String::with_capacity(128);\n    value.serialize(&mut Serializer::pretty(&mut dst))?;\n    Ok(dst)\n}\n\n/// Errors that can occur when serializing a type.\n#[derive(Debug, PartialEq, Eq, Clone)]\npub enum Error {\n    /// Indicates that a Rust type was requested to be serialized but it was not\n    /// supported.\n    ///\n    /// Currently the TOML format does not support serializing types such as\n    /// enums, tuples and tuple structs.\n    UnsupportedType,\n\n    /// The key of all TOML maps must be strings, but serialization was\n    /// attempted where the key of a map was not a string.\n    KeyNotString,\n\n    /// An error that we never omit but keep for backwards compatibility\n    #[doc(hidden)]\n    KeyNewline,\n\n    /// An array had to be homogenous, but now it is allowed to be heterogenous.\n    #[doc(hidden)]\n    ArrayMixedType,\n\n    /// All values in a TOML table must be emitted before further tables are\n    /// emitted. If a value is emitted *after* a table then this error is\n    /// generated.\n    ValueAfterTable,\n\n    /// A serialized date was invalid.\n    DateInvalid,\n\n    /// A serialized number was invalid.\n    NumberInvalid,\n\n    /// None was attempted to be serialized, but it's not supported.\n    UnsupportedNone,\n\n    /// A custom error which could be generated when serializing a particular\n    /// type.\n    Custom(String),\n\n    #[doc(hidden)]\n    __Nonexhaustive,\n}\n\n#[derive(Debug, Default, Clone)]\n/// Internal place for holding array setings\nstruct ArraySettings {\n    indent: usize,\n    trailing_comma: bool,\n}\n\nimpl ArraySettings {\n    fn pretty() -> ArraySettings {\n        ArraySettings {\n            indent: 4,\n            trailing_comma: true,\n        }\n    }\n}\n\n#[derive(Debug, Default, Clone)]\n/// String settings\nstruct StringSettings {\n    /// Whether to use literal strings when possible\n    literal: bool,\n}\n\nimpl StringSettings {\n    fn pretty() -> StringSettings {\n        StringSettings { literal: true }\n    }\n}\n\n#[derive(Debug, Default, Clone)]\n/// Internal struct for holding serialization settings\nstruct Settings {\n    array: Option<ArraySettings>,\n    string: Option<StringSettings>,\n}\n\n/// Serialization implementation for TOML.\n///\n/// This structure implements serialization support for TOML to serialize an\n/// arbitrary type to TOML. Note that the TOML format does not support all\n/// datatypes in Rust, such as enums, tuples, and tuple structs. These types\n/// will generate an error when serialized.\n///\n/// Currently a serializer always writes its output to an in-memory `String`,\n/// which is passed in when creating the serializer itself.\npub struct Serializer<'a> {\n    dst: &'a mut String,\n    state: State<'a>,\n    settings: Rc<Settings>,\n}\n\n#[derive(Debug, Copy, Clone)]\nenum ArrayState {\n    Started,\n    StartedAsATable,\n}\n\n#[derive(Debug, Clone)]\nenum State<'a> {\n    Table {\n        key: &'a str,\n        parent: &'a State<'a>,\n        first: &'a Cell<bool>,\n        table_emitted: &'a Cell<bool>,\n    },\n    Array {\n        parent: &'a State<'a>,\n        first: &'a Cell<bool>,\n        type_: &'a Cell<Option<ArrayState>>,\n        len: Option<usize>,\n    },\n    End,\n}\n\n#[doc(hidden)]\npub struct SerializeSeq<'a, 'b> {\n    ser: &'b mut Serializer<'a>,\n    first: Cell<bool>,\n    type_: Cell<Option<ArrayState>>,\n    len: Option<usize>,\n}\n\n#[doc(hidden)]\npub enum SerializeTable<'a, 'b> {\n    Datetime(&'b mut Serializer<'a>),\n    Table {\n        ser: &'b mut Serializer<'a>,\n        key: String,\n        first: Cell<bool>,\n        table_emitted: Cell<bool>,\n    },\n}\n\nimpl<'a> Serializer<'a> {\n    /// Creates a new serializer which will emit TOML into the buffer provided.\n    ///\n    /// The serializer can then be used to serialize a type after which the data\n    /// will be present in `dst`.\n    pub fn new(dst: &'a mut String) -> Serializer<'a> {\n        Serializer {\n            dst,\n            state: State::End,\n            settings: Rc::new(Settings::default()),\n        }\n    }\n\n    /// Instantiate a \"pretty\" formatter\n    ///\n    /// By default this will use:\n    ///\n    /// - pretty strings: strings with newlines will use the `'''` syntax. See\n    ///   `Serializer::pretty_string`\n    /// - pretty arrays: each item in arrays will be on a newline, have an indentation of 4 and\n    ///   have a trailing comma. See `Serializer::pretty_array`\n    pub fn pretty(dst: &'a mut String) -> Serializer<'a> {\n        Serializer {\n            dst,\n            state: State::End,\n            settings: Rc::new(Settings {\n                array: Some(ArraySettings::pretty()),\n                string: Some(StringSettings::pretty()),\n            }),\n        }\n    }\n\n    /// Enable or Disable pretty strings\n    ///\n    /// If enabled, literal strings will be used when possible and strings with\n    /// one or more newlines will use triple quotes (i.e.: `'''` or `\"\"\"`)\n    ///\n    /// # Examples\n    ///\n    /// Instead of:\n    ///\n    /// ```toml,ignore\n    /// single = \"no newlines\"\n    /// text = \"\\nfoo\\nbar\\n\"\n    /// ```\n    ///\n    /// You will have:\n    ///\n    /// ```toml,ignore\n    /// single = 'no newlines'\n    /// text = '''\n    /// foo\n    /// bar\n    /// '''\n    /// ```\n    pub fn pretty_string(&mut self, value: bool) -> &mut Self {\n        Rc::get_mut(&mut self.settings).unwrap().string = if value {\n            Some(StringSettings::pretty())\n        } else {\n            None\n        };\n        self\n    }\n\n    /// Enable or Disable Literal strings for pretty strings\n    ///\n    /// If enabled, literal strings will be used when possible and strings with\n    /// one or more newlines will use triple quotes (i.e.: `'''` or `\"\"\"`)\n    ///\n    /// If disabled, literal strings will NEVER be used and strings with one or\n    /// more newlines will use `\"\"\"`\n    ///\n    /// # Examples\n    ///\n    /// Instead of:\n    ///\n    /// ```toml,ignore\n    /// single = \"no newlines\"\n    /// text = \"\\nfoo\\nbar\\n\"\n    /// ```\n    ///\n    /// You will have:\n    ///\n    /// ```toml,ignore\n    /// single = \"no newlines\"\n    /// text = \"\"\"\n    /// foo\n    /// bar\n    /// \"\"\"\n    /// ```\n    pub fn pretty_string_literal(&mut self, value: bool) -> &mut Self {\n        let use_default = if let Some(ref mut s) = Rc::get_mut(&mut self.settings).unwrap().string {\n            s.literal = value;\n            false\n        } else {\n            true\n        };\n\n        if use_default {\n            let mut string = StringSettings::pretty();\n            string.literal = value;\n            Rc::get_mut(&mut self.settings).unwrap().string = Some(string);\n        }\n        self\n    }\n\n    /// Enable or Disable pretty arrays\n    ///\n    /// If enabled, arrays will always have each item on their own line.\n    ///\n    /// Some specific features can be controlled via other builder methods:\n    ///\n    /// - `Serializer::pretty_array_indent`: set the indent to a value other\n    ///   than 4.\n    /// - `Serializer::pretty_array_trailing_comma`: enable/disable the trailing\n    ///   comma on the last item.\n    ///\n    /// # Examples\n    ///\n    /// Instead of:\n    ///\n    /// ```toml,ignore\n    /// array = [\"foo\", \"bar\"]\n    /// ```\n    ///\n    /// You will have:\n    ///\n    /// ```toml,ignore\n    /// array = [\n    ///     \"foo\",\n    ///     \"bar\",\n    /// ]\n    /// ```\n    pub fn pretty_array(&mut self, value: bool) -> &mut Self {\n        Rc::get_mut(&mut self.settings).unwrap().array = if value {\n            Some(ArraySettings::pretty())\n        } else {\n            None\n        };\n        self\n    }\n\n    /// Set the indent for pretty arrays\n    ///\n    /// See `Serializer::pretty_array` for more details.\n    pub fn pretty_array_indent(&mut self, value: usize) -> &mut Self {\n        let use_default = if let Some(ref mut a) = Rc::get_mut(&mut self.settings).unwrap().array {\n            a.indent = value;\n            false\n        } else {\n            true\n        };\n\n        if use_default {\n            let mut array = ArraySettings::pretty();\n            array.indent = value;\n            Rc::get_mut(&mut self.settings).unwrap().array = Some(array);\n        }\n        self\n    }\n\n    /// Specify whether to use a trailing comma when serializing pretty arrays\n    ///\n    /// See `Serializer::pretty_array` for more details.\n    pub fn pretty_array_trailing_comma(&mut self, value: bool) -> &mut Self {\n        let use_default = if let Some(ref mut a) = Rc::get_mut(&mut self.settings).unwrap().array {\n            a.trailing_comma = value;\n            false\n        } else {\n            true\n        };\n\n        if use_default {\n            let mut array = ArraySettings::pretty();\n            array.trailing_comma = value;\n            Rc::get_mut(&mut self.settings).unwrap().array = Some(array);\n        }\n        self\n    }\n\n    fn display<T: fmt::Display>(&mut self, t: T, type_: ArrayState) -> Result<(), Error> {\n        self.emit_key(type_)?;\n        write!(self.dst, \"{}\", t).map_err(ser::Error::custom)?;\n        if let State::Table { .. } = self.state {\n            self.dst.push_str(\"\\n\");\n        }\n        Ok(())\n    }\n\n    fn emit_key(&mut self, type_: ArrayState) -> Result<(), Error> {\n        self.array_type(type_)?;\n        let state = self.state.clone();\n        self._emit_key(&state)\n    }\n\n    // recursive implementation of `emit_key` above\n    fn _emit_key(&mut self, state: &State<'_>) -> Result<(), Error> {\n        match *state {\n            State::End => Ok(()),\n            State::Array {\n                parent,\n                first,\n                type_,\n                len,\n            } => {\n                assert!(type_.get().is_some());\n                if first.get() {\n                    self._emit_key(parent)?;\n                }\n                self.emit_array(first, len)\n            }\n            State::Table {\n                parent,\n                first,\n                table_emitted,\n                key,\n            } => {\n                if table_emitted.get() {\n                    return Err(Error::ValueAfterTable);\n                }\n                if first.get() {\n                    self.emit_table_header(parent)?;\n                    first.set(false);\n                }\n                self.escape_key(key)?;\n                self.dst.push_str(\" = \");\n                Ok(())\n            }\n        }\n    }\n\n    fn emit_array(&mut self, first: &Cell<bool>, len: Option<usize>) -> Result<(), Error> {\n        match (len, &self.settings.array) {\n            (Some(0..=1), _) | (_, &None) => {\n                if first.get() {\n                    self.dst.push_str(\"[\")\n                } else {\n                    self.dst.push_str(\", \")\n                }\n            }\n            (_, &Some(ref a)) => {\n                if first.get() {\n                    self.dst.push_str(\"[\\n\")\n                } else {\n                    self.dst.push_str(\",\\n\")\n                }\n                for _ in 0..a.indent {\n                    self.dst.push_str(\" \");\n                }\n            }\n        }\n        Ok(())\n    }\n\n    fn array_type(&mut self, type_: ArrayState) -> Result<(), Error> {\n        let prev = match self.state {\n            State::Array { type_, .. } => type_,\n            _ => return Ok(()),\n        };\n        if prev.get().is_none() {\n            prev.set(Some(type_));\n        }\n        Ok(())\n    }\n\n    fn escape_key(&mut self, key: &str) -> Result<(), Error> {\n        let ok = key.chars().all(|c| match c {\n            'a'..='z' | 'A'..='Z' | '0'..='9' | '-' | '_' => true,\n            _ => false,\n        });\n        if ok {\n            write!(self.dst, \"{}\", key).map_err(ser::Error::custom)?;\n        } else {\n            self.emit_str(key, true)?;\n        }\n        Ok(())\n    }\n\n    fn emit_str(&mut self, value: &str, is_key: bool) -> Result<(), Error> {\n        #[derive(PartialEq)]\n        enum Type {\n            NewlineTripple,\n            OnelineTripple,\n            OnelineSingle,\n        }\n\n        enum Repr {\n            /// represent as a literal string (using '')\n            Literal(String, Type),\n            /// represent the std way (using \"\")\n            Std(Type),\n        }\n\n        fn do_pretty(value: &str) -> Repr {\n            // For doing pretty prints we store in a new String\n            // because there are too many cases where pretty cannot\n            // work. We need to determine:\n            // - if we are a \"multi-line\" pretty (if there are \\n)\n            // - if ['''] appears if multi or ['] if single\n            // - if there are any invalid control characters\n            //\n            // Doing it any other way would require multiple passes\n            // to determine if a pretty string works or not.\n            let mut out = String::with_capacity(value.len() * 2);\n            let mut ty = Type::OnelineSingle;\n            // found consecutive single quotes\n            let mut max_found_singles = 0;\n            let mut found_singles = 0;\n            let mut can_be_pretty = true;\n\n            for ch in value.chars() {\n                if can_be_pretty {\n                    if ch == '\\'' {\n                        found_singles += 1;\n                        if found_singles >= 3 {\n                            can_be_pretty = false;\n                        }\n                    } else {\n                        if found_singles > max_found_singles {\n                            max_found_singles = found_singles;\n                        }\n                        found_singles = 0\n                    }\n                    match ch {\n                        '\\t' => {}\n                        '\\n' => ty = Type::NewlineTripple,\n                        // Escape codes are needed if any ascii control\n                        // characters are present, including \\b \\f \\r.\n                        c if c <= '\\u{1f}' || c == '\\u{7f}' => can_be_pretty = false,\n                        _ => {}\n                    }\n                    out.push(ch);\n                } else {\n                    // the string cannot be represented as pretty,\n                    // still check if it should be multiline\n                    if ch == '\\n' {\n                        ty = Type::NewlineTripple;\n                    }\n                }\n            }\n            if can_be_pretty && found_singles > 0 && value.ends_with('\\'') {\n                // We cannot escape the ending quote so we must use \"\"\"\n                can_be_pretty = false;\n            }\n            if !can_be_pretty {\n                debug_assert!(ty != Type::OnelineTripple);\n                return Repr::Std(ty);\n            }\n            if found_singles > max_found_singles {\n                max_found_singles = found_singles;\n            }\n            debug_assert!(max_found_singles < 3);\n            if ty == Type::OnelineSingle && max_found_singles >= 1 {\n                // no newlines, but must use ''' because it has ' in it\n                ty = Type::OnelineTripple;\n            }\n            Repr::Literal(out, ty)\n        }\n\n        let repr = if !is_key && self.settings.string.is_some() {\n            match (&self.settings.string, do_pretty(value)) {\n                (&Some(StringSettings { literal: false, .. }), Repr::Literal(_, ty)) => {\n                    Repr::Std(ty)\n                }\n                (_, r) => r,\n            }\n        } else {\n            Repr::Std(Type::OnelineSingle)\n        };\n        match repr {\n            Repr::Literal(literal, ty) => {\n                // A pretty string\n                match ty {\n                    Type::NewlineTripple => self.dst.push_str(\"'''\\n\"),\n                    Type::OnelineTripple => self.dst.push_str(\"'''\"),\n                    Type::OnelineSingle => self.dst.push('\\''),\n                }\n                self.dst.push_str(&literal);\n                match ty {\n                    Type::OnelineSingle => self.dst.push('\\''),\n                    _ => self.dst.push_str(\"'''\"),\n                }\n            }\n            Repr::Std(ty) => {\n                match ty {\n                    Type::NewlineTripple => self.dst.push_str(\"\\\"\\\"\\\"\\n\"),\n                    // note: OnelineTripple can happen if do_pretty wants to do\n                    // '''it's one line'''\n                    // but settings.string.literal == false\n                    Type::OnelineSingle | Type::OnelineTripple => self.dst.push('\"'),\n                }\n                for ch in value.chars() {\n                    match ch {\n                        '\\u{8}' => self.dst.push_str(\"\\\\b\"),\n                        '\\u{9}' => self.dst.push_str(\"\\\\t\"),\n                        '\\u{a}' => match ty {\n                            Type::NewlineTripple => self.dst.push('\\n'),\n                            Type::OnelineSingle => self.dst.push_str(\"\\\\n\"),\n                            _ => unreachable!(),\n                        },\n                        '\\u{c}' => self.dst.push_str(\"\\\\f\"),\n                        '\\u{d}' => self.dst.push_str(\"\\\\r\"),\n                        '\\u{22}' => self.dst.push_str(\"\\\\\\\"\"),\n                        '\\u{5c}' => self.dst.push_str(\"\\\\\\\\\"),\n                        c if c <= '\\u{1f}' || c == '\\u{7f}' => {\n                            write!(self.dst, \"\\\\u{:04X}\", ch as u32).map_err(ser::Error::custom)?;\n                        }\n                        ch => self.dst.push(ch),\n                    }\n                }\n                match ty {\n                    Type::NewlineTripple => self.dst.push_str(\"\\\"\\\"\\\"\"),\n                    Type::OnelineSingle | Type::OnelineTripple => self.dst.push('\"'),\n                }\n            }\n        }\n        Ok(())\n    }\n\n    fn emit_table_header(&mut self, state: &State<'_>) -> Result<(), Error> {\n        let array_of_tables = match *state {\n            State::End => return Ok(()),\n            State::Array { .. } => true,\n            _ => false,\n        };\n\n        // Unlike [..]s, we can't omit [[..]] ancestors, so be sure to emit table\n        // headers for them.\n        let mut p = state;\n        if let State::Array { first, parent, .. } = *state {\n            if first.get() {\n                p = parent;\n            }\n        }\n        while let State::Table { first, parent, .. } = *p {\n            p = parent;\n            if !first.get() {\n                break;\n            }\n            if let State::Array {\n                parent: &State::Table { .. },\n                ..\n            } = *parent\n            {\n                self.emit_table_header(parent)?;\n                break;\n            }\n        }\n\n        match *state {\n            State::Table { first, .. } => {\n                if !first.get() {\n                    // Newline if we are a table that is not the first\n                    // table in the document.\n                    self.dst.push('\\n');\n                }\n            }\n            State::Array { parent, first, .. } => {\n                if !first.get() {\n                    // Always newline if we are not the first item in the\n                    // table-array\n                    self.dst.push('\\n');\n                } else if let State::Table { first, .. } = *parent {\n                    if !first.get() {\n                        // Newline if we are not the first item in the document\n                        self.dst.push('\\n');\n                    }\n                }\n            }\n            _ => {}\n        }\n        self.dst.push_str(\"[\");\n        if array_of_tables {\n            self.dst.push_str(\"[\");\n        }\n        self.emit_key_part(state)?;\n        if array_of_tables {\n            self.dst.push_str(\"]\");\n        }\n        self.dst.push_str(\"]\\n\");\n        Ok(())\n    }\n\n    fn emit_key_part(&mut self, key: &State<'_>) -> Result<bool, Error> {\n        match *key {\n            State::Array { parent, .. } => self.emit_key_part(parent),\n            State::End => Ok(true),\n            State::Table {\n                key,\n                parent,\n                table_emitted,\n                ..\n            } => {\n                table_emitted.set(true);\n                let first = self.emit_key_part(parent)?;\n                if !first {\n                    self.dst.push_str(\".\");\n                }\n                self.escape_key(key)?;\n                Ok(false)\n            }\n        }\n    }\n}\n\nmacro_rules! serialize_float {\n    ($this:expr, $v:expr) => {{\n        $this.emit_key(ArrayState::Started)?;\n        if ($v.is_nan() || $v == 0.0) && $v.is_sign_negative() {\n            write!($this.dst, \"-\").map_err(ser::Error::custom)?;\n        }\n        if $v.is_nan() {\n            write!($this.dst, \"nan\").map_err(ser::Error::custom)?;\n        } else {\n            write!($this.dst, \"{}\", $v).map_err(ser::Error::custom)?;\n        }\n        if $v % 1.0 == 0.0 {\n            write!($this.dst, \".0\").map_err(ser::Error::custom)?;\n        }\n        if let State::Table { .. } = $this.state {\n            $this.dst.push_str(\"\\n\");\n        }\n        return Ok(());\n    }};\n}\n\nimpl<'a, 'b> ser::Serializer for &'b mut Serializer<'a> {\n    type Ok = ();\n    type Error = Error;\n    type SerializeSeq = SerializeSeq<'a, 'b>;\n    type SerializeTuple = SerializeSeq<'a, 'b>;\n    type SerializeTupleStruct = SerializeSeq<'a, 'b>;\n    type SerializeTupleVariant = SerializeSeq<'a, 'b>;\n    type SerializeMap = SerializeTable<'a, 'b>;\n    type SerializeStruct = SerializeTable<'a, 'b>;\n    type SerializeStructVariant = ser::Impossible<(), Error>;\n\n    fn serialize_bool(self, v: bool) -> Result<(), Self::Error> {\n        self.display(v, ArrayState::Started)\n    }\n\n    fn serialize_i8(self, v: i8) -> Result<(), Self::Error> {\n        self.display(v, ArrayState::Started)\n    }\n\n    fn serialize_i16(self, v: i16) -> Result<(), Self::Error> {\n        self.display(v, ArrayState::Started)\n    }\n\n    fn serialize_i32(self, v: i32) -> Result<(), Self::Error> {\n        self.display(v, ArrayState::Started)\n    }\n\n    fn serialize_i64(self, v: i64) -> Result<(), Self::Error> {\n        self.display(v, ArrayState::Started)\n    }\n\n    fn serialize_u8(self, v: u8) -> Result<(), Self::Error> {\n        self.display(v, ArrayState::Started)\n    }\n\n    fn serialize_u16(self, v: u16) -> Result<(), Self::Error> {\n        self.display(v, ArrayState::Started)\n    }\n\n    fn serialize_u32(self, v: u32) -> Result<(), Self::Error> {\n        self.display(v, ArrayState::Started)\n    }\n\n    fn serialize_u64(self, v: u64) -> Result<(), Self::Error> {\n        self.display(v, ArrayState::Started)\n    }\n\n    fn serialize_f32(self, v: f32) -> Result<(), Self::Error> {\n        serialize_float!(self, v)\n    }\n\n    fn serialize_f64(self, v: f64) -> Result<(), Self::Error> {\n        serialize_float!(self, v)\n    }\n\n    fn serialize_char(self, v: char) -> Result<(), Self::Error> {\n        let mut buf = [0; 4];\n        self.serialize_str(v.encode_utf8(&mut buf))\n    }\n\n    fn serialize_str(self, value: &str) -> Result<(), Self::Error> {\n        self.emit_key(ArrayState::Started)?;\n        self.emit_str(value, false)?;\n        if let State::Table { .. } = self.state {\n            self.dst.push_str(\"\\n\");\n        }\n        Ok(())\n    }\n\n    fn serialize_bytes(self, value: &[u8]) -> Result<(), Self::Error> {\n        use serde::ser::Serialize;\n        value.serialize(self)\n    }\n\n    fn serialize_none(self) -> Result<(), Self::Error> {\n        Err(Error::UnsupportedNone)\n    }\n\n    fn serialize_some<T: ?Sized>(self, value: &T) -> Result<(), Self::Error>\n    where\n        T: ser::Serialize,\n    {\n        value.serialize(self)\n    }\n\n    fn serialize_unit(self) -> Result<(), Self::Error> {\n        Err(Error::UnsupportedType)\n    }\n\n    fn serialize_unit_struct(self, _name: &'static str) -> Result<(), Self::Error> {\n        Err(Error::UnsupportedType)\n    }\n\n    fn serialize_unit_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n    ) -> Result<(), Self::Error> {\n        self.serialize_str(variant)\n    }\n\n    fn serialize_newtype_struct<T: ?Sized>(\n        self,\n        _name: &'static str,\n        value: &T,\n    ) -> Result<(), Self::Error>\n    where\n        T: ser::Serialize,\n    {\n        value.serialize(self)\n    }\n\n    fn serialize_newtype_variant<T: ?Sized>(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _value: &T,\n    ) -> Result<(), Self::Error>\n    where\n        T: ser::Serialize,\n    {\n        Err(Error::UnsupportedType)\n    }\n\n    fn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq, Self::Error> {\n        self.array_type(ArrayState::Started)?;\n        Ok(SerializeSeq {\n            ser: self,\n            first: Cell::new(true),\n            type_: Cell::new(None),\n            len,\n        })\n    }\n\n    fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple, Self::Error> {\n        self.serialize_seq(Some(len))\n    }\n\n    fn serialize_tuple_struct(\n        self,\n        _name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleStruct, Self::Error> {\n        self.serialize_seq(Some(len))\n    }\n\n    fn serialize_tuple_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleVariant, Self::Error> {\n        self.serialize_seq(Some(len))\n    }\n\n    fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap, Self::Error> {\n        self.array_type(ArrayState::StartedAsATable)?;\n        Ok(SerializeTable::Table {\n            ser: self,\n            key: String::new(),\n            first: Cell::new(true),\n            table_emitted: Cell::new(false),\n        })\n    }\n\n    fn serialize_struct(\n        self,\n        name: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStruct, Self::Error> {\n        if name == datetime::NAME {\n            self.array_type(ArrayState::Started)?;\n            Ok(SerializeTable::Datetime(self))\n        } else {\n            self.array_type(ArrayState::StartedAsATable)?;\n            Ok(SerializeTable::Table {\n                ser: self,\n                key: String::new(),\n                first: Cell::new(true),\n                table_emitted: Cell::new(false),\n            })\n        }\n    }\n\n    fn serialize_struct_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStructVariant, Self::Error> {\n        Err(Error::UnsupportedType)\n    }\n}\n\nimpl<'a, 'b> ser::SerializeSeq for SerializeSeq<'a, 'b> {\n    type Ok = ();\n    type Error = Error;\n\n    fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n    where\n        T: ser::Serialize,\n    {\n        value.serialize(&mut Serializer {\n            dst: &mut *self.ser.dst,\n            state: State::Array {\n                parent: &self.ser.state,\n                first: &self.first,\n                type_: &self.type_,\n                len: self.len,\n            },\n            settings: self.ser.settings.clone(),\n        })?;\n        self.first.set(false);\n        Ok(())\n    }\n\n    fn end(self) -> Result<(), Error> {\n        match self.type_.get() {\n            Some(ArrayState::StartedAsATable) => return Ok(()),\n            Some(ArrayState::Started) => match (self.len, &self.ser.settings.array) {\n                (Some(0..=1), _) | (_, &None) => {\n                    self.ser.dst.push_str(\"]\");\n                }\n                (_, &Some(ref a)) => {\n                    if a.trailing_comma {\n                        self.ser.dst.push_str(\",\");\n                    }\n                    self.ser.dst.push_str(\"\\n]\");\n                }\n            },\n            None => {\n                assert!(self.first.get());\n                self.ser.emit_key(ArrayState::Started)?;\n                self.ser.dst.push_str(\"[]\")\n            }\n        }\n        if let State::Table { .. } = self.ser.state {\n            self.ser.dst.push_str(\"\\n\");\n        }\n        Ok(())\n    }\n}\n\nimpl<'a, 'b> ser::SerializeTuple for SerializeSeq<'a, 'b> {\n    type Ok = ();\n    type Error = Error;\n\n    fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n    where\n        T: ser::Serialize,\n    {\n        ser::SerializeSeq::serialize_element(self, value)\n    }\n\n    fn end(self) -> Result<(), Error> {\n        ser::SerializeSeq::end(self)\n    }\n}\n\nimpl<'a, 'b> ser::SerializeTupleVariant for SerializeSeq<'a, 'b> {\n    type Ok = ();\n    type Error = Error;\n\n    fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n    where\n        T: ser::Serialize,\n    {\n        ser::SerializeSeq::serialize_element(self, value)\n    }\n\n    fn end(self) -> Result<(), Error> {\n        ser::SerializeSeq::end(self)\n    }\n}\n\nimpl<'a, 'b> ser::SerializeTupleStruct for SerializeSeq<'a, 'b> {\n    type Ok = ();\n    type Error = Error;\n\n    fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n    where\n        T: ser::Serialize,\n    {\n        ser::SerializeSeq::serialize_element(self, value)\n    }\n\n    fn end(self) -> Result<(), Error> {\n        ser::SerializeSeq::end(self)\n    }\n}\n\nimpl<'a, 'b> ser::SerializeMap for SerializeTable<'a, 'b> {\n    type Ok = ();\n    type Error = Error;\n\n    fn serialize_key<T: ?Sized>(&mut self, input: &T) -> Result<(), Error>\n    where\n        T: ser::Serialize,\n    {\n        match *self {\n            SerializeTable::Datetime(_) => panic!(), // shouldn't be possible\n            SerializeTable::Table { ref mut key, .. } => {\n                key.truncate(0);\n                *key = input.serialize(StringExtractor)?;\n            }\n        }\n        Ok(())\n    }\n\n    fn serialize_value<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n    where\n        T: ser::Serialize,\n    {\n        match *self {\n            SerializeTable::Datetime(_) => panic!(), // shouldn't be possible\n            SerializeTable::Table {\n                ref mut ser,\n                ref key,\n                ref first,\n                ref table_emitted,\n                ..\n            } => {\n                let res = value.serialize(&mut Serializer {\n                    dst: &mut *ser.dst,\n                    state: State::Table {\n                        key,\n                        parent: &ser.state,\n                        first,\n                        table_emitted,\n                    },\n                    settings: ser.settings.clone(),\n                });\n                match res {\n                    Ok(()) => first.set(false),\n                    Err(Error::UnsupportedNone) => {}\n                    Err(e) => return Err(e),\n                }\n            }\n        }\n        Ok(())\n    }\n\n    fn end(self) -> Result<(), Error> {\n        match self {\n            SerializeTable::Datetime(_) => panic!(), // shouldn't be possible\n            SerializeTable::Table { ser, first, .. } => {\n                if first.get() {\n                    let state = ser.state.clone();\n                    ser.emit_table_header(&state)?;\n                }\n            }\n        }\n        Ok(())\n    }\n}\n\nimpl<'a, 'b> ser::SerializeStruct for SerializeTable<'a, 'b> {\n    type Ok = ();\n    type Error = Error;\n\n    fn serialize_field<T: ?Sized>(&mut self, key: &'static str, value: &T) -> Result<(), Error>\n    where\n        T: ser::Serialize,\n    {\n        match *self {\n            SerializeTable::Datetime(ref mut ser) => {\n                if key == datetime::FIELD {\n                    value.serialize(DateStrEmitter(&mut *ser))?;\n                } else {\n                    return Err(Error::DateInvalid);\n                }\n            }\n            SerializeTable::Table {\n                ref mut ser,\n                ref first,\n                ref table_emitted,\n                ..\n            } => {\n                let res = value.serialize(&mut Serializer {\n                    dst: &mut *ser.dst,\n                    state: State::Table {\n                        key,\n                        parent: &ser.state,\n                        first,\n                        table_emitted,\n                    },\n                    settings: ser.settings.clone(),\n                });\n                match res {\n                    Ok(()) => first.set(false),\n                    Err(Error::UnsupportedNone) => {}\n                    Err(e) => return Err(e),\n                }\n            }\n        }\n        Ok(())\n    }\n\n    fn end(self) -> Result<(), Error> {\n        match self {\n            SerializeTable::Datetime(_) => {}\n            SerializeTable::Table { ser, first, .. } => {\n                if first.get() {\n                    let state = ser.state.clone();\n                    ser.emit_table_header(&state)?;\n                }\n            }\n        }\n        Ok(())\n    }\n}\n\nstruct DateStrEmitter<'a, 'b>(&'b mut Serializer<'a>);\n\nimpl<'a, 'b> ser::Serializer for DateStrEmitter<'a, 'b> {\n    type Ok = ();\n    type Error = Error;\n    type SerializeSeq = ser::Impossible<(), Error>;\n    type SerializeTuple = ser::Impossible<(), Error>;\n    type SerializeTupleStruct = ser::Impossible<(), Error>;\n    type SerializeTupleVariant = ser::Impossible<(), Error>;\n    type SerializeMap = ser::Impossible<(), Error>;\n    type SerializeStruct = ser::Impossible<(), Error>;\n    type SerializeStructVariant = ser::Impossible<(), Error>;\n\n    fn serialize_bool(self, _v: bool) -> Result<(), Self::Error> {\n        Err(Error::DateInvalid)\n    }\n\n    fn serialize_i8(self, _v: i8) -> Result<(), Self::Error> {\n        Err(Error::DateInvalid)\n    }\n\n    fn serialize_i16(self, _v: i16) -> Result<(), Self::Error> {\n        Err(Error::DateInvalid)\n    }\n\n    fn serialize_i32(self, _v: i32) -> Result<(), Self::Error> {\n        Err(Error::DateInvalid)\n    }\n\n    fn serialize_i64(self, _v: i64) -> Result<(), Self::Error> {\n        Err(Error::DateInvalid)\n    }\n\n    fn serialize_u8(self, _v: u8) -> Result<(), Self::Error> {\n        Err(Error::DateInvalid)\n    }\n\n    fn serialize_u16(self, _v: u16) -> Result<(), Self::Error> {\n        Err(Error::DateInvalid)\n    }\n\n    fn serialize_u32(self, _v: u32) -> Result<(), Self::Error> {\n        Err(Error::DateInvalid)\n    }\n\n    fn serialize_u64(self, _v: u64) -> Result<(), Self::Error> {\n        Err(Error::DateInvalid)\n    }\n\n    fn serialize_f32(self, _v: f32) -> Result<(), Self::Error> {\n        Err(Error::DateInvalid)\n    }\n\n    fn serialize_f64(self, _v: f64) -> Result<(), Self::Error> {\n        Err(Error::DateInvalid)\n    }\n\n    fn serialize_char(self, _v: char) -> Result<(), Self::Error> {\n        Err(Error::DateInvalid)\n    }\n\n    fn serialize_str(self, value: &str) -> Result<(), Self::Error> {\n        self.0.display(value, ArrayState::Started)?;\n        Ok(())\n    }\n\n    fn serialize_bytes(self, _value: &[u8]) -> Result<(), Self::Error> {\n        Err(Error::DateInvalid)\n    }\n\n    fn serialize_none(self) -> Result<(), Self::Error> {\n        Err(Error::DateInvalid)\n    }\n\n    fn serialize_some<T: ?Sized>(self, _value: &T) -> Result<(), Self::Error>\n    where\n        T: ser::Serialize,\n    {\n        Err(Error::DateInvalid)\n    }\n\n    fn serialize_unit(self) -> Result<(), Self::Error> {\n        Err(Error::DateInvalid)\n    }\n\n    fn serialize_unit_struct(self, _name: &'static str) -> Result<(), Self::Error> {\n        Err(Error::DateInvalid)\n    }\n\n    fn serialize_unit_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n    ) -> Result<(), Self::Error> {\n        Err(Error::DateInvalid)\n    }\n\n    fn serialize_newtype_struct<T: ?Sized>(\n        self,\n        _name: &'static str,\n        _value: &T,\n    ) -> Result<(), Self::Error>\n    where\n        T: ser::Serialize,\n    {\n        Err(Error::DateInvalid)\n    }\n\n    fn serialize_newtype_variant<T: ?Sized>(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _value: &T,\n    ) -> Result<(), Self::Error>\n    where\n        T: ser::Serialize,\n    {\n        Err(Error::DateInvalid)\n    }\n\n    fn serialize_seq(self, _len: Option<usize>) -> Result<Self::SerializeSeq, Self::Error> {\n        Err(Error::DateInvalid)\n    }\n\n    fn serialize_tuple(self, _len: usize) -> Result<Self::SerializeTuple, Self::Error> {\n        Err(Error::DateInvalid)\n    }\n\n    fn serialize_tuple_struct(\n        self,\n        _name: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeTupleStruct, Self::Error> {\n        Err(Error::DateInvalid)\n    }\n\n    fn serialize_tuple_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeTupleVariant, Self::Error> {\n        Err(Error::DateInvalid)\n    }\n\n    fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap, Self::Error> {\n        Err(Error::DateInvalid)\n    }\n\n    fn serialize_struct(\n        self,\n        _name: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStruct, Self::Error> {\n        Err(Error::DateInvalid)\n    }\n\n    fn serialize_struct_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStructVariant, Self::Error> {\n        Err(Error::DateInvalid)\n    }\n}\n\nstruct StringExtractor;\n\nimpl ser::Serializer for StringExtractor {\n    type Ok = String;\n    type Error = Error;\n    type SerializeSeq = ser::Impossible<String, Error>;\n    type SerializeTuple = ser::Impossible<String, Error>;\n    type SerializeTupleStruct = ser::Impossible<String, Error>;\n    type SerializeTupleVariant = ser::Impossible<String, Error>;\n    type SerializeMap = ser::Impossible<String, Error>;\n    type SerializeStruct = ser::Impossible<String, Error>;\n    type SerializeStructVariant = ser::Impossible<String, Error>;\n\n    fn serialize_bool(self, _v: bool) -> Result<String, Self::Error> {\n        Err(Error::KeyNotString)\n    }\n\n    fn serialize_i8(self, _v: i8) -> Result<String, Self::Error> {\n        Err(Error::KeyNotString)\n    }\n\n    fn serialize_i16(self, _v: i16) -> Result<String, Self::Error> {\n        Err(Error::KeyNotString)\n    }\n\n    fn serialize_i32(self, _v: i32) -> Result<String, Self::Error> {\n        Err(Error::KeyNotString)\n    }\n\n    fn serialize_i64(self, _v: i64) -> Result<String, Self::Error> {\n        Err(Error::KeyNotString)\n    }\n\n    fn serialize_u8(self, _v: u8) -> Result<String, Self::Error> {\n        Err(Error::KeyNotString)\n    }\n\n    fn serialize_u16(self, _v: u16) -> Result<String, Self::Error> {\n        Err(Error::KeyNotString)\n    }\n\n    fn serialize_u32(self, _v: u32) -> Result<String, Self::Error> {\n        Err(Error::KeyNotString)\n    }\n\n    fn serialize_u64(self, _v: u64) -> Result<String, Self::Error> {\n        Err(Error::KeyNotString)\n    }\n\n    fn serialize_f32(self, _v: f32) -> Result<String, Self::Error> {\n        Err(Error::KeyNotString)\n    }\n\n    fn serialize_f64(self, _v: f64) -> Result<String, Self::Error> {\n        Err(Error::KeyNotString)\n    }\n\n    fn serialize_char(self, _v: char) -> Result<String, Self::Error> {\n        Err(Error::KeyNotString)\n    }\n\n    fn serialize_str(self, value: &str) -> Result<String, Self::Error> {\n        Ok(value.to_string())\n    }\n\n    fn serialize_bytes(self, _value: &[u8]) -> Result<String, Self::Error> {\n        Err(Error::KeyNotString)\n    }\n\n    fn serialize_none(self) -> Result<String, Self::Error> {\n        Err(Error::KeyNotString)\n    }\n\n    fn serialize_some<T: ?Sized>(self, _value: &T) -> Result<String, Self::Error>\n    where\n        T: ser::Serialize,\n    {\n        Err(Error::KeyNotString)\n    }\n\n    fn serialize_unit(self) -> Result<String, Self::Error> {\n        Err(Error::KeyNotString)\n    }\n\n    fn serialize_unit_struct(self, _name: &'static str) -> Result<String, Self::Error> {\n        Err(Error::KeyNotString)\n    }\n\n    fn serialize_unit_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n    ) -> Result<String, Self::Error> {\n        Err(Error::KeyNotString)\n    }\n\n    fn serialize_newtype_struct<T: ?Sized>(\n        self,\n        _name: &'static str,\n        value: &T,\n    ) -> Result<String, Self::Error>\n    where\n        T: ser::Serialize,\n    {\n        value.serialize(self)\n    }\n\n    fn serialize_newtype_variant<T: ?Sized>(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _value: &T,\n    ) -> Result<String, Self::Error>\n    where\n        T: ser::Serialize,\n    {\n        Err(Error::KeyNotString)\n    }\n\n    fn serialize_seq(self, _len: Option<usize>) -> Result<Self::SerializeSeq, Self::Error> {\n        Err(Error::KeyNotString)\n    }\n\n    fn serialize_tuple(self, _len: usize) -> Result<Self::SerializeTuple, Self::Error> {\n        Err(Error::KeyNotString)\n    }\n\n    fn serialize_tuple_struct(\n        self,\n        _name: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeTupleStruct, Self::Error> {\n        Err(Error::KeyNotString)\n    }\n\n    fn serialize_tuple_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeTupleVariant, Self::Error> {\n        Err(Error::KeyNotString)\n    }\n\n    fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap, Self::Error> {\n        Err(Error::KeyNotString)\n    }\n\n    fn serialize_struct(\n        self,\n        _name: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStruct, Self::Error> {\n        Err(Error::KeyNotString)\n    }\n\n    fn serialize_struct_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStructVariant, Self::Error> {\n        Err(Error::KeyNotString)\n    }\n}\n\nimpl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            Error::UnsupportedType => \"unsupported Rust type\".fmt(f),\n            Error::KeyNotString => \"map key was not a string\".fmt(f),\n            Error::ValueAfterTable => \"values must be emitted before tables\".fmt(f),\n            Error::DateInvalid => \"a serialized date was invalid\".fmt(f),\n            Error::NumberInvalid => \"a serialized number was invalid\".fmt(f),\n            Error::UnsupportedNone => \"unsupported None value\".fmt(f),\n            Error::Custom(ref s) => s.fmt(f),\n            Error::KeyNewline => unreachable!(),\n            Error::ArrayMixedType => unreachable!(),\n            Error::__Nonexhaustive => panic!(),\n        }\n    }\n}\n\nimpl error::Error for Error {}\n\nimpl ser::Error for Error {\n    fn custom<T: fmt::Display>(msg: T) -> Error {\n        Error::Custom(msg.to_string())\n    }\n}\n\nenum Category {\n    Primitive,\n    Array,\n    Table,\n}\n\n/// Convenience function to serialize items in a map in an order valid with\n/// TOML.\n///\n/// TOML carries the restriction that keys in a table must be serialized last if\n/// their value is a table itself. This isn't always easy to guarantee, so this\n/// helper can be used like so:\n///\n/// ```rust\n/// # use serde_derive::Serialize;\n/// # use std::collections::HashMap;\n/// #[derive(Serialize)]\n/// struct Manifest {\n///     package: Package,\n///     #[serde(serialize_with = \"toml::ser::tables_last\")]\n///     dependencies: HashMap<String, Dependency>,\n/// }\n/// # type Package = String;\n/// # type Dependency = String;\n/// # fn main() {}\n/// ```\npub fn tables_last<'a, I, K, V, S>(data: &'a I, serializer: S) -> Result<S::Ok, S::Error>\nwhere\n    &'a I: IntoIterator<Item = (K, V)>,\n    K: ser::Serialize,\n    V: ser::Serialize,\n    S: ser::Serializer,\n{\n    use serde::ser::SerializeMap;\n\n    let mut map = serializer.serialize_map(None)?;\n    for (k, v) in data {\n        if let Category::Primitive = v.serialize(Categorize::new())? {\n            map.serialize_entry(&k, &v)?;\n        }\n    }\n    for (k, v) in data {\n        if let Category::Array = v.serialize(Categorize::new())? {\n            map.serialize_entry(&k, &v)?;\n        }\n    }\n    for (k, v) in data {\n        if let Category::Table = v.serialize(Categorize::new())? {\n            map.serialize_entry(&k, &v)?;\n        }\n    }\n    map.end()\n}\n\nstruct Categorize<E>(marker::PhantomData<E>);\n\nimpl<E> Categorize<E> {\n    fn new() -> Self {\n        Categorize(marker::PhantomData)\n    }\n}\n\nimpl<E: ser::Error> ser::Serializer for Categorize<E> {\n    type Ok = Category;\n    type Error = E;\n    type SerializeSeq = Self;\n    type SerializeTuple = Self;\n    type SerializeTupleStruct = Self;\n    type SerializeTupleVariant = Self;\n    type SerializeMap = Self;\n    type SerializeStruct = Self;\n    type SerializeStructVariant = ser::Impossible<Category, E>;\n\n    fn serialize_bool(self, _: bool) -> Result<Self::Ok, Self::Error> {\n        Ok(Category::Primitive)\n    }\n\n    fn serialize_i8(self, _: i8) -> Result<Self::Ok, Self::Error> {\n        Ok(Category::Primitive)\n    }\n\n    fn serialize_i16(self, _: i16) -> Result<Self::Ok, Self::Error> {\n        Ok(Category::Primitive)\n    }\n\n    fn serialize_i32(self, _: i32) -> Result<Self::Ok, Self::Error> {\n        Ok(Category::Primitive)\n    }\n\n    fn serialize_i64(self, _: i64) -> Result<Self::Ok, Self::Error> {\n        Ok(Category::Primitive)\n    }\n\n    fn serialize_u8(self, _: u8) -> Result<Self::Ok, Self::Error> {\n        Ok(Category::Primitive)\n    }\n\n    fn serialize_u16(self, _: u16) -> Result<Self::Ok, Self::Error> {\n        Ok(Category::Primitive)\n    }\n\n    fn serialize_u32(self, _: u32) -> Result<Self::Ok, Self::Error> {\n        Ok(Category::Primitive)\n    }\n\n    fn serialize_u64(self, _: u64) -> Result<Self::Ok, Self::Error> {\n        Ok(Category::Primitive)\n    }\n\n    fn serialize_f32(self, _: f32) -> Result<Self::Ok, Self::Error> {\n        Ok(Category::Primitive)\n    }\n\n    fn serialize_f64(self, _: f64) -> Result<Self::Ok, Self::Error> {\n        Ok(Category::Primitive)\n    }\n\n    fn serialize_char(self, _: char) -> Result<Self::Ok, Self::Error> {\n        Ok(Category::Primitive)\n    }\n\n    fn serialize_str(self, _: &str) -> Result<Self::Ok, Self::Error> {\n        Ok(Category::Primitive)\n    }\n\n    fn serialize_bytes(self, _: &[u8]) -> Result<Self::Ok, Self::Error> {\n        Ok(Category::Array)\n    }\n\n    fn serialize_none(self) -> Result<Self::Ok, Self::Error> {\n        Err(ser::Error::custom(\"unsupported\"))\n    }\n\n    fn serialize_some<T: ?Sized + ser::Serialize>(self, v: &T) -> Result<Self::Ok, Self::Error> {\n        v.serialize(self)\n    }\n\n    fn serialize_unit(self) -> Result<Self::Ok, Self::Error> {\n        Err(ser::Error::custom(\"unsupported\"))\n    }\n\n    fn serialize_unit_struct(self, _: &'static str) -> Result<Self::Ok, Self::Error> {\n        Err(ser::Error::custom(\"unsupported\"))\n    }\n\n    fn serialize_unit_variant(\n        self,\n        _: &'static str,\n        _: u32,\n        _: &'static str,\n    ) -> Result<Self::Ok, Self::Error> {\n        Err(ser::Error::custom(\"unsupported\"))\n    }\n\n    fn serialize_newtype_struct<T: ?Sized + ser::Serialize>(\n        self,\n        _: &'static str,\n        v: &T,\n    ) -> Result<Self::Ok, Self::Error> {\n        v.serialize(self)\n    }\n\n    fn serialize_newtype_variant<T: ?Sized + ser::Serialize>(\n        self,\n        _: &'static str,\n        _: u32,\n        _: &'static str,\n        _: &T,\n    ) -> Result<Self::Ok, Self::Error> {\n        Err(ser::Error::custom(\"unsupported\"))\n    }\n\n    fn serialize_seq(self, _: Option<usize>) -> Result<Self, Self::Error> {\n        Ok(self)\n    }\n\n    fn serialize_tuple(self, _: usize) -> Result<Self::SerializeTuple, Self::Error> {\n        Ok(self)\n    }\n\n    fn serialize_tuple_struct(\n        self,\n        _: &'static str,\n        _: usize,\n    ) -> Result<Self::SerializeTupleStruct, Self::Error> {\n        Ok(self)\n    }\n\n    fn serialize_tuple_variant(\n        self,\n        _: &'static str,\n        _: u32,\n        _: &'static str,\n        _: usize,\n    ) -> Result<Self::SerializeTupleVariant, Self::Error> {\n        Ok(self)\n    }\n\n    fn serialize_map(self, _: Option<usize>) -> Result<Self, Self::Error> {\n        Ok(self)\n    }\n\n    fn serialize_struct(self, _: &'static str, _: usize) -> Result<Self, Self::Error> {\n        Ok(self)\n    }\n\n    fn serialize_struct_variant(\n        self,\n        _: &'static str,\n        _: u32,\n        _: &'static str,\n        _: usize,\n    ) -> Result<Self::SerializeStructVariant, Self::Error> {\n        Err(ser::Error::custom(\"unsupported\"))\n    }\n}\n\nimpl<E: ser::Error> ser::SerializeSeq for Categorize<E> {\n    type Ok = Category;\n    type Error = E;\n\n    fn serialize_element<T: ?Sized + ser::Serialize>(&mut self, _: &T) -> Result<(), Self::Error> {\n        Ok(())\n    }\n\n    fn end(self) -> Result<Self::Ok, Self::Error> {\n        Ok(Category::Array)\n    }\n}\n\nimpl<E: ser::Error> ser::SerializeTuple for Categorize<E> {\n    type Ok = Category;\n    type Error = E;\n\n    fn serialize_element<T: ?Sized + ser::Serialize>(&mut self, _: &T) -> Result<(), Self::Error> {\n        Ok(())\n    }\n\n    fn end(self) -> Result<Self::Ok, Self::Error> {\n        Ok(Category::Array)\n    }\n}\n\nimpl<E: ser::Error> ser::SerializeTupleVariant for Categorize<E> {\n    type Ok = Category;\n    type Error = E;\n\n    fn serialize_field<T: ?Sized + ser::Serialize>(&mut self, _: &T) -> Result<(), Self::Error> {\n        Ok(())\n    }\n\n    fn end(self) -> Result<Self::Ok, Self::Error> {\n        Ok(Category::Array)\n    }\n}\n\nimpl<E: ser::Error> ser::SerializeTupleStruct for Categorize<E> {\n    type Ok = Category;\n    type Error = E;\n\n    fn serialize_field<T: ?Sized + ser::Serialize>(&mut self, _: &T) -> Result<(), Self::Error> {\n        Ok(())\n    }\n\n    fn end(self) -> Result<Self::Ok, Self::Error> {\n        Ok(Category::Array)\n    }\n}\n\nimpl<E: ser::Error> ser::SerializeMap for Categorize<E> {\n    type Ok = Category;\n    type Error = E;\n\n    fn serialize_key<T: ?Sized + ser::Serialize>(&mut self, _: &T) -> Result<(), Self::Error> {\n        Ok(())\n    }\n\n    fn serialize_value<T: ?Sized + ser::Serialize>(&mut self, _: &T) -> Result<(), Self::Error> {\n        Ok(())\n    }\n\n    fn end(self) -> Result<Self::Ok, Self::Error> {\n        Ok(Category::Table)\n    }\n}\n\nimpl<E: ser::Error> ser::SerializeStruct for Categorize<E> {\n    type Ok = Category;\n    type Error = E;\n\n    fn serialize_field<T: ?Sized>(&mut self, _: &'static str, _: &T) -> Result<(), Self::Error>\n    where\n        T: ser::Serialize,\n    {\n        Ok(())\n    }\n\n    fn end(self) -> Result<Self::Ok, Self::Error> {\n        Ok(Category::Table)\n    }\n}\n","traces":[{"line":87,"address":[5053744,5053799],"length":1,"stats":{"Line":0},"fn_name":"to_string<toml::value::Value>"},{"line":91,"address":[5053762],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[5053874,5053814,5054102,5054051],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[5054120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[5000368],"length":1,"stats":{"Line":0},"fn_name":"pretty"},{"line":177,"address":[5000400],"length":1,"stats":{"Line":0},"fn_name":"pretty"},{"line":251,"address":[5000416],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":255,"address":[5000437],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[5000560],"length":1,"stats":{"Line":0},"fn_name":"pretty"},{"line":271,"address":[5000662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[5000784],"length":1,"stats":{"Line":0},"fn_name":"pretty_string"},{"line":302,"address":[5000844,5000818,5000802],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[5000820],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[5000813],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[5000912],"length":1,"stats":{"Line":0},"fn_name":"pretty_string_literal"},{"line":337,"address":[5001031,5000930],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[5001053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[5001064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[5001026],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[5001069],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[5001076],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[5001091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[5001097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[5001184],"length":1,"stats":{"Line":0},"fn_name":"pretty_array"},{"line":380,"address":[5001218,5001202,5001260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[5001220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[5001213],"length":1,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[5001344],"length":1,"stats":{"Line":0},"fn_name":"pretty_array_indent"},{"line":392,"address":[5001458,5001358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[5001480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[5001483],"length":1,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[5001453],"length":1,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[5001488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[5001495],"length":1,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[5001514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[5001519],"length":1,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[5001632],"length":1,"stats":{"Line":0},"fn_name":"pretty_array_trailing_comma"},{"line":411,"address":[5001751,5001650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[5001767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[5001778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[5001746],"length":1,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[5001783],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[5001790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[5001808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[5001814],"length":1,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[5060959,5058479,5060064,5055999,5055920,5055179,5061712,5061787,5054350,5058400,5057655,5060137,5059232,5056825,5054272,5055104,5059311,5057568,5056752,5060880],"length":1,"stats":{"Line":0},"fn_name":"display<bool>"},{"line":427,"address":[5060974,5057004,5058658,5055217,5060101,5055194,5061802,5061825,5058494,5060997,5054388,5055138,5054365,5061746,5057611,5061966,5057837,5054309,5059490,5056178,5056037,5058438,5057670,5059270,5060152,5056789,5060175,5054529,5056840,5061138,5056014,5058517,5060316,5060918,5057696,5059326,5055358,5055958,5059349,5056863],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[5055389,5058689,5061169,5061997,5054560,5060347,5059521,5057868,5056209,5057035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[5056625,5057451,5061619,5059937,5058284,5055805,5059971,5062413,5057485,5055839,5060797,5055010,5056659,5054976,5059139,5060763,5061585,5062447,5059105,5058318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[5056637,5060775,5057463,5058296,5059949,5061597,5062425,5059117,5054988,5055817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[5061626,5056666,5057492,5062454,5055017,5060804,5059146,5059978,5058325,5055846],"length":1,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[5002028,5001920],"length":1,"stats":{"Line":0},"fn_name":"emit_key"},{"line":436,"address":[5001950,5002144,5002043],"length":1,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[5002175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[5002207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[5002336,5002256],"length":1,"stats":{"Line":0},"fn_name":"_emit_key"},{"line":443,"address":[5002454,5002915,5002468,5003514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[5002282,5002461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[5002478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[5002490],"length":1,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[5002502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[5002514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[5002543,5002613],"length":1,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[5002647,5002883,5002601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[5002857,5002656],"length":1,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[5002910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[5002356],"length":1,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[5002368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[5002380],"length":1,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[5002392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[5002921,5002421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[5002944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[5002932,5003253,5003017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[5003026],"length":1,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[5003247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[5003255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[5003486],"length":1,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[5003507],"length":1,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[5003584],"length":1,"stats":{"Line":0},"fn_name":"emit_array"},{"line":478,"address":[5003626,5004121,5003821,5003910,5003712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[5003732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[5003828,5003906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[5003890],"length":1,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[5003860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[5003786],"length":1,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[5003983,5003919,5003809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[5003967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[5003937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[5003992,5004123,5004177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[5004161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[5004184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[5004208],"length":1,"stats":{"Line":0},"fn_name":"array_type"},{"line":501,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[5004229,5004274],"length":1,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[5004260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[5004369,5004318,5004288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[5004347],"length":1,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[5004376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[5004400,5004476],"length":1,"stats":{"Line":0},"fn_name":"escape_key"},{"line":512,"address":[5004428,5004491],"length":1,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[5062541,5062628],"length":1,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[5062621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[5005158,5004522,5004962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[5004579,5004936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[5004967,5004528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[5005165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[5005232,5006159],"length":1,"stats":{"Line":0},"fn_name":"emit_str"},{"line":539,"address":[5007952,5008016],"length":1,"stats":{"Line":0},"fn_name":"do_pretty"},{"line":549,"address":[5009156,5008036,5007983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[5008078],"length":1,"stats":{"Line":0},"fn_name":null},{"line":552,"address":[5008083],"length":1,"stats":{"Line":0},"fn_name":null},{"line":553,"address":[5008091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[5008102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[5008120,5008286,5008640,5008189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[5008638,5008316,5008617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":558,"address":[5008345,5008424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":559,"address":[5009206,5008370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[5008406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[5008416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":564,"address":[5008355],"length":1,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[5008426],"length":1,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[5008437],"length":1,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[5008502,5008594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":570,"address":[5008448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":571,"address":[5008483],"length":1,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[5008504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[5008598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[5008326],"length":1,"stats":{"Line":0},"fn_name":null},{"line":582,"address":[5008619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":586,"address":[5008267,5008645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":588,"address":[5008761],"length":1,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[5008769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[5008862,5008797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":592,"address":[5008908,5008834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":594,"address":[5008782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[5008910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":597,"address":[5008958,5008921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":598,"address":[5008935,5008991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[5009042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":602,"address":[5009061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[5007796,5005414,5005501,5005281],"length":1,"stats":{"Line":0},"fn_name":null},{"line":606,"address":[5005876,5005514,5005951,5005567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":607,"address":[5005881,5005702],"length":1,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[5005936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":610,"address":[5005740],"length":1,"stats":{"Line":0},"fn_name":null},{"line":613,"address":[5005471],"length":1,"stats":{"Line":0},"fn_name":null},{"line":615,"address":[5007758,5006382,5006013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[5006015,5005956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":618,"address":[5006157,5006125,5006220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":619,"address":[5006061,5006135],"length":1,"stats":{"Line":0},"fn_name":null},{"line":620,"address":[5006198],"length":1,"stats":{"Line":0},"fn_name":null},{"line":621,"address":[5006110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":623,"address":[5006232],"length":1,"stats":{"Line":0},"fn_name":null},{"line":624,"address":[5006359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":625,"address":[5006344,5006290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":626,"address":[5006314],"length":1,"stats":{"Line":0},"fn_name":null},{"line":629,"address":[5006363,5005973,5006174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":630,"address":[5006444,5006387,5006419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":631,"address":[5006397,5005987],"length":1,"stats":{"Line":0},"fn_name":null},{"line":635,"address":[5006429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":637,"address":[5007694,5006462,5006619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":638,"address":[5007094,5006788,5006823,5007024,5007690,5006989,5007059],"length":1,"stats":{"Line":0},"fn_name":null},{"line":639,"address":[5006649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":640,"address":[5006801],"length":1,"stats":{"Line":0},"fn_name":null},{"line":641,"address":[5006919,5006954],"length":1,"stats":{"Line":0},"fn_name":null},{"line":642,"address":[5006904,5006828],"length":1,"stats":{"Line":0},"fn_name":null},{"line":643,"address":[5006932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":646,"address":[5006967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":647,"address":[5007002],"length":1,"stats":{"Line":0},"fn_name":null},{"line":648,"address":[5007037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":649,"address":[5007072],"length":1,"stats":{"Line":0},"fn_name":null},{"line":650,"address":[5007099],"length":1,"stats":{"Line":0},"fn_name":null},{"line":651,"address":[5007332,5007661,5007189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":653,"address":[5007290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":656,"address":[5007699,5007731,5007756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":657,"address":[5006593,5007709],"length":1,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[5007741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":662,"address":[5007768],"length":1,"stats":{"Line":0},"fn_name":null},{"line":665,"address":[5009326,5009248],"length":1,"stats":{"Line":0},"fn_name":"emit_table_header"},{"line":666,"address":[5009346],"length":1,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[5009375,5009274,5009353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":668,"address":[5009377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":669,"address":[5009341],"length":1,"stats":{"Line":0},"fn_name":null},{"line":674,"address":[5009387],"length":1,"stats":{"Line":0},"fn_name":null},{"line":675,"address":[5009392,5009465],"length":1,"stats":{"Line":0},"fn_name":null},{"line":676,"address":[5009427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":677,"address":[5009460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":680,"address":[5009467,5009513,5009611],"length":1,"stats":{"Line":0},"fn_name":null},{"line":681,"address":[5009558],"length":1,"stats":{"Line":0},"fn_name":null},{"line":682,"address":[5009563],"length":1,"stats":{"Line":0},"fn_name":null},{"line":683,"address":[5009604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":685,"address":[5009596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":686,"address":[5009618],"length":1,"stats":{"Line":0},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":690,"address":[5009628],"length":1,"stats":{"Line":0},"fn_name":null},{"line":691,"address":[5009830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":695,"address":[5010056,5009897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":696,"address":[5009840,5009474],"length":1,"stats":{"Line":0},"fn_name":null},{"line":697,"address":[5009852,5009895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":700,"address":[5009882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":703,"address":[5009907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":704,"address":[5009931,5009990],"length":1,"stats":{"Line":0},"fn_name":null},{"line":707,"address":[5009977],"length":1,"stats":{"Line":0},"fn_name":null},{"line":708,"address":[5010054,5009964,5009997],"length":1,"stats":{"Line":0},"fn_name":null},{"line":709,"address":[5010009,5010052],"length":1,"stats":{"Line":0},"fn_name":null},{"line":711,"address":[5010039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":715,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":717,"address":[5010070],"length":1,"stats":{"Line":0},"fn_name":null},{"line":718,"address":[5010121,5010086],"length":1,"stats":{"Line":0},"fn_name":null},{"line":719,"address":[5010105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":721,"address":[5010123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":722,"address":[5010346,5010381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":723,"address":[5010365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":725,"address":[5010395],"length":1,"stats":{"Line":0},"fn_name":null},{"line":726,"address":[5010416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":729,"address":[5010480,5010559],"length":1,"stats":{"Line":0},"fn_name":"emit_key_part"},{"line":730,"address":[5011219,5010696,5010659,5010713],"length":1,"stats":{"Line":0},"fn_name":null},{"line":731,"address":[5010666,5010506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":733,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":734,"address":[5010579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":735,"address":[5010603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":736,"address":[5010615],"length":1,"stats":{"Line":0},"fn_name":null},{"line":737,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":738,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":739,"address":[5010627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":740,"address":[5010920,5010718],"length":1,"stats":{"Line":0},"fn_name":null},{"line":741,"address":[5010986,5010950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":742,"address":[5010970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":744,"address":[5010988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":783,"address":[5011264],"length":1,"stats":{"Line":0},"fn_name":"serialize_bool"},{"line":784,"address":[5011285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":787,"address":[5011344],"length":1,"stats":{"Line":0},"fn_name":"serialize_i8"},{"line":788,"address":[5011360],"length":1,"stats":{"Line":0},"fn_name":null},{"line":791,"address":[5011408],"length":1,"stats":{"Line":0},"fn_name":"serialize_i16"},{"line":792,"address":[5011425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":795,"address":[5011472],"length":1,"stats":{"Line":0},"fn_name":"serialize_i32"},{"line":796,"address":[5011488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":799,"address":[5011536],"length":1,"stats":{"Line":0},"fn_name":"serialize_i64"},{"line":800,"address":[5011553],"length":1,"stats":{"Line":0},"fn_name":null},{"line":803,"address":[5011600],"length":1,"stats":{"Line":0},"fn_name":"serialize_u8"},{"line":804,"address":[5011616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":807,"address":[5011664],"length":1,"stats":{"Line":0},"fn_name":"serialize_u16"},{"line":808,"address":[5011681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":811,"address":[5011728],"length":1,"stats":{"Line":0},"fn_name":"serialize_u32"},{"line":812,"address":[5011744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":815,"address":[5011792],"length":1,"stats":{"Line":0},"fn_name":"serialize_u64"},{"line":816,"address":[5011809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":819,"address":[5011856,5011937],"length":1,"stats":{"Line":0},"fn_name":"serialize_f32"},{"line":820,"address":[5011952,5011883,5012127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":823,"address":[5013959,5013872],"length":1,"stats":{"Line":0},"fn_name":"serialize_f64"},{"line":824,"address":[5014149,5013899,5013974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":827,"address":[5015936],"length":1,"stats":{"Line":0},"fn_name":"serialize_char"},{"line":828,"address":[5015965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":829,"address":[5016018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":832,"address":[5016174,5016080],"length":1,"stats":{"Line":0},"fn_name":"serialize_str"},{"line":833,"address":[5016336,5016114,5016189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":834,"address":[5016365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":835,"address":[5016589,5016624],"length":1,"stats":{"Line":0},"fn_name":null},{"line":836,"address":[5016608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":838,"address":[5016631],"length":1,"stats":{"Line":0},"fn_name":null},{"line":841,"address":[5016688],"length":1,"stats":{"Line":0},"fn_name":"serialize_bytes"},{"line":843,"address":[5016715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":846,"address":[5016752],"length":1,"stats":{"Line":0},"fn_name":"serialize_none"},{"line":847,"address":[5016764],"length":1,"stats":{"Line":0},"fn_name":null},{"line":854,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":857,"address":[5016816],"length":1,"stats":{"Line":0},"fn_name":"serialize_unit"},{"line":858,"address":[5016828],"length":1,"stats":{"Line":0},"fn_name":null},{"line":861,"address":[5016880],"length":1,"stats":{"Line":0},"fn_name":"serialize_unit_struct"},{"line":862,"address":[5016902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":865,"address":[5016960],"length":1,"stats":{"Line":0},"fn_name":"serialize_unit_variant"},{"line":871,"address":[5017002],"length":1,"stats":{"Line":0},"fn_name":null},{"line":874,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":882,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":885,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":895,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":898,"address":[5017040,5017172],"length":1,"stats":{"Line":0},"fn_name":"serialize_seq"},{"line":899,"address":[5017300,5017074,5017187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":900,"address":[5017372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":901,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":902,"address":[5017326],"length":1,"stats":{"Line":0},"fn_name":null},{"line":903,"address":[5017341],"length":1,"stats":{"Line":0},"fn_name":null},{"line":904,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":908,"address":[5017520],"length":1,"stats":{"Line":0},"fn_name":"serialize_tuple"},{"line":909,"address":[5017537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":912,"address":[5017584],"length":1,"stats":{"Line":0},"fn_name":"serialize_tuple_struct"},{"line":917,"address":[5017611],"length":1,"stats":{"Line":0},"fn_name":null},{"line":920,"address":[5017664],"length":1,"stats":{"Line":0},"fn_name":"serialize_tuple_variant"},{"line":927,"address":[5017711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":930,"address":[5017842,5017760],"length":1,"stats":{"Line":0},"fn_name":"serialize_map"},{"line":931,"address":[5017857,5018005,5017794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":932,"address":[5018105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":933,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":934,"address":[5018031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":935,"address":[5018044],"length":1,"stats":{"Line":0},"fn_name":null},{"line":936,"address":[5018064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":940,"address":[5018369,5018288],"length":1,"stats":{"Line":0},"fn_name":"serialize_struct"},{"line":945,"address":[5018388,5018718,5018324],"length":1,"stats":{"Line":0},"fn_name":null},{"line":946,"address":[5018437,5018623],"length":1,"stats":{"Line":0},"fn_name":null},{"line":947,"address":[5018654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":949,"address":[5018394,5018723],"length":1,"stats":{"Line":0},"fn_name":null},{"line":950,"address":[5018988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":951,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":952,"address":[5018914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":953,"address":[5018927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":954,"address":[5018947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":959,"address":[5019200],"length":1,"stats":{"Line":0},"fn_name":"serialize_struct_variant"},{"line":966,"address":[5019247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":974,"address":[5062656,5063296,5063470,5062830],"length":1,"stats":{"Line":0},"fn_name":"serialize_element<&toml::value::Value>"},{"line":978,"address":[5063490,5063697,5062850,5062992,5063057,5063632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":979,"address":[5063323,5062683],"length":1,"stats":{"Line":0},"fn_name":null},{"line":980,"address":[5063367,5062727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":981,"address":[5062689,5063329],"length":1,"stats":{"Line":0},"fn_name":null},{"line":982,"address":[5062699,5063339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":983,"address":[5062709,5063349],"length":1,"stats":{"Line":0},"fn_name":null},{"line":984,"address":[5062719,5063359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":986,"address":[5062779,5063419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":988,"address":[5063219,5063859],"length":1,"stats":{"Line":0},"fn_name":null},{"line":989,"address":[5063239,5063879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":992,"address":[5019838,5019296],"length":1,"stats":{"Line":0},"fn_name":"end"},{"line":993,"address":[5020013,5019409,5019306,5019713],"length":1,"stats":{"Line":0},"fn_name":null},{"line":994,"address":[5019416,5019344,5019393,5019438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":995,"address":[5019612,5019445,5019645,5019517,5019711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":996,"address":[5019537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":997,"address":[5019626],"length":1,"stats":{"Line":0},"fn_name":null},{"line":999,"address":[5019591],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1000,"address":[5019678,5019604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1001,"address":[5019659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1003,"address":[5019692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1006,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1007,"address":[5019769,5019722,5019369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1008,"address":[5019799,5019853,5019733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1009,"address":[5019994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1012,"address":[5020020,5020061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1013,"address":[5020042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1015,"address":[5020068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1027,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1030,"address":[5020112],"length":1,"stats":{"Line":0},"fn_name":"end"},{"line":1031,"address":[5020119],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1043,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1046,"address":[5020192],"length":1,"stats":{"Line":0},"fn_name":"end"},{"line":1047,"address":[5020199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1059,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1062,"address":[5020272],"length":1,"stats":{"Line":0},"fn_name":"end"},{"line":1063,"address":[5020279],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1071,"address":[5063936,5064113],"length":1,"stats":{"Line":0},"fn_name":"serialize_key<alloc::string::String>"},{"line":1075,"address":[5064035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1076,"address":[5063962,5064037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1077,"address":[5064005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1078,"address":[5064020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1079,"address":[5064299,5064067,5064128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1082,"address":[5064397],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1085,"address":[5064514,5064448],"length":1,"stats":{"Line":0},"fn_name":"serialize_value<toml::value::Value>"},{"line":1089,"address":[5064660],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1090,"address":[5064662,5064474],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1091,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1092,"address":[5064534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1093,"address":[5064553],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1094,"address":[5064573],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1095,"address":[5064593],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1096,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1097,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1098,"address":[5064808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1099,"address":[5064613],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1100,"address":[5064712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1101,"address":[5064620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1102,"address":[5064697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1106,"address":[5064779],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1108,"address":[5065215,5065195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1109,"address":[5065197,5064985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1110,"address":[5065010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1111,"address":[5065022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1115,"address":[5065246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1118,"address":[5020352,5020391],"length":1,"stats":{"Line":0},"fn_name":"end"},{"line":1119,"address":[5020455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1120,"address":[5020362,5020457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1121,"address":[5020411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1122,"address":[5020430,5020770,5020494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1123,"address":[5020508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1124,"address":[5020723,5020545],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1128,"address":[5020777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1136,"address":[5065372,5065296],"length":1,"stats":{"Line":0},"fn_name":"serialize_field<alloc::string::String>"},{"line":1140,"address":[5066388,5065570,5065931],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1141,"address":[5065332,5065577],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1142,"address":[5065591],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1143,"address":[5065903,5065702],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1145,"address":[5065628],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1149,"address":[5065392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1150,"address":[5065411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1151,"address":[5065430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1154,"address":[5065941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1155,"address":[5065450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1156,"address":[5065478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1157,"address":[5065457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1158,"address":[5065467],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1162,"address":[5065530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1164,"address":[5066372,5066352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1165,"address":[5066354,5066124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1166,"address":[5066152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1167,"address":[5066167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1171,"address":[5066395],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1174,"address":[5020960,5021003],"length":1,"stats":{"Line":0},"fn_name":"end"},{"line":1175,"address":[5021351,5021067],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1176,"address":[5020970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1177,"address":[5021023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1178,"address":[5021073,5021042,5021349],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1179,"address":[5021087],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1180,"address":[5021302,5021124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1184,"address":[5021358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1201,"address":[5021536],"length":1,"stats":{"Line":0},"fn_name":"serialize_bool"},{"line":1202,"address":[5021555],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1205,"address":[5021616],"length":1,"stats":{"Line":0},"fn_name":"serialize_i8"},{"line":1206,"address":[5021632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1209,"address":[5021680],"length":1,"stats":{"Line":0},"fn_name":"serialize_i16"},{"line":1210,"address":[5021697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1213,"address":[5021744],"length":1,"stats":{"Line":0},"fn_name":"serialize_i32"},{"line":1214,"address":[5021760],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1217,"address":[5021808],"length":1,"stats":{"Line":0},"fn_name":"serialize_i64"},{"line":1218,"address":[5021825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1221,"address":[5021872],"length":1,"stats":{"Line":0},"fn_name":"serialize_u8"},{"line":1222,"address":[5021888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1225,"address":[5021936],"length":1,"stats":{"Line":0},"fn_name":"serialize_u16"},{"line":1226,"address":[5021953],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1229,"address":[5022000],"length":1,"stats":{"Line":0},"fn_name":"serialize_u32"},{"line":1230,"address":[5022016],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1233,"address":[5022064],"length":1,"stats":{"Line":0},"fn_name":"serialize_u64"},{"line":1234,"address":[5022081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1237,"address":[5022128],"length":1,"stats":{"Line":0},"fn_name":"serialize_f32"},{"line":1238,"address":[5022146],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1241,"address":[5022208],"length":1,"stats":{"Line":0},"fn_name":"serialize_f64"},{"line":1242,"address":[5022226],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1245,"address":[5022288],"length":1,"stats":{"Line":0},"fn_name":"serialize_char"},{"line":1246,"address":[5022304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1249,"address":[5022466,5022352],"length":1,"stats":{"Line":0},"fn_name":"serialize_str"},{"line":1250,"address":[5022582,5022481,5022386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1251,"address":[5022613],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1254,"address":[5022656],"length":1,"stats":{"Line":0},"fn_name":"serialize_bytes"},{"line":1255,"address":[5022678],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1258,"address":[5022736],"length":1,"stats":{"Line":0},"fn_name":"serialize_none"},{"line":1259,"address":[5022748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1269,"address":[5022800],"length":1,"stats":{"Line":0},"fn_name":"serialize_unit"},{"line":1270,"address":[5022812],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1273,"address":[5022864],"length":1,"stats":{"Line":0},"fn_name":"serialize_unit_struct"},{"line":1274,"address":[5022886],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1277,"address":[5022944],"length":1,"stats":{"Line":0},"fn_name":"serialize_unit_variant"},{"line":1283,"address":[5022986],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1310,"address":[5023040],"length":1,"stats":{"Line":0},"fn_name":"serialize_seq"},{"line":1311,"address":[5023062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1314,"address":[5023120],"length":1,"stats":{"Line":0},"fn_name":"serialize_tuple"},{"line":1315,"address":[5023137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1318,"address":[5023184],"length":1,"stats":{"Line":0},"fn_name":"serialize_tuple_struct"},{"line":1323,"address":[5023211],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1326,"address":[5023264],"length":1,"stats":{"Line":0},"fn_name":"serialize_tuple_variant"},{"line":1333,"address":[5023311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1336,"address":[5023360],"length":1,"stats":{"Line":0},"fn_name":"serialize_map"},{"line":1337,"address":[5023382],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1340,"address":[5023440],"length":1,"stats":{"Line":0},"fn_name":"serialize_struct"},{"line":1345,"address":[5023467],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1348,"address":[5023520],"length":1,"stats":{"Line":0},"fn_name":"serialize_struct_variant"},{"line":1355,"address":[5023567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1372,"address":[5023616],"length":1,"stats":{"Line":0},"fn_name":"serialize_bool"},{"line":1373,"address":[5023632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1376,"address":[5023696],"length":1,"stats":{"Line":0},"fn_name":"serialize_i8"},{"line":1377,"address":[5023708],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1380,"address":[5023776],"length":1,"stats":{"Line":0},"fn_name":"serialize_i16"},{"line":1381,"address":[5023788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1384,"address":[5023856],"length":1,"stats":{"Line":0},"fn_name":"serialize_i32"},{"line":1385,"address":[5023867],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1388,"address":[5023936],"length":1,"stats":{"Line":0},"fn_name":"serialize_i64"},{"line":1389,"address":[5023948],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1392,"address":[5024016],"length":1,"stats":{"Line":0},"fn_name":"serialize_u8"},{"line":1393,"address":[5024028],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1396,"address":[5024096],"length":1,"stats":{"Line":0},"fn_name":"serialize_u16"},{"line":1397,"address":[5024108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1400,"address":[5024176],"length":1,"stats":{"Line":0},"fn_name":"serialize_u32"},{"line":1401,"address":[5024187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1404,"address":[5024256],"length":1,"stats":{"Line":0},"fn_name":"serialize_u64"},{"line":1405,"address":[5024268],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1408,"address":[5024336],"length":1,"stats":{"Line":0},"fn_name":"serialize_f32"},{"line":1409,"address":[5024349],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1412,"address":[5024416],"length":1,"stats":{"Line":0},"fn_name":"serialize_f64"},{"line":1413,"address":[5024429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1416,"address":[5024496],"length":1,"stats":{"Line":0},"fn_name":"serialize_char"},{"line":1417,"address":[5024507],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1420,"address":[5024576],"length":1,"stats":{"Line":0},"fn_name":"serialize_str"},{"line":1421,"address":[5024593],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1424,"address":[5024672],"length":1,"stats":{"Line":0},"fn_name":"serialize_bytes"},{"line":1425,"address":[5024689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1428,"address":[5024752],"length":1,"stats":{"Line":0},"fn_name":"serialize_none"},{"line":1429,"address":[5024759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1439,"address":[5024816],"length":1,"stats":{"Line":0},"fn_name":"serialize_unit"},{"line":1440,"address":[5024823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1443,"address":[5024880],"length":1,"stats":{"Line":0},"fn_name":"serialize_unit_struct"},{"line":1444,"address":[5024897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1447,"address":[5024960],"length":1,"stats":{"Line":0},"fn_name":"serialize_unit_variant"},{"line":1453,"address":[5024991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1456,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1464,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1480,"address":[5025056],"length":1,"stats":{"Line":0},"fn_name":"serialize_seq"},{"line":1481,"address":[5025073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1484,"address":[5025120],"length":1,"stats":{"Line":0},"fn_name":"serialize_tuple"},{"line":1485,"address":[5025132],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1488,"address":[5025184],"length":1,"stats":{"Line":0},"fn_name":"serialize_tuple_struct"},{"line":1493,"address":[5025206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1496,"address":[5025264],"length":1,"stats":{"Line":0},"fn_name":"serialize_tuple_variant"},{"line":1503,"address":[5025300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1506,"address":[5025360],"length":1,"stats":{"Line":0},"fn_name":"serialize_map"},{"line":1507,"address":[5025377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1510,"address":[5025424],"length":1,"stats":{"Line":0},"fn_name":"serialize_struct"},{"line":1515,"address":[5025446],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1518,"address":[5025504],"length":1,"stats":{"Line":0},"fn_name":"serialize_struct_variant"},{"line":1525,"address":[5025540],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1530,"address":[5025600],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":1531,"address":[5025789,5025715,5025900,5025681,5025937,5025863,5025752,5025826],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1532,"address":[5025614,5025690],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1533,"address":[5025727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1534,"address":[5025764],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1535,"address":[5025801],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1536,"address":[5025838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1537,"address":[5025875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1538,"address":[5025907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1541,"address":[5025651],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1549,"address":[5066480,5066521,5066608,5066658],"length":1,"stats":{"Line":0},"fn_name":"custom<core::fmt::Error>"},{"line":1550,"address":[5066625,5066487,5066670,5066533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1611,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1612,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1627,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1628,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1631,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1632,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1635,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1636,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1639,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1640,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1643,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1644,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1647,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1648,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1651,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1652,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1655,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1656,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1659,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1660,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1663,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1664,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1667,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1668,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1671,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1672,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1675,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1676,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1679,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1680,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1683,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1684,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1687,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1688,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1691,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1692,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1695,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1696,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1699,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1705,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1708,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1713,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1716,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1723,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1726,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1727,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1730,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1731,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1734,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1739,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1742,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1749,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1752,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1753,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1756,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1757,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1760,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1767,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1775,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1776,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1779,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1780,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1788,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1789,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1792,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1793,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1801,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1802,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1805,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1806,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1814,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1815,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1818,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1819,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1827,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1828,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1831,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1832,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1835,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1836,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1848,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1851,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1852,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":632},{"path":["/","usr","src","toml-rs","src","spanned.rs"],"content":"use serde::{de, ser};\nuse std::borrow::Borrow;\nuse std::cmp::Ordering;\nuse std::fmt;\nuse std::hash::{Hash, Hasher};\n\npub(crate) const NAME: &str = \"$__toml_private_Spanned\";\npub(crate) const START: &str = \"$__toml_private_start\";\npub(crate) const END: &str = \"$__toml_private_end\";\npub(crate) const VALUE: &str = \"$__toml_private_value\";\n\n/// A spanned value, indicating the range at which it is defined in the source.\n///\n/// ```\n/// use serde_derive::Deserialize;\n/// use toml::Spanned;\n///\n/// #[derive(Deserialize)]\n/// struct Value {\n///     s: Spanned<String>,\n/// }\n///\n/// fn main() {\n///     let t = \"s = \\\"value\\\"\\n\";\n///\n///     let u: Value = toml::from_str(t).unwrap();\n///\n///     assert_eq!(u.s.start(), 4);\n///     assert_eq!(u.s.end(), 11);\n///     assert_eq!(u.s.get_ref(), \"value\");\n///     assert_eq!(u.s.into_inner(), String::from(\"value\"));\n/// }\n/// ```\n#[derive(Clone, Debug)]\npub struct Spanned<T> {\n    /// The start range.\n    start: usize,\n    /// The end range (exclusive).\n    end: usize,\n    /// The spanned value.\n    value: T,\n}\n\nimpl<T> Spanned<T> {\n    /// Access the start of the span of the contained value.\n    pub fn start(&self) -> usize {\n        self.start\n    }\n\n    /// Access the end of the span of the contained value.\n    pub fn end(&self) -> usize {\n        self.end\n    }\n\n    /// Get the span of the contained value.\n    pub fn span(&self) -> (usize, usize) {\n        (self.start, self.end)\n    }\n\n    /// Consumes the spanned value and returns the contained value.\n    pub fn into_inner(self) -> T {\n        self.value\n    }\n\n    /// Returns a reference to the contained value.\n    pub fn get_ref(&self) -> &T {\n        &self.value\n    }\n\n    /// Returns a mutable reference to the contained value.\n    pub fn get_mut(&mut self) -> &mut T {\n        &mut self.value\n    }\n}\n\nimpl Borrow<str> for Spanned<String> {\n    fn borrow(&self) -> &str {\n        &self.get_ref()\n    }\n}\n\nimpl<T: PartialEq> PartialEq for Spanned<T> {\n    fn eq(&self, other: &Self) -> bool {\n        self.value.eq(&other.value)\n    }\n}\n\nimpl<T: Eq> Eq for Spanned<T> {}\n\nimpl<T: Hash> Hash for Spanned<T> {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        self.value.hash(state);\n    }\n}\n\nimpl<T: PartialOrd> PartialOrd for Spanned<T> {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        self.value.partial_cmp(&other.value)\n    }\n}\n\nimpl<T: Ord> Ord for Spanned<T> {\n    fn cmp(&self, other: &Self) -> Ordering {\n        self.value.cmp(&other.value)\n    }\n}\n\nimpl<'de, T> de::Deserialize<'de> for Spanned<T>\nwhere\n    T: de::Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Spanned<T>, D::Error>\n    where\n        D: de::Deserializer<'de>,\n    {\n        struct SpannedVisitor<T>(::std::marker::PhantomData<T>);\n\n        impl<'de, T> de::Visitor<'de> for SpannedVisitor<T>\n        where\n            T: de::Deserialize<'de>,\n        {\n            type Value = Spanned<T>;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n                formatter.write_str(\"a TOML spanned\")\n            }\n\n            fn visit_map<V>(self, mut visitor: V) -> Result<Spanned<T>, V::Error>\n            where\n                V: de::MapAccess<'de>,\n            {\n                if visitor.next_key()? != Some(START) {\n                    return Err(de::Error::custom(\"spanned start key not found\"));\n                }\n\n                let start: usize = visitor.next_value()?;\n\n                if visitor.next_key()? != Some(END) {\n                    return Err(de::Error::custom(\"spanned end key not found\"));\n                }\n\n                let end: usize = visitor.next_value()?;\n\n                if visitor.next_key()? != Some(VALUE) {\n                    return Err(de::Error::custom(\"spanned value key not found\"));\n                }\n\n                let value: T = visitor.next_value()?;\n\n                Ok(Spanned { start, end, value })\n            }\n        }\n\n        let visitor = SpannedVisitor(::std::marker::PhantomData);\n\n        static FIELDS: [&str; 3] = [START, END, VALUE];\n        deserializer.deserialize_struct(NAME, &FIELDS, visitor)\n    }\n}\n\nimpl<T: ser::Serialize> ser::Serialize for Spanned<T> {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: ser::Serializer,\n    {\n        self.value.serialize(serializer)\n    }\n}\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":41},{"path":["/","usr","src","toml-rs","src","tokens.rs"],"content":"use std::borrow::Cow;\nuse std::char;\nuse std::str;\nuse std::string;\nuse std::string::String as StdString;\n\nuse self::Token::*;\n\n/// A span, designating a range of bytes where a token is located.\n#[derive(Eq, PartialEq, Debug, Clone, Copy)]\npub struct Span {\n    /// The start of the range.\n    pub start: usize,\n    /// The end of the range (exclusive).\n    pub end: usize,\n}\n\nimpl From<Span> for (usize, usize) {\n    fn from(Span { start, end }: Span) -> (usize, usize) {\n        (start, end)\n    }\n}\n\n#[derive(Eq, PartialEq, Debug)]\npub enum Token<'a> {\n    Whitespace(&'a str),\n    Newline,\n    Comment(&'a str),\n\n    Equals,\n    Period,\n    Comma,\n    Colon,\n    Plus,\n    LeftBrace,\n    RightBrace,\n    LeftBracket,\n    RightBracket,\n\n    Keylike(&'a str),\n    String {\n        src: &'a str,\n        val: Cow<'a, str>,\n        multiline: bool,\n    },\n}\n\n#[derive(Eq, PartialEq, Debug)]\npub enum Error {\n    InvalidCharInString(usize, char),\n    InvalidEscape(usize, char),\n    InvalidHexEscape(usize, char),\n    InvalidEscapeValue(usize, u32),\n    NewlineInString(usize),\n    Unexpected(usize, char),\n    UnterminatedString(usize),\n    NewlineInTableKey(usize),\n    MultilineStringKey(usize),\n    EmptyTableKey(usize),\n    Wanted {\n        at: usize,\n        expected: &'static str,\n        found: &'static str,\n    },\n}\n\n#[derive(Clone)]\npub struct Tokenizer<'a> {\n    input: &'a str,\n    chars: CrlfFold<'a>,\n}\n\n#[derive(Clone)]\nstruct CrlfFold<'a> {\n    chars: str::CharIndices<'a>,\n}\n\n#[derive(Debug)]\nenum MaybeString {\n    NotEscaped(usize),\n    Owned(string::String),\n}\n\nimpl<'a> Tokenizer<'a> {\n    pub fn new(input: &'a str) -> Tokenizer<'a> {\n        let mut t = Tokenizer {\n            input,\n            chars: CrlfFold {\n                chars: input.char_indices(),\n            },\n        };\n        // Eat utf-8 BOM\n        t.eatc('\\u{feff}');\n        t\n    }\n\n    pub fn next(&mut self) -> Result<Option<(Span, Token<'a>)>, Error> {\n        let (start, token) = match self.one() {\n            Some((start, '\\n')) => (start, Newline),\n            Some((start, ' ')) => (start, self.whitespace_token(start)),\n            Some((start, '\\t')) => (start, self.whitespace_token(start)),\n            Some((start, '#')) => (start, self.comment_token(start)),\n            Some((start, '=')) => (start, Equals),\n            Some((start, '.')) => (start, Period),\n            Some((start, ',')) => (start, Comma),\n            Some((start, ':')) => (start, Colon),\n            Some((start, '+')) => (start, Plus),\n            Some((start, '{')) => (start, LeftBrace),\n            Some((start, '}')) => (start, RightBrace),\n            Some((start, '[')) => (start, LeftBracket),\n            Some((start, ']')) => (start, RightBracket),\n            Some((start, '\\'')) => {\n                return self\n                    .literal_string(start)\n                    .map(|t| Some((self.step_span(start), t)))\n            }\n            Some((start, '\"')) => {\n                return self\n                    .basic_string(start)\n                    .map(|t| Some((self.step_span(start), t)))\n            }\n            Some((start, ch)) if is_keylike(ch) => (start, self.keylike(start)),\n\n            Some((start, ch)) => return Err(Error::Unexpected(start, ch)),\n            None => return Ok(None),\n        };\n\n        let span = self.step_span(start);\n        Ok(Some((span, token)))\n    }\n\n    pub fn peek(&mut self) -> Result<Option<(Span, Token<'a>)>, Error> {\n        self.clone().next()\n    }\n\n    pub fn eat(&mut self, expected: Token<'a>) -> Result<bool, Error> {\n        self.eat_spanned(expected).map(|s| s.is_some())\n    }\n\n    /// Eat a value, returning it's span if it was consumed.\n    pub fn eat_spanned(&mut self, expected: Token<'a>) -> Result<Option<Span>, Error> {\n        let span = match self.peek()? {\n            Some((span, ref found)) if expected == *found => span,\n            Some(_) => return Ok(None),\n            None => return Ok(None),\n        };\n\n        drop(self.next());\n        Ok(Some(span))\n    }\n\n    pub fn expect(&mut self, expected: Token<'a>) -> Result<(), Error> {\n        // ignore span\n        let _ = self.expect_spanned(expected)?;\n        Ok(())\n    }\n\n    /// Expect the given token returning its span.\n    pub fn expect_spanned(&mut self, expected: Token<'a>) -> Result<Span, Error> {\n        let current = self.current();\n        match self.next()? {\n            Some((span, found)) => {\n                if expected == found {\n                    Ok(span)\n                } else {\n                    Err(Error::Wanted {\n                        at: current,\n                        expected: expected.describe(),\n                        found: found.describe(),\n                    })\n                }\n            }\n            None => Err(Error::Wanted {\n                at: self.input.len(),\n                expected: expected.describe(),\n                found: \"eof\",\n            }),\n        }\n    }\n\n    pub fn table_key(&mut self) -> Result<(Span, Cow<'a, str>), Error> {\n        let current = self.current();\n        match self.next()? {\n            Some((span, Token::Keylike(k))) => Ok((span, k.into())),\n            Some((\n                span,\n                Token::String {\n                    src,\n                    val,\n                    multiline,\n                },\n            )) => {\n                let offset = self.substr_offset(src);\n                if multiline {\n                    return Err(Error::MultilineStringKey(offset));\n                }\n                if val == \"\" {\n                    return Err(Error::EmptyTableKey(offset));\n                }\n                match src.find('\\n') {\n                    None => Ok((span, val)),\n                    Some(i) => Err(Error::NewlineInTableKey(offset + i)),\n                }\n            }\n            Some((_, other)) => Err(Error::Wanted {\n                at: current,\n                expected: \"a table key\",\n                found: other.describe(),\n            }),\n            None => Err(Error::Wanted {\n                at: self.input.len(),\n                expected: \"a table key\",\n                found: \"eof\",\n            }),\n        }\n    }\n\n    pub fn eat_whitespace(&mut self) -> Result<(), Error> {\n        while self.eatc(' ') || self.eatc('\\t') {\n            // ...\n        }\n        Ok(())\n    }\n\n    pub fn eat_comment(&mut self) -> Result<bool, Error> {\n        if !self.eatc('#') {\n            return Ok(false);\n        }\n        drop(self.comment_token(0));\n        self.eat_newline_or_eof().map(|()| true)\n    }\n\n    pub fn eat_newline_or_eof(&mut self) -> Result<(), Error> {\n        let current = self.current();\n        match self.next()? {\n            None | Some((_, Token::Newline)) => Ok(()),\n            Some((_, other)) => Err(Error::Wanted {\n                at: current,\n                expected: \"newline\",\n                found: other.describe(),\n            }),\n        }\n    }\n\n    pub fn skip_to_newline(&mut self) {\n        loop {\n            match self.one() {\n                Some((_, '\\n')) | None => break,\n                _ => {}\n            }\n        }\n    }\n\n    fn eatc(&mut self, ch: char) -> bool {\n        match self.chars.clone().next() {\n            Some((_, ch2)) if ch == ch2 => {\n                self.one();\n                true\n            }\n            _ => false,\n        }\n    }\n\n    pub fn current(&mut self) -> usize {\n        self.chars\n            .clone()\n            .next()\n            .map(|i| i.0)\n            .unwrap_or_else(|| self.input.len())\n    }\n\n    pub fn input(&self) -> &'a str {\n        self.input\n    }\n\n    fn whitespace_token(&mut self, start: usize) -> Token<'a> {\n        while self.eatc(' ') || self.eatc('\\t') {\n            // ...\n        }\n        Whitespace(&self.input[start..self.current()])\n    }\n\n    fn comment_token(&mut self, start: usize) -> Token<'a> {\n        while let Some((_, ch)) = self.chars.clone().next() {\n            if ch != '\\t' && (ch < '\\u{20}' || ch > '\\u{10ffff}') {\n                break;\n            }\n            self.one();\n        }\n        Comment(&self.input[start..self.current()])\n    }\n\n    fn read_string(\n        &mut self,\n        delim: char,\n        start: usize,\n        new_ch: &mut dyn FnMut(\n            &mut Tokenizer<'_>,\n            &mut MaybeString,\n            bool,\n            usize,\n            char,\n        ) -> Result<(), Error>,\n    ) -> Result<Token<'a>, Error> {\n        let mut multiline = false;\n        if self.eatc(delim) {\n            if self.eatc(delim) {\n                multiline = true;\n            } else {\n                return Ok(String {\n                    src: &self.input[start..start + 2],\n                    val: Cow::Borrowed(\"\"),\n                    multiline: false,\n                });\n            }\n        }\n        let mut val = MaybeString::NotEscaped(self.current());\n        let mut n = 0;\n        'outer: loop {\n            n += 1;\n            match self.one() {\n                Some((i, '\\n')) => {\n                    if multiline {\n                        if self.input.as_bytes()[i] == b'\\r' {\n                            val.to_owned(&self.input[..i]);\n                        }\n                        if n == 1 {\n                            val = MaybeString::NotEscaped(self.current());\n                        } else {\n                            val.push('\\n');\n                        }\n                        continue;\n                    } else {\n                        return Err(Error::NewlineInString(i));\n                    }\n                }\n                Some((mut i, ch)) if ch == delim => {\n                    if multiline {\n                        if !self.eatc(delim) {\n                            val.push(delim);\n                            continue 'outer;\n                        }\n                        if !self.eatc(delim) {\n                            val.push(delim);\n                            val.push(delim);\n                            continue 'outer;\n                        }\n                        if self.eatc(delim) {\n                            val.push(delim);\n                            i += 1;\n                        }\n                        if self.eatc(delim) {\n                            val.push(delim);\n                            i += 1;\n                        }\n                    }\n                    return Ok(String {\n                        src: &self.input[start..self.current()],\n                        val: val.into_cow(&self.input[..i]),\n                        multiline,\n                    });\n                }\n                Some((i, c)) => new_ch(self, &mut val, multiline, i, c)?,\n                None => return Err(Error::UnterminatedString(start)),\n            }\n        }\n    }\n\n    fn literal_string(&mut self, start: usize) -> Result<Token<'a>, Error> {\n        self.read_string('\\'', start, &mut |_me, val, _multi, i, ch| {\n            if ch == '\\u{09}' || ('\\u{20}' <= ch && ch <= '\\u{10ffff}' && ch != '\\u{7f}') {\n                val.push(ch);\n                Ok(())\n            } else {\n                Err(Error::InvalidCharInString(i, ch))\n            }\n        })\n    }\n\n    fn basic_string(&mut self, start: usize) -> Result<Token<'a>, Error> {\n        self.read_string('\"', start, &mut |me, val, multi, i, ch| match ch {\n            '\\\\' => {\n                val.to_owned(&me.input[..i]);\n                match me.chars.next() {\n                    Some((_, '\"')) => val.push('\"'),\n                    Some((_, '\\\\')) => val.push('\\\\'),\n                    Some((_, 'b')) => val.push('\\u{8}'),\n                    Some((_, 'f')) => val.push('\\u{c}'),\n                    Some((_, 'n')) => val.push('\\n'),\n                    Some((_, 'r')) => val.push('\\r'),\n                    Some((_, 't')) => val.push('\\t'),\n                    Some((i, c @ 'u')) | Some((i, c @ 'U')) => {\n                        let len = if c == 'u' { 4 } else { 8 };\n                        val.push(me.hex(start, i, len)?);\n                    }\n                    Some((i, c @ ' ')) | Some((i, c @ '\\t')) | Some((i, c @ '\\n')) if multi => {\n                        if c != '\\n' {\n                            while let Some((_, ch)) = me.chars.clone().next() {\n                                match ch {\n                                    ' ' | '\\t' => {\n                                        me.chars.next();\n                                        continue;\n                                    }\n                                    '\\n' => {\n                                        me.chars.next();\n                                        break;\n                                    }\n                                    _ => return Err(Error::InvalidEscape(i, c)),\n                                }\n                            }\n                        }\n                        while let Some((_, ch)) = me.chars.clone().next() {\n                            match ch {\n                                ' ' | '\\t' | '\\n' => {\n                                    me.chars.next();\n                                }\n                                _ => break,\n                            }\n                        }\n                    }\n                    Some((i, c)) => return Err(Error::InvalidEscape(i, c)),\n                    None => return Err(Error::UnterminatedString(start)),\n                }\n                Ok(())\n            }\n            ch if ch == '\\u{09}' || ('\\u{20}' <= ch && ch <= '\\u{10ffff}' && ch != '\\u{7f}') => {\n                val.push(ch);\n                Ok(())\n            }\n            _ => Err(Error::InvalidCharInString(i, ch)),\n        })\n    }\n\n    fn hex(&mut self, start: usize, i: usize, len: usize) -> Result<char, Error> {\n        let mut buf = StdString::with_capacity(len);\n        for _ in 0..len {\n            match self.one() {\n                Some((_, ch)) if ch as u32 <= 0x7F && ch.is_digit(16) => buf.push(ch),\n                Some((i, ch)) => return Err(Error::InvalidHexEscape(i, ch)),\n                None => return Err(Error::UnterminatedString(start)),\n            }\n        }\n        let val = u32::from_str_radix(&buf, 16).unwrap();\n        match char::from_u32(val) {\n            Some(ch) => Ok(ch),\n            None => Err(Error::InvalidEscapeValue(i, val)),\n        }\n    }\n\n    fn keylike(&mut self, start: usize) -> Token<'a> {\n        while let Some((_, ch)) = self.peek_one() {\n            if !is_keylike(ch) {\n                break;\n            }\n            self.one();\n        }\n        Keylike(&self.input[start..self.current()])\n    }\n\n    pub fn substr_offset(&self, s: &'a str) -> usize {\n        assert!(s.len() <= self.input.len());\n        let a = self.input.as_ptr() as usize;\n        let b = s.as_ptr() as usize;\n        assert!(a <= b);\n        b - a\n    }\n\n    /// Calculate the span of a single character.\n    fn step_span(&mut self, start: usize) -> Span {\n        let end = self\n            .peek_one()\n            .map(|t| t.0)\n            .unwrap_or_else(|| self.input.len());\n        Span { start, end }\n    }\n\n    /// Peek one char without consuming it.\n    fn peek_one(&mut self) -> Option<(usize, char)> {\n        self.chars.clone().next()\n    }\n\n    /// Take one char.\n    pub fn one(&mut self) -> Option<(usize, char)> {\n        self.chars.next()\n    }\n}\n\nimpl<'a> Iterator for CrlfFold<'a> {\n    type Item = (usize, char);\n\n    fn next(&mut self) -> Option<(usize, char)> {\n        self.chars.next().map(|(i, c)| {\n            if c == '\\r' {\n                let mut attempt = self.chars.clone();\n                if let Some((_, '\\n')) = attempt.next() {\n                    self.chars = attempt;\n                    return (i, '\\n');\n                }\n            }\n            (i, c)\n        })\n    }\n}\n\nimpl MaybeString {\n    fn push(&mut self, ch: char) {\n        match *self {\n            MaybeString::NotEscaped(..) => {}\n            MaybeString::Owned(ref mut s) => s.push(ch),\n        }\n    }\n\n    fn to_owned(&mut self, input: &str) {\n        match *self {\n            MaybeString::NotEscaped(start) => {\n                *self = MaybeString::Owned(input[start..].to_owned());\n            }\n            MaybeString::Owned(..) => {}\n        }\n    }\n\n    fn into_cow(self, input: &str) -> Cow<'_, str> {\n        match self {\n            MaybeString::NotEscaped(start) => Cow::Borrowed(&input[start..]),\n            MaybeString::Owned(s) => Cow::Owned(s),\n        }\n    }\n}\n\nfn is_keylike(ch: char) -> bool {\n    ('A' <= ch && ch <= 'Z')\n        || ('a' <= ch && ch <= 'z')\n        || ('0' <= ch && ch <= '9')\n        || ch == '-'\n        || ch == '_'\n}\n\nimpl<'a> Token<'a> {\n    pub fn describe(&self) -> &'static str {\n        match *self {\n            Token::Keylike(_) => \"an identifier\",\n            Token::Equals => \"an equals\",\n            Token::Period => \"a period\",\n            Token::Comment(_) => \"a comment\",\n            Token::Newline => \"a newline\",\n            Token::Whitespace(_) => \"whitespace\",\n            Token::Comma => \"a comma\",\n            Token::RightBrace => \"a right brace\",\n            Token::LeftBrace => \"a left brace\",\n            Token::RightBracket => \"a right bracket\",\n            Token::LeftBracket => \"a left bracket\",\n            Token::String { multiline, .. } => {\n                if multiline {\n                    \"a multiline string\"\n                } else {\n                    \"a string\"\n                }\n            }\n            Token::Colon => \"a colon\",\n            Token::Plus => \"a plus\",\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{Error, Token, Tokenizer};\n    use std::borrow::Cow;\n\n    fn err(input: &str, err: Error) {\n        let mut t = Tokenizer::new(input);\n        let token = t.next().unwrap_err();\n        assert_eq!(token, err);\n        assert!(t.next().unwrap().is_none());\n    }\n\n    #[test]\n    fn literal_strings() {\n        fn t(input: &str, val: &str, multiline: bool) {\n            let mut t = Tokenizer::new(input);\n            let (_, token) = t.next().unwrap().unwrap();\n            assert_eq!(\n                token,\n                Token::String {\n                    src: input,\n                    val: Cow::Borrowed(val),\n                    multiline: multiline,\n                }\n            );\n            assert!(t.next().unwrap().is_none());\n        }\n\n        t(\"''\", \"\", false);\n        t(\"''''''\", \"\", true);\n        t(\"'''\\n'''\", \"\", true);\n        t(\"'a'\", \"a\", false);\n        t(\"'\\\"a'\", \"\\\"a\", false);\n        t(\"''''a'''\", \"'a\", true);\n        t(\"'''\\n'a\\n'''\", \"'a\\n\", true);\n        t(\"'''a\\n'a\\r\\n'''\", \"a\\n'a\\n\", true);\n    }\n\n    #[test]\n    fn basic_strings() {\n        fn t(input: &str, val: &str, multiline: bool) {\n            let mut t = Tokenizer::new(input);\n            let (_, token) = t.next().unwrap().unwrap();\n            assert_eq!(\n                token,\n                Token::String {\n                    src: input,\n                    val: Cow::Borrowed(val),\n                    multiline: multiline,\n                }\n            );\n            assert!(t.next().unwrap().is_none());\n        }\n\n        t(r#\"\"\"\"#, \"\", false);\n        t(r#\"\"\"\"\"\"\"\"#, \"\", true);\n        t(r#\"\"a\"\"#, \"a\", false);\n        t(r#\"\"\"\"a\"\"\"\"#, \"a\", true);\n        t(r#\"\"\\t\"\"#, \"\\t\", false);\n        t(r#\"\"\\u0000\"\"#, \"\\0\", false);\n        t(r#\"\"\\U00000000\"\"#, \"\\0\", false);\n        t(r#\"\"\\U000A0000\"\"#, \"\\u{A0000}\", false);\n        t(r#\"\"\\\\t\"\"#, \"\\\\t\", false);\n        t(\"\\\"\\t\\\"\", \"\\t\", false);\n        t(\"\\\"\\\"\\\"\\n\\t\\\"\\\"\\\"\", \"\\t\", true);\n        t(\"\\\"\\\"\\\"\\\\\\n\\\"\\\"\\\"\", \"\", true);\n        t(\n            \"\\\"\\\"\\\"\\\\\\n     \\t   \\t  \\\\\\r\\n  \\t \\n  \\t \\r\\n\\\"\\\"\\\"\",\n            \"\",\n            true,\n        );\n        t(r#\"\"\\r\"\"#, \"\\r\", false);\n        t(r#\"\"\\n\"\"#, \"\\n\", false);\n        t(r#\"\"\\b\"\"#, \"\\u{8}\", false);\n        t(r#\"\"a\\fa\"\"#, \"a\\u{c}a\", false);\n        t(r#\"\"\\\"a\"\"#, \"\\\"a\", false);\n        t(\"\\\"\\\"\\\"\\na\\\"\\\"\\\"\", \"a\", true);\n        t(\"\\\"\\\"\\\"\\n\\\"\\\"\\\"\", \"\", true);\n        t(r#\"\"\"\"a\\\"\"\"b\"\"\"\"#, \"a\\\"\\\"\\\"b\", true);\n        err(r#\"\"\\a\"#, Error::InvalidEscape(2, 'a'));\n        err(\"\\\"\\\\\\n\", Error::InvalidEscape(2, '\\n'));\n        err(\"\\\"\\\\\\r\\n\", Error::InvalidEscape(2, '\\n'));\n        err(\"\\\"\\\\\", Error::UnterminatedString(0));\n        err(\"\\\"\\u{0}\", Error::InvalidCharInString(1, '\\u{0}'));\n        err(r#\"\"\\U00\"\"#, Error::InvalidHexEscape(5, '\"'));\n        err(r#\"\"\\U00\"#, Error::UnterminatedString(0));\n        err(r#\"\"\\uD800\"#, Error::InvalidEscapeValue(2, 0xd800));\n        err(r#\"\"\\UFFFFFFFF\"#, Error::InvalidEscapeValue(2, 0xffff_ffff));\n    }\n\n    #[test]\n    fn keylike() {\n        fn t(input: &str) {\n            let mut t = Tokenizer::new(input);\n            let (_, token) = t.next().unwrap().unwrap();\n            assert_eq!(token, Token::Keylike(input));\n            assert!(t.next().unwrap().is_none());\n        }\n        t(\"foo\");\n        t(\"0bar\");\n        t(\"bar0\");\n        t(\"1234\");\n        t(\"a-b\");\n        t(\"a_B\");\n        t(\"-_-\");\n        t(\"___\");\n    }\n\n    #[test]\n    fn all() {\n        fn t(input: &str, expected: &[((usize, usize), Token<'_>, &str)]) {\n            let mut tokens = Tokenizer::new(input);\n            let mut actual: Vec<((usize, usize), Token<'_>, &str)> = Vec::new();\n            while let Some((span, token)) = tokens.next().unwrap() {\n                actual.push((span.into(), token, &input[span.start..span.end]));\n            }\n            for (a, b) in actual.iter().zip(expected) {\n                assert_eq!(a, b);\n            }\n            assert_eq!(actual.len(), expected.len());\n        }\n\n        t(\n            \" a \",\n            &[\n                ((0, 1), Token::Whitespace(\" \"), \" \"),\n                ((1, 2), Token::Keylike(\"a\"), \"a\"),\n                ((2, 3), Token::Whitespace(\" \"), \" \"),\n            ],\n        );\n\n        t(\n            \" a\\t [[]] \\t [] {} , . =\\n# foo \\r\\n#foo \\n \",\n            &[\n                ((0, 1), Token::Whitespace(\" \"), \" \"),\n                ((1, 2), Token::Keylike(\"a\"), \"a\"),\n                ((2, 4), Token::Whitespace(\"\\t \"), \"\\t \"),\n                ((4, 5), Token::LeftBracket, \"[\"),\n                ((5, 6), Token::LeftBracket, \"[\"),\n                ((6, 7), Token::RightBracket, \"]\"),\n                ((7, 8), Token::RightBracket, \"]\"),\n                ((8, 11), Token::Whitespace(\" \\t \"), \" \\t \"),\n                ((11, 12), Token::LeftBracket, \"[\"),\n                ((12, 13), Token::RightBracket, \"]\"),\n                ((13, 14), Token::Whitespace(\" \"), \" \"),\n                ((14, 15), Token::LeftBrace, \"{\"),\n                ((15, 16), Token::RightBrace, \"}\"),\n                ((16, 17), Token::Whitespace(\" \"), \" \"),\n                ((17, 18), Token::Comma, \",\"),\n                ((18, 19), Token::Whitespace(\" \"), \" \"),\n                ((19, 20), Token::Period, \".\"),\n                ((20, 21), Token::Whitespace(\" \"), \" \"),\n                ((21, 22), Token::Equals, \"=\"),\n                ((22, 23), Token::Newline, \"\\n\"),\n                ((23, 29), Token::Comment(\"# foo \"), \"# foo \"),\n                ((29, 31), Token::Newline, \"\\r\\n\"),\n                ((31, 36), Token::Comment(\"#foo \"), \"#foo \"),\n                ((36, 37), Token::Newline, \"\\n\"),\n                ((37, 38), Token::Whitespace(\" \"), \" \"),\n            ],\n        );\n    }\n\n    #[test]\n    fn bare_cr_bad() {\n        err(\"\\r\", Error::Unexpected(0, '\\r'));\n        err(\"'\\n\", Error::NewlineInString(1));\n        err(\"'\\u{0}\", Error::InvalidCharInString(1, '\\u{0}'));\n        err(\"'\", Error::UnterminatedString(0));\n        err(\"\\u{0}\", Error::Unexpected(0, '\\u{0}'));\n    }\n\n    #[test]\n    fn bad_comment() {\n        let mut t = Tokenizer::new(\"#\\u{0}\");\n        t.next().unwrap().unwrap();\n        assert_eq!(t.next(), Err(Error::Unexpected(1, '\\u{0}')));\n        assert!(t.next().unwrap().is_none());\n    }\n}\n","traces":[{"line":19,"address":[5330382,5330368],"length":1,"stats":{"Line":2},"fn_name":"from"},{"line":20,"address":[5330392],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[5330416],"length":1,"stats":{"Line":4},"fn_name":"new"},{"line":88,"address":[5330471],"length":1,"stats":{"Line":4},"fn_name":null},{"line":93,"address":[5330551],"length":1,"stats":{"Line":4},"fn_name":null},{"line":94,"address":[5330571],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[5330672,5330608],"length":1,"stats":{"Line":5},"fn_name":"next"},{"line":98,"address":[5331804,5332421,5330826,5330626,5331000,5331654,5331504,5331429,5331204,5331879,5331279,5330898,5331579,5331729,5331102,5331354],"length":1,"stats":{"Line":30},"fn_name":null},{"line":99,"address":[5330687,5330779,5330828],"length":1,"stats":{"Line":12},"fn_name":null},{"line":100,"address":[5330903],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[5331005],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[5331107],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[5331209],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[5331284],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[5331359],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[5331434],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[5331509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[5331584],"length":1,"stats":{"Line":3},"fn_name":null},{"line":109,"address":[5331659],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[5331734],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[5331809],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[5331884],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[5331976,5331916,5331900],"length":1,"stats":{"Line":3},"fn_name":null},{"line":114,"address":[5331908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[5229226,5229200],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":117,"address":[5332018],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[5332034,5332050,5332095],"length":1,"stats":{"Line":6},"fn_name":null},{"line":119,"address":[5332042],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[5229498,5229472],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":122,"address":[5332135,5332374],"length":1,"stats":{"Line":5},"fn_name":null},{"line":124,"address":[5332255],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[5330713],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[5332501,5332553],"length":1,"stats":{"Line":8},"fn_name":null},{"line":129,"address":[5332574],"length":1,"stats":{"Line":4},"fn_name":null},{"line":132,"address":[5332832],"length":1,"stats":{"Line":3},"fn_name":"peek"},{"line":133,"address":[5332844],"length":1,"stats":{"Line":3},"fn_name":null},{"line":136,"address":[5332896],"length":1,"stats":{"Line":1},"fn_name":"eat"},{"line":137,"address":[5229748,5229744],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":141,"address":[5333008,5333064],"length":1,"stats":{"Line":1},"fn_name":"eat_spanned"},{"line":142,"address":[5333455,5333119,5333079,5333039,5333141,5333317,5333557],"length":1,"stats":{"Line":4},"fn_name":null},{"line":143,"address":[5333564,5333289,5333651],"length":1,"stats":{"Line":3},"fn_name":null},{"line":144,"address":[5333919,5333722],"length":1,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[5333492],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[5333937,5333798],"length":1,"stats":{"Line":2},"fn_name":null},{"line":149,"address":[5333822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[5334016],"length":1,"stats":{"Line":1},"fn_name":"expect"},{"line":154,"address":[5334297,5334034,5334170],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[5334162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[5334320,5334379],"length":1,"stats":{"Line":1},"fn_name":"expect_spanned"},{"line":160,"address":[5334346,5334399],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[5334420,5334821,5334443,5334891,5334492,5334683,5335319],"length":1,"stats":{"Line":4},"fn_name":null},{"line":162,"address":[5334893,5334652],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[5335113,5335015],"length":1,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[5335093],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[5335168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[5335063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[5335146],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[5335036,5335300,5335360],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[5334869],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[5335332],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[5335584,5335729],"length":1,"stats":{"Line":2},"fn_name":"table_key"},{"line":182,"address":[5335602],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[5336119,5335744,5336084,5335666,5335943,5337432,5336206,5337717,5336481],"length":1,"stats":{"Line":4},"fn_name":null},{"line":184,"address":[5336154,5336208,5335912],"length":1,"stats":{"Line":5},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[5336486],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[5336518],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[5336550],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[5336590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[5336619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[5336682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[5337964,5336750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[5336716,5336903],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[5336950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[5337115,5337330,5336909,5337033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[5337054,5337117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[5337069,5338124,5337337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[5336689,5337542,5336823,5337437,5337979,5337410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[5337517],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[5337744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[5336129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[5338160],"length":1,"stats":{"Line":1},"fn_name":"eat_whitespace"},{"line":219,"address":[5338293,5338295,5338192],"length":1,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[5338277],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[5338304],"length":1,"stats":{"Line":1},"fn_name":"eat_comment"},{"line":226,"address":[5338327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[5338392],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[5338412,5338370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[5229780,5229776,5229792],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":233,"address":[5338586,5338464],"length":1,"stats":{"Line":1},"fn_name":"eat_newline_or_eof"},{"line":234,"address":[5338482],"length":1,"stats":{"Line":1},"fn_name":null},{"line":235,"address":[5338955,5338923,5338601,5338785,5339071,5338526,5339058,5339242],"length":1,"stats":{"Line":3},"fn_name":null},{"line":236,"address":[5338757,5339065,5338957],"length":1,"stats":{"Line":3},"fn_name":null},{"line":237,"address":[5338970,5339081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[5339041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[5339392],"length":1,"stats":{"Line":1},"fn_name":"skip_to_newline"},{"line":246,"address":[5339469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[5339411],"length":1,"stats":{"Line":1},"fn_name":null},{"line":248,"address":[5339425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[5339488],"length":1,"stats":{"Line":5},"fn_name":"eatc"},{"line":255,"address":[5339594,5339501],"length":1,"stats":{"Line":9},"fn_name":null},{"line":256,"address":[5339562,5339596,5339642],"length":1,"stats":{"Line":12},"fn_name":null},{"line":257,"address":[5339635],"length":1,"stats":{"Line":2},"fn_name":null},{"line":258,"address":[5339644],"length":1,"stats":{"Line":2},"fn_name":null},{"line":260,"address":[5339589],"length":1,"stats":{"Line":2},"fn_name":null},{"line":264,"address":[5339664],"length":1,"stats":{"Line":3},"fn_name":"current"},{"line":265,"address":[5339673,5339752],"length":1,"stats":{"Line":6},"fn_name":null},{"line":268,"address":[5229813,5229792,5229805],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":269,"address":[5229833,5229824],"length":1,"stats":{"Line":7},"fn_name":"{{closure}}"},{"line":272,"address":[5339792],"length":1,"stats":{"Line":0},"fn_name":"input"},{"line":273,"address":[5339797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[5339808],"length":1,"stats":{"Line":2},"fn_name":"whitespace_token"},{"line":277,"address":[5339850,5339967],"length":1,"stats":{"Line":3},"fn_name":null},{"line":280,"address":[5339935,5339974],"length":1,"stats":{"Line":4},"fn_name":null},{"line":283,"address":[5340064],"length":1,"stats":{"Line":1},"fn_name":"comment_token"},{"line":284,"address":[5340115,5340331],"length":1,"stats":{"Line":2},"fn_name":null},{"line":285,"address":[5340199],"length":1,"stats":{"Line":1},"fn_name":null},{"line":286,"address":[5340292],"length":1,"stats":{"Line":1},"fn_name":null},{"line":288,"address":[5340285],"length":1,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[5340299,5340341],"length":1,"stats":{"Line":2},"fn_name":null},{"line":293,"address":[5340448,5340595],"length":1,"stats":{"Line":2},"fn_name":"read_string"},{"line":305,"address":[5340497],"length":1,"stats":{"Line":2},"fn_name":null},{"line":306,"address":[5340742,5340529,5340617],"length":1,"stats":{"Line":5},"fn_name":null},{"line":307,"address":[5340641],"length":1,"stats":{"Line":1},"fn_name":null},{"line":308,"address":[5340734],"length":1,"stats":{"Line":1},"fn_name":null},{"line":310,"address":[5340880],"length":1,"stats":{"Line":1},"fn_name":null},{"line":311,"address":[5340674,5340755,5343479],"length":1,"stats":{"Line":2},"fn_name":null},{"line":312,"address":[5340833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[5341059],"length":1,"stats":{"Line":2},"fn_name":null},{"line":318,"address":[5341108],"length":1,"stats":{"Line":2},"fn_name":null},{"line":319,"address":[5343055],"length":1,"stats":{"Line":2},"fn_name":null},{"line":320,"address":[5343509,5341119],"length":1,"stats":{"Line":2},"fn_name":null},{"line":321,"address":[5341169,5341352],"length":1,"stats":{"Line":2},"fn_name":null},{"line":322,"address":[5341221,5341337,5341354],"length":1,"stats":{"Line":7},"fn_name":null},{"line":323,"address":[5341370],"length":1,"stats":{"Line":1},"fn_name":null},{"line":324,"address":[5341569,5341705,5341482,5343641],"length":1,"stats":{"Line":3},"fn_name":null},{"line":325,"address":[5341615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":327,"address":[5341707,5341818,5343405],"length":1,"stats":{"Line":3},"fn_name":null},{"line":328,"address":[5343259,5341745],"length":1,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[5341730],"length":1,"stats":{"Line":1},"fn_name":null},{"line":332,"address":[5341820],"length":1,"stats":{"Line":1},"fn_name":null},{"line":334,"address":[5341396,5341849],"length":1,"stats":{"Line":3},"fn_name":null},{"line":337,"address":[5341854],"length":1,"stats":{"Line":2},"fn_name":null},{"line":338,"address":[5341933,5342514],"length":1,"stats":{"Line":3},"fn_name":null},{"line":339,"address":[5342160],"length":1,"stats":{"Line":1},"fn_name":null},{"line":340,"address":[5342231],"length":1,"stats":{"Line":1},"fn_name":null},{"line":341,"address":[5342238],"length":1,"stats":{"Line":1},"fn_name":null},{"line":343,"address":[5342252,5342202],"length":1,"stats":{"Line":2},"fn_name":null},{"line":344,"address":[5342302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":345,"address":[5342324],"length":1,"stats":{"Line":1},"fn_name":null},{"line":346,"address":[5342331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":348,"address":[5342340,5342273],"length":1,"stats":{"Line":2},"fn_name":null},{"line":349,"address":[5342361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[5342368,5343561],"length":1,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[5342427],"length":1,"stats":{"Line":1},"fn_name":null},{"line":353,"address":[5342463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[5343591,5342470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[5342836],"length":1,"stats":{"Line":2},"fn_name":null},{"line":358,"address":[5342524],"length":1,"stats":{"Line":2},"fn_name":null},{"line":359,"address":[5343437,5342656],"length":1,"stats":{"Line":2},"fn_name":null},{"line":360,"address":[5342824],"length":1,"stats":{"Line":2},"fn_name":null},{"line":363,"address":[5341952,5343004,5343060],"length":1,"stats":{"Line":4},"fn_name":null},{"line":364,"address":[5341259],"length":1,"stats":{"Line":1},"fn_name":null},{"line":369,"address":[5343712],"length":1,"stats":{"Line":1},"fn_name":"literal_string"},{"line":370,"address":[5229872],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":371,"address":[5230110,5229922],"length":1,"stats":{"Line":2},"fn_name":null},{"line":372,"address":[5230121],"length":1,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[5230131],"length":1,"stats":{"Line":1},"fn_name":null},{"line":375,"address":[5230066],"length":1,"stats":{"Line":1},"fn_name":null},{"line":380,"address":[5343808],"length":1,"stats":{"Line":2},"fn_name":"basic_string"},{"line":381,"address":[5232107,5232091,5232112,5230160,5231829],"length":1,"stats":{"Line":11},"fn_name":"{{closure}}"},{"line":382,"address":[5230225],"length":1,"stats":{"Line":2},"fn_name":null},{"line":383,"address":[5230279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":384,"address":[5230547,5230567,5230726,5231283,5231726,5230527,5230694,5230510,5230627,5230342,5230587,5230647,5231020,5231118,5230607,5231199],"length":1,"stats":{"Line":13},"fn_name":null},{"line":385,"address":[5230463,5230517,5230373],"length":1,"stats":{"Line":3},"fn_name":null},{"line":386,"address":[5230537],"length":1,"stats":{"Line":1},"fn_name":null},{"line":387,"address":[5230557],"length":1,"stats":{"Line":1},"fn_name":null},{"line":388,"address":[5230577],"length":1,"stats":{"Line":1},"fn_name":null},{"line":389,"address":[5230597],"length":1,"stats":{"Line":1},"fn_name":null},{"line":390,"address":[5230617],"length":1,"stats":{"Line":1},"fn_name":null},{"line":391,"address":[5230637],"length":1,"stats":{"Line":1},"fn_name":null},{"line":392,"address":[5230664,5230696],"length":1,"stats":{"Line":2},"fn_name":null},{"line":393,"address":[5230728,5230652],"length":1,"stats":{"Line":2},"fn_name":null},{"line":394,"address":[5231002,5230759],"length":1,"stats":{"Line":2},"fn_name":null},{"line":396,"address":[5231120,5231044,5231204,5231288],"length":1,"stats":{"Line":1},"fn_name":null},{"line":397,"address":[5231025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":398,"address":[5231298],"length":1,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[5231404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[5231519],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[5231534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[5231544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[5231559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[5231439],"length":1,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[5231721,5231563],"length":1,"stats":{"Line":2},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[5231672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":415,"address":[5231706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":417,"address":[5231699],"length":1,"stats":{"Line":1},"fn_name":null},{"line":421,"address":[5231728],"length":1,"stats":{"Line":1},"fn_name":null},{"line":422,"address":[5230404],"length":1,"stats":{"Line":1},"fn_name":null},{"line":424,"address":[5231823],"length":1,"stats":{"Line":1},"fn_name":null},{"line":426,"address":[5231834],"length":1,"stats":{"Line":2},"fn_name":null},{"line":427,"address":[5232018],"length":1,"stats":{"Line":2},"fn_name":null},{"line":428,"address":[5232101],"length":1,"stats":{"Line":2},"fn_name":null},{"line":430,"address":[5232027],"length":1,"stats":{"Line":1},"fn_name":null},{"line":434,"address":[5344006,5343904],"length":1,"stats":{"Line":1},"fn_name":"hex"},{"line":435,"address":[5343946],"length":1,"stats":{"Line":1},"fn_name":null},{"line":436,"address":[5344230,5344130,5344665,5344021],"length":1,"stats":{"Line":3},"fn_name":null},{"line":437,"address":[5344264,5344416],"length":1,"stats":{"Line":1},"fn_name":null},{"line":438,"address":[5344304,5344418],"length":1,"stats":{"Line":2},"fn_name":null},{"line":439,"address":[5344555,5344697],"length":1,"stats":{"Line":2},"fn_name":null},{"line":440,"address":[5344339],"length":1,"stats":{"Line":1},"fn_name":null},{"line":443,"address":[5344210,5344699],"length":1,"stats":{"Line":2},"fn_name":null},{"line":444,"address":[5344936,5344800],"length":1,"stats":{"Line":2},"fn_name":null},{"line":445,"address":[5344940,5344824],"length":1,"stats":{"Line":2},"fn_name":null},{"line":446,"address":[5344856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[5345024],"length":1,"stats":{"Line":3},"fn_name":"keylike"},{"line":451,"address":[5345197,5345069],"length":1,"stats":{"Line":5},"fn_name":null},{"line":452,"address":[5345125],"length":1,"stats":{"Line":3},"fn_name":null},{"line":453,"address":[5345158],"length":1,"stats":{"Line":2},"fn_name":null},{"line":455,"address":[5345151],"length":1,"stats":{"Line":2},"fn_name":null},{"line":457,"address":[5345165,5345207],"length":1,"stats":{"Line":5},"fn_name":null},{"line":460,"address":[5345296],"length":1,"stats":{"Line":1},"fn_name":"substr_offset"},{"line":461,"address":[5345416,5345320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":462,"address":[5345451,5345397],"length":1,"stats":{"Line":2},"fn_name":null},{"line":463,"address":[5345466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":464,"address":[5345491,5345532],"length":1,"stats":{"Line":1},"fn_name":null},{"line":465,"address":[5345571,5345601,5345515],"length":1,"stats":{"Line":1},"fn_name":null},{"line":469,"address":[5345616],"length":1,"stats":{"Line":4},"fn_name":"step_span"},{"line":470,"address":[5345630,5345689],"length":1,"stats":{"Line":8},"fn_name":null},{"line":472,"address":[5232133,5232112,5232125],"length":1,"stats":{"Line":5},"fn_name":"{{closure}}"},{"line":473,"address":[5232153,5232144],"length":1,"stats":{"Line":8},"fn_name":"{{closure}}"},{"line":478,"address":[5345760],"length":1,"stats":{"Line":4},"fn_name":"peek_one"},{"line":479,"address":[5345769],"length":1,"stats":{"Line":4},"fn_name":null},{"line":483,"address":[5345840],"length":1,"stats":{"Line":6},"fn_name":"one"},{"line":484,"address":[5345849],"length":1,"stats":{"Line":4},"fn_name":null},{"line":491,"address":[5345888],"length":1,"stats":{"Line":5},"fn_name":"next"},{"line":492,"address":[5232216,5232192],"length":1,"stats":{"Line":12},"fn_name":"{{closure}}"},{"line":493,"address":[5232325,5232231],"length":1,"stats":{"Line":7},"fn_name":null},{"line":494,"address":[5232259],"length":1,"stats":{"Line":1},"fn_name":null},{"line":495,"address":[5232280,5232327],"length":1,"stats":{"Line":2},"fn_name":null},{"line":496,"address":[5232334],"length":1,"stats":{"Line":1},"fn_name":null},{"line":497,"address":[5232403],"length":1,"stats":{"Line":1},"fn_name":null},{"line":500,"address":[5232438],"length":1,"stats":{"Line":2},"fn_name":null},{"line":506,"address":[5345984],"length":1,"stats":{"Line":2},"fn_name":"push"},{"line":507,"address":[5346046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[5345997],"length":1,"stats":{"Line":2},"fn_name":null},{"line":509,"address":[5346021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":513,"address":[5346064,5346261],"length":1,"stats":{"Line":1},"fn_name":"to_owned"},{"line":514,"address":[5346316,5346113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":515,"address":[5346086,5346120],"length":1,"stats":{"Line":2},"fn_name":null},{"line":516,"address":[5346132,5346276,5346239],"length":1,"stats":{"Line":2},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[5346393,5346336],"length":1,"stats":{"Line":2},"fn_name":"into_cow"},{"line":523,"address":[5346509,5346599],"length":1,"stats":{"Line":3},"fn_name":null},{"line":524,"address":[5346356,5346518],"length":1,"stats":{"Line":4},"fn_name":null},{"line":525,"address":[5346413],"length":1,"stats":{"Line":1},"fn_name":null},{"line":530,"address":[5346656],"length":1,"stats":{"Line":2},"fn_name":"is_keylike"},{"line":531,"address":[5346743,5346664,5346705,5346788,5346825,5346891,5346723,5346924,5346940],"length":1,"stats":{"Line":19},"fn_name":null},{"line":532,"address":[5346867,5346811],"length":1,"stats":{"Line":4},"fn_name":null},{"line":533,"address":[5346770,5346900],"length":1,"stats":{"Line":4},"fn_name":null},{"line":534,"address":[5346740],"length":1,"stats":{"Line":2},"fn_name":null},{"line":535,"address":[5346702],"length":1,"stats":{"Line":2},"fn_name":null},{"line":539,"address":[5346944],"length":1,"stats":{"Line":0},"fn_name":"describe"},{"line":540,"address":[5347140,5347270,5347244,5347114,5347361,5347036,5347062,5347008,5347088,5347218,5347293,5347192,5347166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[5346953,5347022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[5347048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[5347074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[5347100],"length":1,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[5347126],"length":1,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[5347152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[5347178],"length":1,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[5347204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[5347230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[5347256],"length":1,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[5347279],"length":1,"stats":{"Line":0},"fn_name":null},{"line":552,"address":[5347300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":553,"address":[5347312,5347338],"length":1,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[5347347],"length":1,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[5347324],"length":1,"stats":{"Line":0},"fn_name":null},{"line":559,"address":[5347370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[5346994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":570,"address":[4386293,4386224],"length":1,"stats":{"Line":1},"fn_name":"err"},{"line":571,"address":[4386247],"length":1,"stats":{"Line":1},"fn_name":null},{"line":572,"address":[4386308],"length":1,"stats":{"Line":1},"fn_name":null},{"line":573,"address":[4386476,4386357],"length":1,"stats":{"Line":1},"fn_name":null},{"line":574,"address":[4386872,4386770,4386453],"length":1,"stats":{"Line":2},"fn_name":null},{"line":578,"address":[4386928],"length":1,"stats":{"Line":3},"fn_name":"literal_strings"},{"line":579,"address":[4387232,4387348],"length":1,"stats":{"Line":1},"fn_name":"t"},{"line":580,"address":[4387283],"length":1,"stats":{"Line":1},"fn_name":null},{"line":581,"address":[4387363],"length":1,"stats":{"Line":1},"fn_name":null},{"line":582,"address":[4387642,4387743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":584,"address":[4387556],"length":1,"stats":{"Line":1},"fn_name":null},{"line":586,"address":[4387515],"length":1,"stats":{"Line":1},"fn_name":null},{"line":590,"address":[4388232,4388108],"length":1,"stats":{"Line":1},"fn_name":null},{"line":604,"address":[4388336],"length":1,"stats":{"Line":3},"fn_name":"basic_strings"},{"line":605,"address":[4389764,4389648],"length":1,"stats":{"Line":1},"fn_name":"t"},{"line":606,"address":[4389699],"length":1,"stats":{"Line":1},"fn_name":null},{"line":607,"address":[4389779],"length":1,"stats":{"Line":1},"fn_name":null},{"line":608,"address":[4390159,4390058],"length":1,"stats":{"Line":1},"fn_name":null},{"line":610,"address":[4389972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":612,"address":[4389931],"length":1,"stats":{"Line":1},"fn_name":null},{"line":616,"address":[4390524,4390648],"length":1,"stats":{"Line":1},"fn_name":null},{"line":644,"address":[4389142],"length":1,"stats":{"Line":1},"fn_name":null},{"line":645,"address":[4389192],"length":1,"stats":{"Line":1},"fn_name":null},{"line":646,"address":[4389242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":647,"address":[4389292],"length":1,"stats":{"Line":1},"fn_name":null},{"line":648,"address":[4389343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":649,"address":[4389405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":650,"address":[4389467],"length":1,"stats":{"Line":1},"fn_name":null},{"line":651,"address":[4389518],"length":1,"stats":{"Line":1},"fn_name":null},{"line":652,"address":[4389580],"length":1,"stats":{"Line":1},"fn_name":null},{"line":656,"address":[4390752],"length":1,"stats":{"Line":3},"fn_name":"keylike"},{"line":657,"address":[4390989,4390928],"length":1,"stats":{"Line":1},"fn_name":"t"},{"line":658,"address":[4390951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":659,"address":[4391004],"length":1,"stats":{"Line":1},"fn_name":null},{"line":660,"address":[4391153,4391292],"length":1,"stats":{"Line":2},"fn_name":null},{"line":661,"address":[4391652,4391776],"length":1,"stats":{"Line":1},"fn_name":null},{"line":674,"address":[4391888],"length":1,"stats":{"Line":3},"fn_name":"all"},{"line":675,"address":[4392087,4391968],"length":1,"stats":{"Line":1},"fn_name":"t"},{"line":676,"address":[4392007],"length":1,"stats":{"Line":1},"fn_name":null},{"line":677,"address":[4392102],"length":1,"stats":{"Line":1},"fn_name":null},{"line":678,"address":[4392115,4392778,4392155],"length":1,"stats":{"Line":3},"fn_name":null},{"line":679,"address":[4392343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":681,"address":[4393250,4392791,4393071],"length":1,"stats":{"Line":2},"fn_name":null},{"line":682,"address":[4393255,4393145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":684,"address":[4393760,4393053,4393599],"length":1,"stats":{"Line":2},"fn_name":null},{"line":689,"address":[4391896],"length":1,"stats":{"Line":1},"fn_name":null},{"line":698,"address":[4391932],"length":1,"stats":{"Line":1},"fn_name":null},{"line":729,"address":[4394192],"length":1,"stats":{"Line":3},"fn_name":"bare_cr_bad"},{"line":730,"address":[4394206],"length":1,"stats":{"Line":1},"fn_name":null},{"line":731,"address":[4394256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":732,"address":[4394298],"length":1,"stats":{"Line":1},"fn_name":null},{"line":733,"address":[4394348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":734,"address":[4394399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":738,"address":[4394464,4394498],"length":1,"stats":{"Line":3},"fn_name":"bad_comment"},{"line":739,"address":[4394478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":740,"address":[4394513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":741,"address":[4394606],"length":1,"stats":{"Line":1},"fn_name":null},{"line":742,"address":[4395068,4395195],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":278,"coverable":354},{"path":["/","usr","src","toml-rs","src","value.rs"],"content":"//! Definition of a TOML value\n\nuse std::collections::{BTreeMap, HashMap};\nuse std::fmt;\nuse std::hash::Hash;\nuse std::mem::discriminant;\nuse std::ops;\nuse std::str::FromStr;\nuse std::vec;\n\nuse serde::de;\nuse serde::de::IntoDeserializer;\nuse serde::ser;\n\nuse crate::datetime::{self, DatetimeFromString};\n#[doc(no_inline)]\npub use crate::datetime::{Datetime, DatetimeParseError};\n\npub use crate::map::Map;\n\n/// Representation of a TOML value.\n#[derive(PartialEq, Clone, Debug)]\npub enum Value {\n    /// Represents a TOML string\n    String(String),\n    /// Represents a TOML integer\n    Integer(i64),\n    /// Represents a TOML float\n    Float(f64),\n    /// Represents a TOML boolean\n    Boolean(bool),\n    /// Represents a TOML datetime\n    Datetime(Datetime),\n    /// Represents a TOML array\n    Array(Array),\n    /// Represents a TOML table\n    Table(Table),\n}\n\n/// Type representing a TOML array, payload of the `Value::Array` variant\npub type Array = Vec<Value>;\n\n/// Type representing a TOML table, payload of the `Value::Table` variant.\n/// By default it is backed by a BTreeMap, enable the `preserve_order` feature\n/// to use a LinkedHashMap instead.\npub type Table = Map<String, Value>;\n\nimpl Value {\n    /// Convert a `T` into `toml::Value` which is an enum that can represent\n    /// any valid TOML data.\n    ///\n    /// This conversion can fail if `T`'s implementation of `Serialize` decides to\n    /// fail, or if `T` contains a map with non-string keys.\n    pub fn try_from<T>(value: T) -> Result<Value, crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        value.serialize(Serializer)\n    }\n\n    /// Interpret a `toml::Value` as an instance of type `T`.\n    ///\n    /// This conversion can fail if the structure of the `Value` does not match the\n    /// structure expected by `T`, for example if `T` is a struct type but the\n    /// `Value` contains something other than a TOML table. It can also fail if the\n    /// structure is correct but `T`'s implementation of `Deserialize` decides that\n    /// something is wrong with the data, for example required struct fields are\n    /// missing from the TOML map or some number is too big to fit in the expected\n    /// primitive type.\n    pub fn try_into<'de, T>(self) -> Result<T, crate::de::Error>\n    where\n        T: de::Deserialize<'de>,\n    {\n        de::Deserialize::deserialize(self)\n    }\n\n    /// Index into a TOML array or map. A string index can be used to access a\n    /// value in a map, and a usize index can be used to access an element of an\n    /// array.\n    ///\n    /// Returns `None` if the type of `self` does not match the type of the\n    /// index, for example if the index is a string and `self` is an array or a\n    /// number. Also returns `None` if the given key does not exist in the map\n    /// or the given index is not within the bounds of the array.\n    pub fn get<I: Index>(&self, index: I) -> Option<&Value> {\n        index.index(self)\n    }\n\n    /// Mutably index into a TOML array or map. A string index can be used to\n    /// access a value in a map, and a usize index can be used to access an\n    /// element of an array.\n    ///\n    /// Returns `None` if the type of `self` does not match the type of the\n    /// index, for example if the index is a string and `self` is an array or a\n    /// number. Also returns `None` if the given key does not exist in the map\n    /// or the given index is not within the bounds of the array.\n    pub fn get_mut<I: Index>(&mut self, index: I) -> Option<&mut Value> {\n        index.index_mut(self)\n    }\n\n    /// Extracts the integer value if it is an integer.\n    pub fn as_integer(&self) -> Option<i64> {\n        match *self {\n            Value::Integer(i) => Some(i),\n            _ => None,\n        }\n    }\n\n    /// Tests whether this value is an integer.\n    pub fn is_integer(&self) -> bool {\n        self.as_integer().is_some()\n    }\n\n    /// Extracts the float value if it is a float.\n    pub fn as_float(&self) -> Option<f64> {\n        match *self {\n            Value::Float(f) => Some(f),\n            _ => None,\n        }\n    }\n\n    /// Tests whether this value is a float.\n    pub fn is_float(&self) -> bool {\n        self.as_float().is_some()\n    }\n\n    /// Extracts the boolean value if it is a boolean.\n    pub fn as_bool(&self) -> Option<bool> {\n        match *self {\n            Value::Boolean(b) => Some(b),\n            _ => None,\n        }\n    }\n\n    /// Tests whether this value is a boolean.\n    pub fn is_bool(&self) -> bool {\n        self.as_bool().is_some()\n    }\n\n    /// Extracts the string of this value if it is a string.\n    pub fn as_str(&self) -> Option<&str> {\n        match *self {\n            Value::String(ref s) => Some(&**s),\n            _ => None,\n        }\n    }\n\n    /// Tests if this value is a string.\n    pub fn is_str(&self) -> bool {\n        self.as_str().is_some()\n    }\n\n    /// Extracts the datetime value if it is a datetime.\n    ///\n    /// Note that a parsed TOML value will only contain ISO 8601 dates. An\n    /// example date is:\n    ///\n    /// ```notrust\n    /// 1979-05-27T07:32:00Z\n    /// ```\n    pub fn as_datetime(&self) -> Option<&Datetime> {\n        match *self {\n            Value::Datetime(ref s) => Some(s),\n            _ => None,\n        }\n    }\n\n    /// Tests whether this value is a datetime.\n    pub fn is_datetime(&self) -> bool {\n        self.as_datetime().is_some()\n    }\n\n    /// Extracts the array value if it is an array.\n    pub fn as_array(&self) -> Option<&Vec<Value>> {\n        match *self {\n            Value::Array(ref s) => Some(s),\n            _ => None,\n        }\n    }\n\n    /// Extracts the array value if it is an array.\n    pub fn as_array_mut(&mut self) -> Option<&mut Vec<Value>> {\n        match *self {\n            Value::Array(ref mut s) => Some(s),\n            _ => None,\n        }\n    }\n\n    /// Tests whether this value is an array.\n    pub fn is_array(&self) -> bool {\n        self.as_array().is_some()\n    }\n\n    /// Extracts the table value if it is a table.\n    pub fn as_table(&self) -> Option<&Table> {\n        match *self {\n            Value::Table(ref s) => Some(s),\n            _ => None,\n        }\n    }\n\n    /// Extracts the table value if it is a table.\n    pub fn as_table_mut(&mut self) -> Option<&mut Table> {\n        match *self {\n            Value::Table(ref mut s) => Some(s),\n            _ => None,\n        }\n    }\n\n    /// Tests whether this value is a table.\n    pub fn is_table(&self) -> bool {\n        self.as_table().is_some()\n    }\n\n    /// Tests whether this and another value have the same type.\n    pub fn same_type(&self, other: &Value) -> bool {\n        discriminant(self) == discriminant(other)\n    }\n\n    /// Returns a human-readable representation of the type of this value.\n    pub fn type_str(&self) -> &'static str {\n        match *self {\n            Value::String(..) => \"string\",\n            Value::Integer(..) => \"integer\",\n            Value::Float(..) => \"float\",\n            Value::Boolean(..) => \"boolean\",\n            Value::Datetime(..) => \"datetime\",\n            Value::Array(..) => \"array\",\n            Value::Table(..) => \"table\",\n        }\n    }\n}\n\nimpl<I> ops::Index<I> for Value\nwhere\n    I: Index,\n{\n    type Output = Value;\n\n    fn index(&self, index: I) -> &Value {\n        self.get(index).expect(\"index not found\")\n    }\n}\n\nimpl<I> ops::IndexMut<I> for Value\nwhere\n    I: Index,\n{\n    fn index_mut(&mut self, index: I) -> &mut Value {\n        self.get_mut(index).expect(\"index not found\")\n    }\n}\n\nimpl<'a> From<&'a str> for Value {\n    #[inline]\n    fn from(val: &'a str) -> Value {\n        Value::String(val.to_string())\n    }\n}\n\nimpl<V: Into<Value>> From<Vec<V>> for Value {\n    fn from(val: Vec<V>) -> Value {\n        Value::Array(val.into_iter().map(|v| v.into()).collect())\n    }\n}\n\nimpl<S: Into<String>, V: Into<Value>> From<BTreeMap<S, V>> for Value {\n    fn from(val: BTreeMap<S, V>) -> Value {\n        let table = val.into_iter().map(|(s, v)| (s.into(), v.into())).collect();\n\n        Value::Table(table)\n    }\n}\n\nimpl<S: Into<String> + Hash + Eq, V: Into<Value>> From<HashMap<S, V>> for Value {\n    fn from(val: HashMap<S, V>) -> Value {\n        let table = val.into_iter().map(|(s, v)| (s.into(), v.into())).collect();\n\n        Value::Table(table)\n    }\n}\n\nmacro_rules! impl_into_value {\n    ($variant:ident : $T:ty) => {\n        impl From<$T> for Value {\n            #[inline]\n            fn from(val: $T) -> Value {\n                Value::$variant(val.into())\n            }\n        }\n    };\n}\n\nimpl_into_value!(String: String);\nimpl_into_value!(Integer: i64);\nimpl_into_value!(Integer: i32);\nimpl_into_value!(Integer: i8);\nimpl_into_value!(Integer: u8);\nimpl_into_value!(Integer: u32);\nimpl_into_value!(Float: f64);\nimpl_into_value!(Float: f32);\nimpl_into_value!(Boolean: bool);\nimpl_into_value!(Datetime: Datetime);\nimpl_into_value!(Table: Table);\n\n/// Types that can be used to index a `toml::Value`\n///\n/// Currently this is implemented for `usize` to index arrays and `str` to index\n/// tables.\n///\n/// This trait is sealed and not intended for implementation outside of the\n/// `toml` crate.\npub trait Index: Sealed {\n    #[doc(hidden)]\n    fn index<'a>(&self, val: &'a Value) -> Option<&'a Value>;\n    #[doc(hidden)]\n    fn index_mut<'a>(&self, val: &'a mut Value) -> Option<&'a mut Value>;\n}\n\n/// An implementation detail that should not be implemented, this will change in\n/// the future and break code otherwise.\n#[doc(hidden)]\npub trait Sealed {}\nimpl Sealed for usize {}\nimpl Sealed for str {}\nimpl Sealed for String {}\nimpl<'a, T: Sealed + ?Sized> Sealed for &'a T {}\n\nimpl Index for usize {\n    fn index<'a>(&self, val: &'a Value) -> Option<&'a Value> {\n        match *val {\n            Value::Array(ref a) => a.get(*self),\n            _ => None,\n        }\n    }\n\n    fn index_mut<'a>(&self, val: &'a mut Value) -> Option<&'a mut Value> {\n        match *val {\n            Value::Array(ref mut a) => a.get_mut(*self),\n            _ => None,\n        }\n    }\n}\n\nimpl Index for str {\n    fn index<'a>(&self, val: &'a Value) -> Option<&'a Value> {\n        match *val {\n            Value::Table(ref a) => a.get(self),\n            _ => None,\n        }\n    }\n\n    fn index_mut<'a>(&self, val: &'a mut Value) -> Option<&'a mut Value> {\n        match *val {\n            Value::Table(ref mut a) => a.get_mut(self),\n            _ => None,\n        }\n    }\n}\n\nimpl Index for String {\n    fn index<'a>(&self, val: &'a Value) -> Option<&'a Value> {\n        self[..].index(val)\n    }\n\n    fn index_mut<'a>(&self, val: &'a mut Value) -> Option<&'a mut Value> {\n        self[..].index_mut(val)\n    }\n}\n\nimpl<'s, T: ?Sized> Index for &'s T\nwhere\n    T: Index,\n{\n    fn index<'a>(&self, val: &'a Value) -> Option<&'a Value> {\n        (**self).index(val)\n    }\n\n    fn index_mut<'a>(&self, val: &'a mut Value) -> Option<&'a mut Value> {\n        (**self).index_mut(val)\n    }\n}\n\nimpl fmt::Display for Value {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        crate::ser::to_string(self)\n            .expect(\"Unable to represent value as string\")\n            .fmt(f)\n    }\n}\n\nimpl FromStr for Value {\n    type Err = crate::de::Error;\n    fn from_str(s: &str) -> Result<Value, Self::Err> {\n        crate::from_str(s)\n    }\n}\n\nimpl ser::Serialize for Value {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: ser::Serializer,\n    {\n        use serde::ser::SerializeMap;\n\n        match *self {\n            Value::String(ref s) => serializer.serialize_str(s),\n            Value::Integer(i) => serializer.serialize_i64(i),\n            Value::Float(f) => serializer.serialize_f64(f),\n            Value::Boolean(b) => serializer.serialize_bool(b),\n            Value::Datetime(ref s) => s.serialize(serializer),\n            Value::Array(ref a) => a.serialize(serializer),\n            Value::Table(ref t) => {\n                let mut map = serializer.serialize_map(Some(t.len()))?;\n                // Be sure to visit non-tables first (and also non\n                // array-of-tables) as all keys must be emitted first.\n                for (k, v) in t {\n                    if !v.is_table() && !v.is_array()\n                        || (v\n                            .as_array()\n                            .map(|a| !a.iter().any(|v| v.is_table()))\n                            .unwrap_or(false))\n                    {\n                        map.serialize_entry(k, v)?;\n                    }\n                }\n                for (k, v) in t {\n                    if v.as_array()\n                        .map(|a| a.iter().any(|v| v.is_table()))\n                        .unwrap_or(false)\n                    {\n                        map.serialize_entry(k, v)?;\n                    }\n                }\n                for (k, v) in t {\n                    if v.is_table() {\n                        map.serialize_entry(k, v)?;\n                    }\n                }\n                map.end()\n            }\n        }\n    }\n}\n\nimpl<'de> de::Deserialize<'de> for Value {\n    fn deserialize<D>(deserializer: D) -> Result<Value, D::Error>\n    where\n        D: de::Deserializer<'de>,\n    {\n        struct ValueVisitor;\n\n        impl<'de> de::Visitor<'de> for ValueVisitor {\n            type Value = Value;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n                formatter.write_str(\"any valid TOML value\")\n            }\n\n            fn visit_bool<E>(self, value: bool) -> Result<Value, E> {\n                Ok(Value::Boolean(value))\n            }\n\n            fn visit_i64<E>(self, value: i64) -> Result<Value, E> {\n                Ok(Value::Integer(value))\n            }\n\n            fn visit_u64<E: de::Error>(self, value: u64) -> Result<Value, E> {\n                if value <= i64::max_value() as u64 {\n                    Ok(Value::Integer(value as i64))\n                } else {\n                    Err(de::Error::custom(\"u64 value was too large\"))\n                }\n            }\n\n            fn visit_u32<E>(self, value: u32) -> Result<Value, E> {\n                Ok(Value::Integer(value.into()))\n            }\n\n            fn visit_i32<E>(self, value: i32) -> Result<Value, E> {\n                Ok(Value::Integer(value.into()))\n            }\n\n            fn visit_f64<E>(self, value: f64) -> Result<Value, E> {\n                Ok(Value::Float(value))\n            }\n\n            fn visit_str<E>(self, value: &str) -> Result<Value, E> {\n                Ok(Value::String(value.into()))\n            }\n\n            fn visit_string<E>(self, value: String) -> Result<Value, E> {\n                Ok(Value::String(value))\n            }\n\n            fn visit_some<D>(self, deserializer: D) -> Result<Value, D::Error>\n            where\n                D: de::Deserializer<'de>,\n            {\n                de::Deserialize::deserialize(deserializer)\n            }\n\n            fn visit_seq<V>(self, mut visitor: V) -> Result<Value, V::Error>\n            where\n                V: de::SeqAccess<'de>,\n            {\n                let mut vec = Vec::new();\n                while let Some(elem) = visitor.next_element()? {\n                    vec.push(elem);\n                }\n                Ok(Value::Array(vec))\n            }\n\n            fn visit_map<V>(self, mut visitor: V) -> Result<Value, V::Error>\n            where\n                V: de::MapAccess<'de>,\n            {\n                let mut key = String::new();\n                let datetime = visitor.next_key_seed(DatetimeOrTable { key: &mut key })?;\n                match datetime {\n                    Some(true) => {\n                        let date: DatetimeFromString = visitor.next_value()?;\n                        return Ok(Value::Datetime(date.value));\n                    }\n                    None => return Ok(Value::Table(Map::new())),\n                    Some(false) => {}\n                }\n                let mut map = Map::new();\n                map.insert(key, visitor.next_value()?);\n                while let Some(key) = visitor.next_key()? {\n                    if map.contains_key(&key) {\n                        let msg = format!(\"duplicate key: `{}`\", key);\n                        return Err(de::Error::custom(msg));\n                    }\n                    map.insert(key, visitor.next_value()?);\n                }\n                Ok(Value::Table(map))\n            }\n        }\n\n        deserializer.deserialize_any(ValueVisitor)\n    }\n}\n\nimpl<'de> de::Deserializer<'de> for Value {\n    type Error = crate::de::Error;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, crate::de::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        match self {\n            Value::Boolean(v) => visitor.visit_bool(v),\n            Value::Integer(n) => visitor.visit_i64(n),\n            Value::Float(n) => visitor.visit_f64(n),\n            Value::String(v) => visitor.visit_string(v),\n            Value::Datetime(v) => visitor.visit_string(v.to_string()),\n            Value::Array(v) => {\n                let len = v.len();\n                let mut deserializer = SeqDeserializer::new(v);\n                let seq = visitor.visit_seq(&mut deserializer)?;\n                let remaining = deserializer.iter.len();\n                if remaining == 0 {\n                    Ok(seq)\n                } else {\n                    Err(de::Error::invalid_length(len, &\"fewer elements in array\"))\n                }\n            }\n            Value::Table(v) => {\n                let len = v.len();\n                let mut deserializer = MapDeserializer::new(v);\n                let map = visitor.visit_map(&mut deserializer)?;\n                let remaining = deserializer.iter.len();\n                if remaining == 0 {\n                    Ok(map)\n                } else {\n                    Err(de::Error::invalid_length(len, &\"fewer elements in map\"))\n                }\n            }\n        }\n    }\n\n    #[inline]\n    fn deserialize_enum<V>(\n        self,\n        _name: &str,\n        _variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, crate::de::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        match self {\n            Value::String(variant) => visitor.visit_enum(variant.into_deserializer()),\n            _ => Err(de::Error::invalid_type(\n                de::Unexpected::UnitVariant,\n                &\"string only\",\n            )),\n        }\n    }\n\n    // `None` is interpreted as a missing field so be sure to implement `Some`\n    // as a present field.\n    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, crate::de::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        visitor.visit_some(self)\n    }\n\n    fn deserialize_newtype_struct<V>(\n        self,\n        _name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, crate::de::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        visitor.visit_newtype_struct(self)\n    }\n\n    serde::forward_to_deserialize_any! {\n        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit seq\n        bytes byte_buf map unit_struct tuple_struct struct\n        tuple ignored_any identifier\n    }\n}\n\nstruct SeqDeserializer {\n    iter: vec::IntoIter<Value>,\n}\n\nimpl SeqDeserializer {\n    fn new(vec: Vec<Value>) -> Self {\n        SeqDeserializer {\n            iter: vec.into_iter(),\n        }\n    }\n}\n\nimpl<'de> de::SeqAccess<'de> for SeqDeserializer {\n    type Error = crate::de::Error;\n\n    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, crate::de::Error>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        match self.iter.next() {\n            Some(value) => seed.deserialize(value).map(Some),\n            None => Ok(None),\n        }\n    }\n\n    fn size_hint(&self) -> Option<usize> {\n        match self.iter.size_hint() {\n            (lower, Some(upper)) if lower == upper => Some(upper),\n            _ => None,\n        }\n    }\n}\n\nstruct MapDeserializer {\n    iter: <Map<String, Value> as IntoIterator>::IntoIter,\n    value: Option<(String, Value)>,\n}\n\nimpl MapDeserializer {\n    fn new(map: Map<String, Value>) -> Self {\n        MapDeserializer {\n            iter: map.into_iter(),\n            value: None,\n        }\n    }\n}\n\nimpl<'de> de::MapAccess<'de> for MapDeserializer {\n    type Error = crate::de::Error;\n\n    fn next_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, crate::de::Error>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        match self.iter.next() {\n            Some((key, value)) => {\n                self.value = Some((key.clone(), value));\n                seed.deserialize(Value::String(key)).map(Some)\n            }\n            None => Ok(None),\n        }\n    }\n\n    fn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value, crate::de::Error>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        let (key, res) = match self.value.take() {\n            Some((key, value)) => (key, seed.deserialize(value)),\n            None => return Err(de::Error::custom(\"value is missing\")),\n        };\n        res.map_err(|mut error| {\n            error.add_key_context(&key);\n            error\n        })\n    }\n\n    fn size_hint(&self) -> Option<usize> {\n        match self.iter.size_hint() {\n            (lower, Some(upper)) if lower == upper => Some(upper),\n            _ => None,\n        }\n    }\n}\n\nimpl<'de> de::IntoDeserializer<'de, crate::de::Error> for Value {\n    type Deserializer = Self;\n\n    fn into_deserializer(self) -> Self {\n        self\n    }\n}\n\nstruct Serializer;\n\nimpl ser::Serializer for Serializer {\n    type Ok = Value;\n    type Error = crate::ser::Error;\n\n    type SerializeSeq = SerializeVec;\n    type SerializeTuple = SerializeVec;\n    type SerializeTupleStruct = SerializeVec;\n    type SerializeTupleVariant = SerializeVec;\n    type SerializeMap = SerializeMap;\n    type SerializeStruct = SerializeMap;\n    type SerializeStructVariant = ser::Impossible<Value, crate::ser::Error>;\n\n    fn serialize_bool(self, value: bool) -> Result<Value, crate::ser::Error> {\n        Ok(Value::Boolean(value))\n    }\n\n    fn serialize_i8(self, value: i8) -> Result<Value, crate::ser::Error> {\n        self.serialize_i64(value.into())\n    }\n\n    fn serialize_i16(self, value: i16) -> Result<Value, crate::ser::Error> {\n        self.serialize_i64(value.into())\n    }\n\n    fn serialize_i32(self, value: i32) -> Result<Value, crate::ser::Error> {\n        self.serialize_i64(value.into())\n    }\n\n    fn serialize_i64(self, value: i64) -> Result<Value, crate::ser::Error> {\n        Ok(Value::Integer(value))\n    }\n\n    fn serialize_u8(self, value: u8) -> Result<Value, crate::ser::Error> {\n        self.serialize_i64(value.into())\n    }\n\n    fn serialize_u16(self, value: u16) -> Result<Value, crate::ser::Error> {\n        self.serialize_i64(value.into())\n    }\n\n    fn serialize_u32(self, value: u32) -> Result<Value, crate::ser::Error> {\n        self.serialize_i64(value.into())\n    }\n\n    fn serialize_u64(self, value: u64) -> Result<Value, crate::ser::Error> {\n        if value <= i64::max_value() as u64 {\n            self.serialize_i64(value as i64)\n        } else {\n            Err(ser::Error::custom(\"u64 value was too large\"))\n        }\n    }\n\n    fn serialize_f32(self, value: f32) -> Result<Value, crate::ser::Error> {\n        self.serialize_f64(value.into())\n    }\n\n    fn serialize_f64(self, value: f64) -> Result<Value, crate::ser::Error> {\n        Ok(Value::Float(value))\n    }\n\n    fn serialize_char(self, value: char) -> Result<Value, crate::ser::Error> {\n        let mut s = String::new();\n        s.push(value);\n        self.serialize_str(&s)\n    }\n\n    fn serialize_str(self, value: &str) -> Result<Value, crate::ser::Error> {\n        Ok(Value::String(value.to_owned()))\n    }\n\n    fn serialize_bytes(self, value: &[u8]) -> Result<Value, crate::ser::Error> {\n        let vec = value.iter().map(|&b| Value::Integer(b.into())).collect();\n        Ok(Value::Array(vec))\n    }\n\n    fn serialize_unit(self) -> Result<Value, crate::ser::Error> {\n        Err(crate::ser::Error::UnsupportedType)\n    }\n\n    fn serialize_unit_struct(self, _name: &'static str) -> Result<Value, crate::ser::Error> {\n        Err(crate::ser::Error::UnsupportedType)\n    }\n\n    fn serialize_unit_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n    ) -> Result<Value, crate::ser::Error> {\n        self.serialize_str(_variant)\n    }\n\n    fn serialize_newtype_struct<T: ?Sized>(\n        self,\n        _name: &'static str,\n        value: &T,\n    ) -> Result<Value, crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        value.serialize(self)\n    }\n\n    fn serialize_newtype_variant<T: ?Sized>(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _value: &T,\n    ) -> Result<Value, crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        Err(crate::ser::Error::UnsupportedType)\n    }\n\n    fn serialize_none(self) -> Result<Value, crate::ser::Error> {\n        Err(crate::ser::Error::UnsupportedNone)\n    }\n\n    fn serialize_some<T: ?Sized>(self, value: &T) -> Result<Value, crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        value.serialize(self)\n    }\n\n    fn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq, crate::ser::Error> {\n        Ok(SerializeVec {\n            vec: Vec::with_capacity(len.unwrap_or(0)),\n        })\n    }\n\n    fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple, crate::ser::Error> {\n        self.serialize_seq(Some(len))\n    }\n\n    fn serialize_tuple_struct(\n        self,\n        _name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleStruct, crate::ser::Error> {\n        self.serialize_seq(Some(len))\n    }\n\n    fn serialize_tuple_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleVariant, crate::ser::Error> {\n        self.serialize_seq(Some(len))\n    }\n\n    fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap, crate::ser::Error> {\n        Ok(SerializeMap {\n            map: Map::new(),\n            next_key: None,\n        })\n    }\n\n    fn serialize_struct(\n        self,\n        _name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeStruct, crate::ser::Error> {\n        self.serialize_map(Some(len))\n    }\n\n    fn serialize_struct_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStructVariant, crate::ser::Error> {\n        Err(crate::ser::Error::UnsupportedType)\n    }\n}\n\nstruct SerializeVec {\n    vec: Vec<Value>,\n}\n\nstruct SerializeMap {\n    map: Map<String, Value>,\n    next_key: Option<String>,\n}\n\nimpl ser::SerializeSeq for SerializeVec {\n    type Ok = Value;\n    type Error = crate::ser::Error;\n\n    fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        self.vec.push(Value::try_from(value)?);\n        Ok(())\n    }\n\n    fn end(self) -> Result<Value, crate::ser::Error> {\n        Ok(Value::Array(self.vec))\n    }\n}\n\nimpl ser::SerializeTuple for SerializeVec {\n    type Ok = Value;\n    type Error = crate::ser::Error;\n\n    fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        ser::SerializeSeq::serialize_element(self, value)\n    }\n\n    fn end(self) -> Result<Value, crate::ser::Error> {\n        ser::SerializeSeq::end(self)\n    }\n}\n\nimpl ser::SerializeTupleStruct for SerializeVec {\n    type Ok = Value;\n    type Error = crate::ser::Error;\n\n    fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        ser::SerializeSeq::serialize_element(self, value)\n    }\n\n    fn end(self) -> Result<Value, crate::ser::Error> {\n        ser::SerializeSeq::end(self)\n    }\n}\n\nimpl ser::SerializeTupleVariant for SerializeVec {\n    type Ok = Value;\n    type Error = crate::ser::Error;\n\n    fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        ser::SerializeSeq::serialize_element(self, value)\n    }\n\n    fn end(self) -> Result<Value, crate::ser::Error> {\n        ser::SerializeSeq::end(self)\n    }\n}\n\nimpl ser::SerializeMap for SerializeMap {\n    type Ok = Value;\n    type Error = crate::ser::Error;\n\n    fn serialize_key<T: ?Sized>(&mut self, key: &T) -> Result<(), crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        match Value::try_from(key)? {\n            Value::String(s) => self.next_key = Some(s),\n            _ => return Err(crate::ser::Error::KeyNotString),\n        };\n        Ok(())\n    }\n\n    fn serialize_value<T: ?Sized>(&mut self, value: &T) -> Result<(), crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        let key = self.next_key.take();\n        let key = key.expect(\"serialize_value called before serialize_key\");\n        match Value::try_from(value) {\n            Ok(value) => {\n                self.map.insert(key, value);\n            }\n            Err(crate::ser::Error::UnsupportedNone) => {}\n            Err(e) => return Err(e),\n        }\n        Ok(())\n    }\n\n    fn end(self) -> Result<Value, crate::ser::Error> {\n        Ok(Value::Table(self.map))\n    }\n}\n\nimpl ser::SerializeStruct for SerializeMap {\n    type Ok = Value;\n    type Error = crate::ser::Error;\n\n    fn serialize_field<T: ?Sized>(\n        &mut self,\n        key: &'static str,\n        value: &T,\n    ) -> Result<(), crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        ser::SerializeMap::serialize_key(self, key)?;\n        ser::SerializeMap::serialize_value(self, value)\n    }\n\n    fn end(self) -> Result<Value, crate::ser::Error> {\n        ser::SerializeMap::end(self)\n    }\n}\n\nstruct DatetimeOrTable<'a> {\n    key: &'a mut String,\n}\n\nimpl<'a, 'de> de::DeserializeSeed<'de> for DatetimeOrTable<'a> {\n    type Value = bool;\n\n    fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n    where\n        D: de::Deserializer<'de>,\n    {\n        deserializer.deserialize_any(self)\n    }\n}\n\nimpl<'a, 'de> de::Visitor<'de> for DatetimeOrTable<'a> {\n    type Value = bool;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n        formatter.write_str(\"a string key\")\n    }\n\n    fn visit_str<E>(self, s: &str) -> Result<bool, E>\n    where\n        E: de::Error,\n    {\n        if s == datetime::FIELD {\n            Ok(true)\n        } else {\n            self.key.push_str(s);\n            Ok(false)\n        }\n    }\n\n    fn visit_string<E>(self, s: String) -> Result<bool, E>\n    where\n        E: de::Error,\n    {\n        if s == datetime::FIELD {\n            Ok(true)\n        } else {\n            *self.key = s;\n            Ok(false)\n        }\n    }\n}\n","traces":[{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[5092688],"length":1,"stats":{"Line":0},"fn_name":"as_integer"},{"line":103,"address":[5092721],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[5092727,5092697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[5092712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[5092768],"length":1,"stats":{"Line":0},"fn_name":"is_integer"},{"line":111,"address":[5092777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[5092832],"length":1,"stats":{"Line":0},"fn_name":"as_float"},{"line":116,"address":[5092865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[5092841,5092871],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[5092856],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[5092928],"length":1,"stats":{"Line":0},"fn_name":"is_float"},{"line":124,"address":[5092937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[5092992],"length":1,"stats":{"Line":0},"fn_name":"as_bool"},{"line":129,"address":[5093021],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[5093001,5093027],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[5093016],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[5093056],"length":1,"stats":{"Line":0},"fn_name":"is_bool"},{"line":137,"address":[5093065],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[5093104],"length":1,"stats":{"Line":0},"fn_name":"as_str"},{"line":142,"address":[5093138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[5093145,5093113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[5093129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[5093216],"length":1,"stats":{"Line":0},"fn_name":"is_str"},{"line":150,"address":[5093225],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[5093280],"length":1,"stats":{"Line":0},"fn_name":"as_datetime"},{"line":162,"address":[5093313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[5093319,5093289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[5093304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[5093360],"length":1,"stats":{"Line":0},"fn_name":"is_datetime"},{"line":170,"address":[5093369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[5093424],"length":1,"stats":{"Line":0},"fn_name":"as_array"},{"line":175,"address":[5093457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[5093433,5093463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[5093448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[5093504],"length":1,"stats":{"Line":0},"fn_name":"as_array_mut"},{"line":183,"address":[5093537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[5093543,5093513],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[5093528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[5093584],"length":1,"stats":{"Line":0},"fn_name":"is_array"},{"line":191,"address":[5093593],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[5093648],"length":1,"stats":{"Line":0},"fn_name":"as_table"},{"line":196,"address":[5093681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[5093687,5093657],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[5093672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[5093728],"length":1,"stats":{"Line":0},"fn_name":"as_table_mut"},{"line":204,"address":[5093761],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[5093767,5093737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[5093752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[5093808],"length":1,"stats":{"Line":0},"fn_name":"is_table"},{"line":212,"address":[5093817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[5093872],"length":1,"stats":{"Line":0},"fn_name":"same_type"},{"line":217,"address":[5093891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[5093952],"length":1,"stats":{"Line":0},"fn_name":"type_str"},{"line":222,"address":[5094108,5094131,5094085,5094011,5094039,5094062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[5093961,5094025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[5094048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[5094071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[5094094],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[5094117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[5094140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[5093997],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[5094176],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":257,"address":[5094193],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[5102160,5102592,5102240,5102704,5102448,5102384,5101920,5102512,5102032,5102096,5102320],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":288,"address":[5102049,5101927,5102172,5102471,5102711,5102407,5102599,5102529,5102252,5102336,5102112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[5094272],"length":1,"stats":{"Line":0},"fn_name":"index"},{"line":331,"address":[5094316,5094382],"length":1,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[5094323,5094286],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[5094307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[5094400],"length":1,"stats":{"Line":0},"fn_name":"index_mut"},{"line":338,"address":[5094444,5094510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[5094414,5094451],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[5094435],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[5094528],"length":1,"stats":{"Line":0},"fn_name":"index"},{"line":347,"address":[5094624,5094582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[5094547,5094589],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[5094573],"length":1,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[5094640],"length":1,"stats":{"Line":0},"fn_name":"index_mut"},{"line":354,"address":[5094736,5094694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[5094701,5094659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[5094685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[5042800],"length":1,"stats":{"Line":0},"fn_name":"index"},{"line":363,"address":[5042819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[5042880],"length":1,"stats":{"Line":0},"fn_name":"index_mut"},{"line":367,"address":[5042899],"length":1,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[5094752,5094803],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":386,"address":[5094829,5094769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[5094944],"length":1,"stats":{"Line":0},"fn_name":"from_str"},{"line":395,"address":[5094965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[5075468,5075184],"length":1,"stats":{"Line":0},"fn_name":"serialize<&mut toml::ser::Serializer>"},{"line":406,"address":[5075738,5075790,5075361,5075491,5075590,5075541,5075686],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[5075210,5075371,5075483,5078058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[5075504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[5075554],"length":1,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[5075603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[5075699],"length":1,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[5075751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[5075312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[5075803,5075324,5078086,5076079,5076188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[5076244,5076392,5076069,5076957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[5076527,5076955,5076458,5076670],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[5076506,5076622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[5078336,5078288,5078302,5078345],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}<&mut toml::ser::Serializer>"},{"line":422,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[5076950,5076683],"length":1,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[5076382,5076962,5077491,5077098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[5077489,5077164],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[5078480,5078432,5078489,5078446],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}<&mut toml::ser::Serializer>"},{"line":432,"address":[5077250],"length":1,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[5078040,5077088,5077692,5077496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[5077758,5078038],"length":1,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[5077799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[5077606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[5078784,5078704,5078576,5078624],"length":1,"stats":{"Line":0},"fn_name":"deserialize<&mut toml::de::Deserializer>"},{"line":453,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[5094992],"length":1,"stats":{"Line":0},"fn_name":"expecting"},{"line":457,"address":[5095013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[5078864],"length":1,"stats":{"Line":0},"fn_name":"visit_bool<toml::de::Error>"},{"line":461,"address":[5078881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[5078944],"length":1,"stats":{"Line":0},"fn_name":"visit_i64<toml::de::Error>"},{"line":465,"address":[5078956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[5079024],"length":1,"stats":{"Line":0},"fn_name":"visit_f64<toml::de::Error>"},{"line":485,"address":[5079037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[5079104],"length":1,"stats":{"Line":0},"fn_name":"visit_str<toml::de::Error>"},{"line":489,"address":[5079121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[5079248],"length":1,"stats":{"Line":0},"fn_name":"visit_string<toml::de::Error>"},{"line":493,"address":[5079255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[5079376,5079420,5080096,5080140],"length":1,"stats":{"Line":0},"fn_name":"visit_seq<&mut serde::de::value::SeqDeserializer<alloc::vec::IntoIter<toml::de::Value>, toml::de::Error>>"},{"line":507,"address":[5079391,5080106],"length":1,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[5080438,5080586,5079476,5079746,5080155,5080170,5080488,5080207,5079844,5079435,5079439,5079707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":509,"address":[5079788,5080530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[5080596,5079854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[5087192,5080848,5084040,5087120,5080920,5083968],"length":1,"stats":{"Line":0},"fn_name":"visit_map<toml::de::DatetimeDeserializer>"},{"line":518,"address":[5083978,5087130,5080858],"length":1,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[5084121,5087207,5084262,5087273,5081131,5087414,5080935,5084055,5080990],"length":1,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[5081229,5087523,5084371],"length":1,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[5084318,5087470,5081176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[5081570,5087525,5084712,5081231,5084373,5087864],"length":1,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[5087698,5084546,5081404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[5081643,5084785,5087937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[5084361,5087513,5081219],"length":1,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[5089654,5085028,5088180,5083360,5086502,5084913,5082171,5081886,5081771,5088465,5088065,5085313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[5085348,5088500,5088868,5089793,5085716,5082574,5089681,5082206,5086529,5083387,5083499,5086641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[5082533,5085675,5088827],"length":1,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[5088948,5082654,5085796],"length":1,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[5089249,5086097,5082955,5082856,5085998,5089150],"length":1,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[5085721,5082960,5089254,5083464,5082579,5086606,5089758,5088873,5086102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[5089798,5083504,5086646],"length":1,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[5078593,5078631,5078791,5078714],"length":1,"stats":{"Line":0},"fn_name":null},{"line":552,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":558,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":559,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":562,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":564,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":596,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":597,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":611,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":619,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":634,"address":[5095056],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":636,"address":[5095063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":648,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":649,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":650,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":654,"address":[5095168],"length":1,"stats":{"Line":0},"fn_name":"size_hint"},{"line":655,"address":[5095216,5095294,5095177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":656,"address":[5095218,5095199,5095296],"length":1,"stats":{"Line":0},"fn_name":null},{"line":657,"address":[5095207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":668,"address":[5095328],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":670,"address":[5095338],"length":1,"stats":{"Line":0},"fn_name":null},{"line":683,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":684,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":685,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":686,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":698,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":700,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":706,"address":[5095472],"length":1,"stats":{"Line":0},"fn_name":"size_hint"},{"line":707,"address":[5095597,5095481,5095519],"length":1,"stats":{"Line":0},"fn_name":null},{"line":708,"address":[5095521,5095599,5095502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":709,"address":[5095510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":717,"address":[5095616],"length":1,"stats":{"Line":0},"fn_name":"into_deserializer"},{"line":718,"address":[5095619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":736,"address":[5095664],"length":1,"stats":{"Line":0},"fn_name":"serialize_bool"},{"line":737,"address":[5095681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":740,"address":[5095744],"length":1,"stats":{"Line":0},"fn_name":"serialize_i8"},{"line":741,"address":[5095756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":744,"address":[5095824],"length":1,"stats":{"Line":0},"fn_name":"serialize_i16"},{"line":745,"address":[5095836],"length":1,"stats":{"Line":0},"fn_name":null},{"line":748,"address":[5095888],"length":1,"stats":{"Line":0},"fn_name":"serialize_i32"},{"line":749,"address":[5095904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":752,"address":[5095952],"length":1,"stats":{"Line":0},"fn_name":"serialize_i64"},{"line":753,"address":[5095964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":756,"address":[5096032],"length":1,"stats":{"Line":0},"fn_name":"serialize_u8"},{"line":757,"address":[5096044],"length":1,"stats":{"Line":0},"fn_name":null},{"line":760,"address":[5096112],"length":1,"stats":{"Line":0},"fn_name":"serialize_u16"},{"line":761,"address":[5096124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":764,"address":[5096176],"length":1,"stats":{"Line":0},"fn_name":"serialize_u32"},{"line":765,"address":[5096192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":768,"address":[5096240],"length":1,"stats":{"Line":0},"fn_name":"serialize_u64"},{"line":769,"address":[5096330,5096266],"length":1,"stats":{"Line":0},"fn_name":null},{"line":770,"address":[5096324],"length":1,"stats":{"Line":0},"fn_name":null},{"line":772,"address":[5096293,5096332],"length":1,"stats":{"Line":0},"fn_name":null},{"line":776,"address":[5096400],"length":1,"stats":{"Line":0},"fn_name":"serialize_f32"},{"line":777,"address":[5096423],"length":1,"stats":{"Line":0},"fn_name":null},{"line":780,"address":[5096464],"length":1,"stats":{"Line":0},"fn_name":"serialize_f64"},{"line":781,"address":[5096477],"length":1,"stats":{"Line":0},"fn_name":null},{"line":784,"address":[5096584,5096544],"length":1,"stats":{"Line":0},"fn_name":"serialize_char"},{"line":785,"address":[5096555],"length":1,"stats":{"Line":0},"fn_name":null},{"line":786,"address":[5096605],"length":1,"stats":{"Line":0},"fn_name":null},{"line":787,"address":[5096617,5096646],"length":1,"stats":{"Line":0},"fn_name":null},{"line":790,"address":[5096704],"length":1,"stats":{"Line":0},"fn_name":"serialize_str"},{"line":791,"address":[5096721],"length":1,"stats":{"Line":0},"fn_name":null},{"line":794,"address":[5096848],"length":1,"stats":{"Line":0},"fn_name":"serialize_bytes"},{"line":795,"address":[5090289,5090272],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":796,"address":[5096951],"length":1,"stats":{"Line":0},"fn_name":null},{"line":799,"address":[5097088],"length":1,"stats":{"Line":0},"fn_name":"serialize_unit"},{"line":800,"address":[5097095],"length":1,"stats":{"Line":0},"fn_name":null},{"line":803,"address":[5097152],"length":1,"stats":{"Line":0},"fn_name":"serialize_unit_struct"},{"line":804,"address":[5097169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":807,"address":[5097232],"length":1,"stats":{"Line":0},"fn_name":"serialize_unit_variant"},{"line":813,"address":[5097263],"length":1,"stats":{"Line":0},"fn_name":null},{"line":816,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":824,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":827,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":837,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":840,"address":[5097296],"length":1,"stats":{"Line":0},"fn_name":"serialize_none"},{"line":841,"address":[5097303],"length":1,"stats":{"Line":0},"fn_name":null},{"line":848,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":851,"address":[5097360],"length":1,"stats":{"Line":0},"fn_name":"serialize_seq"},{"line":852,"address":[5097428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":853,"address":[5097387],"length":1,"stats":{"Line":0},"fn_name":null},{"line":857,"address":[5097520],"length":1,"stats":{"Line":0},"fn_name":"serialize_tuple"},{"line":858,"address":[5097532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":861,"address":[5097584],"length":1,"stats":{"Line":0},"fn_name":"serialize_tuple_struct"},{"line":866,"address":[5097606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":869,"address":[5097664],"length":1,"stats":{"Line":0},"fn_name":"serialize_tuple_variant"},{"line":876,"address":[5097700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":879,"address":[5097744],"length":1,"stats":{"Line":0},"fn_name":"serialize_map"},{"line":880,"address":[5097798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":881,"address":[5097767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":882,"address":[5097789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":886,"address":[5097920],"length":1,"stats":{"Line":0},"fn_name":"serialize_struct"},{"line":891,"address":[5097942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":894,"address":[5098000],"length":1,"stats":{"Line":0},"fn_name":"serialize_struct_variant"},{"line":901,"address":[5098036],"length":1,"stats":{"Line":0},"fn_name":null},{"line":922,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":923,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":926,"address":[5098096],"length":1,"stats":{"Line":0},"fn_name":"end"},{"line":927,"address":[5098103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":939,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":942,"address":[5098224],"length":1,"stats":{"Line":0},"fn_name":"end"},{"line":943,"address":[5098231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":955,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":958,"address":[5098288],"length":1,"stats":{"Line":0},"fn_name":"end"},{"line":959,"address":[5098295],"length":1,"stats":{"Line":0},"fn_name":null},{"line":971,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":974,"address":[5098352],"length":1,"stats":{"Line":0},"fn_name":"end"},{"line":975,"address":[5098359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":987,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":988,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":989,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":991,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":998,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":999,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1000,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1001,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1002,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1004,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1005,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1007,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1010,"address":[5098416],"length":1,"stats":{"Line":0},"fn_name":"end"},{"line":1011,"address":[5098423],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1019,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1027,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1028,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1031,"address":[5098560],"length":1,"stats":{"Line":0},"fn_name":"end"},{"line":1032,"address":[5098567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1043,"address":[5090352,5090384],"length":1,"stats":{"Line":0},"fn_name":"deserialize<toml::de::DatetimeFieldDeserializer>"},{"line":1047,"address":[5090396,5090368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1054,"address":[5098640],"length":1,"stats":{"Line":0},"fn_name":"expecting"},{"line":1055,"address":[5098661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1058,"address":[5090480],"length":1,"stats":{"Line":0},"fn_name":"visit_str<toml::de::Error>"},{"line":1062,"address":[5090502,5090592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1065,"address":[5090560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1070,"address":[5090690,5090624],"length":1,"stats":{"Line":0},"fn_name":"visit_string<toml::de::Error>"},{"line":1074,"address":[5090706,5090887,5090636],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1077,"address":[5090811,5090712],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":349},{"path":["/","usr","src","toml-rs","test-suite","tests","de-errors.rs"],"content":"extern crate serde;\nextern crate toml;\n\nuse serde::{de, Deserialize};\nuse std::fmt;\n\nmacro_rules! bad {\n    ($toml:expr, $ty:ty, $msg:expr) => {\n        match toml::from_str::<$ty>($toml) {\n            Ok(s) => panic!(\"parsed to: {:#?}\", s),\n            Err(e) => assert_eq!(e.to_string(), $msg),\n        }\n    };\n}\n\n#[derive(Debug, Deserialize, PartialEq)]\nstruct Parent<T> {\n    p_a: T,\n    p_b: Vec<Child<T>>,\n}\n\n#[derive(Debug, Deserialize, PartialEq)]\n#[serde(deny_unknown_fields)]\nstruct Child<T> {\n    c_a: T,\n    c_b: T,\n}\n\n#[derive(Debug, PartialEq)]\nenum CasedString {\n    Lowercase(String),\n    Uppercase(String),\n}\n\nimpl<'de> de::Deserialize<'de> for CasedString {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: de::Deserializer<'de>,\n    {\n        struct CasedStringVisitor;\n\n        impl<'de> de::Visitor<'de> for CasedStringVisitor {\n            type Value = CasedString;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"a string\")\n            }\n\n            fn visit_str<E>(self, s: &str) -> Result<Self::Value, E>\n            where\n                E: de::Error,\n            {\n                if s.is_empty() {\n                    Err(de::Error::invalid_length(0, &\"a non-empty string\"))\n                } else if s.chars().all(|x| x.is_ascii_lowercase()) {\n                    Ok(CasedString::Lowercase(s.to_string()))\n                } else if s.chars().all(|x| x.is_ascii_uppercase()) {\n                    Ok(CasedString::Uppercase(s.to_string()))\n                } else {\n                    Err(de::Error::invalid_value(\n                        de::Unexpected::Str(s),\n                        &\"all lowercase or all uppercase\",\n                    ))\n                }\n            }\n        }\n\n        deserializer.deserialize_any(CasedStringVisitor)\n    }\n}\n\n#[test]\nfn custom_errors() {\n    toml::from_str::<Parent<CasedString>>(\n        \"\n            p_a = 'a'\n            p_b = [{c_a = 'a', c_b = 'c'}]\n        \",\n    )\n    .unwrap();\n\n    // Custom error at p_b value.\n    bad!(\n        \"\n            p_a = ''\n                # ^\n        \",\n        Parent<CasedString>,\n        \"invalid length 0, expected a non-empty string for key `p_a` at line 2 column 19\"\n    );\n\n    // Missing field in table.\n    bad!(\n        \"\n            p_a = 'a'\n          # ^\n        \",\n        Parent<CasedString>,\n        \"missing field `p_b` at line 1 column 1\"\n    );\n\n    // Invalid type in p_b.\n    bad!(\n        \"\n            p_a = 'a'\n            p_b = 1\n                # ^\n        \",\n        Parent<CasedString>,\n        \"invalid type: integer `1`, expected a sequence for key `p_b` at line 3 column 19\"\n    );\n\n    // Sub-table in Vec is missing a field.\n    bad!(\n        \"\n            p_a = 'a'\n            p_b = [\n                {c_a = 'a'}\n              # ^\n            ]\n        \",\n        Parent<CasedString>,\n        \"missing field `c_b` for key `p_b` at line 4 column 17\"\n    );\n\n    // Sub-table in Vec has a field with a bad value.\n    bad!(\n        \"\n            p_a = 'a'\n            p_b = [\n                {c_a = 'a', c_b = '*'}\n                                # ^\n            ]\n        \",\n        Parent<CasedString>,\n        \"invalid value: string \\\"*\\\", expected all lowercase or all uppercase for key `p_b` at line 4 column 35\"\n    );\n\n    // Sub-table in Vec is missing a field.\n    bad!(\n        \"\n            p_a = 'a'\n            p_b = [\n                {c_a = 'a', c_b = 'b'},\n                {c_a = 'aa'}\n              # ^\n            ]\n        \",\n        Parent<CasedString>,\n        \"missing field `c_b` for key `p_b` at line 5 column 17\"\n    );\n\n    // Sub-table in the middle of a Vec is missing a field.\n    bad!(\n        \"\n            p_a = 'a'\n            p_b = [\n                {c_a = 'a', c_b = 'b'},\n                {c_a = 'aa'},\n              # ^\n                {c_a = 'aaa', c_b = 'bbb'},\n            ]\n        \",\n        Parent<CasedString>,\n        \"missing field `c_b` for key `p_b` at line 5 column 17\"\n    );\n\n    // Sub-table in the middle of a Vec has a field with a bad value.\n    bad!(\n        \"\n            p_a = 'a'\n            p_b = [\n                {c_a = 'a', c_b = 'b'},\n                {c_a = 'aa', c_b = 1},\n                                 # ^\n                {c_a = 'aaa', c_b = 'bbb'},\n            ]\n        \",\n        Parent<CasedString>,\n        \"invalid type: integer `1`, expected a string for key `p_b` at line 5 column 36\"\n    );\n\n    // Sub-table in the middle of a Vec has an extra field.\n    // FIXME: This location could be better.\n    bad!(\n        \"\n            p_a = 'a'\n            p_b = [\n                {c_a = 'a', c_b = 'b'},\n                {c_a = 'aa', c_b = 'bb', c_d = 'd'},\n              # ^\n                {c_a = 'aaa', c_b = 'bbb'},\n                {c_a = 'aaaa', c_b = 'bbbb'},\n            ]\n        \",\n        Parent<CasedString>,\n        \"unknown field `c_d`, expected `c_a` or `c_b` for key `p_b` at line 5 column 17\"\n    );\n\n    // Sub-table in the middle of a Vec is missing a field.\n    // FIXME: This location is pretty off.\n    bad!(\n        \"\n            p_a = 'a'\n            [[p_b]]\n            c_a = 'a'\n            c_b = 'b'\n            [[p_b]]\n            c_a = 'aa'\n            # c_b = 'bb' # <- missing field\n            [[p_b]]\n            c_a = 'aaa'\n            c_b = 'bbb'\n            [[p_b]]\n          # ^\n            c_a = 'aaaa'\n            c_b = 'bbbb'\n        \",\n        Parent<CasedString>,\n        \"missing field `c_b` for key `p_b` at line 12 column 13\"\n    );\n\n    // Sub-table in the middle of a Vec has a field with a bad value.\n    bad!(\n        \"\n            p_a = 'a'\n            [[p_b]]\n            c_a = 'a'\n            c_b = 'b'\n            [[p_b]]\n            c_a = 'aa'\n            c_b = '*'\n                # ^\n            [[p_b]]\n            c_a = 'aaa'\n            c_b = 'bbb'\n        \",\n        Parent<CasedString>,\n        \"invalid value: string \\\"*\\\", expected all lowercase or all uppercase for key `p_b.c_b` at line 8 column 19\"\n    );\n\n    // Sub-table in the middle of a Vec has an extra field.\n    // FIXME: This location is pretty off.\n    bad!(\n        \"\n            p_a = 'a'\n            [[p_b]]\n            c_a = 'a'\n            c_b = 'b'\n            [[p_b]]\n            c_a = 'aa'\n            c_d = 'dd' # unknown field\n            [[p_b]]\n            c_a = 'aaa'\n            c_b = 'bbb'\n            [[p_b]]\n          # ^\n            c_a = 'aaaa'\n            c_b = 'bbbb'\n        \",\n        Parent<CasedString>,\n        \"unknown field `c_d`, expected `c_a` or `c_b` for key `p_b` at line 12 column 13\"\n    );\n}\n\n#[test]\nfn serde_derive_deserialize_errors() {\n    bad!(\n        \"\n            p_a = ''\n          # ^\n        \",\n        Parent<String>,\n        \"missing field `p_b` at line 1 column 1\"\n    );\n\n    bad!(\n        \"\n            p_a = ''\n            p_b = [\n                {c_a = ''}\n              # ^\n            ]\n        \",\n        Parent<String>,\n        \"missing field `c_b` for key `p_b` at line 4 column 17\"\n    );\n\n    bad!(\n        \"\n            p_a = ''\n            p_b = [\n                {c_a = '', c_b = 1}\n                               # ^\n            ]\n        \",\n        Parent<String>,\n        \"invalid type: integer `1`, expected a string for key `p_b` at line 4 column 34\"\n    );\n\n    // FIXME: This location could be better.\n    bad!(\n        \"\n            p_a = ''\n            p_b = [\n                {c_a = '', c_b = '', c_d = ''},\n              # ^\n            ]\n        \",\n        Parent<String>,\n        \"unknown field `c_d`, expected `c_a` or `c_b` for key `p_b` at line 4 column 17\"\n    );\n\n    bad!(\n        \"\n            p_a = 'a'\n            p_b = [\n                {c_a = '', c_b = 1, c_d = ''},\n                               # ^\n            ]\n        \",\n        Parent<String>,\n        \"invalid type: integer `1`, expected a string for key `p_b` at line 4 column 34\"\n    );\n}\n\n#[test]\nfn error_handles_crlf() {\n    bad!(\n        \"\\r\\n\\\n         [t1]\\r\\n\\\n         [t2]\\r\\n\\\n         a = 1\\r\\n\\\n         a = 2\\r\\n\\\n         \",\n        toml::Value,\n        \"duplicate key: `a` for key `t2` at line 3 column 1\"\n    );\n\n    // Should be the same as above.\n    bad!(\n        \"\\n\\\n         [t1]\\n\\\n         [t2]\\n\\\n         a = 1\\n\\\n         a = 2\\n\\\n         \",\n        toml::Value,\n        \"duplicate key: `a` for key `t2` at line 3 column 1\"\n    );\n}\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":15},{"path":["/","usr","src","toml-rs","test-suite","tests","serde.rs"],"content":"extern crate serde;\nextern crate serde_json;\nextern crate toml;\n#[macro_use]\nextern crate serde_derive;\n\nuse serde::{Deserialize, Deserializer};\nuse std::collections::{BTreeMap, HashSet};\n\nuse toml::map::Map;\nuse toml::Value;\nuse toml::Value::{Array, Float, Integer, Table};\n\nmacro_rules! t {\n    ($e:expr) => {\n        match $e {\n            Ok(t) => t,\n            Err(e) => panic!(\"{} failed with {}\", stringify!($e), e),\n        }\n    };\n}\n\nmacro_rules! equivalent {\n    ($literal:expr, $toml:expr,) => {{\n        let toml = $toml;\n        let literal = $literal;\n\n        // In/out of Value is equivalent\n        println!(\"try_from\");\n        assert_eq!(t!(Value::try_from(literal.clone())), toml);\n        println!(\"try_into\");\n        assert_eq!(literal, t!(toml.clone().try_into()));\n\n        // Through a string equivalent\n        println!(\"to_string(literal)\");\n        assert_eq!(t!(toml::to_string(&literal)), toml.to_string());\n        println!(\"to_string(toml)\");\n        assert_eq!(t!(toml::to_string(&toml)), toml.to_string());\n        println!(\"literal, from_str(toml)\");\n        assert_eq!(literal, t!(toml::from_str(&toml.to_string())));\n        println!(\"toml, from_str(toml)\");\n        assert_eq!(toml, t!(toml::from_str(&toml.to_string())));\n    }};\n}\n\nmacro_rules! error {\n    ($ty:ty, $toml:expr, $msg_parse:expr, $msg_decode:expr) => {{\n        println!(\"attempting parsing\");\n        match toml::from_str::<$ty>(&$toml.to_string()) {\n            Ok(_) => panic!(\"successful\"),\n            Err(e) => assert_eq!(e.to_string(), $msg_parse),\n        }\n\n        println!(\"attempting toml decoding\");\n        match $toml.try_into::<$ty>() {\n            Ok(_) => panic!(\"successful\"),\n            Err(e) => assert_eq!(e.to_string(), $msg_decode),\n        }\n    }};\n}\n\nmacro_rules! map( ($($k:ident: $v:expr),*) => ({\n    let mut _m = Map::new();\n    $(_m.insert(stringify!($k).to_string(), t!(Value::try_from($v)));)*\n    _m\n}) );\n\n#[test]\nfn smoke() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\n    struct Foo {\n        a: isize,\n    }\n\n    equivalent!(Foo { a: 2 }, Table(map! { a: Integer(2) }),);\n}\n\n#[test]\nfn smoke_hyphen() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\n    struct Foo {\n        a_b: isize,\n    }\n\n    equivalent! {\n        Foo { a_b: 2 },\n        Table(map! { a_b: Integer(2) }),\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\n    struct Foo2 {\n        #[serde(rename = \"a-b\")]\n        a_b: isize,\n    }\n\n    let mut m = Map::new();\n    m.insert(\"a-b\".to_string(), Integer(2));\n    equivalent! {\n        Foo2 { a_b: 2 },\n        Table(m),\n    }\n}\n\n#[test]\nfn nested() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\n    struct Foo {\n        a: isize,\n        b: Bar,\n    }\n    #[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\n    struct Bar {\n        a: String,\n    }\n\n    equivalent! {\n        Foo { a: 2, b: Bar { a: \"test\".to_string() } },\n        Table(map! {\n            a: Integer(2),\n            b: Table(map! {\n                a: Value::String(\"test\".to_string())\n            })\n        }),\n    }\n}\n\n#[test]\nfn application_decode_error() {\n    #[derive(PartialEq, Debug)]\n    struct Range10(usize);\n    impl<'de> Deserialize<'de> for Range10 {\n        fn deserialize<D: Deserializer<'de>>(d: D) -> Result<Range10, D::Error> {\n            let x: usize = Deserialize::deserialize(d)?;\n            if x > 10 {\n                Err(serde::de::Error::custom(\"more than 10\"))\n            } else {\n                Ok(Range10(x))\n            }\n        }\n    }\n    let d_good = Integer(5);\n    let d_bad1 = Value::String(\"not an isize\".to_string());\n    let d_bad2 = Integer(11);\n\n    assert_eq!(Range10(5), d_good.try_into().unwrap());\n\n    let err1: Result<Range10, _> = d_bad1.try_into();\n    assert!(err1.is_err());\n    let err2: Result<Range10, _> = d_bad2.try_into();\n    assert!(err2.is_err());\n}\n\n#[test]\nfn array() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\n    struct Foo {\n        a: Vec<isize>,\n    }\n\n    equivalent! {\n        Foo { a: vec![1, 2, 3, 4] },\n        Table(map! {\n            a: Array(vec![\n                Integer(1),\n                Integer(2),\n                Integer(3),\n                Integer(4)\n            ])\n        }),\n    };\n}\n\n#[test]\nfn inner_structs_with_options() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\n    struct Foo {\n        a: Option<Box<Foo>>,\n        b: Bar,\n    }\n    #[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\n    struct Bar {\n        a: String,\n        b: f64,\n    }\n\n    equivalent! {\n        Foo {\n            a: Some(Box::new(Foo {\n                a: None,\n                b: Bar { a: \"foo\".to_string(), b: 4.5 },\n            })),\n            b: Bar { a: \"bar\".to_string(), b: 1.0 },\n        },\n        Table(map! {\n            a: Table(map! {\n                b: Table(map! {\n                    a: Value::String(\"foo\".to_string()),\n                    b: Float(4.5)\n                })\n            }),\n            b: Table(map! {\n                a: Value::String(\"bar\".to_string()),\n                b: Float(1.0)\n            })\n        }),\n    }\n}\n\n#[test]\nfn hashmap() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\n    struct Foo {\n        set: HashSet<char>,\n        map: BTreeMap<String, isize>,\n    }\n\n    equivalent! {\n        Foo {\n            map: {\n                let mut m = BTreeMap::new();\n                m.insert(\"foo\".to_string(), 10);\n                m.insert(\"bar\".to_string(), 4);\n                m\n            },\n            set: {\n                let mut s = HashSet::new();\n                s.insert('a');\n                s\n            },\n        },\n        Table(map! {\n            map: Table(map! {\n                foo: Integer(10),\n                bar: Integer(4)\n            }),\n            set: Array(vec![Value::String(\"a\".to_string())])\n        }),\n    }\n}\n\n#[test]\nfn table_array() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\n    struct Foo {\n        a: Vec<Bar>,\n    }\n    #[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\n    struct Bar {\n        a: isize,\n    }\n\n    equivalent! {\n        Foo { a: vec![Bar { a: 1 }, Bar { a: 2 }] },\n        Table(map! {\n            a: Array(vec![\n                Table(map!{ a: Integer(1) }),\n                Table(map!{ a: Integer(2) }),\n            ])\n        }),\n    }\n}\n\n#[test]\nfn type_errors() {\n    #[derive(Deserialize)]\n    #[allow(dead_code)]\n    struct Foo {\n        bar: isize,\n    }\n\n    error! {\n        Foo,\n        Table(map! {\n            bar: Value::String(\"a\".to_string())\n        }),\n        \"invalid type: string \\\"a\\\", expected isize for key `bar` at line 1 column 7\",\n        \"invalid type: string \\\"a\\\", expected isize for key `bar`\"\n    }\n\n    #[derive(Deserialize)]\n    #[allow(dead_code)]\n    struct Bar {\n        foo: Foo,\n    }\n\n    error! {\n        Bar,\n        Table(map! {\n            foo: Table(map! {\n                bar: Value::String(\"a\".to_string())\n            })\n        }),\n        \"invalid type: string \\\"a\\\", expected isize for key `foo.bar` at line 2 column 7\",\n        \"invalid type: string \\\"a\\\", expected isize for key `foo.bar`\"\n    }\n}\n\n#[test]\nfn missing_errors() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Foo {\n        bar: isize,\n    }\n\n    error! {\n        Foo,\n        Table(map! { }),\n        \"missing field `bar`\",\n        \"missing field `bar`\"\n    }\n}\n\n#[test]\nfn parse_enum() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\n    struct Foo {\n        a: E,\n    }\n    #[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\n    #[serde(untagged)]\n    enum E {\n        Bar(isize),\n        Baz(String),\n        Last(Foo2),\n    }\n    #[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\n    struct Foo2 {\n        test: String,\n    }\n\n    equivalent! {\n        Foo { a: E::Bar(10) },\n        Table(map! { a: Integer(10) }),\n    }\n\n    equivalent! {\n        Foo { a: E::Baz(\"foo\".to_string()) },\n        Table(map! { a: Value::String(\"foo\".to_string()) }),\n    }\n\n    equivalent! {\n        Foo { a: E::Last(Foo2 { test: \"test\".to_string() }) },\n        Table(map! { a: Table(map! { test: Value::String(\"test\".to_string()) }) }),\n    }\n}\n\n#[test]\nfn parse_enum_string() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\n    struct Foo {\n        a: Sort,\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\n    #[serde(rename_all = \"lowercase\")]\n    enum Sort {\n        Asc,\n        Desc,\n    }\n\n    equivalent! {\n        Foo { a: Sort::Desc },\n        Table(map! { a: Value::String(\"desc\".to_string()) }),\n    }\n}\n\n// #[test]\n// fn unused_fields() {\n//     #[derive(Serialize, Deserialize, PartialEq, Debug)]\n//     struct Foo { a: isize }\n//\n//     let v = Foo { a: 2 };\n//     let mut d = Decoder::new(Table(map! {\n//         a, Integer(2),\n//         b, Integer(5)\n//     }));\n//     assert_eq!(v, t!(Deserialize::deserialize(&mut d)));\n//\n//     assert_eq!(d.toml, Some(Table(map! {\n//         b, Integer(5)\n//     })));\n// }\n//\n// #[test]\n// fn unused_fields2() {\n//     #[derive(Serialize, Deserialize, PartialEq, Debug)]\n//     struct Foo { a: Bar }\n//     #[derive(Serialize, Deserialize, PartialEq, Debug)]\n//     struct Bar { a: isize }\n//\n//     let v = Foo { a: Bar { a: 2 } };\n//     let mut d = Decoder::new(Table(map! {\n//         a, Table(map! {\n//             a, Integer(2),\n//             b, Integer(5)\n//         })\n//     }));\n//     assert_eq!(v, t!(Deserialize::deserialize(&mut d)));\n//\n//     assert_eq!(d.toml, Some(Table(map! {\n//         a, Table(map! {\n//             b, Integer(5)\n//         })\n//     })));\n// }\n//\n// #[test]\n// fn unused_fields3() {\n//     #[derive(Serialize, Deserialize, PartialEq, Debug)]\n//     struct Foo { a: Bar }\n//     #[derive(Serialize, Deserialize, PartialEq, Debug)]\n//     struct Bar { a: isize }\n//\n//     let v = Foo { a: Bar { a: 2 } };\n//     let mut d = Decoder::new(Table(map! {\n//         a, Table(map! {\n//             a, Integer(2)\n//         })\n//     }));\n//     assert_eq!(v, t!(Deserialize::deserialize(&mut d)));\n//\n//     assert_eq!(d.toml, None);\n// }\n//\n// #[test]\n// fn unused_fields4() {\n//     #[derive(Serialize, Deserialize, PartialEq, Debug)]\n//     struct Foo { a: BTreeMap<String, String> }\n//\n//     let v = Foo { a: map! { a, \"foo\".to_string() } };\n//     let mut d = Decoder::new(Table(map! {\n//         a, Table(map! {\n//             a, Value::String(\"foo\".to_string())\n//         })\n//     }));\n//     assert_eq!(v, t!(Deserialize::deserialize(&mut d)));\n//\n//     assert_eq!(d.toml, None);\n// }\n//\n// #[test]\n// fn unused_fields5() {\n//     #[derive(Serialize, Deserialize, PartialEq, Debug)]\n//     struct Foo { a: Vec<String> }\n//\n//     let v = Foo { a: vec![\"a\".to_string()] };\n//     let mut d = Decoder::new(Table(map! {\n//         a, Array(vec![Value::String(\"a\".to_string())])\n//     }));\n//     assert_eq!(v, t!(Deserialize::deserialize(&mut d)));\n//\n//     assert_eq!(d.toml, None);\n// }\n//\n// #[test]\n// fn unused_fields6() {\n//     #[derive(Serialize, Deserialize, PartialEq, Debug)]\n//     struct Foo { a: Option<Vec<String>> }\n//\n//     let v = Foo { a: Some(vec![]) };\n//     let mut d = Decoder::new(Table(map! {\n//         a, Array(vec![])\n//     }));\n//     assert_eq!(v, t!(Deserialize::deserialize(&mut d)));\n//\n//     assert_eq!(d.toml, None);\n// }\n//\n// #[test]\n// fn unused_fields7() {\n//     #[derive(Serialize, Deserialize, PartialEq, Debug)]\n//     struct Foo { a: Vec<Bar> }\n//     #[derive(Serialize, Deserialize, PartialEq, Debug)]\n//     struct Bar { a: isize }\n//\n//     let v = Foo { a: vec![Bar { a: 1 }] };\n//     let mut d = Decoder::new(Table(map! {\n//         a, Array(vec![Table(map! {\n//             a, Integer(1),\n//             b, Integer(2)\n//         })])\n//     }));\n//     assert_eq!(v, t!(Deserialize::deserialize(&mut d)));\n//\n//     assert_eq!(d.toml, Some(Table(map! {\n//         a, Array(vec![Table(map! {\n//             b, Integer(2)\n//         })])\n//     })));\n// }\n\n#[test]\nfn empty_arrays() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\n    struct Foo {\n        a: Vec<Bar>,\n    }\n    #[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\n    struct Bar;\n\n    equivalent! {\n        Foo { a: vec![] },\n        Table(map! {a: Array(Vec::new())}),\n    }\n}\n\n#[test]\nfn empty_arrays2() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\n    struct Foo {\n        a: Option<Vec<Bar>>,\n    }\n    #[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\n    struct Bar;\n\n    equivalent! {\n        Foo { a: None },\n        Table(map! {}),\n    }\n\n    equivalent! {\n        Foo { a: Some(vec![]) },\n        Table(map! { a: Array(vec![]) }),\n    }\n}\n\n#[test]\nfn extra_keys() {\n    #[derive(Serialize, Deserialize)]\n    struct Foo {\n        a: isize,\n    }\n\n    let toml = Table(map! { a: Integer(2), b: Integer(2) });\n    assert!(toml.clone().try_into::<Foo>().is_ok());\n    assert!(toml::from_str::<Foo>(&toml.to_string()).is_ok());\n}\n\n#[test]\nfn newtypes() {\n    #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n    struct A {\n        b: B,\n    }\n\n    #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n    struct B(u32);\n\n    equivalent! {\n        A { b: B(2) },\n        Table(map! { b: Integer(2) }),\n    }\n}\n\n#[test]\nfn newtypes2() {\n    #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n    struct A {\n        b: B,\n    }\n\n    #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n    struct B(Option<C>);\n\n    #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n    struct C {\n        x: u32,\n        y: u32,\n        z: u32,\n    }\n\n    equivalent! {\n        A { b: B(Some(C { x: 0, y: 1, z: 2 })) },\n        Table(map! {\n            b: Table(map! {\n                x: Integer(0),\n                y: Integer(1),\n                z: Integer(2)\n            })\n        }),\n    }\n}\n\n#[derive(Debug, Default, PartialEq, Serialize, Deserialize)]\nstruct CanBeEmpty {\n    a: Option<String>,\n    b: Option<String>,\n}\n\n#[test]\nfn table_structs_empty() {\n    let text = \"[bar]\\n\\n[baz]\\n\\n[bazv]\\na = \\\"foo\\\"\\n\\n[foo]\\n\";\n    let value: BTreeMap<String, CanBeEmpty> = toml::from_str(text).unwrap();\n    let mut expected: BTreeMap<String, CanBeEmpty> = BTreeMap::new();\n    expected.insert(\"bar\".to_string(), CanBeEmpty::default());\n    expected.insert(\"baz\".to_string(), CanBeEmpty::default());\n    expected.insert(\n        \"bazv\".to_string(),\n        CanBeEmpty {\n            a: Some(\"foo\".to_string()),\n            b: None,\n        },\n    );\n    expected.insert(\"foo\".to_string(), CanBeEmpty::default());\n    assert_eq!(value, expected);\n    assert_eq!(toml::to_string(&value).unwrap(), text);\n}\n\n#[test]\nfn fixed_size_array() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\n    struct Entity {\n        pos: [i32; 2],\n    }\n\n    equivalent! {\n        Entity { pos: [1, 2] },\n        Table(map! {\n            pos: Array(vec![\n                Integer(1),\n                Integer(2),\n            ])\n        }),\n    }\n}\n\n#[test]\nfn homogeneous_tuple() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\n    struct Collection {\n        elems: (i64, i64, i64),\n    }\n\n    equivalent! {\n        Collection { elems: (0, 1, 2) },\n        Table(map! {\n            elems: Array(vec![\n                Integer(0),\n                Integer(1),\n                Integer(2),\n            ])\n        }),\n    }\n}\n\n#[test]\nfn homogeneous_tuple_struct() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\n    struct Object(Vec<String>, Vec<String>, Vec<String>);\n\n    equivalent! {\n        map! {\n            obj: Object(vec![\"foo\".to_string()], vec![], vec![\"bar\".to_string(), \"baz\".to_string()])\n        },\n        Table(map! {\n            obj: Array(vec![\n                Array(vec![\n                    Value::String(\"foo\".to_string()),\n                ]),\n                Array(vec![]),\n                Array(vec![\n                    Value::String(\"bar\".to_string()),\n                    Value::String(\"baz\".to_string()),\n                ]),\n            ])\n        }),\n    }\n}\n\n#[test]\nfn json_interoperability() {\n    #[derive(Serialize, Deserialize)]\n    struct Foo {\n        any: toml::Value,\n    }\n\n    let _foo: Foo = serde_json::from_str(\n        r#\"\n        {\"any\":1}\n    \"#,\n    )\n    .unwrap();\n}\n","traces":[{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["/","usr","src","toml-rs","tests","enum_external_deserialize.rs"],"content":"#[macro_use]\nextern crate serde_derive;\nextern crate toml;\n\n#[derive(Debug, Deserialize, PartialEq)]\nstruct OuterStruct {\n    inner: TheEnum,\n}\n\n#[derive(Debug, Deserialize, PartialEq)]\nenum TheEnum {\n    Plain,\n    Tuple(i64, bool),\n    NewType(String),\n    Struct { value: i64 },\n}\n\n#[derive(Debug, Deserialize, PartialEq)]\nstruct Val {\n    val: TheEnum,\n}\n\n#[derive(Debug, Deserialize, PartialEq)]\nstruct Multi {\n    enums: Vec<TheEnum>,\n}\n\n#[test]\nfn invalid_variant_returns_error_with_good_message_string() {\n    let error = toml::from_str::<TheEnum>(\"\\\"NonExistent\\\"\").unwrap_err();\n\n    assert_eq!(\n        error.to_string(),\n        \"unknown variant `NonExistent`, expected one of `Plain`, `Tuple`, `NewType`, `Struct`\"\n    );\n}\n\n#[test]\nfn invalid_variant_returns_error_with_good_message_inline_table() {\n    let error = toml::from_str::<TheEnum>(\"{ NonExistent = {} }\").unwrap_err();\n    assert_eq!(\n        error.to_string(),\n        \"unknown variant `NonExistent`, expected one of `Plain`, `Tuple`, `NewType`, `Struct`\"\n    );\n}\n\n#[test]\nfn extra_field_returns_expected_empty_table_error() {\n    let error = toml::from_str::<TheEnum>(\"{ Plain = { extra_field = 404 } }\").unwrap_err();\n\n    assert_eq!(error.to_string(), \"expected empty table\");\n}\n\n#[test]\nfn extra_field_returns_expected_empty_table_error_struct_variant() {\n    let error = toml::from_str::<TheEnum>(\"{ Struct = { value = 123, extra_0 = 0, extra_1 = 1 } }\")\n        .unwrap_err();\n\n    assert_eq!(\n        error.to_string(),\n        r#\"unexpected keys in table: `[\"extra_0\", \"extra_1\"]`, available keys: `[\"value\"]`\"#\n    );\n}\n\nmod enum_unit {\n    use super::*;\n\n    #[test]\n    fn from_str() {\n        assert_eq!(TheEnum::Plain, toml::from_str(\"\\\"Plain\\\"\").unwrap());\n    }\n\n    #[test]\n    fn from_inline_table() {\n        assert_eq!(TheEnum::Plain, toml::from_str(\"{ Plain = {} }\").unwrap());\n        assert_eq!(\n            Val {\n                val: TheEnum::Plain\n            },\n            toml::from_str(\"val = { Plain = {} }\").unwrap()\n        );\n    }\n\n    #[test]\n    fn from_dotted_table() {\n        assert_eq!(TheEnum::Plain, toml::from_str(\"[Plain]\\n\").unwrap());\n    }\n}\n\nmod enum_tuple {\n    use super::*;\n\n    #[test]\n    fn from_inline_table() {\n        assert_eq!(\n            TheEnum::Tuple(-123, true),\n            toml::from_str(\"{ Tuple = { 0 = -123, 1 = true } }\").unwrap()\n        );\n        assert_eq!(\n            Val {\n                val: TheEnum::Tuple(-123, true)\n            },\n            toml::from_str(\"val = { Tuple = { 0 = -123, 1 = true } }\").unwrap()\n        );\n    }\n\n    #[test]\n    fn from_dotted_table() {\n        assert_eq!(\n            TheEnum::Tuple(-123, true),\n            toml::from_str(\n                r#\"[Tuple]\n                0 = -123\n                1 = true\n                \"#\n            )\n            .unwrap()\n        );\n    }\n}\n\nmod enum_newtype {\n    use super::*;\n\n    #[test]\n    fn from_inline_table() {\n        assert_eq!(\n            TheEnum::NewType(\"value\".to_string()),\n            toml::from_str(r#\"{ NewType = \"value\" }\"#).unwrap()\n        );\n        assert_eq!(\n            Val {\n                val: TheEnum::NewType(\"value\".to_string()),\n            },\n            toml::from_str(r#\"val = { NewType = \"value\" }\"#).unwrap()\n        );\n    }\n\n    #[test]\n    #[ignore = \"Unimplemented: https://github.com/alexcrichton/toml-rs/pull/264#issuecomment-431707209\"]\n    fn from_dotted_table() {\n        assert_eq!(\n            TheEnum::NewType(\"value\".to_string()),\n            toml::from_str(r#\"NewType = \"value\"\"#).unwrap()\n        );\n        assert_eq!(\n            Val {\n                val: TheEnum::NewType(\"value\".to_string()),\n            },\n            toml::from_str(\n                r#\"[val]\n                NewType = \"value\"\n                \"#\n            )\n            .unwrap()\n        );\n    }\n}\n\nmod enum_struct {\n    use super::*;\n\n    #[test]\n    fn from_inline_table() {\n        assert_eq!(\n            TheEnum::Struct { value: -123 },\n            toml::from_str(\"{ Struct = { value = -123 } }\").unwrap()\n        );\n        assert_eq!(\n            Val {\n                val: TheEnum::Struct { value: -123 }\n            },\n            toml::from_str(\"val = { Struct = { value = -123 } }\").unwrap()\n        );\n    }\n\n    #[test]\n    fn from_dotted_table() {\n        assert_eq!(\n            TheEnum::Struct { value: -123 },\n            toml::from_str(\n                r#\"[Struct]\n                value = -123\n                \"#\n            )\n            .unwrap()\n        );\n    }\n\n    #[test]\n    fn from_nested_dotted_table() {\n        assert_eq!(\n            OuterStruct {\n                inner: TheEnum::Struct { value: -123 }\n            },\n            toml::from_str(\n                r#\"[inner.Struct]\n                value = -123\n                \"#\n            )\n            .unwrap()\n        );\n    }\n}\n\nmod enum_array {\n    use super::*;\n\n    #[test]\n    fn from_inline_tables() {\n        let toml_str = r#\"\n            enums = [\n                { Plain = {} },\n                { Tuple = { 0 = -123, 1 = true } },\n                { NewType = \"value\" },\n                { Struct = { value = -123 } }\n            ]\"#;\n        assert_eq!(\n            Multi {\n                enums: vec![\n                    TheEnum::Plain,\n                    TheEnum::Tuple(-123, true),\n                    TheEnum::NewType(\"value\".to_string()),\n                    TheEnum::Struct { value: -123 },\n                ]\n            },\n            toml::from_str(toml_str).unwrap()\n        );\n    }\n\n    #[test]\n    #[ignore = \"Unimplemented: https://github.com/alexcrichton/toml-rs/pull/264#issuecomment-431707209\"]\n    fn from_dotted_table() {\n        let toml_str = r#\"[[enums]]\n            Plain = {}\n\n            [[enums]]\n            Tuple = { 0 = -123, 1 = true }\n\n            [[enums]]\n            NewType = \"value\"\n\n            [[enums]]\n            Struct = { value = -123 }\n            \"#;\n        assert_eq!(\n            Multi {\n                enums: vec![\n                    TheEnum::Plain,\n                    TheEnum::Tuple(-123, true),\n                    TheEnum::NewType(\"value\".to_string()),\n                    TheEnum::Struct { value: -123 },\n                ]\n            },\n            toml::from_str(toml_str).unwrap()\n        );\n    }\n}\n","traces":[{"line":29,"address":[4310624,4310629],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":30,"address":[4334318,4334360],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[4334512,4334402],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[4334378],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[4310661,4310656],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":40,"address":[4335000,4334958],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[4335152,4335042],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[4335018],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[4310688,4310693],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":49,"address":[4335640,4335598],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[4335658,4335792],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[4310725,4310720],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":59,"address":[4336322,4336432],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[4336298],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[4289381,4289376],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":70,"address":[4280622,4280679],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[4289408,4289413],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":75,"address":[4281166,4281226],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[4281748,4281817],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[4281755],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[4282304,4282353],"length":1,"stats":{"Line":3},"fn_name":"from_dotted_table"},{"line":86,"address":[4282318,4282375],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[4220933,4220928],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":95,"address":[4215182,4215274],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[4215242,4215189],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[4215764,4215833],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[4215771],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[4220965,4220960],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":109,"address":[4216334,4216417],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[4216341,4216391],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[4245621,4245616],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":127,"address":[4328124,4328071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[4328004,4327966],"length":1,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[4328086,4328044],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[4328791,4328735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[4328676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[4328615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[4328708,4328753],"length":1,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[4278324,4278272],"length":1,"stats":{"Line":3},"fn_name":"from_inline_table"},{"line":165,"address":[4278286,4278378],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[4278346,4278293],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[4278868,4278937],"length":1,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[4278875],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[4279473,4279424],"length":1,"stats":{"Line":3},"fn_name":"from_dotted_table"},{"line":179,"address":[4279521,4279438],"length":1,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[4279445,4279495],"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[4279968,4280017],"length":1,"stats":{"Line":3},"fn_name":"from_nested_dotted_table"},{"line":192,"address":[4279982,4280065],"length":1,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[4279989,4280039],"length":1,"stats":{"Line":2},"fn_name":null},{"line":210,"address":[4212160,4212165],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":211,"address":[4324487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[4325025,4325075],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[4324969],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[4324691,4324524],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[4324537],"length":1,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[4324545],"length":1,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[4324615,4324573],"length":1,"stats":{"Line":2},"fn_name":null},{"line":224,"address":[4324671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[4324998,4325040],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":59,"coverable":59}]}