{"files":[{"path":["/","home","kms","itertools","benches","bench1.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, Criterion};\nuse itertools::Itertools;\nuse itertools::free::cloned;\nuse itertools::iproduct;\n\nuse std::iter::repeat;\nuse std::cmp;\nuse std::ops::{Add, Range};\n\nmod extra;\n\nuse crate::extra::ZipSlices;\n\nfn slice_iter(c: &mut Criterion) {\n    let xs: Vec<_> = repeat(1i32).take(20).collect();\n\n    c.bench_function(\"slice iter\", move |b| {\n        b.iter(|| for elt in xs.iter() {\n            black_box(elt);\n        })\n    });\n}\n\nfn slice_iter_rev(c: &mut Criterion) {\n    let xs: Vec<_> = repeat(1i32).take(20).collect();\n\n    c.bench_function(\"slice iter rev\", move |b| {\n        b.iter(|| for elt in xs.iter().rev() {\n            black_box(elt);\n        })\n    });\n}\n\nfn zip_default_zip(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zip default zip\", move |b| {\n        b.iter(|| {\n            for (&x, &y) in xs.iter().zip(&ys) {\n                black_box(x);\n                black_box(y);\n            }\n        })\n    });\n}\n\nfn zipdot_i32_default_zip(c: &mut Criterion) {\n    let xs = vec![2; 1024];\n    let ys = vec![2; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot i32 default zip\", move |b| {\n        b.iter(|| {\n            let mut s = 0;\n            for (&x, &y) in xs.iter().zip(&ys) {\n                s += x * y;\n            }\n            s\n        })\n    });\n}\n\nfn zipdot_f32_default_zip(c: &mut Criterion) {\n    let xs = vec![2f32; 1024];\n    let ys = vec![2f32; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot f32 default zip\", move |b| {\n        b.iter(|| {\n            let mut s = 0.;\n            for (&x, &y) in xs.iter().zip(&ys) {\n                s += x * y;\n            }\n            s\n        })\n    });\n}\n\nfn zip_default_zip3(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n    let zs = vec![0; 766];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n    let zs = black_box(zs);\n\n    c.bench_function(\"zip default zip3\", move |b| {\n        b.iter(|| {\n            for ((&x, &y), &z) in xs.iter().zip(&ys).zip(&zs) {\n                black_box(x);\n                black_box(y);\n                black_box(z);\n            }\n        })\n    });\n}\n\nfn zip_slices_ziptuple(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n\n    c.bench_function(\"zip slices ziptuple\", move |b| {\n        b.iter(|| {\n            let xs = black_box(&xs);\n            let ys = black_box(&ys);\n            for (&x, &y) in itertools::multizip((xs, ys)) {\n                black_box(x);\n                black_box(y);\n            }\n        })\n    });\n}\n\nfn zipslices(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipslices\", move |b| {\n        b.iter(|| {\n            for (&x, &y) in ZipSlices::new(&xs, &ys) {\n                black_box(x);\n                black_box(y);\n            }\n        })\n    });\n}\n\nfn zipslices_mut(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n    let xs = black_box(xs);\n    let mut ys = black_box(ys);\n\n    c.bench_function(\"zipslices mut\", move |b| {\n        b.iter(|| {\n            for (&x, &mut y) in ZipSlices::from_slices(&xs[..], &mut ys[..]) {\n                black_box(x);\n                black_box(y);\n            }\n        })\n    });\n}\n\nfn zipdot_i32_zipslices(c: &mut Criterion) {\n    let xs = vec![2; 1024];\n    let ys = vec![2; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot i32 zipslices\", move |b| {\n        b.iter(|| {\n            let mut s = 0i32;\n            for (&x, &y) in ZipSlices::new(&xs, &ys) {\n                s += x * y;\n            }\n            s\n        })\n    });\n}\n\nfn zipdot_f32_zipslices(c: &mut Criterion) {\n    let xs = vec![2f32; 1024];\n    let ys = vec![2f32; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot f32 zipslices\", move |b| {\n        b.iter(|| {\n            let mut s = 0.;\n            for (&x, &y) in ZipSlices::new(&xs, &ys) {\n                s += x * y;\n            }\n            s\n        })\n    });\n}\n\nfn zip_checked_counted_loop(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zip checked counted loop\", move |b| {\n        b.iter(|| {\n            // Must slice to equal lengths, and then bounds checks are eliminated!\n            let len = cmp::min(xs.len(), ys.len());\n            let xs = &xs[..len];\n            let ys = &ys[..len];\n\n            for i in 0..len {\n                let x = xs[i];\n                let y = ys[i];\n                black_box(x);\n                black_box(y);\n            }\n        })\n    });\n}\n\nfn zipdot_i32_checked_counted_loop(c: &mut Criterion) {\n    let xs = vec![2; 1024];\n    let ys = vec![2; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot i32 checked counted loop\", move |b| {\n        b.iter(|| {\n            // Must slice to equal lengths, and then bounds checks are eliminated!\n            let len = cmp::min(xs.len(), ys.len());\n            let xs = &xs[..len];\n            let ys = &ys[..len];\n\n            let mut s = 0i32;\n\n            for i in 0..len {\n                s += xs[i] * ys[i];\n            }\n            s\n        })\n    });\n}\n\nfn zipdot_f32_checked_counted_loop(c: &mut Criterion) {\n    let xs = vec![2f32; 1024];\n    let ys = vec![2f32; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot f32 checked counted loop\", move |b| {\n        b.iter(|| {\n            // Must slice to equal lengths, and then bounds checks are eliminated!\n            let len = cmp::min(xs.len(), ys.len());\n            let xs = &xs[..len];\n            let ys = &ys[..len];\n\n            let mut s = 0.;\n\n            for i in 0..len {\n                s += xs[i] * ys[i];\n            }\n            s\n        })\n    });\n}\n\nfn zipdot_f32_checked_counted_unrolled_loop(c: &mut Criterion) {\n    let xs = vec![2f32; 1024];\n    let ys = vec![2f32; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot f32 checked counted unrolled loop\", move |b| {\n        b.iter(|| {\n            // Must slice to equal lengths, and then bounds checks are eliminated!\n            let len = cmp::min(xs.len(), ys.len());\n            let mut xs = &xs[..len];\n            let mut ys = &ys[..len];\n\n            let mut s = 0.;\n            let (mut p0, mut p1, mut p2, mut p3, mut p4, mut p5, mut p6, mut p7) =\n                (0., 0., 0., 0., 0., 0., 0., 0.);\n\n            // how to unroll and have bounds checks eliminated (by cristicbz)\n            // split sum into eight parts to enable vectorization (by bluss)\n            while xs.len() >= 8 {\n                p0 += xs[0] * ys[0];\n                p1 += xs[1] * ys[1];\n                p2 += xs[2] * ys[2];\n                p3 += xs[3] * ys[3];\n                p4 += xs[4] * ys[4];\n                p5 += xs[5] * ys[5];\n                p6 += xs[6] * ys[6];\n                p7 += xs[7] * ys[7];\n\n                xs = &xs[8..];\n                ys = &ys[8..];\n            }\n            s += p0 + p4;\n            s += p1 + p5;\n            s += p2 + p6;\n            s += p3 + p7;\n\n            for i in 0..xs.len() {\n                s += xs[i] * ys[i];\n            }\n            s\n        })\n    });\n}\n\nfn zip_unchecked_counted_loop(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zip unchecked counted loop\", move |b| {\n        b.iter(|| {\n            let len = cmp::min(xs.len(), ys.len());\n            for i in 0..len {\n                unsafe {\n                let x = *xs.get_unchecked(i);\n                let y = *ys.get_unchecked(i);\n                black_box(x);\n                black_box(y);\n                }\n            }\n        })\n    });\n}\n\nfn zipdot_i32_unchecked_counted_loop(c: &mut Criterion) {\n    let xs = vec![2; 1024];\n    let ys = vec![2; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot i32 unchecked counted loop\", move |b| {\n        b.iter(|| {\n            let len = cmp::min(xs.len(), ys.len());\n            let mut s = 0i32;\n            for i in 0..len {\n                unsafe {\n                let x = *xs.get_unchecked(i);\n                let y = *ys.get_unchecked(i);\n                s += x * y;\n                }\n            }\n            s\n        })\n    });\n}\n\nfn zipdot_f32_unchecked_counted_loop(c: &mut Criterion) {\n    let xs = vec![2.; 1024];\n    let ys = vec![2.; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot f32 unchecked counted loop\", move |b| {\n        b.iter(|| {\n            let len = cmp::min(xs.len(), ys.len());\n            let mut s = 0f32;\n            for i in 0..len {\n                unsafe {\n                let x = *xs.get_unchecked(i);\n                let y = *ys.get_unchecked(i);\n                s += x * y;\n                }\n            }\n            s\n        })\n    });\n}\n\nfn zip_unchecked_counted_loop3(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n    let zs = vec![0; 766];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n    let zs = black_box(zs);\n\n    c.bench_function(\"zip unchecked counted loop3\", move |b| {\n        b.iter(|| {\n            let len = cmp::min(xs.len(), cmp::min(ys.len(), zs.len()));\n            for i in 0..len {\n                unsafe {\n                let x = *xs.get_unchecked(i);\n                let y = *ys.get_unchecked(i);\n                let z = *zs.get_unchecked(i);\n                black_box(x);\n                black_box(y);\n                black_box(z);\n                }\n            }\n        })\n    });\n}\n\nfn group_by_lazy_1(c: &mut Criterion) {\n    let mut data = vec![0; 1024];\n    for (index, elt) in data.iter_mut().enumerate() {\n        *elt = index / 10;\n    }\n\n    let data = black_box(data);\n\n    c.bench_function(\"group by lazy 1\", move |b| {\n        b.iter(|| {\n            for (_key, group) in &data.iter().group_by(|elt| **elt) {\n                for elt in group {\n                    black_box(elt);\n                }\n            }\n        })\n    });\n}\n\nfn group_by_lazy_2(c: &mut Criterion) {\n    let mut data = vec![0; 1024];\n    for (index, elt) in data.iter_mut().enumerate() {\n        *elt = index / 2;\n    }\n\n    let data = black_box(data);\n\n    c.bench_function(\"group by lazy 2\", move |b| {\n        b.iter(|| {\n            for (_key, group) in &data.iter().group_by(|elt| **elt) {\n                for elt in group {\n                    black_box(elt);\n                }\n            }\n        })\n    });\n}\n\nfn slice_chunks(c: &mut Criterion) {\n    let data = vec![0; 1024];\n\n    let data = black_box(data);\n    let sz = black_box(10);\n\n    c.bench_function(\"slice chunks\", move |b| {\n        b.iter(|| {\n            for group in data.chunks(sz) {\n                for elt in group {\n                    black_box(elt);\n                }\n            }\n        })\n    });\n}\n\nfn chunks_lazy_1(c: &mut Criterion) {\n    let data = vec![0; 1024];\n\n    let data = black_box(data);\n    let sz = black_box(10);\n\n    c.bench_function(\"chunks lazy 1\", move |b| {\n        b.iter(|| {\n            for group in &data.iter().chunks(sz) {\n                for elt in group {\n                    black_box(elt);\n                }\n            }\n        })\n    });\n}\n\nfn equal(c: &mut Criterion) {\n    let data = vec![7; 1024];\n    let l = data.len();\n    let alpha = black_box(&data[1..]);\n    let beta = black_box(&data[..l - 1]);\n\n    c.bench_function(\"equal\", move |b| {\n        b.iter(|| {\n            itertools::equal(alpha, beta)\n        })\n    });\n}\n\nfn merge_default(c: &mut Criterion) {\n    let mut data1 = vec![0; 1024];\n    let mut data2 = vec![0; 800];\n    let mut x = 0;\n    for (_, elt) in data1.iter_mut().enumerate() {\n        *elt = x;\n        x += 1;\n    }\n\n    let mut y = 0;\n    for (i, elt) in data2.iter_mut().enumerate() {\n        *elt += y;\n        if i % 3 == 0 {\n            y += 3;\n        } else {\n            y += 0;\n        }\n    }\n    let data1 = black_box(data1);\n    let data2 = black_box(data2);\n\n    c.bench_function(\"merge default\", move |b| {\n        b.iter(|| {\n            data1.iter().merge(&data2).count()\n        })\n    });\n}\n\nfn merge_by_cmp(c: &mut Criterion) {\n    let mut data1 = vec![0; 1024];\n    let mut data2 = vec![0; 800];\n    let mut x = 0;\n    for (_, elt) in data1.iter_mut().enumerate() {\n        *elt = x;\n        x += 1;\n    }\n\n    let mut y = 0;\n    for (i, elt) in data2.iter_mut().enumerate() {\n        *elt += y;\n        if i % 3 == 0 {\n            y += 3;\n        } else {\n            y += 0;\n        }\n    }\n    let data1 = black_box(data1);\n    let data2 = black_box(data2);\n\n    c.bench_function(\"merge by cmp\", move |b| {\n        b.iter(|| {\n            data1.iter().merge_by(&data2, PartialOrd::le).count()\n        })\n    });\n}\n\nfn merge_by_lt(c: &mut Criterion) {\n    let mut data1 = vec![0; 1024];\n    let mut data2 = vec![0; 800];\n    let mut x = 0;\n    for (_, elt) in data1.iter_mut().enumerate() {\n        *elt = x;\n        x += 1;\n    }\n\n    let mut y = 0;\n    for (i, elt) in data2.iter_mut().enumerate() {\n        *elt += y;\n        if i % 3 == 0 {\n            y += 3;\n        } else {\n            y += 0;\n        }\n    }\n    let data1 = black_box(data1);\n    let data2 = black_box(data2);\n\n    c.bench_function(\"merge by lt\", move |b| {\n        b.iter(|| {\n            data1.iter().merge_by(&data2, |a, b| a <= b).count()\n        })\n    });\n}\n\nfn kmerge_default(c: &mut Criterion) {\n    let mut data1 = vec![0; 1024];\n    let mut data2 = vec![0; 800];\n    let mut x = 0;\n    for (_, elt) in data1.iter_mut().enumerate() {\n        *elt = x;\n        x += 1;\n    }\n\n    let mut y = 0;\n    for (i, elt) in data2.iter_mut().enumerate() {\n        *elt += y;\n        if i % 3 == 0 {\n            y += 3;\n        } else {\n            y += 0;\n        }\n    }\n    let data1 = black_box(data1);\n    let data2 = black_box(data2);\n    let its = &[data1.iter(), data2.iter()];\n\n    c.bench_function(\"kmerge default\", move |b| {\n        b.iter(|| {\n            its.iter().cloned().kmerge().count()\n        })\n    });\n}\n\nfn kmerge_tenway(c: &mut Criterion) {\n    let mut data = vec![0; 10240];\n\n    let mut state = 1729u16;\n    fn rng(state: &mut u16) -> u16 {\n        let new = state.wrapping_mul(31421) + 6927;\n        *state = new;\n        new\n    }\n\n    for elt in &mut data {\n        *elt = rng(&mut state);\n    }\n\n    let mut chunks = Vec::new();\n    let mut rest = &mut data[..];\n    while rest.len() > 0 {\n        let chunk_len = 1 + rng(&mut state) % 512;\n        let chunk_len = cmp::min(rest.len(), chunk_len as usize);\n        let (fst, tail) = {rest}.split_at_mut(chunk_len);\n        fst.sort();\n        chunks.push(fst.iter().cloned());\n        rest = tail;\n    }\n\n    // println!(\"Chunk lengths: {}\", chunks.iter().format_with(\", \", |elt, f| f(&elt.len())));\n\n    c.bench_function(\"kmerge tenway\", move |b| {\n        b.iter(|| {\n            chunks.iter().cloned().kmerge().count()\n        })\n    });\n}\n\nfn fast_integer_sum<I>(iter: I) -> I::Item\n    where I: IntoIterator,\n          I::Item: Default + Add<Output=I::Item>\n{\n    iter.into_iter().fold(<_>::default(), |x, y| x + y)\n}\n\nfn step_vec_2(c: &mut Criterion) {\n    let v = vec![0; 1024];\n\n    c.bench_function(\"step vec 2\", move |b| {\n        b.iter(|| {\n            fast_integer_sum(cloned(v.iter().step_by(2)))\n        })\n    });\n}\n\nfn step_vec_10(c: &mut Criterion) {\n    let v = vec![0; 1024];\n\n    c.bench_function(\"step vec 10\", move |b| {\n        b.iter(|| {\n            fast_integer_sum(cloned(v.iter().step_by(10)))\n        })\n    });\n}\n\nfn step_range_2(c: &mut Criterion) {\n    let v = black_box(0..1024);\n\n    c.bench_function(\"step range 2\", move |b| {\n        b.iter(|| {\n            fast_integer_sum(v.clone().step_by(2))\n        })\n    });\n}\n\nfn step_range_10(c: &mut Criterion) {\n    let v = black_box(0..1024);\n\n    c.bench_function(\"step range 10\", move |b| {\n        b.iter(|| {\n            fast_integer_sum(v.clone().step_by(10))\n        })\n    });\n}\n\nfn cartesian_product_iterator(c: &mut Criterion) {\n    let xs = vec![0; 16];\n\n    c.bench_function(\"cartesian product iterator\", move |b| {\n        b.iter(|| {\n            let mut sum = 0;\n            for (&x, &y, &z) in iproduct!(&xs, &xs, &xs) {\n                sum += x;\n                sum += y;\n                sum += z;\n            }\n            sum\n        })\n    });\n}\n\nfn cartesian_product_fold(c: &mut Criterion) {\n    let xs = vec![0; 16];\n\n    c.bench_function(\"cartesian product fold\", move |b| {\n        b.iter(|| {\n            let mut sum = 0;\n            iproduct!(&xs, &xs, &xs).fold((), |(), (&x, &y, &z)| {\n                sum += x;\n                sum += y;\n                sum += z;\n            });\n            sum\n        })\n    });\n}\n\nfn multi_cartesian_product_iterator(c: &mut Criterion) {\n    let xs = [vec![0; 16], vec![0; 16], vec![0; 16]];\n\n    c.bench_function(\"multi cartesian product iterator\", move |b| {\n        b.iter(|| {\n            let mut sum = 0;\n            for x in xs.iter().multi_cartesian_product() {\n                sum += x[0];\n                sum += x[1];\n                sum += x[2];\n            }\n            sum\n        })\n    });\n}\n\nfn multi_cartesian_product_fold(c: &mut Criterion) {\n    let xs = [vec![0; 16], vec![0; 16], vec![0; 16]];\n\n    c.bench_function(\"multi cartesian product fold\", move |b| {\n        b.iter(|| {\n            let mut sum = 0;\n            xs.iter().multi_cartesian_product().fold((), |(), x| {\n                sum += x[0];\n                sum += x[1];\n                sum += x[2];\n            });\n            sum\n        })\n    });\n}\n\nfn cartesian_product_nested_for(c: &mut Criterion) {\n    let xs = vec![0; 16];\n\n    c.bench_function(\"cartesian product nested for\", move |b| {\n        b.iter(|| {\n            let mut sum = 0;\n            for &x in &xs {\n                for &y in &xs {\n                    for &z in &xs {\n                        sum += x;\n                        sum += y;\n                        sum += z;\n                    }\n                }\n            }\n            sum\n        })\n    });\n}\n\nfn all_equal(c: &mut Criterion) {\n    let mut xs = vec![0; 5_000_000];\n    xs.extend(vec![1; 5_000_000]);\n\n    c.bench_function(\"all equal\", move |b| {\n        b.iter(|| xs.iter().all_equal())\n    });\n}\n\nfn all_equal_for(c: &mut Criterion) {\n    let mut xs = vec![0; 5_000_000];\n    xs.extend(vec![1; 5_000_000]);\n\n    c.bench_function(\"all equal for\", move |b| {\n        b.iter(|| {\n            for &x in &xs {\n                if x != xs[0] {\n                    return false;\n                }\n            }\n            true\n        })\n    });\n}\n\nfn all_equal_default(c: &mut Criterion) {\n    let mut xs = vec![0; 5_000_000];\n    xs.extend(vec![1; 5_000_000]);\n\n    c.bench_function(\"all equal default\", move |b| {\n        b.iter(|| xs.iter().dedup().nth(1).is_none())\n    });\n}\n\nconst PERM_COUNT: usize = 6;\n\nfn permutations_iter(c: &mut Criterion) {\n    struct NewIterator(Range<usize>);\n\n    impl Iterator for NewIterator {\n        type Item = usize;\n\n        fn next(&mut self) -> Option<Self::Item> {\n            self.0.next()\n        }\n    }\n\n    c.bench_function(\"permutations iter\", move |b| {\n        b.iter(|| {\n            for _ in NewIterator(0..PERM_COUNT).permutations(PERM_COUNT) {\n\n            }\n        })\n    });\n}\n\nfn permutations_range(c: &mut Criterion) {\n    c.bench_function(\"permutations range\", move |b| {\n        b.iter(|| {\n            for _ in (0..PERM_COUNT).permutations(PERM_COUNT) {\n\n            }\n        })\n    });\n}\n\nfn permutations_slice(c: &mut Criterion) {\n    let v = (0..PERM_COUNT).collect_vec();\n\n    c.bench_function(\"permutations slice\", move |b| {\n        b.iter(|| {\n            for _ in v.as_slice().iter().permutations(PERM_COUNT) {\n\n            }\n        })\n    });\n}\n\ncriterion_group!(\n    benches,\n    slice_iter,\n    slice_iter_rev,\n    zip_default_zip,\n    zipdot_i32_default_zip,\n    zipdot_f32_default_zip,\n    zip_default_zip3,\n    zip_slices_ziptuple,\n    zipslices,\n    zipslices_mut,\n    zipdot_i32_zipslices,\n    zipdot_f32_zipslices,\n    zip_checked_counted_loop,\n    zipdot_i32_checked_counted_loop,\n    zipdot_f32_checked_counted_loop,\n    zipdot_f32_checked_counted_unrolled_loop,\n    zip_unchecked_counted_loop,\n    zipdot_i32_unchecked_counted_loop,\n    zipdot_f32_unchecked_counted_loop,\n    zip_unchecked_counted_loop3,\n    group_by_lazy_1,\n    group_by_lazy_2,\n    slice_chunks,\n    chunks_lazy_1,\n    equal,\n    merge_default,\n    merge_by_cmp,\n    merge_by_lt,\n    kmerge_default,\n    kmerge_tenway,\n    step_vec_2,\n    step_vec_10,\n    step_range_2,\n    step_range_10,\n    cartesian_product_iterator,\n    cartesian_product_fold,\n    multi_cartesian_product_iterator,\n    multi_cartesian_product_fold,\n    cartesian_product_nested_for,\n    all_equal,\n    all_equal_for,\n    all_equal_default,\n    permutations_iter,\n    permutations_range,\n    permutations_slice,\n);\ncriterion_main!(benches);\n","traces":[{"line":794,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":795,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","kms","itertools","benches","extra","zipslices.rs"],"content":"use std::cmp;\n\n// Note: There are different ways to implement ZipSlices.\n// This version performed the best in benchmarks.\n//\n// I also implemented a version with three pointes (tptr, tend, uptr),\n// that mimiced slice::Iter and only checked bounds by using tptr == tend,\n// but that was inferior to this solution.\n\n/// An iterator which iterates two slices simultaneously.\n///\n/// `ZipSlices` acts like a double-ended `.zip()` iterator.\n///\n/// It was intended to be more efficient than `.zip()`, and it was, then\n/// rustc changed how it optimizes so it can not promise improved performance\n/// at this time.\n///\n/// Note that elements past the end of the shortest of the two slices are ignored.\n///\n/// Iterator element type for `ZipSlices<T, U>` is `(T::Item, U::Item)`. For example,\n/// for a `ZipSlices<&'a [A], &'b mut [B]>`, the element type is `(&'a A, &'b mut B)`.\n#[derive(Clone)]\npub struct ZipSlices<T, U> {\n    t: T,\n    u: U,\n    len: usize,\n    index: usize,\n}\n\nimpl<'a, 'b, A, B> ZipSlices<&'a [A], &'b [B]> {\n    /// Create a new `ZipSlices` from slices `a` and `b`.\n    ///\n    /// Act like a double-ended `.zip()` iterator, but more efficiently.\n    ///\n    /// Note that elements past the end of the shortest of the two slices are ignored.\n    #[inline(always)]\n    pub fn new(a: &'a [A], b: &'b [B]) -> Self {\n        let minl = cmp::min(a.len(), b.len());\n        ZipSlices {\n            t: a,\n            u: b,\n            len: minl,\n            index: 0,\n        }\n    }\n}\n\nimpl<T, U> ZipSlices<T, U>\n    where T: Slice,\n          U: Slice\n{\n    /// Create a new `ZipSlices` from slices `a` and `b`.\n    ///\n    /// Act like a double-ended `.zip()` iterator, but more efficiently.\n    ///\n    /// Note that elements past the end of the shortest of the two slices are ignored.\n    #[inline(always)]\n    pub fn from_slices(a: T, b: U) -> Self {\n        let minl = cmp::min(a.len(), b.len());\n        ZipSlices {\n            t: a,\n            u: b,\n            len: minl,\n            index: 0,\n        }\n    }\n}\n\nimpl<T, U> Iterator for ZipSlices<T, U>\n    where T: Slice,\n          U: Slice\n{\n    type Item = (T::Item, U::Item);\n\n    #[inline(always)]\n    fn next(&mut self) -> Option<Self::Item> {\n        unsafe {\n            if self.index >= self.len {\n                None\n            } else {\n                let i = self.index;\n                self.index += 1;\n                Some((\n                    self.t.get_unchecked(i),\n                    self.u.get_unchecked(i)))\n            }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let len = self.len - self.index;\n        (len, Some(len))\n    }\n}\n\nimpl<T, U> DoubleEndedIterator for ZipSlices<T, U>\n    where T: Slice,\n          U: Slice\n{\n    #[inline(always)]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        unsafe {\n            if self.index >= self.len {\n                None\n            } else {\n                self.len -= 1;\n                let i = self.len;\n                Some((\n                    self.t.get_unchecked(i),\n                    self.u.get_unchecked(i)))\n            }\n        }\n    }\n}\n\nimpl<T, U> ExactSizeIterator for ZipSlices<T, U>\n    where T: Slice,\n          U: Slice\n{}\n\nunsafe impl<T, U> Slice for ZipSlices<T, U>\n    where T: Slice,\n          U: Slice\n{\n    type Item = (T::Item, U::Item);\n\n    fn len(&self) -> usize {\n        self.len - self.index\n    }\n\n    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n        (self.t.get_unchecked(i),\n         self.u.get_unchecked(i))\n    }\n}\n\n/// A helper trait to let `ZipSlices` accept both `&[T]` and `&mut [T]`.\n///\n/// Unsafe trait because:\n///\n/// - Implementors must guarantee that `get_unchecked` is valid for all indices `0..len()`.\npub unsafe trait Slice {\n    /// The type of a reference to the slice's elements\n    type Item;\n    #[doc(hidden)]\n    fn len(&self) -> usize;\n    #[doc(hidden)]\n    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item;\n}\n\nunsafe impl<'a, T> Slice for &'a [T] {\n    type Item = &'a T;\n    #[inline(always)]\n    fn len(&self) -> usize { (**self).len() }\n    #[inline(always)]\n    unsafe fn get_unchecked(&mut self, i: usize) -> &'a T {\n        debug_assert!(i < self.len());\n        (**self).get_unchecked(i)\n    }\n}\n\nunsafe impl<'a, T> Slice for &'a mut [T] {\n    type Item = &'a mut T;\n    #[inline(always)]\n    fn len(&self) -> usize { (**self).len() }\n    #[inline(always)]\n    unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut T {\n        debug_assert!(i < self.len());\n        // override the lifetime constraints of &mut &'a mut [T]\n        (*(*self as *mut [T])).get_unchecked_mut(i)\n    }\n}\n\n#[test]\nfn zipslices() {\n\n    let xs = [1, 2, 3, 4, 5, 6];\n    let ys = [1, 2, 3, 7];\n    ::itertools::assert_equal(ZipSlices::new(&xs, &ys), xs.iter().zip(&ys));\n\n    let xs = [1, 2, 3, 4, 5, 6];\n    let mut ys = [0; 6];\n    for (x, y) in ZipSlices::from_slices(&xs[..], &mut ys[..]) {\n        *y = *x;\n    }\n    ::itertools::assert_equal(&xs, &ys);\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":34},{"path":["/","home","kms","itertools","benches","fold_specialization.rs"],"content":"use criterion::{criterion_group, criterion_main, Criterion};\nuse itertools::Itertools;\n\nstruct Unspecialized<I>(I);\n\nimpl<I> Iterator for Unspecialized<I>\nwhere I: Iterator\n{\n    type Item = I::Item;\n\n    #[inline(always)]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.0.next()\n    }\n\n    #[inline(always)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.0.size_hint()\n    }\n}\n\nmod specialization {\n    use super::*;\n\n    pub mod intersperse {\n        use super::*;\n\n        pub fn external(c: &mut Criterion)\n        {\n            let arr = [1; 1024];\n\n            c.bench_function(\"external\", move |b| {\n                b.iter(|| {\n                    let mut sum = 0;\n                    for &x in arr.iter().intersperse(&0) {\n                        sum += x;\n                    }\n                    sum\n                })\n            });\n        }\n\n        pub fn internal_specialized(c: &mut Criterion)\n        {\n            let arr = [1; 1024];\n\n            c.bench_function(\"internal specialized\", move |b| {\n                b.iter(|| {\n                    arr.iter().intersperse(&0).fold(0, |acc, x| acc + x)\n                })\n            });\n        }\n\n        pub fn internal_unspecialized(c: &mut Criterion)\n        {\n            let arr = [1; 1024];\n\n            c.bench_function(\"internal unspecialized\", move |b| {\n                b.iter(|| {\n                    Unspecialized(arr.iter().intersperse(&0)).fold(0, |acc, x| acc + x)\n                })\n            });\n        }\n    }\n}\n\ncriterion_group!(\n    benches,\n    specialization::intersperse::external,\n    specialization::intersperse::internal_specialized,\n    specialization::intersperse::internal_unspecialized,\n);\ncriterion_main!(benches);\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","kms","itertools","benches","tree_fold1.rs"],"content":"use criterion::{criterion_group, criterion_main, Criterion};\nuse itertools::{Itertools, cloned};\n\ntrait IterEx : Iterator {\n    // Another efficient implementation against which to compare,\n    // but needs `std` so is less desirable.\n    fn tree_fold1_vec<F>(self, mut f: F) -> Option<Self::Item>\n        where F: FnMut(Self::Item, Self::Item) -> Self::Item,\n              Self: Sized,\n    {\n        let hint = self.size_hint().0;\n        let cap = std::mem::size_of::<usize>() * 8 - hint.leading_zeros() as usize;\n        let mut stack = Vec::with_capacity(cap);\n        self.enumerate().for_each(|(mut i, mut x)| {\n            while (i & 1) != 0 {\n                x = f(stack.pop().unwrap(), x);\n                i >>= 1;\n            }\n            stack.push(x);\n        });\n        stack.into_iter().fold1(f)\n    }\n}\nimpl<T:Iterator> IterEx for T {}\n\nmacro_rules! def_benchs {\n    ($N:expr,\n     $FUN:ident,\n     $BENCH_NAME:ident,\n     ) => (\n        mod $BENCH_NAME {\n            use super::*;\n\n            pub fn sum(c: &mut Criterion) {\n                let v: Vec<u32> = (0.. $N).collect();\n\n                c.bench_function(&(stringify!($BENCH_NAME).replace('_', \" \") + \" sum\"), move |b| {\n                    b.iter(|| {\n                        cloned(&v).$FUN(|x, y| x + y)\n                    })\n                });\n            }\n\n            pub fn complex_iter(c: &mut Criterion) {\n                let u = (3..).take($N / 2);\n                let v = (5..).take($N / 2);\n                let it = u.chain(v);\n\n                c.bench_function(&(stringify!($BENCH_NAME).replace('_', \" \") + \" complex iter\"), move |b| {\n                    b.iter(|| {\n                        it.clone().map(|x| x as f32).$FUN(f32::atan2)\n                    })\n                });\n            }\n\n            pub fn string_format(c: &mut Criterion) {\n                // This goes quadratic with linear `fold1`, so use a smaller\n                // size to not waste too much time in travis.  The allocations\n                // in here are so expensive anyway that it'll still take\n                // way longer per iteration than the other two benchmarks.\n                let v: Vec<u32> = (0.. ($N/4)).collect();\n\n                c.bench_function(&(stringify!($BENCH_NAME).replace('_', \" \") + \" string format\"), move |b| {\n                    b.iter(|| {\n                        cloned(&v).map(|x| x.to_string()).$FUN(|x, y| format!(\"{} + {}\", x, y))\n                    })\n                });\n            }\n        }\n\n        criterion_group!(\n            $BENCH_NAME,\n            $BENCH_NAME::sum,\n            $BENCH_NAME::complex_iter,\n            $BENCH_NAME::string_format,\n        );\n    )\n}\n\ndef_benchs!{\n    10_000,\n    fold1,\n    fold1_10k,\n}\n\ndef_benchs!{\n    10_000,\n    tree_fold1,\n    tree_fold1_stack_10k,\n}\n\ndef_benchs!{\n    10_000,\n    tree_fold1_vec,\n    tree_fold1_vec_10k,\n}\n\ndef_benchs!{\n    100,\n    fold1,\n    fold1_100,\n}\n\ndef_benchs!{\n    100,\n    tree_fold1,\n    tree_fold1_stack_100,\n}\n\ndef_benchs!{\n    100,\n    tree_fold1_vec,\n    tree_fold1_vec_100,\n}\n\ndef_benchs!{\n    8,\n    fold1,\n    fold1_08,\n}\n\ndef_benchs!{\n    8,\n    tree_fold1,\n    tree_fold1_stack_08,\n}\n\ndef_benchs!{\n    8,\n    tree_fold1_vec,\n    tree_fold1_vec_08,\n}\n\ncriterion_main!(\n    fold1_10k,\n    tree_fold1_stack_10k,\n    tree_fold1_vec_10k,\n    fold1_100,\n    tree_fold1_stack_100,\n    tree_fold1_vec_100,\n    fold1_08,\n    tree_fold1_stack_08,\n    tree_fold1_vec_08,\n);\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":9},{"path":["/","home","kms","itertools","src","adaptors","mod.rs"],"content":"//! Licensed under the Apache License, Version 2.0\n//! http://www.apache.org/licenses/LICENSE-2.0 or the MIT license\n//! http://opensource.org/licenses/MIT, at your\n//! option. This file may not be copied, modified, or distributed\n//! except according to those terms.\n\nmod multi_product;\n#[cfg(feature = \"use_std\")]\npub use self::multi_product::*;\n\nuse std::fmt;\nuse std::mem::replace;\nuse std::iter::{Fuse, Peekable, FromIterator, FusedIterator};\nuse std::marker::PhantomData;\nuse crate::size_hint;\n\n/// An iterator adaptor that alternates elements from two iterators until both\n/// run out.\n///\n/// This iterator is *fused*.\n///\n/// See [`.interleave()`](../trait.Itertools.html#method.interleave) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Interleave<I, J> {\n    a: Fuse<I>,\n    b: Fuse<J>,\n    flag: bool,\n}\n\n/// Create an iterator that interleaves elements in `i` and `j`.\n///\n/// `IntoIterator` enabled version of `i.interleave(j)`.\n///\n/// ```\n/// use itertools::interleave;\n///\n/// for elt in interleave(&[1, 2, 3], &[2, 3, 4]) {\n///     /* loop body */\n/// }\n/// ```\npub fn interleave<I, J>(i: I, j: J) -> Interleave<<I as IntoIterator>::IntoIter, <J as IntoIterator>::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator<Item = I::Item>\n{\n    Interleave {\n        a: i.into_iter().fuse(),\n        b: j.into_iter().fuse(),\n        flag: false,\n    }\n}\n\nimpl<I, J> Iterator for Interleave<I, J>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.flag = !self.flag;\n        if self.flag {\n            match self.a.next() {\n                None => self.b.next(),\n                r => r,\n            }\n        } else {\n            match self.b.next() {\n                None => self.a.next(),\n                r => r,\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add(self.a.size_hint(), self.b.size_hint())\n    }\n}\n\n/// An iterator adaptor that alternates elements from the two iterators until\n/// one of them runs out.\n///\n/// This iterator is *fused*.\n///\n/// See [`.interleave_shortest()`](../trait.Itertools.html#method.interleave_shortest)\n/// for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct InterleaveShortest<I, J>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    it0: I,\n    it1: J,\n    phase: bool, // false ==> it0, true ==> it1\n}\n\n/// Create a new `InterleaveShortest` iterator.\npub fn interleave_shortest<I, J>(a: I, b: J) -> InterleaveShortest<I, J>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    InterleaveShortest {\n        it0: a,\n        it1: b,\n        phase: false,\n    }\n}\n\nimpl<I, J> Iterator for InterleaveShortest<I, J>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    type Item = I::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.phase {\n            false => match self.it0.next() {\n                None => None,\n                e => {\n                    self.phase = true;\n                    e\n                }\n            },\n            true => match self.it1.next() {\n                None => None,\n                e => {\n                    self.phase = false;\n                    e\n                }\n            },\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (curr_hint, next_hint) = {\n            let it0_hint = self.it0.size_hint();\n            let it1_hint = self.it1.size_hint();\n            if self.phase {\n                (it1_hint, it0_hint)\n            } else {\n                (it0_hint, it1_hint)\n            }\n        };\n        let (curr_lower, curr_upper) = curr_hint;\n        let (next_lower, next_upper) = next_hint;\n        let (combined_lower, combined_upper) =\n            size_hint::mul_scalar(size_hint::min(curr_hint, next_hint), 2);\n        let lower =\n            if curr_lower > next_lower {\n                combined_lower + 1\n            } else {\n                combined_lower\n            };\n        let upper = {\n            let extra_elem = match (curr_upper, next_upper) {\n                (_, None) => false,\n                (None, Some(_)) => true,\n                (Some(curr_max), Some(next_max)) => curr_max > next_max,\n            };\n            if extra_elem {\n                combined_upper.and_then(|x| x.checked_add(1))\n            } else {\n                combined_upper\n            }\n        };\n        (lower, upper)\n    }\n}\n\n#[derive(Clone, Debug)]\n/// An iterator adaptor that allows putting back a single\n/// item to the front of the iterator.\n///\n/// Iterator element type is `I::Item`.\npub struct PutBack<I>\n    where I: Iterator\n{\n    top: Option<I::Item>,\n    iter: I,\n}\n\n/// Create an iterator where you can put back a single item\npub fn put_back<I>(iterable: I) -> PutBack<I::IntoIter>\n    where I: IntoIterator\n{\n    PutBack {\n        top: None,\n        iter: iterable.into_iter(),\n    }\n}\n\nimpl<I> PutBack<I>\n    where I: Iterator\n{\n    /// put back value `value` (builder method)\n    pub fn with_value(mut self, value: I::Item) -> Self {\n        self.put_back(value);\n        self\n    }\n\n    /// Split the `PutBack` into its parts.\n    #[inline]\n    pub fn into_parts(self) -> (Option<I::Item>, I) {\n        let PutBack{top, iter} = self;\n        (top, iter)\n    }\n\n    /// Put back a single value to the front of the iterator.\n    ///\n    /// If a value is already in the put back slot, it is overwritten.\n    #[inline]\n    pub fn put_back(&mut self, x: I::Item) {\n        self.top = Some(x)\n    }\n}\n\nimpl<I> Iterator for PutBack<I>\n    where I: Iterator\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.top {\n            None => self.iter.next(),\n            ref mut some => some.take(),\n        }\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // Not ExactSizeIterator because size may be larger than usize\n        size_hint::add_scalar(self.iter.size_hint(), self.top.is_some() as usize)\n    }\n\n    fn count(self) -> usize {\n        self.iter.count() + (self.top.is_some() as usize)\n    }\n\n    fn last(self) -> Option<Self::Item> {\n        self.iter.last().or(self.top)\n    }\n\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        match self.top {\n            None => self.iter.nth(n),\n            ref mut some => {\n                if n == 0 {\n                    some.take()\n                } else {\n                    *some = None;\n                    self.iter.nth(n - 1)\n                }\n            }\n        }\n    }\n\n    fn all<G>(&mut self, mut f: G) -> bool\n        where G: FnMut(Self::Item) -> bool\n    {\n        if let Some(elt) = self.top.take() {\n            if !f(elt) {\n                return false;\n            }\n        }\n        self.iter.all(f)\n    }\n\n    fn fold<Acc, G>(mut self, init: Acc, mut f: G) -> Acc\n        where G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        let mut accum = init;\n        if let Some(elt) = self.top.take() {\n            accum = f(accum, elt);\n        }\n        self.iter.fold(accum, f)\n    }\n}\n\n#[derive(Debug, Clone)]\n/// An iterator adaptor that iterates over the cartesian product of\n/// the element sets of two iterators `I` and `J`.\n///\n/// Iterator element type is `(I::Item, J::Item)`.\n///\n/// See [`.cartesian_product()`](../trait.Itertools.html#method.cartesian_product) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Product<I, J>\n    where I: Iterator\n{\n    a: I,\n    a_cur: Option<I::Item>,\n    b: J,\n    b_orig: J,\n}\n\n/// Create a new cartesian product iterator\n///\n/// Iterator element type is `(I::Item, J::Item)`.\npub fn cartesian_product<I, J>(mut i: I, j: J) -> Product<I, J>\n    where I: Iterator,\n          J: Clone + Iterator,\n          I::Item: Clone\n{\n    Product {\n        a_cur: i.next(),\n        a: i,\n        b: j.clone(),\n        b_orig: j,\n    }\n}\n\nimpl<I, J> Iterator for Product<I, J>\n    where I: Iterator,\n          J: Clone + Iterator,\n          I::Item: Clone\n{\n    type Item = (I::Item, J::Item);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let elt_b = match self.b.next() {\n            None => {\n                self.b = self.b_orig.clone();\n                match self.b.next() {\n                    None => return None,\n                    Some(x) => {\n                        self.a_cur = self.a.next();\n                        x\n                    }\n                }\n            }\n            Some(x) => x\n        };\n        match self.a_cur {\n            None => None,\n            Some(ref a) => {\n                Some((a.clone(), elt_b))\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let has_cur = self.a_cur.is_some() as usize;\n        // Not ExactSizeIterator because size may be larger than usize\n        let (b_min, b_max) = self.b.size_hint();\n\n        // Compute a * b_orig + b for both lower and upper bound\n        size_hint::add(\n            size_hint::mul(self.a.size_hint(), self.b_orig.size_hint()),\n            (b_min * has_cur, b_max.map(move |x| x * has_cur)))\n    }\n\n    fn fold<Acc, G>(mut self, mut accum: Acc, mut f: G) -> Acc\n        where G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        // use a split loop to handle the loose a_cur as well as avoiding to\n        // clone b_orig at the end.\n        if let Some(mut a) = self.a_cur.take() {\n            let mut b = self.b;\n            loop {\n                accum = b.fold(accum, |acc, elt| f(acc, (a.clone(), elt)));\n\n                // we can only continue iterating a if we had a first element;\n                if let Some(next_a) = self.a.next() {\n                    b = self.b_orig.clone();\n                    a = next_a;\n                } else {\n                    break;\n                }\n            }\n        }\n        accum\n    }\n}\n\n/// A “meta iterator adaptor”. Its closure receives a reference to the iterator\n/// and may pick off as many elements as it likes, to produce the next iterator element.\n///\n/// Iterator element type is *X*, if the return type of `F` is *Option\\<X\\>*.\n///\n/// See [`.batching()`](../trait.Itertools.html#method.batching) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Batching<I, F> {\n    f: F,\n    iter: I,\n}\n\nimpl<I, F> fmt::Debug for Batching<I, F> where I: fmt::Debug {\n    debug_fmt_fields!(Batching, iter);\n}\n\n/// Create a new Batching iterator.\npub fn batching<I, F>(iter: I, f: F) -> Batching<I, F> {\n    Batching { f, iter }\n}\n\nimpl<B, F, I> Iterator for Batching<I, F>\n    where I: Iterator,\n          F: FnMut(&mut I) -> Option<B>\n{\n    type Item = B;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        (self.f)(&mut self.iter)\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // No information about closue behavior\n        (0, None)\n    }\n}\n\n/// An iterator adaptor that steps a number elements in the base iterator\n/// for each iteration.\n///\n/// The iterator steps by yielding the next element from the base iterator,\n/// then skipping forward *n-1* elements.\n///\n/// See [`.step()`](../trait.Itertools.html#method.step) for more information.\n#[deprecated(note=\"Use std .step_by() instead\", since=\"0.8\")]\n#[allow(deprecated)]\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Step<I> {\n    iter: Fuse<I>,\n    skip: usize,\n}\n\n/// Create a `Step` iterator.\n///\n/// **Panics** if the step is 0.\n#[allow(deprecated)]\npub fn step<I>(iter: I, step: usize) -> Step<I>\n    where I: Iterator\n{\n    assert!(step != 0);\n    Step {\n        iter: iter.fuse(),\n        skip: step - 1,\n    }\n}\n\n#[allow(deprecated)]\nimpl<I> Iterator for Step<I>\n    where I: Iterator\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let elt = self.iter.next();\n        if self.skip > 0 {\n            self.iter.nth(self.skip - 1);\n        }\n        elt\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, high) = self.iter.size_hint();\n        let div = |x: usize| {\n            if x == 0 {\n                0\n            } else {\n                1 + (x - 1) / (self.skip + 1)\n            }\n        };\n        (div(low), high.map(div))\n    }\n}\n\n// known size\n#[allow(deprecated)]\nimpl<I> ExactSizeIterator for Step<I>\n    where I: ExactSizeIterator\n{}\n\npub trait MergePredicate<T> {\n    fn merge_pred(&mut self, a: &T, b: &T) -> bool;\n}\n\n#[derive(Clone)]\npub struct MergeLte;\n\nimpl<T: PartialOrd> MergePredicate<T> for MergeLte {\n    fn merge_pred(&mut self, a: &T, b: &T) -> bool {\n        a <= b\n    }\n}\n\n/// An iterator adaptor that merges the two base iterators in ascending order.\n/// If both base iterators are sorted (ascending), the result is sorted.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.merge()`](../trait.Itertools.html#method.merge_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub type Merge<I, J> = MergeBy<I, J, MergeLte>;\n\n/// Create an iterator that merges elements in `i` and `j`.\n///\n/// `IntoIterator` enabled version of `i.merge(j)`.\n///\n/// ```\n/// use itertools::merge;\n///\n/// for elt in merge(&[1, 2, 3], &[2, 3, 4]) {\n///     /* loop body */\n/// }\n/// ```\npub fn merge<I, J>(i: I, j: J) -> Merge<<I as IntoIterator>::IntoIter, <J as IntoIterator>::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator<Item = I::Item>,\n          I::Item: PartialOrd\n{\n    merge_by_new(i, j, MergeLte)\n}\n\n/// An iterator adaptor that merges the two base iterators in ascending order.\n/// If both base iterators are sorted (ascending), the result is sorted.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.merge_by()`](../trait.Itertools.html#method.merge_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MergeBy<I, J, F>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    a: Peekable<I>,\n    b: Peekable<J>,\n    fused: Option<bool>,\n    cmp: F,\n}\n\nimpl<I, J, F> fmt::Debug for MergeBy<I, J, F>\n    where I: Iterator + fmt::Debug, J: Iterator<Item = I::Item> + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(MergeBy, a, b);\n}\n\nimpl<T, F: FnMut(&T, &T)->bool> MergePredicate<T> for F {\n    fn merge_pred(&mut self, a: &T, b: &T) -> bool {\n        self(a, b)\n    }\n}\n\n/// Create a `MergeBy` iterator.\npub fn merge_by_new<I, J, F>(a: I, b: J, cmp: F) -> MergeBy<I::IntoIter, J::IntoIter, F>\n    where I: IntoIterator,\n          J: IntoIterator<Item = I::Item>,\n          F: MergePredicate<I::Item>,\n{\n    MergeBy {\n        a: a.into_iter().peekable(),\n        b: b.into_iter().peekable(),\n        fused: None,\n        cmp,\n    }\n}\n\nimpl<I, J, F> Clone for MergeBy<I, J, F>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>,\n          Peekable<I>: Clone,\n          Peekable<J>: Clone,\n          F: Clone\n{\n    clone_fields!(a, b, fused, cmp);\n}\n\nimpl<I, J, F> Iterator for MergeBy<I, J, F>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>,\n          F: MergePredicate<I::Item>\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let less_than = match self.fused {\n            Some(lt) => lt,\n            None => match (self.a.peek(), self.b.peek()) {\n                (Some(a), Some(b)) => self.cmp.merge_pred(a, b),\n                (Some(_), None) => {\n                    self.fused = Some(true);\n                    true\n                }\n                (None, Some(_)) => {\n                    self.fused = Some(false);\n                    false\n                }\n                (None, None) => return None,\n            }\n        };\n        if less_than {\n            self.a.next()\n        } else {\n            self.b.next()\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // Not ExactSizeIterator because size may be larger than usize\n        size_hint::add(self.a.size_hint(), self.b.size_hint())\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct CoalesceCore<I, T>\n    where I: Iterator\n{\n    iter: I,\n    last: Option<T>,\n}\n\nimpl<I, T> CoalesceCore<I, T>\n    where I: Iterator\n{\n    fn next_with<F>(&mut self, mut f: F) -> Option<T>\n        where F: FnMut(T, I::Item) -> Result<T, (T, T)>\n    {\n        // this fuses the iterator\n        let mut last = match self.last.take() {\n            None => return None,\n            Some(x) => x,\n        };\n        for next in &mut self.iter {\n            match f(last, next) {\n                Ok(joined) => last = joined,\n                Err((last_, next_)) => {\n                    self.last = Some(next_);\n                    return Some(last_);\n                }\n            }\n        }\n\n        Some(last)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, hi) = size_hint::add_scalar(self.iter.size_hint(),\n                                              self.last.is_some() as usize);\n        ((low > 0) as usize, hi)\n    }\n}\n\n/// An iterator adaptor that may join together adjacent elements.\n///\n/// See [`.coalesce()`](../trait.Itertools.html#method.coalesce) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Coalesce<I, F>\n    where I: Iterator\n{\n    iter: CoalesceCore<I, I::Item>,\n    f: F,\n}\n\nimpl<I: Clone, F: Clone> Clone for Coalesce<I, F>\n    where I: Iterator,\n          I::Item: Clone\n{\n    clone_fields!(iter, f);\n}\n\nimpl<I, F> fmt::Debug for Coalesce<I, F>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(Coalesce, iter);\n}\n\n/// Create a new `Coalesce`.\npub fn coalesce<I, F>(mut iter: I, f: F) -> Coalesce<I, F>\n    where I: Iterator\n{\n    Coalesce {\n        iter: CoalesceCore {\n            last: iter.next(),\n            iter,\n        },\n        f,\n    }\n}\n\nimpl<I, F> Iterator for Coalesce<I, F>\n    where I: Iterator,\n          F: FnMut(I::Item, I::Item) -> Result<I::Item, (I::Item, I::Item)>\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next_with(&mut self.f)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\n/// An iterator adaptor that removes repeated duplicates, determining equality using a comparison function.\n///\n/// See [`.dedup_by()`](../trait.Itertools.html#method.dedup_by) or [`.dedup()`](../trait.Itertools.html#method.dedup) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct DedupBy<I, Pred>\n    where I: Iterator\n{\n    iter: CoalesceCore<I, I::Item>,\n    dedup_pred: Pred,\n}\n\npub trait DedupPredicate<T> { // TODO replace by Fn(&T, &T)->bool once Rust supports it\n    fn dedup_pair(&mut self, a: &T, b: &T) -> bool;\n}\n\n#[derive(Clone)]\npub struct DedupEq;\n\nimpl<T: PartialEq> DedupPredicate<T> for DedupEq {\n    fn dedup_pair(&mut self, a: &T, b: &T) -> bool {\n        a == b\n    }\n}\n\nimpl<T, F: FnMut(&T, &T)->bool> DedupPredicate<T> for F {\n    fn dedup_pair(&mut self, a: &T, b: &T) -> bool {\n        self(a, b)\n    }\n}\n\n/// An iterator adaptor that removes repeated duplicates.\n///\n/// See [`.dedup()`](../trait.Itertools.html#method.dedup) for more information.\npub type Dedup<I>=DedupBy<I, DedupEq>;\n\nimpl<I: Clone, Pred: Clone> Clone for DedupBy<I, Pred>\n    where I: Iterator,\n          I::Item: Clone,\n{\n    clone_fields!(iter, dedup_pred);\n}\n\n/// Create a new `DedupBy`.\npub fn dedup_by<I, Pred>(mut iter: I, dedup_pred: Pred) -> DedupBy<I, Pred>\n    where I: Iterator,\n{\n    DedupBy {\n        iter: CoalesceCore {\n            last: iter.next(),\n            iter,\n        },\n        dedup_pred,\n    }\n}\n\n/// Create a new `Dedup`.\npub fn dedup<I>(iter: I) -> Dedup<I>\n    where I: Iterator\n{\n    dedup_by(iter, DedupEq)\n}\n\nimpl<I, Pred> fmt::Debug for DedupBy<I, Pred>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(Dedup, iter);\n}\n\nimpl<I, Pred> Iterator for DedupBy<I, Pred>\n    where I: Iterator,\n          Pred: DedupPredicate<I::Item>,\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let ref mut dedup_pred = self.dedup_pred;\n        self.iter.next_with(|x, y| {\n            if dedup_pred.dedup_pair(&x, &y) { Ok(x) } else { Err((x, y)) }\n        })\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn fold<Acc, G>(self, mut accum: Acc, mut f: G) -> Acc\n        where G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        if let Some(mut last) = self.iter.last {\n            let mut dedup_pred = self.dedup_pred;\n            accum = self.iter.iter.fold(accum, |acc, elt| {\n                if dedup_pred.dedup_pair(&elt, &last) {\n                    acc\n                } else {\n                    f(acc, replace(&mut last, elt))\n                }\n            });\n            f(accum, last)\n        } else {\n            accum\n        }\n    }\n}\n\n/// An iterator adaptor that removes repeated duplicates, while keeping a count of how many\n/// repeated elements were present. This will determine equality using a comparison function.\n///\n/// See [`.dedup_by_with_count()`](../trait.Itertools.html#method.dedup_by_with_count) or\n/// [`.dedup_with_count()`](../trait.Itertools.html#method.dedup_with_count) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct DedupByWithCount<I, Pred>\n    where I: Iterator\n{\n    iter: CoalesceCore<I, (usize, I::Item)>,\n    dedup_pred: Pred,\n}\n\n/// An iterator adaptor that removes repeated duplicates, while keeping a count of how many\n/// repeated elements were present.\n///\n/// See [`.dedup_with_count()`](../trait.Itertools.html#method.dedup_with_count) for more information.\npub type DedupWithCount<I> = DedupByWithCount<I, DedupEq>;\n\n/// Create a new `DedupByWithCount`.\npub fn dedup_by_with_count<I, Pred>(mut iter: I, dedup_pred: Pred) -> DedupByWithCount<I, Pred>\n    where I: Iterator,\n{\n    DedupByWithCount {\n        iter: CoalesceCore {\n            last: iter.next().map(|v| (1, v)),\n            iter,\n        },\n        dedup_pred,\n    }\n}\n\n/// Create a new `DedupWithCount`.\npub fn dedup_with_count<I>(iter: I) -> DedupWithCount<I>\n    where I: Iterator\n{\n    dedup_by_with_count(iter, DedupEq)\n}\n\nimpl<I, Pred> fmt::Debug for DedupByWithCount<I, Pred>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(Dedup, iter);\n}\n\nimpl<I: Clone, Pred: Clone> Clone for DedupByWithCount<I, Pred>\n    where I: Iterator,\n          I::Item: Clone,\n{\n    clone_fields!(iter, dedup_pred);\n}\n\nimpl<I, Pred> Iterator for DedupByWithCount<I, Pred>\n    where I: Iterator,\n          Pred: DedupPredicate<I::Item>,\n{\n    type Item = (usize, I::Item);\n\n    fn next(&mut self) -> Option<(usize, I::Item)> {\n        let ref mut dedup_pred = self.dedup_pred;\n        self.iter.next_with(|(c, x), y| {\n            if dedup_pred.dedup_pair(&x, &y) { Ok((c + 1, x)) } else { Err(((c, x), (1, y))) }\n        })\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\nimpl<I: Iterator, Pred: DedupPredicate<I::Item>> FusedIterator for DedupByWithCount<I, Pred> {}\n\n/// An iterator adaptor that borrows from a `Clone`-able iterator\n/// to only pick off elements while the predicate returns `true`.\n///\n/// See [`.take_while_ref()`](../trait.Itertools.html#method.take_while_ref) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct TakeWhileRef<'a, I: 'a, F> {\n    iter: &'a mut I,\n    f: F,\n}\n\nimpl<'a, I, F> fmt::Debug for TakeWhileRef<'a, I, F>\n    where I: Iterator + fmt::Debug,\n{\n    debug_fmt_fields!(TakeWhileRef, iter);\n}\n\n/// Create a new `TakeWhileRef` from a reference to clonable iterator.\npub fn take_while_ref<I, F>(iter: &mut I, f: F) -> TakeWhileRef<I, F>\n    where I: Iterator + Clone\n{\n    TakeWhileRef { iter, f }\n}\n\nimpl<'a, I, F> Iterator for TakeWhileRef<'a, I, F>\n    where I: Iterator + Clone,\n          F: FnMut(&I::Item) -> bool\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let old = self.iter.clone();\n        match self.iter.next() {\n            None => None,\n            Some(elt) => {\n                if (self.f)(&elt) {\n                    Some(elt)\n                } else {\n                    *self.iter = old;\n                    None\n                }\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, hi) = self.iter.size_hint();\n        (0, hi)\n    }\n}\n\n/// An iterator adaptor that filters `Option<A>` iterator elements\n/// and produces `A`. Stops on the first `None` encountered.\n///\n/// See [`.while_some()`](../trait.Itertools.html#method.while_some) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct WhileSome<I> {\n    iter: I,\n}\n\n/// Create a new `WhileSome<I>`.\npub fn while_some<I>(iter: I) -> WhileSome<I> {\n    WhileSome { iter }\n}\n\nimpl<I, A> Iterator for WhileSome<I>\n    where I: Iterator<Item = Option<A>>\n{\n    type Item = A;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.iter.next() {\n            None | Some(None) => None,\n            Some(elt) => elt,\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let sh = self.iter.size_hint();\n        (0, sh.1)\n    }\n}\n\n/// An iterator to iterate through all combinations in a `Clone`-able iterator that produces tuples\n/// of a specific size.\n///\n/// See [`.tuple_combinations()`](../trait.Itertools.html#method.tuple_combinations) for more\n/// information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct TupleCombinations<I, T>\n    where I: Iterator,\n          T: HasCombination<I>\n{\n    iter: T::Combination,\n    _mi: PhantomData<I>,\n    _mt: PhantomData<T>\n}\n\npub trait HasCombination<I>: Sized {\n    type Combination: From<I> + Iterator<Item = Self>;\n}\n\n/// Create a new `TupleCombinations` from a clonable iterator.\npub fn tuple_combinations<T, I>(iter: I) -> TupleCombinations<I, T>\n    where I: Iterator + Clone,\n          I::Item: Clone,\n          T: HasCombination<I>,\n{\n    TupleCombinations {\n        iter: T::Combination::from(iter),\n        _mi: PhantomData,\n        _mt: PhantomData,\n    }\n}\n\nimpl<I, T> Iterator for TupleCombinations<I, T>\n    where I: Iterator,\n          T: HasCombination<I>,\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next()\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct Tuple1Combination<I> {\n    iter: I,\n}\n\nimpl<I> From<I> for Tuple1Combination<I> {\n    fn from(iter: I) -> Self {\n        Tuple1Combination { iter }\n    }\n}\n\nimpl<I: Iterator> Iterator for Tuple1Combination<I> {\n    type Item = (I::Item,);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(|x| (x,))\n    }\n}\n\nimpl<I: Iterator> HasCombination<I> for (I::Item,) {\n    type Combination = Tuple1Combination<I>;\n}\n\nmacro_rules! impl_tuple_combination {\n    ($C:ident $P:ident ; $A:ident, $($I:ident),* ; $($X:ident)*) => (\n        #[derive(Clone, Debug)]\n        pub struct $C<I: Iterator> {\n            item: Option<I::Item>,\n            iter: I,\n            c: $P<I>,\n        }\n\n        impl<I: Iterator + Clone> From<I> for $C<I> {\n            fn from(mut iter: I) -> Self {\n                $C {\n                    item: iter.next(),\n                    iter: iter.clone(),\n                    c: $P::from(iter),\n                }\n            }\n        }\n\n        impl<I: Iterator + Clone> From<I> for $C<Fuse<I>> {\n            fn from(iter: I) -> Self {\n                let mut iter = iter.fuse();\n                $C {\n                    item: iter.next(),\n                    iter: iter.clone(),\n                    c: $P::from(iter),\n                }\n            }\n        }\n\n        impl<I, $A> Iterator for $C<I>\n            where I: Iterator<Item = $A> + Clone,\n                  I::Item: Clone\n        {\n            type Item = ($($I),*);\n\n            fn next(&mut self) -> Option<Self::Item> {\n                if let Some(($($X),*,)) = self.c.next() {\n                    let z = self.item.clone().unwrap();\n                    Some((z, $($X),*))\n                } else {\n                    self.item = self.iter.next();\n                    self.item.clone().and_then(|z| {\n                        self.c = $P::from(self.iter.clone());\n                        self.c.next().map(|($($X),*,)| (z, $($X),*))\n                    })\n                }\n            }\n        }\n\n        impl<I, $A> HasCombination<I> for ($($I),*)\n            where I: Iterator<Item = $A> + Clone,\n                  I::Item: Clone\n        {\n            type Combination = $C<Fuse<I>>;\n        }\n    )\n}\n\nimpl_tuple_combination!(Tuple2Combination Tuple1Combination ; A, A, A ; a);\nimpl_tuple_combination!(Tuple3Combination Tuple2Combination ; A, A, A, A ; a b);\nimpl_tuple_combination!(Tuple4Combination Tuple3Combination ; A, A, A, A, A; a b c);\n\n/// An iterator adapter to apply `Into` conversion to each element.\n///\n/// See [`.map_into()`](../trait.Itertools.html#method.map_into) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MapInto<I, R> {\n    iter: I,\n    _res: PhantomData<R>,\n}\n\n/// Create a new [`MapInto`](struct.MapInto.html) iterator.\npub fn map_into<I, R>(iter: I) -> MapInto<I, R> {\n    MapInto {\n        iter,\n        _res: PhantomData,\n    }\n}\n\nimpl<I, R> Iterator for MapInto<I, R>\n    where I: Iterator,\n          I::Item: Into<R>,\n{\n    type Item = R;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter\n            .next()\n            .map(|i| i.into())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn fold<Acc, Fold>(self, init: Acc, mut fold_f: Fold) -> Acc\n        where Fold: FnMut(Acc, Self::Item) -> Acc,\n    {\n        self.iter.fold(init, move |acc, v| fold_f(acc, v.into()))\n    }\n}\n\nimpl<I, R> DoubleEndedIterator for MapInto<I, R>\n    where I: DoubleEndedIterator,\n          I::Item: Into<R>,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.iter\n            .next_back()\n            .map(|i| i.into())\n    }\n}\n\nimpl<I, R> ExactSizeIterator for MapInto<I, R>\nwhere\n    I: ExactSizeIterator,\n    I::Item: Into<R>,\n{}\n\n/// An iterator adapter to apply a transformation within a nested `Result`.\n///\n/// See [`.map_results()`](../trait.Itertools.html#method.map_results) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MapResults<I, F> {\n    iter: I,\n    f: F\n}\n\n/// Create a new `MapResults` iterator.\npub fn map_results<I, F, T, U, E>(iter: I, f: F) -> MapResults<I, F>\n    where I: Iterator<Item = Result<T, E>>,\n          F: FnMut(T) -> U,\n{\n    MapResults {\n        iter,\n        f,\n    }\n}\n\nimpl<I, F, T, U, E> Iterator for MapResults<I, F>\n    where I: Iterator<Item = Result<T, E>>,\n          F: FnMut(T) -> U,\n{\n    type Item = Result<U, E>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(|v| v.map(&mut self.f))\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn fold<Acc, Fold>(self, init: Acc, mut fold_f: Fold) -> Acc\n        where Fold: FnMut(Acc, Self::Item) -> Acc,\n    {\n        let mut f = self.f;\n        self.iter.fold(init, move |acc, v| fold_f(acc, v.map(&mut f)))\n    }\n\n    fn collect<C>(self) -> C\n        where C: FromIterator<Self::Item>\n    {\n        let mut f = self.f;\n        self.iter.map(move |v| v.map(&mut f)).collect()\n    }\n}\n\n/// An iterator adapter to get the positions of each element that matches a predicate.\n///\n/// See [`.positions()`](../trait.Itertools.html#method.positions) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Positions<I, F> {\n    iter: I,\n    f: F,\n    count: usize,\n}\n\n/// Create a new `Positions` iterator.\npub fn positions<I, F>(iter: I, f: F) -> Positions<I, F>\n    where I: Iterator,\n          F: FnMut(I::Item) -> bool,\n{\n    Positions {\n        iter,\n        f,\n        count: 0\n    }\n}\n\nimpl<I, F> Iterator for Positions<I, F>\n    where I: Iterator,\n          F: FnMut(I::Item) -> bool,\n{\n    type Item = usize;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        while let Some(v) = self.iter.next() {\n            let i = self.count;\n            self.count = i + 1;\n            if (self.f)(v) {\n                return Some(i);\n            }\n        }\n        None\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (0, self.iter.size_hint().1)\n    }\n}\n\nimpl<I, F> DoubleEndedIterator for Positions<I, F>\n    where I: DoubleEndedIterator + ExactSizeIterator,\n          F: FnMut(I::Item) -> bool,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        while let Some(v) = self.iter.next_back() {\n            if (self.f)(v) {\n                return Some(self.count + self.iter.len())\n            }\n        }\n        None\n    }\n}\n\n/// An iterator adapter to apply a mutating function to each element before yielding it.\n///\n/// See [`.update()`](../trait.Itertools.html#method.update) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Update<I, F> {\n    iter: I,\n    f: F,\n}\n\n/// Create a new `Update` iterator.\npub fn update<I, F>(iter: I, f: F) -> Update<I, F>\nwhere\n    I: Iterator,\n    F: FnMut(&mut I::Item),\n{\n    Update { iter, f }\n}\n\nimpl<I, F> Iterator for Update<I, F>\nwhere\n    I: Iterator,\n    F: FnMut(&mut I::Item),\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if let Some(mut v) = self.iter.next() {\n            (self.f)(&mut v);\n            Some(v)\n        } else {\n            None\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn fold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n        where G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        let mut f = self.f;\n        self.iter.fold(init, move |acc, mut v| { f(&mut v); g(acc, v) })\n    }\n\n    // if possible, re-use inner iterator specializations in collect\n    fn collect<C>(self) -> C\n        where C: FromIterator<Self::Item>\n    {\n        let mut f = self.f;\n        self.iter.map(move |mut v| { f(&mut v); v }).collect()\n    }\n}\n\nimpl<I, F> ExactSizeIterator for Update<I, F>\nwhere\n    I: ExactSizeIterator,\n    F: FnMut(&mut I::Item),\n{}\n\nimpl<I, F> DoubleEndedIterator for Update<I, F>\nwhere\n    I: DoubleEndedIterator,\n    F: FnMut(&mut I::Item),\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        if let Some(mut v) = self.iter.next_back() {\n            (self.f)(&mut v);\n            Some(v)\n        } else {\n            None\n        }\n    }\n}\n","traces":[{"line":42,"address":[4319024,4319132],"length":1,"stats":{"Line":3},"fn_name":"interleave<core::slice::Iter<u8>,core::slice::Iter<u8>>"},{"line":47,"address":[4319054],"length":1,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[4319147,4319197],"length":1,"stats":{"Line":6},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[5180064,5180288,5180176],"length":1,"stats":{"Line":5},"fn_name":"interleave_shortest<core::iter::sources::Repeat<i32>,alloc::vec::IntoIter<i32>>"},{"line":116,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":185,"address":[4238864,4238962],"length":1,"stats":{"Line":14},"fn_name":"put_back<core::ops::range::Range<i32>>"},{"line":190,"address":[4238887],"length":1,"stats":{"Line":14},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[4320214,4319858,4320432,4320497,4319792,4320144],"length":1,"stats":{"Line":8},"fn_name":"cartesian_product<itertools::adaptors::Product<core::iter::adapters::Cloned<core::slice::Iter<i32>>, core::iter::adapters::Cloned<core::slice::Iter<i32>>>,core::iter::adapters::Cloned<core::slice::Iter<i32>>>"},{"line":306,"address":[4320171,4319812,4320458],"length":1,"stats":{"Line":9},"fn_name":null},{"line":308,"address":[4319932,4320272,4320539],"length":1,"stats":{"Line":8},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":353,"address":[5759520,5759615],"length":1,"stats":{"Line":1},"fn_name":"fold<itertools::adaptors::Product<quick::Iter<u16, quick::Inexact>, quick::Iter<u16, quick::Inexact>>,quick::Iter<u16, quick::Inexact>,(),closure-0>"},{"line":358,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":394,"address":[4238256],"length":1,"stats":{"Line":2},"fn_name":"batching<core::slice::Iter<core::option::Option<i32>>,closure-0>"},{"line":404,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[4320750,4320688],"length":1,"stats":{"Line":7},"fn_name":"step<core::ops::range::Range<i32>>"},{"line":438,"address":[4320708],"length":1,"stats":{"Line":7},"fn_name":null},{"line":440,"address":[4320762],"length":1,"stats":{"Line":7},"fn_name":null},{"line":441,"address":[4320917,4320817],"length":1,"stats":{"Line":7},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":511,"address":[4320960],"length":1,"stats":{"Line":3},"fn_name":"merge<itertools::adaptors::Step<core::ops::range::Range<i32>>,itertools::adaptors::Step<core::ops::range::Range<i32>>>"},{"line":516,"address":[4320967],"length":1,"stats":{"Line":3},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":550,"address":[4319344,4319439],"length":1,"stats":{"Line":5},"fn_name":"merge_by_new<itertools::adaptors::Step<core::ops::range::Range<i32>>,itertools::adaptors::Step<core::ops::range::Range<i32>>,itertools::adaptors::MergeLte>"},{"line":556,"address":[4319354],"length":1,"stats":{"Line":5},"fn_name":null},{"line":557,"address":[4319546,4319472],"length":1,"stats":{"Line":10},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":582,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":585,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":589,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":596,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":597,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":599,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":620,"address":[5185006,5184185,5184944,5183369,5183312,5180510,5181534,5182496,5180448,5182553,5184128,5181472],"length":1,"stats":{"Line":11},"fn_name":"next_with<core::slice::Iter<i32>,(usize, &i32),closure-0>"},{"line":624,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":626,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":628,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":631,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":632,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":641,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":643,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":692,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":693,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":726,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":727,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":744,"address":[5186720,5186766,5186334,5186432,5186576,5186622,5186478,5186288],"length":1,"stats":{"Line":9},"fn_name":"dedup_by<core::slice::Iter<(i32, i32)>,closure-1>"},{"line":748,"address":[5186356,5186500,5186644,5186788],"length":1,"stats":{"Line":9},"fn_name":null},{"line":757,"address":[5186240],"length":1,"stats":{"Line":4},"fn_name":"dedup<core::slice::Iter<i32>>"},{"line":760,"address":[5186257],"length":1,"stats":{"Line":4},"fn_name":null},{"line":776,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":777,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":778,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":779,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":783,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":784,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":787,"address":[5164586,5164512,5165018,5164944],"length":1,"stats":{"Line":2},"fn_name":"fold<core::slice::Iter<(i32, i32)>,closure-2,(),closure-3>"},{"line":790,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":791,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":792,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":793,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":794,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":796,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":799,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":801,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":826,"address":[5179728,5179775,5179344,5179536,5179391,5179583],"length":1,"stats":{"Line":3},"fn_name":"dedup_by_with_count<core::slice::Iter<(i32, i32)>,closure-1>"},{"line":830,"address":[5179631,5179823,5179439],"length":1,"stats":{"Line":3},"fn_name":null},{"line":839,"address":[5178352],"length":1,"stats":{"Line":1},"fn_name":"dedup_with_count<core::slice::Iter<i32>>"},{"line":842,"address":[5178369],"length":1,"stats":{"Line":1},"fn_name":null},{"line":865,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":866,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":867,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":868,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":872,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":873,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":896,"address":[5779168],"length":1,"stats":{"Line":1},"fn_name":"take_while_ref<core::slice::Iter<u8>,closure-0>"},{"line":908,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":909,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":910,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":911,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":912,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":913,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":914,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":916,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":917,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":923,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":924,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":925,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":940,"address":[5176688],"length":1,"stats":{"Line":2},"fn_name":"while_some<core::iter::adapters::Map<core::ops::range::Range<i32>, closure-0>>"},{"line":949,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":950,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":951,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":952,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":956,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":957,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":958,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":983,"address":[5179248],"length":1,"stats":{"Line":3},"fn_name":"tuple_combinations<(i32, i32),core::ops::range::Range<i32>>"},{"line":989,"address":[5179263],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1001,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1002,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1012,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1020,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1021,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1049,"address":[5174624,5174677],"length":1,"stats":{"Line":3},"fn_name":"from<core::ops::range::Range<i32>>"},{"line":1050,"address":[5174639,5174689],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1052,"address":[5174699],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1053,"address":[5174739],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1054,"address":[5174746],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1065,"address":[5167888,5167947],"length":1,"stats":{"Line":3},"fn_name":"next<core::iter::adapters::Fuse<core::ops::range::Range<i32>>,i32>"},{"line":1066,"address":[5167959,5167998,5168104,5168162,5167900],"length":1,"stats":{"Line":15},"fn_name":null},{"line":1067,"address":[5168059,5168011],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1068,"address":[5168063],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1070,"address":[5167971,5168204,5168109],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1071,"address":[5168115,5168222,5168320,5168386],"length":1,"stats":{"Line":9},"fn_name":"{{closure}}<core::iter::adapters::Fuse<core::ops::range::Range<i32>>,i32>"},{"line":1072,"address":[5168408,5168495,5168336],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1073,"address":[5168519,5168421,5168587,5168576],"length":1,"stats":{"Line":10},"fn_name":"{{closure}}<core::iter::adapters::Fuse<core::ops::range::Range<i32>>,i32>"},{"line":1116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":235,"coverable":306},{"path":["/","home","kms","itertools","src","adaptors","multi_product.rs"],"content":"#![cfg(feature = \"use_std\")]\n\nuse crate::size_hint;\nuse crate::Itertools;\n\n#[derive(Clone)]\n/// An iterator adaptor that iterates over the cartesian product of\n/// multiple iterators of type `I`.\n///\n/// An iterator element type is `Vec<I>`.\n///\n/// See [`.multi_cartesian_product()`](../trait.Itertools.html#method.multi_cartesian_product)\n/// for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MultiProduct<I>(Vec<MultiProductIter<I>>)\n    where I: Iterator + Clone,\n          I::Item: Clone;\n\n/// Create a new cartesian product iterator over an arbitrary number\n/// of iterators of the same type.\n///\n/// Iterator element is of type `Vec<H::Item::Item>`.\npub fn multi_cartesian_product<H>(iters: H) -> MultiProduct<<H::Item as IntoIterator>::IntoIter>\n    where H: Iterator,\n          H::Item: IntoIterator,\n          <H::Item as IntoIterator>::IntoIter: Clone,\n          <H::Item as IntoIterator>::Item: Clone\n{\n    MultiProduct(iters.map(|i| MultiProductIter::new(i.into_iter())).collect())\n}\n\n#[derive(Clone, Debug)]\n/// Holds the state of a single iterator within a MultiProduct.\nstruct MultiProductIter<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    cur: Option<I::Item>,\n    iter: I,\n    iter_orig: I,\n}\n\n/// Holds the current state during an iteration of a MultiProduct.\n#[derive(Debug)]\nenum MultiProductIterState {\n    StartOfIter,\n    MidIter { on_first_iter: bool },\n}\n\nimpl<I> MultiProduct<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    /// Iterates the rightmost iterator, then recursively iterates iterators\n    /// to the left if necessary.\n    ///\n    /// Returns true if the iteration succeeded, else false.\n    fn iterate_last(\n        multi_iters: &mut [MultiProductIter<I>],\n        mut state: MultiProductIterState\n    ) -> bool {\n        use self::MultiProductIterState::*;\n\n        if let Some((last, rest)) = multi_iters.split_last_mut() {\n            let on_first_iter = match state {\n                StartOfIter => {\n                    let on_first_iter = !last.in_progress();\n                    state = MidIter { on_first_iter };\n                    on_first_iter\n                },\n                MidIter { on_first_iter } => on_first_iter\n            };\n\n            if !on_first_iter {\n                last.iterate();\n            }\n\n            if last.in_progress() {\n                true\n            } else if MultiProduct::iterate_last(rest, state) {\n                last.reset();\n                last.iterate();\n                // If iterator is None twice consecutively, then iterator is\n                // empty; whole product is empty.\n                last.in_progress()\n            } else {\n                false\n            }\n        } else {\n            // Reached end of iterator list. On initialisation, return true.\n            // At end of iteration (final iterator finishes), finish.\n            match state {\n                StartOfIter => false,\n                MidIter { on_first_iter } => on_first_iter\n            }\n        }\n    }\n\n    /// Returns the unwrapped value of the next iteration.\n    fn curr_iterator(&self) -> Vec<I::Item> {\n        self.0.iter().map(|multi_iter| {\n            multi_iter.cur.clone().unwrap()\n        }).collect()\n    }\n\n    /// Returns true if iteration has started and has not yet finished; false\n    /// otherwise.\n    fn in_progress(&self) -> bool {\n        if let Some(last) = self.0.last() {\n            last.in_progress()\n        } else {\n            false\n        }\n    }\n}\n\nimpl<I> MultiProductIter<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    fn new(iter: I) -> Self {\n        MultiProductIter {\n            cur: None,\n            iter: iter.clone(),\n            iter_orig: iter\n        }\n    }\n\n    /// Iterate the managed iterator.\n    fn iterate(&mut self) {\n        self.cur = self.iter.next();\n    }\n\n    /// Reset the managed iterator.\n    fn reset(&mut self) {\n        self.iter = self.iter_orig.clone();\n    }\n\n    /// Returns true if the current iterator has been started and has not yet\n    /// finished; false otherwise.\n    fn in_progress(&self) -> bool {\n        self.cur.is_some()\n    }\n}\n\nimpl<I> Iterator for MultiProduct<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    type Item = Vec<I::Item>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if MultiProduct::iterate_last(\n            &mut self.0,\n            MultiProductIterState::StartOfIter\n        ) {\n            Some(self.curr_iterator())\n        } else {\n            None\n        }\n    }\n\n    fn count(self) -> usize {\n        if self.0.len() == 0 {\n            return 0;\n        }\n\n        if !self.in_progress() {\n            return self.0.into_iter().fold(1, |acc, multi_iter| {\n                acc * multi_iter.iter.count()\n            });\n        }\n\n        self.0.into_iter().fold(\n            0,\n            |acc, MultiProductIter { iter, iter_orig, cur: _ }| {\n                let total_count = iter_orig.count();\n                let cur_count = iter.count();\n                acc * total_count + cur_count\n            }\n        )\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // Not ExactSizeIterator because size may be larger than usize\n        if self.0.len() == 0 {\n            return (0, Some(0));\n        }\n\n        if !self.in_progress() {\n            return self.0.iter().fold((1, Some(1)), |acc, multi_iter| {\n                size_hint::mul(acc, multi_iter.iter.size_hint())\n            });\n        }\n\n        self.0.iter().fold(\n            (0, Some(0)),\n            |acc, &MultiProductIter { ref iter, ref iter_orig, cur: _ }| {\n                let cur_size = iter.size_hint();\n                let total_size = iter_orig.size_hint();\n                size_hint::add(size_hint::mul(acc, total_size), cur_size)\n            }\n        )\n    }\n\n    fn last(self) -> Option<Self::Item> {\n        let iter_count = self.0.len();\n\n        let lasts: Self::Item = self.0.into_iter()\n            .map(|multi_iter| multi_iter.iter.last())\n            .while_some()\n            .collect();\n\n        if lasts.len() == iter_count {\n            Some(lasts)\n        } else {\n            None\n        }\n    }\n}\n","traces":[{"line":23,"address":[5441024],"length":1,"stats":{"Line":1},"fn_name":"multi_cartesian_product<quick::ShiftRange<quick::Inexact>>"},{"line":29,"address":[5441152,5441164,5441034],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}<quick::ShiftRange<quick::Inexact>>"},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":61,"coverable":73},{"path":["/","home","kms","itertools","src","combinations.rs"],"content":"use std::fmt;\n\nuse super::lazy_buffer::LazyBuffer;\n\n/// An iterator to iterate through all the `k`-length combinations in an iterator.\n///\n/// See [`.combinations()`](../trait.Itertools.html#method.combinations) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Combinations<I: Iterator> {\n    indices: Vec<usize>,\n    pool: LazyBuffer<I>,\n    first: bool,\n}\n\nimpl<I> Clone for Combinations<I>\n    where I: Clone + Iterator,\n          I::Item: Clone,\n{\n    clone_fields!(indices, pool, first);\n}\n\nimpl<I> fmt::Debug for Combinations<I>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(Combinations, indices, pool, first);\n}\n\n/// Create a new `Combinations` from a clonable iterator.\npub fn combinations<I>(iter: I, k: usize) -> Combinations<I>\n    where I: Iterator\n{\n    let mut pool: LazyBuffer<I> = LazyBuffer::new(iter);\n\n    for _ in 0..k {\n        if !pool.get_next() {\n            break;\n        }\n    }\n\n    Combinations {\n        indices: (0..k).collect(),\n        pool,\n        first: true,\n    }\n}\n\nimpl<I> Iterator for Combinations<I>\n    where I: Iterator,\n          I::Item: Clone\n{\n    type Item = Vec<I::Item>;\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.first {\n            if self.pool.is_done() {\n                return None;\n            }\n            self.first = false;\n        } else if self.indices.len() == 0 {\n            return None;\n        } else {\n            // Scan from the end, looking for an index to increment\n            let mut i: usize = self.indices.len() - 1;\n\n            // Check if we need to consume more from the iterator\n            if self.indices[i] == self.pool.len() - 1 {\n                self.pool.get_next(); // may change pool size\n            }\n\n            while self.indices[i] == i + self.pool.len() - self.indices.len() {\n                if i > 0 {\n                    i -= 1;\n                } else {\n                    // Reached the last combination\n                    return None;\n                }\n            }\n\n            // Increment index, and reset the ones to its right\n            self.indices[i] += 1;\n            for j in i+1..self.indices.len() {\n                self.indices[j] = self.indices[j - 1] + 1;\n            }\n        }\n\n        // Create result vector based on the indices\n        Some(self.indices.iter().map(|i| self.pool[*i].clone()).collect())\n    }\n}\n","traces":[{"line":30,"address":[4233408,4233468],"length":1,"stats":{"Line":3},"fn_name":"combinations<adaptors_no_collect::PanickingCounter>"},{"line":33,"address":[4233433],"length":1,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[4233483,4233585,4233779],"length":1,"stats":{"Line":10},"fn_name":null},{"line":36,"address":[4233773,4233698],"length":1,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[4233784],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[4233709],"length":1,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":54,"address":[4231665,4231554,4232547],"length":1,"stats":{"Line":8},"fn_name":null},{"line":55,"address":[4231611],"length":1,"stats":{"Line":3},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[4231951],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":6},"fn_name":null}],"covered":24,"coverable":24},{"path":["/","home","kms","itertools","src","combinations_with_replacement.rs"],"content":"use std::fmt;\n\nuse super::lazy_buffer::LazyBuffer;\n\n/// An iterator to iterate through all the `n`-length combinations in an iterator, with replacement.\n///\n/// See [`.combinations_with_replacement()`](../trait.Itertools.html#method.combinations_with_replacement) for more information.\n#[derive(Clone)]\npub struct CombinationsWithReplacement<I>\nwhere\n    I: Iterator,\n    I::Item: Clone,\n{\n    k: usize,\n    indices: Vec<usize>,\n    // The current known max index value. This increases as pool grows.\n    max_index: usize,\n    pool: LazyBuffer<I>,\n    first: bool,\n}\n\nimpl<I> fmt::Debug for CombinationsWithReplacement<I>\nwhere\n    I: Iterator + fmt::Debug,\n    I::Item: fmt::Debug + Clone,\n{\n    debug_fmt_fields!(Combinations, k, indices, max_index, pool, first);\n}\n\nimpl<I> CombinationsWithReplacement<I>\nwhere\n    I: Iterator,\n    I::Item: Clone,\n{\n    /// Map the current mask over the pool to get an output combination\n    fn current(&self) -> Vec<I::Item> {\n        self.indices.iter().map(|i| self.pool[*i].clone()).collect()\n    }\n}\n\n/// Create a new `CombinationsWithReplacement` from a clonable iterator.\npub fn combinations_with_replacement<I>(iter: I, k: usize) -> CombinationsWithReplacement<I>\nwhere\n    I: Iterator,\n    I::Item: Clone,\n{\n    let indices: Vec<usize> = vec![0; k];\n    let pool: LazyBuffer<I> = LazyBuffer::new(iter);\n\n    CombinationsWithReplacement {\n        k,\n        indices,\n        max_index: 0,\n        pool,\n        first: true,\n    }\n}\n\nimpl<I> Iterator for CombinationsWithReplacement<I>\nwhere\n    I: Iterator,\n    I::Item: Clone,\n{\n    type Item = Vec<I::Item>;\n    fn next(&mut self) -> Option<Self::Item> {\n        // If this is the first iteration, return early\n        if self.first {\n            // In empty edge cases, stop iterating immediately\n            return if self.k != 0 && !self.pool.get_next() {\n                None\n            // Otherwise, yield the initial state\n            } else {\n                self.first = false;\n                Some(self.current())\n            };\n        }\n\n        // Check if we need to consume more from the iterator\n        // This will run while we increment our first index digit\n        if self.pool.get_next() {\n            self.max_index = self.pool.len() - 1;\n        }\n\n        // Work out where we need to update our indices\n        let mut increment: Option<(usize, usize)> = None;\n        for (i, indices_int) in self.indices.iter().enumerate().rev() {\n            if indices_int < &self.max_index {\n                increment = Some((i, indices_int + 1));\n                break;\n            }\n        }\n\n        match increment {\n            // If we can update the indices further\n            Some((increment_from, increment_value)) => {\n                // We need to update the rightmost non-max value\n                // and all those to the right\n                for indices_index in increment_from..self.indices.len() {\n                    self.indices[indices_index] = increment_value\n                }\n                Some(self.current())\n            }\n            // Otherwise, we're done\n            None => None,\n        }\n    }\n}\n","traces":[{"line":36,"address":[4209408],"length":1,"stats":{"Line":2},"fn_name":"current<adaptors_no_collect::PanickingCounter>"},{"line":37,"address":[4209552,4209566,4209420],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}<adaptors_no_collect::PanickingCounter>"},{"line":42,"address":[4209008,4209085],"length":1,"stats":{"Line":2},"fn_name":"combinations_with_replacement<adaptors_no_collect::PanickingCounter>"},{"line":47,"address":[4209033],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[4209100],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[4207440],"length":1,"stats":{"Line":2},"fn_name":"next<adaptors_no_collect::PanickingCounter>"},{"line":67,"address":[4207458],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[4207682,4207522,4207554,4207727],"length":1,"stats":{"Line":6},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[4207745,4208825,4208855],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":87,"address":[4208236,4208159],"length":1,"stats":{"Line":4},"fn_name":null},{"line":88,"address":[4208247],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[4208401],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":24,"coverable":24},{"path":["/","home","kms","itertools","src","concat_impl.rs"],"content":"use crate::Itertools;\n\n/// Combine all an iterator's elements into one element by using `Extend`.\n///\n/// `IntoIterator`-enabled version of `.concat()`\n///\n/// This combinator will extend the first item with each of the rest of the\n/// items of the iterator. If the iterator is empty, the default value of\n/// `I::Item` is returned.\n///\n/// ```rust\n/// use itertools::concat;\n/// \n/// let input = vec![vec![1], vec![2, 3], vec![4, 5, 6]];\n/// assert_eq!(concat(input), vec![1, 2, 3, 4, 5, 6]);\n/// ```\npub fn concat<I>(iterable: I) -> I::Item\n    where I: IntoIterator,\n          I::Item: Extend<<<I as IntoIterator>::Item as IntoIterator>::Item> + IntoIterator + Default\n{\n    iterable.into_iter().fold1(|mut a, b| { a.extend(b); a }).unwrap_or_else(|| <_>::default())\n}\n","traces":[{"line":17,"address":[4609936,4609824],"length":1,"stats":{"Line":2},"fn_name":"concat<alloc::vec::IntoIter<alloc::vec::Vec<i32>>>"},{"line":21,"address":[4609943,4610060,4610380,4610192,4610204,4609831,4610336,4610048,4610348,4610368],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}<alloc::vec::IntoIter<alloc::vec::Vec<i32>>>"}],"covered":2,"coverable":2},{"path":["/","home","kms","itertools","src","cons_tuples_impl.rs"],"content":"\nmacro_rules! impl_cons_iter(\n    ($_A:ident, $_B:ident, ) => (); // stop\n\n    ($A:ident, $($B:ident,)*) => (\n        impl_cons_iter!($($B,)*);\n        #[allow(non_snake_case)]\n        impl<X, Iter, $($B),*> Iterator for ConsTuples<Iter, (($($B,)*), X)>\n            where Iter: Iterator<Item = (($($B,)*), X)>,\n        {\n            type Item = ($($B,)* X, );\n            fn next(&mut self) -> Option<Self::Item> {\n                self.iter.next().map(|(($($B,)*), x)| ($($B,)* x, ))\n            }\n\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.iter.size_hint()\n            }\n            fn fold<Acc, Fold>(self, accum: Acc, mut f: Fold) -> Acc\n                where Fold: FnMut(Acc, Self::Item) -> Acc,\n            {\n                self.iter.fold(accum, move |acc, (($($B,)*), x)| f(acc, ($($B,)* x, )))\n            }\n        }\n\n        #[allow(non_snake_case)]\n        impl<X, Iter, $($B),*> DoubleEndedIterator for ConsTuples<Iter, (($($B,)*), X)>\n            where Iter: DoubleEndedIterator<Item = (($($B,)*), X)>,\n        {\n            fn next_back(&mut self) -> Option<Self::Item> {\n                self.iter.next().map(|(($($B,)*), x)| ($($B,)* x, ))\n            }\n        }\n\n    );\n);\n\nimpl_cons_iter!(A, B, C, D, E, F, G, H,);\n\n/// An iterator that maps an iterator of tuples like\n/// `((A, B), C)` to an iterator of `(A, B, C)`.\n///\n/// Used by the `iproduct!()` macro.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Debug)]\npub struct ConsTuples<I, J>\n    where I: Iterator<Item=J>,\n{\n    iter: I,\n}\n\nimpl<I, J> Clone for ConsTuples<I, J>\n    where I: Clone + Iterator<Item=J>,\n{\n    clone_fields!(iter);\n}\n\n/// Create an iterator that maps for example iterators of\n/// `((A, B), C)` to `(A, B, C)`.\npub fn cons_tuples<I, J>(iterable: I) -> ConsTuples<I, J>\n    where I: Iterator<Item=J>\n{\n    ConsTuples { iter: iterable.into_iter() }\n}\n","traces":[{"line":12,"address":[4299808],"length":1,"stats":{"Line":4},"fn_name":"next<i32,itertools::adaptors::Product<itertools::adaptors::Product<core::iter::adapters::Cloned<core::slice::Iter<i32>>, core::iter::adapters::Cloned<core::slice::Iter<i32>>>, core::iter::adapters::Cloned<core::slice::Iter<i32>>>,i32,i32>"},{"line":13,"address":[4299895,4299820,4299888],"length":1,"stats":{"Line":12},"fn_name":"{{closure}}<i32,itertools::adaptors::Product<itertools::adaptors::Product<core::iter::adapters::Cloned<core::slice::Iter<i32>>, core::iter::adapters::Cloned<core::slice::Iter<i32>>>, core::iter::adapters::Cloned<core::slice::Iter<i32>>>,i32,i32>"},{"line":16,"address":[5227120],"length":1,"stats":{"Line":2},"fn_name":"size_hint<i32,itertools::adaptors::Product<itertools::adaptors::Product<core::ops::range::Range<i32>, core::ops::range::Range<i32>>, core::ops::range::Range<i32>>,i32,i32>"},{"line":17,"address":[5227132],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[5693536],"length":1,"stats":{"Line":1},"fn_name":"fold<u16,itertools::adaptors::Product<itertools::adaptors::Product<quick::Iter<u16, quick::Inexact>, quick::Iter<u16, quick::Inexact>>, quick::Iter<u16, quick::Inexact>>,u16,u16,(),closure-1>"},{"line":22,"address":[5693673,5693548,5693632],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}<u16,itertools::adaptors::Product<itertools::adaptors::Product<quick::Iter<u16, quick::Inexact>, quick::Iter<u16, quick::Inexact>>, quick::Iter<u16, quick::Inexact>>,u16,u16,(),closure-1>"},{"line":60,"address":[4299984],"length":1,"stats":{"Line":4},"fn_name":"cons_tuples<itertools::adaptors::Product<itertools::adaptors::Product<core::iter::adapters::Cloned<core::slice::Iter<i32>>, core::iter::adapters::Cloned<core::slice::Iter<i32>>>, core::iter::adapters::Cloned<core::slice::Iter<i32>>>,((i32, i32), i32)>"},{"line":63,"address":[4299994],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":8,"coverable":8},{"path":["/","home","kms","itertools","src","diff.rs"],"content":"//! \"Diff\"ing iterators for caching elements to sequential collections without requiring the new\n//! elements' iterator to be `Clone`.\n//!\n//! - [**Diff**](./enum.Diff.html) (produced by the [**diff_with**](./fn.diff_with.html) function)\n//! describes the difference between two non-`Clone` iterators `I` and `J` after breaking ASAP from\n//! a lock-step comparison.\n\nuse crate::free::put_back;\nuse crate::structs::PutBack;\n\n/// A type returned by the [`diff_with`](./fn.diff_with.html) function.\n///\n/// `Diff` represents the way in which the elements yielded by the iterator `I` differ to some\n/// iterator `J`.\npub enum Diff<I, J>\n    where I: Iterator,\n          J: Iterator\n{\n    /// The index of the first non-matching element along with both iterator's remaining elements\n    /// starting with the first mis-match.\n    FirstMismatch(usize, PutBack<I>, PutBack<J>),\n    /// The total number of elements that were in `J` along with the remaining elements of `I`.\n    Shorter(usize, PutBack<I>),\n    /// The total number of elements that were in `I` along with the remaining elements of `J`.\n    Longer(usize, PutBack<J>),\n}\n\n/// Compares every element yielded by both `i` and `j` with the given function in lock-step and\n/// returns a `Diff` which describes how `j` differs from `i`.\n///\n/// If the number of elements yielded by `j` is less than the number of elements yielded by `i`,\n/// the number of `j` elements yielded will be returned along with `i`'s remaining elements as\n/// `Diff::Shorter`.\n///\n/// If the two elements of a step differ, the index of those elements along with the remaining\n/// elements of both `i` and `j` are returned as `Diff::FirstMismatch`.\n///\n/// If `i` becomes exhausted before `j` becomes exhausted, the number of elements in `i` along with\n/// the remaining `j` elements will be returned as `Diff::Longer`.\npub fn diff_with<I, J, F>(i: I, j: J, is_equal: F)\n    -> Option<Diff<I::IntoIter, J::IntoIter>>\n    where I: IntoIterator,\n          J: IntoIterator,\n          F: Fn(&I::Item, &J::Item) -> bool\n{\n    let mut i = i.into_iter();\n    let mut j = j.into_iter();\n    let mut idx = 0;\n    while let Some(i_elem) = i.next() {\n        match j.next() {\n            None => return Some(Diff::Shorter(idx, put_back(i).with_value(i_elem))),\n            Some(j_elem) => if !is_equal(&i_elem, &j_elem) {\n                let remaining_i = put_back(i).with_value(i_elem);\n                let remaining_j = put_back(j).with_value(j_elem);\n                return Some(Diff::FirstMismatch(idx, remaining_i, remaining_j));\n            },\n        }\n        idx += 1;\n    }\n    j.next().map(|j_elem| Diff::Longer(idx, put_back(j).with_value(j_elem)))\n}\n","traces":[{"line":40,"address":[4573436,4575296,4573216,4575516,4571356,4571136],"length":1,"stats":{"Line":3},"fn_name":"diff_with<core::slice::Iter<i32>,core::iter::adapters::Map<alloc::vec::IntoIter<f64>, closure-0>,closure-1>"},{"line":46,"address":[4575319,4571159,4573239],"length":1,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[4571297,4573469,4573377,4575457,4575549,4571389],"length":1,"stats":{"Line":6},"fn_name":null},{"line":48,"address":[4571397,4573477,4575557],"length":1,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[4576909,4575577,4574918,4575103,4575737,4574981,4573657,4572494,4571577,4572901,4571417,4573497,4574574,4572749,4577183,4574829,4577061,4572838,4576998,4573023,4576654],"length":1,"stats":{"Line":11},"fn_name":null},{"line":50,"address":[4571507,4573587,4571610,4575770,4575667,4573690],"length":1,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[4571612,4571677,4575712,4575772,4575837,4573692,4571552,4573632,4573757],"length":1,"stats":{"Line":5},"fn_name":null},{"line":52,"address":[4573943,4576023,4571863],"length":1,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[4571983,4574063,4576143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[4574141,4576221,4572061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[4574247,4576581,4572167,4576327,4574501,4572421],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[4577125,4577310,4574538,4572965,4576618,4575045,4575230,4573150,4572458],"length":1,"stats":{"Line":6},"fn_name":null},{"line":60,"address":[4577390,4572535,4576695,4574615,4577376,4577646,4577888,4577902,4577632],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}<core::slice::Iter<i32>,core::iter::adapters::Map<alloc::vec::IntoIter<f64>, closure-0>,closure-1>"}],"covered":13,"coverable":13},{"path":["/","home","kms","itertools","src","either_or_both.rs"],"content":"use crate::EitherOrBoth::*;\n\nuse either::Either;\n\n/// Value that either holds a single A or B, or both.\n#[derive(Clone, PartialEq, Eq, Hash, Debug)]\npub enum EitherOrBoth<A, B> {\n    /// Both values are present.\n    Both(A, B),\n    /// Only the left value of type `A` is present.\n    Left(A),\n    /// Only the right value of type `B` is present.\n    Right(B),\n}\n\nimpl<A, B> EitherOrBoth<A, B> {\n    /// If `Left`, or `Both`, return true, otherwise, return false.\n    pub fn has_left(&self) -> bool {\n        self.as_ref().left().is_some()\n    }\n\n    /// If `Right`, or `Both`, return true, otherwise, return false.\n    pub fn has_right(&self) -> bool {\n        self.as_ref().right().is_some()\n    }\n\n    /// If Left, return true otherwise, return false.\n    /// Exclusive version of [`has_left`].\n    pub fn is_left(&self) -> bool {\n        match *self {\n            Left(_) => true,\n            _ => false,\n        }\n    }\n\n    /// If Right, return true otherwise, return false.\n    /// Exclusive version of [`has_right`].\n    pub fn is_right(&self) -> bool {\n        match *self {\n            Right(_) => true,\n            _ => false,\n        }\n    }\n\n    /// If Right, return true otherwise, return false.\n    /// Equivalent to `self.as_ref().both().is_some()`.\n    pub fn is_both(&self) -> bool {\n        self.as_ref().both().is_some()\n    }\n\n    /// If `Left`, or `Both`, return `Some` with the left value, otherwise, return `None`.\n    pub fn left(self) -> Option<A> {\n        match self {\n            Left(left) | Both(left, _) => Some(left),\n            _ => None,\n        }\n    }\n\n    /// If `Right`, or `Both`, return `Some` with the right value, otherwise, return `None`.\n    pub fn right(self) -> Option<B> {\n        match self {\n            Right(right) | Both(_, right) => Some(right),\n            _ => None,\n        }\n    }\n\n    /// If Both, return `Some` tuple containing left and right.\n    pub fn both(self) -> Option<(A, B)> {\n        match self {\n            Both(a, b) => Some((a, b)),\n            _ => None,\n        }\n    }\n\n    /// Converts from `&EitherOrBoth<A, B>` to `EitherOrBoth<&A, &B>`.\n    pub fn as_ref(&self) -> EitherOrBoth<&A, &B> {\n        match *self {\n            Left(ref left) => Left(left),\n            Right(ref right) => Right(right),\n            Both(ref left, ref right) => Both(left, right),\n        }\n    }\n\n    /// Converts from `&mut EitherOrBoth<A, B>` to `EitherOrBoth<&mut A, &mut B>`.\n    pub fn as_mut(&mut self) -> EitherOrBoth<&mut A, &mut B> {\n        match *self {\n            Left(ref mut left) => Left(left),\n            Right(ref mut right) => Right(right),\n            Both(ref mut left, ref mut right) => Both(left, right),\n        }\n    }\n\n    /// Convert `EitherOrBoth<A, B>` to `EitherOrBoth<B, A>`.\n    pub fn flip(self) -> EitherOrBoth<B, A> {\n        match self {\n            Left(a) => Right(a),\n            Right(b) => Left(b),\n            Both(a, b) => Both(b, a),\n        }\n    }\n\n    /// Apply the function `f` on the value `a` in `Left(a)` or `Both(a, b)` variants. If it is\n    /// present rewrapping the result in `self`'s original variant.\n    pub fn map_left<F, M>(self, f: F) -> EitherOrBoth<M, B>\n    where\n        F: FnOnce(A) -> M,\n    {\n        match self {\n            Both(a, b) => Both(f(a), b),\n            Left(a) => Left(f(a)),\n            Right(b) => Right(b),\n        }\n    }\n\n    /// Apply the function `f` on the value `b` in `Right(b)` or `Both(a, b)` variants.\n    /// If it is present rewrapping the result in `self`'s original variant.\n    pub fn map_right<F, M>(self, f: F) -> EitherOrBoth<A, M>\n    where\n        F: FnOnce(B) -> M,\n    {\n        match self {\n            Left(a) => Left(a),\n            Right(b) => Right(f(b)),\n            Both(a, b) => Both(a, f(b)),\n        }\n    }\n\n    /// Apply the functions `f` and `g` on the value `a` and `b` respectively;\n    /// found in `Left(a)`, `Right(b)`, or `Both(a, b)` variants.\n    /// The Result is rewrapped `self`'s original variant.\n    pub fn map_any<F, L, G, R>(self, f: F, g: G) -> EitherOrBoth<L, R>\n    where\n        F: FnOnce(A) -> L,\n        G: FnOnce(B) -> R,\n    {\n        match self {\n            Left(a) => Left(f(a)),\n            Right(b) => Right(g(b)),\n            Both(a, b) => Both(f(a), g(b)),\n        }\n    }\n\n    /// Apply the function `f` on the value `b` in `Right(b)` or `Both(a, _)` variants if it is\n    /// present.\n    pub fn left_and_then<F, L>(self, f: F) -> EitherOrBoth<L, B>\n    where\n        F: FnOnce(A) -> EitherOrBoth<L, B>,\n    {\n        match self {\n            Left(a) | Both(a, _) => f(a),\n            Right(b) => Right(b),\n        }\n    }\n\n    /// Apply the function `f` on the value `a`\n    /// in `Left(a)` or `Both(a, _)` variants if it is present.\n    pub fn right_and_then<F, R>(self, f: F) -> EitherOrBoth<A, R>\n    where\n        F: FnOnce(B) -> EitherOrBoth<A, R>,\n    {\n        match self {\n            Left(a) => Left(a),\n            Right(b) | Both(_, b) => f(b),\n        }\n    }\n}\n\nimpl<T> EitherOrBoth<T, T> {\n    /// Return either value of left, right, or the product of `f` applied where `Both` are present.\n    pub fn reduce<F>(self, f: F) -> T\n    where\n        F: FnOnce(T, T) -> T,\n    {\n        match self {\n            Left(a) => a,\n            Right(b) => b,\n            Both(a, b) => f(a, b),\n        }\n    }\n}\n\nimpl<A, B> Into<Option<Either<A, B>>> for EitherOrBoth<A, B> {\n    fn into(self) -> Option<Either<A, B>> {\n        match self {\n            EitherOrBoth::Left(l) => Some(Either::Left(l)),\n            EitherOrBoth::Right(r) => Some(Either::Right(r)),\n            _ => None,\n        }\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":8,"coverable":68},{"path":["/","home","kms","itertools","src","exactly_one_err.rs"],"content":"use std::iter::ExactSizeIterator;\n\nuse crate::size_hint;\n\n/// Iterator returned for the error case of `IterTools::exactly_one()`\n/// This iterator yields exactly the same elements as the input iterator.\n///\n/// During the execution of exactly_one the iterator must be mutated.  This wrapper\n/// effectively \"restores\" the state of the input iterator when it's handed back.\n///\n/// This is very similar to PutBackN except this iterator only supports 0-2 elements and does not\n/// use a `Vec`.\n#[derive(Debug, Clone)]\npub struct ExactlyOneError<I>\nwhere\n    I: Iterator,\n{\n    first_two: (Option<I::Item>, Option<I::Item>),\n    inner: I,\n}\n\nimpl<I> ExactlyOneError<I>\nwhere\n    I: Iterator,\n{\n    /// Creates a new `ExactlyOneErr` iterator.\n    pub(crate) fn new(first_two: (Option<I::Item>, Option<I::Item>), inner: I) -> Self {\n        Self { first_two, inner }\n    }\n}\n\nimpl<I> Iterator for ExactlyOneError<I>\nwhere\n    I: Iterator,\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.first_two\n            .0\n            .take()\n            .or_else(|| self.first_two.1.take())\n            .or_else(|| self.inner.next())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let mut additional_len = 0;\n        if self.first_two.0.is_some() {\n            additional_len += 1;\n        }\n        if self.first_two.1.is_some() {\n            additional_len += 1;\n        }\n        size_hint::add_scalar(self.inner.size_hint(), additional_len)\n    }\n}\n\nimpl<I> ExactSizeIterator for ExactlyOneError<I> where I: ExactSizeIterator {}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[4311102,4311273,4311529,4311264,4311465,4311520,4311456,4310846,4310974],"length":1,"stats":{"Line":12},"fn_name":"{{closure}}<core::iter::adapters::Filter<core::ops::range::Range<i32>, closure-3>>"},{"line":43,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":5,"coverable":13},{"path":["/","home","kms","itertools","src","format.rs"],"content":"use std::fmt;\nuse std::cell::RefCell;\n\n/// Format all iterator elements lazily, separated by `sep`.\n///\n/// The format value can only be formatted once, after that the iterator is\n/// exhausted.\n///\n/// See [`.format_with()`](../trait.Itertools.html#method.format_with) for more information.\n#[derive(Clone)]\npub struct FormatWith<'a, I, F> {\n    sep: &'a str,\n    /// FormatWith uses interior mutability because Display::fmt takes &self.\n    inner: RefCell<Option<(I, F)>>,\n}\n\n/// Format all iterator elements lazily, separated by `sep`.\n///\n/// The format value can only be formatted once, after that the iterator is\n/// exhausted.\n///\n/// See [`.format()`](../trait.Itertools.html#method.format)\n/// for more information.\n#[derive(Clone)]\npub struct Format<'a, I> {\n    sep: &'a str,\n    /// Format uses interior mutability because Display::fmt takes &self.\n    inner: RefCell<Option<I>>,\n}\n\npub fn new_format<'a, I, F>(iter: I, separator: &'a str, f: F) -> FormatWith<'a, I, F>\n    where I: Iterator,\n          F: FnMut(I::Item, &mut dyn FnMut(&dyn fmt::Display) -> fmt::Result) -> fmt::Result\n{\n    FormatWith {\n        sep: separator,\n        inner: RefCell::new(Some((iter, f))),\n    }\n}\n\npub fn new_format_default<'a, I>(iter: I, separator: &'a str) -> Format<'a, I>\n    where I: Iterator,\n{\n    Format {\n        sep: separator,\n        inner: RefCell::new(Some(iter)),\n    }\n}\n\nimpl<'a, I, F> fmt::Display for FormatWith<'a, I, F>\n    where I: Iterator,\n          F: FnMut(I::Item, &mut dyn  FnMut(&dyn fmt::Display) -> fmt::Result) -> fmt::Result\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let (mut iter, mut format) = match self.inner.borrow_mut().take() {\n            Some(t) => t,\n            None => panic!(\"FormatWith: was already formatted once\"),\n        };\n\n        if let Some(fst) = iter.next() {\n            format(fst, &mut |disp: &dyn fmt::Display| disp.fmt(f))?;\n            for elt in iter {\n                if self.sep.len() > 0 {\n\n                    f.write_str(self.sep)?;\n                }\n                format(elt, &mut |disp: &dyn fmt::Display| disp.fmt(f))?;\n            }\n        }\n        Ok(())\n    }\n}\n\nimpl<'a, I> Format<'a, I>\n    where I: Iterator,\n{\n    fn format<F>(&self, f: &mut fmt::Formatter, mut cb: F) -> fmt::Result\n        where F: FnMut(&I::Item, &mut fmt::Formatter) -> fmt::Result,\n    {\n        let mut iter = match self.inner.borrow_mut().take() {\n            Some(t) => t,\n            None => panic!(\"Format: was already formatted once\"),\n        };\n\n        if let Some(fst) = iter.next() {\n            cb(&fst, f)?;\n            for elt in iter {\n                if self.sep.len() > 0 {\n                    f.write_str(self.sep)?;\n                }\n                cb(&elt, f)?;\n            }\n        }\n        Ok(())\n    }\n}\n\nmacro_rules! impl_format {\n    ($($fmt_trait:ident)*) => {\n        $(\n            impl<'a, I> fmt::$fmt_trait for Format<'a, I>\n                where I: Iterator,\n                      I::Item: fmt::$fmt_trait,\n            {\n                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                    self.format(f, fmt::$fmt_trait::fmt)\n                }\n            }\n        )*\n    }\n}\n\nimpl_format!{Display Debug\n             UpperExp LowerExp UpperHex LowerHex Octal Binary Pointer}\n","traces":[{"line":41,"address":[4221312,4221488],"length":1,"stats":{"Line":2},"fn_name":"new_format_default<core::slice::Iter<f64>>"},{"line":46,"address":[4221349,4221525],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[4216486,4219680,4216416,4218048,4218118,4219750],"length":1,"stats":{"Line":3},"fn_name":"format<core::slice::Iter<f64>,fn(&&f64, &mut core::fmt::Formatter) -> core::result::Result<(), core::fmt::Error>>"},{"line":80,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[4216320,4216368,4216272],"length":1,"stats":{"Line":3},"fn_name":"fmt<core::slice::Iter<i32>>"},{"line":106,"address":[4216334,4216382,4216286],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":14,"coverable":26},{"path":["/","home","kms","itertools","src","free.rs"],"content":"//! Free functions that create iterator adaptors or call iterator methods.\n//!\n//! The benefit of free functions is that they accept any `IntoIterator` as\n//! argument, so the resulting code may be easier to read.\n\n#[cfg(feature = \"use_std\")]\nuse std::fmt::Display;\nuse std::iter::{self, Zip};\n#[cfg(feature = \"use_std\")]\ntype VecIntoIter<T> = ::std::vec::IntoIter<T>;\n\n#[cfg(feature = \"use_std\")]\nuse crate::Itertools;\n\npub use crate::adaptors::{\n    interleave,\n    merge,\n    put_back,\n};\n#[cfg(feature = \"use_std\")]\npub use crate::put_back_n_impl::put_back_n;\n#[cfg(feature = \"use_std\")]\npub use crate::multipeek_impl::multipeek;\n#[cfg(feature = \"use_std\")]\npub use crate::peek_nth::peek_nth;\n#[cfg(feature = \"use_std\")]\npub use crate::kmerge_impl::kmerge;\npub use crate::zip_eq_impl::zip_eq;\npub use crate::merge_join::merge_join_by;\n#[cfg(feature = \"use_std\")]\npub use crate::rciter_impl::rciter;\n\n/// Iterate `iterable` with a running index.\n///\n/// `IntoIterator` enabled version of `.enumerate()`.\n///\n/// ```\n/// use itertools::enumerate;\n///\n/// for (i, elt) in enumerate(&[1, 2, 3]) {\n///     /* loop body */\n/// }\n/// ```\npub fn enumerate<I>(iterable: I) -> iter::Enumerate<I::IntoIter>\n    where I: IntoIterator\n{\n    iterable.into_iter().enumerate()\n}\n\n/// Iterate `iterable` in reverse.\n///\n/// `IntoIterator` enabled version of `.rev()`.\n///\n/// ```\n/// use itertools::rev;\n///\n/// for elt in rev(&[1, 2, 3]) {\n///     /* loop body */\n/// }\n/// ```\npub fn rev<I>(iterable: I) -> iter::Rev<I::IntoIter>\n    where I: IntoIterator,\n          I::IntoIter: DoubleEndedIterator\n{\n    iterable.into_iter().rev()\n}\n\n/// Iterate `i` and `j` in lock step.\n///\n/// `IntoIterator` enabled version of `i.zip(j)`.\n///\n/// ```\n/// use itertools::zip;\n///\n/// let data = [1, 2, 3, 4, 5];\n/// for (a, b) in zip(&data, &data[1..]) {\n///     /* loop body */\n/// }\n/// ```\npub fn zip<I, J>(i: I, j: J) -> Zip<I::IntoIter, J::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator\n{\n    i.into_iter().zip(j)\n}\n\n/// Create an iterator that first iterates `i` and then `j`.\n///\n/// `IntoIterator` enabled version of `i.chain(j)`.\n///\n/// ```\n/// use itertools::chain;\n///\n/// for elt in chain(&[1, 2, 3], &[4]) {\n///     /* loop body */\n/// }\n/// ```\npub fn chain<I, J>(i: I, j: J) -> iter::Chain<<I as IntoIterator>::IntoIter, <J as IntoIterator>::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator<Item = I::Item>\n{\n    i.into_iter().chain(j)\n}\n\n/// Create an iterator that clones each element from &T to T\n///\n/// `IntoIterator` enabled version of `i.cloned()`.\n///\n/// ```\n/// use itertools::cloned;\n///\n/// assert_eq!(cloned(b\"abc\").next(), Some(b'a'));\n/// ```\npub fn cloned<'a, I, T: 'a>(iterable: I) -> iter::Cloned<I::IntoIter>\n    where I: IntoIterator<Item=&'a T>,\n          T: Clone,\n{\n    iterable.into_iter().cloned()\n}\n\n/// Perform a fold operation over the iterable.\n///\n/// `IntoIterator` enabled version of `i.fold(init, f)`\n///\n/// ```\n/// use itertools::fold;\n///\n/// assert_eq!(fold(&[1., 2., 3.], 0., |a, &b| f32::max(a, b)), 3.);\n/// ```\npub fn fold<I, B, F>(iterable: I, init: B, f: F) -> B\n    where I: IntoIterator,\n          F: FnMut(B, I::Item) -> B\n{\n    iterable.into_iter().fold(init, f)\n}\n\n/// Test whether the predicate holds for all elements in the iterable.\n///\n/// `IntoIterator` enabled version of `i.all(f)`\n///\n/// ```\n/// use itertools::all;\n///\n/// assert!(all(&[1, 2, 3], |elt| *elt > 0));\n/// ```\npub fn all<I, F>(iterable: I, f: F) -> bool\n    where I: IntoIterator,\n          F: FnMut(I::Item) -> bool\n{\n    iterable.into_iter().all(f)\n}\n\n/// Test whether the predicate holds for any elements in the iterable.\n///\n/// `IntoIterator` enabled version of `i.any(f)`\n///\n/// ```\n/// use itertools::any;\n///\n/// assert!(any(&[0, -1, 2], |elt| *elt > 0));\n/// ```\npub fn any<I, F>(iterable: I, f: F) -> bool\n    where I: IntoIterator,\n          F: FnMut(I::Item) -> bool\n{\n    iterable.into_iter().any(f)\n}\n\n/// Return the maximum value of the iterable.\n///\n/// `IntoIterator` enabled version of `i.max()`.\n///\n/// ```\n/// use itertools::max;\n///\n/// assert_eq!(max(0..10), Some(9));\n/// ```\npub fn max<I>(iterable: I) -> Option<I::Item>\n    where I: IntoIterator,\n          I::Item: Ord\n{\n    iterable.into_iter().max()\n}\n\n/// Return the minimum value of the iterable.\n///\n/// `IntoIterator` enabled version of `i.min()`.\n///\n/// ```\n/// use itertools::min;\n///\n/// assert_eq!(min(0..10), Some(0));\n/// ```\npub fn min<I>(iterable: I) -> Option<I::Item>\n    where I: IntoIterator,\n          I::Item: Ord\n{\n    iterable.into_iter().min()\n}\n\n\n/// Combine all iterator elements into one String, seperated by `sep`.\n///\n/// `IntoIterator` enabled version of `iterable.join(sep)`.\n///\n/// ```\n/// use itertools::join;\n///\n/// assert_eq!(join(&[1, 2, 3], \", \"), \"1, 2, 3\");\n/// ```\n#[cfg(feature = \"use_std\")]\npub fn join<I>(iterable: I, sep: &str) -> String\n    where I: IntoIterator,\n          I::Item: Display\n{\n    iterable.into_iter().join(sep)\n}\n\n/// Sort all iterator elements into a new iterator in ascending order.\n///\n/// `IntoIterator` enabled version of [`iterable.sorted()`][1].\n///\n/// [1]: trait.Itertools.html#method.sorted\n///\n/// ```\n/// use itertools::sorted;\n/// use itertools::assert_equal;\n///\n/// assert_equal(sorted(\"rust\".chars()), \"rstu\".chars());\n/// ```\n#[cfg(feature = \"use_std\")]\npub fn sorted<I>(iterable: I) -> VecIntoIter<I::Item>\n    where I: IntoIterator,\n          I::Item: Ord\n{\n    iterable.into_iter().sorted()\n}\n\n","traces":[{"line":44,"address":[6191648],"length":1,"stats":{"Line":1},"fn_name":"enumerate<&alloc::vec::Vec<u8>>"},{"line":47,"address":[6191660],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[6191312,6191424],"length":1,"stats":{"Line":1},"fn_name":"zip<&[i32],&[i32]>"},{"line":84,"address":[6191339],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[5191952],"length":1,"stats":{"Line":3},"fn_name":"cloned<&[i32; 4],i32>"},{"line":118,"address":[5191961],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","kms","itertools","src","group_map.rs"],"content":"#![cfg(feature = \"use_std\")]\n\nuse std::collections::HashMap;\nuse std::hash::Hash;\nuse std::iter::Iterator;\n\n/// Return a `HashMap` of keys mapped to a list of their corresponding values.\n///\n/// See [`.into_group_map()`](../trait.Itertools.html#method.into_group_map)\n/// for more information.\npub fn into_group_map<I, K, V>(iter: I) -> HashMap<K, Vec<V>>\n    where I: Iterator<Item=(K, V)>,\n          K: Hash + Eq,\n{\n    let mut lookup = HashMap::new();\n\n    for (key, val) in iter {\n        lookup.entry(key).or_insert(Vec::new()).push(val);\n    }\n\n    lookup\n}","traces":[{"line":11,"address":[6195104,6195192],"length":1,"stats":{"Line":1},"fn_name":"into_group_map<core::iter::adapters::Map<alloc::vec::IntoIter<u8>, closure-0>,u8,u8>"},{"line":15,"address":[6195114],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[6195329,6195823,6195681,6195207,6195906],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[6195554,6195930,6195875],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[6195691],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":5,"coverable":5},{"path":["/","home","kms","itertools","src","groupbylazy.rs"],"content":"use std::cell::{Cell, RefCell};\nuse std::vec;\n\n/// A trait to unify FnMut for GroupBy with the chunk key in IntoChunks\ntrait KeyFunction<A> {\n    type Key;\n    fn call_mut(&mut self, arg: A) -> Self::Key;\n}\n\nimpl<'a, A, K, F: ?Sized> KeyFunction<A> for F\n    where F: FnMut(A) -> K\n{\n    type Key = K;\n    #[inline]\n    fn call_mut(&mut self, arg: A) -> Self::Key {\n        (*self)(arg)\n    }\n}\n\n\n/// ChunkIndex acts like the grouping key function for IntoChunks\n#[derive(Debug)]\nstruct ChunkIndex {\n    size: usize,\n    index: usize,\n    key: usize,\n}\n\nimpl ChunkIndex {\n    #[inline(always)]\n    fn new(size: usize) -> Self {\n        ChunkIndex {\n            size,\n            index: 0,\n            key: 0,\n        }\n    }\n}\n\nimpl<'a, A> KeyFunction<A> for ChunkIndex {\n    type Key = usize;\n    #[inline(always)]\n    fn call_mut(&mut self, _arg: A) -> Self::Key {\n        if self.index == self.size {\n            self.key += 1;\n            self.index = 0;\n        }\n        self.index += 1;\n        self.key\n    }\n}\n\n\nstruct GroupInner<K, I, F>\n    where I: Iterator\n{\n    key: F,\n    iter: I,\n    current_key: Option<K>,\n    current_elt: Option<I::Item>,\n    /// flag set if iterator is exhausted\n    done: bool,\n    /// Index of group we are currently buffering or visiting\n    top_group: usize,\n    /// Least index for which we still have elements buffered\n    oldest_buffered_group: usize,\n    /// Group index for `buffer[0]` -- the slots\n    /// bottom_group..oldest_buffered_group are unused and will be erased when\n    /// that range is large enough.\n    bottom_group: usize,\n    /// Buffered groups, from `bottom_group` (index 0) to `top_group`.\n    buffer: Vec<vec::IntoIter<I::Item>>,\n    /// index of last group iter that was dropped, usize::MAX == none\n    dropped_group: usize,\n}\n\nimpl<K, I, F> GroupInner<K, I, F>\n    where I: Iterator,\n          F: for<'a> KeyFunction<&'a I::Item, Key=K>,\n          K: PartialEq,\n{\n    /// `client`: Index of group that requests next element\n    #[inline(always)]\n    fn step(&mut self, client: usize) -> Option<I::Item> {\n        /*\n        println!(\"client={}, bottom_group={}, oldest_buffered_group={}, top_group={}, buffers=[{}]\",\n                 client, self.bottom_group, self.oldest_buffered_group,\n                 self.top_group,\n                 self.buffer.iter().map(|elt| elt.len()).format(\", \"));\n        */\n        if client < self.oldest_buffered_group {\n            None\n        } else if client < self.top_group ||\n            (client == self.top_group &&\n             self.buffer.len() > self.top_group - self.bottom_group)\n        {\n            self.lookup_buffer(client)\n        } else if self.done {\n            None\n        } else if self.top_group == client {\n            self.step_current()\n        } else {\n            self.step_buffering(client)\n        }\n    }\n\n    #[inline(never)]\n    fn lookup_buffer(&mut self, client: usize) -> Option<I::Item> {\n        // if `bufidx` doesn't exist in self.buffer, it might be empty\n        let bufidx = client - self.bottom_group;\n        if client < self.oldest_buffered_group {\n            return None;\n        }\n        let elt = self.buffer.get_mut(bufidx).and_then(|queue| queue.next());\n        if elt.is_none() && client == self.oldest_buffered_group {\n            // FIXME: VecDeque is unfortunately not zero allocation when empty,\n            // so we do this job manually.\n            // `bottom_group..oldest_buffered_group` is unused, and if it's large enough, erase it.\n            self.oldest_buffered_group += 1;\n            // skip forward further empty queues too\n            while self.buffer.get(self.oldest_buffered_group - self.bottom_group)\n                             .map_or(false, |buf| buf.len() == 0)\n            {\n                self.oldest_buffered_group += 1;\n            }\n\n            let nclear = self.oldest_buffered_group - self.bottom_group;\n            if nclear > 0 && nclear >= self.buffer.len() / 2 {\n                let mut i = 0;\n                self.buffer.retain(|buf| {\n                    i += 1;\n                    debug_assert!(buf.len() == 0 || i > nclear);\n                    i > nclear\n                });\n                self.bottom_group = self.oldest_buffered_group;\n            }\n        }\n        elt\n    }\n\n    /// Take the next element from the iterator, and set the done\n    /// flag if exhausted. Must not be called after done.\n    #[inline(always)]\n    fn next_element(&mut self) -> Option<I::Item> {\n        debug_assert!(!self.done);\n        match self.iter.next() {\n            None => { self.done = true; None }\n            otherwise => otherwise,\n        }\n    }\n\n\n    #[inline(never)]\n    fn step_buffering(&mut self, client: usize) -> Option<I::Item> {\n        // requested a later group -- walk through the current group up to\n        // the requested group index, and buffer the elements (unless\n        // the group is marked as dropped).\n        // Because the `Groups` iterator is always the first to request\n        // each group index, client is the next index efter top_group.\n        debug_assert!(self.top_group + 1 == client);\n        let mut group = Vec::new();\n\n        if let Some(elt) = self.current_elt.take() {\n            if self.top_group != self.dropped_group {\n                group.push(elt);\n            }\n        }\n        let mut first_elt = None; // first element of the next group\n\n        while let Some(elt) = self.next_element() {\n            let key = self.key.call_mut(&elt);\n            match self.current_key.take() {\n                None => {}\n                Some(old_key) => if old_key != key {\n                    self.current_key = Some(key);\n                    first_elt = Some(elt);\n                    break;\n                },\n            }\n            self.current_key = Some(key);\n            if self.top_group != self.dropped_group {\n                group.push(elt);\n            }\n        }\n\n        if self.top_group != self.dropped_group {\n            self.push_next_group(group);\n        }\n        if first_elt.is_some() {\n            self.top_group += 1;\n            debug_assert!(self.top_group == client);\n        }\n        first_elt\n    }\n\n    fn push_next_group(&mut self, group: Vec<I::Item>) {\n        // When we add a new buffered group, fill up slots between oldest_buffered_group and top_group\n        while self.top_group - self.bottom_group > self.buffer.len() {\n            if self.buffer.is_empty() {\n                self.bottom_group += 1;\n                self.oldest_buffered_group += 1;\n            } else {\n                self.buffer.push(Vec::new().into_iter());\n            }\n        }\n        self.buffer.push(group.into_iter());\n        debug_assert!(self.top_group + 1 - self.bottom_group == self.buffer.len());\n    }\n\n    /// This is the immediate case, where we use no buffering\n    #[inline]\n    fn step_current(&mut self) -> Option<I::Item> {\n        debug_assert!(!self.done);\n        if let elt @ Some(..) = self.current_elt.take() {\n            return elt;\n        }\n        match self.next_element() {\n            None => None,\n            Some(elt) => {\n                let key = self.key.call_mut(&elt);\n                match self.current_key.take() {\n                    None => {}\n                    Some(old_key) => if old_key != key {\n                        self.current_key = Some(key);\n                        self.current_elt = Some(elt);\n                        self.top_group += 1;\n                        return None;\n                    },\n                }\n                self.current_key = Some(key);\n                Some(elt)\n            }\n        }\n    }\n\n    /// Request the just started groups' key.\n    ///\n    /// `client`: Index of group\n    ///\n    /// **Panics** if no group key is available.\n    fn group_key(&mut self, client: usize) -> K {\n        // This can only be called after we have just returned the first\n        // element of a group.\n        // Perform this by simply buffering one more element, grabbing the\n        // next key.\n        debug_assert!(!self.done);\n        debug_assert!(client == self.top_group);\n        debug_assert!(self.current_key.is_some());\n        debug_assert!(self.current_elt.is_none());\n        let old_key = self.current_key.take().unwrap();\n        if let Some(elt) = self.next_element() {\n            let key = self.key.call_mut(&elt);\n            if old_key != key {\n                self.top_group += 1;\n            }\n            self.current_key = Some(key);\n            self.current_elt = Some(elt);\n        }\n        old_key\n    }\n}\n\nimpl<K, I, F> GroupInner<K, I, F>\n    where I: Iterator,\n{\n    /// Called when a group is dropped\n    fn drop_group(&mut self, client: usize) {\n        // It's only useful to track the maximal index\n        if self.dropped_group == !0 || client > self.dropped_group {\n            self.dropped_group = client;\n        }\n    }\n}\n\n/// `GroupBy` is the storage for the lazy grouping operation.\n///\n/// If the groups are consumed in their original order, or if each\n/// group is dropped without keeping it around, then `GroupBy` uses\n/// no allocations. It needs allocations only if several group iterators\n/// are alive at the same time.\n///\n/// This type implements `IntoIterator` (it is **not** an iterator\n/// itself), because the group iterators need to borrow from this\n/// value. It should be stored in a local variable or temporary and\n/// iterated.\n///\n/// See [`.group_by()`](../trait.Itertools.html#method.group_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct GroupBy<K, I, F>\n    where I: Iterator,\n{\n    inner: RefCell<GroupInner<K, I, F>>,\n    // the group iterator's current index. Keep this in the main value\n    // so that simultaneous iterators all use the same state.\n    index: Cell<usize>,\n}\n\n/// Create a new\npub fn new<K, J, F>(iter: J, f: F) -> GroupBy<K, J::IntoIter, F>\n    where J: IntoIterator,\n          F: FnMut(&J::Item) -> K,\n{\n    GroupBy {\n        inner: RefCell::new(GroupInner {\n            key: f,\n            iter: iter.into_iter(),\n            current_key: None,\n            current_elt: None,\n            done: false,\n            top_group: 0,\n            oldest_buffered_group: 0,\n            bottom_group: 0,\n            buffer: Vec::new(),\n            dropped_group: !0,\n        }),\n        index: Cell::new(0),\n    }\n}\n\nimpl<K, I, F> GroupBy<K, I, F>\n    where I: Iterator,\n{\n    /// `client`: Index of group that requests next element\n    fn step(&self, client: usize) -> Option<I::Item>\n        where F: FnMut(&I::Item) -> K,\n              K: PartialEq,\n    {\n        self.inner.borrow_mut().step(client)\n    }\n\n    /// `client`: Index of group\n    fn drop_group(&self, client: usize) {\n        self.inner.borrow_mut().drop_group(client)\n    }\n}\n\nimpl<'a, K, I, F> IntoIterator for &'a GroupBy<K, I, F>\n    where I: Iterator,\n          I::Item: 'a,\n          F: FnMut(&I::Item) -> K,\n          K: PartialEq\n{\n    type Item = (K, Group<'a, K, I, F>);\n    type IntoIter = Groups<'a, K, I, F>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        Groups { parent: self }\n    }\n}\n\n\n/// An iterator that yields the Group iterators.\n///\n/// Iterator element type is `(K, Group)`:\n/// the group's key `K` and the group's iterator.\n///\n/// See [`.group_by()`](../trait.Itertools.html#method.group_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Groups<'a, K: 'a, I: 'a, F: 'a>\n    where I: Iterator,\n          I::Item: 'a\n{\n    parent: &'a GroupBy<K, I, F>,\n}\n\nimpl<'a, K, I, F> Iterator for Groups<'a, K, I, F>\n    where I: Iterator,\n          I::Item: 'a,\n          F: FnMut(&I::Item) -> K,\n          K: PartialEq\n{\n    type Item = (K, Group<'a, K, I, F>);\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let index = self.parent.index.get();\n        self.parent.index.set(index + 1);\n        let inner = &mut *self.parent.inner.borrow_mut();\n        inner.step(index).map(|elt| {\n            let key = inner.group_key(index);\n            (key, Group {\n                parent: self.parent,\n                index,\n                first: Some(elt),\n            })\n        })\n    }\n}\n\n/// An iterator for the elements in a single group.\n///\n/// Iterator element type is `I::Item`.\npub struct Group<'a, K: 'a, I: 'a, F: 'a>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    parent: &'a GroupBy<K, I, F>,\n    index: usize,\n    first: Option<I::Item>,\n}\n\nimpl<'a, K, I, F> Drop for Group<'a, K, I, F>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    fn drop(&mut self) {\n        self.parent.drop_group(self.index);\n    }\n}\n\nimpl<'a, K, I, F> Iterator for Group<'a, K, I, F>\n    where I: Iterator,\n          I::Item: 'a,\n          F: FnMut(&I::Item) -> K,\n          K: PartialEq,\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        if let elt @ Some(..) = self.first.take() {\n            return elt;\n        }\n        self.parent.step(self.index)\n    }\n}\n\n///// IntoChunks /////\n\n/// Create a new\npub fn new_chunks<J>(iter: J, size: usize) -> IntoChunks<J::IntoIter>\n    where J: IntoIterator,\n{\n    IntoChunks {\n        inner: RefCell::new(GroupInner {\n            key: ChunkIndex::new(size),\n            iter: iter.into_iter(),\n            current_key: None,\n            current_elt: None,\n            done: false,\n            top_group: 0,\n            oldest_buffered_group: 0,\n            bottom_group: 0,\n            buffer: Vec::new(),\n            dropped_group: !0,\n        }),\n        index: Cell::new(0),\n    }\n}\n\n\n/// `ChunkLazy` is the storage for a lazy chunking operation.\n///\n/// `IntoChunks` behaves just like `GroupBy`: it is iterable, and\n/// it only buffers if several chunk iterators are alive at the same time.\n///\n/// This type implements `IntoIterator` (it is **not** an iterator\n/// itself), because the chunk iterators need to borrow from this\n/// value. It should be stored in a local variable or temporary and\n/// iterated.\n///\n/// Iterator element type is `Chunk`, each chunk's iterator.\n///\n/// See [`.chunks()`](../trait.Itertools.html#method.chunks) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct IntoChunks<I>\n    where I: Iterator,\n{\n    inner: RefCell<GroupInner<usize, I, ChunkIndex>>,\n    // the chunk iterator's current index. Keep this in the main value\n    // so that simultaneous iterators all use the same state.\n    index: Cell<usize>,\n}\n\n\nimpl<I> IntoChunks<I>\n    where I: Iterator,\n{\n    /// `client`: Index of chunk that requests next element\n    fn step(&self, client: usize) -> Option<I::Item> {\n        self.inner.borrow_mut().step(client)\n    }\n\n    /// `client`: Index of chunk\n    fn drop_group(&self, client: usize) {\n        self.inner.borrow_mut().drop_group(client)\n    }\n}\n\nimpl<'a, I> IntoIterator for &'a IntoChunks<I>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    type Item = Chunk<'a, I>;\n    type IntoIter = Chunks<'a, I>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        Chunks {\n            parent: self,\n        }\n    }\n}\n\n\n/// An iterator that yields the Chunk iterators.\n///\n/// Iterator element type is `Chunk`.\n///\n/// See [`.chunks()`](../trait.Itertools.html#method.chunks) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Chunks<'a, I: 'a>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    parent: &'a IntoChunks<I>,\n}\n\nimpl<'a, I> Iterator for Chunks<'a, I>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    type Item = Chunk<'a, I>;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let index = self.parent.index.get();\n        self.parent.index.set(index + 1);\n        let inner = &mut *self.parent.inner.borrow_mut();\n        inner.step(index).map(|elt| {\n            Chunk {\n                parent: self.parent,\n                index,\n                first: Some(elt),\n            }\n        })\n    }\n}\n\n/// An iterator for the elements in a single chunk.\n///\n/// Iterator element type is `I::Item`.\npub struct Chunk<'a, I: 'a>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    parent: &'a IntoChunks<I>,\n    index: usize,\n    first: Option<I::Item>,\n}\n\nimpl<'a, I> Drop for Chunk<'a, I>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    fn drop(&mut self) {\n        self.parent.drop_group(self.index);\n    }\n}\n\nimpl<'a, I> Iterator for Chunk<'a, I>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        if let elt @ Some(..) = self.first.take() {\n            return elt;\n        }\n        self.parent.step(self.index)\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":74},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":83},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":74},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":74},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":168,"address":[4300759,4302856,4320046,4326375,4298686,4322160,4296599,4313751,4311664,4307422,4324288,4317959,4305292,4315872,4309536],"length":1,"stats":{"Line":10},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":76},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":57},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":299,"address":[4354672,4357536,4357653,4352855,4355184,4356144,4358628,4354308,4358992,4359109,4353696,4356261,4355303,4358000,4357189,4352736,4356725,4354176,4357072,4353335,4354802,4355783,4353815,4356608,4358132,4358496,4355664,4353216],"length":1,"stats":{"Line":18},"fn_name":"new<&i32,core::slice::Iter<i32>,closure-0>"},{"line":304,"address":[4355807,4356285,4357677,4353359,4352879,4357213,4358156,4353839,4356749,4359133,4355327,4354332,4358652,4354825],"length":1,"stats":{"Line":18},"fn_name":null},{"line":316,"address":[4354529,4359317,4353547,4357397,4356469,4357861,4354027,4356933,4355995,4358353,4358849,4355037,4355515,4353067],"length":1,"stats":{"Line":18},"fn_name":null},{"line":324,"address":[4252980,4249280,4249824,4254528,4250948,4250407,4251940,4248820,4249863,4249319,4253440,4248324,4252439,4253984,4250912,4251408,4250368,4248288,4251444,4252400,4254023,4248784,4254564,4253479,4251904,4252944],"length":1,"stats":{"Line":17},"fn_name":"step<char,core::str::Chars,closure-5>"},{"line":328,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":430,"address":[4245322,4245216],"length":1,"stats":{"Line":2},"fn_name":"new_chunks<core::slice::Iter<i32>>"},{"line":434,"address":[4245241,4245436],"length":1,"stats":{"Line":4},"fn_name":null},{"line":446,"address":[4245659],"length":1,"stats":{"Line":2},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":151,"coverable":157},{"path":["/","home","kms","itertools","src","impl_macros.rs"],"content":"//! \n//! Implementation's internal macros\n\nmacro_rules! debug_fmt_fields {\n    ($tyname:ident, $($($field:ident).+),*) => {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            f.debug_struct(stringify!($tyname))\n                $(\n              .field(stringify!($($field).+), &self.$($field).+)\n              )*\n              .finish()\n        }\n    }\n}\n\nmacro_rules! clone_fields {\n    ($($field:ident),*) => {\n        fn clone(&self) -> Self {\n            Self {\n                $($field: self.$field.clone(),)*\n            }\n        }\n    }\n}\n","traces":[{"line":18,"address":[4243392,4243440],"length":1,"stats":{"Line":4},"fn_name":"clone<alloc::vec::IntoIter<usize>,alloc::vec::IntoIter<usize>,fn(&usize, &usize) -> core::cmp::Ordering>"},{"line":19,"address":[4243508],"length":1,"stats":{"Line":4},"fn_name":null},{"line":20,"address":[4243455,4243407],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","home","kms","itertools","src","intersperse.rs"],"content":"use std::iter::Fuse;\nuse super::size_hint;\n\n#[derive(Clone)]\n/// An iterator adaptor to insert a particular value\n/// between each element of the adapted iterator.\n///\n/// Iterator element type is `I::Item`\n///\n/// This iterator is *fused*.\n///\n/// See [`.intersperse()`](../trait.Itertools.html#method.intersperse) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Debug)]\npub struct Intersperse<I>\n    where I: Iterator\n{\n    element: I::Item,\n    iter: Fuse<I>,\n    peek: Option<I::Item>,\n}\n\n/// Create a new Intersperse iterator\npub fn intersperse<I>(iter: I, elt: I::Item) -> Intersperse<I>\n    where I: Iterator\n{\n    let mut iter = iter.fuse();\n    Intersperse {\n        peek: iter.next(),\n        iter,\n        element: elt,\n    }\n}\n\nimpl<I> Iterator for Intersperse<I>\n    where I: Iterator,\n          I::Item: Clone\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.peek.is_some() {\n            self.peek.take()\n        } else {\n            self.peek = self.iter.next();\n            if self.peek.is_some() {\n                Some(self.element.clone())\n            } else {\n                None\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // 2 * SH + { 1 or 0 }\n        let has_peek = self.peek.is_some() as usize;\n        let sh = self.iter.size_hint();\n        size_hint::add_scalar(size_hint::add(sh, sh), has_peek)\n    }\n\n    fn fold<B, F>(mut self, init: B, mut f: F) -> B where\n        Self: Sized, F: FnMut(B, Self::Item) -> B,\n    {\n        let mut accum = init;\n        \n        if let Some(x) = self.peek.take() {\n            accum = f(accum, x);\n        }\n\n        let element = &self.element;\n\n        self.iter.fold(accum,\n            |accum, x| {\n                let accum = f(accum, element.clone());\n                let accum = f(accum, x);\n                accum\n        })\n    }\n}\n","traces":[{"line":24,"address":[4214960,4215031],"length":1,"stats":{"Line":5},"fn_name":"intersperse<core::ops::range::Range<i32>>"},{"line":27,"address":[4214979],"length":1,"stats":{"Line":5},"fn_name":null},{"line":29,"address":[4770605,4770822],"length":1,"stats":{"Line":5},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":42,"address":[4769769,4769908,4769850,4769993,4770088,4770151],"length":1,"stats":{"Line":14},"fn_name":null},{"line":43,"address":[4770057,4769825],"length":1,"stats":{"Line":4},"fn_name":null},{"line":45,"address":[4214122,4214178,4214243],"length":1,"stats":{"Line":15},"fn_name":null},{"line":46,"address":[4769854,4769942,4770092,4770108,4770191,4769969,4769869,4770218],"length":1,"stats":{"Line":14},"fn_name":null},{"line":47,"address":[4214197],"length":1,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[4214187],"length":1,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[4212703,4212256,4212640,4213087,4213024,4212319],"length":1,"stats":{"Line":3},"fn_name":"fold<core::ops::range::Range<i32>,(),closure-0>"},{"line":64,"address":[4212649,4213033,4212265],"length":1,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[4212334,4212756,4213058,4213102,4213140,4212718,4212372,4212290,4212674],"length":1,"stats":{"Line":9},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[4212876,4213260,4212492],"length":1,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[4212543,4213311,4212927,4212497,4212881,4213265],"length":1,"stats":{"Line":6},"fn_name":null},{"line":73,"address":[4213509,4213856,4213957,4213733,4212528,4213296,4213632,4213408,4212912],"length":1,"stats":{"Line":5},"fn_name":"{{closure}}<core::ops::range::Range<i32>,(),closure-0>"},{"line":74,"address":[4213645,4213421,4214027,4213579,4213869,4213530,4213754,4213803,4213978],"length":1,"stats":{"Line":4},"fn_name":null},{"line":75,"address":[4213983,4213535,4213759],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":23,"coverable":24},{"path":["/","home","kms","itertools","src","kmerge_impl.rs"],"content":"use crate::size_hint;\nuse crate::Itertools;\n\nuse std::mem::replace;\nuse std::fmt;\n\n/// Head element and Tail iterator pair\n///\n/// `PartialEq`, `Eq`, `PartialOrd` and `Ord` are implemented by comparing sequences based on\n/// first items (which are guaranteed to exist).\n///\n/// The meanings of `PartialOrd` and `Ord` are reversed so as to turn the heap used in\n/// `KMerge` into a min-heap.\n#[derive(Debug)]\nstruct HeadTail<I>\n    where I: Iterator\n{\n    head: I::Item,\n    tail: I,\n}\n\nimpl<I> HeadTail<I>\n    where I: Iterator\n{\n    /// Constructs a `HeadTail` from an `Iterator`. Returns `None` if the `Iterator` is empty.\n    fn new(mut it: I) -> Option<HeadTail<I>> {\n        let head = it.next();\n        head.map(|h| {\n            HeadTail {\n                head: h,\n                tail: it,\n            }\n        })\n    }\n\n    /// Get the next element and update `head`, returning the old head in `Some`.\n    ///\n    /// Returns `None` when the tail is exhausted (only `head` then remains).\n    fn next(&mut self) -> Option<I::Item> {\n        if let Some(next) = self.tail.next() {\n            Some(replace(&mut self.head, next))\n        } else {\n            None\n        }\n    }\n\n    /// Hints at the size of the sequence, same as the `Iterator` method.\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add_scalar(self.tail.size_hint(), 1)\n    }\n}\n\nimpl<I> Clone for HeadTail<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    clone_fields!(head, tail);\n}\n\n/// Make `data` a heap (min-heap w.r.t the sorting).\nfn heapify<T, S>(data: &mut [T], mut less_than: S)\n    where S: FnMut(&T, &T) -> bool\n{\n    for i in (0..data.len() / 2).rev() {\n        sift_down(data, i, &mut less_than);\n    }\n}\n\n/// Sift down element at `index` (`heap` is a min-heap wrt the ordering)\nfn sift_down<T, S>(heap: &mut [T], index: usize, mut less_than: S)\n    where S: FnMut(&T, &T) -> bool\n{\n    debug_assert!(index <= heap.len());\n    let mut pos = index;\n    let mut child = 2 * pos + 1;\n    // the `pos` conditional is to avoid a bounds check\n    while pos < heap.len() && child < heap.len() {\n        let right = child + 1;\n\n        // pick the smaller of the two children\n        if right < heap.len() && less_than(&heap[right], &heap[child]) {\n            child = right;\n        }\n\n        // sift down is done if we are already in order\n        if !less_than(&heap[child], &heap[pos]) {\n            return;\n        }\n        heap.swap(pos, child);\n        pos = child;\n        child = 2 * pos + 1;\n    }\n}\n\n/// An iterator adaptor that merges an abitrary number of base iterators in ascending order.\n/// If all base iterators are sorted (ascending), the result is sorted.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.kmerge()`](../trait.Itertools.html#method.kmerge) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub type KMerge<I> = KMergeBy<I, KMergeByLt>;\n\npub trait KMergePredicate<T> {\n    fn kmerge_pred(&mut self, a: &T, b: &T) -> bool;\n}\n\n#[derive(Clone)]\npub struct KMergeByLt;\n\nimpl<T: PartialOrd> KMergePredicate<T> for KMergeByLt {\n    fn kmerge_pred(&mut self, a: &T, b: &T) -> bool {\n        a < b\n    }\n}\n\nimpl<T, F: FnMut(&T, &T)->bool> KMergePredicate<T> for F {\n    fn kmerge_pred(&mut self, a: &T, b: &T) -> bool {\n        self(a, b)\n    }\n}\n\n/// Create an iterator that merges elements of the contained iterators using\n/// the ordering function.\n///\n/// Equivalent to `iterable.into_iter().kmerge()`.\n///\n/// ```\n/// use itertools::kmerge;\n///\n/// for elt in kmerge(vec![vec![0, 2, 4], vec![1, 3, 5], vec![6, 7]]) {\n///     /* loop body */\n/// }\n/// ```\npub fn kmerge<I>(iterable: I) -> KMerge<<I::Item as IntoIterator>::IntoIter>\n    where I: IntoIterator,\n          I::Item: IntoIterator,\n          <<I as IntoIterator>::Item as IntoIterator>::Item: PartialOrd\n{\n    kmerge_by(iterable, KMergeByLt)\n}\n\n/// An iterator adaptor that merges an abitrary number of base iterators\n/// according to an ordering function.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.kmerge_by()`](../trait.Itertools.html#method.kmerge_by) for more\n/// information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct KMergeBy<I, F>\n    where I: Iterator,\n{\n    heap: Vec<HeadTail<I>>,\n    less_than: F,\n}\n\nimpl<I, F> fmt::Debug for KMergeBy<I, F>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(KMergeBy, heap);\n}\n\n/// Create an iterator that merges elements of the contained iterators.\n///\n/// Equivalent to `iterable.into_iter().kmerge_by(less_than)`.\npub fn kmerge_by<I, F>(iterable: I, mut less_than: F)\n    -> KMergeBy<<I::Item as IntoIterator>::IntoIter, F>\n    where I: IntoIterator,\n          I::Item: IntoIterator,\n          F: KMergePredicate<<<I as IntoIterator>::Item as IntoIterator>::Item>,\n{\n    let iter = iterable.into_iter();\n    let (lower, _) = iter.size_hint();\n    let mut heap: Vec<_> = Vec::with_capacity(lower);\n    heap.extend(iter.filter_map(|it| HeadTail::new(it.into_iter())));\n    heapify(&mut heap, |a, b| less_than.kmerge_pred(&a.head, &b.head));\n    KMergeBy { heap, less_than }\n}\n\nimpl<I, F> Clone for KMergeBy<I, F>\n    where I: Iterator + Clone,\n          I::Item: Clone,\n          F: Clone,\n{\n    clone_fields!(heap, less_than);\n}\n\nimpl<I, F> Iterator for KMergeBy<I, F>\n    where I: Iterator,\n          F: KMergePredicate<I::Item>\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.heap.is_empty() {\n            return None;\n        }\n        let result = if let Some(next) = self.heap[0].next() {\n            next\n        } else {\n            self.heap.swap_remove(0).head\n        };\n        let less_than = &mut self.less_than;\n        sift_down(&mut self.heap, 0, |a, b| less_than.kmerge_pred(&a.head, &b.head));\n        Some(result)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.heap.iter()\n                 .map(|i| i.size_hint())\n                 .fold1(size_hint::add)\n                 .unwrap_or((0, Some(0)))\n    }\n}\n","traces":[{"line":26,"address":[5210601,5210720,5210770,5210544],"length":1,"stats":{"Line":4},"fn_name":"new<core::ops::range::Range<i32>>"},{"line":27,"address":[5210616,5210786,5210559,5210727],"length":1,"stats":{"Line":8},"fn_name":null},{"line":28,"address":[5210976,5210896,5210798,5210628],"length":1,"stats":{"Line":8},"fn_name":"{{closure}}<itertools::adaptors::Step<core::ops::range::Range<i32>>>"},{"line":29,"address":[5211005,5210937],"length":1,"stats":{"Line":4},"fn_name":null},{"line":30,"address":[5210907,5210994],"length":1,"stats":{"Line":4},"fn_name":null},{"line":31,"address":[5210998,5210911],"length":1,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[5211070,5211232,5211024,5211271],"length":1,"stats":{"Line":3},"fn_name":"next<core::ops::range::Range<i32>>"},{"line":40,"address":[5211303,5211082,5211283,5211033,5211102,5211241],"length":1,"stats":{"Line":10},"fn_name":null},{"line":41,"address":[5211117,5211318],"length":1,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[5211452],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[5212508,5212128,5212800,5212844,5212464,5211836,5211792,5213180,5213136,5212172],"length":1,"stats":{"Line":10},"fn_name":"heapify<itertools::kmerge_impl::HeadTail<core::ops::range::Range<i32>>,closure-1>"},{"line":64,"address":[5213158,5213364,5212150,5211814,5212020,5212864,5212242,5211906,5212356,5212528,5212578,5213028,5212430,5213200,5213250,5213438,5212822,5212914,5212486,5212094,5212692,5212766,5211856,5212192,5213102],"length":1,"stats":{"Line":38},"fn_name":null},{"line":65,"address":[5213072,5213408,5212064,5212400,5212736],"length":1,"stats":{"Line":8},"fn_name":null},{"line":70,"address":[5216672,5221174,5221088,5222560,5222646,5224032,5219616,5224118,5219702,5225590,5225504,5218230,5216758,5218144],"length":1,"stats":{"Line":15},"fn_name":"sift_down<itertools::kmerge_impl::HeadTail<itertools::adaptors::Step<core::ops::range::Range<i32>>>,&mut closure-1>"},{"line":73,"address":[5216711,5224071,5218261,5219733,5225543,5219655,5216789,5218183,5222599,5221127,5224149,5222677,5225621,5221205],"length":1,"stats":{"Line":30},"fn_name":null},{"line":74,"address":[5224167,5218279,5225639,5216807,5219751,5221223,5222695],"length":1,"stats":{"Line":15},"fn_name":null},{"line":75,"address":[5224183,5218295,5216823,5219848,5222792,5219335,5222711,5225736,5226687,5220807,5218376,5217855,5224264,5221239,5225223,5223751,5219767,5225655,5216904,5221320,5222271],"length":1,"stats":{"Line":30},"fn_name":null},{"line":77,"address":[5219308,5217828,5221362,5219890,5222834,5223724,5216946,5224306,5225196,5218418,5222244,5225778,5226660,5220780],"length":1,"stats":{"Line":28},"fn_name":null},{"line":78,"address":[5220067,5218595,5223011,5224483,5225955,5222331,5226747,5217123,5217915,5225283,5223811,5220867,5221539,5219395],"length":1,"stats":{"Line":15},"fn_name":null},{"line":81,"address":[5222361,5223061,5224533,5223841,5220117,5225313,5226005,5226777,5217173,5219425,5221589,5218645,5220897,5217945],"length":1,"stats":{"Line":15},"fn_name":null},{"line":82,"address":[5226309,5218953,5221893,5224841,5217477,5220425,5223369],"length":1,"stats":{"Line":11},"fn_name":null},{"line":86,"address":[5218004,5220956,5221909,5218969,5223900,5226836,5217493,5223385,5226325,5225372,5220441,5222420,5219484,5224857],"length":1,"stats":{"Line":14},"fn_name":null},{"line":89,"address":[5225055,5219167,5222103,5217687,5223583,5226519,5220639],"length":1,"stats":{"Line":13},"fn_name":null},{"line":90,"address":[5225104,5219216,5222152,5217736,5226568,5220688,5223632],"length":1,"stats":{"Line":13},"fn_name":null},{"line":91,"address":[5222482,5221018,5225434,5226584,5226964,5222168,5218132,5223648,5224028,5225500,5225120,5218066,5226898,5219232,5219546,5219612,5220704,5221084,5217752,5222548,5223962],"length":1,"stats":{"Line":13},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":135,"address":[5211696,5211568,5211520,5211648,5211744],"length":1,"stats":{"Line":7},"fn_name":"kmerge<core::iter::adapters::Map<core::ops::range::Range<i32>, closure-0>>"},{"line":140,"address":[5211535,5211663,5211711,5211575,5211759],"length":1,"stats":{"Line":7},"fn_name":null},{"line":168,"address":[5213984,5213565,5215376,5213472,5215478,5214912,5214086,5215014,5214550,5214448],"length":1,"stats":{"Line":10},"fn_name":"kmerge_by<core::iter::adapters::Map<alloc::vec::IntoIter<i32>, closure-0>,itertools::kmerge_impl::KMergeByLt>"},{"line":174,"address":[5213482,5214002,5214930,5215394,5214466],"length":1,"stats":{"Line":10},"fn_name":null},{"line":175,"address":[5215471,5213558,5213582,5215031,5215007,5214543,5215495,5214079,5214103,5214567],"length":1,"stats":{"Line":20},"fn_name":null},{"line":176,"address":[5214577,5213595,5215505,5214113,5215041],"length":1,"stats":{"Line":10},"fn_name":null},{"line":177,"address":[5214130,5216588,5215522,5215840,5215058,5215932,5216576,5214594,5216116,5213615,5216356,5215860,5216096,5216336,5215920],"length":1,"stats":{"Line":30},"fn_name":"{{closure}}<core::iter::adapters::Map<core::ops::range::Range<i32>, closure-0>,itertools::kmerge_impl::KMergeByLt>"},{"line":178,"address":[5216515,5214665,5213721,5216016,5216035,5216256,5216176,5215593,5216496,5214201,5216195,5216275,5216435,5215129,5216416],"length":1,"stats":{"Line":26},"fn_name":"{{closure}}<core::iter::adapters::Map<core::ops::range::Range<i32>, closure-0>,itertools::kmerge_impl::KMergeByLt>"},{"line":196,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":52,"coverable":53},{"path":["/","home","kms","itertools","src","lazy_buffer.rs"],"content":"use std::ops::Index;\n\n#[derive(Debug, Clone)]\npub struct LazyBuffer<I: Iterator> {\n    pub it: I,\n    done: bool,\n    buffer: Vec<I::Item>,\n}\n\nimpl<I> LazyBuffer<I>\nwhere\n    I: Iterator,\n{\n    pub fn new(it: I) -> LazyBuffer<I> {\n        LazyBuffer {\n            it,\n            done: false,\n            buffer: Vec::new(),\n        }\n    }\n\n    pub fn len(&self) -> usize {\n        self.buffer.len()\n    }\n\n    pub fn is_done(&self) -> bool {\n        self.done\n    }\n\n    pub fn get_next(&mut self) -> bool {\n        if self.done {\n            return false;\n        }\n        let next_item = self.it.next();\n        match next_item {\n            Some(x) => {\n                self.buffer.push(x);\n                true\n            }\n            None => {\n                self.done = true;\n                false\n            }\n        }\n    }\n}\n\nimpl<I, J> Index<J> for LazyBuffer<I>\nwhere\n    I: Iterator,\n    I::Item: Sized,\n    Vec<I::Item>: Index<J>\n{\n    type Output = <Vec<I::Item> as Index<J>>::Output;\n\n    fn index(&self, _index: J) -> &Self::Output {\n        self.buffer.index(_index)\n    }\n}\n","traces":[{"line":14,"address":[4570208,4570321,4570352,4570479],"length":1,"stats":{"Line":7},"fn_name":"new<core::ops::range::Range<i32>>"},{"line":18,"address":[4227317],"length":1,"stats":{"Line":8},"fn_name":null},{"line":22,"address":[4227232],"length":1,"stats":{"Line":5},"fn_name":"len<adaptors_no_collect::PanickingCounter>"},{"line":23,"address":[4570169,4570121],"length":1,"stats":{"Line":5},"fn_name":null},{"line":26,"address":[4570512,4570544],"length":1,"stats":{"Line":4},"fn_name":"is_done<core::ops::range::Range<i32>>"},{"line":27,"address":[4227445],"length":1,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[4570576,4570603,4570816,4570843],"length":1,"stats":{"Line":6},"fn_name":"get_next<core::ops::range::Range<i32>>"},{"line":31,"address":[4570585,4570825],"length":1,"stats":{"Line":6},"fn_name":null},{"line":32,"address":[4570647,4570886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":36,"address":[4570937,4570699,4570666,4570905],"length":1,"stats":{"Line":16},"fn_name":null},{"line":37,"address":[4227591],"length":1,"stats":{"Line":8},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":5},"fn_name":null}],"covered":18,"coverable":19},{"path":["/","home","kms","itertools","src","lib.rs"],"content":"#![warn(missing_docs)]\n#![crate_name=\"itertools\"]\n#![cfg_attr(not(feature = \"use_std\"), no_std)]\n\n//! Extra iterator adaptors, functions and macros.\n//!\n//! To extend [`Iterator`] with methods in this crate, import\n//! the [`Itertools` trait](./trait.Itertools.html):\n//!\n//! ```\n//! use itertools::Itertools;\n//! ```\n//!\n//! Now, new methods like [`interleave`](./trait.Itertools.html#method.interleave)\n//! are available on all iterators:\n//!\n//! ```\n//! use itertools::Itertools;\n//!\n//! let it = (1..3).interleave(vec![-1, -2]);\n//! itertools::assert_equal(it, vec![1, -1, 2, -2]);\n//! ```\n//!\n//! Most iterator methods are also provided as functions (with the benefit\n//! that they convert parameters using [`IntoIterator`]):\n//!\n//! ```\n//! use itertools::interleave;\n//!\n//! for elt in interleave(&[1, 2, 3], &[2, 3, 4]) {\n//!     /* loop body */\n//! }\n//! ```\n//!\n//! ## Crate Features\n//!\n//! - `use_std`\n//!   - Enabled by default.\n//!   - Disable to compile itertools using `#![no_std]`. This disables\n//!     any items that depend on collections (like `group_by`, `unique`,\n//!     `kmerge`, `join` and many more).\n//!\n//! ## Rust Version\n//!\n//! This version of itertools requires Rust 1.32 or later.\n//!\n//! [`Iterator`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html\n#![doc(html_root_url=\"https://docs.rs/itertools/0.8/\")]\n\n#[cfg(not(feature = \"use_std\"))]\nextern crate core as std;\n\npub use either::Either;\n\n#[cfg(feature = \"use_std\")]\nuse std::collections::HashMap;\nuse std::iter::{IntoIterator, once};\nuse std::cmp::Ordering;\nuse std::fmt;\n#[cfg(feature = \"use_std\")]\nuse std::hash::Hash;\n#[cfg(feature = \"use_std\")]\nuse std::fmt::Write;\n#[cfg(feature = \"use_std\")]\ntype VecIntoIter<T> = ::std::vec::IntoIter<T>;\n#[cfg(feature = \"use_std\")]\nuse std::iter::FromIterator;\n\n#[macro_use]\nmod impl_macros;\n\n// for compatibility with no std and macros\n#[doc(hidden)]\npub use std::iter as __std_iter;\n\n/// The concrete iterator types.\npub mod structs {\n    pub use crate::adaptors::{\n        Dedup,\n        DedupBy,\n        DedupWithCount,\n        DedupByWithCount,\n        Interleave,\n        InterleaveShortest,\n        Product,\n        PutBack,\n        Batching,\n        MapInto,\n        MapResults,\n        Merge,\n        MergeBy,\n        TakeWhileRef,\n        WhileSome,\n        Coalesce,\n        TupleCombinations,\n        Positions,\n        Update,\n    };\n    #[allow(deprecated)]\n    pub use crate::adaptors::Step;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::adaptors::MultiProduct;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::combinations::Combinations;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::combinations_with_replacement::CombinationsWithReplacement;\n    pub use crate::cons_tuples_impl::ConsTuples;\n    pub use crate::exactly_one_err::ExactlyOneError;\n    pub use crate::format::{Format, FormatWith};\n    #[cfg(feature = \"use_std\")]\n    pub use crate::groupbylazy::{IntoChunks, Chunk, Chunks, GroupBy, Group, Groups};\n    pub use crate::intersperse::Intersperse;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::kmerge_impl::{KMerge, KMergeBy};\n    pub use crate::merge_join::MergeJoinBy;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::multipeek_impl::MultiPeek;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::peek_nth::PeekNth;\n    pub use crate::pad_tail::PadUsing;\n    pub use crate::peeking_take_while::PeekingTakeWhile;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::permutations::Permutations;\n    pub use crate::process_results_impl::ProcessResults;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::put_back_n_impl::PutBackN;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::rciter_impl::RcIter;\n    pub use crate::repeatn::RepeatN;\n    #[allow(deprecated)]\n    pub use crate::sources::{RepeatCall, Unfold, Iterate};\n    #[cfg(feature = \"use_std\")]\n    pub use crate::tee::Tee;\n    pub use crate::tuple_impl::{TupleBuffer, TupleWindows, CircularTupleWindows, Tuples};\n    #[cfg(feature = \"use_std\")]\n    pub use crate::unique_impl::{Unique, UniqueBy};\n    pub use crate::with_position::WithPosition;\n    pub use crate::zip_eq_impl::ZipEq;\n    pub use crate::zip_longest::ZipLongest;\n    pub use crate::ziptuple::Zip;\n}\n\n/// Traits helpful for using certain `Itertools` methods in generic contexts.\npub mod traits {\n    pub use crate::tuple_impl::HomogeneousTuple;\n}\n\n#[allow(deprecated)]\npub use crate::structs::*;\npub use crate::concat_impl::concat;\npub use crate::cons_tuples_impl::cons_tuples;\npub use crate::diff::diff_with;\npub use crate::diff::Diff;\n#[cfg(feature = \"use_std\")]\npub use crate::kmerge_impl::{kmerge_by};\npub use crate::minmax::MinMaxResult;\npub use crate::peeking_take_while::PeekingNext;\npub use crate::process_results_impl::process_results;\npub use crate::repeatn::repeat_n;\n#[allow(deprecated)]\npub use crate::sources::{repeat_call, unfold, iterate};\npub use crate::with_position::Position;\npub use crate::ziptuple::multizip;\nmod adaptors;\nmod either_or_both;\npub use crate::either_or_both::EitherOrBoth;\n#[doc(hidden)]\npub mod free;\n#[doc(inline)]\npub use crate::free::*;\nmod concat_impl;\nmod cons_tuples_impl;\n#[cfg(feature = \"use_std\")]\nmod combinations;\n#[cfg(feature = \"use_std\")]\nmod combinations_with_replacement;\nmod exactly_one_err;\nmod diff;\nmod format;\n#[cfg(feature = \"use_std\")]\nmod group_map;\n#[cfg(feature = \"use_std\")]\nmod groupbylazy;\nmod intersperse;\n#[cfg(feature = \"use_std\")]\nmod kmerge_impl;\n#[cfg(feature = \"use_std\")]\nmod lazy_buffer;\nmod merge_join;\nmod minmax;\n#[cfg(feature = \"use_std\")]\nmod multipeek_impl;\nmod pad_tail;\n#[cfg(feature = \"use_std\")]\nmod peek_nth;\nmod peeking_take_while;\n#[cfg(feature = \"use_std\")]\nmod permutations;\nmod process_results_impl;\n#[cfg(feature = \"use_std\")]\nmod put_back_n_impl;\n#[cfg(feature = \"use_std\")]\nmod rciter_impl;\nmod repeatn;\nmod size_hint;\nmod sources;\n#[cfg(feature = \"use_std\")]\nmod tee;\nmod tuple_impl;\n#[cfg(feature = \"use_std\")]\nmod unique_impl;\nmod with_position;\nmod zip_eq_impl;\nmod zip_longest;\nmod ziptuple;\n\n#[macro_export]\n/// Create an iterator over the “cartesian product” of iterators.\n///\n/// Iterator element type is like `(A, B, ..., E)` if formed\n/// from iterators `(I, J, ..., M)` with element types `I::Item = A`, `J::Item = B`, etc.\n///\n/// ```\n/// # use itertools::iproduct;\n/// #\n/// # fn main() {\n/// // Iterate over the coordinates of a 4 x 4 x 4 grid\n/// // from (0, 0, 0), (0, 0, 1), .., (0, 1, 0), (0, 1, 1), .. etc until (3, 3, 3)\n/// for (i, j, k) in iproduct!(0..4, 0..4, 0..4) {\n///    // ..\n/// }\n/// # }\n/// ```\nmacro_rules! iproduct {\n    (@flatten $I:expr,) => (\n        $I\n    );\n    (@flatten $I:expr, $J:expr, $($K:expr,)*) => (\n        iproduct!(@flatten $crate::cons_tuples(iproduct!($I, $J)), $($K,)*)\n    );\n    ($I:expr) => (\n        $crate::__std_iter::IntoIterator::into_iter($I)\n    );\n    ($I:expr, $J:expr) => (\n        $crate::Itertools::cartesian_product(iproduct!($I), iproduct!($J))\n    );\n    ($I:expr, $J:expr, $($K:expr),+) => (\n        iproduct!(@flatten iproduct!($I, $J), $($K,)+)\n    );\n}\n\n#[macro_export]\n/// Create an iterator running multiple iterators in lockstep.\n///\n/// The `izip!` iterator yields elements until any subiterator\n/// returns `None`.\n///\n/// This is a version of the standard ``.zip()`` that's supporting more than\n/// two iterators. The iterator element type is a tuple with one element\n/// from each of the input iterators. Just like ``.zip()``, the iteration stops\n/// when the shortest of the inputs reaches its end.\n///\n/// **Note:** The result of this macro is in the general case an iterator\n/// composed of repeated `.zip()` and a `.map()`; it has an anonymous type.\n/// The special cases of one and two arguments produce the equivalent of\n/// `$a.into_iter()` and `$a.into_iter().zip($b)` respectively.\n///\n/// Prefer this macro `izip!()` over [`multizip`] for the performance benefits\n/// of using the standard library `.zip()`.\n///\n/// [`multizip`]: fn.multizip.html\n///\n/// ```\n/// # use itertools::izip;\n/// #\n/// # fn main() {\n///\n/// // iterate over three sequences side-by-side\n/// let mut results = [0, 0, 0, 0];\n/// let inputs = [3, 7, 9, 6];\n///\n/// for (r, index, input) in izip!(&mut results, 0..10, &inputs) {\n///     *r = index * 10 + input;\n/// }\n///\n/// assert_eq!(results, [0 + 3, 10 + 7, 29, 36]);\n/// # }\n/// ```\nmacro_rules! izip {\n    // @closure creates a tuple-flattening closure for .map() call. usage:\n    // @closure partial_pattern => partial_tuple , rest , of , iterators\n    // eg. izip!( @closure ((a, b), c) => (a, b, c) , dd , ee )\n    ( @closure $p:pat => $tup:expr ) => {\n        |$p| $tup\n    };\n\n    // The \"b\" identifier is a different identifier on each recursion level thanks to hygiene.\n    ( @closure $p:pat => ( $($tup:tt)* ) , $_iter:expr $( , $tail:expr )* ) => {\n        izip!(@closure ($p, b) => ( $($tup)*, b ) $( , $tail )*)\n    };\n\n    // unary\n    ($first:expr $(,)*) => {\n        $crate::__std_iter::IntoIterator::into_iter($first)\n    };\n\n    // binary\n    ($first:expr, $second:expr $(,)*) => {\n        izip!($first)\n            .zip($second)\n    };\n\n    // n-ary where n > 2\n    ( $first:expr $( , $rest:expr )* $(,)* ) => {\n        izip!($first)\n            $(\n                .zip($rest)\n            )*\n            .map(\n                izip!(@closure a => (a) $( , $rest )*)\n            )\n    };\n}\n\n/// An [`Iterator`] blanket implementation that provides extra adaptors and\n/// methods.\n///\n/// This trait defines a number of methods. They are divided into two groups:\n///\n/// * *Adaptors* take an iterator and parameter as input, and return\n/// a new iterator value. These are listed first in the trait. An example\n/// of an adaptor is [`.interleave()`](#method.interleave)\n///\n/// * *Regular methods* are those that don't return iterators and instead\n/// return a regular value of some other kind.\n/// [`.next_tuple()`](#method.next_tuple) is an example and the first regular\n/// method in the list.\n///\n/// [`Iterator`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html\npub trait Itertools : Iterator {\n    // adaptors\n\n    /// Alternate elements from two iterators until both have run out.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = (1..7).interleave(vec![-1, -2]);\n    /// itertools::assert_equal(it, vec![1, -1, 2, -2, 3, 4, 5, 6]);\n    /// ```\n    fn interleave<J>(self, other: J) -> Interleave<Self, J::IntoIter>\n        where J: IntoIterator<Item = Self::Item>,\n              Self: Sized\n    {\n        interleave(self, other)\n    }\n\n    /// Alternate elements from two iterators until at least one of them has run\n    /// out.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = (1..7).interleave_shortest(vec![-1, -2]);\n    /// itertools::assert_equal(it, vec![1, -1, 2, -2, 3]);\n    /// ```\n    fn interleave_shortest<J>(self, other: J) -> InterleaveShortest<Self, J::IntoIter>\n        where J: IntoIterator<Item = Self::Item>,\n              Self: Sized\n    {\n        adaptors::interleave_shortest(self, other.into_iter())\n    }\n\n    /// An iterator adaptor to insert a particular value\n    /// between each element of the adapted iterator.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// itertools::assert_equal((0..3).intersperse(8), vec![0, 8, 1, 8, 2]);\n    /// ```\n    fn intersperse(self, element: Self::Item) -> Intersperse<Self>\n        where Self: Sized,\n              Self::Item: Clone\n    {\n        intersperse::intersperse(self, element)\n    }\n\n    /// Create an iterator which iterates over both this and the specified\n    /// iterator simultaneously, yielding pairs of two optional elements.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// As long as neither input iterator is exhausted yet, it yields two values\n    /// via `EitherOrBoth::Both`.\n    ///\n    /// When the parameter iterator is exhausted, it only yields a value from the\n    /// `self` iterator via `EitherOrBoth::Left`.\n    ///\n    /// When the `self` iterator is exhausted, it only yields a value from the\n    /// parameter iterator via `EitherOrBoth::Right`.\n    ///\n    /// When both iterators return `None`, all further invocations of `.next()`\n    /// will return `None`.\n    ///\n    /// Iterator element type is\n    /// [`EitherOrBoth<Self::Item, J::Item>`](enum.EitherOrBoth.html).\n    ///\n    /// ```rust\n    /// use itertools::EitherOrBoth::{Both, Right};\n    /// use itertools::Itertools;\n    /// let it = (0..1).zip_longest(1..3);\n    /// itertools::assert_equal(it, vec![Both(0, 1), Right(2)]);\n    /// ```\n    #[inline]\n    fn zip_longest<J>(self, other: J) -> ZipLongest<Self, J::IntoIter>\n        where J: IntoIterator,\n              Self: Sized\n    {\n        zip_longest::zip_longest(self, other.into_iter())\n    }\n\n    /// Create an iterator which iterates over both this and the specified\n    /// iterator simultaneously, yielding pairs of elements.\n    ///\n    /// **Panics** if the iterators reach an end and they are not of equal\n    /// lengths.\n    #[inline]\n    fn zip_eq<J>(self, other: J) -> ZipEq<Self, J::IntoIter>\n        where J: IntoIterator,\n              Self: Sized\n    {\n        zip_eq(self, other)\n    }\n\n    /// A “meta iterator adaptor”. Its closure receives a reference to the\n    /// iterator and may pick off as many elements as it likes, to produce the\n    /// next iterator element.\n    ///\n    /// Iterator element type is `B`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // An adaptor that gathers elements in pairs\n    /// let pit = (0..4).batching(|it| {\n    ///            match it.next() {\n    ///                None => None,\n    ///                Some(x) => match it.next() {\n    ///                    None => None,\n    ///                    Some(y) => Some((x, y)),\n    ///                }\n    ///            }\n    ///        });\n    ///\n    /// itertools::assert_equal(pit, vec![(0, 1), (2, 3)]);\n    /// ```\n    ///\n    fn batching<B, F>(self, f: F) -> Batching<Self, F>\n        where F: FnMut(&mut Self) -> Option<B>,\n              Self: Sized\n    {\n        adaptors::batching(self, f)\n    }\n\n    /// Return an *iterable* that can group iterator elements.\n    /// Consecutive elements that map to the same key (“runs”), are assigned\n    /// to the same group.\n    ///\n    /// `GroupBy` is the storage for the lazy grouping operation.\n    ///\n    /// If the groups are consumed in order, or if each group's iterator is\n    /// dropped without keeping it around, then `GroupBy` uses no\n    /// allocations.  It needs allocations only if several group iterators\n    /// are alive at the same time.\n    ///\n    /// This type implements `IntoIterator` (it is **not** an iterator\n    /// itself), because the group iterators need to borrow from this\n    /// value. It should be stored in a local variable or temporary and\n    /// iterated.\n    ///\n    /// Iterator element type is `(K, Group)`: the group's key and the\n    /// group iterator.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // group data into runs of larger than zero or not.\n    /// let data = vec![1, 3, -2, -2, 1, 0, 1, 2];\n    /// // groups:     |---->|------>|--------->|\n    ///\n    /// // Note: The `&` is significant here, `GroupBy` is iterable\n    /// // only by reference. You can also call `.into_iter()` explicitly.\n    /// let mut data_grouped = Vec::new();\n    /// for (key, group) in &data.into_iter().group_by(|elt| *elt >= 0) {\n    ///     data_grouped.push((key, group.collect()));\n    /// }\n    /// assert_eq!(data_grouped, vec![(true, vec![1, 3]), (false, vec![-2, -2]), (true, vec![1, 0, 1, 2])]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn group_by<K, F>(self, key: F) -> GroupBy<K, Self, F>\n        where Self: Sized,\n              F: FnMut(&Self::Item) -> K,\n              K: PartialEq,\n    {\n        groupbylazy::new(self, key)\n    }\n\n    /// Return an *iterable* that can chunk the iterator.\n    ///\n    /// Yield subiterators (chunks) that each yield a fixed number elements,\n    /// determined by `size`. The last chunk will be shorter if there aren't\n    /// enough elements.\n    ///\n    /// `IntoChunks` is based on `GroupBy`: it is iterable (implements\n    /// `IntoIterator`, **not** `Iterator`), and it only buffers if several\n    /// chunk iterators are alive at the same time.\n    ///\n    /// Iterator element type is `Chunk`, each chunk's iterator.\n    ///\n    /// **Panics** if `size` is 0.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![1, 1, 2, -2, 6, 0, 3, 1];\n    /// //chunk size=3 |------->|-------->|--->|\n    ///\n    /// // Note: The `&` is significant here, `IntoChunks` is iterable\n    /// // only by reference. You can also call `.into_iter()` explicitly.\n    /// for chunk in &data.into_iter().chunks(3) {\n    ///     // Check that the sum of each chunk is 4.\n    ///     assert_eq!(4, chunk.sum());\n    /// }\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn chunks(self, size: usize) -> IntoChunks<Self>\n        where Self: Sized,\n    {\n        assert!(size != 0);\n        groupbylazy::new_chunks(self, size)\n    }\n\n    /// Return an iterator over all contiguous windows producing tuples of\n    /// a specific size (up to 4).\n    ///\n    /// `tuple_windows` clones the iterator elements so that they can be\n    /// part of successive windows, this makes it most suited for iterators\n    /// of references and other values that are cheap to copy.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// let mut v = Vec::new();\n    /// for (a, b) in (1..5).tuple_windows() {\n    ///     v.push((a, b));\n    /// }\n    /// assert_eq!(v, vec![(1, 2), (2, 3), (3, 4)]);\n    ///\n    /// let mut it = (1..5).tuple_windows();\n    /// assert_eq!(Some((1, 2, 3)), it.next());\n    /// assert_eq!(Some((2, 3, 4)), it.next());\n    /// assert_eq!(None, it.next());\n    ///\n    /// // this requires a type hint\n    /// let it = (1..5).tuple_windows::<(_, _, _)>();\n    /// itertools::assert_equal(it, vec![(1, 2, 3), (2, 3, 4)]);\n    ///\n    /// // you can also specify the complete type\n    /// use itertools::TupleWindows;\n    /// use std::ops::Range;\n    ///\n    /// let it: TupleWindows<Range<u32>, (u32, u32, u32)> = (1..5).tuple_windows();\n    /// itertools::assert_equal(it, vec![(1, 2, 3), (2, 3, 4)]);\n    /// ```\n    fn tuple_windows<T>(self) -> TupleWindows<Self, T>\n        where Self: Sized + Iterator<Item = T::Item>,\n              T: traits::HomogeneousTuple,\n              T::Item: Clone\n    {\n        tuple_impl::tuple_windows(self)\n    }\n\n    /// Return an iterator over all windows, wrapping back to the first\n    /// elements when the window would otherwise exceed the length of the\n    /// iterator, producing tuples of a specific size (up to 4).\n    ///\n    /// `circular_tuple_windows` clones the iterator elements so that they can be\n    /// part of successive windows, this makes it most suited for iterators\n    /// of references and other values that are cheap to copy.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// let mut v = Vec::new();\n    /// for (a, b) in (1..5).circular_tuple_windows() {\n    ///     v.push((a, b));\n    /// }\n    /// assert_eq!(v, vec![(1, 2), (2, 3), (3, 4), (4, 1)]);\n    ///\n    /// let mut it = (1..5).circular_tuple_windows();\n    /// assert_eq!(Some((1, 2, 3)), it.next());\n    /// assert_eq!(Some((2, 3, 4)), it.next());\n    /// assert_eq!(Some((3, 4, 1)), it.next());\n    /// assert_eq!(Some((4, 1, 2)), it.next());\n    /// assert_eq!(None, it.next());\n    ///\n    /// // this requires a type hint\n    /// let it = (1..5).circular_tuple_windows::<(_, _, _)>();\n    /// itertools::assert_equal(it, vec![(1, 2, 3), (2, 3, 4), (3, 4, 1), (4, 1, 2)]);\n    /// ```\n    fn circular_tuple_windows<T>(self) -> CircularTupleWindows<Self, T>\n        where Self: Sized + Clone + Iterator<Item = T::Item> + ExactSizeIterator,\n              T: tuple_impl::TupleCollect + Clone,\n              T::Item: Clone\n    {\n        tuple_impl::circular_tuple_windows(self)\n    }\n    /// Return an iterator that groups the items in tuples of a specific size\n    /// (up to 4).\n    ///\n    /// See also the method [`.next_tuple()`](#method.next_tuple).\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// let mut v = Vec::new();\n    /// for (a, b) in (1..5).tuples() {\n    ///     v.push((a, b));\n    /// }\n    /// assert_eq!(v, vec![(1, 2), (3, 4)]);\n    ///\n    /// let mut it = (1..7).tuples();\n    /// assert_eq!(Some((1, 2, 3)), it.next());\n    /// assert_eq!(Some((4, 5, 6)), it.next());\n    /// assert_eq!(None, it.next());\n    ///\n    /// // this requires a type hint\n    /// let it = (1..7).tuples::<(_, _, _)>();\n    /// itertools::assert_equal(it, vec![(1, 2, 3), (4, 5, 6)]);\n    ///\n    /// // you can also specify the complete type\n    /// use itertools::Tuples;\n    /// use std::ops::Range;\n    ///\n    /// let it: Tuples<Range<u32>, (u32, u32, u32)> = (1..7).tuples();\n    /// itertools::assert_equal(it, vec![(1, 2, 3), (4, 5, 6)]);\n    /// ```\n    ///\n    /// See also [`Tuples::into_buffer`](structs/struct.Tuples.html#method.into_buffer).\n    fn tuples<T>(self) -> Tuples<Self, T>\n        where Self: Sized + Iterator<Item = T::Item>,\n              T: traits::HomogeneousTuple\n    {\n        tuple_impl::tuples(self)\n    }\n\n    /// Split into an iterator pair that both yield all elements from\n    /// the original iterator.\n    ///\n    /// **Note:** If the iterator is clonable, prefer using that instead\n    /// of using this method. It is likely to be more efficient.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// let xs = vec![0, 1, 2, 3];\n    ///\n    /// let (mut t1, t2) = xs.into_iter().tee();\n    /// itertools::assert_equal(t1.next(), Some(0));\n    /// itertools::assert_equal(t2, 0..4);\n    /// itertools::assert_equal(t1, 1..4);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn tee(self) -> (Tee<Self>, Tee<Self>)\n        where Self: Sized,\n              Self::Item: Clone\n    {\n        tee::new(self)\n    }\n\n    /// Return an iterator adaptor that steps `n` elements in the base iterator\n    /// for each iteration.\n    ///\n    /// The iterator steps by yielding the next element from the base iterator,\n    /// then skipping forward `n - 1` elements.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// **Panics** if the step is 0.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = (0..8).step(3);\n    /// itertools::assert_equal(it, vec![0, 3, 6]);\n    /// ```\n    #[deprecated(note=\"Use std .step_by() instead\", since=\"0.8\")]\n    #[allow(deprecated)]\n    fn step(self, n: usize) -> Step<Self>\n        where Self: Sized\n    {\n        adaptors::step(self, n)\n    }\n\n    /// Convert each item of the iterator using the `Into` trait.\n    ///\n    /// ```rust\n    /// use itertools::Itertools;\n    ///\n    /// (1i32..42i32).map_into::<f64>().collect_vec();\n    /// ```\n    fn map_into<R>(self) -> MapInto<Self, R>\n        where Self: Sized,\n              Self::Item: Into<R>,\n    {\n        adaptors::map_into(self)\n    }\n\n    /// Return an iterator adaptor that applies the provided closure\n    /// to every `Result::Ok` value. `Result::Err` values are\n    /// unchanged.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let input = vec![Ok(41), Err(false), Ok(11)];\n    /// let it = input.into_iter().map_results(|i| i + 1);\n    /// itertools::assert_equal(it, vec![Ok(42), Err(false), Ok(12)]);\n    /// ```\n    fn map_results<F, T, U, E>(self, f: F) -> MapResults<Self, F>\n        where Self: Iterator<Item = Result<T, E>> + Sized,\n              F: FnMut(T) -> U,\n    {\n        adaptors::map_results(self, f)\n    }\n\n    /// Return an iterator adaptor that merges the two base iterators in\n    /// ascending order.  If both base iterators are sorted (ascending), the\n    /// result is sorted.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a = (0..11).step(3);\n    /// let b = (0..11).step(5);\n    /// let it = a.merge(b);\n    /// itertools::assert_equal(it, vec![0, 0, 3, 5, 6, 9, 10]);\n    /// ```\n    fn merge<J>(self, other: J) -> Merge<Self, J::IntoIter>\n        where Self: Sized,\n              Self::Item: PartialOrd,\n              J: IntoIterator<Item = Self::Item>\n    {\n        merge(self, other)\n    }\n\n    /// Return an iterator adaptor that merges the two base iterators in order.\n    /// This is much like `.merge()` but allows for a custom ordering.\n    ///\n    /// This can be especially useful for sequences of tuples.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a = (0..).zip(\"bc\".chars());\n    /// let b = (0..).zip(\"ad\".chars());\n    /// let it = a.merge_by(b, |x, y| x.1 <= y.1);\n    /// itertools::assert_equal(it, vec![(0, 'a'), (0, 'b'), (1, 'c'), (1, 'd')]);\n    /// ```\n\n    fn merge_by<J, F>(self, other: J, is_first: F) -> MergeBy<Self, J::IntoIter, F>\n        where Self: Sized,\n              J: IntoIterator<Item = Self::Item>,\n              F: FnMut(&Self::Item, &Self::Item) -> bool\n    {\n        adaptors::merge_by_new(self, other.into_iter(), is_first)\n    }\n\n    /// Create an iterator that merges items from both this and the specified\n    /// iterator in ascending order.\n    ///\n    /// It chooses whether to pair elements based on the `Ordering` returned by the\n    /// specified compare function. At any point, inspecting the tip of the\n    /// iterators `I` and `J` as items `i` of type `I::Item` and `j` of type\n    /// `J::Item` respectively, the resulting iterator will:\n    ///\n    /// - Emit `EitherOrBoth::Left(i)` when `i < j`,\n    ///   and remove `i` from its source iterator\n    /// - Emit `EitherOrBoth::Right(j)` when `i > j`,\n    ///   and remove `j` from its source iterator\n    /// - Emit `EitherOrBoth::Both(i, j)` when  `i == j`,\n    ///   and remove both `i` and `j` from their respective source iterators\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// use itertools::EitherOrBoth::{Left, Right, Both};\n    ///\n    /// let ki = (0..10).step(3);\n    /// let ku = (0..10).step(5);\n    /// let ki_ku = ki.merge_join_by(ku, |i, j| i.cmp(j)).map(|either| {\n    ///     match either {\n    ///         Left(_) => \"Ki\",\n    ///         Right(_) => \"Ku\",\n    ///         Both(_, _) => \"KiKu\"\n    ///     }\n    /// });\n    ///\n    /// itertools::assert_equal(ki_ku, vec![\"KiKu\", \"Ki\", \"Ku\", \"Ki\", \"Ki\"]);\n    /// ```\n    #[inline]\n    fn merge_join_by<J, F>(self, other: J, cmp_fn: F) -> MergeJoinBy<Self, J::IntoIter, F>\n        where J: IntoIterator,\n              F: FnMut(&Self::Item, &J::Item) -> std::cmp::Ordering,\n              Self: Sized\n    {\n        merge_join_by(self, other, cmp_fn)\n    }\n\n    /// Return an iterator adaptor that flattens an iterator of iterators by\n    /// merging them in ascending order.\n    ///\n    /// If all base iterators are sorted (ascending), the result is sorted.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a = (0..6).step(3);\n    /// let b = (1..6).step(3);\n    /// let c = (2..6).step(3);\n    /// let it = vec![a, b, c].into_iter().kmerge();\n    /// itertools::assert_equal(it, vec![0, 1, 2, 3, 4, 5]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn kmerge(self) -> KMerge<<Self::Item as IntoIterator>::IntoIter>\n        where Self: Sized,\n              Self::Item: IntoIterator,\n              <Self::Item as IntoIterator>::Item: PartialOrd,\n    {\n        kmerge(self)\n    }\n\n    /// Return an iterator adaptor that flattens an iterator of iterators by\n    /// merging them according to the given closure.\n    ///\n    /// The closure `first` is called with two elements *a*, *b* and should\n    /// return `true` if *a* is ordered before *b*.\n    ///\n    /// If all base iterators are sorted according to `first`, the result is\n    /// sorted.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a = vec![-1f64, 2., 3., -5., 6., -7.];\n    /// let b = vec![0., 2., -4.];\n    /// let mut it = vec![a, b].into_iter().kmerge_by(|a, b| a.abs() < b.abs());\n    /// assert_eq!(it.next(), Some(0.));\n    /// assert_eq!(it.last(), Some(-7.));\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn kmerge_by<F>(self, first: F)\n        -> KMergeBy<<Self::Item as IntoIterator>::IntoIter, F>\n        where Self: Sized,\n              Self::Item: IntoIterator,\n              F: FnMut(&<Self::Item as IntoIterator>::Item,\n                       &<Self::Item as IntoIterator>::Item) -> bool\n    {\n        kmerge_by(self, first)\n    }\n\n    /// Return an iterator adaptor that iterates over the cartesian product of\n    /// the element sets of two iterators `self` and `J`.\n    ///\n    /// Iterator element type is `(Self::Item, J::Item)`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = (0..2).cartesian_product(\"αβ\".chars());\n    /// itertools::assert_equal(it, vec![(0, 'α'), (0, 'β'), (1, 'α'), (1, 'β')]);\n    /// ```\n    fn cartesian_product<J>(self, other: J) -> Product<Self, J::IntoIter>\n        where Self: Sized,\n              Self::Item: Clone,\n              J: IntoIterator,\n              J::IntoIter: Clone\n    {\n        adaptors::cartesian_product(self, other.into_iter())\n    }\n\n    /// Return an iterator adaptor that iterates over the cartesian product of\n    /// all subiterators returned by meta-iterator `self`.\n    ///\n    /// All provided iterators must yield the same `Item` type. To generate\n    /// the product of iterators yielding multiple types, use the\n    /// [`iproduct`](macro.iproduct.html) macro instead.\n    ///\n    ///\n    /// The iterator element type is `Vec<T>`, where `T` is the iterator element\n    /// of the subiterators.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// let mut multi_prod = (0..3).map(|i| (i * 2)..(i * 2 + 2))\n    ///     .multi_cartesian_product();\n    /// assert_eq!(multi_prod.next(), Some(vec![0, 2, 4]));\n    /// assert_eq!(multi_prod.next(), Some(vec![0, 2, 5]));\n    /// assert_eq!(multi_prod.next(), Some(vec![0, 3, 4]));\n    /// assert_eq!(multi_prod.next(), Some(vec![0, 3, 5]));\n    /// assert_eq!(multi_prod.next(), Some(vec![1, 2, 4]));\n    /// assert_eq!(multi_prod.next(), Some(vec![1, 2, 5]));\n    /// assert_eq!(multi_prod.next(), Some(vec![1, 3, 4]));\n    /// assert_eq!(multi_prod.next(), Some(vec![1, 3, 5]));\n    /// assert_eq!(multi_prod.next(), None);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn multi_cartesian_product(self) -> MultiProduct<<Self::Item as IntoIterator>::IntoIter>\n        where Self: Iterator + Sized,\n              Self::Item: IntoIterator,\n              <Self::Item as IntoIterator>::IntoIter: Clone,\n              <Self::Item as IntoIterator>::Item: Clone\n    {\n        adaptors::multi_cartesian_product(self)\n    }\n\n    /// Return an iterator adaptor that uses the passed-in closure to\n    /// optionally merge together consecutive elements.\n    ///\n    /// The closure `f` is passed two elements, `previous` and `current` and may\n    /// return either (1) `Ok(combined)` to merge the two values or\n    /// (2) `Err((previous', current'))` to indicate they can't be merged.\n    /// In (2), the value `previous'` is emitted by the iterator.\n    /// Either (1) `combined` or (2) `current'` becomes the previous value\n    /// when coalesce continues with the next pair of elements to merge. The\n    /// value that remains at the end is also emitted by the iterator.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // sum same-sign runs together\n    /// let data = vec![-1., -2., -3., 3., 1., 0., -1.];\n    /// itertools::assert_equal(data.into_iter().coalesce(|x, y|\n    ///         if (x >= 0.) == (y >= 0.) {\n    ///             Ok(x + y)\n    ///         } else {\n    ///             Err((x, y))\n    ///         }),\n    ///         vec![-6., 4., -1.]);\n    /// ```\n    fn coalesce<F>(self, f: F) -> Coalesce<Self, F>\n        where Self: Sized,\n              F: FnMut(Self::Item, Self::Item)\n                       -> Result<Self::Item, (Self::Item, Self::Item)>\n    {\n        adaptors::coalesce(self, f)\n    }\n\n    /// Remove duplicates from sections of consecutive identical elements.\n    /// If the iterator is sorted, all elements will be unique.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![1., 1., 2., 3., 3., 2., 2.];\n    /// itertools::assert_equal(data.into_iter().dedup(),\n    ///                         vec![1., 2., 3., 2.]);\n    /// ```\n    fn dedup(self) -> Dedup<Self>\n        where Self: Sized,\n              Self::Item: PartialEq,\n    {\n        adaptors::dedup(self)\n    }\n\n    /// Remove duplicates from sections of consecutive identical elements,\n    /// determining equality using a comparison function.\n    /// If the iterator is sorted, all elements will be unique.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![(0, 1.), (1, 1.), (0, 2.), (0, 3.), (1, 3.), (1, 2.), (2, 2.)];\n    /// itertools::assert_equal(data.into_iter().dedup_by(|x, y| x.1 == y.1),\n    ///                         vec![(0, 1.), (0, 2.), (0, 3.), (1, 2.)]);\n    /// ```\n    fn dedup_by<Cmp>(self, cmp: Cmp) -> DedupBy<Self, Cmp>\n        where Self: Sized,\n              Cmp: FnMut(&Self::Item, &Self::Item)->bool,\n    {\n        adaptors::dedup_by(self, cmp)\n    }\n\n    /// Remove duplicates from sections of consecutive identical elements, while keeping a count of\n    /// how many repeated elements were present.\n    /// If the iterator is sorted, all elements will be unique.\n    ///\n    /// Iterator element type is `(usize, Self::Item)`.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![1., 1., 2., 3., 3., 2., 2.];\n    /// itertools::assert_equal(data.into_iter().dedup_with_count(),\n    ///                         vec![(2, 1.), (1, 2.), (2, 3.), (2, 2.)]);\n    /// ```\n    fn dedup_with_count(self) -> DedupWithCount<Self>\n        where Self: Sized,\n    {\n        adaptors::dedup_with_count(self)\n    }\n\n    /// Remove duplicates from sections of consecutive identical elements, while keeping a count of\n    /// how many repeated elements were present.\n    /// This will determine equality using a comparison function.\n    /// If the iterator is sorted, all elements will be unique.\n    ///\n    /// Iterator element type is `(usize, Self::Item)`.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![(0, 1.), (1, 1.), (0, 2.), (0, 3.), (1, 3.), (1, 2.), (2, 2.)];\n    /// itertools::assert_equal(data.into_iter().dedup_by_with_count(|x, y| x.1 == y.1),\n    ///                         vec![(2, (0, 1.)), (1, (0, 2.)), (2, (0, 3.)), (2, (1, 2.))]);\n    /// ```\n    fn dedup_by_with_count<Cmp>(self, cmp: Cmp) -> DedupByWithCount<Self, Cmp>\n        where Self: Sized,\n              Cmp: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        adaptors::dedup_by_with_count(self, cmp)\n    }\n\n    /// Return an iterator adaptor that filters out elements that have\n    /// already been produced once during the iteration. Duplicates\n    /// are detected using hash and equality.\n    ///\n    /// Clones of visited elements are stored in a hash set in the\n    /// iterator.\n    ///\n    /// The iterator is stable, returning the non-duplicate items in the order\n    /// in which they occur in the adapted iterator. In a set of duplicate\n    /// items, the first item encountered is the item retained.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![10, 20, 30, 20, 40, 10, 50];\n    /// itertools::assert_equal(data.into_iter().unique(),\n    ///                         vec![10, 20, 30, 40, 50]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn unique(self) -> Unique<Self>\n        where Self: Sized,\n              Self::Item: Clone + Eq + Hash\n    {\n        unique_impl::unique(self)\n    }\n\n    /// Return an iterator adaptor that filters out elements that have\n    /// already been produced once during the iteration.\n    ///\n    /// Duplicates are detected by comparing the key they map to\n    /// with the keying function `f` by hash and equality.\n    /// The keys are stored in a hash set in the iterator.\n    ///\n    /// The iterator is stable, returning the non-duplicate items in the order\n    /// in which they occur in the adapted iterator. In a set of duplicate\n    /// items, the first item encountered is the item retained.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![\"a\", \"bb\", \"aa\", \"c\", \"ccc\"];\n    /// itertools::assert_equal(data.into_iter().unique_by(|s| s.len()),\n    ///                         vec![\"a\", \"bb\", \"ccc\"]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn unique_by<V, F>(self, f: F) -> UniqueBy<Self, V, F>\n        where Self: Sized,\n              V: Eq + Hash,\n              F: FnMut(&Self::Item) -> V\n    {\n        unique_impl::unique_by(self, f)\n    }\n\n    /// Return an iterator adaptor that borrows from this iterator and\n    /// takes items while the closure `accept` returns `true`.\n    ///\n    /// This adaptor can only be used on iterators that implement `PeekingNext`\n    /// like `.peekable()`, `put_back` and a few other collection iterators.\n    ///\n    /// The last and rejected element (first `false`) is still available when\n    /// `peeking_take_while` is done.\n    ///\n    ///\n    /// See also [`.take_while_ref()`](#method.take_while_ref)\n    /// which is a similar adaptor.\n    fn peeking_take_while<F>(&mut self, accept: F) -> PeekingTakeWhile<Self, F>\n        where Self: Sized + PeekingNext,\n              F: FnMut(&Self::Item) -> bool,\n    {\n        peeking_take_while::peeking_take_while(self, accept)\n    }\n\n    /// Return an iterator adaptor that borrows from a `Clone`-able iterator\n    /// to only pick off elements while the predicate `accept` returns `true`.\n    ///\n    /// It uses the `Clone` trait to restore the original iterator so that the\n    /// last and rejected element (first `false`) is still available when\n    /// `take_while_ref` is done.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut hexadecimals = \"0123456789abcdef\".chars();\n    ///\n    /// let decimals = hexadecimals.take_while_ref(|c| c.is_numeric())\n    ///                            .collect::<String>();\n    /// assert_eq!(decimals, \"0123456789\");\n    /// assert_eq!(hexadecimals.next(), Some('a'));\n    ///\n    /// ```\n    fn take_while_ref<F>(&mut self, accept: F) -> TakeWhileRef<Self, F>\n        where Self: Clone,\n              F: FnMut(&Self::Item) -> bool\n    {\n        adaptors::take_while_ref(self, accept)\n    }\n\n    /// Return an iterator adaptor that filters `Option<A>` iterator elements\n    /// and produces `A`. Stops on the first `None` encountered.\n    ///\n    /// Iterator element type is `A`, the unwrapped element.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // List all hexadecimal digits\n    /// itertools::assert_equal(\n    ///     (0..).map(|i| std::char::from_digit(i, 16)).while_some(),\n    ///     \"0123456789abcdef\".chars());\n    ///\n    /// ```\n    fn while_some<A>(self) -> WhileSome<Self>\n        where Self: Sized + Iterator<Item = Option<A>>\n    {\n        adaptors::while_some(self)\n    }\n\n    /// Return an iterator adaptor that iterates over the combinations of the\n    /// elements from an iterator.\n    ///\n    /// Iterator element can be any homogeneous tuple of type `Self::Item` with\n    /// size up to 4.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut v = Vec::new();\n    /// for (a, b) in (1..5).tuple_combinations() {\n    ///     v.push((a, b));\n    /// }\n    /// assert_eq!(v, vec![(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]);\n    ///\n    /// let mut it = (1..5).tuple_combinations();\n    /// assert_eq!(Some((1, 2, 3)), it.next());\n    /// assert_eq!(Some((1, 2, 4)), it.next());\n    /// assert_eq!(Some((1, 3, 4)), it.next());\n    /// assert_eq!(Some((2, 3, 4)), it.next());\n    /// assert_eq!(None, it.next());\n    ///\n    /// // this requires a type hint\n    /// let it = (1..5).tuple_combinations::<(_, _, _)>();\n    /// itertools::assert_equal(it, vec![(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]);\n    ///\n    /// // you can also specify the complete type\n    /// use itertools::TupleCombinations;\n    /// use std::ops::Range;\n    ///\n    /// let it: TupleCombinations<Range<u32>, (u32, u32, u32)> = (1..5).tuple_combinations();\n    /// itertools::assert_equal(it, vec![(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]);\n    /// ```\n    fn tuple_combinations<T>(self) -> TupleCombinations<Self, T>\n        where Self: Sized + Clone,\n              Self::Item: Clone,\n              T: adaptors::HasCombination<Self>,\n    {\n        adaptors::tuple_combinations(self)\n    }\n\n    /// Return an iterator adaptor that iterates over the `k`-length combinations of\n    /// the elements from an iterator.\n    ///\n    /// Iterator element type is `Vec<Self::Item>`. The iterator produces a new Vec per iteration,\n    /// and clones the iterator elements.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = (1..5).combinations(3);\n    /// itertools::assert_equal(it, vec![\n    ///     vec![1, 2, 3],\n    ///     vec![1, 2, 4],\n    ///     vec![1, 3, 4],\n    ///     vec![2, 3, 4],\n    /// ]);\n    /// ```\n    ///\n    /// Note: Combinations does not take into account the equality of the iterated values.\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = vec![1, 2, 2].into_iter().combinations(2);\n    /// itertools::assert_equal(it, vec![\n    ///     vec![1, 2], // Note: these are the same\n    ///     vec![1, 2], // Note: these are the same\n    ///     vec![2, 2],\n    /// ]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn combinations(self, k: usize) -> Combinations<Self>\n        where Self: Sized,\n              Self::Item: Clone\n    {\n        combinations::combinations(self, k)\n    }\n\n    /// Return an iterator that iterates over the `k`-length combinations of\n    /// the elements from an iterator, with replacement.\n    ///\n    /// Iterator element type is `Vec<Self::Item>`. The iterator produces a new Vec per iteration,\n    /// and clones the iterator elements.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = (1..4).combinations_with_replacement(2);\n    /// itertools::assert_equal(it, vec![\n    ///     vec![1, 1],\n    ///     vec![1, 2],\n    ///     vec![1, 3],\n    ///     vec![2, 2],\n    ///     vec![2, 3],\n    ///     vec![3, 3],\n    /// ]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn combinations_with_replacement(self, k: usize) -> CombinationsWithReplacement<Self>\n    where\n        Self: Sized,\n        Self::Item: Clone,\n    {\n        combinations_with_replacement::combinations_with_replacement(self, k)\n    }\n\n    /// Return an iterator adaptor that iterates over all k-permutations of the\n    /// elements from an iterator.\n    ///\n    /// Iterator element type is `Vec<Self::Item>` with length `k`. The iterator\n    /// produces a new Vec per iteration, and clones the iterator elements.\n    ///\n    /// If `k` is greater than the length of the input iterator, the resultant\n    /// iterator adaptor will be empty.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let perms = (5..8).permutations(2);\n    /// itertools::assert_equal(perms, vec![\n    ///     vec![5, 6],\n    ///     vec![5, 7],\n    ///     vec![6, 5],\n    ///     vec![6, 7],\n    ///     vec![7, 5],\n    ///     vec![7, 6],\n    /// ]);\n    /// ```\n    ///\n    /// Note: Permutations does not take into account the equality of the iterated values.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = vec![2, 2].into_iter().permutations(2);\n    /// itertools::assert_equal(it, vec![\n    ///     vec![2, 2], // Note: these are the same\n    ///     vec![2, 2], // Note: these are the same\n    /// ]);\n    /// ```\n    ///\n    /// Note: The source iterator is collected lazily, and will not be\n    /// re-iterated if the permutations adaptor is completed and re-iterated.\n    #[cfg(feature = \"use_std\")]\n    fn permutations(self, k: usize) -> Permutations<Self>\n        where Self: Sized,\n              Self::Item: Clone\n    {\n        permutations::permutations(self, k)\n    }\n\n    /// Return an iterator adaptor that pads the sequence to a minimum length of\n    /// `min` by filling missing elements using a closure `f`.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = (0..5).pad_using(10, |i| 2*i);\n    /// itertools::assert_equal(it, vec![0, 1, 2, 3, 4, 10, 12, 14, 16, 18]);\n    ///\n    /// let it = (0..10).pad_using(5, |i| 2*i);\n    /// itertools::assert_equal(it, vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n    ///\n    /// let it = (0..5).pad_using(10, |i| 2*i).rev();\n    /// itertools::assert_equal(it, vec![18, 16, 14, 12, 10, 4, 3, 2, 1, 0]);\n    /// ```\n    fn pad_using<F>(self, min: usize, f: F) -> PadUsing<Self, F>\n        where Self: Sized,\n              F: FnMut(usize) -> Self::Item\n    {\n        pad_tail::pad_using(self, min, f)\n    }\n\n    /// Return an iterator adaptor that wraps each element in a `Position` to\n    /// ease special-case handling of the first or last elements.\n    ///\n    /// Iterator element type is\n    /// [`Position<Self::Item>`](enum.Position.html)\n    ///\n    /// ```\n    /// use itertools::{Itertools, Position};\n    ///\n    /// let it = (0..4).with_position();\n    /// itertools::assert_equal(it,\n    ///                         vec![Position::First(0),\n    ///                              Position::Middle(1),\n    ///                              Position::Middle(2),\n    ///                              Position::Last(3)]);\n    ///\n    /// let it = (0..1).with_position();\n    /// itertools::assert_equal(it, vec![Position::Only(0)]);\n    /// ```\n    fn with_position(self) -> WithPosition<Self>\n        where Self: Sized,\n    {\n        with_position::with_position(self)\n    }\n\n    /// Return an iterator adaptor that yields the indices of all elements\n    /// satisfying a predicate, counted from the start of the iterator.\n    ///\n    /// Equivalent to `iter.enumerate().filter(|(_, v)| predicate(v)).map(|(i, _)| i)`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![1, 2, 3, 3, 4, 6, 7, 9];\n    /// itertools::assert_equal(data.iter().positions(|v| v % 2 == 0), vec![1, 4, 5]);\n    ///\n    /// itertools::assert_equal(data.iter().positions(|v| v % 2 == 1).rev(), vec![7, 6, 3, 2, 0]);\n    /// ```\n    fn positions<P>(self, predicate: P) -> Positions<Self, P>\n        where Self: Sized,\n              P: FnMut(Self::Item) -> bool,\n    {\n        adaptors::positions(self, predicate)\n    }\n\n    /// Return an iterator adaptor that applies a mutating function\n    /// to each element before yielding it.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let input = vec![vec![1], vec![3, 2, 1]];\n    /// let it = input.into_iter().update(|mut v| v.push(0));\n    /// itertools::assert_equal(it, vec![vec![1, 0], vec![3, 2, 1, 0]]);\n    /// ```\n    fn update<F>(self, updater: F) -> Update<Self, F>\n        where Self: Sized,\n              F: FnMut(&mut Self::Item),\n    {\n        adaptors::update(self, updater)\n    }\n\n    // non-adaptor methods\n    /// Advances the iterator and returns the next items grouped in a tuple of\n    /// a specific size (up to 4).\n    ///\n    /// If there are enough elements to be grouped in a tuple, then the tuple is\n    /// returned inside `Some`, otherwise `None` is returned.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut iter = 1..5;\n    ///\n    /// assert_eq!(Some((1, 2)), iter.next_tuple());\n    /// ```\n    fn next_tuple<T>(&mut self) -> Option<T>\n        where Self: Sized + Iterator<Item = T::Item>,\n              T: traits::HomogeneousTuple\n    {\n        T::collect_from_iter_no_buf(self)\n    }\n\n    /// Collects all items from the iterator into a tuple of a specific size\n    /// (up to 4).\n    ///\n    /// If the number of elements inside the iterator is **exactly** equal to\n    /// the tuple size, then the tuple is returned inside `Some`, otherwise\n    /// `None` is returned.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let iter = 1..3;\n    ///\n    /// if let Some((x, y)) = iter.collect_tuple() {\n    ///     assert_eq!((x, y), (1, 2))\n    /// } else {\n    ///     panic!(\"Expected two elements\")\n    /// }\n    /// ```\n    fn collect_tuple<T>(mut self) -> Option<T>\n        where Self: Sized + Iterator<Item = T::Item>,\n              T: traits::HomogeneousTuple\n    {\n        match self.next_tuple() {\n            elt @ Some(_) => match self.next() {\n                Some(_) => None,\n                None => elt,\n            },\n            _ => None\n        }\n    }\n\n\n    /// Find the position and value of the first element satisfying a predicate.\n    ///\n    /// The iterator is not advanced past the first element found.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let text = \"Hα\";\n    /// assert_eq!(text.chars().find_position(|ch| ch.is_lowercase()), Some((1, 'α')));\n    /// ```\n    fn find_position<P>(&mut self, mut pred: P) -> Option<(usize, Self::Item)>\n        where P: FnMut(&Self::Item) -> bool\n    {\n        let mut index = 0usize;\n        for elt in self {\n            if pred(&elt) {\n                return Some((index, elt));\n            }\n            index += 1;\n        }\n        None\n    }\n\n    /// Check whether all elements compare equal.\n    ///\n    /// Empty iterators are considered to have equal elements:\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![1, 1, 1, 2, 2, 3, 3, 3, 4, 5, 5];\n    /// assert!(!data.iter().all_equal());\n    /// assert!(data[0..3].iter().all_equal());\n    /// assert!(data[3..5].iter().all_equal());\n    /// assert!(data[5..8].iter().all_equal());\n    ///\n    /// let data : Option<usize> = None;\n    /// assert!(data.into_iter().all_equal());\n    /// ```\n    fn all_equal(&mut self) -> bool\n        where Self: Sized,\n              Self::Item: PartialEq,\n    {\n        match self.next() {\n            None => true,\n            Some(a) => self.all(|x| a == x),\n        }\n    }\n\n    /// Consume the first `n` elements from the iterator eagerly,\n    /// and return the same iterator again.\n    ///\n    /// It works similarly to *.skip(* `n` *)* except it is eager and\n    /// preserves the iterator type.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut iter = \"αβγ\".chars().dropping(2);\n    /// itertools::assert_equal(iter, \"γ\".chars());\n    /// ```\n    ///\n    /// *Fusing notes: if the iterator is exhausted by dropping,\n    /// the result of calling `.next()` again depends on the iterator implementation.*\n    fn dropping(mut self, n: usize) -> Self\n        where Self: Sized\n    {\n        if n > 0 {\n            self.nth(n - 1);\n        }\n        self\n    }\n\n    /// Consume the last `n` elements from the iterator eagerly,\n    /// and return the same iterator again.\n    ///\n    /// This is only possible on double ended iterators. `n` may be\n    /// larger than the number of elements.\n    ///\n    /// Note: This method is eager, dropping the back elements immediately and\n    /// preserves the iterator type.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let init = vec![0, 3, 6, 9].into_iter().dropping_back(1);\n    /// itertools::assert_equal(init, vec![0, 3, 6]);\n    /// ```\n    fn dropping_back(mut self, n: usize) -> Self\n        where Self: Sized,\n              Self: DoubleEndedIterator\n    {\n        if n > 0 {\n            (&mut self).rev().nth(n - 1);\n        }\n        self\n    }\n\n    /// Run the closure `f` eagerly on each element of the iterator.\n    ///\n    /// Consumes the iterator until its end.\n    ///\n    /// ```\n    /// use std::sync::mpsc::channel;\n    /// use itertools::Itertools;\n    ///\n    /// let (tx, rx) = channel();\n    ///\n    /// // use .foreach() to apply a function to each value -- sending it\n    /// (0..5).map(|x| x * 2 + 1).foreach(|x| { tx.send(x).unwrap(); } );\n    ///\n    /// drop(tx);\n    ///\n    /// itertools::assert_equal(rx.iter(), vec![1, 3, 5, 7, 9]);\n    /// ```\n    #[deprecated(note=\"Use .for_each() instead\", since=\"0.8\")]\n    fn foreach<F>(self, f: F)\n        where F: FnMut(Self::Item),\n              Self: Sized,\n    {\n        self.for_each(f)\n    }\n\n    /// Combine all an iterator's elements into one element by using `Extend`.\n    ///\n    /// This combinator will extend the first item with each of the rest of the\n    /// items of the iterator. If the iterator is empty, the default value of\n    /// `I::Item` is returned.\n    ///\n    /// ```rust\n    /// use itertools::Itertools;\n    ///\n    /// let input = vec![vec![1], vec![2, 3], vec![4, 5, 6]];\n    /// assert_eq!(input.into_iter().concat(),\n    ///            vec![1, 2, 3, 4, 5, 6]);\n    /// ```\n    fn concat(self) -> Self::Item\n        where Self: Sized,\n              Self::Item: Extend<<<Self as Iterator>::Item as IntoIterator>::Item> + IntoIterator + Default\n    {\n        concat(self)\n    }\n\n    /// `.collect_vec()` is simply a type specialization of `.collect()`,\n    /// for convenience.\n    #[cfg(feature = \"use_std\")]\n    fn collect_vec(self) -> Vec<Self::Item>\n        where Self: Sized\n    {\n        self.collect()\n    }\n\n    /// `.try_collect()` is more convenient way of writing\n    /// `.collect::<Result<_, _>>()`\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::{fs, io};\n    /// use itertools::Itertools;\n    ///\n    /// fn process_dir_entries(entries: &[fs::DirEntry]) {\n    ///     // ...\n    /// }\n    ///\n    /// fn do_stuff() -> std::io::Result<()> {\n    ///     let entries: Vec<_> = fs::read_dir(\".\")?.try_collect()?;\n    ///     process_dir_entries(&entries);\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn try_collect<T, U, E>(self) -> Result<U, E>\n    where\n        Self: Sized + Iterator<Item = Result<T, E>>,\n        Result<U, E>: FromIterator<Result<T, E>>,\n    {\n        self.collect()\n    }\n\n    /// Assign to each reference in `self` from the `from` iterator,\n    /// stopping at the shortest of the two iterators.\n    ///\n    /// The `from` iterator is queried for its next element before the `self`\n    /// iterator, and if either is exhausted the method is done.\n    ///\n    /// Return the number of elements written.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut xs = [0; 4];\n    /// xs.iter_mut().set_from(1..);\n    /// assert_eq!(xs, [1, 2, 3, 4]);\n    /// ```\n    #[inline]\n    fn set_from<'a, A: 'a, J>(&mut self, from: J) -> usize\n        where Self: Iterator<Item = &'a mut A>,\n              J: IntoIterator<Item = A>\n    {\n        let mut count = 0;\n        for elt in from {\n            match self.next() {\n                None => break,\n                Some(ptr) => *ptr = elt,\n            }\n            count += 1;\n        }\n        count\n    }\n\n    /// Combine all iterator elements into one String, separated by `sep`.\n    ///\n    /// Use the `Display` implementation of each element.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// assert_eq!([\"a\", \"b\", \"c\"].iter().join(\", \"), \"a, b, c\");\n    /// assert_eq!([1, 2, 3].iter().join(\", \"), \"1, 2, 3\");\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn join(&mut self, sep: &str) -> String\n        where Self::Item: std::fmt::Display\n    {\n        match self.next() {\n            None => String::new(),\n            Some(first_elt) => {\n                // estimate lower bound of capacity needed\n                let (lower, _) = self.size_hint();\n                let mut result = String::with_capacity(sep.len() * lower);\n                write!(&mut result, \"{}\", first_elt).unwrap();\n                for elt in self {\n                    result.push_str(sep);\n                    write!(&mut result, \"{}\", elt).unwrap();\n                }\n                result\n            }\n        }\n    }\n\n    /// Format all iterator elements, separated by `sep`.\n    ///\n    /// All elements are formatted (any formatting trait)\n    /// with `sep` inserted between each element.\n    ///\n    /// **Panics** if the formatter helper is formatted more than once.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = [1.1, 2.71828, -3.];\n    /// assert_eq!(\n    ///     format!(\"{:.2}\", data.iter().format(\", \")),\n    ///            \"1.10, 2.72, -3.00\");\n    /// ```\n    fn format(self, sep: &str) -> Format<Self>\n        where Self: Sized,\n    {\n        format::new_format_default(self, sep)\n    }\n\n    /// Format all iterator elements, separated by `sep`.\n    ///\n    /// This is a customizable version of `.format()`.\n    ///\n    /// The supplied closure `format` is called once per iterator element,\n    /// with two arguments: the element and a callback that takes a\n    /// `&Display` value, i.e. any reference to type that implements `Display`.\n    ///\n    /// Using `&format_args!(...)` is the most versatile way to apply custom\n    /// element formatting. The callback can be called multiple times if needed.\n    ///\n    /// **Panics** if the formatter helper is formatted more than once.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = [1.1, 2.71828, -3.];\n    /// let data_formatter = data.iter().format_with(\", \", |elt, f| f(&format_args!(\"{:.2}\", elt)));\n    /// assert_eq!(format!(\"{}\", data_formatter),\n    ///            \"1.10, 2.72, -3.00\");\n    ///\n    /// // .format_with() is recursively composable\n    /// let matrix = [[1., 2., 3.],\n    ///               [4., 5., 6.]];\n    /// let matrix_formatter = matrix.iter().format_with(\"\\n\", |row, f| {\n    ///                                 f(&row.iter().format_with(\", \", |elt, g| g(&elt)))\n    ///                              });\n    /// assert_eq!(format!(\"{}\", matrix_formatter),\n    ///            \"1, 2, 3\\n4, 5, 6\");\n    ///\n    ///\n    /// ```\n    fn format_with<F>(self, sep: &str, format: F) -> FormatWith<Self, F>\n        where Self: Sized,\n              F: FnMut(Self::Item, &mut dyn FnMut(&dyn fmt::Display) -> fmt::Result) -> fmt::Result,\n    {\n        format::new_format(self, sep, format)\n    }\n\n    /// Fold `Result` values from an iterator.\n    ///\n    /// Only `Ok` values are folded. If no error is encountered, the folded\n    /// value is returned inside `Ok`. Otherwise, the operation terminates\n    /// and returns the first `Err` value it encounters. No iterator elements are\n    /// consumed after the first error.\n    ///\n    /// The first accumulator value is the `start` parameter.\n    /// Each iteration passes the accumulator value and the next value inside `Ok`\n    /// to the fold function `f` and its return value becomes the new accumulator value.\n    ///\n    /// For example the sequence *Ok(1), Ok(2), Ok(3)* will result in a\n    /// computation like this:\n    ///\n    /// ```ignore\n    /// let mut accum = start;\n    /// accum = f(accum, 1);\n    /// accum = f(accum, 2);\n    /// accum = f(accum, 3);\n    /// ```\n    ///\n    /// With a `start` value of 0 and an addition as folding function,\n    /// this effectively results in *((0 + 1) + 2) + 3*\n    ///\n    /// ```\n    /// use std::ops::Add;\n    /// use itertools::Itertools;\n    ///\n    /// let values = [1, 2, -2, -1, 2, 1];\n    /// assert_eq!(\n    ///     values.iter()\n    ///           .map(Ok::<_, ()>)\n    ///           .fold_results(0, Add::add),\n    ///     Ok(3)\n    /// );\n    /// assert!(\n    ///     values.iter()\n    ///           .map(|&x| if x >= 0 { Ok(x) } else { Err(\"Negative number\") })\n    ///           .fold_results(0, Add::add)\n    ///           .is_err()\n    /// );\n    /// ```\n    fn fold_results<A, E, B, F>(&mut self, mut start: B, mut f: F) -> Result<B, E>\n        where Self: Iterator<Item = Result<A, E>>,\n              F: FnMut(B, A) -> B\n    {\n        for elt in self {\n            match elt {\n                Ok(v) => start = f(start, v),\n                Err(u) => return Err(u),\n            }\n        }\n        Ok(start)\n    }\n\n    /// Fold `Option` values from an iterator.\n    ///\n    /// Only `Some` values are folded. If no `None` is encountered, the folded\n    /// value is returned inside `Some`. Otherwise, the operation terminates\n    /// and returns `None`. No iterator elements are consumed after the `None`.\n    ///\n    /// This is the `Option` equivalent to `fold_results`.\n    ///\n    /// ```\n    /// use std::ops::Add;\n    /// use itertools::Itertools;\n    ///\n    /// let mut values = vec![Some(1), Some(2), Some(-2)].into_iter();\n    /// assert_eq!(values.fold_options(5, Add::add), Some(5 + 1 + 2 - 2));\n    ///\n    /// let mut more_values = vec![Some(2), None, Some(0)].into_iter();\n    /// assert!(more_values.fold_options(0, Add::add).is_none());\n    /// assert_eq!(more_values.next().unwrap(), Some(0));\n    /// ```\n    fn fold_options<A, B, F>(&mut self, mut start: B, mut f: F) -> Option<B>\n        where Self: Iterator<Item = Option<A>>,\n              F: FnMut(B, A) -> B\n    {\n        for elt in self {\n            match elt {\n                Some(v) => start = f(start, v),\n                None => return None,\n            }\n        }\n        Some(start)\n    }\n\n    /// Accumulator of the elements in the iterator.\n    ///\n    /// Like `.fold()`, without a base case. If the iterator is\n    /// empty, return `None`. With just one element, return it.\n    /// Otherwise elements are accumulated in sequence using the closure `f`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// assert_eq!((0..10).fold1(|x, y| x + y).unwrap_or(0), 45);\n    /// assert_eq!((0..0).fold1(|x, y| x * y), None);\n    /// ```\n    fn fold1<F>(mut self, f: F) -> Option<Self::Item>\n        where F: FnMut(Self::Item, Self::Item) -> Self::Item,\n              Self: Sized,\n    {\n        self.next().map(move |x| self.fold(x, f))\n    }\n\n    /// Accumulate the elements in the iterator in a tree-like manner.\n    ///\n    /// You can think of it as, while there's more than one item, repeatedly\n    /// combining adjacent items.  It does so in bottom-up-merge-sort order,\n    /// however, so that it needs only logarithmic stack space.\n    ///\n    /// This produces a call tree like the following (where the calls under\n    /// an item are done after reading that item):\n    ///\n    /// ```text\n    /// 1 2 3 4 5 6 7\n    /// │ │ │ │ │ │ │\n    /// └─f └─f └─f │\n    ///   │   │   │ │\n    ///   └───f   └─f\n    ///       │     │\n    ///       └─────f\n    /// ```\n    ///\n    /// Which, for non-associative functions, will typically produce a different\n    /// result than the linear call tree used by `fold1`:\n    ///\n    /// ```text\n    /// 1 2 3 4 5 6 7\n    /// │ │ │ │ │ │ │\n    /// └─f─f─f─f─f─f\n    /// ```\n    ///\n    /// If `f` is associative, prefer the normal `fold1` instead.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // The same tree as above\n    /// let num_strings = (1..8).map(|x| x.to_string());\n    /// assert_eq!(num_strings.tree_fold1(|x, y| format!(\"f({}, {})\", x, y)),\n    ///     Some(String::from(\"f(f(f(1, 2), f(3, 4)), f(f(5, 6), 7))\")));\n    ///\n    /// // Like fold1, an empty iterator produces None\n    /// assert_eq!((0..0).tree_fold1(|x, y| x * y), None);\n    ///\n    /// // tree_fold1 matches fold1 for associative operations...\n    /// assert_eq!((0..10).tree_fold1(|x, y| x + y),\n    ///     (0..10).fold1(|x, y| x + y));\n    /// // ...but not for non-associative ones\n    /// assert_ne!((0..10).tree_fold1(|x, y| x - y),\n    ///     (0..10).fold1(|x, y| x - y));\n    /// ```\n    fn tree_fold1<F>(mut self, mut f: F) -> Option<Self::Item>\n        where F: FnMut(Self::Item, Self::Item) -> Self::Item,\n              Self: Sized,\n    {\n        type State<T> = Result<T, Option<T>>;\n\n        fn inner0<T, II, FF>(it: &mut II, f: &mut FF) -> State<T>\n            where\n                II: Iterator<Item = T>,\n                FF: FnMut(T, T) -> T\n        {\n            // This function could be replaced with `it.next().ok_or(None)`,\n            // but half the useful tree_fold1 work is combining adjacent items,\n            // so put that in a form that LLVM is more likely to optimize well.\n\n            let a =\n                if let Some(v) = it.next() { v }\n                else { return Err(None) };\n            let b =\n                if let Some(v) = it.next() { v }\n                else { return Err(Some(a)) };\n            Ok(f(a, b))\n        }\n\n        fn inner<T, II, FF>(stop: usize, it: &mut II, f: &mut FF) -> State<T>\n            where\n                II: Iterator<Item = T>,\n                FF: FnMut(T, T) -> T\n        {\n            let mut x = inner0(it, f)?;\n            for height in 0..stop {\n                // Try to get another tree the same size with which to combine it,\n                // creating a new tree that's twice as big for next time around.\n                let next =\n                    if height == 0 {\n                        inner0(it, f)\n                    } else {\n                        inner(height, it, f)\n                    };\n                match next {\n                    Ok(y) => x = f(x, y),\n\n                    // If we ran out of items, combine whatever we did manage\n                    // to get.  It's better combined with the current value\n                    // than something in a parent frame, because the tree in\n                    // the parent is always as least as big as this one.\n                    Err(None) => return Err(Some(x)),\n                    Err(Some(y)) => return Err(Some(f(x, y))),\n                }\n            }\n            Ok(x)\n        }\n\n        match inner(usize::max_value(), &mut self, &mut f) {\n            Err(x) => x,\n            _ => unreachable!(),\n        }\n    }\n\n    /// An iterator method that applies a function, producing a single, final value.\n    ///\n    /// `fold_while()` is basically equivalent to `fold()` but with additional support for\n    /// early exit via short-circuiting.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// use itertools::FoldWhile::{Continue, Done};\n    ///\n    /// let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    ///\n    /// let mut result = 0;\n    ///\n    /// // for loop:\n    /// for i in &numbers {\n    ///     if *i > 5 {\n    ///         break;\n    ///     }\n    ///     result = result + i;\n    /// }\n    ///\n    /// // fold:\n    /// let result2 = numbers.iter().fold(0, |acc, x| {\n    ///     if *x > 5 { acc } else { acc + x }\n    /// });\n    ///\n    /// // fold_while:\n    /// let result3 = numbers.iter().fold_while(0, |acc, x| {\n    ///     if *x > 5 { Done(acc) } else { Continue(acc + x) }\n    /// }).into_inner();\n    ///\n    /// // they're the same\n    /// assert_eq!(result, result2);\n    /// assert_eq!(result2, result3);\n    /// ```\n    ///\n    /// The big difference between the computations of `result2` and `result3` is that while\n    /// `fold()` called the provided closure for every item of the callee iterator,\n    /// `fold_while()` actually stopped iterating as soon as it encountered `Fold::Done(_)`.\n    #[deprecated(note=\"Use .try_fold() instead\", since=\"0.8\")]\n    fn fold_while<B, F>(&mut self, init: B, mut f: F) -> FoldWhile<B>\n        where Self: Sized,\n              F: FnMut(B, Self::Item) -> FoldWhile<B>\n    {\n        let mut acc = init;\n        while let Some(item) = self.next() {\n            match f(acc, item) {\n                FoldWhile::Continue(res) => acc = res,\n                res @ FoldWhile::Done(_) => return res,\n            }\n        }\n        FoldWhile::Continue(acc)\n    }\n\n    /// Iterate over the entire iterator and add all the elements.\n    ///\n    /// An empty iterator returns `None`, otherwise `Some(sum)`.\n    ///\n    /// # Panics\n    ///\n    /// When calling `sum1()` and a primitive integer type is being returned, this\n    /// method will panic if the computation overflows and debug assertions are\n    /// enabled.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let empty_sum = (1..1).sum1::<i32>();\n    /// assert_eq!(empty_sum, None);\n    ///\n    /// let nonempty_sum = (1..11).sum1::<i32>();\n    /// assert_eq!(nonempty_sum, Some(55));\n    /// ```\n    fn sum1<S>(mut self) -> Option<S>\n        where Self: Sized,\n              S: std::iter::Sum<Self::Item>,\n    {\n        self.next()\n            .map(|first| once(first).chain(self).sum())\n    }\n\n    /// Iterate over the entire iterator and multiply all the elements.\n    ///\n    /// An empty iterator returns `None`, otherwise `Some(product)`.\n    ///\n    /// # Panics\n    ///\n    /// When calling `product1()` and a primitive integer type is being returned,\n    /// method will panic if the computation overflows and debug assertions are\n    /// enabled.\n    ///\n    /// # Examples\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let empty_product = (1..1).product1::<i32>();\n    /// assert_eq!(empty_product, None);\n    ///\n    /// let nonempty_product = (1..11).product1::<i32>();\n    /// assert_eq!(nonempty_product, Some(3628800));\n    /// ```\n    fn product1<P>(mut self) -> Option<P>\n        where Self: Sized,\n              P: std::iter::Product<Self::Item>,\n    {\n        self.next()\n            .map(|first| once(first).chain(self).product())\n    }\n\n\n    /// Sort all iterator elements into a new iterator in ascending order.\n    ///\n    /// **Note:** This consumes the entire iterator, uses the\n    /// `slice::sort()` method and returns the result as a new\n    /// iterator that owns its elements.\n    ///\n    /// The sorted iterator, if directly collected to a `Vec`, is converted\n    /// without any extra copying or allocation cost.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // sort the letters of the text in ascending order\n    /// let text = \"bdacfe\";\n    /// itertools::assert_equal(text.chars().sorted(),\n    ///                         \"abcdef\".chars());\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn sorted(self) -> VecIntoIter<Self::Item>\n        where Self: Sized,\n              Self::Item: Ord\n    {\n        // Use .sort() directly since it is not quite identical with\n        // .sort_by(Ord::cmp)\n        let mut v = Vec::from_iter(self);\n        v.sort();\n        v.into_iter()\n    }\n\n    /// Sort all iterator elements into a new iterator in ascending order.\n    ///\n    /// **Note:** This consumes the entire iterator, uses the\n    /// `slice::sort_by()` method and returns the result as a new\n    /// iterator that owns its elements.\n    ///\n    /// The sorted iterator, if directly collected to a `Vec`, is converted\n    /// without any extra copying or allocation cost.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // sort people in descending order by age\n    /// let people = vec![(\"Jane\", 20), (\"John\", 18), (\"Jill\", 30), (\"Jack\", 27)];\n    ///\n    /// let oldest_people_first = people\n    ///     .into_iter()\n    ///     .sorted_by(|a, b| Ord::cmp(&b.1, &a.1))\n    ///     .map(|(person, _age)| person);\n    ///\n    /// itertools::assert_equal(oldest_people_first,\n    ///                         vec![\"Jill\", \"Jack\", \"Jane\", \"John\"]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn sorted_by<F>(self, cmp: F) -> VecIntoIter<Self::Item>\n        where Self: Sized,\n              F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n    {\n        let mut v = Vec::from_iter(self);\n        v.sort_by(cmp);\n        v.into_iter()\n    }\n\n    /// Sort all iterator elements into a new iterator in ascending order.\n    ///\n    /// **Note:** This consumes the entire iterator, uses the\n    /// `slice::sort_by_key()` method and returns the result as a new\n    /// iterator that owns its elements.\n    ///\n    /// The sorted iterator, if directly collected to a `Vec`, is converted\n    /// without any extra copying or allocation cost.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // sort people in descending order by age\n    /// let people = vec![(\"Jane\", 20), (\"John\", 18), (\"Jill\", 30), (\"Jack\", 27)];\n    ///\n    /// let oldest_people_first = people\n    ///     .into_iter()\n    ///     .sorted_by_key(|x| -x.1)\n    ///     .map(|(person, _age)| person);\n    ///\n    /// itertools::assert_equal(oldest_people_first,\n    ///                         vec![\"Jill\", \"Jack\", \"Jane\", \"John\"]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn sorted_by_key<K, F>(self, f: F) -> VecIntoIter<Self::Item>\n        where Self: Sized,\n              K: Ord,\n              F: FnMut(&Self::Item) -> K,\n    {\n        let mut v = Vec::from_iter(self);\n        v.sort_by_key(f);\n        v.into_iter()\n    }\n\n    /// Collect all iterator elements into one of two\n    /// partitions. Unlike `Iterator::partition`, each partition may\n    /// have a distinct type.\n    ///\n    /// ```\n    /// use itertools::{Itertools, Either};\n    ///\n    /// let successes_and_failures = vec![Ok(1), Err(false), Err(true), Ok(2)];\n    ///\n    /// let (successes, failures): (Vec<_>, Vec<_>) = successes_and_failures\n    ///     .into_iter()\n    ///     .partition_map(|r| {\n    ///         match r {\n    ///             Ok(v) => Either::Left(v),\n    ///             Err(v) => Either::Right(v),\n    ///         }\n    ///     });\n    ///\n    /// assert_eq!(successes, [1, 2]);\n    /// assert_eq!(failures, [false, true]);\n    /// ```\n    fn partition_map<A, B, F, L, R>(self, mut predicate: F) -> (A, B)\n        where Self: Sized,\n              F: FnMut(Self::Item) -> Either<L, R>,\n              A: Default + Extend<L>,\n              B: Default + Extend<R>,\n    {\n        let mut left = A::default();\n        let mut right = B::default();\n\n        self.for_each(|val| match predicate(val) {\n            Either::Left(v) => left.extend(Some(v)),\n            Either::Right(v) => right.extend(Some(v)),\n        });\n\n        (left, right)\n    }\n\n    /// Return a `HashMap` of keys mapped to `Vec`s of values. Keys and values\n    /// are taken from `(Key, Value)` tuple pairs yielded by the input iterator.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![(0, 10), (2, 12), (3, 13), (0, 20), (3, 33), (2, 42)];\n    /// let lookup = data.into_iter().into_group_map();\n    ///\n    /// assert_eq!(lookup[&0], vec![10, 20]);\n    /// assert_eq!(lookup.get(&1), None);\n    /// assert_eq!(lookup[&2], vec![12, 42]);\n    /// assert_eq!(lookup[&3], vec![13, 33]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn into_group_map<K, V>(self) -> HashMap<K, Vec<V>>\n        where Self: Iterator<Item=(K, V)> + Sized,\n              K: Hash + Eq,\n    {\n        group_map::into_group_map(self)\n    }\n\n    /// Return the minimum and maximum elements in the iterator.\n    ///\n    /// The return type `MinMaxResult` is an enum of three variants:\n    ///\n    /// - `NoElements` if the iterator is empty.\n    /// - `OneElement(x)` if the iterator has exactly one element.\n    /// - `MinMax(x, y)` is returned otherwise, where `x <= y`. Two\n    ///    values are equal if and only if there is more than one\n    ///    element in the iterator and all elements are equal.\n    ///\n    /// On an iterator of length `n`, `minmax` does `1.5 * n` comparisons,\n    /// and so is faster than calling `min` and `max` separately which does\n    /// `2 * n` comparisons.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// use itertools::MinMaxResult::{NoElements, OneElement, MinMax};\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().minmax(), NoElements);\n    ///\n    /// let a = [1];\n    /// assert_eq!(a.iter().minmax(), OneElement(&1));\n    ///\n    /// let a = [1, 2, 3, 4, 5];\n    /// assert_eq!(a.iter().minmax(), MinMax(&1, &5));\n    ///\n    /// let a = [1, 1, 1, 1];\n    /// assert_eq!(a.iter().minmax(), MinMax(&1, &1));\n    /// ```\n    ///\n    /// The elements can be floats but no particular result is guaranteed\n    /// if an element is NaN.\n    fn minmax(self) -> MinMaxResult<Self::Item>\n        where Self: Sized, Self::Item: PartialOrd\n    {\n        minmax::minmax_impl(self, |_| (), |x, y, _, _| x < y)\n    }\n\n    /// Return the minimum and maximum element of an iterator, as determined by\n    /// the specified function.\n    ///\n    /// The return value is a variant of `MinMaxResult` like for `minmax()`.\n    ///\n    /// For the minimum, the first minimal element is returned.  For the maximum,\n    /// the last maximal element wins.  This matches the behavior of the standard\n    /// `Iterator::min()` and `Iterator::max()` methods.\n    ///\n    /// The keys can be floats but no particular result is guaranteed\n    /// if a key is NaN.\n    fn minmax_by_key<K, F>(self, key: F) -> MinMaxResult<Self::Item>\n        where Self: Sized, K: PartialOrd, F: FnMut(&Self::Item) -> K\n    {\n        minmax::minmax_impl(self, key, |_, _, xk, yk| xk < yk)\n    }\n\n    /// Return the minimum and maximum element of an iterator, as determined by\n    /// the specified comparison function.\n    ///\n    /// The return value is a variant of `MinMaxResult` like for `minmax()`.\n    ///\n    /// For the minimum, the first minimal element is returned.  For the maximum,\n    /// the last maximal element wins.  This matches the behavior of the standard\n    /// `Iterator::min()` and `Iterator::max()` methods.\n    fn minmax_by<F>(self, mut compare: F) -> MinMaxResult<Self::Item>\n        where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering\n    {\n        minmax::minmax_impl(\n            self,\n            |_| (),\n            |x, y, _, _| Ordering::Less == compare(x, y)\n        )\n    }\n\n    /// Return the position of the maximum element in the iterator.\n    ///\n    /// If several elements are equally maximum, the position of the\n    /// last of them is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_max(), None);\n    ///\n    /// let a = [-3, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_max(), Some(3));\n    ///\n    /// let a = [1, 1, -1, -1];\n    /// assert_eq!(a.iter().position_max(), Some(1));\n    /// ```\n    fn position_max(self) -> Option<usize>\n        where Self: Sized, Self::Item: Ord\n    {\n        self.enumerate()\n            .max_by(|x, y| Ord::cmp(&x.1, &y.1))\n            .map(|x| x.0)\n    }\n\n    /// Return the position of the maximum element in the iterator, as\n    /// determined by the specified function.\n    ///\n    /// If several elements are equally maximum, the position of the\n    /// last of them is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_max_by_key(|x| x.abs()), None);\n    ///\n    /// let a = [-3_i32, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_max_by_key(|x| x.abs()), Some(4));\n    ///\n    /// let a = [1_i32, 1, -1, -1];\n    /// assert_eq!(a.iter().position_max_by_key(|x| x.abs()), Some(3));\n    /// ```\n    fn position_max_by_key<K, F>(self, mut key: F) -> Option<usize>\n        where Self: Sized, K: Ord, F: FnMut(&Self::Item) -> K\n    {\n        self.enumerate()\n            .max_by(|x, y| Ord::cmp(&key(&x.1), &key(&y.1)))\n            .map(|x| x.0)\n    }\n\n    /// Return the position of the maximum element in the iterator, as\n    /// determined by the specified comparison function.\n    ///\n    /// If several elements are equally maximum, the position of the\n    /// last of them is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_max_by(|x, y| x.cmp(y)), None);\n    ///\n    /// let a = [-3_i32, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_max_by(|x, y| x.cmp(y)), Some(3));\n    ///\n    /// let a = [1_i32, 1, -1, -1];\n    /// assert_eq!(a.iter().position_max_by(|x, y| x.cmp(y)), Some(1));\n    /// ```\n    fn position_max_by<F>(self, mut compare: F) -> Option<usize>\n        where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering\n    {\n        self.enumerate()\n            .max_by(|x, y| compare(&x.1, &y.1))\n            .map(|x| x.0)\n    }\n\n    /// Return the position of the minimum element in the iterator.\n    ///\n    /// If several elements are equally minimum, the position of the\n    /// first of them is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_min(), None);\n    ///\n    /// let a = [-3, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_min(), Some(4));\n    ///\n    /// let a = [1, 1, -1, -1];\n    /// assert_eq!(a.iter().position_min(), Some(2));\n    /// ```\n    fn position_min(self) -> Option<usize>\n        where Self: Sized, Self::Item: Ord\n    {\n        self.enumerate()\n            .min_by(|x, y| Ord::cmp(&x.1, &y.1))\n            .map(|x| x.0)\n    }\n\n    /// Return the position of the minimum element in the iterator, as\n    /// determined by the specified function.\n    ///\n    /// If several elements are equally minimum, the position of the\n    /// first of them is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_min_by_key(|x| x.abs()), None);\n    ///\n    /// let a = [-3_i32, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_min_by_key(|x| x.abs()), Some(1));\n    ///\n    /// let a = [1_i32, 1, -1, -1];\n    /// assert_eq!(a.iter().position_min_by_key(|x| x.abs()), Some(0));\n    /// ```\n    fn position_min_by_key<K, F>(self, mut key: F) -> Option<usize>\n        where Self: Sized, K: Ord, F: FnMut(&Self::Item) -> K\n    {\n        self.enumerate()\n            .min_by(|x, y| Ord::cmp(&key(&x.1), &key(&y.1)))\n            .map(|x| x.0)\n    }\n\n    /// Return the position of the minimum element in the iterator, as\n    /// determined by the specified comparison function.\n    ///\n    /// If several elements are equally minimum, the position of the\n    /// first of them is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_min_by(|x, y| x.cmp(y)), None);\n    ///\n    /// let a = [-3_i32, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_min_by(|x, y| x.cmp(y)), Some(4));\n    ///\n    /// let a = [1_i32, 1, -1, -1];\n    /// assert_eq!(a.iter().position_min_by(|x, y| x.cmp(y)), Some(2));\n    /// ```\n    fn position_min_by<F>(self, mut compare: F) -> Option<usize>\n        where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering\n    {\n        self.enumerate()\n            .min_by(|x, y| compare(&x.1, &y.1))\n            .map(|x| x.0)\n    }\n\n    /// Return the positions of the minimum and maximum elements in\n    /// the iterator.\n    ///\n    /// The return type [`MinMaxResult`] is an enum of three variants:\n    ///\n    /// - `NoElements` if the iterator is empty.\n    /// - `OneElement(xpos)` if the iterator has exactly one element.\n    /// - `MinMax(xpos, ypos)` is returned otherwise, where the\n    ///    element at `xpos` ≤ the element at `ypos`. While the\n    ///    referenced elements themselves may be equal, `xpos` cannot\n    ///    be equal to `ypos`.\n    ///\n    /// On an iterator of length `n`, `position_minmax` does `1.5 * n`\n    /// comparisons, and so is faster than calling `positon_min` and\n    /// `position_max` separately which does `2 * n` comparisons.\n    ///\n    /// For the minimum, if several elements are equally minimum, the\n    /// position of the first of them is returned. For the maximum, if\n    /// several elements are equally maximum, the position of the last\n    /// of them is returned.\n    ///\n    /// The elements can be floats but no particular result is\n    /// guaranteed if an element is NaN.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// use itertools::MinMaxResult::{NoElements, OneElement, MinMax};\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_minmax(), NoElements);\n    ///\n    /// let a = [10];\n    /// assert_eq!(a.iter().position_minmax(), OneElement(0));\n    ///\n    /// let a = [-3, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_minmax(), MinMax(4, 3));\n    ///\n    /// let a = [1, 1, -1, -1];\n    /// assert_eq!(a.iter().position_minmax(), MinMax(2, 1));\n    /// ```\n    ///\n    /// [`MinMaxResult`]: enum.MinMaxResult.html\n    fn position_minmax(self) -> MinMaxResult<usize>\n        where Self: Sized, Self::Item: PartialOrd\n    {\n        use crate::MinMaxResult::{NoElements, OneElement, MinMax};\n        match minmax::minmax_impl(self.enumerate(), |_| (), |x, y, _, _| x.1 < y.1) {\n            NoElements => NoElements,\n            OneElement(x) => OneElement(x.0),\n            MinMax(x, y) => MinMax(x.0, y.0),\n        }\n    }\n\n    /// Return the postions of the minimum and maximum elements of an\n    /// iterator, as determined by the specified function.\n    ///\n    /// The return value is a variant of [`MinMaxResult`] like for\n    /// [`position_minmax`].\n    ///\n    /// For the minimum, if several elements are equally minimum, the\n    /// position of the first of them is returned. For the maximum, if\n    /// several elements are equally maximum, the position of the last\n    /// of them is returned.\n    ///\n    /// The keys can be floats but no particular result is guaranteed\n    /// if a key is NaN.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// use itertools::MinMaxResult::{NoElements, OneElement, MinMax};\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_minmax_by_key(|x| x.abs()), NoElements);\n    ///\n    /// let a = [10_i32];\n    /// assert_eq!(a.iter().position_minmax_by_key(|x| x.abs()), OneElement(0));\n    ///\n    /// let a = [-3_i32, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_minmax_by_key(|x| x.abs()), MinMax(1, 4));\n    ///\n    /// let a = [1_i32, 1, -1, -1];\n    /// assert_eq!(a.iter().position_minmax_by_key(|x| x.abs()), MinMax(0, 3));\n    /// ```\n    ///\n    /// [`MinMaxResult`]: enum.MinMaxResult.html\n    /// [`position_minmax`]: #method.position_minmax\n    fn position_minmax_by_key<K, F>(self, mut key: F) -> MinMaxResult<usize>\n        where Self: Sized, K: PartialOrd, F: FnMut(&Self::Item) -> K\n    {\n        use crate::MinMaxResult::{NoElements, OneElement, MinMax};\n        match self.enumerate().minmax_by_key(|e| key(&e.1)) {\n            NoElements => NoElements,\n            OneElement(x) => OneElement(x.0),\n            MinMax(x, y) => MinMax(x.0, y.0),\n        }\n    }\n\n    /// Return the postions of the minimum and maximum elements of an\n    /// iterator, as determined by the specified comparison function.\n    ///\n    /// The return value is a variant of [`MinMaxResult`] like for\n    /// [`position_minmax`].\n    ///\n    /// For the minimum, if several elements are equally minimum, the\n    /// position of the first of them is returned. For the maximum, if\n    /// several elements are equally maximum, the position of the last\n    /// of them is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// use itertools::MinMaxResult::{NoElements, OneElement, MinMax};\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_minmax_by(|x, y| x.cmp(y)), NoElements);\n    ///\n    /// let a = [10_i32];\n    /// assert_eq!(a.iter().position_minmax_by(|x, y| x.cmp(y)), OneElement(0));\n    ///\n    /// let a = [-3_i32, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_minmax_by(|x, y| x.cmp(y)), MinMax(4, 3));\n    ///\n    /// let a = [1_i32, 1, -1, -1];\n    /// assert_eq!(a.iter().position_minmax_by(|x, y| x.cmp(y)), MinMax(2, 1));\n    /// ```\n    ///\n    /// [`MinMaxResult`]: enum.MinMaxResult.html\n    /// [`position_minmax`]: #method.position_minmax\n    fn position_minmax_by<F>(self, mut compare: F) -> MinMaxResult<usize>\n        where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering\n    {\n        use crate::MinMaxResult::{NoElements, OneElement, MinMax};\n        match self.enumerate().minmax_by(|x, y| compare(&x.1, &y.1)) {\n            NoElements => NoElements,\n            OneElement(x) => OneElement(x.0),\n            MinMax(x, y) => MinMax(x.0, y.0),\n        }\n    }\n\n    /// If the iterator yields exactly one element, that element will be returned, otherwise\n    /// an error will be returned containing an iterator that has the same output as the input\n    /// iterator.\n    ///\n    /// This provides an additional layer of validation over just calling `Iterator::next()`.\n    /// If your assumption that there should only be one element yielded is false this provides\n    /// the opportunity to detect and handle that, preventing errors at a distance.\n    ///\n    /// # Examples\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// assert_eq!((0..10).filter(|&x| x == 2).exactly_one().unwrap(), 2);\n    /// assert!((0..10).filter(|&x| x > 1 && x < 4).exactly_one().unwrap_err().eq(2..4));\n    /// assert!((0..10).filter(|&x| x > 1 && x < 5).exactly_one().unwrap_err().eq(2..5));\n    /// assert!((0..10).filter(|&_| false).exactly_one().unwrap_err().eq(0..0));\n    /// ```\n    fn exactly_one(mut self) -> Result<Self::Item, ExactlyOneError<Self>>\n    where\n        Self: Sized,\n    {\n        match self.next() {\n            Some(first) => {\n                match self.next() {\n                    Some(second) => {\n                        Err(ExactlyOneError::new((Some(first), Some(second)), self))\n                    }\n                    None => {\n                        Ok(first)\n                    }\n                }\n            }\n            None => Err(ExactlyOneError::new((None, None), self)),\n        }\n    }\n\n    /// An iterator adaptor that allows the user to peek at multiple `.next()`\n    /// values without advancing the base iterator.\n    ///\n    /// # Examples\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut iter = (0..10).multipeek();\n    /// assert_eq!(iter.peek(), Some(&0));\n    /// assert_eq!(iter.peek(), Some(&1));\n    /// assert_eq!(iter.peek(), Some(&2));\n    /// assert_eq!(iter.next(), Some(0));\n    /// assert_eq!(iter.peek(), Some(&1));\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn multipeek(self) -> MultiPeek<Self>\n    where\n        Self: Sized,\n    {\n        multipeek_impl::multipeek(self)\n    }\n}\n\nimpl<T: ?Sized> Itertools for T where T: Iterator { }\n\n/// Return `true` if both iterables produce equal sequences\n/// (elements pairwise equal and sequences of the same length),\n/// `false` otherwise.\n///\n/// This is an `IntoIterator` enabled function that is similar to the standard\n/// library method `Iterator::eq`.\n///\n/// ```\n/// assert!(itertools::equal(vec![1, 2, 3], 1..4));\n/// assert!(!itertools::equal(&[0, 0], &[0, 0, 0]));\n/// ```\npub fn equal<I, J>(a: I, b: J) -> bool\n    where I: IntoIterator,\n          J: IntoIterator,\n          I::Item: PartialEq<J::Item>\n{\n    let mut ia = a.into_iter();\n    let mut ib = b.into_iter();\n    loop {\n        match ia.next() {\n            Some(x) => match ib.next() {\n                Some(y) => if x != y { return false; },\n                None => return false,\n            },\n            None => return ib.next().is_none()\n        }\n    }\n}\n\n/// Assert that two iterables produce equal sequences, with the same\n/// semantics as *equal(a, b)*.\n///\n/// **Panics** on assertion failure with a message that shows the\n/// two iteration elements.\n///\n/// ```ignore\n/// assert_equal(\"exceed\".split('c'), \"excess\".split('c'));\n/// // ^PANIC: panicked at 'Failed assertion Some(\"eed\") == Some(\"ess\") for iteration 1',\n/// ```\npub fn assert_equal<I, J>(a: I, b: J)\n    where I: IntoIterator,\n          J: IntoIterator,\n          I::Item: fmt::Debug + PartialEq<J::Item>,\n          J::Item: fmt::Debug,\n{\n    let mut ia = a.into_iter();\n    let mut ib = b.into_iter();\n    let mut i = 0;\n    loop {\n        match (ia.next(), ib.next()) {\n            (None, None) => return,\n            (a, b) => {\n                let equal = match (&a, &b) {\n                    (&Some(ref a), &Some(ref b)) => a == b,\n                    _ => false,\n                };\n                assert!(equal, \"Failed assertion {a:?} == {b:?} for iteration {i}\",\n                        i=i, a=a, b=b);\n                i += 1;\n            }\n        }\n    }\n}\n\n/// Partition a sequence using predicate `pred` so that elements\n/// that map to `true` are placed before elements which map to `false`.\n///\n/// The order within the partitions is arbitrary.\n///\n/// Return the index of the split point.\n///\n/// ```\n/// use itertools::partition;\n///\n/// # // use repeated numbers to not promise any ordering\n/// let mut data = [7, 1, 1, 7, 1, 1, 7];\n/// let split_index = partition(&mut data, |elt| *elt >= 3);\n///\n/// assert_eq!(data, [7, 7, 7, 1, 1, 1, 1]);\n/// assert_eq!(split_index, 3);\n/// ```\npub fn partition<'a, A: 'a, I, F>(iter: I, mut pred: F) -> usize\n    where I: IntoIterator<Item = &'a mut A>,\n          I::IntoIter: DoubleEndedIterator,\n          F: FnMut(&A) -> bool\n{\n    let mut split_index = 0;\n    let mut iter = iter.into_iter();\n    'main: while let Some(front) = iter.next() {\n        if !pred(front) {\n            loop {\n                match iter.next_back() {\n                    Some(back) => if pred(back) {\n                        std::mem::swap(front, back);\n                        break;\n                    },\n                    None => break 'main,\n                }\n            }\n        }\n        split_index += 1;\n    }\n    split_index\n}\n\n/// An enum used for controlling the execution of `.fold_while()`.\n///\n/// See [`.fold_while()`](trait.Itertools.html#method.fold_while) for more information.\n#[derive(Copy, Clone, Debug, Eq, PartialEq)]\npub enum FoldWhile<T> {\n    /// Continue folding with this value\n    Continue(T),\n    /// Fold is complete and will return this value\n    Done(T),\n}\n\nimpl<T> FoldWhile<T> {\n    /// Return the value in the continue or done.\n    pub fn into_inner(self) -> T {\n        match self {\n            FoldWhile::Continue(x) | FoldWhile::Done(x) => x,\n        }\n    }\n\n    /// Return true if `self` is `Done`, false if it is `Continue`.\n    pub fn is_done(&self) -> bool {\n        match *self {\n            FoldWhile::Continue(_) => false,\n            FoldWhile::Done(_) => true,\n        }\n    }\n}\n","traces":[{"line":355,"address":[4242704,4242608],"length":1,"stats":{"Line":2},"fn_name":"interleave<quick::Iter<i16, quick::Exact>,quick::Iter<i16, quick::Exact>>"},{"line":359,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":373,"address":[5004304,5004235,5004414,5004144],"length":1,"stats":{"Line":5},"fn_name":"interleave_shortest<alloc::vec::IntoIter<i32>,core::iter::sources::Repeat<i32>>"},{"line":377,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":392,"address":[4212192],"length":1,"stats":{"Line":5},"fn_name":"intersperse<core::ops::range::Range<i32>>"},{"line":396,"address":[4212211],"length":1,"stats":{"Line":5},"fn_name":null},{"line":426,"address":[4238439,4238304],"length":1,"stats":{"Line":8},"fn_name":"zip_longest<itertools::adaptors::Batching<core::slice::Iter<core::option::Option<i32>>, closure-0>,core::iter::adapters::Cloned<core::slice::Iter<i32>>>"},{"line":430,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[4210256],"length":1,"stats":{"Line":2},"fn_name":"batching<core::slice::Iter<core::option::Option<i32>>,i32,closure-0>"},{"line":473,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":511,"address":[4559216,4559168,4559264,4559312,4559056,4559104],"length":1,"stats":{"Line":18},"fn_name":"group_by<core::slice::Iter<i32>,&i32,closure-0>"},{"line":516,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":547,"address":[4558528,4558464],"length":1,"stats":{"Line":2},"fn_name":"chunks<core::slice::Iter<i32>>"},{"line":550,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":585,"address":[4211104,4211200,4211248,4211152],"length":1,"stats":{"Line":8},"fn_name":"tuple_windows<core::iter::adapters::Cloned<core::slice::Iter<i32>>,(i32, i32)>"},{"line":590,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[4211344,4211296,4211440,4211392],"length":1,"stats":{"Line":8},"fn_name":"tuples<core::iter::adapters::Cloned<core::slice::Iter<i32>>,(i32, i32, i32, i32)>"},{"line":662,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":683,"address":[4414592],"length":1,"stats":{"Line":3},"fn_name":"tee<core::iter::adapters::Cloned<core::slice::Iter<i32>>>"},{"line":687,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":708,"address":[4310560],"length":1,"stats":{"Line":7},"fn_name":"step<core::ops::range::Range<i32>>"},{"line":711,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":743,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":760,"address":[4321456],"length":1,"stats":{"Line":3},"fn_name":"merge<itertools::adaptors::Step<core::ops::range::Range<i32>>,itertools::adaptors::Step<core::ops::range::Range<i32>>>"},{"line":765,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":784,"address":[4559510,4559360],"length":1,"stats":{"Line":2},"fn_name":"merge_by<core::slice::Iter<(u32, &str)>,core::slice::Iter<(u32, &str)>,closure-0>"},{"line":789,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":824,"address":[4302272],"length":1,"stats":{"Line":1},"fn_name":"merge_join_by<alloc::vec::IntoIter<usize>,alloc::vec::IntoIter<usize>,fn(&usize, &usize) -> core::cmp::Ordering>"},{"line":829,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":849,"address":[4414832,4415024,4414976,4414928,4414880],"length":1,"stats":{"Line":5},"fn_name":"kmerge<core::iter::adapters::Map<core::ops::range::Range<i32>, closure-0>>"},{"line":854,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":878,"address":[4751520,4751600,4751440],"length":1,"stats":{"Line":3},"fn_name":"kmerge_by<alloc::vec::IntoIter<alloc::vec::Vec<i16>>,closure-0>"},{"line":885,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":899,"address":[4300689,4300560],"length":1,"stats":{"Line":8},"fn_name":"cartesian_product<core::str::Chars,core::ops::range::Range<i32>>"},{"line":905,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":934,"address":[4244288],"length":1,"stats":{"Line":1},"fn_name":"multi_cartesian_product<quick::ShiftRange<quick::Inexact>>"},{"line":940,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":976,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":993,"address":[4558416],"length":1,"stats":{"Line":4},"fn_name":"dedup<core::slice::Iter<i32>>"},{"line":997,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1015,"address":[4558912,4559008,4558960],"length":1,"stats":{"Line":5},"fn_name":"dedup_by<core::slice::Iter<(i32, i32)>,closure-2>"},{"line":1019,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1037,"address":[4556992],"length":1,"stats":{"Line":1},"fn_name":"dedup_with_count<core::slice::Iter<i32>>"},{"line":1040,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1059,"address":[4557040,4557088],"length":1,"stats":{"Line":2},"fn_name":"dedup_by_with_count<core::slice::Iter<(i32, i32)>,closure-1>"},{"line":1063,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1085,"address":[4415104],"length":1,"stats":{"Line":4},"fn_name":"unique<core::iter::adapters::Rev<core::slice::Iter<i32>>>"},{"line":1089,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1111,"address":[4415424],"length":1,"stats":{"Line":3},"fn_name":"unique_by<core::iter::adapters::Rev<core::slice::Iter<&str>>,alloc::string::String,closure-1>"},{"line":1116,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1131,"address":[4220208,4220272,4220240],"length":1,"stats":{"Line":9},"fn_name":"peeking_take_while<core::iter::adapters::Peekable<core::ops::range::Range<i32>>,closure-0>"},{"line":1135,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1156,"address":[6147184],"length":1,"stats":{"Line":1},"fn_name":"take_while_ref<core::slice::Iter<u8>,closure-0>"},{"line":1160,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1177,"address":[4414080],"length":1,"stats":{"Line":2},"fn_name":"while_some<core::iter::adapters::Map<core::ops::range::Range<i32>, closure-0>,i32>"},{"line":1180,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1216,"address":[4728528],"length":1,"stats":{"Line":3},"fn_name":"tuple_combinations<core::ops::range::Range<i32>,(i32, i32)>"},{"line":1221,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1254,"address":[4218128],"length":1,"stats":{"Line":3},"fn_name":"combinations<adaptors_no_collect::PanickingCounter>"},{"line":1258,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1281,"address":[4218256],"length":1,"stats":{"Line":2},"fn_name":"combinations_with_replacement<adaptors_no_collect::PanickingCounter>"},{"line":1286,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1327,"address":[4218192],"length":1,"stats":{"Line":5},"fn_name":"permutations<adaptors_no_collect::PanickingCounter>"},{"line":1331,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1351,"address":[4728704],"length":1,"stats":{"Line":6},"fn_name":"pad_using<core::ops::range::Range<i32>,closure-0>"},{"line":1355,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1377,"address":[4243840],"length":1,"stats":{"Line":2},"fn_name":"with_position<quick::Iter<u8, quick::Exact>>"},{"line":1380,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1434,"address":[4246544],"length":1,"stats":{"Line":3},"fn_name":"next_tuple<core::slice::Iter<i32>,(&i32, &i32)>"},{"line":1438,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1459,"address":[4210768,4210825],"length":1,"stats":{"Line":2},"fn_name":"collect_tuple<core::iter::adapters::Cloned<core::slice::Iter<i32>>,(i32, i32)>"},{"line":1463,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":1464,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1465,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1466,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1468,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1483,"address":[4740592,4740669],"length":1,"stats":{"Line":1},"fn_name":"find_position<Iterator,closure-1>"},{"line":1486,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1487,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1488,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1489,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1491,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1493,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1512,"address":[4359600,4359635],"length":1,"stats":{"Line":2},"fn_name":"all_equal<itertools::groupbylazy::Group<char, core::str::Chars, closure-0>>"},{"line":1516,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1517,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1518,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1537,"address":[4221344,4221373],"length":1,"stats":{"Line":2},"fn_name":"dropping<core::slice::Iter<i32>>"},{"line":1540,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1541,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1543,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1565,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1566,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1568,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1589,"address":[4221296],"length":1,"stats":{"Line":2},"fn_name":"foreach<core::slice::Iter<i32>,closure-0>"},{"line":1593,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1609,"address":[5004960,5004880],"length":1,"stats":{"Line":2},"fn_name":"concat<alloc::vec::IntoIter<alloc::vec::Vec<i32>>>"},{"line":1613,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1619,"address":[4414128],"length":1,"stats":{"Line":9},"fn_name":"collect_vec<core::iter::adapters::Map<itertools::groupbylazy::Groups<char, core::str::Chars, closure-3>, closure-4>>"},{"line":1622,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1651,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1670,"address":[4222138,4222064,4221572,4221504],"length":1,"stats":{"Line":2},"fn_name":"set_from<core::slice::IterMut<i32>,i32,core::ops::range::Range<i32>>"},{"line":1674,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1675,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1676,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1677,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1678,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1680,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1682,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1696,"address":[4557136,4557224],"length":1,"stats":{"Line":1},"fn_name":"join<core::slice::Iter<i32>>"},{"line":1699,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1700,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1701,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1703,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1704,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1705,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1706,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1707,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1708,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1710,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1730,"address":[4558736,4558656],"length":1,"stats":{"Line":2},"fn_name":"format<core::slice::Iter<i32>>"},{"line":1733,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1772,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1821,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1822,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1823,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1824,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1827,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1853,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1854,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1855,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1856,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1859,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1874,"address":[4310624,4310676],"length":1,"stats":{"Line":7},"fn_name":"fold1<core::ops::range::Range<i32>,closure-1>"},{"line":1878,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":1929,"address":[4310382,4310368],"length":1,"stats":{"Line":3},"fn_name":"tree_fold1<core::ops::range::Range<i32>,closure-0>"},{"line":1933,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1935,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1936,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1937,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1938,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1944,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1945,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1946,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1947,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1948,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1949,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1950,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1953,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1954,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1955,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1956,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1958,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":1959,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1962,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1963,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1964,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1966,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1968,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1969,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1975,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1976,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1979,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1982,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1983,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1984,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2028,"address":[5003712,5003771],"length":1,"stats":{"Line":1},"fn_name":"fold_while<alloc::vec::IntoIter<i32>,i32,closure-0>"},{"line":2032,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2033,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":2034,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2035,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2036,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2039,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2063,"address":[4260860,4260816],"length":1,"stats":{"Line":1},"fn_name":"sum1<core::iter::adapters::Cloned<core::slice::Iter<i32>>,i32>"},{"line":2067,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2068,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":2091,"address":[4261084,4261040],"length":1,"stats":{"Line":1},"fn_name":"product1<core::iter::adapters::Cloned<core::slice::Iter<i32>>,i32>"},{"line":2095,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2096,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":2124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2153,"address":[4415152,4415248],"length":1,"stats":{"Line":2},"fn_name":"sorted_by<core::iter::adapters::Cloned<core::slice::Iter<i32>>,closure-0>"},{"line":2157,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2158,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":2159,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2186,"address":[4414416,4414320],"length":1,"stats":{"Line":2},"fn_name":"sorted_by_key<core::iter::adapters::Cloned<core::slice::Iter<i32>>,i32,closure-0>"},{"line":2191,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2192,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":2193,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2249,"address":[5128480],"length":1,"stats":{"Line":1},"fn_name":"into_group_map<core::iter::adapters::Map<alloc::vec::IntoIter<u8>, closure-0>,u8,u8>"},{"line":2253,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2291,"address":[4527104,4527152],"length":1,"stats":{"Line":5},"fn_name":"minmax<core::option::Iter<core::option::Option<u32>>>"},{"line":2294,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":2308,"address":[4556944],"length":1,"stats":{"Line":1},"fn_name":"minmax_by_key<core::slice::Iter<test_std::minmax::Val>,u32,closure-0>"},{"line":2311,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":2322,"address":[4559637,4559584],"length":1,"stats":{"Line":1},"fn_name":"minmax_by<core::slice::Iter<test_std::minmax::Val>,closure-1>"},{"line":2325,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2326,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2327,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2328,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":2354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2439,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2465,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2466,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2493,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2494,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2495,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2545,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2546,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2547,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2548,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2549,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2591,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2592,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2593,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2594,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2595,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2634,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2635,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2636,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2637,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2638,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2659,"address":[4259739,4257696,4256811,4259648,4257787,4256720,4258672,4258763],"length":1,"stats":{"Line":5},"fn_name":"exactly_one<core::iter::adapters::Filter<core::ops::range::Range<i32>, closure-3>>"},{"line":2663,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":2664,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":2665,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":2666,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":2667,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":2669,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2670,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2674,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":2697,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2714,"address":[4512400,4512555,4510367,4498592,4517664,4506064,4520869,4503942,4496671,4501776,4509120,4510224,4501934,4500903,4503824,4504864,4509260,4513520,4513669,4498729,4502921,4505037,4516656,4516817,4519712,4521744,4508080,4496528,4519853,4500720,4518865,4499632,4507209,4506201,4514576,4508217,4497568,4507072,4515616,4521937,4515753,4497709,4499813,4502784,4511388,4518704,4511248,4520720,4517825,4514713],"length":1,"stats":{"Line":25},"fn_name":"equal<core::iter::adapters::Map<core::iter::adapters::Filter<core::slice::Chunks<u8>, closure-0>, closure-1>,itertools::tuple_impl::Tuples<core::slice::Iter<u8>, (&u8, &u8, &u8)>>"},{"line":2719,"address":[4500732,4504871,4513527,4517671,4518711,4520727,4509127,4503841,4511255,4515623,4497580,4510231,4514583,4508087,4506071,4501783,4512407,4502791,4516663,4496535,4519724,4499649,4507079,4498599,4521761],"length":1,"stats":{"Line":25},"fn_name":null},{"line":2720,"address":[4504978,4503962,4499733,4507153,4511329,4508161,4515697,4518785,4501866,4509201,4503907,4496609,4516737,4502865,4506145,4514657,4517745,4500811,4498673,4519803,4497659,4510305,4512484,4520801,4521845,4513601],"length":1,"stats":{"Line":26},"fn_name":null},{"line":2721,"address":[4503663,4505907,4500565,4501625,4512238,4516495,4517840,4520884,4513369,4496686,4515768,4513684,4515455,4520571,4518545,4517505,4519553,4502936,4498431,4516832,4501949,4502622,4497724,4503980,4505052,4500918,4508965,4512570,4514728,4506216,4508232,4514419,4521952,4504711,4498744,4522689,4511403,4518880,4509275,4519868,4510074,4507224,4497421,4507927,4506919,4521589,4510382,4499828,4499471,4511087],"length":1,"stats":{"Line":50},"fn_name":null},{"line":2722,"address":[4501014,4502058,4504021,4507255,4499934,4510467,4499873,4500925,4512582,4515901,4516941,4508334,4499835,4515828,4508273,4506228,4507236,4498804,4517852,4519960,4500953,4498877,4514788,4522058,4504086,4505195,4512606,4512690,4518989,4497759,4503069,4505111,4516844,4519899,4513704,4520904,4514745,4496725,4505074,4506247,4501985,4502996,4518892,4496781,4497820,4515785,4520913,4510402,4510411,4509287,4511452,4501961,4513723,4516868,4509311,4518916,4517883,4521997,4513779,4519880,4511415,4504002,4520969,4517952,4498761,4496706,4506308,4509395,4511536,4521959,4497731,4507316,4508244,4514861,4502953],"length":1,"stats":{"Line":50},"fn_name":null},{"line":2723,"address":[4496891,4499889,4510577,4502060,4513889,4515903,4503025,4521079,4509340,4512833,4505338,4497775,4517954,4522162,4504194,4500038,4499936,4506412,4514817,4519915,4505197,4511481,4511679,4506263,4511538,4518945,4517909,4508289,4502174,4506310,4497822,4509397,4518991,4507420,4519105,4510469,4502014,4520064,4520921,4518061,4520971,4500969,4507271,4496733,4505140,4522060,4515857,4513731,4516897,4516943,4508438,4497924,4504037,4498833,4507318,4498879,4504088,4509538,4512692,4514863,4519962,4516017,4501118,4501016,4514977,4496783,4517057,4503185,4508336,4513781,4522013,4512635,4498993,4510419,4503071],"length":1,"stats":{"Line":50},"fn_name":null},{"line":2724,"address":[4522122,4517023,4496893,4509540,4517141,4501120,4502176,4512945,4515983,4516019,4503269,4521039,4512791,4506372,4511637,4520066,4505340,4499998,4502258,4522258,4519107,4518147,4498020,4519071,4515061,4513849,4520024,4509496,4501078,4498995,4497003,4503151,4504154,4508534,4500134,4508398,4507380,4503187,4522164,4498959,4509650,4517059,4514001,4518026,4511791,4510579,4500040,4521191,4511681,4514943,4507516,4497926,4497884,4514979,4510689,4504290,4516101,4520160,4521081,4510537,4518063,4512835,4501214,4519189,4506414,4505450,4502140,4504196,4505296,4506508,4499077,4508440,4496851,4513891,4507422],"length":1,"stats":{"Line":50},"fn_name":null},{"line":2725,"address":[4520054,4497914,4511669,4507410,4508428,4514967,4504184,4516007,4503175,4501108,4509528,4519095,4512823,4506402,4498983,4518051,4496881,4521069,4505328,4502164,4510567,4517047,4522152,4500028,4513879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2727,"address":[4506293,4509375,4511516,4517934,4516921,4504062,4502351,4505175,4503049,4513769,4512670,4514841,4506625,4515881,4514121,4516204,4496771,4497123,4519282,4507301,4505577,4520277,4501331,4497805,4503372,4499919,4509767,4510457,4521311,4522043,4500999,4499180,4500251,4518247,4519945,4522375,4502038,4498137,4507633,4508319,4511908,4513062,4504417,4515164,4517234,4518969,4508651,4510809,4498857,4520959],"length":1,"stats":{"Line":50},"fn_name":null},{"line":2742,"address":[4225456,4225601],"length":1,"stats":{"Line":49},"fn_name":"assert_equal<itertools::zip_longest::ZipLongest<itertools::adaptors::Batching<core::slice::Iter<core::option::Option<i32>>, closure-0>, core::iter::adapters::Cloned<core::slice::Iter<i32>>>,alloc::vec::Vec<itertools::either_or_both::EitherOrBoth<i32, i32>>>"},{"line":2748,"address":[4225463],"length":1,"stats":{"Line":49},"fn_name":null},{"line":2749,"address":[4225542],"length":1,"stats":{"Line":69},"fn_name":null},{"line":2750,"address":[4225616],"length":1,"stats":{"Line":49},"fn_name":null},{"line":2751,"address":[4225627,4226563],"length":1,"stats":{"Line":99},"fn_name":null},{"line":2752,"address":[4225647,4225786,4225685],"length":1,"stats":{"Line":99},"fn_name":null},{"line":2753,"address":[4225756,4225797],"length":1,"stats":{"Line":100},"fn_name":null},{"line":2754,"address":[4225856],"length":1,"stats":{"Line":50},"fn_name":null},{"line":2755,"address":[4225916,4226100,4226048],"length":1,"stats":{"Line":100},"fn_name":null},{"line":2756,"address":[4225948,4226054],"length":1,"stats":{"Line":100},"fn_name":null},{"line":2757,"address":[4226040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2759,"address":[4226109],"length":1,"stats":{"Line":50},"fn_name":null},{"line":2760,"address":[4226200,4226342,4226290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2761,"address":[4226122,4226735,4226554,4226705],"length":1,"stats":{"Line":100},"fn_name":null},{"line":2784,"address":[4331553,4332049,4331984,4332480,4332545,4331488],"length":1,"stats":{"Line":4},"fn_name":"partition<i32,&mut [i32; 7],closure-0>"},{"line":2789,"address":[4331500,4332492,4331996],"length":1,"stats":{"Line":4},"fn_name":null},{"line":2790,"address":[4332501,4331509,4332005],"length":1,"stats":{"Line":4},"fn_name":null},{"line":2791,"address":[4331877,4332590,4331551,4332071,4332567,4331575,4331598,4332047,4332094,4332373,4332543,4332869],"length":1,"stats":{"Line":16},"fn_name":null},{"line":2792,"address":[4331831,4332134,4332630,4332327,4332823,4331638],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2793,"address":[4331809,4332305,4332801],"length":1,"stats":{"Line":3},"fn_name":null},{"line":2794,"address":[4331689,4332237,4331741,4332681,4332733,4332185],"length":1,"stats":{"Line":4},"fn_name":null},{"line":2795,"address":[4332210,4332735,4332706,4331743,4332239,4331714],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2796,"address":[4332307,4332803,4331811],"length":1,"stats":{"Line":4},"fn_name":null},{"line":2799,"address":[4332731,4331739,4332235],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2803,"address":[4331845,4332341,4332433,4332837,4332929,4331937],"length":1,"stats":{"Line":4},"fn_name":null},{"line":2805,"address":[4332825,4331833,4332329],"length":1,"stats":{"Line":4},"fn_name":null},{"line":2821,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2822,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2823,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":2828,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2829,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2830,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2831,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":212,"coverable":298},{"path":["/","home","kms","itertools","src","merge_join.rs"],"content":"use std::cmp::Ordering;\nuse std::iter::Fuse;\nuse std::fmt;\n\nuse super::adaptors::{PutBack, put_back};\nuse crate::either_or_both::EitherOrBoth;\n\n/// Return an iterator adaptor that merge-joins items from the two base iterators in ascending order.\n///\n/// See [`.merge_join_by()`](trait.Itertools.html#method.merge_join_by) for more information.\npub fn merge_join_by<I, J, F>(left: I, right: J, cmp_fn: F)\n    -> MergeJoinBy<I::IntoIter, J::IntoIter, F>\n    where I: IntoIterator,\n          J: IntoIterator,\n          F: FnMut(&I::Item, &J::Item) -> Ordering\n{\n    MergeJoinBy {\n        left: put_back(left.into_iter().fuse()),\n        right: put_back(right.into_iter().fuse()),\n        cmp_fn,\n    }\n}\n\n/// An iterator adaptor that merge-joins items from the two base iterators in ascending order.\n///\n/// See [`.merge_join_by()`](../trait.Itertools.html#method.merge_join_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MergeJoinBy<I: Iterator, J: Iterator, F> {\n    left: PutBack<Fuse<I>>,\n    right: PutBack<Fuse<J>>,\n    cmp_fn: F\n}\n\nimpl<I, J, F> Clone for MergeJoinBy<I, J, F>\n    where I: Iterator,\n          J: Iterator,\n          PutBack<Fuse<I>>: Clone,\n          PutBack<Fuse<J>>: Clone,\n          F: Clone,\n{\n    clone_fields!(left, right, cmp_fn);\n}\n\nimpl<I, J, F> fmt::Debug for MergeJoinBy<I, J, F>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n          J: Iterator + fmt::Debug,\n          J::Item: fmt::Debug,\n{\n    debug_fmt_fields!(MergeJoinBy, left, right);\n}\n\nimpl<I, J, F> Iterator for MergeJoinBy<I, J, F>\n    where I: Iterator,\n          J: Iterator,\n          F: FnMut(&I::Item, &J::Item) -> Ordering\n{\n    type Item = EitherOrBoth<I::Item, J::Item>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match (self.left.next(), self.right.next()) {\n            (None, None) => None,\n            (Some(left), None) =>\n                Some(EitherOrBoth::Left(left)),\n            (None, Some(right)) =>\n                Some(EitherOrBoth::Right(right)),\n            (Some(left), Some(right)) => {\n                match (self.cmp_fn)(&left, &right) {\n                    Ordering::Equal =>\n                        Some(EitherOrBoth::Both(left, right)),\n                    Ordering::Less => {\n                        self.right.put_back(right);\n                        Some(EitherOrBoth::Left(left))\n                    },\n                    Ordering::Greater => {\n                        self.left.put_back(left);\n                        Some(EitherOrBoth::Right(right))\n                    }\n                }\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (a_lower, a_upper) = self.left.size_hint();\n        let (b_lower, b_upper) = self.right.size_hint();\n\n        let lower = ::std::cmp::max(a_lower, b_lower);\n\n        let upper = match (a_upper, b_upper) {\n            (Some(x), Some(y)) => x.checked_add(y),\n            _ => None,\n        };\n\n        (lower, upper)\n    }\n\n    fn count(mut self) -> usize {\n        let mut count = 0;\n        loop {\n            match (self.left.next(), self.right.next()) {\n                (None, None) => break count,\n                (Some(_left), None) => break count + 1 + self.left.into_parts().1.count(),\n                (None, Some(_right)) => break count + 1 + self.right.into_parts().1.count(),\n                (Some(left), Some(right)) => {\n                    count += 1;\n                    match (self.cmp_fn)(&left, &right) {\n                        Ordering::Equal => {}\n                        Ordering::Less => self.right.put_back(right),\n                        Ordering::Greater => self.left.put_back(left),\n                    }\n                }\n            }\n        }\n    }\n\n    fn last(mut self) -> Option<Self::Item> {\n        let mut previous_element = None;\n        loop {\n            match (self.left.next(), self.right.next()) {\n                (None, None) => break previous_element,\n                (Some(left), None) => {\n                    break Some(EitherOrBoth::Left(\n                        self.left.into_parts().1.last().unwrap_or(left),\n                    ))\n                }\n                (None, Some(right)) => {\n                    break Some(EitherOrBoth::Right(\n                        self.right.into_parts().1.last().unwrap_or(right),\n                    ))\n                }\n                (Some(left), Some(right)) => {\n                    previous_element = match (self.cmp_fn)(&left, &right) {\n                        Ordering::Equal => Some(EitherOrBoth::Both(left, right)),\n                        Ordering::Less => {\n                            self.right.put_back(right);\n                            Some(EitherOrBoth::Left(left))\n                        }\n                        Ordering::Greater => {\n                            self.left.put_back(left);\n                            Some(EitherOrBoth::Right(right))\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n        loop {\n            if n == 0 {\n                break self.next();\n            }\n            n -= 1;\n            match (self.left.next(), self.right.next()) {\n                (None, None) => break None,\n                (Some(_left), None) => break self.left.nth(n).map(EitherOrBoth::Left),\n                (None, Some(_right)) => break self.right.nth(n).map(EitherOrBoth::Right),\n                (Some(left), Some(right)) => match (self.cmp_fn)(&left, &right) {\n                    Ordering::Equal => {}\n                    Ordering::Less => self.right.put_back(right),\n                    Ordering::Greater => self.left.put_back(left),\n                },\n            }\n        }\n    }\n}\n","traces":[{"line":11,"address":[4252256,4253552,4253662,4253984,4252366,4252798,4254526,4253230,4252688,4254094,4254848,4254958,4253120,4254416],"length":1,"stats":{"Line":8},"fn_name":"merge_join_by<alloc::vec::Vec<u32>,alloc::vec::Vec<u32>,closure-0>"},{"line":18,"address":[4252266,4253273,4252409,4254137,4254426,4254858,4253562,4253130,4252841,4253705,4253994,4254569,4252698,4255001],"length":1,"stats":{"Line":16},"fn_name":null},{"line":19,"address":[4253280,4252503,4252848,4254144,4254663,4255095,4254231,4253799,4255008,4252416,4253367,4253712,4252935,4254576],"length":1,"stats":{"Line":16},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":51,"coverable":74},{"path":["/","home","kms","itertools","src","minmax.rs"],"content":"\n/// `MinMaxResult` is an enum returned by `minmax`. See `Itertools::minmax()` for\n/// more detail.\n#[derive(Copy, Clone, PartialEq, Debug)]\npub enum MinMaxResult<T> {\n    /// Empty iterator\n    NoElements,\n\n    /// Iterator with one element, so the minimum and maximum are the same\n    OneElement(T),\n\n    /// More than one element in the iterator, the first element is not larger\n    /// than the second\n    MinMax(T, T)\n}\n\nimpl<T: Clone> MinMaxResult<T> {\n    /// `into_option` creates an `Option` of type `(T, T)`. The returned `Option`\n    /// has variant `None` if and only if the `MinMaxResult` has variant\n    /// `NoElements`. Otherwise `Some((x, y))` is returned where `x <= y`.\n    /// If the `MinMaxResult` has variant `OneElement(x)`, performing this\n    /// operation will make one clone of `x`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::MinMaxResult::{self, NoElements, OneElement, MinMax};\n    ///\n    /// let r: MinMaxResult<i32> = NoElements;\n    /// assert_eq!(r.into_option(), None);\n    ///\n    /// let r = OneElement(1);\n    /// assert_eq!(r.into_option(), Some((1, 1)));\n    ///\n    /// let r = MinMax(1, 2);\n    /// assert_eq!(r.into_option(), Some((1, 2)));\n    /// ```\n    pub fn into_option(self) -> Option<(T,T)> {\n        match self {\n            MinMaxResult::NoElements => None,\n            MinMaxResult::OneElement(x) => Some((x.clone(), x)),\n            MinMaxResult::MinMax(x, y) => Some((x, y))\n        }\n    }\n}\n\n/// Implementation guts for `minmax` and `minmax_by_key`.\npub fn minmax_impl<I, K, F, L>(mut it: I, mut key_for: F,\n                               mut lt: L) -> MinMaxResult<I::Item>\n    where I: Iterator,\n          F: FnMut(&I::Item) -> K,\n          L: FnMut(&I::Item, &I::Item, &K, &K) -> bool,\n{\n    let (mut min, mut max, mut min_key, mut max_key) = match it.next() {\n        None => return MinMaxResult::NoElements,\n        Some(x) => {\n            match it.next() {\n                None => return MinMaxResult::OneElement(x),\n                Some(y) => {\n                    let xk = key_for(&x);\n                    let yk = key_for(&y);\n                    if !lt(&y, &x, &yk, &xk) {(x, y, xk, yk)} else {(y, x, yk, xk)}\n                }\n            }\n        }\n    };\n\n    loop {\n        // `first` and `second` are the two next elements we want to look\n        // at.  We first compare `first` and `second` (#1). The smaller one\n        // is then compared to current minimum (#2). The larger one is\n        // compared to current maximum (#3). This way we do 3 comparisons\n        // for 2 elements.\n        let first = match it.next() {\n            None => break,\n            Some(x) => x\n        };\n        let second = match it.next() {\n            None => {\n                let first_key = key_for(&first);\n                if lt(&first, &min, &first_key, &min_key) {\n                    min = first;\n                } else if !lt(&first, &max, &first_key, &max_key) {\n                    max = first;\n                }\n                break;\n            }\n            Some(x) => x\n        };\n        let first_key = key_for(&first);\n        let second_key = key_for(&second);\n        if !lt(&second, &first, &second_key, &first_key) {\n            if lt(&first, &min, &first_key, &min_key) {\n                min = first;\n                min_key = first_key;\n            }\n            if !lt(&second, &max, &second_key, &max_key) {\n                max = second;\n                max_key = second_key;\n            }\n        } else {\n            if lt(&second, &min, &second_key, &min_key) {\n                min = second;\n                min_key = second_key;\n            }\n            if !lt(&first, &max, &first_key, &max_key) {\n                max = first;\n                max_key = first_key;\n            }\n        }\n    }\n\n    MinMaxResult::MinMax(min, max)\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[4371392,4381844,4378406,4374969,4378288,4371521,4381712,4385558,4374832,4385440],"length":1,"stats":{"Line":7},"fn_name":"minmax_impl<core::slice::Iter<test_std::minmax::Val>,(),closure-0,closure-1>"},{"line":54,"address":[4381867,4385625,4381914,4381738,4371541,4378306,4374866,4371418,4374989,4378426,4378473,4380937,4385578,4388089,4377504,4375036,4374056,4384536,4371588,4385458],"length":1,"stats":{"Line":19},"fn_name":null},{"line":55,"address":[4385635,4371598,4371557,4381883,4375005,4381924,4375046,4378442,4385594,4378483],"length":1,"stats":{"Line":9},"fn_name":null},{"line":56,"address":[4378545,4375111,4371663,4381989,4385697],"length":1,"stats":{"Line":6},"fn_name":null},{"line":57,"address":[4371703,4382029,4385737,4371753,4382085,4375201,4378585,4378635,4375151,4385787],"length":1,"stats":{"Line":6},"fn_name":null},{"line":58,"address":[4385762,4375176,4375203,4371755,4378610,4382060,4371728,4385789,4378637,4382087],"length":1,"stats":{"Line":9},"fn_name":null},{"line":59,"address":[4371842,4378724,4385876,4375290,4382174],"length":1,"stats":{"Line":5},"fn_name":null},{"line":60,"address":[4371866,4375314,4378748,4382198,4385900],"length":1,"stats":{"Line":5},"fn_name":null},{"line":61,"address":[4378787,4371905,4385939,4382308,4375353,4382258],"length":1,"stats":{"Line":6},"fn_name":null},{"line":62,"address":[4382455,4378944,4382323,4386106,4375520,4378954,4375510,4375397,4372072,4378831,4372062,4382445,4386096,4385983,4371949],"length":1,"stats":{"Line":14},"fn_name":null},{"line":68,"address":[4387947,4377362,4373914,4377614,4388199,4384674,4374166,4384394,4380795,4381047],"length":1,"stats":{"Line":10},"fn_name":null},{"line":74,"address":[4372348,4386382,4375746,4379230,4382737,4379180,4375796,4386332,4382787,4372298],"length":1,"stats":{"Line":5},"fn_name":null},{"line":75,"address":[4372323,4386394,4375808,4372360,4375771,4379205,4382799,4382762,4386357,4379242],"length":1,"stats":{"Line":7},"fn_name":null},{"line":76,"address":[4382808,4386403,4372369,4379251,4375817],"length":1,"stats":{"Line":5},"fn_name":null},{"line":78,"address":[4372466,4379384,4374181,4386536,4381062,4375950,4375914,4382905,4372502,4382941,4379348,4388214,4377629,4386500,4384689],"length":1,"stats":{"Line":10},"fn_name":null},{"line":79,"address":[4375922,4382913,4386508,4372474,4379356],"length":1,"stats":{"Line":5},"fn_name":null},{"line":80,"address":[4379394,4375960,4386546,4372512,4382951],"length":1,"stats":{"Line":5},"fn_name":null},{"line":81,"address":[4372870,4386904,4383005,4384740,4379752,4372551,4381113,4383324,4386701,4376318,4376115,4386585,4374232,4372667,4377680,4379433,4388265,4379549,4383121,4375999],"length":1,"stats":{"Line":17},"fn_name":null},{"line":82,"address":[4374211,4372790,4383244,4376238,4381092,4386824,4388244,4379672,4377659,4384719],"length":1,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[4374258,4376131,4379565,4372683,4386862,4388291,4379710,4381139,4372828,4377706,4376276,4386717,4383282,4384766,4383137],"length":1,"stats":{"Line":12},"fn_name":null},{"line":84,"address":[4384745,4383290,4377685,4386870,4381118,4376284,4374237,4388270,4372836,4379718],"length":1,"stats":{"Line":4},"fn_name":null},{"line":86,"address":[4386940,4376354,4372906,4379788,4383360],"length":1,"stats":{"Line":5},"fn_name":null},{"line":88,"address":[4383369,4386949,4372915,4376363,4379797],"length":1,"stats":{"Line":5},"fn_name":null},{"line":90,"address":[4384792,4374284,4377732,4379889,4388317,4376455,4383465,4373007,4381165,4387041],"length":1,"stats":{"Line":10},"fn_name":null},{"line":91,"address":[4379905,4383488,4387057,4376471,4373023],"length":1,"stats":{"Line":5},"fn_name":null},{"line":92,"address":[4379952,4373070,4377073,4384315,4380716,4377283,4373835,4383550,4373625,4380507,4387104,4387659,4376518,4387868,4384105],"length":1,"stats":{"Line":12},"fn_name":null},{"line":93,"address":[4384946,4374412,4373313,4383793,4381293,4376761,4380195,4387347,4377860,4388445],"length":1,"stats":{"Line":5},"fn_name":null},{"line":94,"address":[4380312,4388416,4377831,4381264,4374383,4384895,4383910,4387464,4376878,4373430],"length":1,"stats":{"Line":4},"fn_name":null},{"line":95,"address":[4388437,4374404,4381285,4384916,4377852],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[4374446,4380354,4376920,4377894,4383952,4387506,4388479,4385002,4381327,4373472],"length":1,"stats":{"Line":5},"fn_name":null},{"line":98,"address":[4384951,4380473,4377039,4384071,4388450,4381298,4373591,4374417,4377865,4387625],"length":1,"stats":{"Line":4},"fn_name":null},{"line":99,"address":[4377886,4374438,4388471,4384972,4381319],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[4383675,4376643,4380077,4388513,4374480,4387668,4384114,4373634,4380516,4377082,4387229,4381361,4373195,4377928,4385058],"length":1,"stats":{"Line":10},"fn_name":null},{"line":103,"address":[4387674,4380522,4384120,4373640,4388484,4374451,4381332,4377088,4377899,4385007],"length":1,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[4385028,4381353,4374472,4377920,4388505],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[4387716,4380564,4384162,4385114,4373682,4377962,4388546,4374514,4377130,4381394],"length":1,"stats":{"Line":8},"fn_name":null},{"line":107,"address":[4384281,4373801,4377249,4387835,4380683,4377933,4374485,4385063,4381366,4388518],"length":1,"stats":{"Line":8},"fn_name":null},{"line":108,"address":[4374506,4385084,4381386,4377954,4388538],"length":1,"stats":{"Line":4},"fn_name":null},{"line":113,"address":[4379112,4372230,4382669,4375678,4386264],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":43,"coverable":44},{"path":["/","home","kms","itertools","src","multipeek_impl.rs"],"content":"use std::iter::Fuse;\nuse std::collections::VecDeque;\nuse crate::size_hint;\nuse crate::PeekingNext;\n\n/// See [`multipeek()`](../fn.multipeek.html) for more information.\n#[derive(Clone, Debug)]\npub struct MultiPeek<I>\n    where I: Iterator\n{\n    iter: Fuse<I>,\n    buf: VecDeque<I::Item>,\n    index: usize,\n}\n\n/// An iterator adaptor that allows the user to peek at multiple `.next()`\n/// values without advancing the base iterator.\npub fn multipeek<I>(iterable: I) -> MultiPeek<I::IntoIter>\n    where I: IntoIterator\n{\n    MultiPeek {\n        iter: iterable.into_iter().fuse(),\n        buf: VecDeque::new(),\n        index: 0,\n    }\n}\n\nimpl<I> MultiPeek<I>\n    where I: Iterator\n{\n    /// Reset the peeking “cursor”\n    pub fn reset_peek(&mut self) {\n        self.index = 0;\n    }\n}\n\nimpl<I: Iterator> MultiPeek<I> {\n    /// Works exactly like `.next()` with the only difference that it doesn't\n    /// advance itself. `.peek()` can be called multiple times, to peek\n    /// further ahead.\n    pub fn peek(&mut self) -> Option<&I::Item> {\n        let ret = if self.index < self.buf.len() {\n            Some(&self.buf[self.index])\n        } else {\n            match self.iter.next() {\n                Some(x) => {\n                    self.buf.push_back(x);\n                    Some(&self.buf[self.index])\n                }\n                None => return None,\n            }\n        };\n\n        self.index += 1;\n        ret\n    }\n}\n\nimpl<I> PeekingNext for MultiPeek<I>\n    where I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool\n    {\n        if self.buf.is_empty() {\n            if let Some(r) = self.peek() {\n                if !accept(r) { return None }\n            }\n        } else {\n            if let Some(r) = self.buf.get(0) {\n                if !accept(r) { return None }\n            }\n        }\n        self.next()\n    }\n}\n\nimpl<I> Iterator for MultiPeek<I>\n    where I: Iterator\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.index = 0;\n        self.buf.pop_front().or_else(|| self.iter.next())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add_scalar(self.iter.size_hint(), self.buf.len())\n    }\n}\n\n// Same size\nimpl<I> ExactSizeIterator for MultiPeek<I>\n    where I: ExactSizeIterator\n{}\n\n\n","traces":[{"line":18,"address":[4428568,4428512,4428304,4428720,4428984,4428360,4428776,4428928],"length":1,"stats":{"Line":5},"fn_name":"multipeek<core::iter::adapters::Cloned<core::slice::Iter<i32>>>"},{"line":22,"address":[4428945,4428529,4428996,4428321,4428580,4428788,4428737,4428372],"length":1,"stats":{"Line":10},"fn_name":null},{"line":23,"address":[4428604,4428812,4429020,4428396],"length":1,"stats":{"Line":5},"fn_name":null},{"line":32,"address":[4427040],"length":1,"stats":{"Line":1},"fn_name":"reset_peek<core::iter::adapters::Cloned<core::slice::Iter<i32>>>"},{"line":33,"address":[4427045],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[4427488,4427122,4427904,4427072,4427538,4427954],"length":1,"stats":{"Line":4},"fn_name":"peek<core::iter::adapters::Map<core::slice::Iter<u8>, closure-1>>"},{"line":42,"address":[4427144,4427431,4427847,4428249,4427212,4427913,4427976,4427628,4427560,4428044,4427497,4427081],"length":1,"stats":{"Line":15},"fn_name":null},{"line":43,"address":[4428001,4427169,4427585],"length":1,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[4427149,4427981,4427660,4427244,4427565,4428072],"length":1,"stats":{"Line":4},"fn_name":null},{"line":46,"address":[4428074,4427246,4428046,4427217,4427633,4427662],"length":1,"stats":{"Line":8},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[4425245,4424813,4424768,4425677,4426064,4425200,4426109,4425632,4423904,4426496,4424336,4424381,4423949,4426541],"length":1,"stats":{"Line":7},"fn_name":"peeking_next<core::iter::adapters::Map<core::slice::Iter<u8>, closure-0>,closure-7>"},{"line":65,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":27,"coverable":27},{"path":["/","home","kms","itertools","src","pad_tail.rs"],"content":"use std::iter::Fuse;\nuse crate::size_hint;\n\n/// An iterator adaptor that pads a sequence to a minimum length by filling\n/// missing elements using a closure.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.pad_using()`](../trait.Itertools.html#method.pad_using) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct PadUsing<I, F> {\n    iter: Fuse<I>,\n    min: usize,\n    pos: usize,\n    filler: F,\n}\n\n/// Create a new **PadUsing** iterator.\npub fn pad_using<I, F>(iter: I, min: usize, filler: F) -> PadUsing<I, F>\n    where I: Iterator,\n          F: FnMut(usize) -> I::Item\n{\n    PadUsing {\n        iter: iter.fuse(),\n        min,\n        pos: 0,\n        filler,\n    }\n}\n\nimpl<I, F> Iterator for PadUsing<I, F>\n    where I: Iterator,\n          F: FnMut(usize) -> I::Item\n{\n    type Item = I::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.iter.next() {\n            None => {\n                if self.pos < self.min {\n                    let e = Some((self.filler)(self.pos));\n                    self.pos += 1;\n                    e\n                } else {\n                    None\n                }\n            },\n            e => {\n                self.pos += 1;\n                e\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let tail = self.min.saturating_sub(self.pos);\n        size_hint::max(self.iter.size_hint(), (tail, Some(tail)))\n    }\n}\n\nimpl<I, F> DoubleEndedIterator for PadUsing<I, F>\n    where I: DoubleEndedIterator + ExactSizeIterator,\n          F: FnMut(usize) -> I::Item\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        if self.min == 0 {\n            self.iter.next_back()\n        } else if self.iter.len() >= self.min {\n            self.min -= 1;\n            self.iter.next_back()\n        } else {\n            self.min -= 1;\n            Some((self.filler)(self.min))\n        }\n    }\n}\n\nimpl<I, F> ExactSizeIterator for PadUsing<I, F>\n    where I: ExactSizeIterator,\n          F: FnMut(usize) -> I::Item\n{}\n","traces":[{"line":20,"address":[4368112,4368370,4367952,4368243,4368083,4368272],"length":1,"stats":{"Line":6},"fn_name":"pad_using<alloc::vec::IntoIter<usize>,closure-1>"},{"line":25,"address":[4368127,4368292,4367967],"length":1,"stats":{"Line":6},"fn_name":null},{"line":39,"address":[5941879,5941840,5941376,5940942,5940896,5941415],"length":1,"stats":{"Line":6},"fn_name":"next<quick::Iter<i8, quick::Exact>,closure-0>"},{"line":40,"address":[4366892,4366396,4366610,4367106,4367595,4367385],"length":1,"stats":{"Line":12},"fn_name":null},{"line":41,"address":[4366440,4366936,4367434],"length":1,"stats":{"Line":6},"fn_name":null},{"line":42,"address":[4366603,4367477,4367591,4367099,4366452,4366948,4366481,4367450,4366977],"length":1,"stats":{"Line":17},"fn_name":null},{"line":43,"address":[4366979,4367479,4366483],"length":1,"stats":{"Line":5},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":47,"address":[5941468,5941932,5940994],"length":1,"stats":{"Line":6},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":51,"address":[5941268,5941621,5942206,5941147,5941742,5942085],"length":1,"stats":{"Line":5},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":16,"coverable":24},{"path":["/","home","kms","itertools","src","peek_nth.rs"],"content":"use crate::size_hint;\nuse crate::PeekingNext;\nuse std::collections::VecDeque;\nuse std::iter::Fuse;\n\n/// See [`peek_nth()`](../fn.peek_nth.html) for more information.\n#[derive(Clone, Debug)]\npub struct PeekNth<I>\nwhere\n    I: Iterator,\n{\n    iter: Fuse<I>,\n    buf: VecDeque<I::Item>,\n}\n\n/// A drop-in replacement for `std::iter::Peekable` which adds a `peek_nth`\n/// method allowing the user to `peek` at a value several iterations forward\n/// without advancing the base iterator.\n///\n/// This differs from `multipeek` in that subsequent calls to `peek` or\n/// `peek_nth` will always return the same value until `next` is called\n/// (making `reset_peek` unnecessary).\npub fn peek_nth<I>(iterable: I) -> PeekNth<I::IntoIter>\nwhere\n    I: IntoIterator,\n{\n    PeekNth {\n        iter: iterable.into_iter().fuse(),\n        buf: VecDeque::new(),\n    }\n}\n\nimpl<I> PeekNth<I>\nwhere\n    I: Iterator,\n{\n    /// Works exactly like the `peek` method in `std::iter::Peekable`\n    pub fn peek(&mut self) -> Option<&I::Item> {\n        self.peek_nth(0)\n    }\n\n    /// Returns a reference to the `nth` value without advancing the iterator.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```rust\n    /// use itertools::peek_nth;\n    ///\n    /// let xs = vec![1,2,3];\n    /// let mut iter = peek_nth(xs.iter());\n    ///\n    /// assert_eq!(iter.peek_nth(0), Some(&&1));\n    /// assert_eq!(iter.next(), Some(&1));\n    ///\n    /// // The iterator does not advance even if we call `peek_nth` multiple times\n    /// assert_eq!(iter.peek_nth(0), Some(&&2));\n    /// assert_eq!(iter.peek_nth(1), Some(&&3));\n    /// assert_eq!(iter.next(), Some(&2));\n    ///\n    /// // Calling `peek_nth` past the end of the iterator will return `None`\n    /// assert_eq!(iter.peek_nth(1), None);\n    /// ```\n    pub fn peek_nth(&mut self, n: usize) -> Option<&I::Item> {\n        let unbuffered_items = (n + 1).saturating_sub(self.buf.len());\n\n        self.buf.extend(self.iter.by_ref().take(unbuffered_items));\n\n        self.buf.get(n)\n    }\n}\n\nimpl<I> Iterator for PeekNth<I>\nwhere\n    I: Iterator,\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.buf.pop_front().or_else(|| self.iter.next())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add_scalar(self.iter.size_hint(), self.buf.len())\n    }\n}\n\nimpl<I> ExactSizeIterator for PeekNth<I> where I: ExactSizeIterator {}\n\nimpl<I> PeekingNext for PeekNth<I>\nwhere\n    I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n    where\n        F: FnOnce(&Self::Item) -> bool,\n    {\n        self.peek().filter(|item| accept(item))?;\n        self.next()\n    }\n}\n","traces":[{"line":23,"address":[4363824,4364016,4364072,4364208,4363880,4364264],"length":1,"stats":{"Line":4},"fn_name":"peek_nth<core::iter::adapters::Map<core::slice::Iter<u8>, closure-0>>"},{"line":28,"address":[4782323,4782262],"length":1,"stats":{"Line":8},"fn_name":null},{"line":29,"address":[4364300,4364108,4363916],"length":1,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[4782016],"length":1,"stats":{"Line":3},"fn_name":"peek_nth<quick::Iter<u16, quick::Exact>>"},{"line":66,"address":[4363788,4363578,4363598,4363818,4363548,4363358],"length":1,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[4363749,4363509],"length":1,"stats":{"Line":3},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[4360836,4360528,4360564,4360800,4361108,4361380,4361616,4361344,4361072,4361652,4361924,4360256,4360292,4361888],"length":1,"stats":{"Line":7},"fn_name":"peeking_next<core::iter::adapters::Map<core::slice::Iter<u8>, closure-0>,closure-5>"},{"line":99,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":5},"fn_name":null}],"covered":16,"coverable":16},{"path":["/","home","kms","itertools","src","peeking_take_while.rs"],"content":"use std::iter::Peekable;\nuse crate::PutBack;\n#[cfg(feature = \"use_std\")]\nuse crate::PutBackN;\n\n/// An iterator that allows peeking at an element before deciding to accept it.\n///\n/// See [`.peeking_take_while()`](trait.Itertools.html#method.peeking_take_while)\n/// for more information.\n///\n/// This is implemented by peeking adaptors like peekable and put back,\n/// but also by a few iterators that can be peeked natively, like the slice’s\n/// by reference iterator (`std::slice::Iter`).\npub trait PeekingNext : Iterator {\n    /// Pass a reference to the next iterator element to the closure `accept`;\n    /// if `accept` returns true, return it as the next element,\n    /// else None.\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool;\n}\n\nimpl<I> PeekingNext for Peekable<I>\n    where I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool\n    {\n        if let Some(r) = self.peek() {\n            if !accept(r) {\n                return None;\n            }\n        }\n        self.next()\n    }\n}\n\nimpl<I> PeekingNext for PutBack<I>\n    where I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool\n    {\n        if let Some(r) = self.next() {\n            if !accept(&r) {\n                self.put_back(r);\n                return None;\n            }\n            Some(r)\n        } else {\n            None\n        }\n    }\n}\n\n#[cfg(feature = \"use_std\")]\nimpl<I> PeekingNext for PutBackN<I>\n    where I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool\n    {\n        if let Some(r) = self.next() {\n            if !accept(&r) {\n                self.put_back(r);\n                return None;\n            }\n            Some(r)\n        } else {\n            None\n        }\n    }\n}\n\n/// An iterator adaptor that takes items while a closure returns `true`.\n///\n/// See [`.peeking_take_while()`](../trait.Itertools.html#method.peeking_take_while)\n/// for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct PeekingTakeWhile<'a, I: 'a, F>\n    where I: Iterator,\n{\n    iter: &'a mut I,\n    f: F,\n}\n\n/// Create a PeekingTakeWhile\npub fn peeking_take_while<I, F>(iter: &mut I, f: F) -> PeekingTakeWhile<I, F>\n    where I: Iterator,\n{\n    PeekingTakeWhile {\n        iter,\n        f,\n    }\n}\n\nimpl<'a, I, F> Iterator for PeekingTakeWhile<'a, I, F>\n    where I: PeekingNext,\n          F: FnMut(&I::Item) -> bool,\n\n{\n    type Item = I::Item;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.peeking_next(&mut self.f)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, hi) = self.iter.size_hint();\n        (0, hi)\n    }\n}\n\n// Some iterators are so lightweight we can simply clone them to save their\n// state and use that for peeking.\nmacro_rules! peeking_next_by_clone {\n    ([$($typarm:tt)*] $type_:ty) => {\n        impl<$($typarm)*> PeekingNext for $type_ {\n            fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n                where F: FnOnce(&Self::Item) -> bool\n            {\n                let saved_state = self.clone();\n                if let Some(r) = self.next() {\n                    if !accept(&r) {\n                        *self = saved_state;\n                    } else {\n                        return Some(r)\n                    }\n                }\n                None\n            }\n        }\n    }\n}\n\npeeking_next_by_clone! { ['a, T] ::std::slice::Iter<'a, T> }\npeeking_next_by_clone! { ['a] ::std::str::Chars<'a> }\npeeking_next_by_clone! { ['a] ::std::str::CharIndices<'a> }\npeeking_next_by_clone! { ['a] ::std::str::Bytes<'a> }\npeeking_next_by_clone! { ['a, T] ::std::option::Iter<'a, T> }\npeeking_next_by_clone! { ['a, T] ::std::result::Iter<'a, T> }\npeeking_next_by_clone! { [T] ::std::iter::Empty<T> }\n#[cfg(feature = \"use_std\")]\npeeking_next_by_clone! { ['a, T] ::std::collections::linked_list::Iter<'a, T> }\n#[cfg(feature = \"use_std\")]\npeeking_next_by_clone! { ['a, T] ::std::collections::vec_deque::Iter<'a, T> }\n\n// cloning a Rev has no extra overhead; peekable and put backs are never DEI.\npeeking_next_by_clone! { [I: Clone + PeekingNext + DoubleEndedIterator]\n                         ::std::iter::Rev<I> }\n","traces":[{"line":25,"address":[4218000,4218041],"length":1,"stats":{"Line":1},"fn_name":"peeking_next<core::ops::range::Range<i32>,&mut closure-0>"},{"line":28,"address":[4218014,4218062,4218144],"length":1,"stats":{"Line":3},"fn_name":null},{"line":29,"address":[4218098],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[4218146],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[4218167],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[4238288,4237926,4238342,4237872],"length":1,"stats":{"Line":2},"fn_name":"peeking_next<core::ops::range::Range<i32>,&mut closure-0>"},{"line":43,"address":[4237979,4238358,4237942,4238302,4237886,4238395],"length":1,"stats":{"Line":5},"fn_name":null},{"line":44,"address":[4238418,4238002],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[4242982,4243398,4243344,4242928],"length":1,"stats":{"Line":2},"fn_name":"peeking_next<core::ops::range::Range<i32>,&mut closure-0>"},{"line":62,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[4217168,4217392,4217232,4217200,4217264,4217296,4217136,4217360,4217328],"length":1,"stats":{"Line":9},"fn_name":"peeking_take_while<itertools::put_back_n_impl::PutBackN<core::ops::range::Range<i32>>,closure-1>"},{"line":102,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[4218768,4219419,4219360,4218827],"length":1,"stats":{"Line":4},"fn_name":"peeking_next<core::slice::Iter<i32>,&mut closure-1>"},{"line":120,"address":[4222462,4222158,4222207,4222511],"length":1,"stats":{"Line":8},"fn_name":null},{"line":121,"address":[4219706,4218864,4219114,4219456],"length":1,"stats":{"Line":6},"fn_name":null},{"line":122,"address":[4219532,4218940],"length":1,"stats":{"Line":4},"fn_name":null},{"line":123,"address":[4219177,4219660,4219769,4219068],"length":1,"stats":{"Line":3},"fn_name":null},{"line":125,"address":[4219028,4219620],"length":1,"stats":{"Line":4},"fn_name":null},{"line":128,"address":[4219811,4219219],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":29,"coverable":32},{"path":["/","home","kms","itertools","src","permutations.rs"],"content":"use std::fmt;\nuse std::iter::once;\n\nuse super::lazy_buffer::LazyBuffer;\n\n/// An iterator adaptor that iterates through all the `k`-permutations of the\n/// elements from an iterator.\n///\n/// See [`.permutations()`](../trait.Itertools.html#method.permutations) for\n/// more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Permutations<I: Iterator> {\n    vals: LazyBuffer<I>,\n    state: PermutationState,\n}\n\nimpl<I> Clone for Permutations<I>\n    where I: Clone + Iterator,\n          I::Item: Clone,\n{\n    clone_fields!(vals, state);\n}\n\n#[derive(Clone, Debug)]\nenum PermutationState {\n    StartUnknownLen {\n        k: usize,\n    },\n    OngoingUnknownLen {\n        k: usize,\n        min_n: usize,\n    },\n    Complete(CompleteState),\n    Empty,\n}\n\n#[derive(Clone, Debug)]\nenum CompleteState {\n    Start {\n        n: usize,\n        k: usize,\n    },\n    Ongoing {\n        indices: Vec<usize>,\n        cycles: Vec<usize>,\n    }\n}\n\nenum CompleteStateRemaining {\n    Known(usize),\n    Overflow,\n}\n\nimpl<I> fmt::Debug for Permutations<I>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(Permutations, vals, state);\n}\n\npub fn permutations<I: Iterator>(iter: I, k: usize) -> Permutations<I> {\n    let mut vals = LazyBuffer::new(iter);\n\n    if k == 0 {\n        // Special case, yields single empty vec; `n` is irrelevant\n        let state = PermutationState::Complete(CompleteState::Start { n: 0, k: 0 });\n\n        return Permutations {\n            vals,\n            state\n        };\n    }\n\n    let mut enough_vals = true;\n\n    while vals.len() < k {\n        if !vals.get_next() {\n            enough_vals = false;\n            break;\n        }\n    }\n\n    let state = if enough_vals {\n        PermutationState::StartUnknownLen { k }\n    } else {\n        PermutationState::Empty\n    };\n\n    Permutations {\n        vals,\n        state\n    }\n}\n\nimpl<I> Iterator for Permutations<I>\nwhere\n    I: Iterator,\n    I::Item: Clone\n{\n    type Item = Vec<I::Item>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.advance();\n\n        let &mut Permutations { ref vals, ref state } = self;\n\n        match state {\n            &PermutationState::StartUnknownLen { .. } => panic!(\"unexpected iterator state\"),\n            &PermutationState::OngoingUnknownLen { k, min_n } => {\n                let latest_idx = min_n - 1;\n                let indices = (0..(k - 1)).chain(once(latest_idx));\n\n                Some(indices.map(|i| vals[i].clone()).collect())\n            }\n            &PermutationState::Complete(CompleteState::Start { .. }) => None,\n            &PermutationState::Complete(CompleteState::Ongoing { ref indices, ref cycles }) => {\n                let k = cycles.len();\n\n                Some(indices[0..k].iter().map(|&i| vals[i].clone()).collect())\n            },\n            &PermutationState::Empty => None\n        }\n    }\n\n    fn count(self) -> usize {\n        let Permutations { vals, state } = self;\n\n        fn from_complete(complete_state: CompleteState) -> usize {\n            match complete_state.remaining() {\n                CompleteStateRemaining::Known(count) => count,\n                CompleteStateRemaining::Overflow => {\n                    panic!(\"Iterator count greater than usize::MAX\");\n                }\n            }\n        }\n\n        match state {\n            PermutationState::StartUnknownLen { k } => {\n                let n = vals.len() + vals.it.count();\n                let complete_state = CompleteState::Start { n, k };\n\n                from_complete(complete_state)\n            }\n            PermutationState::OngoingUnknownLen { k, min_n } => {\n                let prev_iteration_count = min_n - k + 1;\n                let n = vals.len() + vals.it.count();\n                let complete_state = CompleteState::Start { n, k };\n\n                from_complete(complete_state) - prev_iteration_count\n            },\n            PermutationState::Complete(state) => from_complete(state),\n            PermutationState::Empty => 0\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        match self.state {\n            PermutationState::StartUnknownLen { .. } |\n            PermutationState::OngoingUnknownLen { .. } => (0, None), // TODO can we improve this lower bound?\n            PermutationState::Complete(ref state) => match state.remaining() {\n                CompleteStateRemaining::Known(count) => (count, Some(count)),\n                CompleteStateRemaining::Overflow => (::std::usize::MAX, None)\n            }\n            PermutationState::Empty => (0, Some(0))\n        }\n    }\n}\n\nimpl<I> Permutations<I>\nwhere\n    I: Iterator,\n    I::Item: Clone\n{\n    fn advance(&mut self) {\n        let &mut Permutations { ref mut vals, ref mut state } = self;\n\n        *state = match state {\n            &mut PermutationState::StartUnknownLen { k } => {\n                PermutationState::OngoingUnknownLen { k, min_n: k }\n            }\n            &mut PermutationState::OngoingUnknownLen { k, min_n } => {\n                if vals.get_next() {\n                    PermutationState::OngoingUnknownLen { k, min_n: min_n + 1 }\n                } else {\n                    let n = min_n;\n                    let prev_iteration_count = n - k + 1;\n                    let mut complete_state = CompleteState::Start { n, k };\n\n                    // Advance the complete-state iterator to the correct point\n                    for _ in 0..(prev_iteration_count + 1) {\n                        complete_state.advance();\n                    }\n\n                    PermutationState::Complete(complete_state)\n                }\n            }\n            &mut PermutationState::Complete(ref mut state) => {\n                state.advance();\n\n                return;\n            }\n            &mut PermutationState::Empty => { return; }\n        };\n    }\n}\n\nimpl CompleteState {\n    fn advance(&mut self) {\n        *self = match self {\n            &mut CompleteState::Start { n, k } => {\n                let indices = (0..n).collect();\n                let cycles = ((n - k)..n).rev().collect();\n\n                CompleteState::Ongoing {\n                    cycles,\n                    indices\n                }\n            },\n            &mut CompleteState::Ongoing { ref mut indices, ref mut cycles } => {\n                let n = indices.len();\n                let k = cycles.len();\n\n                for i in (0..k).rev() {\n                    if cycles[i] == 0 {\n                        cycles[i] = n - i - 1;\n\n                        let to_push = indices.remove(i);\n                        indices.push(to_push);\n                    } else {\n                        let swap_index = n - cycles[i];\n                        indices.swap(i, swap_index);\n\n                        cycles[i] -= 1;\n                        return;\n                    }\n                }\n\n                CompleteState::Start { n, k }\n            }\n        }\n    }\n\n    fn remaining(&self) -> CompleteStateRemaining {\n        use self::CompleteStateRemaining::{Known, Overflow};\n\n        match self {\n            &CompleteState::Start { n, k } => {\n                if n < k {\n                    return Known(0);\n                }\n\n                let count: Option<usize> = (n - k + 1..n + 1).fold(Some(1), |acc, i| {\n                    acc.and_then(|acc| acc.checked_mul(i))\n                });\n\n                match count {\n                    Some(count) => Known(count),\n                    None => Overflow\n                }\n            }\n            &CompleteState::Ongoing { ref indices, ref cycles } => {\n                let mut count: usize = 0;\n\n                for (i, &c) in cycles.iter().enumerate() {\n                    let radix = indices.len() - i;\n                    let next_count = count.checked_mul(radix)\n                        .and_then(|count| count.checked_add(c));\n\n                    count = match next_count {\n                        Some(count) => count,\n                        None => { return Overflow; }\n                    };\n                }\n\n                Known(count)\n            }\n        }\n    }\n}\n","traces":[{"line":61,"address":[4222050,4221984],"length":1,"stats":{"Line":5},"fn_name":"permutations<adaptors_no_collect::PanickingCounter>"},{"line":62,"address":[4222012],"length":1,"stats":{"Line":5},"fn_name":null},{"line":64,"address":[4222065],"length":1,"stats":{"Line":5},"fn_name":null},{"line":66,"address":[4222089],"length":1,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[4222287],"length":1,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[4222184],"length":1,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[4222232],"length":1,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[4222076],"length":1,"stats":{"Line":4},"fn_name":null},{"line":76,"address":[4222084,4222376,4222432],"length":1,"stats":{"Line":12},"fn_name":null},{"line":77,"address":[4222411],"length":1,"stats":{"Line":4},"fn_name":null},{"line":78,"address":[4222434],"length":1,"stats":{"Line":3},"fn_name":null},{"line":83,"address":[4222464,4222442],"length":1,"stats":{"Line":7},"fn_name":null},{"line":86,"address":[4222452],"length":1,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[4542368,4542398],"length":1,"stats":{"Line":1},"fn_name":"from_complete"},{"line":129,"address":[4542415,4542372,4542487],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[4542489,4542430],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[4542457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[5320124,5320460],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[4542582,4542544],"length":1,"stats":{"Line":2},"fn_name":"advance"},{"line":209,"address":[4543832,4543060,4543359,4542597],"length":1,"stats":{"Line":6},"fn_name":null},{"line":210,"address":[4542599,4542559],"length":1,"stats":{"Line":4},"fn_name":null},{"line":211,"address":[4542639],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[4544042,4542697,4542824],"length":1,"stats":{"Line":4},"fn_name":null},{"line":214,"address":[4542952],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[4542856],"length":1,"stats":{"Line":2},"fn_name":null},{"line":216,"address":[4542904],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[4543065],"length":1,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[4543109],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[4543131],"length":1,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[4543364,4543650,4543153],"length":1,"stats":{"Line":3},"fn_name":null},{"line":224,"address":[4543414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[4543922,4543497],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[4543598],"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[4543628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[4543665,4543982,4543452],"length":1,"stats":{"Line":2},"fn_name":null},{"line":231,"address":[4543698],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[4543754,4544012],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[4543315],"length":1,"stats":{"Line":2},"fn_name":null},{"line":243,"address":[4544128],"length":1,"stats":{"Line":1},"fn_name":"remaining"},{"line":246,"address":[4544160,4544508],"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[4544140,4544162],"length":1,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[4544193],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[4544240],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[4542048],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":253,"address":[4542072,4541984,4541998],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":256,"address":[4544466],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[4544440,4544470],"length":1,"stats":{"Line":2},"fn_name":null},{"line":258,"address":[4544457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[4544513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[4544551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[4544792,4544563,4545110],"length":1,"stats":{"Line":2},"fn_name":null},{"line":265,"address":[4544893,4545115],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[4544955,4545002],"length":1,"stats":{"Line":2},"fn_name":null},{"line":267,"address":[4542128,4542142],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":269,"address":[4545076,4545102],"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[4545078,4545045],"length":1,"stats":{"Line":2},"fn_name":null},{"line":271,"address":[4545062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[4544765],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":104,"coverable":113},{"path":["/","home","kms","itertools","src","process_results_impl.rs"],"content":"\n/// An iterator that produces only the `T` values as long as the\n/// inner iterator produces `Ok(T)`.\n///\n/// Used by [`process_results`](../fn.process_results.html), see its docs\n/// for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Debug)]\npub struct ProcessResults<'a, I, E: 'a> {\n    error: &'a mut Result<(), E>,\n    iter: I,\n}\n\nimpl<'a, I, T, E> Iterator for ProcessResults<'a, I, E>\n    where I: Iterator<Item = Result<T, E>>\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.iter.next() {\n            Some(Ok(x)) => Some(x),\n            Some(Err(e)) => {\n                *self.error = Err(e);\n                None\n            }\n            None => None,\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, hi) = self.iter.size_hint();\n        (0, hi)\n    }\n}\n\n/// “Lift” a function of the values of an iterator so that it can process\n/// an iterator of `Result` values instead.\n///\n/// `iterable` is an iterator or iterable with `Result<T, E>` elements, where\n/// `T` is the value type and `E` the error type.\n///\n/// `processor` is a closure that receives an adapted version of the iterable\n/// as the only argument — the adapted iterator produces elements of type `T`,\n/// as long as the original iterator produces `Ok` values.\n///\n/// If the original iterable produces an error at any point, the adapted\n/// iterator ends and the `process_results` function will return the\n/// error iself.\n///\n/// Otherwise, the return value from the closure is returned wrapped\n/// inside `Ok`.\n///\n/// # Example\n///\n/// ```\n/// use itertools::process_results;\n///\n/// type R = Result<i32, &'static str>;\n///\n/// let first_values: Vec<R> = vec![Ok(1), Ok(0), Ok(3)];\n/// let second_values: Vec<R> = vec![Ok(2), Ok(1), Err(\"overflow\")];\n///\n/// // “Lift” the iterator .max() method to work on the values in Results using process_results\n///\n/// let first_max = process_results(first_values, |iter| iter.max().unwrap_or(0));\n/// let second_max = process_results(second_values, |iter| iter.max().unwrap_or(0));\n///\n/// assert_eq!(first_max, Ok(3));\n/// assert!(second_max.is_err());\n/// ```\npub fn process_results<I, F, T, E, R>(iterable: I, processor: F) -> Result<R, E>\n    where I: IntoIterator<Item = Result<T, E>>,\n          F: FnOnce(ProcessResults<I::IntoIter, E>) -> R\n{\n    let iter = iterable.into_iter();\n    let mut error = Ok(());\n\n    let result = processor(ProcessResults { error: &mut error, iter });\n\n    error.map(|_| result)\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","home","kms","itertools","src","put_back_n_impl.rs"],"content":"use crate::size_hint;\n\n/// An iterator adaptor that allows putting multiple\n/// items in front of the iterator.\n///\n/// Iterator element type is `I::Item`.\n#[derive(Debug, Clone)]\npub struct PutBackN<I: Iterator> {\n    top: Vec<I::Item>,\n    iter: I,\n}\n\n/// Create an iterator where you can put back multiple values to the front\n/// of the iteration.\n///\n/// Iterator element type is `I::Item`.\npub fn put_back_n<I>(iterable: I) -> PutBackN<I::IntoIter>\n    where I: IntoIterator\n{\n    PutBackN {\n        top: Vec::new(),\n        iter: iterable.into_iter(),\n    }\n}\n\nimpl<I: Iterator> PutBackN<I> {\n    /// Puts x in front of the iterator.\n    /// The values are yielded in order of the most recently put back\n    /// values first.\n    ///\n    /// ```rust\n    /// use itertools::put_back_n;\n    ///\n    /// let mut it = put_back_n(1..5);\n    /// it.next();\n    /// it.put_back(1);\n    /// it.put_back(0);\n    ///\n    /// assert!(itertools::equal(it, 0..5));\n    /// ```\n    #[inline]\n    pub fn put_back(&mut self, x: I::Item) {\n        self.top.push(x);\n    }\n}\n\nimpl<I: Iterator> Iterator for PutBackN<I> {\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.top.pop().or_else(|| self.iter.next())\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add_scalar(self.iter.size_hint(), self.top.len())\n    }\n}\n\n","traces":[{"line":17,"address":[5867205,5867152],"length":1,"stats":{"Line":3},"fn_name":"put_back_n<alloc::vec::IntoIter<u8>>"},{"line":21,"address":[5867162],"length":1,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[4243822],"length":1,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[4560173],"length":1,"stats":{"Line":3},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","kms","itertools","src","rciter_impl.rs"],"content":"\nuse std::iter::IntoIterator;\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n/// A wrapper for `Rc<RefCell<I>>`, that implements the `Iterator` trait.\n#[derive(Debug)]\npub struct RcIter<I> {\n    /// The boxed iterator.\n    pub rciter: Rc<RefCell<I>>,\n}\n\n/// Return an iterator inside a `Rc<RefCell<_>>` wrapper.\n///\n/// The returned `RcIter` can be cloned, and each clone will refer back to the\n/// same original iterator.\n///\n/// `RcIter` allows doing interesting things like using `.zip()` on an iterator with\n/// itself, at the cost of runtime borrow checking which may have a performance\n/// penalty.\n///\n/// Iterator element type is `Self::Item`.\n///\n/// ```\n/// use itertools::rciter;\n/// use itertools::zip;\n///\n/// // In this example a range iterator is created and we iterate it using\n/// // three separate handles (two of them given to zip).\n/// // We also use the IntoIterator implementation for `&RcIter`.\n///\n/// let mut iter = rciter(0..9);\n/// let mut z = zip(&iter, &iter);\n///\n/// assert_eq!(z.next(), Some((0, 1)));\n/// assert_eq!(z.next(), Some((2, 3)));\n/// assert_eq!(z.next(), Some((4, 5)));\n/// assert_eq!(iter.next(), Some(6));\n/// assert_eq!(z.next(), Some((7, 8)));\n/// assert_eq!(z.next(), None);\n/// ```\n///\n/// **Panics** in iterator methods if a borrow error is encountered in the\n/// iterator methods. It can only happen if the `RcIter` is reentered in\n/// `.next()`, i.e. if it somehow participates in an “iterator knot”\n/// where it is an adaptor of itself.\npub fn rciter<I>(iterable: I) -> RcIter<I::IntoIter>\n    where I: IntoIterator\n{\n    RcIter { rciter: Rc::new(RefCell::new(iterable.into_iter())) }\n}\n\nimpl<I> Clone for RcIter<I> {\n    #[inline]\n    clone_fields!(rciter);\n}\n\nimpl<A, I> Iterator for RcIter<I>\n    where I: Iterator<Item = A>\n{\n    type Item = A;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.rciter.borrow_mut().next()\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // To work sanely with other API that assume they own an iterator,\n        // so it can't change in other places, we can't guarantee as much\n        // in our size_hint. Other clones may drain values under our feet.\n        let (_, hi) = self.rciter.borrow().size_hint();\n        (0, hi)\n    }\n}\n\nimpl<I> DoubleEndedIterator for RcIter<I>\n    where I: DoubleEndedIterator\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.rciter.borrow_mut().next_back()\n    }\n}\n\n/// Return an iterator from `&RcIter<I>` (by simply cloning it).\nimpl<'a, I> IntoIterator for &'a RcIter<I>\n    where I: Iterator\n{\n    type Item = I::Item;\n    type IntoIter = RcIter<I>;\n\n    fn into_iter(self) -> RcIter<I> {\n        self.clone()\n    }\n}\n","traces":[{"line":47,"address":[5206080,5205984],"length":1,"stats":{"Line":3},"fn_name":"rciter<core::ops::range::Range<i32>>"},{"line":50,"address":[5205996,5206094],"length":1,"stats":{"Line":3},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":9,"coverable":11},{"path":["/","home","kms","itertools","src","repeatn.rs"],"content":"\n/// An iterator that produces *n* repetitions of an element.\n///\n/// See [`repeat_n()`](../fn.repeat_n.html) for more information.\n#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n#[derive(Clone, Debug)]\npub struct RepeatN<A> {\n    elt: Option<A>,\n    n: usize,\n}\n\n/// Create an iterator that produces `n` repetitions of `element`.\npub fn repeat_n<A>(element: A, n: usize) -> RepeatN<A>\n    where A: Clone,\n{\n    if n == 0 {\n        RepeatN { elt: None, n, }\n    } else {\n        RepeatN { elt: Some(element), n, }\n    }\n}\n\nimpl<A> Iterator for RepeatN<A>\n    where A: Clone\n{\n    type Item = A;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.n > 1 {\n            self.n -= 1;\n            self.elt.as_ref().cloned()\n        } else {\n            self.n = 0;\n            self.elt.take()\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (self.n, Some(self.n))\n    }\n}\n\nimpl<A> DoubleEndedIterator for RepeatN<A>\n    where A: Clone\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.next()\n    }\n}\n\nimpl<A> ExactSizeIterator for RepeatN<A>\n    where A: Clone\n{}\n","traces":[{"line":13,"address":[4209280,4209456],"length":1,"stats":{"Line":3},"fn_name":"repeat_n<&str>"},{"line":16,"address":[5245968,5246043],"length":1,"stats":{"Line":6},"fn_name":null},{"line":19,"address":[4209329,4209500],"length":1,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[5245680],"length":1,"stats":{"Line":3},"fn_name":"next<i32>"},{"line":29,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":30,"address":[4209003,4209064,4208973,4209161,4208876,4209191],"length":1,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":11,"coverable":13},{"path":["/","home","kms","itertools","src","size_hint.rs"],"content":"//! Arithmetic on **Iterator** *.size_hint()* values.\n//!\n\nuse std::usize;\nuse std::cmp;\n\n/// **SizeHint** is the return type of **Iterator::size_hint()**.\npub type SizeHint = (usize, Option<usize>);\n\n/// Add **SizeHint** correctly.\n#[inline]\npub fn add(a: SizeHint, b: SizeHint) -> SizeHint {\n    let min = a.0.checked_add(b.0).unwrap_or(usize::MAX);\n    let max = match (a.1, b.1) {\n        (Some(x), Some(y)) => x.checked_add(y),\n        _ => None,\n    };\n\n    (min, max)\n}\n\n/// Add **x** correctly to a **SizeHint**.\n#[inline]\npub fn add_scalar(sh: SizeHint, x: usize) -> SizeHint {\n    let (mut low, mut hi) = sh;\n    low = low.saturating_add(x);\n    hi = hi.and_then(|elt| elt.checked_add(x));\n    (low, hi)\n}\n\n/// Sbb **x** correctly to a **SizeHint**.\n#[inline]\n#[allow(dead_code)]\npub fn sub_scalar(sh: SizeHint, x: usize) -> SizeHint {\n    let (mut low, mut hi) = sh;\n    low = low.saturating_sub(x);\n    hi = hi.map(|elt| elt.saturating_sub(x));\n    (low, hi)\n}\n\n\n/// Multiply **SizeHint** correctly\n///\n/// ```ignore\n/// use std::usize;\n/// use itertools::size_hint;\n///\n/// assert_eq!(size_hint::mul((3, Some(4)), (3, Some(4))),\n///            (9, Some(16)));\n///\n/// assert_eq!(size_hint::mul((3, Some(4)), (usize::MAX, None)),\n///            (usize::MAX, None));\n///\n/// assert_eq!(size_hint::mul((3, None), (0, Some(0))),\n///            (0, Some(0)));\n/// ```\n#[inline]\npub fn mul(a: SizeHint, b: SizeHint) -> SizeHint {\n    let low = a.0.checked_mul(b.0).unwrap_or(usize::MAX);\n    let hi = match (a.1, b.1) {\n        (Some(x), Some(y)) => x.checked_mul(y),\n        (Some(0), None) | (None, Some(0)) => Some(0),\n        _ => None,\n    };\n    (low, hi)\n}\n\n/// Multiply **x** correctly with a **SizeHint**.\n#[inline]\npub fn mul_scalar(sh: SizeHint, x: usize) -> SizeHint {\n    let (mut low, mut hi) = sh;\n    low = low.saturating_mul(x);\n    hi = hi.and_then(|elt| elt.checked_mul(x));\n    (low, hi)\n}\n\n/// Return the maximum\n#[inline]\npub fn max(a: SizeHint, b: SizeHint) -> SizeHint {\n    let (a_lower, a_upper) = a;\n    let (b_lower, b_upper) = b;\n\n    let lower = cmp::max(a_lower, b_lower);\n\n    let upper = match (a_upper, b_upper) {\n        (Some(x), Some(y)) => Some(cmp::max(x, y)),\n        _ => None,\n    };\n\n    (lower, upper)\n}\n\n/// Return the minimum\n#[inline]\npub fn min(a: SizeHint, b: SizeHint) -> SizeHint {\n    let (a_lower, a_upper) = a;\n    let (b_lower, b_upper) = b;\n    let lower = cmp::min(a_lower, b_lower);\n    let upper = match (a_upper, b_upper) {\n        (Some(u1), Some(u2)) => Some(cmp::min(u1, u2)),\n        _ => a_upper.or(b_upper),\n    };\n    (lower, upper)\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":27,"address":[4552030,4552016],"length":1,"stats":{"Line":17},"fn_name":"{{closure}}"},{"line":28,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[4552094,4552080],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[4552128,4552142],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[4208048],"length":1,"stats":{"Line":2},"fn_name":"max"},{"line":80,"address":[4208058],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[4208084],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":38,"coverable":43},{"path":["/","home","kms","itertools","src","sources.rs"],"content":"//! Iterators that are sources (produce elements from parameters,\n//! not from another iterator).\n#![allow(deprecated)]\n\nuse std::fmt;\nuse std::mem;\n\n/// See [`repeat_call`](../fn.repeat_call.html) for more information.\n#[derive(Clone)]\n#[deprecated(note=\"Use std repeat_with() instead\", since=\"0.8\")]\npub struct RepeatCall<F> {\n    f: F,\n}\n\nimpl<F> fmt::Debug for RepeatCall<F>\n{\n    debug_fmt_fields!(RepeatCall, );\n}\n\n/// An iterator source that produces elements indefinitely by calling\n/// a given closure.\n///\n/// Iterator element type is the return type of the closure.\n///\n/// ```\n/// use itertools::repeat_call;\n/// use itertools::Itertools;\n/// use std::collections::BinaryHeap;\n///\n/// let mut heap = BinaryHeap::from(vec![2, 5, 3, 7, 8]);\n///\n/// // extract each element in sorted order\n/// for element in repeat_call(|| heap.pop()).while_some() {\n///     print!(\"{}\", element);\n/// }\n///\n/// itertools::assert_equal(\n///     repeat_call(|| 1).take(5),\n///     vec![1, 1, 1, 1, 1]\n/// );\n/// ```\n#[deprecated(note=\"Use std repeat_with() instead\", since=\"0.8\")]\npub fn repeat_call<F, A>(function: F) -> RepeatCall<F>\n    where F: FnMut() -> A\n{\n    RepeatCall { f: function }\n}\n\nimpl<A, F> Iterator for RepeatCall<F>\n    where F: FnMut() -> A\n{\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        Some((self.f)())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (usize::max_value(), None)\n    }\n}\n\n/// Creates a new unfold source with the specified closure as the \"iterator\n/// function\" and an initial state to eventually pass to the closure\n///\n/// `unfold` is a general iterator builder: it has a mutable state value,\n/// and a closure with access to the state that produces the next value.\n///\n/// This more or less equivalent to a regular struct with an `Iterator`\n/// implementation, and is useful for one-off iterators.\n///\n/// ```\n/// // an iterator that yields sequential Fibonacci numbers,\n/// // and stops at the maximum representable value.\n///\n/// use itertools::unfold;\n///\n/// let (mut x1, mut x2) = (1u32, 1u32);\n/// let mut fibonacci = unfold((), move |_| {\n///     // Attempt to get the next Fibonacci number\n///     let next = x1.saturating_add(x2);\n///\n///     // Shift left: ret <- x1 <- x2 <- next\n///     let ret = x1;\n///     x1 = x2;\n///     x2 = next;\n///\n///     // If addition has saturated at the maximum, we are finished\n///     if ret == x1 && ret > 1 {\n///         return None;\n///     }\n///\n///     Some(ret)\n/// });\n///\n/// itertools::assert_equal(fibonacci.by_ref().take(8),\n///                         vec![1, 1, 2, 3, 5, 8, 13, 21]);\n/// assert_eq!(fibonacci.last(), Some(2_971_215_073))\n/// ```\npub fn unfold<A, St, F>(initial_state: St, f: F) -> Unfold<St, F>\n    where F: FnMut(&mut St) -> Option<A>\n{\n    Unfold {\n        f,\n        state: initial_state,\n    }\n}\n\nimpl<St, F> fmt::Debug for Unfold<St, F>\n    where St: fmt::Debug,\n{\n    debug_fmt_fields!(Unfold, state);\n}\n\n/// See [`unfold`](../fn.unfold.html) for more information.\n#[derive(Clone)]\n#[must_use = \"iterators are lazy and do nothing unless consumed\"]\npub struct Unfold<St, F> {\n    f: F,\n    /// Internal state that will be passed to the closure on the next iteration\n    pub state: St,\n}\n\nimpl<A, St, F> Iterator for Unfold<St, F>\n    where F: FnMut(&mut St) -> Option<A>\n{\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        (self.f)(&mut self.state)\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // no possible known bounds at this point\n        (0, None)\n    }\n}\n\n/// An iterator that infinitely applies function to value and yields results.\n///\n/// This `struct` is created by the [`iterate()`] function. See its documentation for more.\n///\n/// [`iterate()`]: ../fn.iterate.html\n#[derive(Clone)]\n#[must_use = \"iterators are lazy and do nothing unless consumed\"]\npub struct Iterate<St, F> {\n    state: St,\n    f: F,\n}\n\nimpl<St, F> fmt::Debug for Iterate<St, F>\n    where St: fmt::Debug,\n{\n    debug_fmt_fields!(Iterate, state);\n}\n\nimpl<St, F> Iterator for Iterate<St, F>\n    where F: FnMut(&St) -> St\n{\n    type Item = St;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let next_state = (self.f)(&self.state);\n        Some(mem::replace(&mut self.state, next_state))\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (usize::max_value(), None)\n    }\n}\n\n/// Creates a new iterator that infinitely applies function to value and yields results.\n///\n/// ```\n/// use itertools::iterate;\n///\n/// itertools::assert_equal(iterate(1, |&i| i * 3).take(5), vec![1, 3, 9, 27, 81]);\n/// ```\npub fn iterate<St, F>(initial_value: St, f: F) -> Iterate<St, F>\n    where F: FnMut(&St) -> St\n{\n    Iterate {\n        state: initial_value,\n        f,\n    }\n}\n","traces":[{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":13},{"path":["/","home","kms","itertools","src","tee.rs"],"content":"use super::size_hint;\n\nuse std::cell::RefCell;\nuse std::collections::VecDeque;\nuse std::rc::Rc;\n\n/// Common buffer object for the two tee halves\n#[derive(Debug)]\nstruct TeeBuffer<A, I> {\n    backlog: VecDeque<A>,\n    iter: I,\n    /// The owner field indicates which id should read from the backlog\n    owner: bool,\n}\n\n/// One half of an iterator pair where both return the same elements.\n///\n/// See [`.tee()`](../trait.Itertools.html#method.tee) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Debug)]\npub struct Tee<I>\n    where I: Iterator\n{\n    rcbuffer: Rc<RefCell<TeeBuffer<I::Item, I>>>,\n    id: bool,\n}\n\npub fn new<I>(iter: I) -> (Tee<I>, Tee<I>)\n    where I: Iterator\n{\n    let buffer = TeeBuffer{backlog: VecDeque::new(), iter, owner: false};\n    let t1 = Tee{rcbuffer: Rc::new(RefCell::new(buffer)), id: true};\n    let t2 = Tee{rcbuffer: t1.rcbuffer.clone(), id: false};\n    (t1, t2)\n}\n\nimpl<I> Iterator for Tee<I>\n    where I: Iterator,\n          I::Item: Clone\n{\n    type Item = I::Item;\n    fn next(&mut self) -> Option<Self::Item> {\n        // .borrow_mut may fail here -- but only if the user has tied some kind of weird\n        // knot where the iterator refers back to itself.\n        let mut buffer = self.rcbuffer.borrow_mut();\n        if buffer.owner == self.id {\n            match buffer.backlog.pop_front() {\n                None => {}\n                some_elt => return some_elt,\n            }\n        }\n        match buffer.iter.next() {\n            None => None,\n            Some(elt) => {\n                buffer.backlog.push_back(elt.clone());\n                buffer.owner = !self.id;\n                Some(elt)\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let buffer = self.rcbuffer.borrow();\n        let sh = buffer.iter.size_hint();\n\n        if buffer.owner == self.id {\n            let log_len = buffer.backlog.len();\n            size_hint::add_scalar(sh, log_len)\n        } else {\n            sh\n        }\n    }\n}\n\nimpl<I> ExactSizeIterator for Tee<I>\n    where I: ExactSizeIterator,\n          I::Item: Clone\n{}\n","traces":[{"line":28,"address":[4494045,4493984,4493560,4493504],"length":1,"stats":{"Line":3},"fn_name":"new<itertools::adaptors::DedupBy<core::slice::Iter<u8>, itertools::adaptors::DedupEq>>"},{"line":31,"address":[4494060,4494004,4493575,4493514],"length":1,"stats":{"Line":6},"fn_name":null},{"line":32,"address":[5149604],"length":1,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[5149728],"length":1,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[5149759],"length":1,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[5148704,5148779],"length":1,"stats":{"Line":3},"fn_name":"next<core::iter::adapters::Cloned<core::slice::Iter<i32>>>"},{"line":45,"address":[5148777,5148716,5148799],"length":1,"stats":{"Line":9},"fn_name":null},{"line":46,"address":[5148819,5149011],"length":1,"stats":{"Line":6},"fn_name":null},{"line":47,"address":[5148875],"length":1,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[5148923],"length":1,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[4491465,4491411,4492249,4492195],"length":1,"stats":{"Line":6},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":53,"address":[4492315,4491535,4492342,4491562],"length":1,"stats":{"Line":6},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":24,"coverable":24},{"path":["/","home","kms","itertools","src","tuple_impl.rs"],"content":"//! Some iterator that produces tuples\n\nuse std::iter::Fuse;\nuse std::iter::Take;\nuse std::iter::Cycle;\nuse std::marker::PhantomData;\n\n// `HomogeneousTuple` is a public facade for `TupleCollect`, allowing\n// tuple-related methods to be used by clients in generic contexts, while\n// hiding the implementation details of `TupleCollect`.\n// See https://github.com/rust-itertools/itertools/issues/387\n\n/// Implemented for homogeneous tuples of size up to 4.\npub trait HomogeneousTuple\n    : TupleCollect\n{}\n\nimpl<T: TupleCollect> HomogeneousTuple for T {}\n\n/// An iterator over a incomplete tuple.\n///\n/// See [`.tuples()`](../trait.Itertools.html#method.tuples) and\n/// [`Tuples::into_buffer()`](struct.Tuples.html#method.into_buffer).\n#[derive(Clone, Debug)]\npub struct TupleBuffer<T>\n    where T: HomogeneousTuple\n{\n    cur: usize,\n    buf: T::Buffer,\n}\n\nimpl<T> TupleBuffer<T>\n    where T: HomogeneousTuple\n{\n    fn new(buf: T::Buffer) -> Self {\n        TupleBuffer {\n            cur: 0,\n            buf,\n        }\n    }\n}\n\nimpl<T> Iterator for TupleBuffer<T>\n    where T: HomogeneousTuple\n{\n    type Item = T::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let s = self.buf.as_mut();\n        if let Some(ref mut item) = s.get_mut(self.cur) {\n            self.cur += 1;\n            item.take()\n        } else {\n            None\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let buffer = &self.buf.as_ref()[self.cur..];\n        let len = if buffer.len() == 0 {\n            0\n        } else {\n            buffer.iter()\n                  .position(|x| x.is_none())\n                  .unwrap_or(buffer.len())\n        };\n        (len, Some(len))\n    }\n}\n\nimpl<T> ExactSizeIterator for TupleBuffer<T>\n    where T: HomogeneousTuple\n{\n}\n\n/// An iterator that groups the items in tuples of a specific size.\n///\n/// See [`.tuples()`](../trait.Itertools.html#method.tuples) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Tuples<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    iter: Fuse<I>,\n    buf: T::Buffer,\n}\n\n/// Create a new tuples iterator.\npub fn tuples<I, T>(iter: I) -> Tuples<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    Tuples {\n        iter: iter.fuse(),\n        buf: Default::default(),\n    }\n}\n\nimpl<I, T> Iterator for Tuples<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        T::collect_from_iter(&mut self.iter, &mut self.buf)\n    }\n}\n\nimpl<I, T> Tuples<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    /// Return a buffer with the produced items that was not enough to be grouped in a tuple.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut iter = (0..5).tuples();\n    /// assert_eq!(Some((0, 1, 2)), iter.next());\n    /// assert_eq!(None, iter.next());\n    /// itertools::assert_equal(vec![3, 4], iter.into_buffer());\n    /// ```\n    pub fn into_buffer(self) -> TupleBuffer<T> {\n        TupleBuffer::new(self.buf)\n    }\n}\n\n\n/// An iterator over all contiguous windows that produces tuples of a specific size.\n///\n/// See [`.tuple_windows()`](../trait.Itertools.html#method.tuple_windows) for more\n/// information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Clone, Debug)]\npub struct TupleWindows<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    iter: I,\n    last: Option<T>,\n}\n\n/// Create a new tuple windows iterator.\npub fn tuple_windows<I, T>(mut iter: I) -> TupleWindows<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple,\n          T::Item: Clone\n{\n    use std::iter::once;\n\n    let mut last = None;\n    if T::num_items() != 1 {\n        // put in a duplicate item in front of the tuple; this simplifies\n        // .next() function.\n        if let Some(item) = iter.next() {\n            let iter = once(item.clone()).chain(once(item)).chain(&mut iter);\n            last = T::collect_from_iter_no_buf(iter);\n        }\n    }\n\n    TupleWindows {\n        last,\n        iter,\n    }\n}\n\nimpl<I, T> Iterator for TupleWindows<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple + Clone,\n          T::Item: Clone\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if T::num_items() == 1 {\n            return T::collect_from_iter_no_buf(&mut self.iter)\n        }\n        if let Some(ref mut last) = self.last {\n            if let Some(new) = self.iter.next() {\n                last.left_shift_push(new);\n                return Some(last.clone());\n            }\n        }\n        None\n    }\n}\n\n/// An iterator over all windows,wrapping back to the first elements when the\n/// window would otherwise exceed the length of the iterator, producing tuples\n/// of a specific size.\n///\n/// See [`.circular_tuple_windows()`](../trait.Itertools.html#method.circular_tuple_windows) for more\n/// information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Debug)]\npub struct CircularTupleWindows<I, T: Clone>\n    where I: Iterator<Item = T::Item> + Clone,\n          T: TupleCollect + Clone\n{\n    iter: Take<TupleWindows<Cycle<I>, T>>,\n    phantom_data: PhantomData<T>\n}\n\npub fn circular_tuple_windows<I, T>(iter: I) -> CircularTupleWindows<I, T>\n    where I: Iterator<Item = T::Item> + Clone + ExactSizeIterator,\n          T: TupleCollect + Clone,\n          T::Item: Clone\n{\n    let len = iter.len();\n    let iter = tuple_windows(iter.cycle()).take(len);\n\n    CircularTupleWindows {\n        iter: iter,\n        phantom_data: PhantomData{}\n    }\n}\n\nimpl<I, T> Iterator for CircularTupleWindows<I, T>\n    where I: Iterator<Item = T::Item> + Clone,\n          T: TupleCollect + Clone,\n          T::Item: Clone\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next()\n    }\n}\n\npub trait TupleCollect: Sized {\n    type Item;\n    type Buffer: Default + AsRef<[Option<Self::Item>]> + AsMut<[Option<Self::Item>]>;\n\n    fn collect_from_iter<I>(iter: I, buf: &mut Self::Buffer) -> Option<Self>\n        where I: IntoIterator<Item = Self::Item>;\n\n    fn collect_from_iter_no_buf<I>(iter: I) -> Option<Self>\n        where I: IntoIterator<Item = Self::Item>;\n\n    fn num_items() -> usize;\n\n    fn left_shift_push(&mut self, item: Self::Item);\n}\n\nmacro_rules! impl_tuple_collect {\n    ($N:expr; $A:ident ; $($X:ident),* ; $($Y:ident),* ; $($Y_rev:ident),*) => (\n        impl<$A> TupleCollect for ($($X),*,) {\n            type Item = $A;\n            type Buffer = [Option<$A>; $N - 1];\n\n            #[allow(unused_assignments, unused_mut)]\n            fn collect_from_iter<I>(iter: I, buf: &mut Self::Buffer) -> Option<Self>\n                where I: IntoIterator<Item = $A>\n            {\n                let mut iter = iter.into_iter();\n                $(\n                    let mut $Y = None;\n                )*\n\n                loop {\n                    $(\n                        $Y = iter.next();\n                        if $Y.is_none() {\n                            break\n                        }\n                    )*\n                    return Some(($($Y.unwrap()),*,))\n                }\n\n                let mut i = 0;\n                let mut s = buf.as_mut();\n                $(\n                    if i < s.len() {\n                        s[i] = $Y;\n                        i += 1;\n                    }\n                )*\n                return None;\n            }\n\n            #[allow(unused_assignments)]\n            fn collect_from_iter_no_buf<I>(iter: I) -> Option<Self>\n                where I: IntoIterator<Item = $A>\n            {\n                let mut iter = iter.into_iter();\n                loop {\n                    $(\n                        let $Y = if let Some($Y) = iter.next() {\n                            $Y\n                        } else {\n                            break;\n                        };\n                    )*\n                    return Some(($($Y),*,))\n                }\n\n                return None;\n            }\n\n            fn num_items() -> usize {\n                $N\n            }\n\n            fn left_shift_push(&mut self, item: $A) {\n                use std::mem::replace;\n\n                let &mut ($(ref mut $Y),*,) = self;\n                let tmp = item;\n                $(\n                    let tmp = replace($Y_rev, tmp);\n                )*\n                drop(tmp);\n            }\n        }\n    )\n}\n\nimpl_tuple_collect!(1; A; A; a; a);\nimpl_tuple_collect!(2; A; A, A; a, b; b, a);\nimpl_tuple_collect!(3; A; A, A, A; a, b, c; c, b, a);\nimpl_tuple_collect!(4; A; A, A, A, A; a, b, c, d; d, c, b, a);\n","traces":[{"line":35,"address":[4268672,4268816,4268736,4268608],"length":1,"stats":{"Line":5},"fn_name":"new<(i32, i32)>"},{"line":48,"address":[4251056,4251504,4251280,4251728],"length":1,"stats":{"Line":5},"fn_name":"next<(i32, i32, i32)>"},{"line":49,"address":[4251289,4251513,4251737,4251065],"length":1,"stats":{"Line":5},"fn_name":null},{"line":50,"address":[4251377,4251540,4251153,4251672,4251601,4251224,4251757,4251316,4251092,4251889,4251818,4251448],"length":1,"stats":{"Line":13},"fn_name":null},{"line":51,"address":[4251165,4251389,4251463,4251493,4251239,4251613,4251830,4251934,4251904,4251269,4251717,4251687],"length":1,"stats":{"Line":5},"fn_name":null},{"line":52,"address":[4251868,4251427,4251651,4251203],"length":1,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[4251369,4251593,4251145,4251810],"length":1,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[4269008,4268899,4268848,4269060,4269379,4269168,4269220,4269328],"length":1,"stats":{"Line":8},"fn_name":"tuples<core::iter::adapters::Cloned<core::slice::Iter<i32>>,(i32, i32, i32)>"},{"line":95,"address":[4269025,4269185,4268865,4269345],"length":1,"stats":{"Line":8},"fn_name":null},{"line":96,"address":[4268916,4269072,4269091,4269391,4269237],"length":1,"stats":{"Line":10},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":125,"address":[4268304,4268528,4268337,4268464,4268485,4268384,4268570,4268417],"length":1,"stats":{"Line":5},"fn_name":"into_buffer<core::iter::adapters::Cloned<core::slice::Iter<i32>>,(i32, i32)>"},{"line":126,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":146,"address":[4266096,4265424,4265498,4266816,4266890,4267536,4266170,4267610],"length":1,"stats":{"Line":8},"fn_name":"tuple_windows<core::iter::adapters::Cloned<core::slice::Iter<i32>>,(i32)>"},{"line":153,"address":[4266116,4265444,4266836,4267556],"length":1,"stats":{"Line":8},"fn_name":null},{"line":154,"address":[4266190,4266910,4265518,4266710,4267424,4267630,4265989,4267598,4266878,4266158,4268188,4265486],"length":1,"stats":{"Line":22},"fn_name":null},{"line":157,"address":[4267650,4266210,4266930,4265538],"length":1,"stats":{"Line":6},"fn_name":null},{"line":158,"address":[4267793,4267360,4268111,4266353,4265681,4265622,4267073,4267014,4266644,4266294,4267734,4265933],"length":1,"stats":{"Line":12},"fn_name":null},{"line":159,"address":[4268133,4267382,4267912,4266666,4265959,4265797,4266469,4267189],"length":1,"stats":{"Line":12},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[4253346,4254592,4257408,4261108,4254692,4257524,4253296,4260976],"length":1,"stats":{"Line":8},"fn_name":"collect_from_iter<i32,&mut core::iter::adapters::Fuse<core::iter::adapters::Cloned<core::slice::Iter<i32>>>>"},{"line":257,"address":[4253313,4261002,4257434,4254618],"length":1,"stats":{"Line":8},"fn_name":null},{"line":259,"address":[4253361,4257539,4254707,4261123],"length":1,"stats":{"Line":8},"fn_name":null},{"line":264,"address":[4257708,4261546,4257828,4262935,4255586,4253399,4257604,4254887,4258903,4254870,4255534,4257781,4261327,4262752,4261473,4254753,4257854,4258842,4253764,4261447,4261400,4262813,4257755,4253382,4261374,4258781,4261207,4262874,4254826,4261520],"length":1,"stats":{"Line":60},"fn_name":null},{"line":265,"address":[4258947,4262918,4257874,4258886,4255624,4261347,4262796,4262979,4255572,4261420,4253793,4257728,4254843,4262857,4258825,4257801,4261493,4261566,4254904,4253416],"length":1,"stats":{"Line":40},"fn_name":null},{"line":266,"address":[4257849,4261541,4257929,4261621,4254885,4261395,4261468,4257776,4254956],"length":1,"stats":{"Line":12},"fn_name":null},{"line":269,"address":[4254961,4254923,4253429,4257934,4261585,4253491,4257893,4261626],"length":1,"stats":{"Line":16},"fn_name":null},{"line":272,"address":[4254768,4253456,4257625,4261228],"length":1,"stats":{"Line":8},"fn_name":null},{"line":273,"address":[4254780,4253465,4255120,4257637,4261240,4253554,4261950,4258183],"length":1,"stats":{"Line":16},"fn_name":null},{"line":275,"address":[4253575,4261974,4255141,4255308,4262165,4262332,4258374,4258541,4262499,4258207],"length":1,"stats":{"Line":20},"fn_name":null},{"line":276,"address":[4259350,4263404,4258430,4258597,4253628,4259478,4262555,4263663,4262388,4255664,4256014,4263048,4253910,4259225,4255886,4259559,4262221,4253820,4258263,4263828,4259003,4259100,4263529,4262042,4263744,4263279,4255761,4263154,4255197,4255364],"length":1,"stats":{"Line":18},"fn_name":null},{"line":277,"address":[4258525,4254034,4253710,4255825,4253856,4259610,4263795,4259289,4262483,4259039,4263343,4255458,4258358,4259526,4263633,4259164,4255700,4262149,4263468,4263711,4262316,4258692,4263218,4262650,4263879,4259448,4254004,4255984,4263093,4256061,4255292],"length":1,"stats":{"Line":24},"fn_name":null},{"line":280,"address":[4262674,4258716,4253723,4255482],"length":1,"stats":{"Line":8},"fn_name":null},{"line":284,"address":[4256586,4256880,4256544,4264752,4260267,4254104,4256909,4263984,4260192,4256128,4256203,4254272,4259741,4254048,4259696,4264797,4264059,4254298],"length":1,"stats":{"Line":11},"fn_name":"collect_from_iter_no_buf<i32,core::iter::adapters::chain::Chain<core::iter::adapters::chain::Chain<core::iter::sources::Once<i32>, core::iter::sources::Once<i32>>, &mut core::iter::adapters::Cloned<core::slice::Iter<i32>>>>"},{"line":287,"address":[4256892,4260202,4256138,4254281,4256556,4254052,4259711,4264767,4263994],"length":1,"stats":{"Line":11},"fn_name":null},{"line":290,"address":[4254166,4254334,4260436,4264116,4260350,4256730,4259895,4264394,4260324,4256926,4265103,4256963,4264428,4256704,4259798,4265166,4265078,4257086,4256666,4264079,4260503,4264295,4260401,4264228,4260610,4264854,4264525,4264817,4260048,4256640,4254360,4254121,4259943,4264951,4256995,4257054,4256260,4256286,4260635,4264142,4256359,4259761,4257161,4256784,4264880,4265029,4265003,4259969,4260287,4264500,4259869,4260538,4259824,4264925,4256603,4264550,4264330,4260023,4264193,4265191,4256223,4256428,4256324,4265216,4254140,4254315],"length":1,"stats":{"Line":81},"fn_name":null},{"line":291,"address":[4264442,4259977,4265114,4256373,4254174,4264959,4264888,4260552,4259832,4257096,4256738,4264344,4256674,4265037,4256294,4259903,4260450,4264153,4264242,4260361,4257005,4254368],"length":1,"stats":{"Line":27},"fn_name":null},{"line":293,"address":[4257041,4260001,4260488,4264988,4260393,4260588,4256403,4264185,4264992,4265066,4259861,4260492,4256762,4256316,4264280,4264917,4265070,4264284,4259928,4265144,4259932,4264382,4256696,4257131,4264386,4264478],"length":1,"stats":{"Line":11},"fn_name":null},{"line":296,"address":[4257175,4254413,4256445,4264569,4265235,4256801,4260065,4260655,4254219],"length":1,"stats":{"Line":11},"fn_name":null},{"line":299,"address":[4256938,4256243,4264837,4254196,4260307,4264099,4256623,4254390,4259781],"length":1,"stats":{"Line":6},"fn_name":null},{"line":302,"address":[4257264,4265408,4254464,4260800],"length":1,"stats":{"Line":8},"fn_name":"num_items<i32>"},{"line":306,"address":[4257280,4254480,4253232,4260816],"length":1,"stats":{"Line":6},"fn_name":"left_shift_push<i32>"},{"line":309,"address":[4253245,4254493,4260828,4257292],"length":1,"stats":{"Line":6},"fn_name":null},{"line":310,"address":[4260882,4254519,4253255,4257331],"length":1,"stats":{"Line":6},"fn_name":null},{"line":312,"address":[4257339,4253263,4260890,4254527],"length":1,"stats":{"Line":6},"fn_name":null},{"line":314,"address":[4257393,4253281,4260962,4254563],"length":1,"stats":{"Line":6},"fn_name":null}],"covered":61,"coverable":64},{"path":["/","home","kms","itertools","src","unique_impl.rs"],"content":"\nuse std::collections::HashMap;\nuse std::collections::hash_map::{Entry};\nuse std::hash::Hash;\nuse std::fmt;\n\n/// An iterator adapter to filter out duplicate elements.\n///\n/// See [`.unique_by()`](../trait.Itertools.html#method.unique) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct UniqueBy<I: Iterator, V, F> {\n    iter: I,\n    // Use a hashmap for the entry API\n    used: HashMap<V, ()>,\n    f: F,\n}\n\nimpl<I, V, F> fmt::Debug for UniqueBy<I, V, F>\n    where I: Iterator + fmt::Debug,\n          V: fmt::Debug + Hash + Eq,\n{\n    debug_fmt_fields!(UniqueBy, iter, used);\n}\n\n/// Create a new `UniqueBy` iterator.\npub fn unique_by<I, V, F>(iter: I, f: F) -> UniqueBy<I, V, F>\n    where V: Eq + Hash,\n          F: FnMut(&I::Item) -> V,\n          I: Iterator,\n{\n    UniqueBy {\n        iter,\n        used: HashMap::new(),\n        f,\n    }\n}\n\n// count the number of new unique keys in iterable (`used` is the set already seen)\nfn count_new_keys<I, K>(mut used: HashMap<K, ()>, iterable: I) -> usize\n    where I: IntoIterator<Item=K>,\n          K: Hash + Eq,\n{\n    let iter = iterable.into_iter();\n    let current_used = used.len();\n    used.extend(iter.map(|key| (key, ())));\n    used.len() - current_used\n}\n\nimpl<I, V, F> Iterator for UniqueBy<I, V, F>\n    where I: Iterator,\n          V: Eq + Hash,\n          F: FnMut(&I::Item) -> V\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        while let Some(v) = self.iter.next() {\n            let key = (self.f)(&v);\n            if self.used.insert(key, ()).is_none() {\n                return Some(v);\n            }\n        }\n        None\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, hi) = self.iter.size_hint();\n        ((low > 0 && self.used.is_empty()) as usize, hi)\n    }\n\n    fn count(self) -> usize {\n        let mut key_f = self.f;\n        count_new_keys(self.used, self.iter.map(move |elt| key_f(&elt)))\n    }\n}\n\nimpl<I, V, F> DoubleEndedIterator for UniqueBy<I, V, F>\n    where I: DoubleEndedIterator,\n          V: Eq + Hash,\n          F: FnMut(&I::Item) -> V\n{\n    fn next_back(&mut self) -> Option<I::Item> {\n        while let Some(v) = self.iter.next_back() {\n            let key = (self.f)(&v);\n            if self.used.insert(key, ()).is_none() {\n                return Some(v);\n            }\n        }\n        None\n    }\n}\n\nimpl<I> Iterator for Unique<I>\n    where I: Iterator,\n          I::Item: Eq + Hash + Clone\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        while let Some(v) = self.iter.iter.next() {\n            if let Entry::Vacant(entry) = self.iter.used.entry(v) {\n                let elt = entry.key().clone();\n                entry.insert(());\n                return Some(elt);\n            }\n        }\n        None\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, hi) = self.iter.iter.size_hint();\n        ((low > 0 && self.iter.used.is_empty()) as usize, hi)\n    }\n\n    fn count(self) -> usize {\n        count_new_keys(self.iter.used, self.iter.iter)\n    }\n}\n\nimpl<I> DoubleEndedIterator for Unique<I>\n    where I: DoubleEndedIterator,\n          I::Item: Eq + Hash + Clone\n{\n    fn next_back(&mut self) -> Option<I::Item> {\n        while let Some(v) = self.iter.iter.next_back() {\n            if let Entry::Vacant(entry) = self.iter.used.entry(v) {\n                let elt = entry.key().clone();\n                entry.insert(());\n                return Some(elt);\n            }\n        }\n        None\n    }\n}\n\n/// An iterator adapter to filter out duplicate elements.\n///\n/// See [`.unique()`](../trait.Itertools.html#method.unique) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Unique<I: Iterator> {\n    iter: UniqueBy<I, I::Item, ()>,\n}\n\nimpl<I> fmt::Debug for Unique<I>\n    where I: Iterator + fmt::Debug,\n          I::Item: Hash + Eq + fmt::Debug,\n{\n    debug_fmt_fields!(Unique, iter);\n}\n\npub fn unique<I>(iter: I) -> Unique<I>\n    where I: Iterator,\n          I::Item: Eq + Hash,\n{\n    Unique {\n        iter: UniqueBy {\n            iter,\n            used: HashMap::new(),\n            f: (),\n        }\n    }\n}\n","traces":[{"line":27,"address":[5204604,5204480,5204640,5204924,5204764,5204800],"length":1,"stats":{"Line":3},"fn_name":"unique_by<core::slice::Iter<&str>,alloc::string::String,closure-2>"},{"line":34,"address":[5204680,5204520,5204840],"length":1,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[5159632,5159689],"length":1,"stats":{"Line":1},"fn_name":"count_new_keys<core::iter::adapters::Cloned<core::slice::Iter<i8>>,i8>"},{"line":44,"address":[5159649,5159706],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[5159731,5159760],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[5159997,5159984,5159765],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}<core::iter::adapters::Cloned<core::slice::Iter<i8>>,i8>"},{"line":47,"address":[5159940,5159824],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[5202881,5202614,5202966,5202529],"length":1,"stats":{"Line":4},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[5204214,5204032,5204438,5204256],"length":1,"stats":{"Line":4},"fn_name":"unique<core::slice::Iter<i32>>"},{"line":160,"address":[5204329,5204105],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":40,"coverable":46},{"path":["/","home","kms","itertools","src","with_position.rs"],"content":"use std::iter::{Fuse,Peekable};\n\n/// An iterator adaptor that wraps each element in an [`Position`](../enum.Position.html).\n///\n/// Iterator element type is `Position<I::Item>`.\n///\n/// See [`.with_position()`](../trait.Itertools.html#method.with_position) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct WithPosition<I>\n    where I: Iterator,\n{\n    handled_first: bool,\n    peekable: Peekable<Fuse<I>>,\n}\n\nimpl<I> Clone for WithPosition<I>\n    where I: Clone + Iterator,\n          I::Item: Clone,\n{\n    clone_fields!(handled_first, peekable);\n}\n\n/// Create a new `WithPosition` iterator.\npub fn with_position<I>(iter: I) -> WithPosition<I>\n    where I: Iterator,\n{\n    WithPosition {\n        handled_first: false,\n        peekable: iter.fuse().peekable(),\n    }\n}\n\n/// A value yielded by `WithPosition`.\n/// Indicates the position of this element in the iterator results.\n///\n/// See [`.with_position()`](trait.Itertools.html#method.with_position) for more information.\n#[derive(Copy, Clone, Debug, PartialEq)]\npub enum Position<T> {\n    /// This is the first element.\n    First(T),\n    /// This is neither the first nor the last element.\n    Middle(T),\n    /// This is the last element.\n    Last(T),\n    /// This is the only element.\n    Only(T),\n}\n\nimpl<T> Position<T> {\n    /// Return the inner value.\n    pub fn into_inner(self) -> T {\n        match self {\n            Position::First(x) |\n            Position::Middle(x) |\n            Position::Last(x) |\n            Position::Only(x) => x,\n        }\n    }\n}\n\nimpl<I: Iterator> Iterator for WithPosition<I> {\n    type Item = Position<I::Item>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.peekable.next() {\n            Some(item) => {\n                if !self.handled_first {\n                    // Haven't seen the first item yet, and there is one to give.\n                    self.handled_first = true;\n                    // Peek to see if this is also the last item,\n                    // in which case tag it as `Only`.\n                    match self.peekable.peek() {\n                        Some(_) => Some(Position::First(item)),\n                        None => Some(Position::Only(item)),\n                    }\n                } else {\n                    // Have seen the first item, and there's something left.\n                    // Peek to see if this is the last item.\n                    match self.peekable.peek() {\n                        Some(_) => Some(Position::Middle(item)),\n                        None => Some(Position::Last(item)),\n                    }\n                }\n            }\n            // Iterator is finished.\n            None => None,\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.peekable.size_hint()\n    }\n}\n\nimpl<I> ExactSizeIterator for WithPosition<I>\n    where I: ExactSizeIterator,\n{ }\n","traces":[{"line":24,"address":[5738736,5738624],"length":1,"stats":{"Line":2},"fn_name":"with_position<quick::Iter<u8, quick::Exact>>"},{"line":29,"address":[5738753,5738646],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[5737543,5737952,5737504,5738000],"length":1,"stats":{"Line":2},"fn_name":"next<quick::Iter<u8, quick::Exact>>"},{"line":65,"address":[5737513,5737576,5737964,5738046],"length":1,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":15,"coverable":22},{"path":["/","home","kms","itertools","src","zip_eq_impl.rs"],"content":"use super::size_hint;\n\n/// An iterator which iterates two other iterators simultaneously\n///\n/// See [`.zip_eq()`](../trait.Itertools.html#method.zip_eq) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct ZipEq<I, J> {\n    a: I,\n    b: J,\n}\n\n/// Iterate `i` and `j` in lock step.\n///\n/// **Panics** if the iterators are not of the same length.\n///\n/// `IntoIterator` enabled version of `i.zip_eq(j)`.\n///\n/// ```\n/// use itertools::zip_eq;\n///\n/// let data = [1, 2, 3, 4, 5];\n/// for (a, b) in zip_eq(&data[..data.len() - 1], &data[1..]) {\n///     /* loop body */\n/// }\n/// ```\npub fn zip_eq<I, J>(i: I, j: J) -> ZipEq<I::IntoIter, J::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator\n{\n    ZipEq {\n        a: i.into_iter(),\n        b: j.into_iter(),\n    }\n}\n\nimpl<I, J> Iterator for ZipEq<I, J>\n    where I: Iterator,\n          J: Iterator\n{\n    type Item = (I::Item, J::Item);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match (self.a.next(), self.b.next()) {\n            (None, None) => None,\n            (Some(a), Some(b)) => Some((a, b)),\n            (None, Some(_)) | (Some(_), None) =>\n            panic!(\"itertools: .zip_eq() reached end of one iterator before the other\")\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::min(self.a.size_hint(), self.b.size_hint())\n    }\n}\n\nimpl<I, J> ExactSizeIterator for ZipEq<I, J>\n    where I: ExactSizeIterator,\n          J: ExactSizeIterator\n{}\n","traces":[{"line":27,"address":[4225116,4225008,4225340,4225232],"length":1,"stats":{"Line":3},"fn_name":"zip_eq<&[i32; 0],&[i32; 3]>"},{"line":32,"address":[4225249,4225025],"length":1,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[4225304,4225080],"length":1,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":7,"coverable":11},{"path":["/","home","kms","itertools","src","zip_longest.rs"],"content":"use std::cmp::Ordering::{Equal, Greater, Less};\nuse super::size_hint;\nuse std::iter::Fuse;\n\nuse crate::either_or_both::EitherOrBoth;\n\n// ZipLongest originally written by SimonSapin,\n// and dedicated to itertools https://github.com/rust-lang/rust/pull/19283\n\n/// An iterator which iterates two other iterators simultaneously\n///\n/// This iterator is *fused*.\n///\n/// See [`.zip_longest()`](../trait.Itertools.html#method.zip_longest) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct ZipLongest<T, U> {\n    a: Fuse<T>,\n    b: Fuse<U>,\n}\n\n/// Create a new `ZipLongest` iterator.\npub fn zip_longest<T, U>(a: T, b: U) -> ZipLongest<T, U> \n    where T: Iterator,\n          U: Iterator\n{\n    ZipLongest {\n        a: a.fuse(),\n        b: b.fuse(),\n    }\n}\n\nimpl<T, U> Iterator for ZipLongest<T, U>\n    where T: Iterator,\n          U: Iterator\n{\n    type Item = EitherOrBoth<T::Item, U::Item>;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        match (self.a.next(), self.b.next()) {\n            (None, None) => None,\n            (Some(a), None) => Some(EitherOrBoth::Left(a)),\n            (None, Some(b)) => Some(EitherOrBoth::Right(b)),\n            (Some(a), Some(b)) => Some(EitherOrBoth::Both(a, b)),\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::max(self.a.size_hint(), self.b.size_hint())\n    }\n}\n\nimpl<T, U> DoubleEndedIterator for ZipLongest<T, U>\n    where T: DoubleEndedIterator + ExactSizeIterator,\n          U: DoubleEndedIterator + ExactSizeIterator\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        match self.a.len().cmp(&self.b.len()) {\n            Equal => match (self.a.next_back(), self.b.next_back()) {\n                (None, None) => None,\n                (Some(a), Some(b)) => Some(EitherOrBoth::Both(a, b)),\n                // These can only happen if .len() is inconsistent with .next_back()\n                (Some(a), None) => Some(EitherOrBoth::Left(a)),\n                (None, Some(b)) => Some(EitherOrBoth::Right(b)),\n            },\n            Greater => self.a.next_back().map(EitherOrBoth::Left),\n            Less => self.b.next_back().map(EitherOrBoth::Right),\n        }\n    }\n}\n\nimpl<T, U> ExactSizeIterator for ZipLongest<T, U>\n    where T: ExactSizeIterator,\n          U: ExactSizeIterator\n{}\n","traces":[{"line":23,"address":[4781127,4781232,4780902,4780784,4781008,4781456,4781590,4781343],"length":1,"stats":{"Line":8},"fn_name":"zip_longest<quick::Iter<i16, quick::Exact>,quick::Iter<i16, quick::Exact>>"},{"line":28,"address":[4781030,4780821,4781254,4781466],"length":1,"stats":{"Line":8},"fn_name":null},{"line":29,"address":[4237767,4237991,4237316,4237543],"length":1,"stats":{"Line":8},"fn_name":null},{"line":40,"address":[4235770,4235258,4235712,4235200],"length":1,"stats":{"Line":6},"fn_name":"next<itertools::adaptors::Batching<core::slice::Iter<core::option::Option<i32>>, closure-0>,core::iter::adapters::Cloned<core::slice::Iter<i32>>>"},{"line":41,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":42,"address":[4776745,4777273,4777801,4777125,4776623,4777653,4778181,4778207,4778329,4777151,4776597,4777679],"length":1,"stats":{"Line":18},"fn_name":null},{"line":43,"address":[4235378,4236019,4235890,4235507],"length":1,"stats":{"Line":10},"fn_name":null},{"line":44,"address":[4777746,4777218,4776690,4778274],"length":1,"stats":{"Line":5},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":50,"address":[4778576,4778672,4778768],"length":1,"stats":{"Line":5},"fn_name":"size_hint<itertools::adaptors::DedupBy<quick::Iter<i16, quick::Exact>, itertools::adaptors::DedupEq>,quick::Iter<i16, quick::Exact>>"},{"line":51,"address":[4778588,4778684,4778780],"length":1,"stats":{"Line":5},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":63,"address":[4236910,4236704,4236737],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":17,"coverable":20},{"path":["/","home","kms","itertools","src","ziptuple.rs"],"content":"use super::size_hint;\n\n/// See [`multizip`](../fn.multizip.html) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Zip<T> {\n    t: T,\n}\n\n/// An iterator that generalizes *.zip()* and allows running multiple iterators in lockstep.\n///\n/// The iterator `Zip<(I, J, ..., M)>` is formed from a tuple of iterators (or values that\n/// implement `IntoIterator`) and yields elements\n/// until any of the subiterators yields `None`.\n///\n/// The iterator element type is a tuple like like `(A, B, ..., E)` where `A` to `E` are the\n/// element types of the subiterator.\n///\n/// **Note:** The result of this macro is a value of a named type (`Zip<(I, J,\n/// ..)>` of each component iterator `I, J, ...`) if each component iterator is\n/// nameable.\n///\n/// Prefer [`izip!()`] over `multizip` for the performance benefits of using the\n/// standard library `.zip()`. Prefer `multizip` if a nameable type is needed.\n///\n/// [`izip!()`]: macro.izip.html\n///\n/// ```\n/// use itertools::multizip;\n///\n/// // iterate over three sequences side-by-side\n/// let mut results = [0, 0, 0, 0];\n/// let inputs = [3, 7, 9, 6];\n///\n/// for (r, index, input) in multizip((&mut results, 0..10, &inputs)) {\n///     *r = index * 10 + input;\n/// }\n///\n/// assert_eq!(results, [0 + 3, 10 + 7, 29, 36]);\n/// ```\npub fn multizip<T, U>(t: U) -> Zip<T>\n    where Zip<T>: From<U>,\n          Zip<T>: Iterator,\n{\n    Zip::from(t)\n}\n\nmacro_rules! impl_zip_iter {\n    ($($B:ident),*) => (\n        #[allow(non_snake_case)]\n        impl<$($B: IntoIterator),*> From<($($B,)*)> for Zip<($($B::IntoIter,)*)> {\n            fn from(t: ($($B,)*)) -> Self {\n                let ($($B,)*) = t;\n                Zip { t: ($($B.into_iter(),)*) }\n            }\n        }\n\n        #[allow(non_snake_case)]\n        #[allow(unused_assignments)]\n        impl<$($B),*> Iterator for Zip<($($B,)*)>\n            where\n            $(\n                $B: Iterator,\n            )*\n        {\n            type Item = ($($B::Item,)*);\n\n            fn next(&mut self) -> Option<Self::Item>\n            {\n                let ($(ref mut $B,)*) = self.t;\n\n                // NOTE: Just like iter::Zip, we check the iterators\n                // for None in order. We may finish unevenly (some\n                // iterators gave n + 1 elements, some only n).\n                $(\n                    let $B = match $B.next() {\n                        None => return None,\n                        Some(elt) => elt\n                    };\n                )*\n                Some(($($B,)*))\n            }\n\n            fn size_hint(&self) -> (usize, Option<usize>)\n            {\n                let sh = (::std::usize::MAX, None);\n                let ($(ref $B,)*) = self.t;\n                $(\n                    let sh = size_hint::min($B.size_hint(), sh);\n                )*\n                sh\n            }\n        }\n\n        #[allow(non_snake_case)]\n        impl<$($B),*> ExactSizeIterator for Zip<($($B,)*)> where\n            $(\n                $B: ExactSizeIterator,\n            )*\n        { }\n    );\n}\n\nimpl_zip_iter!(A);\nimpl_zip_iter!(A, B);\nimpl_zip_iter!(A, B, C);\nimpl_zip_iter!(A, B, C, D);\nimpl_zip_iter!(A, B, C, D, E);\nimpl_zip_iter!(A, B, C, D, E, F);\nimpl_zip_iter!(A, B, C, D, E, F, G);\nimpl_zip_iter!(A, B, C, D, E, F, G, H);\n","traces":[{"line":41,"address":[4714208],"length":1,"stats":{"Line":7},"fn_name":"multizip<(itertools::groupbylazy::Group<char, core::str::Chars, closure-3>, itertools::groupbylazy::Group<char, core::str::Chars, closure-3>, itertools::groupbylazy::Group<char, core::str::Chars, closure-3>, itertools::groupbylazy::Group<char, core::str::Chars, closure-3>),(itertools::groupbylazy::Group<char, core::str::Chars, closure-3>, itertools::groupbylazy::Group<char, core::str::Chars, closure-3>, itertools::groupbylazy::Group<char, core::str::Chars, closure-3>, itertools::groupbylazy::Group<char, core::str::Chars, closure-3>)>"},{"line":45,"address":[4288823,4288663,4288743],"length":1,"stats":{"Line":7},"fn_name":null},{"line":52,"address":[5921997,5921856,5922352,5922521,5922848,5923012],"length":1,"stats":{"Line":7},"fn_name":"from<&itertools::rciter_impl::RcIter<quick::Iter<i16, quick::Inexact>>,&itertools::rciter_impl::RcIter<quick::Iter<i16, quick::Inexact>>,quick::Iter<i16, quick::Inexact>>"},{"line":53,"address":[4286506,4287034,4287691],"length":1,"stats":{"Line":7},"fn_name":null},{"line":54,"address":[4713593,4713428],"length":1,"stats":{"Line":7},"fn_name":null},{"line":68,"address":[4284688,4285570,4284220,4285456,4284128,4284788],"length":1,"stats":{"Line":7},"fn_name":"next<core::ops::range::Range<usize>,core::ops::range::Range<i32>,core::ops::range::Range<i8>>"},{"line":70,"address":[4284143,4285471,4284703],"length":1,"stats":{"Line":7},"fn_name":null},{"line":76,"address":[4285830,4285962,4285929,4284352,4286102,4284415,4285682,4284453,4284986,4286171,4284922,4284249,4285106,4285248,4285537,4285797,4286196,4285600,4285139,4286218,4284895,4286240,4285718,4284325,4285024,4284818,4284518,4284543,4284755,4285273,4286064,4284181,4285223],"length":1,"stats":{"Line":39},"fn_name":null},{"line":77,"address":[4284370,4284278,4285156,4285607,4285725,4284256,4285043,4284433,4285980,4285805,4285848,4284359,4286085,4284907,4284825,4284941,4285114,4286118,4284235,4285585,4285736,4284469,4284460,4284929,4284337,4285969,4285700,4285937,4285031,4284848,4285004,4284803,4285837,4286109,4285146,4285629],"length":1,"stats":{"Line":52},"fn_name":null},{"line":78,"address":[4285989,4284943,4285045,4284471,4284282,4284852,4285162,4285633,4284372,4285854,4286123,4285738],"length":1,"stats":{"Line":21},"fn_name":null},{"line":81,"address":[4286267,4284568,4285295],"length":1,"stats":{"Line":5},"fn_name":null},{"line":84,"address":[5921424,5920560,5920992],"length":1,"stats":{"Line":3},"fn_name":"size_hint<quick::Iter<i16, quick::Exact>,quick::Iter<i16, quick::Exact>,quick::Iter<i16, quick::Exact>>"},{"line":86,"address":[5921439,5920575,5921007],"length":1,"stats":{"Line":3},"fn_name":null},{"line":87,"address":[5920613,5921045,5921477],"length":1,"stats":{"Line":3},"fn_name":null},{"line":89,"address":[5920657,5921521,5921089],"length":1,"stats":{"Line":3},"fn_name":null},{"line":91,"address":[5920928,5921360,5921792],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":16,"coverable":16},{"path":["/","home","kms","itertools","tests","adaptors_no_collect.rs"],"content":"use itertools::Itertools;\n\nstruct PanickingCounter {\n    curr: usize,\n    max: usize,\n}\n\nimpl Iterator for PanickingCounter {\n    type Item = ();\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.curr += 1;\n\n        if self.curr == self.max {\n            panic!(\n                \"Input iterator reached maximum of {} suggesting collection by adaptor\",\n                self.max\n            );\n        }\n\n        Some(())\n    }\n}\n\nfn no_collect_test<A, T>(to_adaptor: T)\n    where A: Iterator, T: Fn(PanickingCounter) -> A\n{\n    let counter = PanickingCounter { curr: 0, max: 10_000 };\n    let adaptor = to_adaptor(counter);\n\n    for _ in adaptor.take(5) {}\n}\n\n#[test]\nfn permutations_no_collect() {\n    no_collect_test(|iter| iter.permutations(5))\n}\n\n#[test]\nfn combinations_no_collect() {\n    no_collect_test(|iter| iter.combinations(5))\n}\n\n#[test]\nfn combinations_with_replacement_no_collect() {\n    no_collect_test(|iter| iter.combinations_with_replacement(5))\n}","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[4219852,4219136,4219760,4218412,4218320,4219056],"length":1,"stats":{"Line":3},"fn_name":"no_collect_test<itertools::permutations::Permutations<adaptors_no_collect::PanickingCounter>,closure-0>"},{"line":28,"address":[4218327,4219063,4219767],"length":1,"stats":{"Line":3},"fn_name":null},{"line":29,"address":[4218353,4219089,4219793],"length":1,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[4219612,4219262,4219991,4220341,4219151,4218427,4219867,4218920,4218570],"length":1,"stats":{"Line":6},"fn_name":null},{"line":35,"address":[4247248],"length":1,"stats":{"Line":3},"fn_name":"permutations_no_collect"},{"line":36,"address":[4220512,4220534],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":40,"address":[4220581,4220576],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":41,"address":[4220608,4220630],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":45,"address":[4220677,4220672],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":46,"address":[4220726,4220704],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"}],"covered":13,"coverable":16},{"path":["/","home","kms","itertools","tests","fold_specialization.rs"],"content":"use itertools::Itertools;\n\n#[test]\nfn specialization_intersperse() {\n    let mut iter = (1..2).intersperse(0);\n    iter.clone().for_each(|x| assert_eq!(Some(x), iter.next()));\n\n    let mut iter = (1..3).intersperse(0);\n    iter.clone().for_each(|x| assert_eq!(Some(x), iter.next()));\n\n    let mut iter = (1..4).intersperse(0);\n    iter.clone().for_each(|x| assert_eq!(Some(x), iter.next()));\n}\n","traces":[{"line":4,"address":[4207781,4207776],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":5,"address":[4218457],"length":1,"stats":{"Line":1},"fn_name":null},{"line":6,"address":[4207824,4207808],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":8,"address":[4218564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[4208224,4208208],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":11,"address":[4218664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[4208608,4208624],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"}],"covered":7,"coverable":7},{"path":["/","home","kms","itertools","tests","merge_join.rs"],"content":"use itertools::EitherOrBoth;\nuse itertools::free::merge_join_by;\n\n#[test]\nfn empty() {\n    let left: Vec<u32> = vec![];\n    let right: Vec<u32> = vec![];\n    let expected_result: Vec<EitherOrBoth<u32, u32>> = vec![];\n    let actual_result = merge_join_by(left, right, |l, r| l.cmp(r))\n        .collect::<Vec<_>>();\n    assert_eq!(expected_result, actual_result);\n}\n\n#[test]\nfn left_only() {\n    let left: Vec<u32> = vec![1,2,3];\n    let right: Vec<u32> = vec![];\n    let expected_result: Vec<EitherOrBoth<u32, u32>> = vec![\n        EitherOrBoth::Left(1),\n        EitherOrBoth::Left(2),\n        EitherOrBoth::Left(3)\n    ];\n    let actual_result = merge_join_by(left, right, |l, r| l.cmp(r))\n        .collect::<Vec<_>>();\n    assert_eq!(expected_result, actual_result);\n}\n\n#[test]\nfn right_only() {\n    let left: Vec<u32> = vec![];\n    let right: Vec<u32> = vec![1,2,3];\n    let expected_result: Vec<EitherOrBoth<u32, u32>> = vec![\n        EitherOrBoth::Right(1),\n        EitherOrBoth::Right(2),\n        EitherOrBoth::Right(3)\n    ];\n    let actual_result = merge_join_by(left, right, |l, r| l.cmp(r))\n        .collect::<Vec<_>>();\n    assert_eq!(expected_result, actual_result);\n}\n\n#[test]\nfn first_left_then_right() {\n    let left: Vec<u32> = vec![1,2,3];\n    let right: Vec<u32> = vec![4,5,6];\n    let expected_result: Vec<EitherOrBoth<u32, u32>> = vec![\n        EitherOrBoth::Left(1),\n        EitherOrBoth::Left(2),\n        EitherOrBoth::Left(3),\n        EitherOrBoth::Right(4),\n        EitherOrBoth::Right(5),\n        EitherOrBoth::Right(6)\n    ];\n    let actual_result = merge_join_by(left, right, |l, r| l.cmp(r))\n        .collect::<Vec<_>>();\n    assert_eq!(expected_result, actual_result);\n}\n\n#[test]\nfn first_right_then_left() {\n    let left: Vec<u32> = vec![4,5,6];\n    let right: Vec<u32> = vec![1,2,3];\n    let expected_result: Vec<EitherOrBoth<u32, u32>> = vec![\n        EitherOrBoth::Right(1),\n        EitherOrBoth::Right(2),\n        EitherOrBoth::Right(3),\n        EitherOrBoth::Left(4),\n        EitherOrBoth::Left(5),\n        EitherOrBoth::Left(6)\n    ];\n    let actual_result = merge_join_by(left, right, |l, r| l.cmp(r))\n        .collect::<Vec<_>>();\n    assert_eq!(expected_result, actual_result);\n}\n\n#[test]\nfn interspersed_left_and_right() {\n    let left: Vec<u32> = vec![1,3,5];\n    let right: Vec<u32> = vec![2,4,6];\n    let expected_result: Vec<EitherOrBoth<u32, u32>> = vec![\n        EitherOrBoth::Left(1),\n        EitherOrBoth::Right(2),\n        EitherOrBoth::Left(3),\n        EitherOrBoth::Right(4),\n        EitherOrBoth::Left(5),\n        EitherOrBoth::Right(6)\n    ];\n    let actual_result = merge_join_by(left, right, |l, r| l.cmp(r))\n        .collect::<Vec<_>>();\n    assert_eq!(expected_result, actual_result);\n}\n\n#[test]\nfn overlapping_left_and_right() {\n    let left: Vec<u32> = vec![1,3,4,6];\n    let right: Vec<u32> = vec![2,3,4,5];\n    let expected_result: Vec<EitherOrBoth<u32, u32>> = vec![\n        EitherOrBoth::Left(1),\n        EitherOrBoth::Right(2),\n        EitherOrBoth::Both(3, 3),\n        EitherOrBoth::Both(4, 4),\n        EitherOrBoth::Right(5),\n        EitherOrBoth::Left(6)\n    ];\n    let actual_result = merge_join_by(left, right, |l, r| l.cmp(r))\n        .collect::<Vec<_>>();\n    assert_eq!(expected_result, actual_result);\n}\n","traces":[{"line":5,"address":[4255280,4255336],"length":1,"stats":{"Line":3},"fn_name":"empty"},{"line":6,"address":[4255351,4255291],"length":1,"stats":{"Line":2},"fn_name":null},{"line":7,"address":[4255417,4255368],"length":1,"stats":{"Line":2},"fn_name":null},{"line":8,"address":[4255434],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[4224608,4224627],"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":11,"address":[4255765,4255634],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[4256321,4256240],"length":1,"stats":{"Line":3},"fn_name":"left_only"},{"line":16,"address":[4256247,4256336],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[4256402,4256353],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[4256420,4256491],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4256425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[4256447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[4256469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[4224707,4224688],"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":25,"address":[4256737,4256868],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[4224736,4224741],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":30,"address":[4257355,4257415],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[4257433,4257494],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[4257512,4257583],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[4257517],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[4257539],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[4257561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[4224787,4224768],"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":39,"address":[4257960,4257829],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4224816,4224821],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":44,"address":[4258439,4258528],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[4258607,4258546],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[4258625,4258762],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[4258630],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[4258652],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[4258674],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[4258696],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[4258718],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[4258740],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[4224867,4224848],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":56,"address":[4259205,4259074],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4224901,4224896],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":61,"address":[4259687,4259776],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[4259855,4259794],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[4260010,4259873],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[4259878],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[4259900],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[4259922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[4259944],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[4259966],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[4259988],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[4224928,4224947],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":73,"address":[4260322,4260453],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[4224976,4224981],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":78,"address":[4260935,4261024],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[4261042,4261103],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[4261121,4261258],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[4261126],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[4261148],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[4261170],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[4261192],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[4261214],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[4261236],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[4225008,4225027],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":90,"address":[4261701,4261570],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[4225056,4225061],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":95,"address":[4262279,4262183],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[4262297,4262373],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[4262391,4262550],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[4262396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[4262418],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[4262440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[4262473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[4262506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[4262528],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[4225088,4225107],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":107,"address":[4262993,4262862],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":72,"coverable":72},{"path":["/","home","kms","itertools","tests","peeking_take_while.rs"],"content":"use itertools::Itertools;\nuse itertools::{put_back, put_back_n};\n\n#[test]\nfn peeking_take_while_peekable() {\n    let mut r = (0..10).peekable();\n    r.peeking_take_while(|x| *x <= 3).count();\n    assert_eq!(r.next(), Some(4));\n}\n\n#[test]\nfn peeking_take_while_put_back() {\n    let mut r = put_back(0..10);\n    r.peeking_take_while(|x| *x <= 3).count();\n    assert_eq!(r.next(), Some(4));\n    r.peeking_take_while(|_| true).count();\n    assert_eq!(r.next(), None);\n}\n\n#[test]\nfn peeking_take_while_put_back_n() {\n    let mut r = put_back_n(6..10);\n    for elt in (0..6).rev() {\n        r.put_back(elt);\n    }\n    r.peeking_take_while(|x| *x <= 3).count();\n    assert_eq!(r.next(), Some(4));\n    r.peeking_take_while(|_| true).count();\n    assert_eq!(r.next(), None);\n}\n\n#[test]\nfn peeking_take_while_slice_iter() {\n    let v = [1, 2, 3, 4, 5, 6];\n    let mut r = v.iter();\n    r.peeking_take_while(|x| **x <= 3).count();\n    assert_eq!(r.next(), Some(&4));\n    r.peeking_take_while(|_| true).count();\n    assert_eq!(r.next(), None);\n}\n\n#[test]\nfn peeking_take_while_slice_iter_rev() {\n    let v = [1, 2, 3, 4, 5, 6];\n    let mut r = v.iter().rev();\n    r.peeking_take_while(|x| **x >= 3).count();\n    assert_eq!(r.next(), Some(&2));\n    r.peeking_take_while(|_| true).count();\n    assert_eq!(r.next(), None);\n}\n","traces":[{"line":5,"address":[4232800],"length":1,"stats":{"Line":3},"fn_name":"peeking_take_while_peekable"},{"line":6,"address":[4232807],"length":1,"stats":{"Line":1},"fn_name":null},{"line":7,"address":[4208381,4208368],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":8,"address":[4232871,4232963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[4208421,4208416],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":13,"address":[4233239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[4233273],"length":1,"stats":{"Line":3},"fn_name":null},{"line":15,"address":[4233303,4233434],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[4208521,4208496,4208509],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":17,"address":[4233728,4233853],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[4208533,4208528],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":22,"address":[4234151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[4234217,4234450,4234331,4234516],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[4234494],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[4208560,4208573],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":27,"address":[4234544,4234716],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[4208633,4208621,4208608],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":29,"address":[4235038,4235193],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[4208645,4208640],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":34,"address":[4235527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[4235585],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[4208672,4208685],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":37,"address":[4235764,4235628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[4208733,4208720,4208745],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":39,"address":[4236177,4236053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4208752,4208757],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":44,"address":[4236471],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[4236525],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[4208784,4208797],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":47,"address":[4236612,4236754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[4208857,4208832,4208845],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":49,"address":[4237170,4237043],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":32,"coverable":32},{"path":["/","home","kms","itertools","tests","quick.rs"],"content":"//! The purpose of these tests is to cover corner cases of iterators\n//! and adaptors.\n//!\n//! In particular we test the tedious size_hint and exact size correctness.\n\nuse quickcheck as qc;\nuse std::default::Default;\nuse std::ops::Range;\nuse std::cmp::{max, min, Ordering};\nuse std::collections::HashSet;\nuse itertools::Itertools;\nuse itertools::{\n    multizip,\n    EitherOrBoth,\n    iproduct,\n    izip,\n};\nuse itertools::free::{\n    cloned,\n    enumerate,\n    multipeek,\n    peek_nth,\n    put_back,\n    put_back_n,\n    rciter,\n    zip,\n    zip_eq,\n};\n\nuse rand::Rng;\nuse rand::seq::SliceRandom;\nuse quickcheck::TestResult;\n\n/// Trait for size hint modifier types\ntrait HintKind: Copy + Send + qc::Arbitrary {\n    fn loosen_bounds(&self, org_hint: (usize, Option<usize>)) -> (usize, Option<usize>);\n}\n\n/// Exact size hint variant that leaves hints unchanged\n#[derive(Clone, Copy, Debug)]\nstruct Exact {}\n\nimpl HintKind for Exact {\n    fn loosen_bounds(&self, org_hint: (usize, Option<usize>)) -> (usize, Option<usize>) {\n        org_hint\n    }\n}\n\nimpl qc::Arbitrary for Exact {\n    fn arbitrary<G: qc::Gen>(_: &mut G) -> Self {\n        Exact {}\n    }\n}\n\n/// Inexact size hint variant to simulate imprecise (but valid) size hints\n///\n/// Will always decrease the lower bound and increase the upper bound\n/// of the size hint by set amounts.\n#[derive(Clone, Copy, Debug)]\nstruct Inexact {\n    underestimate: usize,\n    overestimate: usize,\n}\n\nimpl HintKind for Inexact {\n    fn loosen_bounds(&self, org_hint: (usize, Option<usize>)) -> (usize, Option<usize>) {\n        let (org_lower, org_upper) = org_hint;\n        (org_lower.saturating_sub(self.underestimate),\n         org_upper.and_then(move |x| x.checked_add(self.overestimate)))\n    }\n}\n\nimpl qc::Arbitrary for Inexact {\n    fn arbitrary<G: qc::Gen>(g: &mut G) -> Self {\n        let ue_value = usize::arbitrary(g);\n        let oe_value = usize::arbitrary(g);\n        // Compensate for quickcheck using extreme values too rarely\n        let ue_choices = &[0, ue_value, usize::max_value()];\n        let oe_choices = &[0, oe_value, usize::max_value()];\n        Inexact {\n            underestimate: *ue_choices.choose(g).unwrap(),\n            overestimate: *oe_choices.choose(g).unwrap(),\n        }\n    }\n\n    fn shrink(&self) -> Box<dyn Iterator<Item=Self>> {\n        let underestimate_value = self.underestimate;\n        let overestimate_value = self.overestimate;\n        Box::new(\n            underestimate_value.shrink().flat_map(move |ue_value|\n                overestimate_value.shrink().map(move |oe_value|\n                    Inexact {\n                        underestimate: ue_value,\n                        overestimate: oe_value,\n                    }\n                )\n            )\n        )\n    }\n}\n\n/// Our base iterator that we can impl Arbitrary for\n///\n/// By default we'll return inexact bounds estimates for size_hint\n/// to make tests harder to pass.\n///\n/// NOTE: Iter is tricky and is not fused, to help catch bugs.\n/// At the end it will return None once, then return Some(0),\n/// then return None again.\n#[derive(Clone, Debug)]\nstruct Iter<T, SK: HintKind = Inexact> {\n    iterator: Range<T>,\n    // fuse/done flag\n    fuse_flag: i32,\n    hint_kind: SK,\n}\n\nimpl<T, HK> Iter<T, HK> where HK: HintKind\n{\n    fn new(it: Range<T>, hint_kind: HK) -> Self {\n        Iter {\n            iterator: it,\n            fuse_flag: 0,\n            hint_kind,\n        }\n    }\n}\n\nimpl<T, HK> Iterator for Iter<T, HK>\n    where Range<T>: Iterator,\n          <Range<T> as Iterator>::Item: Default,\n          HK: HintKind,\n{\n    type Item = <Range<T> as Iterator>::Item;\n\n    fn next(&mut self) -> Option<Self::Item>\n    {\n        let elt = self.iterator.next();\n        if elt.is_none() {\n            self.fuse_flag += 1;\n            // check fuse flag\n            if self.fuse_flag == 2 {\n                return Some(Default::default())\n            }\n        }\n        elt\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>)\n    {\n        let org_hint = self.iterator.size_hint();\n        self.hint_kind.loosen_bounds(org_hint)\n    }\n}\n\nimpl<T, HK> DoubleEndedIterator for Iter<T, HK>\n    where Range<T>: DoubleEndedIterator,\n          <Range<T> as Iterator>::Item: Default,\n          HK: HintKind\n{\n    fn next_back(&mut self) -> Option<Self::Item> { self.iterator.next_back() }\n}\n\nimpl<T> ExactSizeIterator for Iter<T, Exact> where Range<T>: ExactSizeIterator,\n    <Range<T> as Iterator>::Item: Default,\n{ }\n\nimpl<T, HK> qc::Arbitrary for Iter<T, HK>\n    where T: qc::Arbitrary,\n          HK: HintKind,\n{\n    fn arbitrary<G: qc::Gen>(g: &mut G) -> Self\n    {\n        Iter::new(T::arbitrary(g)..T::arbitrary(g), HK::arbitrary(g))\n    }\n\n    fn shrink(&self) -> Box<dyn Iterator<Item=Iter<T, HK>>>\n    {\n        let r = self.iterator.clone();\n        let hint_kind = self.hint_kind;\n        Box::new(\n            r.start.shrink().flat_map(move |a|\n                r.end.shrink().map(move |b|\n                    Iter::new(a.clone()..b, hint_kind)\n                )\n            )\n        )\n    }\n}\n\n/// A meta-iterator which yields `Iter<i32>`s whose start/endpoints are\n/// increased or decreased linearly on each iteration.\n#[derive(Clone, Debug)]\nstruct ShiftRange<HK = Inexact> {\n    range_start: i32,\n    range_end: i32,\n    start_step: i32,\n    end_step: i32,\n    iter_count: u32,\n    hint_kind: HK,\n}\n\nimpl<HK> Iterator for ShiftRange<HK> where HK: HintKind {\n    type Item = Iter<i32, HK>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.iter_count == 0 {\n            return None;\n        }\n\n        let iter = Iter::new(self.range_start..self.range_end, self.hint_kind);\n\n        self.range_start += self.start_step;\n        self.range_end += self.end_step;\n        self.iter_count -= 1;\n\n        Some(iter)\n    }\n}\n\nimpl ExactSizeIterator for ShiftRange<Exact> { }\n\nimpl<HK> qc::Arbitrary for ShiftRange<HK>\n    where HK: HintKind\n{\n    fn arbitrary<G: qc::Gen>(g: &mut G) -> Self {\n        const MAX_STARTING_RANGE_DIFF: i32 = 32;\n        const MAX_STEP_MODULO: i32 = 8;\n        const MAX_ITER_COUNT: u32 = 3;\n\n        let range_start = qc::Arbitrary::arbitrary(g);\n        let range_end = range_start + g.gen_range(0, MAX_STARTING_RANGE_DIFF + 1);\n        let start_step = g.gen_range(-MAX_STEP_MODULO, MAX_STEP_MODULO + 1);\n        let end_step = g.gen_range(-MAX_STEP_MODULO, MAX_STEP_MODULO + 1);\n        let iter_count = g.gen_range(0, MAX_ITER_COUNT + 1);\n        let hint_kind = qc::Arbitrary::arbitrary(g);\n\n        ShiftRange {\n            range_start,\n            range_end,\n            start_step,\n            end_step,\n            iter_count,\n            hint_kind,\n        }\n    }\n}\n\nfn correct_count<I, F>(get_it: F) -> bool\nwhere\n    I: Iterator,\n    F: Fn() -> I\n{\n    let mut counts = vec![get_it().count()];\n\n    'outer: loop {\n        let mut it = get_it();\n\n        for _ in 0..(counts.len() - 1) {\n            if let None = it.next() {\n                panic!(\"Iterator shouldn't be finished, may not be deterministic\");\n            }\n        }\n\n        if let None = it.next() {\n            break 'outer;\n        }\n\n        counts.push(it.count());\n    }\n\n    let total_actual_count = counts.len() - 1;\n\n    for (i, returned_count) in counts.into_iter().enumerate() {\n        let actual_count = total_actual_count - i;\n        if actual_count != returned_count {\n            println!(\"Total iterations: {} True count: {} returned count: {}\", i, actual_count, returned_count);\n\n            return false;\n        }\n    }\n\n    true\n}\n\nfn correct_size_hint<I: Iterator>(mut it: I) -> bool {\n    // record size hint at each iteration\n    let initial_hint = it.size_hint();\n    let mut hints = Vec::with_capacity(initial_hint.0 + 1);\n    hints.push(initial_hint);\n    while let Some(_) = it.next() {\n        hints.push(it.size_hint())\n    }\n\n    let mut true_count = hints.len(); // start off +1 too much\n\n    // check all the size hints\n    for &(low, hi) in &hints {\n        true_count -= 1;\n        if low > true_count ||\n            (hi.is_some() && hi.unwrap() < true_count)\n        {\n            println!(\"True size: {:?}, size hint: {:?}\", true_count, (low, hi));\n            //println!(\"All hints: {:?}\", hints);\n            return false\n        }\n    }\n    true\n}\n\nfn exact_size<I: ExactSizeIterator>(mut it: I) -> bool {\n    // check every iteration\n    let (mut low, mut hi) = it.size_hint();\n    if Some(low) != hi { return false; }\n    while let Some(_) = it.next() {\n        let (xlow, xhi) = it.size_hint();\n        if low != xlow + 1 { return false; }\n        low = xlow;\n        hi = xhi;\n        if Some(low) != hi { return false; }\n    }\n    let (low, hi) = it.size_hint();\n    low == 0 && hi == Some(0)\n}\n\n// Exact size for this case, without ExactSizeIterator\nfn exact_size_for_this<I: Iterator>(mut it: I) -> bool {\n    // check every iteration\n    let (mut low, mut hi) = it.size_hint();\n    if Some(low) != hi { return false; }\n    while let Some(_) = it.next() {\n        let (xlow, xhi) = it.size_hint();\n        if low != xlow + 1 { return false; }\n        low = xlow;\n        hi = xhi;\n        if Some(low) != hi { return false; }\n    }\n    let (low, hi) = it.size_hint();\n    low == 0 && hi == Some(0)\n}\n\n/*\n * NOTE: Range<i8> is broken!\n * (all signed ranges are)\n#[quickcheck]\nfn size_range_i8(a: Iter<i8>) -> bool {\n    exact_size(a)\n}\n\n#[quickcheck]\nfn size_range_i16(a: Iter<i16>) -> bool {\n    exact_size(a)\n}\n\n#[quickcheck]\nfn size_range_u8(a: Iter<u8>) -> bool {\n    exact_size(a)\n}\n */\n\nmacro_rules! quickcheck {\n    // accept several property function definitions\n    // The property functions can use pattern matching and `mut` as usual\n    // in the function arguments, but the functions can not be generic.\n    {$($(#$attr:tt)* fn $fn_name:ident($($arg:tt)*) -> $ret:ty { $($code:tt)* })*} => (\n        $(\n            #[test]\n            $(#$attr)*\n            fn $fn_name() {\n                fn prop($($arg)*) -> $ret {\n                    $($code)*\n                }\n                ::quickcheck::quickcheck(quickcheck!(@fn prop [] $($arg)*));\n            }\n        )*\n    );\n    // parse argument list (with patterns allowed) into prop as fn(_, _) -> _\n    (@fn $f:ident [$($t:tt)*]) => {\n        $f as fn($($t),*) -> _\n    };\n    (@fn $f:ident [$($p:tt)*] : $($tail:tt)*) => {\n        quickcheck!(@fn $f [$($p)* _] $($tail)*)\n    };\n    (@fn $f:ident [$($p:tt)*] $t:tt $($tail:tt)*) => {\n        quickcheck!(@fn $f [$($p)*] $($tail)*)\n    };\n}\n\nquickcheck! {\n\n    fn size_product(a: Iter<u16>, b: Iter<u16>) -> bool {\n        correct_size_hint(a.cartesian_product(b))\n    }\n    fn size_product3(a: Iter<u16>, b: Iter<u16>, c: Iter<u16>) -> bool {\n        correct_size_hint(iproduct!(a, b, c))\n    }\n\n    fn correct_cartesian_product3(a: Iter<u16>, b: Iter<u16>, c: Iter<u16>,\n                                  take_manual: usize) -> ()\n    {\n        // test correctness of iproduct through regular iteration (take)\n        // and through fold.\n        let ac = a.clone();\n        let br = &b.clone();\n        let cr = &c.clone();\n        let answer: Vec<_> = ac.flat_map(move |ea| br.clone().flat_map(move |eb| cr.clone().map(move |ec| (ea, eb, ec)))).collect();\n        let mut product_iter = iproduct!(a, b, c);\n        let mut actual = Vec::new();\n\n        actual.extend((&mut product_iter).take(take_manual));\n        if actual.len() == take_manual {\n            product_iter.fold((), |(), elt| actual.push(elt));\n        }\n        assert_eq!(answer, actual);\n    }\n\n    fn size_multi_product(a: ShiftRange) -> bool {\n        correct_size_hint(a.multi_cartesian_product())\n    }\n    fn correct_multi_product3(a: ShiftRange, take_manual: usize) -> () {\n        // Fix no. of iterators at 3\n        let a = ShiftRange { iter_count: 3, ..a };\n\n        // test correctness of MultiProduct through regular iteration (take)\n        // and through fold.\n        let mut iters = a.clone();\n        let i0 = iters.next().unwrap();\n        let i1r = &iters.next().unwrap();\n        let i2r = &iters.next().unwrap();\n        let answer: Vec<_> = i0.flat_map(move |ei0| i1r.clone().flat_map(move |ei1| i2r.clone().map(move |ei2| vec![ei0, ei1, ei2]))).collect();\n        let mut multi_product = a.clone().multi_cartesian_product();\n        let mut actual = Vec::new();\n\n        actual.extend((&mut multi_product).take(take_manual));\n        if actual.len() == take_manual {\n            multi_product.fold((), |(), elt| actual.push(elt));\n        }\n        assert_eq!(answer, actual);\n\n        assert_eq!(answer.into_iter().last(), a.clone().multi_cartesian_product().last());\n    }\n\n    #[allow(deprecated)]\n    fn size_step(a: Iter<i16, Exact>, s: usize) -> bool {\n        let mut s = s;\n        if s == 0 {\n            s += 1; // never zero\n        }\n        let filt = a.clone().dedup();\n        correct_size_hint(filt.step(s)) &&\n            exact_size(a.step(s))\n    }\n\n    #[allow(deprecated)]\n    fn equal_step(a: Iter<i16>, s: usize) -> bool {\n        let mut s = s;\n        if s == 0 {\n            s += 1; // never zero\n        }\n        let mut i = 0;\n        itertools::equal(a.clone().step(s), a.filter(|_| {\n            let keep = i % s == 0;\n            i += 1;\n            keep\n        }))\n    }\n\n    #[allow(deprecated)]\n    fn equal_step_vec(a: Vec<i16>, s: usize) -> bool {\n        let mut s = s;\n        if s == 0 {\n            s += 1; // never zero\n        }\n        let mut i = 0;\n        itertools::equal(a.iter().step(s), a.iter().filter(|_| {\n            let keep = i % s == 0;\n            i += 1;\n            keep\n        }))\n    }\n\n    fn size_multipeek(a: Iter<u16, Exact>, s: u8) -> bool {\n        let mut it = multipeek(a);\n        // peek a few times\n        for _ in 0..s {\n            it.peek();\n        }\n        exact_size(it)\n    }\n\n    fn size_peek_nth(a: Iter<u16, Exact>, s: u8) -> bool {\n        let mut it = peek_nth(a);\n        // peek a few times\n        for n in 0..s {\n            it.peek_nth(n as usize);\n        }\n        exact_size(it)\n    }\n\n    fn equal_merge(a: Vec<i16>, b: Vec<i16>) -> bool {\n        let mut sa = a.clone();\n        let mut sb = b.clone();\n        sa.sort();\n        sb.sort();\n        let mut merged = sa.clone();\n        merged.extend(sb.iter().cloned());\n        merged.sort();\n        itertools::equal(&merged, sa.iter().merge(&sb))\n    }\n    fn size_merge(a: Iter<u16>, b: Iter<u16>) -> bool {\n        correct_size_hint(a.merge(b))\n    }\n    fn size_zip(a: Iter<i16, Exact>, b: Iter<i16, Exact>, c: Iter<i16, Exact>) -> bool {\n        let filt = a.clone().dedup();\n        correct_size_hint(multizip((filt, b.clone(), c.clone()))) &&\n            exact_size(multizip((a, b, c)))\n    }\n    fn size_zip_rc(a: Iter<i16>, b: Iter<i16>) -> bool {\n        let rc = rciter(a.clone());\n        correct_size_hint(multizip((&rc, &rc, b)))\n    }\n\n    fn size_zip_macro(a: Iter<i16, Exact>, b: Iter<i16, Exact>, c: Iter<i16, Exact>) -> bool {\n        let filt = a.clone().dedup();\n        correct_size_hint(izip!(filt, b.clone(), c.clone())) &&\n            exact_size(izip!(a, b, c))\n    }\n    fn equal_kmerge(a: Vec<i16>, b: Vec<i16>, c: Vec<i16>) -> bool {\n        use itertools::free::kmerge;\n        let mut sa = a.clone();\n        let mut sb = b.clone();\n        let mut sc = c.clone();\n        sa.sort();\n        sb.sort();\n        sc.sort();\n        let mut merged = sa.clone();\n        merged.extend(sb.iter().cloned());\n        merged.extend(sc.iter().cloned());\n        merged.sort();\n        itertools::equal(merged.into_iter(), kmerge(vec![sa, sb, sc]))\n    }\n\n    // Any number of input iterators\n    fn equal_kmerge_2(mut inputs: Vec<Vec<i16>>) -> bool {\n        use itertools::free::kmerge;\n        // sort the inputs\n        for input in &mut inputs {\n            input.sort();\n        }\n        let mut merged = inputs.concat();\n        merged.sort();\n        itertools::equal(merged.into_iter(), kmerge(inputs))\n    }\n\n    // Any number of input iterators\n    fn equal_kmerge_by_ge(mut inputs: Vec<Vec<i16>>) -> bool {\n        // sort the inputs\n        for input in &mut inputs {\n            input.sort();\n            input.reverse();\n        }\n        let mut merged = inputs.concat();\n        merged.sort();\n        merged.reverse();\n        itertools::equal(merged.into_iter(),\n                         inputs.into_iter().kmerge_by(|x, y| x >= y))\n    }\n\n    // Any number of input iterators\n    fn equal_kmerge_by_lt(mut inputs: Vec<Vec<i16>>) -> bool {\n        // sort the inputs\n        for input in &mut inputs {\n            input.sort();\n        }\n        let mut merged = inputs.concat();\n        merged.sort();\n        itertools::equal(merged.into_iter(),\n                         inputs.into_iter().kmerge_by(|x, y| x < y))\n    }\n\n    // Any number of input iterators\n    fn equal_kmerge_by_le(mut inputs: Vec<Vec<i16>>) -> bool {\n        // sort the inputs\n        for input in &mut inputs {\n            input.sort();\n        }\n        let mut merged = inputs.concat();\n        merged.sort();\n        itertools::equal(merged.into_iter(),\n                         inputs.into_iter().kmerge_by(|x, y| x <= y))\n    }\n    fn size_kmerge(a: Iter<i16>, b: Iter<i16>, c: Iter<i16>) -> bool {\n        use itertools::free::kmerge;\n        correct_size_hint(kmerge(vec![a, b, c]))\n    }\n    fn equal_zip_eq(a: Vec<i32>, b: Vec<i32>) -> bool {\n        let len = std::cmp::min(a.len(), b.len());\n        let a = &a[..len];\n        let b = &b[..len];\n        itertools::equal(zip_eq(a, b), zip(a, b))\n    }\n    fn size_zip_longest(a: Iter<i16, Exact>, b: Iter<i16, Exact>) -> bool {\n        let filt = a.clone().dedup();\n        let filt2 = b.clone().dedup();\n        correct_size_hint(filt.zip_longest(b.clone())) &&\n        correct_size_hint(a.clone().zip_longest(filt2)) &&\n            exact_size(a.zip_longest(b))\n    }\n    fn size_2_zip_longest(a: Iter<i16>, b: Iter<i16>) -> bool {\n        let it = a.clone().zip_longest(b.clone());\n        let jt = a.clone().zip_longest(b.clone());\n        itertools::equal(a.clone(),\n                         it.filter_map(|elt| match elt {\n                             EitherOrBoth::Both(x, _) => Some(x),\n                             EitherOrBoth::Left(x) => Some(x),\n                             _ => None,\n                         }\n                         ))\n            &&\n        itertools::equal(b.clone(),\n                         jt.filter_map(|elt| match elt {\n                             EitherOrBoth::Both(_, y) => Some(y),\n                             EitherOrBoth::Right(y) => Some(y),\n                             _ => None,\n                         }\n                         ))\n    }\n    fn size_interleave(a: Iter<i16>, b: Iter<i16>) -> bool {\n        correct_size_hint(a.interleave(b))\n    }\n    fn exact_interleave(a: Iter<i16, Exact>, b: Iter<i16, Exact>) -> bool {\n        exact_size_for_this(a.interleave(b))\n    }\n    fn size_interleave_shortest(a: Iter<i16>, b: Iter<i16>) -> bool {\n        correct_size_hint(a.interleave_shortest(b))\n    }\n    fn exact_interleave_shortest(a: Vec<()>, b: Vec<()>) -> bool {\n        exact_size_for_this(a.iter().interleave_shortest(&b))\n    }\n    fn size_intersperse(a: Iter<i16>, x: i16) -> bool {\n        correct_size_hint(a.intersperse(x))\n    }\n    fn equal_intersperse(a: Vec<i32>, x: i32) -> bool {\n        let mut inter = false;\n        let mut i = 0;\n        for elt in a.iter().cloned().intersperse(x) {\n            if inter {\n                if elt != x { return false }\n            } else {\n                if elt != a[i] { return false }\n                i += 1;\n            }\n            inter = !inter;\n        }\n        true\n    }\n\n    fn equal_combinations_2(a: Vec<u8>) -> bool {\n        let mut v = Vec::new();\n        for (i, x) in enumerate(&a) {\n            for y in &a[i + 1..] {\n                v.push((x, y));\n            }\n        }\n        itertools::equal(a.iter().tuple_combinations::<(_, _)>(), v)\n    }\n\n    fn collect_tuple_matches_size(a: Iter<i16>) -> bool {\n        let size = a.clone().count();\n        a.collect_tuple::<(_, _, _)>().is_some() == (size == 3)\n    }\n\n    fn correct_permutations(vals: HashSet<i32>, k: usize) -> () {\n        // Test permutations only on iterators of distinct integers, to prevent\n        // false positives.\n\n        const MAX_N: usize = 5;\n\n        let n = min(vals.len(), MAX_N);\n        let vals: HashSet<i32> = vals.into_iter().take(n).collect();\n\n        let perms = vals.iter().permutations(k);\n\n        let mut actual = HashSet::new();\n\n        for perm in perms {\n            assert_eq!(perm.len(), k);\n\n            let all_items_valid = perm.iter().all(|p| vals.contains(p));\n            assert!(all_items_valid, \"perm contains value not from input: {:?}\", perm);\n\n            // Check that all perm items are distinct\n            let distinct_len = {\n                let perm_set: HashSet<_> = perm.iter().collect();\n                perm_set.len()\n            };\n            assert_eq!(perm.len(), distinct_len);\n\n            // Check that the perm is new\n            assert!(actual.insert(perm.clone()), \"perm already encountered: {:?}\", perm);\n        }\n    }\n\n    fn permutations_lexic_order(a: usize, b: usize) -> () {\n        let a = a % 6;\n        let b = b % 6;\n\n        let n = max(a, b);\n        let k = min (a, b);\n\n        let expected_first: Vec<usize> = (0..k).collect();\n        let expected_last: Vec<usize> = ((n - k)..n).rev().collect();\n\n        let mut perms = (0..n).permutations(k);\n\n        let mut curr_perm = match perms.next() {\n            Some(p) => p,\n            None => { return; }\n        };\n\n        assert_eq!(expected_first, curr_perm);\n\n        while let Some(next_perm) = perms.next() {\n            assert!(\n                next_perm > curr_perm,\n                \"next perm isn't greater-than current; next_perm={:?} curr_perm={:?} n={}\",\n                next_perm, curr_perm, n\n            );\n\n            curr_perm = next_perm;\n        }\n\n        assert_eq!(expected_last, curr_perm);\n\n    }\n\n    fn permutations_count(n: usize, k: usize) -> bool {\n        let n = n % 6;\n\n        correct_count(|| (0..n).permutations(k))\n    }\n\n    fn permutations_size(a: Iter<i32>, k: usize) -> bool {\n        correct_size_hint(a.take(5).permutations(k))\n    }\n\n    fn permutations_k0_yields_once(n: usize) -> () {\n        let k = 0;\n        let expected: Vec<Vec<usize>> = vec![vec![]];\n        let actual = (0..n).permutations(k).collect_vec();\n\n        assert_eq!(expected, actual);\n    }\n}\n\nquickcheck! {\n    fn equal_dedup(a: Vec<i32>) -> bool {\n        let mut b = a.clone();\n        b.dedup();\n        itertools::equal(&b, a.iter().dedup())\n    }\n}\n\nquickcheck! {\n    fn equal_dedup_by(a: Vec<(i32, i32)>) -> bool {\n        let mut b = a.clone();\n        b.dedup_by(|x, y| x.0==y.0);\n        itertools::equal(&b, a.iter().dedup_by(|x, y| x.0==y.0))\n    }\n}\n\nquickcheck! {\n    fn size_dedup(a: Vec<i32>) -> bool {\n        correct_size_hint(a.iter().dedup())\n    }\n}\n\nquickcheck! {\n    fn size_dedup_by(a: Vec<(i32, i32)>) -> bool {\n        correct_size_hint(a.iter().dedup_by(|x, y| x.0==y.0))\n    }\n}\n\nquickcheck! {\n    fn exact_repeatn((n, x): (usize, i32)) -> bool {\n        let it = itertools::repeat_n(x, n);\n        exact_size(it)\n    }\n}\n\nquickcheck! {\n    fn size_put_back(a: Vec<u8>, x: Option<u8>) -> bool {\n        let mut it = put_back(a.into_iter());\n        match x {\n            Some(t) => it.put_back(t),\n            None => {}\n        }\n        correct_size_hint(it)\n    }\n}\n\nquickcheck! {\n    fn size_put_backn(a: Vec<u8>, b: Vec<u8>) -> bool {\n        let mut it = put_back_n(a.into_iter());\n        for elt in b {\n            it.put_back(elt)\n        }\n        correct_size_hint(it)\n    }\n}\n\nquickcheck! {\n    fn size_tee(a: Vec<u8>) -> bool {\n        let (mut t1, mut t2) = a.iter().tee();\n        t1.next();\n        t1.next();\n        t2.next();\n        exact_size(t1) && exact_size(t2)\n    }\n}\n\nquickcheck! {\n    fn size_tee_2(a: Vec<u8>) -> bool {\n        let (mut t1, mut t2) = a.iter().dedup().tee();\n        t1.next();\n        t1.next();\n        t2.next();\n        correct_size_hint(t1) && correct_size_hint(t2)\n    }\n}\n\nquickcheck! {\n    fn size_take_while_ref(a: Vec<u8>, stop: u8) -> bool {\n        correct_size_hint(a.iter().take_while_ref(|x| **x != stop))\n    }\n}\n\nquickcheck! {\n    fn equal_partition(a: Vec<i32>) -> bool {\n        let mut a = a;\n        let mut ap = a.clone();\n        let split_index = itertools::partition(&mut ap, |x| *x >= 0);\n        let parted = (0..split_index).all(|i| ap[i] >= 0) &&\n            (split_index..a.len()).all(|i| ap[i] < 0);\n\n        a.sort();\n        ap.sort();\n        parted && (a == ap)\n    }\n}\n\nquickcheck! {\n    fn size_combinations(it: Iter<i16>) -> bool {\n        correct_size_hint(it.tuple_combinations::<(_, _)>())\n    }\n}\n\nquickcheck! {\n    fn equal_combinations(it: Iter<i16>) -> bool {\n        let values = it.clone().collect_vec();\n        let mut cmb = it.tuple_combinations();\n        for i in 0..values.len() {\n            for j in i+1..values.len() {\n                let pair = (values[i], values[j]);\n                if pair != cmb.next().unwrap() {\n                    return false;\n                }\n            }\n        }\n        cmb.next() == None\n    }\n}\n\nquickcheck! {\n    fn size_pad_tail(it: Iter<i8>, pad: u8) -> bool {\n        correct_size_hint(it.clone().pad_using(pad as usize, |_| 0)) &&\n            correct_size_hint(it.dropping(1).rev().pad_using(pad as usize, |_| 0))\n    }\n}\n\nquickcheck! {\n    fn size_pad_tail2(it: Iter<i8, Exact>, pad: u8) -> bool {\n        exact_size(it.pad_using(pad as usize, |_| 0))\n    }\n}\n\nquickcheck! {\n    fn size_unique(it: Iter<i8>) -> bool {\n        correct_size_hint(it.unique())\n    }\n\n    fn count_unique(it: Vec<i8>, take_first: u8) -> () {\n        let answer = {\n            let mut v = it.clone();\n            v.sort(); v.dedup();\n            v.len()\n        };\n        let mut iter = cloned(&it).unique();\n        let first_count = (&mut iter).take(take_first as usize).count();\n        let rest_count = iter.count();\n        assert_eq!(answer, first_count + rest_count);\n    }\n}\n\nquickcheck! {\n    fn fuzz_group_by_lazy_1(it: Iter<u8>) -> bool {\n        let jt = it.clone();\n        let groups = it.group_by(|k| *k);\n        let res = itertools::equal(jt, groups.into_iter().flat_map(|(_, x)| x));\n        res\n    }\n}\n\nquickcheck! {\n    fn fuzz_group_by_lazy_2(data: Vec<u8>) -> bool {\n        let groups = data.iter().group_by(|k| *k / 10);\n        let res = itertools::equal(data.iter(), groups.into_iter().flat_map(|(_, x)| x));\n        res\n    }\n}\n\nquickcheck! {\n    fn fuzz_group_by_lazy_3(data: Vec<u8>) -> bool {\n        let grouper = data.iter().group_by(|k| *k / 10);\n        let groups = grouper.into_iter().collect_vec();\n        let res = itertools::equal(data.iter(), groups.into_iter().flat_map(|(_, x)| x));\n        res\n    }\n}\n\nquickcheck! {\n    fn fuzz_group_by_lazy_duo(data: Vec<u8>, order: Vec<(bool, bool)>) -> bool {\n        let grouper = data.iter().group_by(|k| *k / 3);\n        let mut groups1 = grouper.into_iter();\n        let mut groups2 = grouper.into_iter();\n        let mut elts = Vec::<&u8>::new();\n        let mut old_groups = Vec::new();\n\n        let tup1 = |(_, b)| b;\n        for &(ord, consume_now) in &order {\n            let iter = &mut [&mut groups1, &mut groups2][ord as usize];\n            match iter.next() {\n                Some((_, gr)) => if consume_now {\n                    for og in old_groups.drain(..) {\n                        elts.extend(og);\n                    }\n                    elts.extend(gr);\n                } else {\n                    old_groups.push(gr);\n                },\n                None => break,\n            }\n        }\n        for og in old_groups.drain(..) {\n            elts.extend(og);\n        }\n        for gr in groups1.map(&tup1) { elts.extend(gr); }\n        for gr in groups2.map(&tup1) { elts.extend(gr); }\n        itertools::assert_equal(&data, elts);\n        true\n    }\n}\n\nquickcheck! {\n    fn equal_chunks_lazy(a: Vec<u8>, size: u8) -> bool {\n        let mut size = size;\n        if size == 0 {\n            size += 1;\n        }\n        let chunks = a.iter().chunks(size as usize);\n        let it = a.chunks(size as usize);\n        for (a, b) in chunks.into_iter().zip(it) {\n            if !itertools::equal(a, b) {\n                return false;\n            }\n        }\n        true\n    }\n}\n\nquickcheck! {\n    fn equal_tuple_windows_1(a: Vec<u8>) -> bool {\n        let x = a.windows(1).map(|s| (&s[0], ));\n        let y = a.iter().tuple_windows::<(_,)>();\n        itertools::equal(x, y)\n    }\n\n    fn equal_tuple_windows_2(a: Vec<u8>) -> bool {\n        let x = a.windows(2).map(|s| (&s[0], &s[1]));\n        let y = a.iter().tuple_windows::<(_, _)>();\n        itertools::equal(x, y)\n    }\n\n    fn equal_tuple_windows_3(a: Vec<u8>) -> bool {\n        let x = a.windows(3).map(|s| (&s[0], &s[1], &s[2]));\n        let y = a.iter().tuple_windows::<(_, _, _)>();\n        itertools::equal(x, y)\n    }\n\n    fn equal_tuple_windows_4(a: Vec<u8>) -> bool {\n        let x = a.windows(4).map(|s| (&s[0], &s[1], &s[2], &s[3]));\n        let y = a.iter().tuple_windows::<(_, _, _, _)>();\n        itertools::equal(x, y)\n    }\n\n    fn equal_tuples_1(a: Vec<u8>) -> bool {\n        let x = a.chunks(1).map(|s| (&s[0], ));\n        let y = a.iter().tuples::<(_,)>();\n        itertools::equal(x, y)\n    }\n\n    fn equal_tuples_2(a: Vec<u8>) -> bool {\n        let x = a.chunks(2).filter(|s| s.len() == 2).map(|s| (&s[0], &s[1]));\n        let y = a.iter().tuples::<(_, _)>();\n        itertools::equal(x, y)\n    }\n\n    fn equal_tuples_3(a: Vec<u8>) -> bool {\n        let x = a.chunks(3).filter(|s| s.len() == 3).map(|s| (&s[0], &s[1], &s[2]));\n        let y = a.iter().tuples::<(_, _, _)>();\n        itertools::equal(x, y)\n    }\n\n    fn equal_tuples_4(a: Vec<u8>) -> bool {\n        let x = a.chunks(4).filter(|s| s.len() == 4).map(|s| (&s[0], &s[1], &s[2], &s[3]));\n        let y = a.iter().tuples::<(_, _, _, _)>();\n        itertools::equal(x, y)\n    }\n\n    fn exact_tuple_buffer(a: Vec<u8>) -> bool {\n        let mut iter = a.iter().tuples::<(_, _, _, _)>();\n        (&mut iter).last();\n        let buffer = iter.into_buffer();\n        assert_eq!(buffer.len(), a.len() % 4);\n        exact_size(buffer)\n    }\n}\n\n// with_position\nquickcheck! {\n    fn with_position_exact_size_1(a: Vec<u8>) -> bool {\n        exact_size_for_this(a.iter().with_position())\n    }\n    fn with_position_exact_size_2(a: Iter<u8, Exact>) -> bool {\n        exact_size_for_this(a.with_position())\n    }\n}\n\nquickcheck! {\n    fn correct_group_map_modulo_key(a: Vec<u8>, modulo: u8) -> () {\n        let modulo = if modulo == 0 { 1 } else { modulo }; // Avoid `% 0`\n        let count = a.len();\n        let lookup = a.into_iter().map(|i| (i % modulo, i)).into_group_map();\n\n        assert_eq!(lookup.values().flat_map(|vals| vals.iter()).count(), count);\n\n        for (&key, vals) in lookup.iter() {\n            assert!(vals.iter().all(|&val| val % modulo == key));\n        }\n    }\n}\n\n/// A peculiar type: Equality compares both tuple items, but ordering only the\n/// first item.  This is so we can check the stability property easily.\n#[derive(Clone, Debug, PartialEq, Eq)]\nstruct Val(u32, u32);\n\nimpl PartialOrd<Val> for Val {\n    fn partial_cmp(&self, other: &Val) -> Option<Ordering> {\n        self.0.partial_cmp(&other.0)\n    }\n}\n\nimpl Ord for Val {\n    fn cmp(&self, other: &Val) -> Ordering {\n        self.0.cmp(&other.0)\n    }\n}\n\nimpl qc::Arbitrary for Val {\n    fn arbitrary<G: qc::Gen>(g: &mut G) -> Self {\n        let (x, y) = <(u32, u32)>::arbitrary(g);\n        Val(x, y)\n    }\n    fn shrink(&self) -> Box<dyn Iterator<Item = Self>> {\n        Box::new((self.0, self.1).shrink().map(|(x, y)| Val(x, y)))\n    }\n}\n\nquickcheck! {\n    fn minmax(a: Vec<Val>) -> bool {\n        use itertools::MinMaxResult;\n\n\n        let minmax = a.iter().minmax();\n        let expected = match a.len() {\n            0 => MinMaxResult::NoElements,\n            1 => MinMaxResult::OneElement(&a[0]),\n            _ => MinMaxResult::MinMax(a.iter().min().unwrap(),\n                                      a.iter().max().unwrap()),\n        };\n        minmax == expected\n    }\n}\n\nquickcheck! {\n    fn minmax_f64(a: Vec<f64>) -> TestResult {\n        use itertools::MinMaxResult;\n\n        if a.iter().any(|x| x.is_nan()) {\n            return TestResult::discard();\n        }\n\n        let min = cloned(&a).fold1(f64::min);\n        let max = cloned(&a).fold1(f64::max);\n\n        let minmax = cloned(&a).minmax();\n        let expected = match a.len() {\n            0 => MinMaxResult::NoElements,\n            1 => MinMaxResult::OneElement(min.unwrap()),\n            _ => MinMaxResult::MinMax(min.unwrap(), max.unwrap()),\n        };\n        TestResult::from_bool(minmax == expected)\n    }\n}\n\nquickcheck! {\n    #[allow(deprecated)]\n    fn tree_fold1_f64(mut a: Vec<f64>) -> TestResult {\n        fn collapse_adjacent<F>(x: Vec<f64>, mut f: F) -> Vec<f64>\n            where F: FnMut(f64, f64) -> f64\n        {\n            let mut out = Vec::new();\n            for i in (0..x.len()).step(2) {\n                if i == x.len()-1 {\n                    out.push(x[i])\n                } else {\n                    out.push(f(x[i], x[i+1]));\n                }\n            }\n            out\n        }\n\n        if a.iter().any(|x| x.is_nan()) {\n            return TestResult::discard();\n        }\n\n        let actual = a.iter().cloned().tree_fold1(f64::atan2);\n\n        while a.len() > 1 {\n            a = collapse_adjacent(a, f64::atan2);\n        }\n        let expected = a.pop();\n\n        TestResult::from_bool(actual == expected)\n    }\n}\n\nquickcheck! {\n    fn exactly_one_i32(a: Vec<i32>) -> TestResult {\n        let ret = a.iter().cloned().exactly_one();\n        match a.len() {\n            1 => TestResult::from_bool(ret.unwrap() == a[0]),\n            _ => TestResult::from_bool(ret.unwrap_err().eq(a.iter().cloned())),\n        }\n    }\n}\n","traces":[{"line":1,"address":[6196421],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":136,"address":[4247110,4246592,4246388,4247814,4248240,4247776,4248276,4247312,4247348,4246630,4248052,4248016,4246832,4246870,4247536,4246352,4247072,4247572],"length":1,"stats":{"Line":9},"fn_name":"next<i8,quick::Inexact>"},{"line":138,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":149,"address":[4249152,4249264,4248592,4248928,4248480,4248704,4249040,4248816],"length":1,"stats":{"Line":8},"fn_name":"size_hint<u16,quick::Exact>"},{"line":151,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":161,"address":[4249376,4249385],"length":1,"stats":{"Line":2},"fn_name":"next_back<i8,quick::Inexact>"},{"line":172,"address":[4250528,4250126,4249664,4251215,4249872,4249903,4250304,4249487,4250080,4250798,4250976,4249694,4250351,4249440,4251184,4250574,4250752,4251006],"length":1,"stats":{"Line":9},"fn_name":"arbitrary<u16,quick::Inexact,quickcheck::arbitrary::StdThreadGen>"},{"line":174,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":177,"address":[4253680,4253095,4251783,4253984,4252704,4254039,4252761,4252064,4253376,4251728,4252368,4253040,4252425,4251447,4253735,4251392,4252121,4253433],"length":1,"stats":{"Line":0},"fn_name":"shrink<i32,quick::Inexact>"},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[4258326,4258240],"length":1,"stats":{"Line":1},"fn_name":"correct_count<itertools::permutations::Permutations<core::ops::range::Range<usize>>,closure-0>"},{"line":254,"address":[4258263,4258349,4258366,4260047],"length":1,"stats":{"Line":3},"fn_name":null},{"line":256,"address":[4259162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[4258441],"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[4258718,4260212,4258869,4258456],"length":1,"stats":{"Line":2},"fn_name":null},{"line":260,"address":[4258768],"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[4258818],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[4258878,4258708],"length":1,"stats":{"Line":2},"fn_name":null},{"line":269,"address":[4258990],"length":1,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[4260264,4259172,4258963],"length":1,"stats":{"Line":2},"fn_name":null},{"line":274,"address":[4259429,4259591,4259208,4259394],"length":1,"stats":{"Line":3},"fn_name":null},{"line":275,"address":[4260344,4259527,4260314],"length":1,"stats":{"Line":1},"fn_name":null},{"line":276,"address":[4259573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[4259604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[4259976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[4260029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":286,"address":[4283440,4278304,4278345,4282169,4287321,4265424,4275776,4284736,4261656,4277040,4264176,4271872,4262905,4283481,4269280,4275817,4260352,4277081,4274448,4270576,4270617,4266720,4269321,4264217,4265465,4267984,4279568,4280832,4287280,4288544,4289808,4280873,4271907,4261616,4268019,4289849,4291056,4291097,4273209,4274489,4284780,4273168,4288585,4286057,4282128,4260393,4262864,4266761,4279609,4286016],"length":1,"stats":{"Line":25},"fn_name":"correct_size_hint<itertools::ziptuple::Zip<(itertools::adaptors::DedupBy<quick::Iter<i16, quick::Exact>, itertools::adaptors::DedupEq>, quick::Iter<i16, quick::Exact>, quick::Iter<i16, quick::Exact>)>>"},{"line":288,"address":[4279591,4280855,4278327,4283463,4291079,4287303,4262887,4277063,4265447,4275799,4260375,4264199,4268004,4269303,4271892,4284773,4274471,4286039,4288567,4289831,4273191,4282151,4270599,4261649,4266743],"length":1,"stats":{"Line":25},"fn_name":null},{"line":289,"address":[4273272,4291173,4273224,4266824,4260456,4271980,4287336,4288431,4289912,4291112,4286120,4264280,4261671,4282232,4271765,4278189,4262968,4264059,4283496,4265541,4279672,4280949,4282021,4261501,4284853,4265318,4266613,4280888,4289694,4278360,4289864,4287384,4270468,4283323,4271922,4267871,4266776,4262920,4278408,4269165,4273053,4284795,4268092,4270693,4276925,4288648,4282184,4288600,4279624,4262749,4286072,4287166,4285903,4292246,4265480,4277096,4274504,4274565,4261719,4277144,4284630,4269336,4268034,4260408,4275663,4275832,4280719,4283557,4270632,4269397,4264232,4290950,4275880,4274344,4279455],"length":1,"stats":{"Line":50},"fn_name":null},{"line":290,"address":[4287391,4286127,4271987,4279679,4284860,4265548,4273279,4274572,4275887,4269404,4280956,4288655,4291180,4260463,4264287,4268099,4278415,4270700,4283564,4289919,4261726,4262975,4282239,4277151,4266831],"length":1,"stats":{"Line":25},"fn_name":null},{"line":291,"address":[4261901,4261803,4270886,4281011,4260648,4283619,4269616,4284937,4291235,4269484,4286340,4268277,4276099,4270913,4272042,4275942,4281036,4282470,4263055,4274784,4285035,4283751,4272218,4288841,4291367,4267045,4263233,4260675,4266886,4278629,4286182,4268154,4281142,4287471,4278470,4282319,4287578,4277206,4278495,4284915,4282294,4264367,4279866,4286207,4273334,4264492,4287446,4287605,4260518,4261925,4289999,4290100,4273491,4267018,4269589,4261781,4288868,4265734,4282497,4288735,4268330,4274627,4277336,4277363,4265603,4281169,4272165,4264342,4279759,4286313,4264468,4276072,4265628,4273359,4273518,4270780,4272072,4291260,4263030,4274652,4279734,4291394,4263206,4269459,4265761,4283644,4285059,4289974,4290124,4274811,4279893,4288710,4283778,4277231,4260543,4268184,4270755,4266911,4278602,4275967],"length":1,"stats":{"Line":75},"fn_name":null},{"line":292,"address":[4274754,4278572,4268247,4285005,4263176,4265704,4272135,4276042,4279836,4273461,4260618,4266988,4283721,4287548,4288811,4286283,4281112,4290070,4261871,4277306,4269559,4270856,4282440,4291337,4264438],"length":1,"stats":{"Line":25},"fn_name":null},{"line":295,"address":[4290112,4261935,4272228,4260685,4274821,4288878,4261913,4268340,4283766,4290134,4286328,4267033,4276087,4283788,4288856,4277351,4265771,4278639,4268318,4264480,4278617,4276109,4279903,4282485,4272206,4264502,4286350,4270901,4270923,4263243,4267055,4281157,4285069,4273506,4273528,4274799,4281179,4285047,4287615,4282507,4277373,4260663,4279881,4269604,4291382,4263221,4269626,4287593,4291404,4265749],"length":1,"stats":{"Line":50},"fn_name":null},{"line":298,"address":[4287631,4282523,4267071,4267487,4261117,4271066,4276252,4288047,4280335,4265914,4283931,4287758,4271355,4265787,4264645,4276541,4263675,4269642,4290277,4273960,4266203,4291836,4261951,4273671,4279919,4270058,4272368,4279071,4283804,4269769,4281322,4273544,4281195,4278782,4275253,4272244,4263386,4277389,4286366,4262367,4264934,4268480,4284220,4272657,4274964,4268356,4277805,4282939,4274837,4260701,4277516,4290150,4291420,4285501,4289021,4291547,4262078,4267198,4278655,4268769,4281611,4282650,4286493,4280046,4285212,4264518,4288894,4276125,4263259,4260828,4289310,4270939,4285085,4286782,4290566],"length":1,"stats":{"Line":50},"fn_name":null},{"line":299,"address":[4275049,4262801,4272453,4273105,4283375,4287843,4276977,4284016,4289106,4261553,4279507,4286578,4288483,4271151,4285955,4263471,4289746,4266665,4291002,4269854,4271817,4278867,4265370,4276337,4282735,4264730,4285297,4265999,4270520,4275715,4264111,4268565,4280131,4262163,4267283,4260913,4267923,4269217,4273756,4277601,4280771,4281407,4282073,4274396,4278241,4284682,4287218,4291632,4290362,4292298],"length":1,"stats":{"Line":25},"fn_name":null},{"line":300,"address":[4264774,4273861,4281451,4262328,4282840,4285462,4290527,4291797,4266164,4272497,4280175,4285341,4285402,4263636,4263515,4276442,4279032,4287948,4276381,4261078,4267327,4288008,4290467,4286743,4282779,4263576,4269959,4290406,4286622,4272618,4261018,4267388,4269898,4276502,4260957,4270019,4262207,4262268,4268730,4275093,4275214,4284060,4289211,4291737,4271195,4275154,4268670,4273800,4268609,4280236,4280296,4282900,4286683,4271256,4289271,4271316,4277766,4277645,4264895,4289150,4281572,4267448,4281512,4277706,4287887,4264835,4266043,4278911,4266104,4272558,4278972,4284121,4273921,4291676,4284181],"length":1,"stats":{"Line":75},"fn_name":null},{"line":301,"address":[4290479,4266116,4264812,4268682,4290543,4267464,4291813,4267365,4269971,4279048,4286695,4287960,4272535,4262245,4264911,4268647,4280248,4277718,4275230,4291749,4260995,4278984,4282817,4273873,4284098,4276454,4271332,4276419,4289223,4266180,4262280,4262344,4261030,4277683,4285379,4281489,4280312,4282852,4268746,4271268,4286660,4263588,4271233,4284197,4261094,4277782,4275131,4280213,4281588,4282916,4289188,4266081,4270035,4281524,4287925,4267400,4269936,4263553,4286759,4264847,4276518,4272570,4272634,4285414,4289287,4291714,4290444,4263652,4273838,4278949,4284133,4288024,4285478,4275166,4273937],"length":1,"stats":{"Line":50},"fn_name":null},{"line":303,"address":[4277810,4266208,4270063,4263680,4282944,4290571,4288052,4264939,4271360,4276546,4268774,4281616,4285506,4291841,4286787,4279076,4267492,4280340,4289315,4262372,4284225,4261122,4272662,4275258,4273965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[4289627,4284537,4287099,4272972,4276858,4266520,4275570,4270375,4269084,4274277,4262682,4290883,4285816,4261434,4279388,4265251,4278122,4280652,4271672,4288364,4263992,4292153,4283256,4267804,4281928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[4280020,4262052,4264619,4274938,4277490,4278756,4285186,4287732,4291521,4271040,4286467,4260802,4282624,4269743,4288995,4281296,4290251,4272345,4283905,4267172,4273645,4276226,4265888,4263360,4268457],"length":1,"stats":{"Line":25},"fn_name":null},{"line":311,"address":[4298736,4295904,4298768,4293040,4296640,4292352,4296672,4293072,4293728,4295936,4298080,4295184,4295216,4292384,4294496,4297360,4298048,4293766,4294464,4297392],"length":1,"stats":{"Line":10},"fn_name":"exact_size<itertools::pad_tail::PadUsing<quick::Iter<i8, quick::Exact>, closure-0>>"},{"line":313,"address":[4292369,4293759,4293057,4297377,4295921,4297407,4298753,4294511,4298783,4298065,4295201,4295951,4293781,4293087,4296687,4295231,4298095,4296657,4292399,4294481],"length":1,"stats":{"Line":20},"fn_name":null},{"line":314,"address":[4298813,4293875,4296773,4295317,4297491,4295261,4294541,4297437,4296717,4298867,4294605,4292429,4298171,4298179,4298859,4294597,4293117,4297483,4296035,4293163,4293867,4292483,4293171,4296781,4298125,4292475,4295325,4293811,4296027,4295981],"length":1,"stats":{"Line":20},"fn_name":null},{"line":315,"address":[4297850,4298527,4294216,4293916,4299179,4294199,4299225,4292514,4293169,4295527,4294946,4294086,4293483,4292830,4296066,4293529,4296277,4296779,4296983,4297489,4298865,4298371,4294245,4298498,4298481,4297139,4299066,4293202,4294929,4297522,4294603,4292674,4293873,4297093,4294816,4295323,4297110,4298898,4293370,4295366,4298177,4299196,4295654,4298210,4294975,4292801,4295683,4294646,4296390,4296436,4297821,4296407,4296822,4296033,4297804,4297691,4292784,4293500,4295637,4292481],"length":1,"stats":{"Line":40},"fn_name":null},{"line":316,"address":[4293987,4297592,4294717,4296178,4298967,4293271,4292581,4296890,4295434,4298278],"length":1,"stats":{"Line":10},"fn_name":null},{"line":317,"address":[4296292,4295858,4294420,4292689,4297799,4297314,4298483,4299174,4299181,4297088,4294201,4294101,4294831,4296392,4297647,4293385,4295639,4292786,4294772,4299081,4297095,4294924,4296385,4293694,4296942,4296233,4295542,4297806,4299390,4295632,4296998,4297706,4298330,4298015,4294042,4294194,4292995,4295150,4298692,4292779,4293485,4298386,4293478,4299022,4295486,4296601,4298476,4292633,4294931,4293326],"length":1,"stats":{"Line":20},"fn_name":null},{"line":318,"address":[4298391,4296297,4297003,4292694,4297711,4299086,4295547,4294106,4294836,4293390],"length":1,"stats":{"Line":10},"fn_name":null},{"line":319,"address":[4297724,4296310,4293403,4292704,4299099,4295557,4298401,4294849,4297013,4294119],"length":1,"stats":{"Line":10},"fn_name":null},{"line":320,"address":[4295583,4297104,4295648,4298427,4298492,4297823,4294940,4299125,4297112,4293429,4296401,4297815,4292795,4294875,4295656,4296409,4292803,4297750,4299198,4298500,4294210,4293494,4294948,4293502,4294145,4297039,4296336,4294218,4292730,4299190],"length":1,"stats":{"Line":20},"fn_name":null},{"line":322,"address":[4299218,4295688,4296441,4299230,4294968,4295676,4294980,4293522,4297132,4296429,4294250,4292835,4294238,4297144,4297855,4297843,4298532,4293534,4292823,4298520],"length":1,"stats":{"Line":20},"fn_name":null},{"line":323,"address":[4292883,4296489,4297192,4298580,4295028,4293582,4294374,4294298,4298646,4297969,4295812,4299278,4295736,4297268,4293648,4299344,4297903,4295104,4292949,4296555],"length":1,"stats":{"Line":20},"fn_name":null},{"line":327,"address":[4300816,4300112,4299424,4300144,4300848,4301504,4299456,4301536],"length":1,"stats":{"Line":4},"fn_name":"exact_size_for_this<itertools::adaptors::Interleave<quick::Iter<i16, quick::Exact>, quick::Iter<i16, quick::Exact>>>"},{"line":329,"address":[4299441,4301551,4300833,4300129,4300159,4300863,4299471,4301521],"length":1,"stats":{"Line":8},"fn_name":null},{"line":330,"address":[4300235,4299501,4300189,4299555,4300947,4301581,4300243,4301630,4301638,4299547,4300893,4300939],"length":1,"stats":{"Line":8},"fn_name":null},{"line":331,"address":[4301261,4301307,4301867,4301997,4302026,4300978,4300578,4300945,4299747,4300607,4299857,4300274,4301669,4301278,4301980,4299903,4299553,4300561,4301148,4299586,4301636,4300241,4300451,4299874],"length":1,"stats":{"Line":16},"fn_name":null},{"line":332,"address":[4300358,4301768,4299654,4301049],"length":1,"stats":{"Line":4},"fn_name":null},{"line":333,"address":[4299852,4301975,4301823,4299762,4301472,4300466,4302191,4300556,4300772,4300410,4300563,4300068,4301163,4301256,4301982,4299859,4301104,4301882,4301263,4299706],"length":1,"stats":{"Line":8},"fn_name":null},{"line":334,"address":[4300471,4301168,4301887,4299767],"length":1,"stats":{"Line":4},"fn_name":null},{"line":335,"address":[4301900,4299777,4300481,4301181],"length":1,"stats":{"Line":4},"fn_name":null},{"line":336,"address":[4300507,4301999,4299803,4299876,4301991,4300572,4299868,4301280,4301207,4301926,4300580,4301272],"length":1,"stats":{"Line":8},"fn_name":null},{"line":338,"address":[4301300,4301312,4302019,4302031,4300600,4300612,4299908,4299896],"length":1,"stats":{"Line":8},"fn_name":null},{"line":339,"address":[4301426,4302079,4301360,4300660,4300022,4302145,4300726,4299956],"length":1,"stats":{"Line":8},"fn_name":null},{"line":369,"address":[4310389,4311504,4312709,4311120,4312133,4311344,4310320,4310357,4311317,4311717,4312245,4312880,4310709,4313749,4314608,4312240,4314613,4315285,4311253,4311221,4312165,4315792,4310000,4311904,4309557,4312448,4310384,4309301,4311312,4308293,4308832,4311381,4309296,4312032,4314069,4309909,4309877,4310677,4310704,4313397,4311909,4311152,4314485,4312485,4315824,4308352,4311248,4317312,4310005,4311712,4310773,4312512,4308288,4313205,4317317,4312480,4314896,4314901,4311280,4311621,4309840,4311877,4315861,4309813,4316352,4312677,4310672,4313520,4310480,4310485,4311184,4308325,4311125,4311376,4311157,4312000,4312160,4312704,4313365,4316240,4312069,4309808,4310736,4309264,4311349,4312064,4309941,4313200,4311189,4312101,4312885,4311680,4311653,4309269,4311616,4315280,4308800,4309968,4308805,4311477,4315829,4310768,4310581,4309904,4312096,4314480,4312736,4313525,4308320,4311872,4313360,4316272,4315760,4315856,4312741,4310325,4308837,4315797,4313040,4309936,4309973,4311509,4310576,4309552,4308357,4309845,4313744,4311216,4315765,4316245,4311472,4312613,4311685,4310741,4312128,4312672,4314064,4316277,4311648,4311285,4310352,4312453,4316357,4309872,4312517,4313392,4312608,4312005,4312037,4313045],"length":1,"stats":{"Line":225},"fn_name":"{{closure}}"},{"line":370,"address":[5313077,5283072,5269632,5309728,5305632,5289029,5281024,5284287,5282528,5309584,5293296,5284915,5311661,5274614,5309680,5305692,5273040,5274128,5285840,5299696,5312160,5280349,5307008,5275856,5293848,5274996,5293776,5284128,5307404,5295907,5304602,5283904,5278704,5298544,5307344,5271008,5283935,5294193,5308512,5283648,5294096,5300368,5283776,5296825,5286016,5293648,5293472,5293069,5282113,5275712,5298048,5292813,5273696,5281085,5277184,5307696,5300928,5284880,5269280,5296160,5269688,5278765,5306364,5296784,5276392,5299968,5280288,5295312,5281760,5292784,5271136,5312960,5312267,5274544,5298601,5291664,5294768,5294848,5288912,5300032,5308064,5284240,5296096,5305968,5308432,5283504,5304560,5293498,5306304,5306656,5307756,5298448,5279424,5292051,5309408,5298336,5306716,5307068,5301066,5276608,5282080,5291936,5276352,5269136,5291776,5277284,5313825,5299664,5295392,5273733,5309438,5286086,5296688,5311584,5274198,5273392,5308124,5313728,5270896,5293040,5274944,5293322,5300440,5306028,5279485,5295872],"length":1,"stats":{"Line":75},"fn_name":"prop"},{"line":373,"address":[5270881,5276337,5274529,5298529,5273377,5300353,5307681,5304545,5309665,5277169,5312945,5307329,5294753,5284113,5306993,5312145,5291761,5283633,5284865,5269617,5275697,5283489,5294081,5269265,5276593,5298433,5300913,5283889,5296673,5279409,5283057,5273681,5305617,5309569,5281745,5305953,5275841,5278689,5296769,5295297,5299649,5293761,5274113,5296081,5282513,5308417,5292769,5269121,5293457,5293633,5311569,5291649,5284225,5274929,5281009,5295857,5291921,5282065,5298321,5306289,5288897,5308049,5313713,5273025,5299953,5306641,5309393,5270993,5293025,5286001,5293281,5283761,5298033,5280273,5285825],"length":1,"stats":{"Line":75},"fn_name":null},{"line":392,"address":[5269143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":395,"address":[5269287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":403,"address":[5269647],"length":1,"stats":{"Line":1},"fn_name":null},{"line":404,"address":[5269703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":405,"address":[5269737],"length":1,"stats":{"Line":1},"fn_name":null},{"line":406,"address":[4308464,4308481,4308397,4308576,4308593,4308384],"length":1,"stats":{"Line":7},"fn_name":"{{closure}}"},{"line":407,"address":[5270053,5269914],"length":1,"stats":{"Line":2},"fn_name":null},{"line":408,"address":[5270196],"length":1,"stats":{"Line":1},"fn_name":null},{"line":410,"address":[5270203],"length":1,"stats":{"Line":1},"fn_name":null},{"line":411,"address":[5270287,5270393],"length":1,"stats":{"Line":2},"fn_name":null},{"line":412,"address":[4308688,4308729],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":414,"address":[5270403,5270514],"length":1,"stats":{"Line":1},"fn_name":null},{"line":418,"address":[5270900],"length":1,"stats":{"Line":1},"fn_name":null},{"line":422,"address":[5271023],"length":1,"stats":{"Line":1},"fn_name":null},{"line":426,"address":[5271113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":427,"address":[5271151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":428,"address":[5271193],"length":1,"stats":{"Line":1},"fn_name":null},{"line":429,"address":[5271251],"length":1,"stats":{"Line":1},"fn_name":null},{"line":430,"address":[4308864,4308976,4309104,4309088,4308880,4308992],"length":1,"stats":{"Line":7},"fn_name":"{{closure}}"},{"line":431,"address":[5271487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":432,"address":[5271533],"length":1,"stats":{"Line":1},"fn_name":null},{"line":434,"address":[5271540],"length":1,"stats":{"Line":1},"fn_name":null},{"line":435,"address":[5271636,5271742],"length":1,"stats":{"Line":2},"fn_name":null},{"line":436,"address":[4309200,4309208],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":438,"address":[5271752,5271911],"length":1,"stats":{"Line":1},"fn_name":null},{"line":440,"address":[5271845,5272229],"length":1,"stats":{"Line":2},"fn_name":null},{"line":445,"address":[5273067],"length":1,"stats":{"Line":1},"fn_name":null},{"line":446,"address":[5273077],"length":1,"stats":{"Line":1},"fn_name":null},{"line":447,"address":[5273362,5273085,5273332],"length":1,"stats":{"Line":1},"fn_name":null},{"line":449,"address":[5273123],"length":1,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[5273169,5273281,5273326],"length":1,"stats":{"Line":3},"fn_name":null},{"line":451,"address":[5273305,5273223],"length":1,"stats":{"Line":2},"fn_name":null},{"line":456,"address":[5273404],"length":1,"stats":{"Line":1},"fn_name":null},{"line":457,"address":[5273414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":458,"address":[5273645,5273427,5273675],"length":1,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[5273465],"length":1,"stats":{"Line":1},"fn_name":null},{"line":461,"address":[4309328],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":462,"address":[4309342,4309485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":463,"address":[4309421,4309545,4309515],"length":1,"stats":{"Line":1},"fn_name":null},{"line":464,"address":[4309470],"length":1,"stats":{"Line":1},"fn_name":null},{"line":470,"address":[5273708],"length":1,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[5273786,5273718],"length":1,"stats":{"Line":1},"fn_name":null},{"line":472,"address":[5273748,5274060],"length":1,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[5273800],"length":1,"stats":{"Line":1},"fn_name":null},{"line":475,"address":[4309584],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":476,"address":[4309741,4309598],"length":1,"stats":{"Line":1},"fn_name":null},{"line":477,"address":[4309771,4309677,4309801],"length":1,"stats":{"Line":1},"fn_name":null},{"line":478,"address":[4309726],"length":1,"stats":{"Line":1},"fn_name":null},{"line":483,"address":[5274155],"length":1,"stats":{"Line":1},"fn_name":null},{"line":485,"address":[5274399,5274213,5274429],"length":1,"stats":{"Line":2},"fn_name":null},{"line":486,"address":[5274422],"length":1,"stats":{"Line":1},"fn_name":null},{"line":488,"address":[5274320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":492,"address":[5274571],"length":1,"stats":{"Line":1},"fn_name":null},{"line":494,"address":[5274796,5274841,5274629],"length":1,"stats":{"Line":2},"fn_name":null},{"line":495,"address":[5274822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":497,"address":[5274736],"length":1,"stats":{"Line":1},"fn_name":null},{"line":501,"address":[5274967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":502,"address":[5275027],"length":1,"stats":{"Line":1},"fn_name":null},{"line":503,"address":[5275124,5275064],"length":1,"stats":{"Line":2},"fn_name":null},{"line":504,"address":[5275146],"length":1,"stats":{"Line":1},"fn_name":null},{"line":505,"address":[5275208],"length":1,"stats":{"Line":1},"fn_name":null},{"line":506,"address":[5275223,5275299],"length":1,"stats":{"Line":2},"fn_name":null},{"line":507,"address":[5275341],"length":1,"stats":{"Line":1},"fn_name":null},{"line":508,"address":[5275395],"length":1,"stats":{"Line":1},"fn_name":null},{"line":511,"address":[5275719],"length":1,"stats":{"Line":1},"fn_name":null},{"line":514,"address":[5275908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":515,"address":[5276321,5276161,5276334,5275954],"length":1,"stats":{"Line":3},"fn_name":null},{"line":516,"address":[5276031,5276300],"length":1,"stats":{"Line":2},"fn_name":null},{"line":519,"address":[5276359,5276407],"length":1,"stats":{"Line":2},"fn_name":null},{"line":520,"address":[5276427],"length":1,"stats":{"Line":1},"fn_name":null},{"line":524,"address":[5276660],"length":1,"stats":{"Line":1},"fn_name":null},{"line":525,"address":[4310073],"length":1,"stats":{"Line":4},"fn_name":null},{"line":526,"address":[4310217],"length":1,"stats":{"Line":3},"fn_name":null},{"line":530,"address":[5277191,5277299],"length":1,"stats":{"Line":2},"fn_name":null},{"line":531,"address":[5277323,5277375],"length":1,"stats":{"Line":2},"fn_name":null},{"line":532,"address":[5277399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":533,"address":[5277414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":534,"address":[5277472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":535,"address":[5277530],"length":1,"stats":{"Line":1},"fn_name":null},{"line":536,"address":[5277598],"length":1,"stats":{"Line":1},"fn_name":null},{"line":537,"address":[5277621],"length":1,"stats":{"Line":1},"fn_name":null},{"line":538,"address":[5277729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":539,"address":[5277829],"length":1,"stats":{"Line":1},"fn_name":null},{"line":540,"address":[5277875,5278502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":547,"address":[5278785,5278711,5278871,5278952],"length":1,"stats":{"Line":3},"fn_name":null},{"line":548,"address":[5278906],"length":1,"stats":{"Line":1},"fn_name":null},{"line":550,"address":[5278854,5278975],"length":1,"stats":{"Line":2},"fn_name":null},{"line":551,"address":[5278990],"length":1,"stats":{"Line":1},"fn_name":null},{"line":552,"address":[5279036,5279311],"length":1,"stats":{"Line":1},"fn_name":null},{"line":558,"address":[5279603,5279431,5279505,5279745],"length":1,"stats":{"Line":3},"fn_name":null},{"line":559,"address":[5279653],"length":1,"stats":{"Line":1},"fn_name":null},{"line":560,"address":[5279699],"length":1,"stats":{"Line":1},"fn_name":null},{"line":562,"address":[5279583,5279768],"length":1,"stats":{"Line":2},"fn_name":null},{"line":563,"address":[5279783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":564,"address":[5279829],"length":1,"stats":{"Line":1},"fn_name":null},{"line":565,"address":[5280032,5279875],"length":1,"stats":{"Line":2},"fn_name":null},{"line":566,"address":[4310435,4310416],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":572,"address":[5280455,5280536,5280369,5280295],"length":1,"stats":{"Line":3},"fn_name":null},{"line":573,"address":[5280490],"length":1,"stats":{"Line":1},"fn_name":null},{"line":575,"address":[5280559,5280438],"length":1,"stats":{"Line":2},"fn_name":null},{"line":576,"address":[5280574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":577,"address":[5280620,5280777],"length":1,"stats":{"Line":2},"fn_name":null},{"line":578,"address":[4310512,4310531],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":584,"address":[5281272,5281105,5281031,5281191],"length":1,"stats":{"Line":3},"fn_name":null},{"line":585,"address":[5281226],"length":1,"stats":{"Line":1},"fn_name":null},{"line":587,"address":[5281174,5281295],"length":1,"stats":{"Line":2},"fn_name":null},{"line":588,"address":[5281310],"length":1,"stats":{"Line":1},"fn_name":null},{"line":589,"address":[5281513,5281356],"length":1,"stats":{"Line":2},"fn_name":null},{"line":590,"address":[4310627,4310608],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":594,"address":[5281767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":597,"address":[5282087,5282128,5282173],"length":1,"stats":{"Line":3},"fn_name":null},{"line":598,"address":[5282209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":599,"address":[5282266],"length":1,"stats":{"Line":1},"fn_name":null},{"line":600,"address":[5282329],"length":1,"stats":{"Line":1},"fn_name":null},{"line":603,"address":[5282565],"length":1,"stats":{"Line":1},"fn_name":null},{"line":604,"address":[5282611],"length":1,"stats":{"Line":1},"fn_name":null},{"line":605,"address":[5282861,5283001,5283048,5283035,5282657,5282811],"length":1,"stats":{"Line":5},"fn_name":null},{"line":606,"address":[5282927,5282825],"length":1,"stats":{"Line":2},"fn_name":null},{"line":607,"address":[5283014,5282734],"length":1,"stats":{"Line":2},"fn_name":null},{"line":610,"address":[5283079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":611,"address":[5283151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":612,"address":[5283216,5283480,5283467,5283342],"length":1,"stats":{"Line":3},"fn_name":null},{"line":613,"address":[4310800,4310879,4310908],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":614,"address":[4310842,4310881],"length":1,"stats":{"Line":2},"fn_name":null},{"line":615,"address":[4310910],"length":1,"stats":{"Line":1},"fn_name":null},{"line":616,"address":[4310872],"length":1,"stats":{"Line":1},"fn_name":null},{"line":620,"address":[5283438,5283250],"length":1,"stats":{"Line":2},"fn_name":null},{"line":621,"address":[4311039,4311068,4310960],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":622,"address":[4311002,4311041],"length":1,"stats":{"Line":2},"fn_name":null},{"line":623,"address":[4311070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":624,"address":[4311032],"length":1,"stats":{"Line":1},"fn_name":null},{"line":629,"address":[5283511],"length":1,"stats":{"Line":1},"fn_name":null},{"line":632,"address":[5283682],"length":1,"stats":{"Line":1},"fn_name":null},{"line":635,"address":[5283780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":638,"address":[5283957,5283918,5284018],"length":1,"stats":{"Line":3},"fn_name":null},{"line":641,"address":[5284137],"length":1,"stats":{"Line":1},"fn_name":null},{"line":644,"address":[5284251],"length":1,"stats":{"Line":1},"fn_name":null},{"line":645,"address":[5284256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":646,"address":[5284355,5284765,5284549,5284270,5284302,5284495],"length":1,"stats":{"Line":5},"fn_name":null},{"line":647,"address":[5284646,5284593],"length":1,"stats":{"Line":2},"fn_name":null},{"line":648,"address":[5284648,5284633],"length":1,"stats":{"Line":1},"fn_name":null},{"line":650,"address":[5284600,5284708,5284737],"length":1,"stats":{"Line":2},"fn_name":null},{"line":651,"address":[5284712,5284748,5284830],"length":1,"stats":{"Line":2},"fn_name":null},{"line":653,"address":[5284753],"length":1,"stats":{"Line":1},"fn_name":null},{"line":655,"address":[5284770],"length":1,"stats":{"Line":1},"fn_name":null},{"line":659,"address":[5284887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":660,"address":[5284930,5284986,5285148,5285439],"length":1,"stats":{"Line":3},"fn_name":null},{"line":661,"address":[5285789,5285444,5285246,5285554],"length":1,"stats":{"Line":2},"fn_name":null},{"line":662,"address":[5285494],"length":1,"stats":{"Line":1},"fn_name":null},{"line":665,"address":[5285119,5285559],"length":1,"stats":{"Line":2},"fn_name":null},{"line":669,"address":[5285844],"length":1,"stats":{"Line":1},"fn_name":null},{"line":670,"address":[5285887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":679,"address":[5286101,5286031],"length":1,"stats":{"Line":2},"fn_name":null},{"line":680,"address":[5286149],"length":1,"stats":{"Line":1},"fn_name":null},{"line":682,"address":[5286361,5286305],"length":1,"stats":{"Line":2},"fn_name":null},{"line":684,"address":[5286377],"length":1,"stats":{"Line":1},"fn_name":null},{"line":686,"address":[5288746,5288498,5286384,5286532,5286554,5288672],"length":1,"stats":{"Line":5},"fn_name":null},{"line":687,"address":[5286822,5288720,5286984],"length":1,"stats":{"Line":2},"fn_name":null},{"line":689,"address":[4311408,4311422],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":690,"address":[5287518,5287463],"length":1,"stats":{"Line":1},"fn_name":null},{"line":694,"address":[5287696,5287484],"length":1,"stats":{"Line":2},"fn_name":null},{"line":695,"address":[5287746],"length":1,"stats":{"Line":1},"fn_name":null},{"line":697,"address":[5287812,5287963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":700,"address":[5288336,5288289,5287953],"length":1,"stats":{"Line":2},"fn_name":null},{"line":705,"address":[5288935],"length":1,"stats":{"Line":1},"fn_name":null},{"line":706,"address":[5288971],"length":1,"stats":{"Line":1},"fn_name":null},{"line":708,"address":[5288997],"length":1,"stats":{"Line":1},"fn_name":null},{"line":709,"address":[5289044],"length":1,"stats":{"Line":1},"fn_name":null},{"line":711,"address":[5289074],"length":1,"stats":{"Line":1},"fn_name":null},{"line":712,"address":[5289261,5289132,5291488],"length":1,"stats":{"Line":2},"fn_name":null},{"line":714,"address":[5289296],"length":1,"stats":{"Line":1},"fn_name":null},{"line":716,"address":[5289379,5289462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":717,"address":[5289404,5289468],"length":1,"stats":{"Line":2},"fn_name":null},{"line":718,"address":[5289648],"length":1,"stats":{"Line":0},"fn_name":null},{"line":721,"address":[5291167,5289702,5289675],"length":1,"stats":{"Line":2},"fn_name":null},{"line":723,"address":[5289697,5290056,5290198,5291444,5291275],"length":1,"stats":{"Line":3},"fn_name":null},{"line":724,"address":[5290186,5290297],"length":1,"stats":{"Line":1},"fn_name":null},{"line":725,"address":[5290165],"length":1,"stats":{"Line":1},"fn_name":null},{"line":730,"address":[5290231,5291334],"length":1,"stats":{"Line":1},"fn_name":null},{"line":733,"address":[5290694,5290809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":738,"address":[5291678],"length":1,"stats":{"Line":1},"fn_name":null},{"line":740,"address":[4311536,4311548],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":744,"address":[5291788],"length":1,"stats":{"Line":1},"fn_name":null},{"line":748,"address":[5291948],"length":1,"stats":{"Line":1},"fn_name":null},{"line":749,"address":[5291967,5292066],"length":1,"stats":{"Line":1},"fn_name":null},{"line":750,"address":[5292150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":752,"address":[5292385,5292254],"length":1,"stats":{"Line":1},"fn_name":null},{"line":758,"address":[5292798],"length":1,"stats":{"Line":1},"fn_name":null},{"line":759,"address":[5292830],"length":1,"stats":{"Line":1},"fn_name":null},{"line":760,"address":[5292854,5292883],"length":1,"stats":{"Line":2},"fn_name":null},{"line":766,"address":[5293054],"length":1,"stats":{"Line":1},"fn_name":null},{"line":767,"address":[4311744,4311762],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":768,"address":[4311808,4311826],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":774,"address":[5293334,5293392,5293305],"length":1,"stats":{"Line":3},"fn_name":null},{"line":780,"address":[4311954,4311936],"length":1,"stats":{"Line":5},"fn_name":"{{closure}}"},{"line":785,"address":[5293661],"length":1,"stats":{"Line":1},"fn_name":null},{"line":786,"address":[5293679],"length":1,"stats":{"Line":1},"fn_name":null},{"line":787,"address":[5293698],"length":1,"stats":{"Line":1},"fn_name":null},{"line":793,"address":[5293863,5293796],"length":1,"stats":{"Line":2},"fn_name":null},{"line":794,"address":[5293929,5293902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":795,"address":[5293886,5293904],"length":1,"stats":{"Line":2},"fn_name":null},{"line":798,"address":[5293931],"length":1,"stats":{"Line":1},"fn_name":null},{"line":804,"address":[5294208,5294103],"length":1,"stats":{"Line":2},"fn_name":null},{"line":805,"address":[5294445,5294509,5294216,5294392],"length":1,"stats":{"Line":3},"fn_name":null},{"line":806,"address":[5294489],"length":1,"stats":{"Line":1},"fn_name":null},{"line":808,"address":[5294514],"length":1,"stats":{"Line":1},"fn_name":null},{"line":814,"address":[5294775,5294890],"length":1,"stats":{"Line":2},"fn_name":null},{"line":815,"address":[5294954],"length":1,"stats":{"Line":1},"fn_name":null},{"line":816,"address":[5294998],"length":1,"stats":{"Line":1},"fn_name":null},{"line":817,"address":[5295010],"length":1,"stats":{"Line":1},"fn_name":null},{"line":818,"address":[5295105,5295017],"length":1,"stats":{"Line":2},"fn_name":null},{"line":824,"address":[5295319,5295434],"length":1,"stats":{"Line":2},"fn_name":null},{"line":825,"address":[5295515],"length":1,"stats":{"Line":1},"fn_name":null},{"line":826,"address":[5295562],"length":1,"stats":{"Line":1},"fn_name":null},{"line":827,"address":[5295574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":828,"address":[5295669,5295581],"length":1,"stats":{"Line":2},"fn_name":null},{"line":834,"address":[4312192,4312205],"length":1,"stats":{"Line":5},"fn_name":"{{closure}}"},{"line":840,"address":[5296103],"length":1,"stats":{"Line":1},"fn_name":null},{"line":841,"address":[5296133],"length":1,"stats":{"Line":1},"fn_name":null},{"line":842,"address":[4312272,4312285],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":843,"address":[4312334,4312320],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":844,"address":[4312384,4312398],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":846,"address":[5296340,5296472],"length":1,"stats":{"Line":2},"fn_name":null},{"line":847,"address":[5296479],"length":1,"stats":{"Line":1},"fn_name":null},{"line":848,"address":[5296594,5296525],"length":1,"stats":{"Line":2},"fn_name":null},{"line":854,"address":[5296692],"length":1,"stats":{"Line":1},"fn_name":null},{"line":860,"address":[5296791,5296840],"length":1,"stats":{"Line":2},"fn_name":null},{"line":861,"address":[5296869],"length":1,"stats":{"Line":1},"fn_name":null},{"line":862,"address":[5297161,5296960,5296915,5297045,5297427],"length":1,"stats":{"Line":4},"fn_name":null},{"line":863,"address":[5297432,5297765,5297211,5297996],"length":1,"stats":{"Line":2},"fn_name":null},{"line":864,"address":[5297482],"length":1,"stats":{"Line":1},"fn_name":null},{"line":865,"address":[5297588],"length":1,"stats":{"Line":1},"fn_name":null},{"line":866,"address":[5297826,5297770],"length":1,"stats":{"Line":0},"fn_name":null},{"line":870,"address":[5297833,5297146],"length":1,"stats":{"Line":2},"fn_name":null},{"line":876,"address":[4312544,4312564,4312559],"length":1,"stats":{"Line":5},"fn_name":"{{closure}}"},{"line":877,"address":[4312591,4312576,4312596],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":883,"address":[4312640,4312655,4312660],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":889,"address":[5298452],"length":1,"stats":{"Line":1},"fn_name":null},{"line":893,"address":[5298559],"length":1,"stats":{"Line":1},"fn_name":null},{"line":894,"address":[5298583],"length":1,"stats":{"Line":1},"fn_name":null},{"line":895,"address":[5298676,5298616,5298706],"length":1,"stats":{"Line":3},"fn_name":null},{"line":896,"address":[5298713],"length":1,"stats":{"Line":1},"fn_name":null},{"line":898,"address":[5298773],"length":1,"stats":{"Line":1},"fn_name":null},{"line":899,"address":[5298823],"length":1,"stats":{"Line":1},"fn_name":null},{"line":900,"address":[5298893],"length":1,"stats":{"Line":1},"fn_name":null},{"line":901,"address":[5299014,5299602,5299186],"length":1,"stats":{"Line":1},"fn_name":null},{"line":907,"address":[5299671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":908,"address":[4312781,4312768],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":909,"address":[4312800,4312811],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":910,"address":[5299887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":916,"address":[4312926,4312912],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":917,"address":[4312971,4312960],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":918,"address":[5300249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":924,"address":[4313086,4313072],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":925,"address":[5300538,5300494],"length":1,"stats":{"Line":2},"fn_name":null},{"line":926,"address":[4313120,4313131],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":927,"address":[5300751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":933,"address":[4313232,4313246],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":934,"address":[5301147],"length":1,"stats":{"Line":1},"fn_name":null},{"line":935,"address":[5301180,5301212],"length":1,"stats":{"Line":2},"fn_name":null},{"line":936,"address":[5301228],"length":1,"stats":{"Line":1},"fn_name":null},{"line":937,"address":[5301235],"length":1,"stats":{"Line":1},"fn_name":null},{"line":939,"address":[4313280,4313291],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":940,"address":[5301337,5303818,5301266],"length":1,"stats":{"Line":3},"fn_name":null},{"line":941,"address":[5301567,5304380,5301467],"length":1,"stats":{"Line":2},"fn_name":null},{"line":942,"address":[5301583,5301649],"length":1,"stats":{"Line":1},"fn_name":null},{"line":943,"address":[5301606,5301651,5302272],"length":1,"stats":{"Line":3},"fn_name":null},{"line":944,"address":[5303811,5301799,5303705,5301866,5301939,5302204],"length":1,"stats":{"Line":5},"fn_name":null},{"line":945,"address":[5303745],"length":1,"stats":{"Line":1},"fn_name":null},{"line":947,"address":[5302209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":949,"address":[5301717],"length":1,"stats":{"Line":1},"fn_name":null},{"line":951,"address":[5302321],"length":1,"stats":{"Line":1},"fn_name":null},{"line":954,"address":[5302687,5302342,5303879,5303985,5302422,5301552],"length":1,"stats":{"Line":5},"fn_name":null},{"line":955,"address":[5303919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":957,"address":[5303076,5303992,5302692],"length":1,"stats":{"Line":2},"fn_name":null},{"line":958,"address":[5303043,5303470,5303099,5304146],"length":1,"stats":{"Line":2},"fn_name":null},{"line":959,"address":[5303407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":966,"address":[5304572],"length":1,"stats":{"Line":1},"fn_name":null},{"line":967,"address":[5304588,5304647],"length":1,"stats":{"Line":2},"fn_name":null},{"line":968,"address":[5304617,5305513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":970,"address":[5304661],"length":1,"stats":{"Line":1},"fn_name":null},{"line":971,"address":[5304747],"length":1,"stats":{"Line":1},"fn_name":null},{"line":972,"address":[5304825,5305239,5305353,5305503],"length":1,"stats":{"Line":3},"fn_name":null},{"line":973,"address":[5305209,5305425],"length":1,"stats":{"Line":2},"fn_name":null},{"line":974,"address":[5305244],"length":1,"stats":{"Line":0},"fn_name":null},{"line":977,"address":[5305188],"length":1,"stats":{"Line":1},"fn_name":null},{"line":983,"address":[4313447,4313424],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":984,"address":[5305736],"length":1,"stats":{"Line":1},"fn_name":null},{"line":985,"address":[5305815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":989,"address":[4313552,4313575],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":990,"address":[5306072],"length":1,"stats":{"Line":1},"fn_name":null},{"line":991,"address":[5306151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":995,"address":[4313804,4313776],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":996,"address":[5306408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":997,"address":[5306487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1001,"address":[4314096,4314124],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":1002,"address":[5306760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1003,"address":[5306839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1007,"address":[4314535,4314512],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":1008,"address":[5307112],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1009,"address":[5307191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1013,"address":[4314704,4314654,4314640,4314727],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":1014,"address":[5307465],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1015,"address":[5307547],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1019,"address":[4314942,4315020,4314928,4314992],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":1020,"address":[5307817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1021,"address":[5307899],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1025,"address":[4315404,4315312,4315376,4315326],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":1026,"address":[5308185],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1027,"address":[5308267],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1031,"address":[5308554,5308439],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1032,"address":[5308582],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1033,"address":[5308589],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1034,"address":[5308681,5308905],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1035,"address":[5308843],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1042,"address":[5309508,5309450,5309412],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1045,"address":[5309603],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1051,"address":[5309743,5309695],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1052,"address":[5309767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1053,"address":[4315888,4315902],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1055,"address":[4316030,4316016],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":1057,"address":[5310880,5310618,5310147,5310483],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1058,"address":[4316110,4316096],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1069,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1070,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1075,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1076,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1081,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1082,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1083,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1085,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1086,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1095,"address":[5311599,5311715],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1096,"address":[5311858,5311804,5311730],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1097,"address":[5311747,5311792],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1098,"address":[5311821],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1099,"address":[5312025,5311775,5311873],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1100,"address":[5311937],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1102,"address":[5312074],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1110,"address":[4316318,4316304],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":1111,"address":[5312383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1114,"address":[5312366,5312443],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1115,"address":[5312497],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1117,"address":[5312578],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1118,"address":[5312773,5312620,5312711],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1119,"address":[5312649,5312699],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1120,"address":[5312716],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1121,"address":[5312775,5312669],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1123,"address":[5312863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1130,"address":[4316432,4316475],"length":1,"stats":{"Line":1},"fn_name":"collapse_adjacent<fn(f64, f64) -> f64>"},{"line":1133,"address":[4316455],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1134,"address":[4316490,4316801,4316525,4317171,4316617],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1135,"address":[4317002,4316851,4317239,4317169],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1136,"address":[4316953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1138,"address":[4316928,4317301,4317012,4317271],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1141,"address":[4316756],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1144,"address":[4316384,4316398],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":1145,"address":[5313176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1148,"address":[5313147,5313234],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1150,"address":[5313348,5313522],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1151,"address":[5313409],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1153,"address":[5313391,5313532],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1155,"address":[5313571],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1161,"address":[5313865,5313746],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1162,"address":[5314313,5314165,5313907],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1163,"address":[5314016,5313936],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1164,"address":[5313942,5314178],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":451,"coverable":480},{"path":["/","home","kms","itertools","tests","specializations.rs"],"content":"use itertools::{EitherOrBoth, Itertools};\nuse std::fmt::Debug;\nuse std::ops::BitXor;\nuse quickcheck::quickcheck;\n\nstruct Unspecialized<I>(I);\nimpl<I> Iterator for Unspecialized<I>\nwhere\n    I: Iterator,\n{\n    type Item = I::Item;\n\n    #[inline(always)]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.0.next()\n    }\n\n    #[inline(always)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.0.size_hint()\n    }\n}\n\nfn check_specialized<'a, V, IterItem, Iter, F>(iterator: &Iter, mapper: F)\nwhere\n    V: Eq + Debug,\n    IterItem: 'a,\n    Iter: Iterator<Item = IterItem> + Clone + 'a,\n    F: Fn(Box<dyn Iterator<Item = IterItem> + 'a>) -> V,\n{\n    assert_eq!(\n        mapper(Box::new(Unspecialized(iterator.clone()))),\n        mapper(Box::new(iterator.clone()))\n    )\n}\n\nfn check_specialized_count_last_nth_sizeh<'a, IterItem, Iter>(\n    it: &Iter,\n    known_expected_size: Option<usize>,\n) where\n    IterItem: 'a + Eq + Debug,\n    Iter: Iterator<Item = IterItem> + Clone + 'a,\n{\n    let size = it.clone().count();\n    if let Some(expected_size) = known_expected_size {\n        assert_eq!(size, expected_size);\n    }\n    check_specialized(it, |i| i.count());\n    check_specialized(it, |i| i.last());\n    for n in 0..size + 2 {\n        check_specialized(it, |mut i| i.nth(n));\n    }\n    let mut it_sh = it.clone();\n    for n in 0..size + 2 {\n        let len = it_sh.clone().count();\n        let (min, max) = it_sh.size_hint();\n        assert_eq!((size - n.min(size)), len);\n        assert!(min <= len);\n        if let Some(max) = max {\n            assert!(len <= max);\n        }\n        it_sh.next();\n    }\n}\n\nfn check_specialized_fold_xor<'a, IterItem, Iter>(it: &Iter)\nwhere\n    IterItem: 'a\n        + BitXor\n        + Eq\n        + Debug\n        + BitXor<<IterItem as BitXor>::Output, Output = <IterItem as BitXor>::Output>\n        + Clone,\n    <IterItem as BitXor>::Output:\n        BitXor<Output = <IterItem as BitXor>::Output> + Eq + Debug + Clone,\n    Iter: Iterator<Item = IterItem> + Clone + 'a,\n{\n    check_specialized(it, |mut i| {\n        let first = i.next().map(|f| f.clone() ^ (f.clone() ^ f));\n        i.fold(first, |acc, v: IterItem| acc.map(move |a| v ^ a))\n    });\n}\n\nfn put_back_test(test_vec: Vec<i32>, known_expected_size: Option<usize>) {\n    {\n        // Lexical lifetimes support\n        let pb = itertools::put_back(test_vec.iter());\n        check_specialized_count_last_nth_sizeh(&pb, known_expected_size);\n        check_specialized_fold_xor(&pb);\n    }\n\n    let mut pb = itertools::put_back(test_vec.into_iter());\n    pb.put_back(1);\n    check_specialized_count_last_nth_sizeh(&pb, known_expected_size.map(|x| x + 1));\n    check_specialized_fold_xor(&pb)\n}\n\n#[test]\nfn put_back() {\n    put_back_test(vec![7, 4, 1], Some(3));\n}\n\nquickcheck! {\n    fn put_back_qc(test_vec: Vec<i32>) -> () {\n        put_back_test(test_vec, None)\n    }\n}\n\nfn merge_join_by_test(i1: Vec<usize>, i2: Vec<usize>, known_expected_size: Option<usize>) {\n    let i1 = i1.into_iter();\n    let i2 = i2.into_iter();\n    let mjb = i1.clone().merge_join_by(i2.clone(), std::cmp::Ord::cmp);\n    check_specialized_count_last_nth_sizeh(&mjb, known_expected_size);\n    // Rust 1.24 compatibility:\n    fn eob_left_z(eob: EitherOrBoth<usize, usize>) -> usize {\n        eob.left().unwrap_or(0)\n    }\n    fn eob_right_z(eob: EitherOrBoth<usize, usize>) -> usize {\n        eob.left().unwrap_or(0)\n    }\n    fn eob_both_z(eob: EitherOrBoth<usize, usize>) -> usize {\n        let (a, b) = eob.both().unwrap_or((0, 0));\n        assert_eq!(a, b);\n        a\n    }\n    check_specialized_fold_xor(&mjb.clone().map(eob_left_z));\n    check_specialized_fold_xor(&mjb.clone().map(eob_right_z));\n    check_specialized_fold_xor(&mjb.clone().map(eob_both_z));\n\n    // And the other way around\n    let mjb = i2.merge_join_by(i1, std::cmp::Ord::cmp);\n    check_specialized_count_last_nth_sizeh(&mjb, known_expected_size);\n    check_specialized_fold_xor(&mjb.clone().map(eob_left_z));\n    check_specialized_fold_xor(&mjb.clone().map(eob_right_z));\n    check_specialized_fold_xor(&mjb.clone().map(eob_both_z));\n}\n\n#[test]\nfn merge_join_by() {\n    let i1 = vec![1, 3, 5, 7, 8, 9];\n    let i2 = vec![0, 3, 4, 5];\n    merge_join_by_test(i1, i2, Some(8));\n}\n\nquickcheck! {\n    fn merge_join_by_qc(i1: Vec<usize>, i2: Vec<usize>) -> () {\n        merge_join_by_test(i1, i2, None)\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[4272400,4272432,4277008,4270496,4270528,4273344,4265872,4268704,4264992,4265024,4274208,4275141,4266822,4274240,4269616,4276000,4276038,4277040,4266784,4267792,4271430,4267824,4273312,4275104,4269653,4265909,4268672,4271392],"length":1,"stats":{"Line":20},"fn_name":"check_specialized<core::option::Option<&i32>,&i32,itertools::adaptors::PutBack<core::slice::Iter<i32>>,closure-1>"},{"line":31,"address":[4270026,4275526,4269132,4270112,4270999,4272010,4277510,4273826,4273746,4277413,4274722,4272915,4271999,4272926,4272829,4270913,4266311,4267402,4268282,4267295,4273837,4274711,4267391,4269229,4269218,4268271,4271010,4274625,4266391,4266402,4268185,4265494,4275612,4276607,4276618,4271903,4275623,4265397,4270123,4276511,4277499,4265483],"length":1,"stats":{"Line":44},"fn_name":null},{"line":32,"address":[4265924,4266837,4267019,4269668,4272560,4275121,4276015,4276235,4265889,4271445,4268684,4274220,4265004,4265152,4275156,4267839,4273359,4269633,4274255,4273324,4269781,4267804,4266106,4272447,4274370,4277020,4270658,4275271,4270508,4265039,4276053,4277168,4267954,4271627,4268719,4271407,4277055,4266799,4268901,4270543,4272412,4273541],"length":1,"stats":{"Line":66},"fn_name":null},{"line":33,"address":[4273682,4276413,4269055,4266162,4268108,4267109,4269949,4268970,4271805,4266247,4274451,4267197,4273597,4265221,4269850,4275352,4277237,4277336,4276325,4270739,4271717,4274536,4275437,4272641,4272740,4265320,4268023,4270824],"length":1,"stats":{"Line":44},"fn_name":null},{"line":37,"address":[4282016,4280022,4282070,4279968,4277958,4277904],"length":1,"stats":{"Line":4},"fn_name":"check_specialized_count_last_nth_sizeh<itertools::either_or_both::EitherOrBoth<usize, usize>,itertools::merge_join::MergeJoinBy<alloc::vec::IntoIter<usize>, alloc::vec::IntoIter<usize>, fn(&usize, &usize) -> core::cmp::Ordering>>"},{"line":44,"address":[4282047,4282085,4277935,4280037,4279999,4277973],"length":1,"stats":{"Line":10},"fn_name":null},{"line":45,"address":[4282106,4280186,4278122,4282234,4280058,4277994],"length":1,"stats":{"Line":8},"fn_name":null},{"line":46,"address":[4282137,4282246,4278025,4280198,4280089,4278134],"length":1,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[4284112,4278432,4284067,4284131,4280496,4284176,4284195,4284048,4282544],"length":1,"stats":{"Line":13},"fn_name":"{{closure}}<itertools::either_or_both::EitherOrBoth<usize, usize>,itertools::merge_join::MergeJoinBy<alloc::vec::IntoIter<usize>, alloc::vec::IntoIter<usize>, fn(&usize, &usize) -> core::cmp::Ordering>>"},{"line":49,"address":[4284304,4278445,4284259,4280509,4282557,4284240,4284390,4284368,4284323],"length":1,"stats":{"Line":15},"fn_name":"{{closure}}<&i32,itertools::adaptors::PutBack<core::slice::Iter<i32>>>"},{"line":50,"address":[4282775,4283925,4282862,4280522,4278663,4279847,4278458,4281901,4280814,4278750,4280727,4282570],"length":1,"stats":{"Line":10},"fn_name":null},{"line":51,"address":[4284656,4284678,4278713,4284544,4284451,4284563,4284432,4280777,4282825],"length":1,"stats":{"Line":15},"fn_name":"{{closure}}<&i32,itertools::adaptors::PutBack<core::slice::Iter<i32>>>"},{"line":53,"address":[4278640,4282752,4280704],"length":1,"stats":{"Line":5},"fn_name":null},{"line":54,"address":[4281888,4282867,4278982,4281046,4282970,4280935,4283955,4278871,4281931,4278755,4283068,4280819,4279877,4279834,4283912],"length":1,"stats":{"Line":15},"fn_name":null},{"line":55,"address":[4279048,4281112,4283134],"length":1,"stats":{"Line":5},"fn_name":null},{"line":56,"address":[4279104,4281168,4283190],"length":1,"stats":{"Line":5},"fn_name":null},{"line":57,"address":[4283464,4279959,4279159,4283245,4284037,4281442,4279929,4281223,4281983,4279378,4284007,4282013],"length":1,"stats":{"Line":5},"fn_name":null},{"line":58,"address":[4283787,4283428,4279342,4281406,4279701,4281765],"length":1,"stats":{"Line":5},"fn_name":null},{"line":59,"address":[4279688,4279734,4279777,4283774,4283820,4283863,4281798,4281841,4281752],"length":1,"stats":{"Line":15},"fn_name":null},{"line":60,"address":[4281843,4283836,4279750,4283865,4281814,4279779],"length":1,"stats":{"Line":5},"fn_name":null},{"line":62,"address":[4281881,4283903,4279825],"length":1,"stats":{"Line":5},"fn_name":null},{"line":66,"address":[4284768,4284816,4284784,4284800,4284832],"length":1,"stats":{"Line":7},"fn_name":"check_specialized_fold_xor<&i32,itertools::adaptors::PutBack<core::slice::Iter<i32>>>"},{"line":78,"address":[4287152,4284821,4284773,4284789,4287207,4287429,4287376,4286512,4284805,4284837,4286704,4286759,4286983,4286558,4286928],"length":1,"stats":{"Line":14},"fn_name":"{{closure}}<&i32,itertools::adaptors::PutBack<core::slice::Iter<i32>>>"},{"line":79,"address":[4287005,4285456,4287449,4287395,4286781,4285465,4285673,4285664,4285056,4286575,4285272,4286947,4287171,4284857,4287229,4286723,4285065,4285264,4284848,4286531],"length":1,"stats":{"Line":28},"fn_name":"{{closure}}<usize,core::iter::adapters::Map<itertools::merge_join::MergeJoinBy<alloc::vec::IntoIter<usize>, alloc::vec::IntoIter<usize>, fn(&usize, &usize) -> core::cmp::Ordering>, fn(itertools::either_or_both::EitherOrBoth<usize, usize>) -> usize>>"},{"line":80,"address":[4286296,4286352,4285872,4285968,4285982,4286456,4286016,4286064,4286374,4287042,4286432,4286606,4286030,4286272,4286818,4286136,4285884,4286192,4285934,4286077,4286213,4285920,4287480,4287266,4286112],"length":1,"stats":{"Line":35},"fn_name":"{{closure}}<i32,itertools::adaptors::PutBack<alloc::vec::IntoIter<i32>>>"},{"line":84,"address":[4364551,4364496],"length":1,"stats":{"Line":1},"fn_name":"put_back_test"},{"line":87,"address":[4364566,4364534],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[4364619],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[4364646],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[4364653],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[4364746],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[4287577,4287568],"length":1,"stats":{"Line":5},"fn_name":"{{closure}}"},{"line":95,"address":[4364819],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[4287653,4287648],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":100,"address":[4367108],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[4367236],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[4364928,4365099],"length":1,"stats":{"Line":1},"fn_name":"merge_join_by_test"},{"line":110,"address":[4364945],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[4365114,4365039],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[4366124,4365122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[4365225],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[4366400],"length":1,"stats":{"Line":1},"fn_name":"eob_left_z"},{"line":116,"address":[4366404],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[4366496],"length":1,"stats":{"Line":1},"fn_name":"eob_right_z"},{"line":119,"address":[4366500],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[4366592],"length":1,"stats":{"Line":1},"fn_name":"eob_both_z"},{"line":122,"address":[4366599],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[4366714,4366828],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[4366808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[4365266,4365307],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[4365375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[4365469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[4365547],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[4365646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[4365687,4365728],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[4365796],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[4365890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[4287712,4287717],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":140,"address":[4367410,4367303],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[4367428],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[4367500],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[4367684],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":64,"coverable":66},{"path":["/","home","kms","itertools","tests","test_core.rs"],"content":"//! Licensed under the Apache License, Version 2.0\n//! http://www.apache.org/licenses/LICENSE-2.0 or the MIT license\n//! http://opensource.org/licenses/MIT, at your\n//! option. This file may not be copied, modified, or distributed\n//! except according to those terms.\n#![no_std]\n\nuse core::iter;\nuse itertools as it;\nuse crate::it::Itertools;\nuse crate::it::interleave;\nuse crate::it::multizip;\nuse crate::it::free::put_back;\nuse crate::it::iproduct;\nuse crate::it::izip;\n\n#[test]\nfn product2() {\n    let s = \"αβ\";\n\n    let mut prod = iproduct!(s.chars(), 0..2);\n    assert!(prod.next() == Some(('α', 0)));\n    assert!(prod.next() == Some(('α', 1)));\n    assert!(prod.next() == Some(('β', 0)));\n    assert!(prod.next() == Some(('β', 1)));\n    assert!(prod.next() == None);\n}\n\n#[test]\nfn product_temporary() {\n    for (_x, _y, _z) in iproduct!(\n        [0, 1, 2].iter().cloned(),\n        [0, 1, 2].iter().cloned(),\n        [0, 1, 2].iter().cloned())\n    {\n        // ok\n    }\n}\n\n\n#[test]\nfn izip_macro() {\n    let mut zip = izip!(2..3);\n    assert!(zip.next() == Some(2));\n    assert!(zip.next().is_none());\n\n    let mut zip = izip!(0..3, 0..2, 0..2i8);\n    for i in 0..2 {\n        assert!((i as usize, i, i as i8) == zip.next().unwrap());\n    }\n    assert!(zip.next().is_none());\n\n    let xs: [isize; 0] = [];\n    let mut zip = izip!(0..3, 0..2, 0..2i8, &xs);\n    assert!(zip.next().is_none());\n}\n\n#[test]\nfn izip2() {\n    let _zip1: iter::Zip<_, _> = izip!(1.., 2..);\n    let _zip2: iter::Zip<_, _> = izip!(1.., 2.., );\n}\n\n#[test]\nfn izip3() {\n    let mut zip: iter::Map<iter::Zip<_, _>, _> = izip!(0..3, 0..2, 0..2i8);\n    for i in 0..2 {\n        assert!((i as usize, i, i as i8) == zip.next().unwrap());\n    }\n    assert!(zip.next().is_none());\n}\n\n#[test]\nfn multizip3() {\n    let mut zip = multizip((0..3, 0..2, 0..2i8));\n    for i in 0..2 {\n        assert!((i as usize, i, i as i8) == zip.next().unwrap());\n    }\n    assert!(zip.next().is_none());\n\n    let xs: [isize; 0] = [];\n    let mut zip = multizip((0..3, 0..2, 0..2i8, xs.iter()));\n    assert!(zip.next().is_none());\n\n    for (_, _, _, _, _) in multizip((0..3, 0..2, xs.iter(), &xs, xs.to_vec())) {\n        /* test compiles */\n    }\n}\n\n#[test]\nfn write_to() {\n    let xs = [7, 9, 8];\n    let mut ys = [0; 5];\n    let cnt = ys.iter_mut().set_from(xs.iter().map(|x| *x));\n    assert!(cnt == xs.len());\n    assert!(ys == [7, 9, 8, 0, 0]);\n\n    let cnt = ys.iter_mut().set_from(0..10);\n    assert!(cnt == ys.len());\n    assert!(ys == [0, 1, 2, 3, 4]);\n}\n\n#[test]\nfn test_interleave() {\n    let xs: [u8; 0]  = [];\n    let ys = [7u8, 9, 8, 10];\n    let zs = [2u8, 77];\n    let it = interleave(xs.iter(), ys.iter());\n    it::assert_equal(it, ys.iter());\n\n    let rs = [7u8, 2, 9, 77, 8, 10];\n    let it = interleave(ys.iter(), zs.iter());\n    it::assert_equal(it, rs.iter());\n}\n\n#[allow(deprecated)]\n#[test]\nfn foreach() {\n    let xs = [1i32, 2, 3];\n    let mut sum = 0;\n    xs.iter().foreach(|elt| sum += *elt);\n    assert!(sum == 6);\n}\n\n#[test]\nfn dropping() {\n    let xs = [1, 2, 3];\n    let mut it = xs.iter().dropping(2);\n    assert_eq!(it.next(), Some(&3));\n    assert!(it.next().is_none());\n    let mut it = xs.iter().dropping(5);\n    assert!(it.next().is_none());\n}\n\n#[test]\nfn batching() {\n    let xs = [0, 1, 2, 1, 3];\n    let ys = [(0, 1), (2, 1)];\n\n    // An iterator that gathers elements up in pairs\n    let pit = xs.iter().cloned().batching(|it| {\n               match it.next() {\n                   None => None,\n                   Some(x) => match it.next() {\n                       None => None,\n                       Some(y) => Some((x, y)),\n                   }\n               }\n           });\n    it::assert_equal(pit, ys.iter().cloned());\n}\n\n#[test]\nfn test_put_back() {\n    let xs = [0, 1, 1, 1, 2, 1, 3, 3];\n    let mut pb = put_back(xs.iter().cloned());\n    pb.next();\n    pb.put_back(1);\n    pb.put_back(0);\n    it::assert_equal(pb, xs.iter().cloned());\n}\n\n#[allow(deprecated)]\n#[test]\nfn step() {\n    it::assert_equal((0..10).step(1), 0..10);\n    it::assert_equal((0..10).step(2), (0..10).filter(|x: &i32| *x % 2 == 0));\n    it::assert_equal((0..10).step(10), 0..1);\n}\n\n#[allow(deprecated)]\n#[test]\nfn merge() {\n    it::assert_equal((0..10).step(2).merge((1..10).step(2)), 0..10);\n}\n\n\n#[test]\nfn repeatn() {\n    let s = \"α\";\n    let mut it = it::repeat_n(s, 3);\n    assert_eq!(it.len(), 3);\n    assert_eq!(it.next(), Some(s));\n    assert_eq!(it.next(), Some(s));\n    assert_eq!(it.next(), Some(s));\n    assert_eq!(it.next(), None);\n    assert_eq!(it.next(), None);\n}\n\n#[test]\nfn count_clones() {\n    // Check that RepeatN only clones N - 1 times.\n\n    use core::cell::Cell;\n    #[derive(PartialEq, Debug)]\n    struct Foo {\n        n: Cell<usize>\n    }\n\n    impl Clone for Foo\n    {\n        fn clone(&self) -> Self\n        {\n            let n = self.n.get();\n            self.n.set(n + 1);\n            Foo { n: Cell::new(n + 1) }\n        }\n    }\n\n\n    for n in 0..10 {\n        let f = Foo{n: Cell::new(0)};\n        let it = it::repeat_n(f, n);\n        // drain it\n        let last = it.last();\n        if n == 0 {\n            assert_eq!(last, None);\n        } else {\n            assert_eq!(last, Some(Foo{n: Cell::new(n - 1)}));\n        }\n    }\n}\n\n#[test]\nfn part() {\n    let mut data = [7, 1, 1, 9, 1, 1, 3];\n    let i = it::partition(&mut data, |elt| *elt >= 3);\n    assert_eq!(i, 3);\n    assert_eq!(data, [7, 3, 9, 1, 1, 1, 1]);\n\n    let i = it::partition(&mut data, |elt| *elt == 1);\n    assert_eq!(i, 4);\n    assert_eq!(data, [1, 1, 1, 1, 9, 3, 7]);\n\n    let mut data = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let i = it::partition(&mut data, |elt| *elt % 3 == 0);\n    assert_eq!(i, 3);\n    assert_eq!(data, [9, 6, 3, 4, 5, 2, 7, 8, 1]);\n}\n\n#[test]\nfn tree_fold1() {\n    for i in 0..100 {\n        assert_eq!((0..i).tree_fold1(|x, y| x + y), (0..i).fold1(|x, y| x + y));\n    }\n}\n\n#[test]\nfn exactly_one() {\n    assert_eq!((0..10).filter(|&x| x == 2).exactly_one().unwrap(), 2);\n    assert!((0..10).filter(|&x| x > 1 && x < 4).exactly_one().unwrap_err().eq(2..4));\n    assert!((0..10).filter(|&x| x > 1 && x < 5).exactly_one().unwrap_err().eq(2..5));\n    assert!((0..10).filter(|&_| false).exactly_one().unwrap_err().eq(0..0));\n}\n\n#[test]\nfn sum1() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq!(v[..0].iter().cloned().sum1::<i32>(), None);\n    assert_eq!(v[1..2].iter().cloned().sum1::<i32>(), Some(1));\n    assert_eq!(v[1..3].iter().cloned().sum1::<i32>(), Some(3));\n    assert_eq!(v.iter().cloned().sum1::<i32>(), Some(55));\n}\n\n#[test]\nfn product1() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq!(v[..0].iter().cloned().product1::<i32>(), None);\n    assert_eq!(v[..1].iter().cloned().product1::<i32>(), Some(0));\n    assert_eq!(v[1..3].iter().cloned().product1::<i32>(), Some(2));\n    assert_eq!(v[1..5].iter().cloned().product1::<i32>(), Some(24));\n}\n","traces":[{"line":18,"address":[4210512,4210517],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":19,"address":[4227326],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[4227343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[4227485,4227577],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[4227633,4227699,4227549],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[4227755,4227821,4227671],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[4227793,4227943,4227877],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[4228044,4228091,4227999,4227915],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[4228096],"length":1,"stats":{"Line":3},"fn_name":"product_temporary"},{"line":31,"address":[4228260,4228394,4228180,4228559],"length":1,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[4228110],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[4228202],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[4228336],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[4210576,4210581],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":43,"address":[4228711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[4228753,4228842],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[4228983,4228814,4228891],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[4210619],"length":1,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[4229475,4229310,4229168],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[4229354,4229487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[4229284,4229536,4229621],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[4210683],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[4229943,4229833,4229896],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[4210768,4210773],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":60,"address":[4229956],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[4230003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[4230064],"length":1,"stats":{"Line":3},"fn_name":"izip3"},{"line":66,"address":[4210843],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[4230393,4230555,4230254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[4230437,4230567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[4230658,4230705,4230370,4230616],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[4210896,4210901],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":75,"address":[4230727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[4231211,4231049,4230910],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[4231093,4231223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[4231272,4231395,4231026],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[4231303,4231444],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[4231705,4231577],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[4232081,4232038,4231629,4231756],"length":1,"stats":{"Line":3},"fn_name":null},{"line":91,"address":[4210928,4210933],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":92,"address":[4232327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[4232351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[4210960,4210973],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":95,"address":[4232587,4232491],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[4232689,4232640,4232558],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[4232738,4232659],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[4232795,4232894],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[4232947,4233015,4232865,4232968],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[4210997,4210992],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":106,"address":[4233035],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[4233055],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[4233065],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[4233143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[4233223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[4233271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[4233360],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[4211029,4211024],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":119,"address":[4233460],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[4233484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[4211070,4211056],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":122,"address":[4233617,4233550,4233576],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[4211152,4211157],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":127,"address":[4233639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[4233669],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[4233733,4233878],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[4233852,4234183,4234247],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[4234210,4234311],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[4234444,4234332,4234395],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[4211189,4211184],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":137,"address":[4234455],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[4234495],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[4211216],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":142,"address":[4211278,4211291,4211398,4211233],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[4211263,4211285],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[4211347,4211293,4211334],"length":1,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[4211341,4211319],"length":1,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[4211349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[4234655],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[4211429,4211424],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":155,"address":[4234775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[4234839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[4234912],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[4234922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[4234939],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[4234949],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[4211461,4211456],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":166,"address":[4235079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[4211502,4211488],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":168,"address":[4235246],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[4211605,4211600],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":174,"address":[4235351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[4211632,4211637],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":180,"address":[4235534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[4235554],"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[4235588,4235746],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[4236076,4236247,4235713],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[4236582,4236221,4236753],"length":1,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[4237259,4237088,4236727],"length":1,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[4237577,4237702,4237233],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[4238113,4238014,4237676],"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[4211669,4211664],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":202,"address":[4239696],"length":1,"stats":{"Line":1},"fn_name":"clone"},{"line":204,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[4238569,4239654,4238423],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[4238623],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[4238646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[4238675],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[4238736,4238881,4239346],"length":1,"stats":{"Line":3},"fn_name":null},{"line":217,"address":[4238790,4238886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[4239689,4238747,4239659,4239196,4239351],"length":1,"stats":{"Line":2},"fn_name":null},{"line":225,"address":[4211701,4211696],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":226,"address":[4240215],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[4211728,4211741],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":228,"address":[4240320,4240512],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[4240849,4240881,4240416],"length":1,"stats":{"Line":2},"fn_name":null},{"line":231,"address":[4211776,4211789],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":232,"address":[4241415,4241223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[4241883,4241752,4241319],"length":1,"stats":{"Line":2},"fn_name":null},{"line":235,"address":[4241758],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[4211824,4211838],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":237,"address":[4242390,4242201],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[4242708,4242694,4242297],"length":1,"stats":{"Line":2},"fn_name":null},{"line":242,"address":[4211936,4211941],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":243,"address":[4243327,4243031,4243125],"length":1,"stats":{"Line":2},"fn_name":null},{"line":244,"address":[4211968,4212048,4212065,4211985],"length":1,"stats":{"Line":5},"fn_name":"{{closure}}"},{"line":249,"address":[4212128,4212133],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":250,"address":[4212160,4212173],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":251,"address":[4212221,4212208],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":252,"address":[4212301,4212288],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":253,"address":[4212368,4212383,4212393],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":257,"address":[4212400,4212405],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":258,"address":[4244814],"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[4245186,4244834],"length":1,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[4245816,4245104,4245537],"length":1,"stats":{"Line":2},"fn_name":null},{"line":261,"address":[4245734,4246394,4246167],"length":1,"stats":{"Line":2},"fn_name":null},{"line":262,"address":[4246358,4246709,4246859],"length":1,"stats":{"Line":2},"fn_name":null},{"line":266,"address":[4212432,4212437],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":267,"address":[4247182],"length":1,"stats":{"Line":1},"fn_name":null},{"line":268,"address":[4247534,4247202],"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[4247472,4247885,4248164],"length":1,"stats":{"Line":2},"fn_name":null},{"line":270,"address":[4248515,4248794,4248082],"length":1,"stats":{"Line":2},"fn_name":null},{"line":271,"address":[4248712,4249115,4249290],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":144,"coverable":144},{"path":["/","home","kms","itertools","tests","test_std.rs"],"content":"use permutohedron;\nuse itertools as it;\nuse crate::it::Itertools;\nuse crate::it::multizip;\nuse crate::it::multipeek;\nuse crate::it::peek_nth;\nuse crate::it::free::rciter;\nuse crate::it::free::put_back_n;\nuse crate::it::FoldWhile;\nuse crate::it::cloned;\nuse crate::it::iproduct;\nuse crate::it::izip;\n\n#[test]\nfn product3() {\n    let prod = iproduct!(0..3, 0..2, 0..2);\n    assert_eq!(prod.size_hint(), (12, Some(12)));\n    let v = prod.collect_vec();\n    for i in 0..3 {\n        for j in 0..2 {\n            for k in 0..2 {\n                assert!((i, j, k) == v[(i * 2 * 2 + j * 2 + k) as usize]);\n            }\n        }\n    }\n    for (_, _, _, _) in iproduct!(0..3, 0..2, 0..2, 0..3) {\n        /* test compiles */\n    }\n}\n\n#[test]\nfn interleave_shortest() {\n    let v0: Vec<i32> = vec![0, 2, 4];\n    let v1: Vec<i32> = vec![1, 3, 5, 7];\n    let it = v0.into_iter().interleave_shortest(v1.into_iter());\n    assert_eq!(it.size_hint(), (6, Some(6)));\n    assert_eq!(it.collect_vec(), vec![0, 1, 2, 3, 4, 5]);\n\n    let v0: Vec<i32> = vec![0, 2, 4, 6, 8];\n    let v1: Vec<i32> = vec![1, 3, 5];\n    let it = v0.into_iter().interleave_shortest(v1.into_iter());\n    assert_eq!(it.size_hint(), (7, Some(7)));\n    assert_eq!(it.collect_vec(), vec![0, 1, 2, 3, 4, 5, 6]);\n\n    let i0 = ::std::iter::repeat(0);\n    let v1: Vec<_> = vec![1, 3, 5];\n    let it = i0.interleave_shortest(v1.into_iter());\n    assert_eq!(it.size_hint(), (7, Some(7)));\n\n    let v0: Vec<_> = vec![0, 2, 4];\n    let i1 = ::std::iter::repeat(1);\n    let it = v0.into_iter().interleave_shortest(i1);\n    assert_eq!(it.size_hint(), (6, Some(6)));\n}\n\n\n#[test]\nfn unique_by() {\n    let xs = [\"aaa\", \"bbbbb\", \"aa\", \"ccc\", \"bbbb\", \"aaaaa\", \"cccc\"];\n    let ys = [\"aaa\", \"bbbbb\", \"ccc\"];\n    it::assert_equal(ys.iter(), xs.iter().unique_by(|x| x[..2].to_string()));\n    it::assert_equal(ys.iter(), xs.iter().rev().unique_by(|x| x[..2].to_string()).rev());\n    let ys_rev = [\"cccc\", \"aaaaa\", \"bbbb\"];\n    it::assert_equal(ys_rev.iter(), xs.iter().unique_by(|x| x[..2].to_string()).rev());\n}\n\n#[test]\nfn unique() {\n    let xs = [0, 1, 2, 3, 2, 1, 3];\n    let ys = [0, 1, 2, 3];\n    it::assert_equal(ys.iter(), xs.iter().unique());\n    it::assert_equal(ys.iter(), xs.iter().rev().unique().rev());\n    let ys_rev = [3, 1, 2, 0];\n    it::assert_equal(ys_rev.iter(), xs.iter().unique().rev());\n\n    let xs = [0, 1];\n    let ys = [0, 1];\n    it::assert_equal(ys.iter(), xs.iter().unique());\n    it::assert_equal(ys.iter(), xs.iter().rev().unique().rev());\n    let ys_rev = [1, 0];\n    it::assert_equal(ys_rev.iter(), xs.iter().unique().rev());\n}\n\n#[test]\nfn intersperse() {\n    let xs = [\"a\", \"\", \"b\", \"c\"];\n    let v: Vec<&str> = xs.iter().map(|x| x.clone()).intersperse(\", \").collect();\n    let text: String = v.concat();\n    assert_eq!(text, \"a, , b, c\".to_string());\n\n    let ys = [0, 1, 2, 3];\n    let mut it = ys[..0].iter().map(|x| *x).intersperse(1);\n    assert!(it.next() == None);\n}\n\n#[test]\nfn dedup() {\n    let xs = [0, 1, 1, 1, 2, 1, 3, 3];\n    let ys = [0, 1, 2, 1, 3];\n    it::assert_equal(ys.iter(), xs.iter().dedup());\n    let xs = [0, 0, 0, 0, 0];\n    let ys = [0];\n    it::assert_equal(ys.iter(), xs.iter().dedup());\n\n    let xs = [0, 1, 1, 1, 2, 1, 3, 3];\n    let ys = [0, 1, 2, 1, 3];\n    let mut xs_d = Vec::new();\n    xs.iter().dedup().fold((), |(), &elt| xs_d.push(elt));\n    assert_eq!(&xs_d, &ys);\n}\n\n#[test]\nfn dedup_by() {\n    let xs = [(0, 0), (0, 1), (1, 1), (2, 1), (0, 2), (3, 1), (0, 3), (1, 3)];\n    let ys = [(0, 0), (0, 1), (0, 2), (3, 1), (0, 3)];\n    it::assert_equal(ys.iter(), xs.iter().dedup_by(|x, y| x.1==y.1));\n    let xs = [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)];\n    let ys = [(0, 1)];\n    it::assert_equal(ys.iter(), xs.iter().dedup_by(|x, y| x.0==y.0));\n\n    let xs = [(0, 0), (0, 1), (1, 1), (2, 1), (0, 2), (3, 1), (0, 3), (1, 3)];\n    let ys = [(0, 0), (0, 1), (0, 2), (3, 1), (0, 3)];\n    let mut xs_d = Vec::new();\n    xs.iter().dedup_by(|x, y| x.1==y.1).fold((), |(), &elt| xs_d.push(elt));\n    assert_eq!(&xs_d, &ys);\n}\n\n#[test]\nfn dedup_with_count() {\n    let xs: [i32; 8] = [0, 1, 1, 1, 2, 1, 3, 3];\n    let ys: [(usize, &i32); 5] = [(1, &0), (3, &1), (1, &2), (1, &1), (2, &3)];\n\n    it::assert_equal(ys.iter().cloned(), xs.iter().dedup_with_count());\n\n    let xs: [i32; 5] = [0, 0, 0, 0, 0];\n    let ys: [(usize, &i32); 1] = [(5, &0)];\n\n    it::assert_equal(ys.iter().cloned(), xs.iter().dedup_with_count());\n}\n\n\n#[test]\nfn dedup_by_with_count() {\n    let xs = [(0, 0), (0, 1), (1, 1), (2, 1), (0, 2), (3, 1), (0, 3), (1, 3)];\n    let ys = [(1, &(0, 0)), (3, &(0, 1)), (1, &(0, 2)), (1, &(3, 1)), (2, &(0, 3))];\n\n    it::assert_equal(ys.iter().cloned(), xs.iter().dedup_by_with_count(|x, y| x.1==y.1));\n\n    let xs = [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)];\n    let ys = [( 5, &(0, 1))];\n\n    it::assert_equal(ys.iter().cloned(), xs.iter().dedup_by_with_count(|x, y| x.0==y.0));\n}\n\n#[test]\nfn all_equal() {\n    assert!(\"\".chars().all_equal());\n    assert!(\"A\".chars().all_equal());\n    assert!(!\"AABBCCC\".chars().all_equal());\n    assert!(\"AAAAAAA\".chars().all_equal());\n    for (_key, mut sub) in &\"AABBCCC\".chars().group_by(|&x| x) {\n        assert!(sub.all_equal());\n    }\n}\n\n#[test]\nfn test_put_back_n() {\n    let xs = [0, 1, 1, 1, 2, 1, 3, 3];\n    let mut pb = put_back_n(xs.iter().cloned());\n    pb.next();\n    pb.next();\n    pb.put_back(1);\n    pb.put_back(0);\n    it::assert_equal(pb, xs.iter().cloned());\n}\n\n#[test]\nfn tee() {\n    let xs  = [0, 1, 2, 3];\n    let (mut t1, mut t2) = xs.iter().cloned().tee();\n    assert_eq!(t1.next(), Some(0));\n    assert_eq!(t2.next(), Some(0));\n    assert_eq!(t1.next(), Some(1));\n    assert_eq!(t1.next(), Some(2));\n    assert_eq!(t1.next(), Some(3));\n    assert_eq!(t1.next(), None);\n    assert_eq!(t2.next(), Some(1));\n    assert_eq!(t2.next(), Some(2));\n    assert_eq!(t1.next(), None);\n    assert_eq!(t2.next(), Some(3));\n    assert_eq!(t2.next(), None);\n    assert_eq!(t1.next(), None);\n    assert_eq!(t2.next(), None);\n\n    let (t1, t2) = xs.iter().cloned().tee();\n    it::assert_equal(t1, xs.iter().cloned());\n    it::assert_equal(t2, xs.iter().cloned());\n\n    let (t1, t2) = xs.iter().cloned().tee();\n    it::assert_equal(t1.zip(t2), xs.iter().cloned().zip(xs.iter().cloned()));\n}\n\n\n#[test]\nfn test_rciter() {\n    let xs = [0, 1, 1, 1, 2, 1, 3, 5, 6];\n\n    let mut r1 = rciter(xs.iter().cloned());\n    let mut r2 = r1.clone();\n    assert_eq!(r1.next(), Some(0));\n    assert_eq!(r2.next(), Some(1));\n    let mut z = r1.zip(r2);\n    assert_eq!(z.next(), Some((1, 1)));\n    assert_eq!(z.next(), Some((2, 1)));\n    assert_eq!(z.next(), Some((3, 5)));\n    assert_eq!(z.next(), None);\n\n    // test intoiterator\n    let r1 = rciter(0..5);\n    let mut z = izip!(&r1, r1);\n    assert_eq!(z.next(), Some((0, 1)));\n}\n\n#[allow(deprecated)]\n#[test]\nfn trait_pointers() {\n    struct ByRef<'r, I: ?Sized>(&'r mut I) ;\n\n    impl<'r, X, I: ?Sized> Iterator for ByRef<'r, I> where\n        I: 'r + Iterator<Item=X>\n    {\n        type Item = X;\n        fn next(&mut self) -> Option<Self::Item>\n        {\n            self.0.next()\n        }\n    }\n\n    let mut it = Box::new(0..10) as Box<dyn Iterator<Item=i32>>;\n    assert_eq!(it.next(), Some(0));\n\n    {\n        /* make sure foreach works on non-Sized */\n        let jt: &mut dyn Iterator<Item = i32> = &mut *it;\n        assert_eq!(jt.next(), Some(1));\n\n        {\n            let mut r = ByRef(jt);\n            assert_eq!(r.next(), Some(2));\n        }\n\n        assert_eq!(jt.find_position(|x| *x == 4), Some((1, 4)));\n        jt.foreach(|_| ());\n    }\n}\n\n#[test]\nfn merge_by() {\n    let odd : Vec<(u32, &str)> = vec![(1, \"hello\"), (3, \"world\"), (5, \"!\")];\n    let even = vec![(2, \"foo\"), (4, \"bar\"), (6, \"baz\")];\n    let expected = vec![(1, \"hello\"), (2, \"foo\"), (3, \"world\"), (4, \"bar\"), (5, \"!\"), (6, \"baz\")];\n    let results = odd.iter().merge_by(even.iter(), |a, b| a.0 <= b.0);\n    it::assert_equal(results, expected.iter());\n}\n\n#[test]\nfn merge_by_btree() {\n    use std::collections::BTreeMap;\n    let mut bt1 = BTreeMap::new();\n    bt1.insert(\"hello\", 1);\n    bt1.insert(\"world\", 3);\n    let mut bt2 = BTreeMap::new();\n    bt2.insert(\"foo\", 2);\n    bt2.insert(\"bar\", 4);\n    let results = bt1.into_iter().merge_by(bt2.into_iter(), |a, b| a.0 <= b.0 );\n    let expected = vec![(\"bar\", 4), (\"foo\", 2), (\"hello\", 1), (\"world\", 3)];\n    it::assert_equal(results, expected.into_iter());\n}\n\n#[allow(deprecated)]\n#[test]\nfn kmerge() {\n    let its = (0..4).map(|s| (s..10).step(4));\n\n    it::assert_equal(its.kmerge(), 0..10);\n}\n\n#[allow(deprecated)]\n#[test]\nfn kmerge_2() {\n    let its = vec![3, 2, 1, 0].into_iter().map(|s| (s..10).step(4));\n\n    it::assert_equal(its.kmerge(), 0..10);\n}\n\n#[test]\nfn kmerge_empty() {\n    let its = (0..4).map(|_| 0..0);\n    assert_eq!(its.kmerge().next(), None);\n}\n\n#[test]\nfn kmerge_size_hint() {\n    let its = (0..5).map(|_| (0..10));\n    assert_eq!(its.kmerge().size_hint(), (50, Some(50)));\n}\n\n#[test]\nfn kmerge_empty_size_hint() {\n    let its = (0..5).map(|_| (0..0));\n    assert_eq!(its.kmerge().size_hint(), (0, Some(0)));\n}\n\n#[test]\nfn join() {\n    let many = [1, 2, 3];\n    let one  = [1];\n    let none: Vec<i32> = vec![];\n\n    assert_eq!(many.iter().join(\", \"), \"1, 2, 3\");\n    assert_eq!( one.iter().join(\", \"), \"1\");\n    assert_eq!(none.iter().join(\", \"), \"\");\n}\n\n#[test]\nfn sorted_by() {\n    let sc = [3, 4, 1, 2].iter().cloned().sorted_by(|&a, &b| {\n        a.cmp(&b)\n    });\n    it::assert_equal(sc, vec![1, 2, 3, 4]);\n\n    let v = (0..5).sorted_by(|&a, &b| a.cmp(&b).reverse());\n    it::assert_equal(v, vec![4, 3, 2, 1, 0]);\n}\n\n#[test]\nfn sorted_by_key() {\n    let sc = [3, 4, 1, 2].iter().cloned().sorted_by_key(|&x| x);\n    it::assert_equal(sc, vec![1, 2, 3, 4]);\n\n    let v = (0..5).sorted_by_key(|&x| -x);\n    it::assert_equal(v, vec![4, 3, 2, 1, 0]);\n}\n\n#[test]\nfn test_multipeek() {\n    let nums = vec![1u8,2,3,4,5];\n\n    let mp = multipeek(nums.iter().map(|&x| x));\n    assert_eq!(nums, mp.collect::<Vec<_>>());\n\n    let mut mp = multipeek(nums.iter().map(|&x| x));\n    assert_eq!(mp.peek(), Some(&1));\n    assert_eq!(mp.next(), Some(1));\n    assert_eq!(mp.peek(), Some(&2));\n    assert_eq!(mp.peek(), Some(&3));\n    assert_eq!(mp.next(), Some(2));\n    assert_eq!(mp.peek(), Some(&3));\n    assert_eq!(mp.peek(), Some(&4));\n    assert_eq!(mp.peek(), Some(&5));\n    assert_eq!(mp.peek(), None);\n    assert_eq!(mp.next(), Some(3));\n    assert_eq!(mp.next(), Some(4));\n    assert_eq!(mp.peek(), Some(&5));\n    assert_eq!(mp.peek(), None);\n    assert_eq!(mp.next(), Some(5));\n    assert_eq!(mp.next(), None);\n    assert_eq!(mp.peek(), None);\n\n}\n\n#[test]\nfn test_multipeek_reset() {\n    let data = [1, 2, 3, 4];\n\n    let mut mp = multipeek(cloned(&data));\n    assert_eq!(mp.peek(), Some(&1));\n    assert_eq!(mp.next(), Some(1));\n    assert_eq!(mp.peek(), Some(&2));\n    assert_eq!(mp.peek(), Some(&3));\n    mp.reset_peek();\n    assert_eq!(mp.peek(), Some(&2));\n    assert_eq!(mp.next(), Some(2));\n}\n\n#[test]\nfn test_multipeek_peeking_next() {\n    use crate::it::PeekingNext;\n    let nums = vec![1u8,2,3,4,5,6,7];\n\n    let mut mp = multipeek(nums.iter().map(|&x| x));\n    assert_eq!(mp.peeking_next(|&x| x != 0), Some(1));\n    assert_eq!(mp.next(), Some(2));\n    assert_eq!(mp.peek(), Some(&3));\n    assert_eq!(mp.peek(), Some(&4));\n    assert_eq!(mp.peeking_next(|&x| x == 3), Some(3));\n    assert_eq!(mp.peek(), Some(&4));\n    assert_eq!(mp.peeking_next(|&x| x != 4), None);\n    assert_eq!(mp.peeking_next(|&x| x == 4), Some(4));\n    assert_eq!(mp.peek(), Some(&5));\n    assert_eq!(mp.peek(), Some(&6));\n    assert_eq!(mp.peeking_next(|&x| x != 5), None);\n    assert_eq!(mp.peek(), Some(&7));\n    assert_eq!(mp.peeking_next(|&x| x == 5), Some(5));\n    assert_eq!(mp.peeking_next(|&x| x == 6), Some(6));\n    assert_eq!(mp.peek(), Some(&7));\n    assert_eq!(mp.peek(), None);\n    assert_eq!(mp.next(), Some(7));\n    assert_eq!(mp.peek(), None);\n}\n\n#[test]\nfn test_peek_nth() {\n    let nums = vec![1u8,2,3,4,5];\n\n    let iter = peek_nth(nums.iter().map(|&x| x));\n    assert_eq!(nums, iter.collect::<Vec<_>>());\n\n    let mut iter = peek_nth(nums.iter().map(|&x| x));\n\n    assert_eq!(iter.peek_nth(0), Some(&1));\n    assert_eq!(iter.peek_nth(0), Some(&1));\n    assert_eq!(iter.next(), Some(1));\n\n    assert_eq!(iter.peek_nth(0), Some(&2));\n    assert_eq!(iter.peek_nth(1), Some(&3));\n    assert_eq!(iter.next(), Some(2));\n\n    assert_eq!(iter.peek_nth(0), Some(&3));\n    assert_eq!(iter.peek_nth(1), Some(&4));\n    assert_eq!(iter.peek_nth(2), Some(&5));\n    assert_eq!(iter.peek_nth(3), None);\n\n    assert_eq!(iter.next(), Some(3));\n    assert_eq!(iter.next(), Some(4));\n\n    assert_eq!(iter.peek_nth(0), Some(&5));\n    assert_eq!(iter.peek_nth(1), None);\n    assert_eq!(iter.next(), Some(5));\n    assert_eq!(iter.next(), None);\n\n    assert_eq!(iter.peek_nth(0), None);\n    assert_eq!(iter.peek_nth(1), None);\n}\n\n#[test]\nfn test_peek_nth_peeking_next() {\n    use it::PeekingNext;\n    let nums = vec![1u8,2,3,4,5,6,7];\n    let mut iter = peek_nth(nums.iter().map(|&x| x));\n\n    assert_eq!(iter.peeking_next(|&x| x != 0), Some(1));\n    assert_eq!(iter.next(), Some(2));\n\n    assert_eq!(iter.peek_nth(0), Some(&3));\n    assert_eq!(iter.peek_nth(1), Some(&4));\n    assert_eq!(iter.peeking_next(|&x| x == 3), Some(3));\n    assert_eq!(iter.peek(), Some(&4));\n\n    assert_eq!(iter.peeking_next(|&x| x != 4), None);\n    assert_eq!(iter.peeking_next(|&x| x == 4), Some(4));\n    assert_eq!(iter.peek_nth(0), Some(&5));\n    assert_eq!(iter.peek_nth(1), Some(&6));\n\n    assert_eq!(iter.peeking_next(|&x| x != 5), None);\n    assert_eq!(iter.peek(), Some(&5));\n\n    assert_eq!(iter.peeking_next(|&x| x == 5), Some(5));\n    assert_eq!(iter.peeking_next(|&x| x == 6), Some(6));\n    assert_eq!(iter.peek_nth(0), Some(&7));\n    assert_eq!(iter.peek_nth(1), None);\n    assert_eq!(iter.next(), Some(7));\n    assert_eq!(iter.peek(), None);\n}\n\n#[test]\nfn pad_using() {\n    it::assert_equal((0..0).pad_using(1, |_| 1), 1..2);\n\n    let v: Vec<usize> = vec![0, 1, 2];\n    let r = v.into_iter().pad_using(5, |n| n);\n    it::assert_equal(r, vec![0, 1, 2, 3, 4]);\n\n    let v: Vec<usize> = vec![0, 1, 2];\n    let r = v.into_iter().pad_using(1, |_| panic!());\n    it::assert_equal(r, vec![0, 1, 2]);\n}\n\n#[test]\nfn group_by() {\n    for (ch1, sub) in &\"AABBCCC\".chars().group_by(|&x| x) {\n        for ch2 in sub {\n            assert_eq!(ch1, ch2);\n        }\n    }\n\n    for (ch1, sub) in &\"AAABBBCCCCDDDD\".chars().group_by(|&x| x) {\n        for ch2 in sub {\n            assert_eq!(ch1, ch2);\n            if ch1 == 'C' {\n                break;\n            }\n        }\n    }\n\n    let toupper = |ch: &char| ch.to_uppercase().nth(0).unwrap();\n\n    // try all possible orderings\n    for indices in permutohedron::Heap::new(&mut [0, 1, 2, 3]) {\n        let groups = \"AaaBbbccCcDDDD\".chars().group_by(&toupper);\n        let mut subs = groups.into_iter().collect_vec();\n\n        for &idx in &indices[..] {\n            let (key, text) = match idx {\n                 0 => ('A', \"Aaa\".chars()),\n                 1 => ('B', \"Bbb\".chars()),\n                 2 => ('C', \"ccCc\".chars()),\n                 3 => ('D', \"DDDD\".chars()),\n                 _ => unreachable!(),\n            };\n            assert_eq!(key, subs[idx].0);\n            it::assert_equal(&mut subs[idx].1, text);\n        }\n    }\n\n    let groups = \"AAABBBCCCCDDDD\".chars().group_by(|&x| x);\n    let mut subs = groups.into_iter().map(|(_, g)| g).collect_vec();\n\n    let sd = subs.pop().unwrap();\n    let sc = subs.pop().unwrap();\n    let sb = subs.pop().unwrap();\n    let sa = subs.pop().unwrap();\n    for (a, b, c, d) in multizip((sa, sb, sc, sd)) {\n        assert_eq!(a, 'A');\n        assert_eq!(b, 'B');\n        assert_eq!(c, 'C');\n        assert_eq!(d, 'D');\n    }\n\n    // check that the key closure is called exactly n times\n    {\n        let mut ntimes = 0;\n        let text = \"AABCCC\";\n        for (_, sub) in &text.chars().group_by(|&x| { ntimes += 1; x}) {\n            for _ in sub {\n            }\n        }\n        assert_eq!(ntimes, text.len());\n    }\n\n    {\n        let mut ntimes = 0;\n        let text = \"AABCCC\";\n        for _ in &text.chars().group_by(|&x| { ntimes += 1; x}) {\n        }\n        assert_eq!(ntimes, text.len());\n    }\n\n    {\n        let text = \"ABCCCDEEFGHIJJKK\";\n        let gr = text.chars().group_by(|&x| x);\n        it::assert_equal(gr.into_iter().flat_map(|(_, sub)| sub), text.chars());\n    }\n}\n\n#[test]\nfn group_by_lazy_2() {\n    let data = vec![0, 1];\n    let groups = data.iter().group_by(|k| *k);\n    let gs = groups.into_iter().collect_vec();\n    it::assert_equal(data.iter(), gs.into_iter().flat_map(|(_k, g)| g));\n\n    let data = vec![0, 1, 1, 0, 0];\n    let groups = data.iter().group_by(|k| *k);\n    let mut gs = groups.into_iter().collect_vec();\n    gs[1..].reverse();\n    it::assert_equal(&[0, 0, 0, 1, 1], gs.into_iter().flat_map(|(_, g)| g));\n\n    let grouper = data.iter().group_by(|k| *k);\n    let mut groups = Vec::new();\n    for (k, group) in &grouper {\n        if *k == 1 {\n            groups.push(group);\n        }\n    }\n    it::assert_equal(&mut groups[0], &[1, 1]);\n\n    let data = vec![0, 0, 0, 1, 1, 0, 0, 2, 2, 3, 3];\n    let grouper = data.iter().group_by(|k| *k);\n    let mut groups = Vec::new();\n    for (i, (_, group)) in grouper.into_iter().enumerate() {\n        if i < 2 {\n            groups.push(group);\n        } else if i < 4 {\n            for _ in group {\n            }\n        } else {\n            groups.push(group);\n        }\n    }\n    it::assert_equal(&mut groups[0], &[0, 0, 0]);\n    it::assert_equal(&mut groups[1], &[1, 1]);\n    it::assert_equal(&mut groups[2], &[3, 3]);\n\n    // use groups as chunks\n    let data = vec![0, 0, 0, 1, 1, 0, 0, 2, 2, 3, 3];\n    let mut i = 0;\n    let grouper = data.iter().group_by(move |_| { let k = i / 3; i += 1; k });\n    for (i, group) in &grouper {\n        match i {\n            0 => it::assert_equal(group, &[0, 0, 0]),\n            1 => it::assert_equal(group, &[1, 1, 0]),\n            2 => it::assert_equal(group, &[0, 2, 2]),\n            3 => it::assert_equal(group, &[3, 3]),\n            _ => unreachable!(),\n        }\n    }\n}\n\n#[test]\nfn group_by_lazy_3() {\n    // test consuming each group on the lap after it was produced\n    let data = vec![0, 0, 0, 1, 1, 0, 0, 1, 1, 2, 2];\n    let grouper = data.iter().group_by(|elt| *elt);\n    let mut last = None;\n    for (key, group) in &grouper {\n        if let Some(gr) = last.take() {\n            for elt in gr {\n                assert!(elt != key && i32::abs(elt - key) == 1);\n            }\n        }\n        last = Some(group);\n    }\n}\n\n#[test]\nfn chunks() {\n    let data = vec![0, 0, 0, 1, 1, 0, 0, 2, 2, 3, 3];\n    let grouper = data.iter().chunks(3);\n    for (i, chunk) in grouper.into_iter().enumerate() {\n        match i {\n            0 => it::assert_equal(chunk, &[0, 0, 0]),\n            1 => it::assert_equal(chunk, &[1, 1, 0]),\n            2 => it::assert_equal(chunk, &[0, 2, 2]),\n            3 => it::assert_equal(chunk, &[3, 3]),\n            _ => unreachable!(),\n        }\n    }\n}\n\n#[test]\nfn concat_empty() {\n    let data: Vec<Vec<()>> = Vec::new();\n    assert_eq!(data.into_iter().concat(), Vec::new())\n}\n\n#[test]\nfn concat_non_empty() {\n    let data = vec![vec![1,2,3], vec![4,5,6], vec![7,8,9]];\n    assert_eq!(data.into_iter().concat(), vec![1,2,3,4,5,6,7,8,9])\n}\n\n#[test]\nfn combinations() {\n    assert!((1..3).combinations(5).next().is_none());\n\n    let it = (1..3).combinations(2);\n    it::assert_equal(it, vec![\n        vec![1, 2],\n        ]);\n\n    let it = (1..5).combinations(2);\n    it::assert_equal(it, vec![\n        vec![1, 2],\n        vec![1, 3],\n        vec![1, 4],\n        vec![2, 3],\n        vec![2, 4],\n        vec![3, 4],\n        ]);\n\n    it::assert_equal((0..0).tuple_combinations::<(_, _)>(), <Vec<_>>::new());\n    it::assert_equal((0..1).tuple_combinations::<(_, _)>(), <Vec<_>>::new());\n    it::assert_equal((0..2).tuple_combinations::<(_, _)>(), vec![(0, 1)]);\n\n    it::assert_equal((0..0).combinations(2), <Vec<Vec<_>>>::new());\n    it::assert_equal((0..1).combinations(1), vec![vec![0]]);\n    it::assert_equal((0..2).combinations(1), vec![vec![0], vec![1]]);\n    it::assert_equal((0..2).combinations(2), vec![vec![0, 1]]);\n}\n\n#[test]\nfn combinations_of_too_short() {\n    for i in 1..10 {\n        assert!((0..0).combinations(i).next().is_none());\n        assert!((0..i - 1).combinations(i).next().is_none());\n    }\n}\n\n\n#[test]\nfn combinations_zero() {\n    it::assert_equal((1..3).combinations(0), vec![vec![]]);\n    it::assert_equal((0..0).combinations(0), vec![vec![]]);\n}\n\n#[test]\nfn permutations_zero() {\n    it::assert_equal((1..3).permutations(0), vec![vec![]]);\n    it::assert_equal((0..0).permutations(0), vec![vec![]]);\n}\n\n#[test]\nfn combinations_with_replacement() {\n    // Pool smaller than n\n    it::assert_equal((0..1).combinations_with_replacement(2), vec![vec![0, 0]]);\n    // Pool larger than n\n    it::assert_equal(\n        (0..3).combinations_with_replacement(2),\n        vec![\n            vec![0, 0],\n            vec![0, 1],\n            vec![0, 2],\n            vec![1, 1],\n            vec![1, 2],\n            vec![2, 2],\n        ],\n    );\n    // Zero size\n    it::assert_equal(\n        (0..3).combinations_with_replacement(0),\n        vec![vec![]],\n    );\n    // Zero size on empty pool\n    it::assert_equal(\n        (0..0).combinations_with_replacement(0),\n        vec![vec![]],\n    );\n    // Empty pool\n    it::assert_equal(\n        (0..0).combinations_with_replacement(2),\n        <Vec<Vec<_>>>::new(),\n    );\n}\n\n#[test]\nfn diff_mismatch() {\n    let a = vec![1, 2, 3, 4];\n    let b = vec![1.0, 5.0, 3.0, 4.0];\n    let b_map = b.into_iter().map(|f| f as i32);\n    let diff = it::diff_with(a.iter(), b_map, |a, b| *a == b);\n\n    assert!(match diff {\n        Some(it::Diff::FirstMismatch(1, _, from_diff)) =>\n            from_diff.collect::<Vec<_>>() == vec![5, 3, 4],\n        _ => false,\n    });\n}\n\n#[test]\nfn diff_longer() {\n    let a = vec![1, 2, 3, 4];\n    let b = vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0];\n    let b_map = b.into_iter().map(|f| f as i32);\n    let diff = it::diff_with(a.iter(), b_map, |a, b| *a == b);\n\n    assert!(match diff {\n        Some(it::Diff::Longer(_, remaining)) =>\n            remaining.collect::<Vec<_>>() == vec![5, 6],\n        _ => false,\n    });\n}\n\n#[test]\nfn diff_shorter() {\n    let a = vec![1, 2, 3, 4];\n    let b = vec![1.0, 2.0];\n    let b_map = b.into_iter().map(|f| f as i32);\n    let diff = it::diff_with(a.iter(), b_map, |a, b| *a == b);\n\n    assert!(match diff {\n        Some(it::Diff::Shorter(len, _)) => len == 2,\n        _ => false,\n    });\n}\n\n#[test]\nfn minmax() {\n    use std::cmp::Ordering;\n    use crate::it::MinMaxResult;\n\n    // A peculiar type: Equality compares both tuple items, but ordering only the\n    // first item.  This is so we can check the stability property easily.\n    #[derive(Clone, Debug, PartialEq, Eq)]\n    struct Val(u32, u32);\n\n    impl PartialOrd<Val> for Val {\n        fn partial_cmp(&self, other: &Val) -> Option<Ordering> {\n            self.0.partial_cmp(&other.0)\n        }\n    }\n\n    impl Ord for Val {\n        fn cmp(&self, other: &Val) -> Ordering {\n            self.0.cmp(&other.0)\n        }\n    }\n\n    assert_eq!(None::<Option<u32>>.iter().minmax(), MinMaxResult::NoElements);\n\n    assert_eq!(Some(1u32).iter().minmax(), MinMaxResult::OneElement(&1));\n\n    let data = vec![Val(0, 1), Val(2, 0), Val(0, 2), Val(1, 0), Val(2, 1)];\n\n    let minmax = data.iter().minmax();\n    assert_eq!(minmax, MinMaxResult::MinMax(&Val(0, 1), &Val(2, 1)));\n\n    let (min, max) = data.iter().minmax_by_key(|v| v.1).into_option().unwrap();\n    assert_eq!(min, &Val(2, 0));\n    assert_eq!(max, &Val(0, 2));\n\n    let (min, max) = data.iter().minmax_by(|x, y| x.1.cmp(&y.1)).into_option().unwrap();\n    assert_eq!(min, &Val(2, 0));\n    assert_eq!(max, &Val(0, 2));\n}\n\n#[test]\nfn format() {\n    let data = [0, 1, 2, 3];\n    let ans1 = \"0, 1, 2, 3\";\n    let ans2 = \"0--1--2--3\";\n\n    let t1 = format!(\"{}\", data.iter().format(\", \"));\n    assert_eq!(t1, ans1);\n    let t2 = format!(\"{:?}\", data.iter().format(\"--\"));\n    assert_eq!(t2, ans2);\n\n    let dataf = [1.1, 2.71828, -22.];\n    let t3 = format!(\"{:.2e}\", dataf.iter().format(\", \"));\n    assert_eq!(t3, \"1.10e0, 2.72e0, -2.20e1\");\n}\n\n#[test]\nfn while_some() {\n    let ns = (1..10).map(|x| if x % 5 != 0 { Some(x) } else { None })\n                    .while_some();\n    it::assert_equal(ns, vec![1, 2, 3, 4]);\n}\n\n#[allow(deprecated)]\n#[test]\nfn fold_while() {\n    let mut iterations = 0;\n    let vec = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    let sum = vec.into_iter().fold_while(0, |acc, item| {\n        iterations += 1;\n        let new_sum = acc.clone() + item;\n        if new_sum <= 20 {\n            FoldWhile::Continue(new_sum)\n        } else {\n            FoldWhile::Done(acc)\n        }\n    }).into_inner();\n    assert_eq!(iterations, 6);\n    assert_eq!(sum, 15);\n}\n\n#[test]\nfn tree_fold1() {\n    let x = [\n        \"\",\n        \"0\",\n        \"0 1 x\",\n        \"0 1 x 2 x\",\n        \"0 1 x 2 3 x x\",\n        \"0 1 x 2 3 x x 4 x\",\n        \"0 1 x 2 3 x x 4 5 x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 9 x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 9 x 10 x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 9 x 10 11 x x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 9 x 10 11 x x 12 x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 9 x 10 11 x x 12 13 x x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 9 x 10 11 x x 12 13 x 14 x x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 9 x 10 11 x x 12 13 x 14 15 x x x x\",\n    ];\n    for (i, &s) in x.iter().enumerate() {\n        let expected = if s == \"\" { None } else { Some(s.to_string()) };\n        let num_strings = (0..i).map(|x| x.to_string());\n        let actual = num_strings.tree_fold1(|a, b| format!(\"{} {} x\", a, b));\n        assert_eq!(actual, expected);\n    }\n}\n","traces":[{"line":15,"address":[4789776,4789712],"length":1,"stats":{"Line":3},"fn_name":"product3"},{"line":16,"address":[4789719,4789791],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[4790020,4790214],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[4790145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[4790517,4790739,4790630,4790919],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[4791104,4790783,4790924],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[4791109,4790968,4791397],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[4792032,4791153,4791402],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[4791443,4790685,4791901],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[4792192,4792332],"length":1,"stats":{"Line":3},"fn_name":"interleave_shortest"},{"line":33,"address":[4792199,4792347],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[4792365,4792450],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[4792458,4796767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[4792890,4792663],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[4792776,4793238],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[4793828],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[4793975,4793908],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[4793983,4796901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[4794188,4794415],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4794301,4794763],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[4795352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[4795384],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[4795432],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[4795663,4795730,4795544],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[4796032,4795679],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[4796045],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[4796067],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[4796295,4796319,4796176],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[4797328],"length":1,"stats":{"Line":3},"fn_name":"unique_by"},{"line":59,"address":[4797384],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4797518],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[4797578],"length":1,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[5154928,5154945],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":63,"address":[4797855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[4797915],"length":1,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[4798048],"length":1,"stats":{"Line":3},"fn_name":"unique"},{"line":69,"address":[4798055],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[4798132],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[4798176],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[4798308],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[4798498],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[4798542],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[4798683],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[4798705],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[4798727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[4798835],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[4798989],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[4799011],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[4799306,4799152],"length":1,"stats":{"Line":3},"fn_name":"intersperse"},{"line":86,"address":[4799180],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[4799337,4799267],"length":1,"stats":{"Line":4},"fn_name":null},{"line":88,"address":[4799432],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[4799504,4799644],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[4799987],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[4800031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[4800173,4800258,4800279],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[4800432,4800618],"length":1,"stats":{"Line":3},"fn_name":"dedup"},{"line":98,"address":[4800439],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[4800527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[4800582,4800633],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[4800713],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[4800768],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[4800779],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[4800887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[4800975],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[4801030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[4801124,4801056],"length":1,"stats":{"Line":4},"fn_name":null},{"line":109,"address":[4801306,4801163],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[4801648,4802344],"length":1,"stats":{"Line":3},"fn_name":"dedup_by"},{"line":114,"address":[4801655],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[4802055],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[4802305,4802359],"length":1,"stats":{"Line":4},"fn_name":null},{"line":117,"address":[4802442],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[4802692],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[4802742],"length":1,"stats":{"Line":3},"fn_name":null},{"line":121,"address":[4802850],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[4803250],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[4803500],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[4803594,4803526],"length":1,"stats":{"Line":6},"fn_name":null},{"line":125,"address":[4803633,4803776],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[4804112],"length":1,"stats":{"Line":3},"fn_name":"dedup_with_count"},{"line":130,"address":[4804147],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[4804211],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[4804471],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[4804608],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[4804663],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[4804715],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[4804864],"length":1,"stats":{"Line":3},"fn_name":"dedup_by_with_count"},{"line":144,"address":[4804906],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[4805320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[4805580],"length":1,"stats":{"Line":3},"fn_name":null},{"line":149,"address":[4805717],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[4805967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[4806019],"length":1,"stats":{"Line":3},"fn_name":null},{"line":156,"address":[4806203,4806160],"length":1,"stats":{"Line":3},"fn_name":"all_equal"},{"line":157,"address":[4806218,4806271,4806167],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[4806242,4806301,4806354],"length":1,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[4806384,4806325,4806439],"length":1,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[4806410,4806469,4806525],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[4806555,4807053,4807115,4807199,4806500,4806942],"length":1,"stats":{"Line":7},"fn_name":null},{"line":162,"address":[4807177,4806958,4807012],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[4807280,4807397],"length":1,"stats":{"Line":3},"fn_name":"test_put_back_n"},{"line":168,"address":[4807287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[4807367,4807422],"length":1,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[4807470],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[4807482],"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[4807499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[4807513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[4807520,4807727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[4807808,4807954],"length":1,"stats":{"Line":3},"fn_name":"tee"},{"line":179,"address":[4807815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[4807915,4807985],"length":1,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[4808103,4808164,4808323],"length":1,"stats":{"Line":2},"fn_name":null},{"line":182,"address":[4808668,4808827,4808299],"length":1,"stats":{"Line":2},"fn_name":null},{"line":183,"address":[4808803,4809172,4809331],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[4809835,4809676,4809307],"length":1,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[4809811,4810339,4810180],"length":1,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[4810684,4810843,4810315],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[4810819,4811347,4811188],"length":1,"stats":{"Line":2},"fn_name":null},{"line":188,"address":[4811692,4811323,4811851],"length":1,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[4812355,4811827,4812196],"length":1,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[4812700,4812331,4812859],"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[4812835,4813363,4813204],"length":1,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[4813339,4813867,4813708],"length":1,"stats":{"Line":2},"fn_name":null},{"line":193,"address":[4813843,4814212,4814378],"length":1,"stats":{"Line":2},"fn_name":null},{"line":195,"address":[4814732,4814352],"length":1,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[4814995,4815836,4814862],"length":1,"stats":{"Line":2},"fn_name":null},{"line":197,"address":[4815073,4815877],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[4815256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[4815401,4815970,4815500],"length":1,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[4816160,4816329],"length":1,"stats":{"Line":3},"fn_name":"test_rciter"},{"line":206,"address":[4816167],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[4816290,4816360],"length":1,"stats":{"Line":2},"fn_name":null},{"line":209,"address":[4816426],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[4816660,4816473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[4817182,4817005,4816636],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[4817132],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[4817661,4817693,4817536],"length":1,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[4818163,4817683,4818039],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[4818633,4818153,4818509],"length":1,"stats":{"Line":2},"fn_name":null},{"line":216,"address":[4819128,4818623,4818979],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[4819435,4819077],"length":1,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[4819459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[4819666,4819642,4819523],"length":1,"stats":{"Line":2},"fn_name":null},{"line":226,"address":[4820346,4820240],"length":1,"stats":{"Line":3},"fn_name":"trait_pointers"},{"line":233,"address":[5156160],"length":1,"stats":{"Line":1},"fn_name":"next<i32,Iterator>"},{"line":235,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":239,"address":[4820369,4820344,4820247],"length":1,"stats":{"Line":3},"fn_name":null},{"line":240,"address":[4820643,4820400,4820443],"length":1,"stats":{"Line":2},"fn_name":null},{"line":244,"address":[4820570],"length":1,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[4820988,4820602,4821179],"length":1,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[4821115],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[4821155,4821518,4821673],"length":1,"stats":{"Line":2},"fn_name":null},{"line":252,"address":[4821639,4821983,4822101],"length":1,"stats":{"Line":4},"fn_name":null},{"line":253,"address":[4822075],"length":1,"stats":{"Line":3},"fn_name":null},{"line":258,"address":[4822727,4822448],"length":1,"stats":{"Line":3},"fn_name":"merge_by"},{"line":259,"address":[4822455],"length":1,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[4822752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[4822993],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[4823508,4823421],"length":1,"stats":{"Line":4},"fn_name":null},{"line":263,"address":[4823587],"length":1,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[4823856,4823923],"length":1,"stats":{"Line":3},"fn_name":"merge_by_btree"},{"line":269,"address":[4823863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[4823938],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[4823967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[4824001],"length":1,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[4824008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[4824045],"length":1,"stats":{"Line":1},"fn_name":null},{"line":275,"address":[4824074,4824796],"length":1,"stats":{"Line":3},"fn_name":null},{"line":276,"address":[4824258],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[4824552,4824851],"length":1,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[4824992],"length":1,"stats":{"Line":3},"fn_name":"kmerge"},{"line":283,"address":[4824996],"length":1,"stats":{"Line":3},"fn_name":null},{"line":285,"address":[4825033],"length":1,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[4825104],"length":1,"stats":{"Line":3},"fn_name":"kmerge_2"},{"line":291,"address":[4825111],"length":1,"stats":{"Line":3},"fn_name":null},{"line":293,"address":[4825202],"length":1,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[4825374,4825328],"length":1,"stats":{"Line":3},"fn_name":"kmerge_empty"},{"line":298,"address":[4825335],"length":1,"stats":{"Line":3},"fn_name":null},{"line":299,"address":[4825389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[4825934,4825888],"length":1,"stats":{"Line":3},"fn_name":"kmerge_size_hint"},{"line":304,"address":[4825895],"length":1,"stats":{"Line":3},"fn_name":null},{"line":305,"address":[4825949],"length":1,"stats":{"Line":1},"fn_name":null},{"line":309,"address":[4826478,4826432],"length":1,"stats":{"Line":3},"fn_name":"kmerge_empty_size_hint"},{"line":310,"address":[4826439],"length":1,"stats":{"Line":3},"fn_name":null},{"line":311,"address":[4826493],"length":1,"stats":{"Line":1},"fn_name":null},{"line":315,"address":[4827063,4826976],"length":1,"stats":{"Line":3},"fn_name":"join"},{"line":316,"address":[4826987],"length":1,"stats":{"Line":1},"fn_name":null},{"line":317,"address":[4827020],"length":1,"stats":{"Line":1},"fn_name":null},{"line":318,"address":[4827031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":320,"address":[4827091,4827207],"length":1,"stats":{"Line":2},"fn_name":null},{"line":321,"address":[4827694],"length":1,"stats":{"Line":1},"fn_name":null},{"line":322,"address":[4828244],"length":1,"stats":{"Line":1},"fn_name":null},{"line":326,"address":[4828896,4829092],"length":1,"stats":{"Line":3},"fn_name":"sorted_by"},{"line":327,"address":[4828910],"length":1,"stats":{"Line":3},"fn_name":null},{"line":328,"address":[5156985],"length":1,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[4828994,4829107,4829379],"length":1,"stats":{"Line":1},"fn_name":null},{"line":332,"address":[4829156],"length":1,"stats":{"Line":3},"fn_name":null},{"line":333,"address":[4829205,4829402],"length":1,"stats":{"Line":1},"fn_name":null},{"line":337,"address":[4829472,4829668],"length":1,"stats":{"Line":3},"fn_name":"sorted_by_key"},{"line":338,"address":[4829486],"length":1,"stats":{"Line":3},"fn_name":null},{"line":339,"address":[4829955,4829570,4829683],"length":1,"stats":{"Line":1},"fn_name":null},{"line":341,"address":[4829732],"length":1,"stats":{"Line":3},"fn_name":null},{"line":342,"address":[4829781,4829978],"length":1,"stats":{"Line":1},"fn_name":null},{"line":346,"address":[4830048,4830121],"length":1,"stats":{"Line":3},"fn_name":"test_multipeek"},{"line":347,"address":[4830061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":349,"address":[4830144,4830237],"length":1,"stats":{"Line":4},"fn_name":null},{"line":350,"address":[4830291],"length":1,"stats":{"Line":1},"fn_name":null},{"line":352,"address":[4830867],"length":1,"stats":{"Line":3},"fn_name":null},{"line":353,"address":[4831194,4831156,4831007],"length":1,"stats":{"Line":2},"fn_name":null},{"line":354,"address":[4831539,4831692,4831170],"length":1,"stats":{"Line":2},"fn_name":null},{"line":355,"address":[4832038,4832178,4831674],"length":1,"stats":{"Line":2},"fn_name":null},{"line":356,"address":[4832670,4832160,4832524],"length":1,"stats":{"Line":2},"fn_name":null},{"line":357,"address":[4832646,4833015,4833168],"length":1,"stats":{"Line":2},"fn_name":null},{"line":358,"address":[4833654,4833150,4833514],"length":1,"stats":{"Line":2},"fn_name":null},{"line":359,"address":[4833636,4834140,4834000],"length":1,"stats":{"Line":2},"fn_name":null},{"line":360,"address":[4834626,4834486,4834122],"length":1,"stats":{"Line":2},"fn_name":null},{"line":361,"address":[4835118,4834608,4834972],"length":1,"stats":{"Line":2},"fn_name":null},{"line":362,"address":[4835094,4835622,4835463],"length":1,"stats":{"Line":2},"fn_name":null},{"line":363,"address":[4836120,4835967,4835598],"length":1,"stats":{"Line":2},"fn_name":null},{"line":364,"address":[4836466,4836606,4836102],"length":1,"stats":{"Line":2},"fn_name":null},{"line":365,"address":[4836952,4837098,4836588],"length":1,"stats":{"Line":2},"fn_name":null},{"line":366,"address":[4837443,4837602,4837074],"length":1,"stats":{"Line":2},"fn_name":null},{"line":367,"address":[4837578,4837947,4838091],"length":1,"stats":{"Line":2},"fn_name":null},{"line":368,"address":[4838524,4838398,4838076],"length":1,"stats":{"Line":2},"fn_name":null},{"line":373,"address":[4838994,4838912],"length":1,"stats":{"Line":3},"fn_name":"test_multipeek_reset"},{"line":374,"address":[4838919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":376,"address":[4838963,4839009],"length":1,"stats":{"Line":2},"fn_name":null},{"line":377,"address":[4839233,4839046,4839195],"length":1,"stats":{"Line":2},"fn_name":null},{"line":378,"address":[4839209,4839578,4839731],"length":1,"stats":{"Line":2},"fn_name":null},{"line":379,"address":[4839713,4840077,4840217],"length":1,"stats":{"Line":2},"fn_name":null},{"line":380,"address":[4840199,4840563,4840695],"length":1,"stats":{"Line":2},"fn_name":null},{"line":381,"address":[4840685],"length":1,"stats":{"Line":1},"fn_name":null},{"line":382,"address":[4841198,4841041],"length":1,"stats":{"Line":1},"fn_name":null},{"line":383,"address":[4841640,4841180,4841504],"length":1,"stats":{"Line":2},"fn_name":null},{"line":387,"address":[4842065,4841984],"length":1,"stats":{"Line":3},"fn_name":"test_multipeek_peeking_next"},{"line":389,"address":[4841997],"length":1,"stats":{"Line":1},"fn_name":null},{"line":391,"address":[4842088,4842181],"length":1,"stats":{"Line":4},"fn_name":null},{"line":392,"address":[4842410,4842243,4842448],"length":1,"stats":{"Line":4},"fn_name":null},{"line":393,"address":[4842946,4842793,4842424],"length":1,"stats":{"Line":2},"fn_name":null},{"line":394,"address":[4843432,4842928,4843292],"length":1,"stats":{"Line":2},"fn_name":null},{"line":395,"address":[4843924,4843778,4843414],"length":1,"stats":{"Line":2},"fn_name":null},{"line":396,"address":[4844269,4843900,4844422],"length":1,"stats":{"Line":4},"fn_name":null},{"line":397,"address":[4844404,4844914,4844768],"length":1,"stats":{"Line":2},"fn_name":null},{"line":398,"address":[4845418,4845259,4844890],"length":1,"stats":{"Line":4},"fn_name":null},{"line":399,"address":[4845394,4845763,4845916],"length":1,"stats":{"Line":4},"fn_name":null},{"line":400,"address":[4845898,4846402,4846262],"length":1,"stats":{"Line":2},"fn_name":null},{"line":401,"address":[4846384,4846748,4846894],"length":1,"stats":{"Line":2},"fn_name":null},{"line":402,"address":[4847239,4847392,4846870],"length":1,"stats":{"Line":4},"fn_name":null},{"line":403,"address":[4847884,4847738,4847374],"length":1,"stats":{"Line":2},"fn_name":null},{"line":404,"address":[4848388,4848229,4847860],"length":1,"stats":{"Line":4},"fn_name":null},{"line":405,"address":[4848364,4848733,4848886],"length":1,"stats":{"Line":4},"fn_name":null},{"line":406,"address":[4849372,4849232,4848868],"length":1,"stats":{"Line":2},"fn_name":null},{"line":407,"address":[4849718,4849354,4849864],"length":1,"stats":{"Line":2},"fn_name":null},{"line":408,"address":[4850209,4849840,4850353],"length":1,"stats":{"Line":2},"fn_name":null},{"line":409,"address":[4850338,4850660,4850786],"length":1,"stats":{"Line":2},"fn_name":null},{"line":413,"address":[4851225,4851152],"length":1,"stats":{"Line":3},"fn_name":"test_peek_nth"},{"line":414,"address":[4851165],"length":1,"stats":{"Line":1},"fn_name":null},{"line":416,"address":[4851248,4851341],"length":1,"stats":{"Line":4},"fn_name":null},{"line":417,"address":[4851395],"length":1,"stats":{"Line":1},"fn_name":null},{"line":419,"address":[4851971],"length":1,"stats":{"Line":3},"fn_name":null},{"line":421,"address":[4852264,4852115,4852300],"length":1,"stats":{"Line":2},"fn_name":null},{"line":422,"address":[4852282,4852792,4852646],"length":1,"stats":{"Line":2},"fn_name":null},{"line":423,"address":[4853137,4852768,4853294],"length":1,"stats":{"Line":2},"fn_name":null},{"line":425,"address":[4853276,4853640,4853785],"length":1,"stats":{"Line":2},"fn_name":null},{"line":426,"address":[4853767,4854131,4854277],"length":1,"stats":{"Line":2},"fn_name":null},{"line":427,"address":[4854253,4854779,4854622],"length":1,"stats":{"Line":2},"fn_name":null},{"line":429,"address":[4854761,4855125,4855270],"length":1,"stats":{"Line":2},"fn_name":null},{"line":430,"address":[4855616,4855252,4855761],"length":1,"stats":{"Line":2},"fn_name":null},{"line":431,"address":[4856252,4856107,4855743],"length":1,"stats":{"Line":2},"fn_name":null},{"line":432,"address":[4856744,4856598,4856234],"length":1,"stats":{"Line":2},"fn_name":null},{"line":434,"address":[4856720,4857089,4857248],"length":1,"stats":{"Line":2},"fn_name":null},{"line":435,"address":[4857224,4857750,4857593],"length":1,"stats":{"Line":2},"fn_name":null},{"line":437,"address":[4858096,4858241,4857732],"length":1,"stats":{"Line":2},"fn_name":null},{"line":438,"address":[4858587,4858733,4858223],"length":1,"stats":{"Line":2},"fn_name":null},{"line":439,"address":[4859237,4859078,4858709],"length":1,"stats":{"Line":2},"fn_name":null},{"line":440,"address":[4859582,4859213,4859739],"length":1,"stats":{"Line":2},"fn_name":null},{"line":442,"address":[4860079,4860215,4859721],"length":1,"stats":{"Line":2},"fn_name":null},{"line":443,"address":[4860522,4860648,4860200],"length":1,"stats":{"Line":2},"fn_name":null},{"line":447,"address":[4861040,4861121],"length":1,"stats":{"Line":3},"fn_name":"test_peek_nth_peeking_next"},{"line":449,"address":[4861053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[4861237,4861144],"length":1,"stats":{"Line":4},"fn_name":null},{"line":452,"address":[4861466,4861299,4861504],"length":1,"stats":{"Line":4},"fn_name":null},{"line":453,"address":[4861480,4862006,4861849],"length":1,"stats":{"Line":2},"fn_name":null},{"line":455,"address":[4862497,4861988,4862352],"length":1,"stats":{"Line":2},"fn_name":null},{"line":456,"address":[4862989,4862479,4862843],"length":1,"stats":{"Line":2},"fn_name":null},{"line":457,"address":[4862965,4863334,4863487],"length":1,"stats":{"Line":4},"fn_name":null},{"line":458,"address":[4863979,4863833,4863469],"length":1,"stats":{"Line":2},"fn_name":null},{"line":460,"address":[4864483,4863955,4864324],"length":1,"stats":{"Line":4},"fn_name":null},{"line":461,"address":[4864828,4864985,4864459],"length":1,"stats":{"Line":4},"fn_name":null},{"line":462,"address":[4865331,4865476,4864967],"length":1,"stats":{"Line":2},"fn_name":null},{"line":463,"address":[4865968,4865458,4865822],"length":1,"stats":{"Line":2},"fn_name":null},{"line":465,"address":[4865944,4866466,4866313],"length":1,"stats":{"Line":4},"fn_name":null},{"line":466,"address":[4866448,4866958,4866812],"length":1,"stats":{"Line":2},"fn_name":null},{"line":468,"address":[4867303,4867462,4866934],"length":1,"stats":{"Line":4},"fn_name":null},{"line":469,"address":[4867964,4867438,4867807],"length":1,"stats":{"Line":4},"fn_name":null},{"line":470,"address":[4867946,4868310,4868455],"length":1,"stats":{"Line":2},"fn_name":null},{"line":471,"address":[4868801,4868437,4868947],"length":1,"stats":{"Line":2},"fn_name":null},{"line":472,"address":[4868923,4869286,4869430],"length":1,"stats":{"Line":2},"fn_name":null},{"line":473,"address":[4869863,4869415,4869737],"length":1,"stats":{"Line":2},"fn_name":null},{"line":477,"address":[4870288,4870224],"length":1,"stats":{"Line":3},"fn_name":"pad_using"},{"line":478,"address":[4870303,4870231],"length":1,"stats":{"Line":4},"fn_name":null},{"line":480,"address":[4870337],"length":1,"stats":{"Line":1},"fn_name":null},{"line":481,"address":[4870396],"length":1,"stats":{"Line":3},"fn_name":null},{"line":482,"address":[4871029,4870479],"length":1,"stats":{"Line":1},"fn_name":null},{"line":484,"address":[4870677],"length":1,"stats":{"Line":1},"fn_name":null},{"line":485,"address":[4870739],"length":1,"stats":{"Line":1},"fn_name":null},{"line":486,"address":[4870834,4871055],"length":1,"stats":{"Line":1},"fn_name":null},{"line":490,"address":[4871136,4871251],"length":1,"stats":{"Line":3},"fn_name":"group_by"},{"line":491,"address":[4871266,4871671,4871156,4872326,4880609,4880729],"length":1,"stats":{"Line":7},"fn_name":null},{"line":492,"address":[4871689,4871784,4871836,4871975,4880663],"length":1,"stats":{"Line":4},"fn_name":null},{"line":493,"address":[4871980,4871880],"length":1,"stats":{"Line":1},"fn_name":null},{"line":497,"address":[4872338,4873461,4872775,4880905,4880785],"length":1,"stats":{"Line":6},"fn_name":null},{"line":498,"address":[4880839,4872888,4872793,4873443],"length":1,"stats":{"Line":4},"fn_name":null},{"line":499,"address":[4873105,4872971],"length":1,"stats":{"Line":1},"fn_name":null},{"line":500,"address":[4873086],"length":1,"stats":{"Line":1},"fn_name":null},{"line":501,"address":[4873448],"length":1,"stats":{"Line":1},"fn_name":null},{"line":506,"address":[5158688,5158702],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":509,"address":[4873699,4875364,4873466],"length":1,"stats":{"Line":2},"fn_name":null},{"line":510,"address":[4873964],"length":1,"stats":{"Line":1},"fn_name":null},{"line":511,"address":[4874038],"length":1,"stats":{"Line":1},"fn_name":null},{"line":513,"address":[4874302,4874192,4875346,4874107],"length":1,"stats":{"Line":3},"fn_name":null},{"line":514,"address":[4874515,4874681,4874598,4874761],"length":1,"stats":{"Line":4},"fn_name":null},{"line":515,"address":[4874355,4874437],"length":1,"stats":{"Line":2},"fn_name":null},{"line":516,"address":[4874520],"length":1,"stats":{"Line":1},"fn_name":null},{"line":517,"address":[4874603],"length":1,"stats":{"Line":1},"fn_name":null},{"line":518,"address":[4874683],"length":1,"stats":{"Line":1},"fn_name":null},{"line":521,"address":[4874807,4874970],"length":1,"stats":{"Line":1},"fn_name":null},{"line":522,"address":[4875316,4874936],"length":1,"stats":{"Line":2},"fn_name":null},{"line":526,"address":[4875369,4873665],"length":1,"stats":{"Line":4},"fn_name":null},{"line":527,"address":[4875478,4875406],"length":1,"stats":{"Line":4},"fn_name":null},{"line":529,"address":[4875546,4875501],"length":1,"stats":{"Line":2},"fn_name":null},{"line":530,"address":[4875570],"length":1,"stats":{"Line":1},"fn_name":null},{"line":531,"address":[4875624],"length":1,"stats":{"Line":1},"fn_name":null},{"line":532,"address":[4875678],"length":1,"stats":{"Line":1},"fn_name":null},{"line":533,"address":[4877734,4876151,4876107,4875708],"length":1,"stats":{"Line":3},"fn_name":null},{"line":534,"address":[4876508,4876312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":535,"address":[4876409,4876952],"length":1,"stats":{"Line":1},"fn_name":null},{"line":536,"address":[4876853,4877396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":537,"address":[4877739,4877297],"length":1,"stats":{"Line":1},"fn_name":null},{"line":542,"address":[4878077],"length":1,"stats":{"Line":1},"fn_name":null},{"line":543,"address":[4878089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":544,"address":[4881072,4878116,4878597,4881178,4878791],"length":1,"stats":{"Line":6},"fn_name":null},{"line":545,"address":[4881112,4878607,4878702,4878751],"length":1,"stats":{"Line":3},"fn_name":null},{"line":548,"address":[4879024,4878796],"length":1,"stats":{"Line":1},"fn_name":null},{"line":552,"address":[4878943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":553,"address":[4878955],"length":1,"stats":{"Line":1},"fn_name":null},{"line":554,"address":[4878982,4879788,4879803,4881260,4879360],"length":1,"stats":{"Line":6},"fn_name":null},{"line":556,"address":[4880012,4879808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":560,"address":[4879949],"length":1,"stats":{"Line":1},"fn_name":null},{"line":561,"address":[4880340,4879976],"length":1,"stats":{"Line":4},"fn_name":null},{"line":562,"address":[4880355,4880405,4881267],"length":1,"stats":{"Line":4},"fn_name":null},{"line":567,"address":[4881744,4881861],"length":1,"stats":{"Line":3},"fn_name":"group_by_lazy_2"},{"line":568,"address":[4881751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":569,"address":[4881985,4881884],"length":1,"stats":{"Line":4},"fn_name":null},{"line":570,"address":[4882000,4882053],"length":1,"stats":{"Line":2},"fn_name":null},{"line":571,"address":[4882069],"length":1,"stats":{"Line":3},"fn_name":null},{"line":573,"address":[4882290],"length":1,"stats":{"Line":1},"fn_name":null},{"line":574,"address":[4882464,4882360],"length":1,"stats":{"Line":4},"fn_name":null},{"line":575,"address":[4882479,4882532],"length":1,"stats":{"Line":2},"fn_name":null},{"line":576,"address":[4882540],"length":1,"stats":{"Line":1},"fn_name":null},{"line":577,"address":[4882614],"length":1,"stats":{"Line":3},"fn_name":null},{"line":579,"address":[4882730],"length":1,"stats":{"Line":3},"fn_name":null},{"line":580,"address":[4882831],"length":1,"stats":{"Line":1},"fn_name":null},{"line":581,"address":[4882846,4882928,4882887,4883347,4885762,4885872],"length":1,"stats":{"Line":5},"fn_name":null},{"line":582,"address":[4883315,4885842],"length":1,"stats":{"Line":2},"fn_name":null},{"line":583,"address":[4883252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":586,"address":[4883237,4883352],"length":1,"stats":{"Line":2},"fn_name":null},{"line":588,"address":[4883384],"length":1,"stats":{"Line":1},"fn_name":null},{"line":589,"address":[4883496,4883600],"length":1,"stats":{"Line":4},"fn_name":null},{"line":590,"address":[4883615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":591,"address":[4883630,4886060,4885960,4883668,4884409,4883722],"length":1,"stats":{"Line":5},"fn_name":null},{"line":592,"address":[4886032,4884399,4884102],"length":1,"stats":{"Line":3},"fn_name":null},{"line":593,"address":[4884047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":594,"address":[4884034,4884395],"length":1,"stats":{"Line":2},"fn_name":null},{"line":595,"address":[4884359,4884311,4884165],"length":1,"stats":{"Line":2},"fn_name":null},{"line":598,"address":[4884107],"length":1,"stats":{"Line":1},"fn_name":null},{"line":601,"address":[4884019,4884414],"length":1,"stats":{"Line":2},"fn_name":null},{"line":602,"address":[4884446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":603,"address":[4884490],"length":1,"stats":{"Line":1},"fn_name":null},{"line":606,"address":[4884531],"length":1,"stats":{"Line":1},"fn_name":null},{"line":607,"address":[4884635],"length":1,"stats":{"Line":1},"fn_name":null},{"line":608,"address":[4884716,4884654],"length":1,"stats":{"Line":4},"fn_name":null},{"line":609,"address":[4884828,4886116,4886234,4885454,4884770],"length":1,"stats":{"Line":4},"fn_name":null},{"line":610,"address":[4885372,4885238,4885305,4885436],"length":1,"stats":{"Line":4},"fn_name":null},{"line":611,"address":[4885176,4886178],"length":1,"stats":{"Line":2},"fn_name":null},{"line":612,"address":[4885243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":613,"address":[4885310],"length":1,"stats":{"Line":1},"fn_name":null},{"line":614,"address":[4885374],"length":1,"stats":{"Line":1},"fn_name":null},{"line":621,"address":[4886656,4886801],"length":1,"stats":{"Line":3},"fn_name":"group_by_lazy_3"},{"line":623,"address":[4886663],"length":1,"stats":{"Line":1},"fn_name":null},{"line":624,"address":[4886892,4886821],"length":1,"stats":{"Line":4},"fn_name":null},{"line":625,"address":[4886899],"length":1,"stats":{"Line":1},"fn_name":null},{"line":626,"address":[4887973,4886916,4886986,4887875,4888365],"length":1,"stats":{"Line":4},"fn_name":null},{"line":627,"address":[4887305,4887955],"length":1,"stats":{"Line":2},"fn_name":null},{"line":628,"address":[4887578,4887381,4887527,4887753],"length":1,"stats":{"Line":3},"fn_name":null},{"line":629,"address":[4887758,4887644],"length":1,"stats":{"Line":1},"fn_name":null},{"line":632,"address":[4888074,4888248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":637,"address":[4888681,4888544],"length":1,"stats":{"Line":3},"fn_name":"chunks"},{"line":638,"address":[4888551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":639,"address":[4888701,4888777],"length":1,"stats":{"Line":2},"fn_name":null},{"line":640,"address":[4888845,4889716,4889527,4889599,4888789],"length":1,"stats":{"Line":4},"fn_name":null},{"line":641,"address":[4889311,4889509,4889378,4889445],"length":1,"stats":{"Line":4},"fn_name":null},{"line":642,"address":[4889249,4889663],"length":1,"stats":{"Line":2},"fn_name":null},{"line":643,"address":[4889316],"length":1,"stats":{"Line":1},"fn_name":null},{"line":644,"address":[4889383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":645,"address":[4889447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":652,"address":[4889875,4889856],"length":1,"stats":{"Line":3},"fn_name":"concat_empty"},{"line":653,"address":[4889863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":654,"address":[4889890,4889994,4890110],"length":1,"stats":{"Line":2},"fn_name":null},{"line":658,"address":[4890562,4890480],"length":1,"stats":{"Line":3},"fn_name":"concat_non_empty"},{"line":659,"address":[4890577,4890497],"length":1,"stats":{"Line":1},"fn_name":null},{"line":660,"address":[4891053,4891179,4890846,4891155],"length":1,"stats":{"Line":3},"fn_name":null},{"line":664,"address":[4891732,4891600],"length":1,"stats":{"Line":3},"fn_name":"combinations"},{"line":665,"address":[4891607,4891757,4891902],"length":1,"stats":{"Line":2},"fn_name":null},{"line":667,"address":[4891846],"length":1,"stats":{"Line":1},"fn_name":null},{"line":668,"address":[4891932,4892121],"length":1,"stats":{"Line":1},"fn_name":null},{"line":669,"address":[4892061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":672,"address":[4892234],"length":1,"stats":{"Line":1},"fn_name":null},{"line":673,"address":[4892477,4892543,4892288,4892609,4892675,4892741,4892807],"length":1,"stats":{"Line":1},"fn_name":null},{"line":674,"address":[4892417],"length":1,"stats":{"Line":1},"fn_name":null},{"line":675,"address":[4892502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":676,"address":[4892568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":677,"address":[4892634],"length":1,"stats":{"Line":1},"fn_name":null},{"line":678,"address":[4892700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":679,"address":[4892766],"length":1,"stats":{"Line":1},"fn_name":null},{"line":682,"address":[4894519,4893043],"length":1,"stats":{"Line":1},"fn_name":null},{"line":683,"address":[4893154,4894560],"length":1,"stats":{"Line":1},"fn_name":null},{"line":684,"address":[4893265,4894601],"length":1,"stats":{"Line":1},"fn_name":null},{"line":686,"address":[4893459,4894627],"length":1,"stats":{"Line":1},"fn_name":null},{"line":687,"address":[4893575,4894668],"length":1,"stats":{"Line":1},"fn_name":null},{"line":688,"address":[4893837,4894694],"length":1,"stats":{"Line":1},"fn_name":null},{"line":689,"address":[4894183,4894720],"length":1,"stats":{"Line":1},"fn_name":null},{"line":693,"address":[4895200,4895253],"length":1,"stats":{"Line":3},"fn_name":"combinations_of_too_short"},{"line":694,"address":[4895773,4895273,4895207,4895334],"length":1,"stats":{"Line":3},"fn_name":null},{"line":695,"address":[4895561,4895366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":696,"address":[4895531,4895591,4895778],"length":1,"stats":{"Line":2},"fn_name":null},{"line":702,"address":[4895920,4895991],"length":1,"stats":{"Line":3},"fn_name":"combinations_zero"},{"line":703,"address":[4896016,4895931,4896449],"length":1,"stats":{"Line":2},"fn_name":null},{"line":704,"address":[4896186,4896472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":708,"address":[4896592,4896663],"length":1,"stats":{"Line":3},"fn_name":"permutations_zero"},{"line":709,"address":[4897139,4896688,4896603],"length":1,"stats":{"Line":2},"fn_name":null},{"line":710,"address":[4896876,4897162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":714,"address":[4897376,4897280],"length":1,"stats":{"Line":3},"fn_name":"combinations_with_replacement"},{"line":716,"address":[4897401,4897287,4898972],"length":1,"stats":{"Line":2},"fn_name":null},{"line":719,"address":[4897599],"length":1,"stats":{"Line":1},"fn_name":null},{"line":720,"address":[4897762,4898026,4898092,4897894,4897960,4897671,4897828],"length":1,"stats":{"Line":1},"fn_name":null},{"line":721,"address":[4897702],"length":1,"stats":{"Line":1},"fn_name":null},{"line":722,"address":[4897787],"length":1,"stats":{"Line":1},"fn_name":null},{"line":723,"address":[4897853],"length":1,"stats":{"Line":1},"fn_name":null},{"line":724,"address":[4897919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":725,"address":[4897985],"length":1,"stats":{"Line":1},"fn_name":null},{"line":726,"address":[4898051],"length":1,"stats":{"Line":1},"fn_name":null},{"line":731,"address":[4898332],"length":1,"stats":{"Line":1},"fn_name":null},{"line":732,"address":[4898399,4898476],"length":1,"stats":{"Line":1},"fn_name":null},{"line":736,"address":[4898593],"length":1,"stats":{"Line":1},"fn_name":null},{"line":737,"address":[4898735,4898660],"length":1,"stats":{"Line":1},"fn_name":null},{"line":741,"address":[4898848],"length":1,"stats":{"Line":1},"fn_name":null},{"line":742,"address":[4898918],"length":1,"stats":{"Line":1},"fn_name":null},{"line":747,"address":[4899496,4899408],"length":1,"stats":{"Line":3},"fn_name":"diff_mismatch"},{"line":748,"address":[4899415],"length":1,"stats":{"Line":1},"fn_name":null},{"line":749,"address":[4899521],"length":1,"stats":{"Line":1},"fn_name":null},{"line":750,"address":[4899613],"length":1,"stats":{"Line":3},"fn_name":null},{"line":751,"address":[4899695],"length":1,"stats":{"Line":3},"fn_name":null},{"line":753,"address":[4900249,4899993,4900187],"length":1,"stats":{"Line":1},"fn_name":null},{"line":754,"address":[4899998,4899818],"length":1,"stats":{"Line":2},"fn_name":null},{"line":755,"address":[4899914,4900036],"length":1,"stats":{"Line":2},"fn_name":null},{"line":756,"address":[4899985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":761,"address":[4900672,4900760],"length":1,"stats":{"Line":3},"fn_name":"diff_longer"},{"line":762,"address":[4900679],"length":1,"stats":{"Line":1},"fn_name":null},{"line":763,"address":[4900785],"length":1,"stats":{"Line":1},"fn_name":null},{"line":764,"address":[4900908],"length":1,"stats":{"Line":3},"fn_name":null},{"line":765,"address":[4900990],"length":1,"stats":{"Line":3},"fn_name":null},{"line":767,"address":[4901288,4901464,4901526],"length":1,"stats":{"Line":1},"fn_name":null},{"line":768,"address":[4901293,4901113],"length":1,"stats":{"Line":2},"fn_name":null},{"line":769,"address":[4901320,4901209],"length":1,"stats":{"Line":2},"fn_name":null},{"line":770,"address":[4901280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":775,"address":[4901952,4902032],"length":1,"stats":{"Line":3},"fn_name":"diff_shorter"},{"line":776,"address":[4901959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":777,"address":[4902057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":778,"address":[4902121],"length":1,"stats":{"Line":3},"fn_name":null},{"line":779,"address":[4902197],"length":1,"stats":{"Line":3},"fn_name":null},{"line":781,"address":[4902437,4902384,4902409,4902394],"length":1,"stats":{"Line":2},"fn_name":null},{"line":782,"address":[4902396,4902310],"length":1,"stats":{"Line":2},"fn_name":null},{"line":783,"address":[4902386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":788,"address":[4902640,4902608],"length":1,"stats":{"Line":3},"fn_name":"minmax"},{"line":798,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":799,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":804,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":805,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":809,"address":[4902622,4902808,4902655],"length":1,"stats":{"Line":2},"fn_name":null},{"line":811,"address":[4902787,4903111,4903503],"length":1,"stats":{"Line":2},"fn_name":null},{"line":813,"address":[4903240],"length":1,"stats":{"Line":1},"fn_name":null},{"line":815,"address":[4903814,4903918],"length":1,"stats":{"Line":2},"fn_name":null},{"line":816,"address":[4904065,4903933],"length":1,"stats":{"Line":1},"fn_name":null},{"line":818,"address":[4904039,4904419],"length":1,"stats":{"Line":4},"fn_name":null},{"line":819,"address":[4904777,4904583],"length":1,"stats":{"Line":1},"fn_name":null},{"line":820,"address":[4904689,4905122,4905162],"length":1,"stats":{"Line":2},"fn_name":null},{"line":822,"address":[4905136,4905516],"length":1,"stats":{"Line":4},"fn_name":null},{"line":823,"address":[4905668,4905853],"length":1,"stats":{"Line":1},"fn_name":null},{"line":824,"address":[4906159,4905768,4906183],"length":1,"stats":{"Line":2},"fn_name":null},{"line":828,"address":[4907312,4907168],"length":1,"stats":{"Line":3},"fn_name":"format"},{"line":829,"address":[4907189],"length":1,"stats":{"Line":1},"fn_name":null},{"line":830,"address":[4907233],"length":1,"stats":{"Line":1},"fn_name":null},{"line":831,"address":[4907253],"length":1,"stats":{"Line":1},"fn_name":null},{"line":833,"address":[4907334,4907273],"length":1,"stats":{"Line":2},"fn_name":null},{"line":834,"address":[4907750,4907592],"length":1,"stats":{"Line":1},"fn_name":null},{"line":835,"address":[4907724,4908088],"length":1,"stats":{"Line":2},"fn_name":null},{"line":836,"address":[4908352,4908564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":838,"address":[4908481],"length":1,"stats":{"Line":1},"fn_name":null},{"line":839,"address":[4908878,4908538],"length":1,"stats":{"Line":2},"fn_name":null},{"line":840,"address":[4909271,4909141],"length":1,"stats":{"Line":1},"fn_name":null},{"line":844,"address":[4909680],"length":1,"stats":{"Line":3},"fn_name":"while_some"},{"line":845,"address":[4909684],"length":1,"stats":{"Line":3},"fn_name":null},{"line":847,"address":[4909742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":852,"address":[4909856,4909978],"length":1,"stats":{"Line":3},"fn_name":"fold_while"},{"line":853,"address":[4909863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":854,"address":[4909871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":855,"address":[4909993,4910113],"length":1,"stats":{"Line":3},"fn_name":null},{"line":856,"address":[5160969,5160833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":857,"address":[5160999,5160873,5161029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":858,"address":[5160938,5160915],"length":1,"stats":{"Line":2},"fn_name":null},{"line":859,"address":[5160940],"length":1,"stats":{"Line":1},"fn_name":null},{"line":861,"address":[5160922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":863,"address":[4910093,4910132],"length":1,"stats":{"Line":2},"fn_name":null},{"line":864,"address":[4910339,4910149],"length":1,"stats":{"Line":1},"fn_name":null},{"line":865,"address":[4910626,4910243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":869,"address":[4910928,4911448],"length":1,"stats":{"Line":3},"fn_name":"tree_fold1"},{"line":870,"address":[4911067],"length":1,"stats":{"Line":1},"fn_name":null},{"line":889,"address":[4911418,4912455,4911627,4911463],"length":1,"stats":{"Line":3},"fn_name":null},{"line":890,"address":[4911747],"length":1,"stats":{"Line":1},"fn_name":null},{"line":891,"address":[4911870],"length":1,"stats":{"Line":3},"fn_name":null},{"line":892,"address":[4911957],"length":1,"stats":{"Line":3},"fn_name":null},{"line":893,"address":[4912014,4912145],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":529,"coverable":534},{"path":["/","home","kms","itertools","tests","tuples.rs"],"content":"use itertools::Itertools;\n\n#[test]\nfn tuples() {\n    let v = [1, 2, 3, 4, 5];\n    let mut iter = v.iter().cloned().tuples();\n    assert_eq!(Some((1,)), iter.next());\n    assert_eq!(Some((2,)), iter.next());\n    assert_eq!(Some((3,)), iter.next());\n    assert_eq!(Some((4,)), iter.next());\n    assert_eq!(Some((5,)), iter.next());\n    assert_eq!(None, iter.next());\n    assert_eq!(None, iter.into_buffer().next());\n\n    let mut iter = v.iter().cloned().tuples();\n    assert_eq!(Some((1, 2)), iter.next());\n    assert_eq!(Some((3, 4)), iter.next());\n    assert_eq!(None, iter.next());\n    itertools::assert_equal(vec![5], iter.into_buffer());\n\n    let mut iter = v.iter().cloned().tuples();\n    assert_eq!(Some((1, 2, 3)), iter.next());\n    assert_eq!(None, iter.next());\n    itertools::assert_equal(vec![4, 5], iter.into_buffer());\n\n    let mut iter = v.iter().cloned().tuples();\n    assert_eq!(Some((1, 2, 3, 4)), iter.next());\n    assert_eq!(None, iter.next());\n    itertools::assert_equal(vec![5], iter.into_buffer());\n}\n\n#[test]\nfn tuple_windows() {\n    let v = [1, 2, 3, 4, 5];\n\n    let mut iter = v.iter().cloned().tuple_windows();\n    assert_eq!(Some((1,)), iter.next());\n    assert_eq!(Some((2,)), iter.next());\n    assert_eq!(Some((3,)), iter.next());\n\n    let mut iter = v.iter().cloned().tuple_windows();\n    assert_eq!(Some((1, 2)), iter.next());\n    assert_eq!(Some((2, 3)), iter.next());\n    assert_eq!(Some((3, 4)), iter.next());\n    assert_eq!(Some((4, 5)), iter.next());\n    assert_eq!(None, iter.next());\n\n    let mut iter = v.iter().cloned().tuple_windows();\n    assert_eq!(Some((1, 2, 3)), iter.next());\n    assert_eq!(Some((2, 3, 4)), iter.next());\n    assert_eq!(Some((3, 4, 5)), iter.next());\n    assert_eq!(None, iter.next());\n\n    let mut iter = v.iter().cloned().tuple_windows();\n    assert_eq!(Some((1, 2, 3, 4)), iter.next());\n    assert_eq!(Some((2, 3, 4, 5)), iter.next());\n    assert_eq!(None, iter.next());\n\n    let v = [1, 2, 3];\n    let mut iter = v.iter().cloned().tuple_windows::<(_, _, _, _)>();\n    assert_eq!(None, iter.next());\n}\n\n#[test]\nfn next_tuple() {\n    let v = [1, 2, 3, 4, 5];\n    let mut iter = v.iter();\n    assert_eq!(iter.next_tuple().map(|(&x, &y)| (x, y)), Some((1, 2)));\n    assert_eq!(iter.next_tuple().map(|(&x, &y)| (x, y)), Some((3, 4)));\n    assert_eq!(iter.next_tuple::<(_, _)>(), None);\n}\n\n#[test]\nfn collect_tuple() {\n    let v = [1, 2];\n    let iter = v.iter().cloned();\n    assert_eq!(iter.collect_tuple(), Some((1, 2)));\n\n    let v = [1];\n    let iter = v.iter().cloned();\n    assert_eq!(iter.collect_tuple::<(_, _)>(), None);\n\n    let v = [1, 2, 3];\n    let iter = v.iter().cloned();\n    assert_eq!(iter.collect_tuple::<(_, _)>(), None);\n}\n","traces":[{"line":4,"address":[4212077,4211920],"length":1,"stats":{"Line":3},"fn_name":"tuples"},{"line":5,"address":[4211927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":6,"address":[4212038,4212108],"length":1,"stats":{"Line":2},"fn_name":null},{"line":7,"address":[4212361,4212174],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[4212865,4212337,4212706],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9,"address":[4213369,4212841,4213210],"length":1,"stats":{"Line":2},"fn_name":null},{"line":10,"address":[4213873,4213714,4213345],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[4213849,4214377,4214218],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[4214353,4214722,4214915],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[4214849,4215261],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[4215819],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[4215936,4216075],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[4216413,4216065,4216545],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[4217037,4216535,4216883],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4217375,4216994,4219959],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[4217498],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[4217615,4217754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[4217744,4218092,4218252],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[4220029,4218590,4218208],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[4218729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[4218967,4218834],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[4219417,4219269,4218957],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[4219717,4220099,4219374],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[4220304],"length":1,"stats":{"Line":3},"fn_name":"tuple_windows"},{"line":34,"address":[4220311],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[4220366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[4220632,4220477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[4220942,4220608,4221071],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[4221520,4221047,4221381],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[4221839,4221478],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[4222040,4221889],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4222014,4222473,4222350],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[4222906,4222783,4222447],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[4223216,4223339,4222880],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[4223649,4223313,4223788],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[4223746,4224107],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[4224157,4224308],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[4224618,4224741,4224282],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[4225174,4225051,4224715],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[4225148,4225623,4225484],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[4225942,4225581],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[4226143,4225992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[4226117,4226453,4226576],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[4226874,4226550,4227034],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[4226965],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4227323,4226998],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[4227361,4227488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[4227776],"length":1,"stats":{"Line":3},"fn_name":"next_tuple"},{"line":66,"address":[4227783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[4227851],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[4227872,4228065],"length":1,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[4228502,4228034,4228344],"length":1,"stats":{"Line":4},"fn_name":null},{"line":70,"address":[4228788,4228887,4228476],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[4229168],"length":1,"stats":{"Line":3},"fn_name":"collect_tuple"},{"line":75,"address":[4229175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[4229197],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[4229457,4229271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[4229404],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[4229752,4229415],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[4229773,4229969],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[4229900],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[4229933,4230258],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[4230414,4230279],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":63,"coverable":63},{"path":["/","home","kms","itertools","tests","zip.rs"],"content":"use itertools::Itertools;\nuse itertools::EitherOrBoth::{Both, Left, Right};\nuse itertools::free::zip_eq;\n\n#[test]\nfn zip_longest_fused() {\n    let a = [Some(1), None, Some(3), Some(4)];\n    let b = [1, 2, 3];\n\n    let unfused = a.iter().batching(|it| *it.next().unwrap())\n        .zip_longest(b.iter().cloned());\n    itertools::assert_equal(unfused,\n                       vec![Both(1, 1), Right(2), Right(3)]);\n}\n\n#[test]\nfn test_zip_longest_size_hint() {\n    let c = (1..10).cycle();\n    let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let v2 = &[10, 11, 12];\n\n    assert_eq!(c.zip_longest(v.iter()).size_hint(), (std::usize::MAX, None));\n\n    assert_eq!(v.iter().zip_longest(v2.iter()).size_hint(), (10, Some(10)));\n}\n\n#[test]\nfn test_double_ended_zip_longest() {\n    let xs = [1, 2, 3, 4, 5, 6];\n    let ys = [1, 2, 3, 7];\n    let a = xs.iter().map(|&x| x);\n    let b = ys.iter().map(|&x| x);\n    let mut it = a.zip_longest(b);\n    assert_eq!(it.next(), Some(Both(1, 1)));\n    assert_eq!(it.next(), Some(Both(2, 2)));\n    assert_eq!(it.next_back(), Some(Left(6)));\n    assert_eq!(it.next_back(), Some(Left(5)));\n    assert_eq!(it.next_back(), Some(Both(4, 7)));\n    assert_eq!(it.next(), Some(Both(3, 3)));\n    assert_eq!(it.next(), None);\n}\n\n\n#[should_panic]\n#[test]\nfn zip_eq_panic1()\n{\n    let a = [1, 2];\n    let b = [1, 2, 3];\n\n    zip_eq(&a, &b).count();\n}\n\n#[should_panic]\n#[test]\nfn zip_eq_panic2()\n{\n    let a: [i32; 0] = [];\n    let b = [1, 2, 3];\n\n    zip_eq(&a, &b).count();\n}\n\n","traces":[{"line":6,"address":[4210464],"length":1,"stats":{"Line":3},"fn_name":"zip_longest_fused"},{"line":7,"address":[4210471],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[4210591],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[4233120,4233134],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":11,"address":[4210677],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[4210764,4210983],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[4210796],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[4233184,4233189],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":18,"address":[4211031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[4211094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[4211114],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[4211122,4211377],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[4211341,4211656,4211847],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[4233216,4233221],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":29,"address":[4212135],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[4212201],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[4212245],"length":1,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[4212319],"length":1,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[4212393],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[4212438,4212589],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[4212899,4212563,4213022],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[4213332,4212996,4213455],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[4213765,4213888,4213429],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[4213862,4214315,4214198],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[4214601,4214289,4214718],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[4215004,4214692,4215103],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[4215392],"length":1,"stats":{"Line":3},"fn_name":"zip_eq_panic1"},{"line":48,"address":[4215396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[4215412],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[4215436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[4215472],"length":1,"stats":{"Line":3},"fn_name":"zip_eq_panic2"},{"line":59,"address":[4215476],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[4215500],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":33,"coverable":33}]}