{"files":[{"path":["/","home","kms","itertools","benches","bench1.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, Criterion};\nuse itertools::Itertools;\nuse itertools::free::cloned;\nuse itertools::iproduct;\n\nuse std::iter::repeat;\nuse std::cmp;\nuse std::ops::{Add, Range};\n\nmod extra;\n\nuse crate::extra::ZipSlices;\n\nfn slice_iter(c: &mut Criterion) {\n    let xs: Vec<_> = repeat(1i32).take(20).collect();\n\n    c.bench_function(\"slice iter\", move |b| {\n        b.iter(|| for elt in xs.iter() {\n            black_box(elt);\n        })\n    });\n}\n\nfn slice_iter_rev(c: &mut Criterion) {\n    let xs: Vec<_> = repeat(1i32).take(20).collect();\n\n    c.bench_function(\"slice iter rev\", move |b| {\n        b.iter(|| for elt in xs.iter().rev() {\n            black_box(elt);\n        })\n    });\n}\n\nfn zip_default_zip(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zip default zip\", move |b| {\n        b.iter(|| {\n            for (&x, &y) in xs.iter().zip(&ys) {\n                black_box(x);\n                black_box(y);\n            }\n        })\n    });\n}\n\nfn zipdot_i32_default_zip(c: &mut Criterion) {\n    let xs = vec![2; 1024];\n    let ys = vec![2; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot i32 default zip\", move |b| {\n        b.iter(|| {\n            let mut s = 0;\n            for (&x, &y) in xs.iter().zip(&ys) {\n                s += x * y;\n            }\n            s\n        })\n    });\n}\n\nfn zipdot_f32_default_zip(c: &mut Criterion) {\n    let xs = vec![2f32; 1024];\n    let ys = vec![2f32; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot f32 default zip\", move |b| {\n        b.iter(|| {\n            let mut s = 0.;\n            for (&x, &y) in xs.iter().zip(&ys) {\n                s += x * y;\n            }\n            s\n        })\n    });\n}\n\nfn zip_default_zip3(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n    let zs = vec![0; 766];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n    let zs = black_box(zs);\n\n    c.bench_function(\"zip default zip3\", move |b| {\n        b.iter(|| {\n            for ((&x, &y), &z) in xs.iter().zip(&ys).zip(&zs) {\n                black_box(x);\n                black_box(y);\n                black_box(z);\n            }\n        })\n    });\n}\n\nfn zip_slices_ziptuple(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n\n    c.bench_function(\"zip slices ziptuple\", move |b| {\n        b.iter(|| {\n            let xs = black_box(&xs);\n            let ys = black_box(&ys);\n            for (&x, &y) in itertools::multizip((xs, ys)) {\n                black_box(x);\n                black_box(y);\n            }\n        })\n    });\n}\n\nfn zipslices(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipslices\", move |b| {\n        b.iter(|| {\n            for (&x, &y) in ZipSlices::new(&xs, &ys) {\n                black_box(x);\n                black_box(y);\n            }\n        })\n    });\n}\n\nfn zipslices_mut(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n    let xs = black_box(xs);\n    let mut ys = black_box(ys);\n\n    c.bench_function(\"zipslices mut\", move |b| {\n        b.iter(|| {\n            for (&x, &mut y) in ZipSlices::from_slices(&xs[..], &mut ys[..]) {\n                black_box(x);\n                black_box(y);\n            }\n        })\n    });\n}\n\nfn zipdot_i32_zipslices(c: &mut Criterion) {\n    let xs = vec![2; 1024];\n    let ys = vec![2; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot i32 zipslices\", move |b| {\n        b.iter(|| {\n            let mut s = 0i32;\n            for (&x, &y) in ZipSlices::new(&xs, &ys) {\n                s += x * y;\n            }\n            s\n        })\n    });\n}\n\nfn zipdot_f32_zipslices(c: &mut Criterion) {\n    let xs = vec![2f32; 1024];\n    let ys = vec![2f32; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot f32 zipslices\", move |b| {\n        b.iter(|| {\n            let mut s = 0.;\n            for (&x, &y) in ZipSlices::new(&xs, &ys) {\n                s += x * y;\n            }\n            s\n        })\n    });\n}\n\nfn zip_checked_counted_loop(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zip checked counted loop\", move |b| {\n        b.iter(|| {\n            // Must slice to equal lengths, and then bounds checks are eliminated!\n            let len = cmp::min(xs.len(), ys.len());\n            let xs = &xs[..len];\n            let ys = &ys[..len];\n\n            for i in 0..len {\n                let x = xs[i];\n                let y = ys[i];\n                black_box(x);\n                black_box(y);\n            }\n        })\n    });\n}\n\nfn zipdot_i32_checked_counted_loop(c: &mut Criterion) {\n    let xs = vec![2; 1024];\n    let ys = vec![2; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot i32 checked counted loop\", move |b| {\n        b.iter(|| {\n            // Must slice to equal lengths, and then bounds checks are eliminated!\n            let len = cmp::min(xs.len(), ys.len());\n            let xs = &xs[..len];\n            let ys = &ys[..len];\n\n            let mut s = 0i32;\n\n            for i in 0..len {\n                s += xs[i] * ys[i];\n            }\n            s\n        })\n    });\n}\n\nfn zipdot_f32_checked_counted_loop(c: &mut Criterion) {\n    let xs = vec![2f32; 1024];\n    let ys = vec![2f32; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot f32 checked counted loop\", move |b| {\n        b.iter(|| {\n            // Must slice to equal lengths, and then bounds checks are eliminated!\n            let len = cmp::min(xs.len(), ys.len());\n            let xs = &xs[..len];\n            let ys = &ys[..len];\n\n            let mut s = 0.;\n\n            for i in 0..len {\n                s += xs[i] * ys[i];\n            }\n            s\n        })\n    });\n}\n\nfn zipdot_f32_checked_counted_unrolled_loop(c: &mut Criterion) {\n    let xs = vec![2f32; 1024];\n    let ys = vec![2f32; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot f32 checked counted unrolled loop\", move |b| {\n        b.iter(|| {\n            // Must slice to equal lengths, and then bounds checks are eliminated!\n            let len = cmp::min(xs.len(), ys.len());\n            let mut xs = &xs[..len];\n            let mut ys = &ys[..len];\n\n            let mut s = 0.;\n            let (mut p0, mut p1, mut p2, mut p3, mut p4, mut p5, mut p6, mut p7) =\n                (0., 0., 0., 0., 0., 0., 0., 0.);\n\n            // how to unroll and have bounds checks eliminated (by cristicbz)\n            // split sum into eight parts to enable vectorization (by bluss)\n            while xs.len() >= 8 {\n                p0 += xs[0] * ys[0];\n                p1 += xs[1] * ys[1];\n                p2 += xs[2] * ys[2];\n                p3 += xs[3] * ys[3];\n                p4 += xs[4] * ys[4];\n                p5 += xs[5] * ys[5];\n                p6 += xs[6] * ys[6];\n                p7 += xs[7] * ys[7];\n\n                xs = &xs[8..];\n                ys = &ys[8..];\n            }\n            s += p0 + p4;\n            s += p1 + p5;\n            s += p2 + p6;\n            s += p3 + p7;\n\n            for i in 0..xs.len() {\n                s += xs[i] * ys[i];\n            }\n            s\n        })\n    });\n}\n\nfn zip_unchecked_counted_loop(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zip unchecked counted loop\", move |b| {\n        b.iter(|| {\n            let len = cmp::min(xs.len(), ys.len());\n            for i in 0..len {\n                unsafe {\n                let x = *xs.get_unchecked(i);\n                let y = *ys.get_unchecked(i);\n                black_box(x);\n                black_box(y);\n                }\n            }\n        })\n    });\n}\n\nfn zipdot_i32_unchecked_counted_loop(c: &mut Criterion) {\n    let xs = vec![2; 1024];\n    let ys = vec![2; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot i32 unchecked counted loop\", move |b| {\n        b.iter(|| {\n            let len = cmp::min(xs.len(), ys.len());\n            let mut s = 0i32;\n            for i in 0..len {\n                unsafe {\n                let x = *xs.get_unchecked(i);\n                let y = *ys.get_unchecked(i);\n                s += x * y;\n                }\n            }\n            s\n        })\n    });\n}\n\nfn zipdot_f32_unchecked_counted_loop(c: &mut Criterion) {\n    let xs = vec![2.; 1024];\n    let ys = vec![2.; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot f32 unchecked counted loop\", move |b| {\n        b.iter(|| {\n            let len = cmp::min(xs.len(), ys.len());\n            let mut s = 0f32;\n            for i in 0..len {\n                unsafe {\n                let x = *xs.get_unchecked(i);\n                let y = *ys.get_unchecked(i);\n                s += x * y;\n                }\n            }\n            s\n        })\n    });\n}\n\nfn zip_unchecked_counted_loop3(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n    let zs = vec![0; 766];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n    let zs = black_box(zs);\n\n    c.bench_function(\"zip unchecked counted loop3\", move |b| {\n        b.iter(|| {\n            let len = cmp::min(xs.len(), cmp::min(ys.len(), zs.len()));\n            for i in 0..len {\n                unsafe {\n                let x = *xs.get_unchecked(i);\n                let y = *ys.get_unchecked(i);\n                let z = *zs.get_unchecked(i);\n                black_box(x);\n                black_box(y);\n                black_box(z);\n                }\n            }\n        })\n    });\n}\n\nfn group_by_lazy_1(c: &mut Criterion) {\n    let mut data = vec![0; 1024];\n    for (index, elt) in data.iter_mut().enumerate() {\n        *elt = index / 10;\n    }\n\n    let data = black_box(data);\n\n    c.bench_function(\"group by lazy 1\", move |b| {\n        b.iter(|| {\n            for (_key, group) in &data.iter().group_by(|elt| **elt) {\n                for elt in group {\n                    black_box(elt);\n                }\n            }\n        })\n    });\n}\n\nfn group_by_lazy_2(c: &mut Criterion) {\n    let mut data = vec![0; 1024];\n    for (index, elt) in data.iter_mut().enumerate() {\n        *elt = index / 2;\n    }\n\n    let data = black_box(data);\n\n    c.bench_function(\"group by lazy 2\", move |b| {\n        b.iter(|| {\n            for (_key, group) in &data.iter().group_by(|elt| **elt) {\n                for elt in group {\n                    black_box(elt);\n                }\n            }\n        })\n    });\n}\n\nfn slice_chunks(c: &mut Criterion) {\n    let data = vec![0; 1024];\n\n    let data = black_box(data);\n    let sz = black_box(10);\n\n    c.bench_function(\"slice chunks\", move |b| {\n        b.iter(|| {\n            for group in data.chunks(sz) {\n                for elt in group {\n                    black_box(elt);\n                }\n            }\n        })\n    });\n}\n\nfn chunks_lazy_1(c: &mut Criterion) {\n    let data = vec![0; 1024];\n\n    let data = black_box(data);\n    let sz = black_box(10);\n\n    c.bench_function(\"chunks lazy 1\", move |b| {\n        b.iter(|| {\n            for group in &data.iter().chunks(sz) {\n                for elt in group {\n                    black_box(elt);\n                }\n            }\n        })\n    });\n}\n\nfn equal(c: &mut Criterion) {\n    let data = vec![7; 1024];\n    let l = data.len();\n    let alpha = black_box(&data[1..]);\n    let beta = black_box(&data[..l - 1]);\n\n    c.bench_function(\"equal\", move |b| {\n        b.iter(|| {\n            itertools::equal(alpha, beta)\n        })\n    });\n}\n\nfn merge_default(c: &mut Criterion) {\n    let mut data1 = vec![0; 1024];\n    let mut data2 = vec![0; 800];\n    let mut x = 0;\n    for (_, elt) in data1.iter_mut().enumerate() {\n        *elt = x;\n        x += 1;\n    }\n\n    let mut y = 0;\n    for (i, elt) in data2.iter_mut().enumerate() {\n        *elt += y;\n        if i % 3 == 0 {\n            y += 3;\n        } else {\n            y += 0;\n        }\n    }\n    let data1 = black_box(data1);\n    let data2 = black_box(data2);\n\n    c.bench_function(\"merge default\", move |b| {\n        b.iter(|| {\n            data1.iter().merge(&data2).count()\n        })\n    });\n}\n\nfn merge_by_cmp(c: &mut Criterion) {\n    let mut data1 = vec![0; 1024];\n    let mut data2 = vec![0; 800];\n    let mut x = 0;\n    for (_, elt) in data1.iter_mut().enumerate() {\n        *elt = x;\n        x += 1;\n    }\n\n    let mut y = 0;\n    for (i, elt) in data2.iter_mut().enumerate() {\n        *elt += y;\n        if i % 3 == 0 {\n            y += 3;\n        } else {\n            y += 0;\n        }\n    }\n    let data1 = black_box(data1);\n    let data2 = black_box(data2);\n\n    c.bench_function(\"merge by cmp\", move |b| {\n        b.iter(|| {\n            data1.iter().merge_by(&data2, PartialOrd::le).count()\n        })\n    });\n}\n\nfn merge_by_lt(c: &mut Criterion) {\n    let mut data1 = vec![0; 1024];\n    let mut data2 = vec![0; 800];\n    let mut x = 0;\n    for (_, elt) in data1.iter_mut().enumerate() {\n        *elt = x;\n        x += 1;\n    }\n\n    let mut y = 0;\n    for (i, elt) in data2.iter_mut().enumerate() {\n        *elt += y;\n        if i % 3 == 0 {\n            y += 3;\n        } else {\n            y += 0;\n        }\n    }\n    let data1 = black_box(data1);\n    let data2 = black_box(data2);\n\n    c.bench_function(\"merge by lt\", move |b| {\n        b.iter(|| {\n            data1.iter().merge_by(&data2, |a, b| a <= b).count()\n        })\n    });\n}\n\nfn kmerge_default(c: &mut Criterion) {\n    let mut data1 = vec![0; 1024];\n    let mut data2 = vec![0; 800];\n    let mut x = 0;\n    for (_, elt) in data1.iter_mut().enumerate() {\n        *elt = x;\n        x += 1;\n    }\n\n    let mut y = 0;\n    for (i, elt) in data2.iter_mut().enumerate() {\n        *elt += y;\n        if i % 3 == 0 {\n            y += 3;\n        } else {\n            y += 0;\n        }\n    }\n    let data1 = black_box(data1);\n    let data2 = black_box(data2);\n    let its = &[data1.iter(), data2.iter()];\n\n    c.bench_function(\"kmerge default\", move |b| {\n        b.iter(|| {\n            its.iter().cloned().kmerge().count()\n        })\n    });\n}\n\nfn kmerge_tenway(c: &mut Criterion) {\n    let mut data = vec![0; 10240];\n\n    let mut state = 1729u16;\n    fn rng(state: &mut u16) -> u16 {\n        let new = state.wrapping_mul(31421) + 6927;\n        *state = new;\n        new\n    }\n\n    for elt in &mut data {\n        *elt = rng(&mut state);\n    }\n\n    let mut chunks = Vec::new();\n    let mut rest = &mut data[..];\n    while rest.len() > 0 {\n        let chunk_len = 1 + rng(&mut state) % 512;\n        let chunk_len = cmp::min(rest.len(), chunk_len as usize);\n        let (fst, tail) = {rest}.split_at_mut(chunk_len);\n        fst.sort();\n        chunks.push(fst.iter().cloned());\n        rest = tail;\n    }\n\n    // println!(\"Chunk lengths: {}\", chunks.iter().format_with(\", \", |elt, f| f(&elt.len())));\n\n    c.bench_function(\"kmerge tenway\", move |b| {\n        b.iter(|| {\n            chunks.iter().cloned().kmerge().count()\n        })\n    });\n}\n\nfn fast_integer_sum<I>(iter: I) -> I::Item\n    where I: IntoIterator,\n          I::Item: Default + Add<Output=I::Item>\n{\n    iter.into_iter().fold(<_>::default(), |x, y| x + y)\n}\n\nfn step_vec_2(c: &mut Criterion) {\n    let v = vec![0; 1024];\n\n    c.bench_function(\"step vec 2\", move |b| {\n        b.iter(|| {\n            fast_integer_sum(cloned(v.iter().step_by(2)))\n        })\n    });\n}\n\nfn step_vec_10(c: &mut Criterion) {\n    let v = vec![0; 1024];\n\n    c.bench_function(\"step vec 10\", move |b| {\n        b.iter(|| {\n            fast_integer_sum(cloned(v.iter().step_by(10)))\n        })\n    });\n}\n\nfn step_range_2(c: &mut Criterion) {\n    let v = black_box(0..1024);\n\n    c.bench_function(\"step range 2\", move |b| {\n        b.iter(|| {\n            fast_integer_sum(v.clone().step_by(2))\n        })\n    });\n}\n\nfn step_range_10(c: &mut Criterion) {\n    let v = black_box(0..1024);\n\n    c.bench_function(\"step range 10\", move |b| {\n        b.iter(|| {\n            fast_integer_sum(v.clone().step_by(10))\n        })\n    });\n}\n\nfn cartesian_product_iterator(c: &mut Criterion) {\n    let xs = vec![0; 16];\n\n    c.bench_function(\"cartesian product iterator\", move |b| {\n        b.iter(|| {\n            let mut sum = 0;\n            for (&x, &y, &z) in iproduct!(&xs, &xs, &xs) {\n                sum += x;\n                sum += y;\n                sum += z;\n            }\n            sum\n        })\n    });\n}\n\nfn cartesian_product_fold(c: &mut Criterion) {\n    let xs = vec![0; 16];\n\n    c.bench_function(\"cartesian product fold\", move |b| {\n        b.iter(|| {\n            let mut sum = 0;\n            iproduct!(&xs, &xs, &xs).fold((), |(), (&x, &y, &z)| {\n                sum += x;\n                sum += y;\n                sum += z;\n            });\n            sum\n        })\n    });\n}\n\nfn multi_cartesian_product_iterator(c: &mut Criterion) {\n    let xs = [vec![0; 16], vec![0; 16], vec![0; 16]];\n\n    c.bench_function(\"multi cartesian product iterator\", move |b| {\n        b.iter(|| {\n            let mut sum = 0;\n            for x in xs.iter().multi_cartesian_product() {\n                sum += x[0];\n                sum += x[1];\n                sum += x[2];\n            }\n            sum\n        })\n    });\n}\n\nfn multi_cartesian_product_fold(c: &mut Criterion) {\n    let xs = [vec![0; 16], vec![0; 16], vec![0; 16]];\n\n    c.bench_function(\"multi cartesian product fold\", move |b| {\n        b.iter(|| {\n            let mut sum = 0;\n            xs.iter().multi_cartesian_product().fold((), |(), x| {\n                sum += x[0];\n                sum += x[1];\n                sum += x[2];\n            });\n            sum\n        })\n    });\n}\n\nfn cartesian_product_nested_for(c: &mut Criterion) {\n    let xs = vec![0; 16];\n\n    c.bench_function(\"cartesian product nested for\", move |b| {\n        b.iter(|| {\n            let mut sum = 0;\n            for &x in &xs {\n                for &y in &xs {\n                    for &z in &xs {\n                        sum += x;\n                        sum += y;\n                        sum += z;\n                    }\n                }\n            }\n            sum\n        })\n    });\n}\n\nfn all_equal(c: &mut Criterion) {\n    let mut xs = vec![0; 5_000_000];\n    xs.extend(vec![1; 5_000_000]);\n\n    c.bench_function(\"all equal\", move |b| {\n        b.iter(|| xs.iter().all_equal())\n    });\n}\n\nfn all_equal_for(c: &mut Criterion) {\n    let mut xs = vec![0; 5_000_000];\n    xs.extend(vec![1; 5_000_000]);\n\n    c.bench_function(\"all equal for\", move |b| {\n        b.iter(|| {\n            for &x in &xs {\n                if x != xs[0] {\n                    return false;\n                }\n            }\n            true\n        })\n    });\n}\n\nfn all_equal_default(c: &mut Criterion) {\n    let mut xs = vec![0; 5_000_000];\n    xs.extend(vec![1; 5_000_000]);\n\n    c.bench_function(\"all equal default\", move |b| {\n        b.iter(|| xs.iter().dedup().nth(1).is_none())\n    });\n}\n\nconst PERM_COUNT: usize = 6;\n\nfn permutations_iter(c: &mut Criterion) {\n    struct NewIterator(Range<usize>);\n\n    impl Iterator for NewIterator {\n        type Item = usize;\n\n        fn next(&mut self) -> Option<Self::Item> {\n            self.0.next()\n        }\n    }\n\n    c.bench_function(\"permutations iter\", move |b| {\n        b.iter(|| {\n            for _ in NewIterator(0..PERM_COUNT).permutations(PERM_COUNT) {\n\n            }\n        })\n    });\n}\n\nfn permutations_range(c: &mut Criterion) {\n    c.bench_function(\"permutations range\", move |b| {\n        b.iter(|| {\n            for _ in (0..PERM_COUNT).permutations(PERM_COUNT) {\n\n            }\n        })\n    });\n}\n\nfn permutations_slice(c: &mut Criterion) {\n    let v = (0..PERM_COUNT).collect_vec();\n\n    c.bench_function(\"permutations slice\", move |b| {\n        b.iter(|| {\n            for _ in v.as_slice().iter().permutations(PERM_COUNT) {\n\n            }\n        })\n    });\n}\n\ncriterion_group!(\n    benches,\n    slice_iter,\n    slice_iter_rev,\n    zip_default_zip,\n    zipdot_i32_default_zip,\n    zipdot_f32_default_zip,\n    zip_default_zip3,\n    zip_slices_ziptuple,\n    zipslices,\n    zipslices_mut,\n    zipdot_i32_zipslices,\n    zipdot_f32_zipslices,\n    zip_checked_counted_loop,\n    zipdot_i32_checked_counted_loop,\n    zipdot_f32_checked_counted_loop,\n    zipdot_f32_checked_counted_unrolled_loop,\n    zip_unchecked_counted_loop,\n    zipdot_i32_unchecked_counted_loop,\n    zipdot_f32_unchecked_counted_loop,\n    zip_unchecked_counted_loop3,\n    group_by_lazy_1,\n    group_by_lazy_2,\n    slice_chunks,\n    chunks_lazy_1,\n    equal,\n    merge_default,\n    merge_by_cmp,\n    merge_by_lt,\n    kmerge_default,\n    kmerge_tenway,\n    step_vec_2,\n    step_vec_10,\n    step_range_2,\n    step_range_10,\n    cartesian_product_iterator,\n    cartesian_product_fold,\n    multi_cartesian_product_iterator,\n    multi_cartesian_product_fold,\n    cartesian_product_nested_for,\n    all_equal,\n    all_equal_for,\n    all_equal_default,\n    permutations_iter,\n    permutations_range,\n    permutations_slice,\n);\ncriterion_main!(benches);\n","traces":[{"line":794,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":795,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","kms","itertools","benches","extra","zipslices.rs"],"content":"use std::cmp;\n\n// Note: There are different ways to implement ZipSlices.\n// This version performed the best in benchmarks.\n//\n// I also implemented a version with three pointes (tptr, tend, uptr),\n// that mimiced slice::Iter and only checked bounds by using tptr == tend,\n// but that was inferior to this solution.\n\n/// An iterator which iterates two slices simultaneously.\n///\n/// `ZipSlices` acts like a double-ended `.zip()` iterator.\n///\n/// It was intended to be more efficient than `.zip()`, and it was, then\n/// rustc changed how it optimizes so it can not promise improved performance\n/// at this time.\n///\n/// Note that elements past the end of the shortest of the two slices are ignored.\n///\n/// Iterator element type for `ZipSlices<T, U>` is `(T::Item, U::Item)`. For example,\n/// for a `ZipSlices<&'a [A], &'b mut [B]>`, the element type is `(&'a A, &'b mut B)`.\n#[derive(Clone)]\npub struct ZipSlices<T, U> {\n    t: T,\n    u: U,\n    len: usize,\n    index: usize,\n}\n\nimpl<'a, 'b, A, B> ZipSlices<&'a [A], &'b [B]> {\n    /// Create a new `ZipSlices` from slices `a` and `b`.\n    ///\n    /// Act like a double-ended `.zip()` iterator, but more efficiently.\n    ///\n    /// Note that elements past the end of the shortest of the two slices are ignored.\n    #[inline(always)]\n    pub fn new(a: &'a [A], b: &'b [B]) -> Self {\n        let minl = cmp::min(a.len(), b.len());\n        ZipSlices {\n            t: a,\n            u: b,\n            len: minl,\n            index: 0,\n        }\n    }\n}\n\nimpl<T, U> ZipSlices<T, U>\n    where T: Slice,\n          U: Slice\n{\n    /// Create a new `ZipSlices` from slices `a` and `b`.\n    ///\n    /// Act like a double-ended `.zip()` iterator, but more efficiently.\n    ///\n    /// Note that elements past the end of the shortest of the two slices are ignored.\n    #[inline(always)]\n    pub fn from_slices(a: T, b: U) -> Self {\n        let minl = cmp::min(a.len(), b.len());\n        ZipSlices {\n            t: a,\n            u: b,\n            len: minl,\n            index: 0,\n        }\n    }\n}\n\nimpl<T, U> Iterator for ZipSlices<T, U>\n    where T: Slice,\n          U: Slice\n{\n    type Item = (T::Item, U::Item);\n\n    #[inline(always)]\n    fn next(&mut self) -> Option<Self::Item> {\n        unsafe {\n            if self.index >= self.len {\n                None\n            } else {\n                let i = self.index;\n                self.index += 1;\n                Some((\n                    self.t.get_unchecked(i),\n                    self.u.get_unchecked(i)))\n            }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let len = self.len - self.index;\n        (len, Some(len))\n    }\n}\n\nimpl<T, U> DoubleEndedIterator for ZipSlices<T, U>\n    where T: Slice,\n          U: Slice\n{\n    #[inline(always)]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        unsafe {\n            if self.index >= self.len {\n                None\n            } else {\n                self.len -= 1;\n                let i = self.len;\n                Some((\n                    self.t.get_unchecked(i),\n                    self.u.get_unchecked(i)))\n            }\n        }\n    }\n}\n\nimpl<T, U> ExactSizeIterator for ZipSlices<T, U>\n    where T: Slice,\n          U: Slice\n{}\n\nunsafe impl<T, U> Slice for ZipSlices<T, U>\n    where T: Slice,\n          U: Slice\n{\n    type Item = (T::Item, U::Item);\n\n    fn len(&self) -> usize {\n        self.len - self.index\n    }\n\n    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n        (self.t.get_unchecked(i),\n         self.u.get_unchecked(i))\n    }\n}\n\n/// A helper trait to let `ZipSlices` accept both `&[T]` and `&mut [T]`.\n///\n/// Unsafe trait because:\n///\n/// - Implementors must guarantee that `get_unchecked` is valid for all indices `0..len()`.\npub unsafe trait Slice {\n    /// The type of a reference to the slice's elements\n    type Item;\n    #[doc(hidden)]\n    fn len(&self) -> usize;\n    #[doc(hidden)]\n    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item;\n}\n\nunsafe impl<'a, T> Slice for &'a [T] {\n    type Item = &'a T;\n    #[inline(always)]\n    fn len(&self) -> usize { (**self).len() }\n    #[inline(always)]\n    unsafe fn get_unchecked(&mut self, i: usize) -> &'a T {\n        debug_assert!(i < self.len());\n        (**self).get_unchecked(i)\n    }\n}\n\nunsafe impl<'a, T> Slice for &'a mut [T] {\n    type Item = &'a mut T;\n    #[inline(always)]\n    fn len(&self) -> usize { (**self).len() }\n    #[inline(always)]\n    unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut T {\n        debug_assert!(i < self.len());\n        // override the lifetime constraints of &mut &'a mut [T]\n        (*(*self as *mut [T])).get_unchecked_mut(i)\n    }\n}\n\n#[test]\nfn zipslices() {\n\n    let xs = [1, 2, 3, 4, 5, 6];\n    let ys = [1, 2, 3, 7];\n    ::itertools::assert_equal(ZipSlices::new(&xs, &ys), xs.iter().zip(&ys));\n\n    let xs = [1, 2, 3, 4, 5, 6];\n    let mut ys = [0; 6];\n    for (x, y) in ZipSlices::from_slices(&xs[..], &mut ys[..]) {\n        *y = *x;\n    }\n    ::itertools::assert_equal(&xs, &ys);\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":34},{"path":["/","home","kms","itertools","benches","fold_specialization.rs"],"content":"use criterion::{criterion_group, criterion_main, Criterion};\nuse itertools::Itertools;\n\nstruct Unspecialized<I>(I);\n\nimpl<I> Iterator for Unspecialized<I>\nwhere I: Iterator\n{\n    type Item = I::Item;\n\n    #[inline(always)]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.0.next()\n    }\n\n    #[inline(always)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.0.size_hint()\n    }\n}\n\nmod specialization {\n    use super::*;\n\n    pub mod intersperse {\n        use super::*;\n\n        pub fn external(c: &mut Criterion)\n        {\n            let arr = [1; 1024];\n\n            c.bench_function(\"external\", move |b| {\n                b.iter(|| {\n                    let mut sum = 0;\n                    for &x in arr.iter().intersperse(&0) {\n                        sum += x;\n                    }\n                    sum\n                })\n            });\n        }\n\n        pub fn internal_specialized(c: &mut Criterion)\n        {\n            let arr = [1; 1024];\n\n            c.bench_function(\"internal specialized\", move |b| {\n                b.iter(|| {\n                    arr.iter().intersperse(&0).fold(0, |acc, x| acc + x)\n                })\n            });\n        }\n\n        pub fn internal_unspecialized(c: &mut Criterion)\n        {\n            let arr = [1; 1024];\n\n            c.bench_function(\"internal unspecialized\", move |b| {\n                b.iter(|| {\n                    Unspecialized(arr.iter().intersperse(&0)).fold(0, |acc, x| acc + x)\n                })\n            });\n        }\n    }\n}\n\ncriterion_group!(\n    benches,\n    specialization::intersperse::external,\n    specialization::intersperse::internal_specialized,\n    specialization::intersperse::internal_unspecialized,\n);\ncriterion_main!(benches);\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","kms","itertools","benches","tree_fold1.rs"],"content":"use criterion::{criterion_group, criterion_main, Criterion};\nuse itertools::{Itertools, cloned};\n\ntrait IterEx : Iterator {\n    // Another efficient implementation against which to compare,\n    // but needs `std` so is less desirable.\n    fn tree_fold1_vec<F>(self, mut f: F) -> Option<Self::Item>\n        where F: FnMut(Self::Item, Self::Item) -> Self::Item,\n              Self: Sized,\n    {\n        let hint = self.size_hint().0;\n        let cap = std::mem::size_of::<usize>() * 8 - hint.leading_zeros() as usize;\n        let mut stack = Vec::with_capacity(cap);\n        self.enumerate().for_each(|(mut i, mut x)| {\n            while (i & 1) != 0 {\n                x = f(stack.pop().unwrap(), x);\n                i >>= 1;\n            }\n            stack.push(x);\n        });\n        stack.into_iter().fold1(f)\n    }\n}\nimpl<T:Iterator> IterEx for T {}\n\nmacro_rules! def_benchs {\n    ($N:expr,\n     $FUN:ident,\n     $BENCH_NAME:ident,\n     ) => (\n        mod $BENCH_NAME {\n            use super::*;\n\n            pub fn sum(c: &mut Criterion) {\n                let v: Vec<u32> = (0.. $N).collect();\n\n                c.bench_function(&(stringify!($BENCH_NAME).replace('_', \" \") + \" sum\"), move |b| {\n                    b.iter(|| {\n                        cloned(&v).$FUN(|x, y| x + y)\n                    })\n                });\n            }\n\n            pub fn complex_iter(c: &mut Criterion) {\n                let u = (3..).take($N / 2);\n                let v = (5..).take($N / 2);\n                let it = u.chain(v);\n\n                c.bench_function(&(stringify!($BENCH_NAME).replace('_', \" \") + \" complex iter\"), move |b| {\n                    b.iter(|| {\n                        it.clone().map(|x| x as f32).$FUN(f32::atan2)\n                    })\n                });\n            }\n\n            pub fn string_format(c: &mut Criterion) {\n                // This goes quadratic with linear `fold1`, so use a smaller\n                // size to not waste too much time in travis.  The allocations\n                // in here are so expensive anyway that it'll still take\n                // way longer per iteration than the other two benchmarks.\n                let v: Vec<u32> = (0.. ($N/4)).collect();\n\n                c.bench_function(&(stringify!($BENCH_NAME).replace('_', \" \") + \" string format\"), move |b| {\n                    b.iter(|| {\n                        cloned(&v).map(|x| x.to_string()).$FUN(|x, y| format!(\"{} + {}\", x, y))\n                    })\n                });\n            }\n        }\n\n        criterion_group!(\n            $BENCH_NAME,\n            $BENCH_NAME::sum,\n            $BENCH_NAME::complex_iter,\n            $BENCH_NAME::string_format,\n        );\n    )\n}\n\ndef_benchs!{\n    10_000,\n    fold1,\n    fold1_10k,\n}\n\ndef_benchs!{\n    10_000,\n    tree_fold1,\n    tree_fold1_stack_10k,\n}\n\ndef_benchs!{\n    10_000,\n    tree_fold1_vec,\n    tree_fold1_vec_10k,\n}\n\ndef_benchs!{\n    100,\n    fold1,\n    fold1_100,\n}\n\ndef_benchs!{\n    100,\n    tree_fold1,\n    tree_fold1_stack_100,\n}\n\ndef_benchs!{\n    100,\n    tree_fold1_vec,\n    tree_fold1_vec_100,\n}\n\ndef_benchs!{\n    8,\n    fold1,\n    fold1_08,\n}\n\ndef_benchs!{\n    8,\n    tree_fold1,\n    tree_fold1_stack_08,\n}\n\ndef_benchs!{\n    8,\n    tree_fold1_vec,\n    tree_fold1_vec_08,\n}\n\ncriterion_main!(\n    fold1_10k,\n    tree_fold1_stack_10k,\n    tree_fold1_vec_10k,\n    fold1_100,\n    tree_fold1_stack_100,\n    tree_fold1_vec_100,\n    fold1_08,\n    tree_fold1_stack_08,\n    tree_fold1_vec_08,\n);\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":9},{"path":["/","home","kms","itertools","src","adaptors","mod.rs"],"content":"//! Licensed under the Apache License, Version 2.0\n//! http://www.apache.org/licenses/LICENSE-2.0 or the MIT license\n//! http://opensource.org/licenses/MIT, at your\n//! option. This file may not be copied, modified, or distributed\n//! except according to those terms.\n\nmod multi_product;\n#[cfg(feature = \"use_std\")]\npub use self::multi_product::*;\n\nuse std::fmt;\nuse std::mem::replace;\nuse std::iter::{Fuse, Peekable, FromIterator, FusedIterator};\nuse std::marker::PhantomData;\nuse crate::size_hint;\n\n/// An iterator adaptor that alternates elements from two iterators until both\n/// run out.\n///\n/// This iterator is *fused*.\n///\n/// See [`.interleave()`](../trait.Itertools.html#method.interleave) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Interleave<I, J> {\n    a: Fuse<I>,\n    b: Fuse<J>,\n    flag: bool,\n}\n\n/// Create an iterator that interleaves elements in `i` and `j`.\n///\n/// `IntoIterator` enabled version of `i.interleave(j)`.\n///\n/// ```\n/// use itertools::interleave;\n///\n/// for elt in interleave(&[1, 2, 3], &[2, 3, 4]) {\n///     /* loop body */\n/// }\n/// ```\npub fn interleave<I, J>(i: I, j: J) -> Interleave<<I as IntoIterator>::IntoIter, <J as IntoIterator>::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator<Item = I::Item>\n{\n    Interleave {\n        a: i.into_iter().fuse(),\n        b: j.into_iter().fuse(),\n        flag: false,\n    }\n}\n\nimpl<I, J> Iterator for Interleave<I, J>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.flag = !self.flag;\n        if self.flag {\n            match self.a.next() {\n                None => self.b.next(),\n                r => r,\n            }\n        } else {\n            match self.b.next() {\n                None => self.a.next(),\n                r => r,\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add(self.a.size_hint(), self.b.size_hint())\n    }\n}\n\n/// An iterator adaptor that alternates elements from the two iterators until\n/// one of them runs out.\n///\n/// This iterator is *fused*.\n///\n/// See [`.interleave_shortest()`](../trait.Itertools.html#method.interleave_shortest)\n/// for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct InterleaveShortest<I, J>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    it0: I,\n    it1: J,\n    phase: bool, // false ==> it0, true ==> it1\n}\n\n/// Create a new `InterleaveShortest` iterator.\npub fn interleave_shortest<I, J>(a: I, b: J) -> InterleaveShortest<I, J>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    InterleaveShortest {\n        it0: a,\n        it1: b,\n        phase: false,\n    }\n}\n\nimpl<I, J> Iterator for InterleaveShortest<I, J>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    type Item = I::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.phase {\n            false => match self.it0.next() {\n                None => None,\n                e => {\n                    self.phase = true;\n                    e\n                }\n            },\n            true => match self.it1.next() {\n                None => None,\n                e => {\n                    self.phase = false;\n                    e\n                }\n            },\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (curr_hint, next_hint) = {\n            let it0_hint = self.it0.size_hint();\n            let it1_hint = self.it1.size_hint();\n            if self.phase {\n                (it1_hint, it0_hint)\n            } else {\n                (it0_hint, it1_hint)\n            }\n        };\n        let (curr_lower, curr_upper) = curr_hint;\n        let (next_lower, next_upper) = next_hint;\n        let (combined_lower, combined_upper) =\n            size_hint::mul_scalar(size_hint::min(curr_hint, next_hint), 2);\n        let lower =\n            if curr_lower > next_lower {\n                combined_lower + 1\n            } else {\n                combined_lower\n            };\n        let upper = {\n            let extra_elem = match (curr_upper, next_upper) {\n                (_, None) => false,\n                (None, Some(_)) => true,\n                (Some(curr_max), Some(next_max)) => curr_max > next_max,\n            };\n            if extra_elem {\n                combined_upper.and_then(|x| x.checked_add(1))\n            } else {\n                combined_upper\n            }\n        };\n        (lower, upper)\n    }\n}\n\n#[derive(Clone, Debug)]\n/// An iterator adaptor that allows putting back a single\n/// item to the front of the iterator.\n///\n/// Iterator element type is `I::Item`.\npub struct PutBack<I>\n    where I: Iterator\n{\n    top: Option<I::Item>,\n    iter: I,\n}\n\n/// Create an iterator where you can put back a single item\npub fn put_back<I>(iterable: I) -> PutBack<I::IntoIter>\n    where I: IntoIterator\n{\n    PutBack {\n        top: None,\n        iter: iterable.into_iter(),\n    }\n}\n\nimpl<I> PutBack<I>\n    where I: Iterator\n{\n    /// put back value `value` (builder method)\n    pub fn with_value(mut self, value: I::Item) -> Self {\n        self.put_back(value);\n        self\n    }\n\n    /// Split the `PutBack` into its parts.\n    #[inline]\n    pub fn into_parts(self) -> (Option<I::Item>, I) {\n        let PutBack{top, iter} = self;\n        (top, iter)\n    }\n\n    /// Put back a single value to the front of the iterator.\n    ///\n    /// If a value is already in the put back slot, it is overwritten.\n    #[inline]\n    pub fn put_back(&mut self, x: I::Item) {\n        self.top = Some(x)\n    }\n}\n\nimpl<I> Iterator for PutBack<I>\n    where I: Iterator\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.top {\n            None => self.iter.next(),\n            ref mut some => some.take(),\n        }\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // Not ExactSizeIterator because size may be larger than usize\n        size_hint::add_scalar(self.iter.size_hint(), self.top.is_some() as usize)\n    }\n\n    fn count(self) -> usize {\n        self.iter.count() + (self.top.is_some() as usize)\n    }\n\n    fn last(self) -> Option<Self::Item> {\n        self.iter.last().or(self.top)\n    }\n\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        match self.top {\n            None => self.iter.nth(n),\n            ref mut some => {\n                if n == 0 {\n                    some.take()\n                } else {\n                    *some = None;\n                    self.iter.nth(n - 1)\n                }\n            }\n        }\n    }\n\n    fn all<G>(&mut self, mut f: G) -> bool\n        where G: FnMut(Self::Item) -> bool\n    {\n        if let Some(elt) = self.top.take() {\n            if !f(elt) {\n                return false;\n            }\n        }\n        self.iter.all(f)\n    }\n\n    fn fold<Acc, G>(mut self, init: Acc, mut f: G) -> Acc\n        where G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        let mut accum = init;\n        if let Some(elt) = self.top.take() {\n            accum = f(accum, elt);\n        }\n        self.iter.fold(accum, f)\n    }\n}\n\n#[derive(Debug, Clone)]\n/// An iterator adaptor that iterates over the cartesian product of\n/// the element sets of two iterators `I` and `J`.\n///\n/// Iterator element type is `(I::Item, J::Item)`.\n///\n/// See [`.cartesian_product()`](../trait.Itertools.html#method.cartesian_product) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Product<I, J>\n    where I: Iterator\n{\n    a: I,\n    a_cur: Option<I::Item>,\n    b: J,\n    b_orig: J,\n}\n\n/// Create a new cartesian product iterator\n///\n/// Iterator element type is `(I::Item, J::Item)`.\npub fn cartesian_product<I, J>(mut i: I, j: J) -> Product<I, J>\n    where I: Iterator,\n          J: Clone + Iterator,\n          I::Item: Clone\n{\n    Product {\n        a_cur: i.next(),\n        a: i,\n        b: j.clone(),\n        b_orig: j,\n    }\n}\n\nimpl<I, J> Iterator for Product<I, J>\n    where I: Iterator,\n          J: Clone + Iterator,\n          I::Item: Clone\n{\n    type Item = (I::Item, J::Item);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let elt_b = match self.b.next() {\n            None => {\n                self.b = self.b_orig.clone();\n                match self.b.next() {\n                    None => return None,\n                    Some(x) => {\n                        self.a_cur = self.a.next();\n                        x\n                    }\n                }\n            }\n            Some(x) => x\n        };\n        match self.a_cur {\n            None => None,\n            Some(ref a) => {\n                Some((a.clone(), elt_b))\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let has_cur = self.a_cur.is_some() as usize;\n        // Not ExactSizeIterator because size may be larger than usize\n        let (b_min, b_max) = self.b.size_hint();\n\n        // Compute a * b_orig + b for both lower and upper bound\n        size_hint::add(\n            size_hint::mul(self.a.size_hint(), self.b_orig.size_hint()),\n            (b_min * has_cur, b_max.map(move |x| x * has_cur)))\n    }\n\n    fn fold<Acc, G>(mut self, mut accum: Acc, mut f: G) -> Acc\n        where G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        // use a split loop to handle the loose a_cur as well as avoiding to\n        // clone b_orig at the end.\n        if let Some(mut a) = self.a_cur.take() {\n            let mut b = self.b;\n            loop {\n                accum = b.fold(accum, |acc, elt| f(acc, (a.clone(), elt)));\n\n                // we can only continue iterating a if we had a first element;\n                if let Some(next_a) = self.a.next() {\n                    b = self.b_orig.clone();\n                    a = next_a;\n                } else {\n                    break;\n                }\n            }\n        }\n        accum\n    }\n}\n\n/// A “meta iterator adaptor”. Its closure receives a reference to the iterator\n/// and may pick off as many elements as it likes, to produce the next iterator element.\n///\n/// Iterator element type is *X*, if the return type of `F` is *Option\\<X\\>*.\n///\n/// See [`.batching()`](../trait.Itertools.html#method.batching) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Batching<I, F> {\n    f: F,\n    iter: I,\n}\n\nimpl<I, F> fmt::Debug for Batching<I, F> where I: fmt::Debug {\n    debug_fmt_fields!(Batching, iter);\n}\n\n/// Create a new Batching iterator.\npub fn batching<I, F>(iter: I, f: F) -> Batching<I, F> {\n    Batching { f, iter }\n}\n\nimpl<B, F, I> Iterator for Batching<I, F>\n    where I: Iterator,\n          F: FnMut(&mut I) -> Option<B>\n{\n    type Item = B;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        (self.f)(&mut self.iter)\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // No information about closue behavior\n        (0, None)\n    }\n}\n\n/// An iterator adaptor that steps a number elements in the base iterator\n/// for each iteration.\n///\n/// The iterator steps by yielding the next element from the base iterator,\n/// then skipping forward *n-1* elements.\n///\n/// See [`.step()`](../trait.Itertools.html#method.step) for more information.\n#[deprecated(note=\"Use std .step_by() instead\", since=\"0.8\")]\n#[allow(deprecated)]\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Step<I> {\n    iter: Fuse<I>,\n    skip: usize,\n}\n\n/// Create a `Step` iterator.\n///\n/// **Panics** if the step is 0.\n#[allow(deprecated)]\npub fn step<I>(iter: I, step: usize) -> Step<I>\n    where I: Iterator\n{\n    assert!(step != 0);\n    Step {\n        iter: iter.fuse(),\n        skip: step - 1,\n    }\n}\n\n#[allow(deprecated)]\nimpl<I> Iterator for Step<I>\n    where I: Iterator\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let elt = self.iter.next();\n        if self.skip > 0 {\n            self.iter.nth(self.skip - 1);\n        }\n        elt\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, high) = self.iter.size_hint();\n        let div = |x: usize| {\n            if x == 0 {\n                0\n            } else {\n                1 + (x - 1) / (self.skip + 1)\n            }\n        };\n        (div(low), high.map(div))\n    }\n}\n\n// known size\n#[allow(deprecated)]\nimpl<I> ExactSizeIterator for Step<I>\n    where I: ExactSizeIterator\n{}\n\npub trait MergePredicate<T> {\n    fn merge_pred(&mut self, a: &T, b: &T) -> bool;\n}\n\n#[derive(Clone)]\npub struct MergeLte;\n\nimpl<T: PartialOrd> MergePredicate<T> for MergeLte {\n    fn merge_pred(&mut self, a: &T, b: &T) -> bool {\n        a <= b\n    }\n}\n\n/// An iterator adaptor that merges the two base iterators in ascending order.\n/// If both base iterators are sorted (ascending), the result is sorted.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.merge()`](../trait.Itertools.html#method.merge_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub type Merge<I, J> = MergeBy<I, J, MergeLte>;\n\n/// Create an iterator that merges elements in `i` and `j`.\n///\n/// `IntoIterator` enabled version of `i.merge(j)`.\n///\n/// ```\n/// use itertools::merge;\n///\n/// for elt in merge(&[1, 2, 3], &[2, 3, 4]) {\n///     /* loop body */\n/// }\n/// ```\npub fn merge<I, J>(i: I, j: J) -> Merge<<I as IntoIterator>::IntoIter, <J as IntoIterator>::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator<Item = I::Item>,\n          I::Item: PartialOrd\n{\n    merge_by_new(i, j, MergeLte)\n}\n\n/// An iterator adaptor that merges the two base iterators in ascending order.\n/// If both base iterators are sorted (ascending), the result is sorted.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.merge_by()`](../trait.Itertools.html#method.merge_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MergeBy<I, J, F>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    a: Peekable<I>,\n    b: Peekable<J>,\n    fused: Option<bool>,\n    cmp: F,\n}\n\nimpl<I, J, F> fmt::Debug for MergeBy<I, J, F>\n    where I: Iterator + fmt::Debug, J: Iterator<Item = I::Item> + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(MergeBy, a, b);\n}\n\nimpl<T, F: FnMut(&T, &T)->bool> MergePredicate<T> for F {\n    fn merge_pred(&mut self, a: &T, b: &T) -> bool {\n        self(a, b)\n    }\n}\n\n/// Create a `MergeBy` iterator.\npub fn merge_by_new<I, J, F>(a: I, b: J, cmp: F) -> MergeBy<I::IntoIter, J::IntoIter, F>\n    where I: IntoIterator,\n          J: IntoIterator<Item = I::Item>,\n          F: MergePredicate<I::Item>,\n{\n    MergeBy {\n        a: a.into_iter().peekable(),\n        b: b.into_iter().peekable(),\n        fused: None,\n        cmp,\n    }\n}\n\nimpl<I, J, F> Clone for MergeBy<I, J, F>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>,\n          Peekable<I>: Clone,\n          Peekable<J>: Clone,\n          F: Clone\n{\n    clone_fields!(a, b, fused, cmp);\n}\n\nimpl<I, J, F> Iterator for MergeBy<I, J, F>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>,\n          F: MergePredicate<I::Item>\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let less_than = match self.fused {\n            Some(lt) => lt,\n            None => match (self.a.peek(), self.b.peek()) {\n                (Some(a), Some(b)) => self.cmp.merge_pred(a, b),\n                (Some(_), None) => {\n                    self.fused = Some(true);\n                    true\n                }\n                (None, Some(_)) => {\n                    self.fused = Some(false);\n                    false\n                }\n                (None, None) => return None,\n            }\n        };\n        if less_than {\n            self.a.next()\n        } else {\n            self.b.next()\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // Not ExactSizeIterator because size may be larger than usize\n        size_hint::add(self.a.size_hint(), self.b.size_hint())\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct CoalesceCore<I, T>\n    where I: Iterator\n{\n    iter: I,\n    last: Option<T>,\n}\n\nimpl<I, T> CoalesceCore<I, T>\n    where I: Iterator\n{\n    fn next_with<F>(&mut self, mut f: F) -> Option<T>\n        where F: FnMut(T, I::Item) -> Result<T, (T, T)>\n    {\n        // this fuses the iterator\n        let mut last = match self.last.take() {\n            None => return None,\n            Some(x) => x,\n        };\n        for next in &mut self.iter {\n            match f(last, next) {\n                Ok(joined) => last = joined,\n                Err((last_, next_)) => {\n                    self.last = Some(next_);\n                    return Some(last_);\n                }\n            }\n        }\n\n        Some(last)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, hi) = size_hint::add_scalar(self.iter.size_hint(),\n                                              self.last.is_some() as usize);\n        ((low > 0) as usize, hi)\n    }\n}\n\n/// An iterator adaptor that may join together adjacent elements.\n///\n/// See [`.coalesce()`](../trait.Itertools.html#method.coalesce) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Coalesce<I, F>\n    where I: Iterator\n{\n    iter: CoalesceCore<I, I::Item>,\n    f: F,\n}\n\nimpl<I: Clone, F: Clone> Clone for Coalesce<I, F>\n    where I: Iterator,\n          I::Item: Clone\n{\n    clone_fields!(iter, f);\n}\n\nimpl<I, F> fmt::Debug for Coalesce<I, F>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(Coalesce, iter);\n}\n\n/// Create a new `Coalesce`.\npub fn coalesce<I, F>(mut iter: I, f: F) -> Coalesce<I, F>\n    where I: Iterator\n{\n    Coalesce {\n        iter: CoalesceCore {\n            last: iter.next(),\n            iter,\n        },\n        f,\n    }\n}\n\nimpl<I, F> Iterator for Coalesce<I, F>\n    where I: Iterator,\n          F: FnMut(I::Item, I::Item) -> Result<I::Item, (I::Item, I::Item)>\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next_with(&mut self.f)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\n/// An iterator adaptor that removes repeated duplicates, determining equality using a comparison function.\n///\n/// See [`.dedup_by()`](../trait.Itertools.html#method.dedup_by) or [`.dedup()`](../trait.Itertools.html#method.dedup) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct DedupBy<I, Pred>\n    where I: Iterator\n{\n    iter: CoalesceCore<I, I::Item>,\n    dedup_pred: Pred,\n}\n\npub trait DedupPredicate<T> { // TODO replace by Fn(&T, &T)->bool once Rust supports it\n    fn dedup_pair(&mut self, a: &T, b: &T) -> bool;\n}\n\n#[derive(Clone)]\npub struct DedupEq;\n\nimpl<T: PartialEq> DedupPredicate<T> for DedupEq {\n    fn dedup_pair(&mut self, a: &T, b: &T) -> bool {\n        a == b\n    }\n}\n\nimpl<T, F: FnMut(&T, &T)->bool> DedupPredicate<T> for F {\n    fn dedup_pair(&mut self, a: &T, b: &T) -> bool {\n        self(a, b)\n    }\n}\n\n/// An iterator adaptor that removes repeated duplicates.\n///\n/// See [`.dedup()`](../trait.Itertools.html#method.dedup) for more information.\npub type Dedup<I>=DedupBy<I, DedupEq>;\n\nimpl<I: Clone, Pred: Clone> Clone for DedupBy<I, Pred>\n    where I: Iterator,\n          I::Item: Clone,\n{\n    clone_fields!(iter, dedup_pred);\n}\n\n/// Create a new `DedupBy`.\npub fn dedup_by<I, Pred>(mut iter: I, dedup_pred: Pred) -> DedupBy<I, Pred>\n    where I: Iterator,\n{\n    DedupBy {\n        iter: CoalesceCore {\n            last: iter.next(),\n            iter,\n        },\n        dedup_pred,\n    }\n}\n\n/// Create a new `Dedup`.\npub fn dedup<I>(iter: I) -> Dedup<I>\n    where I: Iterator\n{\n    dedup_by(iter, DedupEq)\n}\n\nimpl<I, Pred> fmt::Debug for DedupBy<I, Pred>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(Dedup, iter);\n}\n\nimpl<I, Pred> Iterator for DedupBy<I, Pred>\n    where I: Iterator,\n          Pred: DedupPredicate<I::Item>,\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let ref mut dedup_pred = self.dedup_pred;\n        self.iter.next_with(|x, y| {\n            if dedup_pred.dedup_pair(&x, &y) { Ok(x) } else { Err((x, y)) }\n        })\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn fold<Acc, G>(self, mut accum: Acc, mut f: G) -> Acc\n        where G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        if let Some(mut last) = self.iter.last {\n            let mut dedup_pred = self.dedup_pred;\n            accum = self.iter.iter.fold(accum, |acc, elt| {\n                if dedup_pred.dedup_pair(&elt, &last) {\n                    acc\n                } else {\n                    f(acc, replace(&mut last, elt))\n                }\n            });\n            f(accum, last)\n        } else {\n            accum\n        }\n    }\n}\n\n/// An iterator adaptor that removes repeated duplicates, while keeping a count of how many\n/// repeated elements were present. This will determine equality using a comparison function.\n///\n/// See [`.dedup_by_with_count()`](../trait.Itertools.html#method.dedup_by_with_count) or\n/// [`.dedup_with_count()`](../trait.Itertools.html#method.dedup_with_count) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct DedupByWithCount<I, Pred>\n    where I: Iterator\n{\n    iter: CoalesceCore<I, (usize, I::Item)>,\n    dedup_pred: Pred,\n}\n\n/// An iterator adaptor that removes repeated duplicates, while keeping a count of how many\n/// repeated elements were present.\n///\n/// See [`.dedup_with_count()`](../trait.Itertools.html#method.dedup_with_count) for more information.\npub type DedupWithCount<I> = DedupByWithCount<I, DedupEq>;\n\n/// Create a new `DedupByWithCount`.\npub fn dedup_by_with_count<I, Pred>(mut iter: I, dedup_pred: Pred) -> DedupByWithCount<I, Pred>\n    where I: Iterator,\n{\n    DedupByWithCount {\n        iter: CoalesceCore {\n            last: iter.next().map(|v| (1, v)),\n            iter,\n        },\n        dedup_pred,\n    }\n}\n\n/// Create a new `DedupWithCount`.\npub fn dedup_with_count<I>(iter: I) -> DedupWithCount<I>\n    where I: Iterator\n{\n    dedup_by_with_count(iter, DedupEq)\n}\n\nimpl<I, Pred> fmt::Debug for DedupByWithCount<I, Pred>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(Dedup, iter);\n}\n\nimpl<I: Clone, Pred: Clone> Clone for DedupByWithCount<I, Pred>\n    where I: Iterator,\n          I::Item: Clone,\n{\n    clone_fields!(iter, dedup_pred);\n}\n\nimpl<I, Pred> Iterator for DedupByWithCount<I, Pred>\n    where I: Iterator,\n          Pred: DedupPredicate<I::Item>,\n{\n    type Item = (usize, I::Item);\n\n    fn next(&mut self) -> Option<(usize, I::Item)> {\n        let ref mut dedup_pred = self.dedup_pred;\n        self.iter.next_with(|(c, x), y| {\n            if dedup_pred.dedup_pair(&x, &y) { Ok((c + 1, x)) } else { Err(((c, x), (1, y))) }\n        })\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\nimpl<I: Iterator, Pred: DedupPredicate<I::Item>> FusedIterator for DedupByWithCount<I, Pred> {}\n\n/// An iterator adaptor that borrows from a `Clone`-able iterator\n/// to only pick off elements while the predicate returns `true`.\n///\n/// See [`.take_while_ref()`](../trait.Itertools.html#method.take_while_ref) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct TakeWhileRef<'a, I: 'a, F> {\n    iter: &'a mut I,\n    f: F,\n}\n\nimpl<'a, I, F> fmt::Debug for TakeWhileRef<'a, I, F>\n    where I: Iterator + fmt::Debug,\n{\n    debug_fmt_fields!(TakeWhileRef, iter);\n}\n\n/// Create a new `TakeWhileRef` from a reference to clonable iterator.\npub fn take_while_ref<I, F>(iter: &mut I, f: F) -> TakeWhileRef<I, F>\n    where I: Iterator + Clone\n{\n    TakeWhileRef { iter, f }\n}\n\nimpl<'a, I, F> Iterator for TakeWhileRef<'a, I, F>\n    where I: Iterator + Clone,\n          F: FnMut(&I::Item) -> bool\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let old = self.iter.clone();\n        match self.iter.next() {\n            None => None,\n            Some(elt) => {\n                if (self.f)(&elt) {\n                    Some(elt)\n                } else {\n                    *self.iter = old;\n                    None\n                }\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, hi) = self.iter.size_hint();\n        (0, hi)\n    }\n}\n\n/// An iterator adaptor that filters `Option<A>` iterator elements\n/// and produces `A`. Stops on the first `None` encountered.\n///\n/// See [`.while_some()`](../trait.Itertools.html#method.while_some) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct WhileSome<I> {\n    iter: I,\n}\n\n/// Create a new `WhileSome<I>`.\npub fn while_some<I>(iter: I) -> WhileSome<I> {\n    WhileSome { iter }\n}\n\nimpl<I, A> Iterator for WhileSome<I>\n    where I: Iterator<Item = Option<A>>\n{\n    type Item = A;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.iter.next() {\n            None | Some(None) => None,\n            Some(elt) => elt,\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let sh = self.iter.size_hint();\n        (0, sh.1)\n    }\n}\n\n/// An iterator to iterate through all combinations in a `Clone`-able iterator that produces tuples\n/// of a specific size.\n///\n/// See [`.tuple_combinations()`](../trait.Itertools.html#method.tuple_combinations) for more\n/// information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct TupleCombinations<I, T>\n    where I: Iterator,\n          T: HasCombination<I>\n{\n    iter: T::Combination,\n    _mi: PhantomData<I>,\n    _mt: PhantomData<T>\n}\n\npub trait HasCombination<I>: Sized {\n    type Combination: From<I> + Iterator<Item = Self>;\n}\n\n/// Create a new `TupleCombinations` from a clonable iterator.\npub fn tuple_combinations<T, I>(iter: I) -> TupleCombinations<I, T>\n    where I: Iterator + Clone,\n          I::Item: Clone,\n          T: HasCombination<I>,\n{\n    TupleCombinations {\n        iter: T::Combination::from(iter),\n        _mi: PhantomData,\n        _mt: PhantomData,\n    }\n}\n\nimpl<I, T> Iterator for TupleCombinations<I, T>\n    where I: Iterator,\n          T: HasCombination<I>,\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next()\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct Tuple1Combination<I> {\n    iter: I,\n}\n\nimpl<I> From<I> for Tuple1Combination<I> {\n    fn from(iter: I) -> Self {\n        Tuple1Combination { iter }\n    }\n}\n\nimpl<I: Iterator> Iterator for Tuple1Combination<I> {\n    type Item = (I::Item,);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(|x| (x,))\n    }\n}\n\nimpl<I: Iterator> HasCombination<I> for (I::Item,) {\n    type Combination = Tuple1Combination<I>;\n}\n\nmacro_rules! impl_tuple_combination {\n    ($C:ident $P:ident ; $A:ident, $($I:ident),* ; $($X:ident)*) => (\n        #[derive(Clone, Debug)]\n        pub struct $C<I: Iterator> {\n            item: Option<I::Item>,\n            iter: I,\n            c: $P<I>,\n        }\n\n        impl<I: Iterator + Clone> From<I> for $C<I> {\n            fn from(mut iter: I) -> Self {\n                $C {\n                    item: iter.next(),\n                    iter: iter.clone(),\n                    c: $P::from(iter),\n                }\n            }\n        }\n\n        impl<I: Iterator + Clone> From<I> for $C<Fuse<I>> {\n            fn from(iter: I) -> Self {\n                let mut iter = iter.fuse();\n                $C {\n                    item: iter.next(),\n                    iter: iter.clone(),\n                    c: $P::from(iter),\n                }\n            }\n        }\n\n        impl<I, $A> Iterator for $C<I>\n            where I: Iterator<Item = $A> + Clone,\n                  I::Item: Clone\n        {\n            type Item = ($($I),*);\n\n            fn next(&mut self) -> Option<Self::Item> {\n                if let Some(($($X),*,)) = self.c.next() {\n                    let z = self.item.clone().unwrap();\n                    Some((z, $($X),*))\n                } else {\n                    self.item = self.iter.next();\n                    self.item.clone().and_then(|z| {\n                        self.c = $P::from(self.iter.clone());\n                        self.c.next().map(|($($X),*,)| (z, $($X),*))\n                    })\n                }\n            }\n        }\n\n        impl<I, $A> HasCombination<I> for ($($I),*)\n            where I: Iterator<Item = $A> + Clone,\n                  I::Item: Clone\n        {\n            type Combination = $C<Fuse<I>>;\n        }\n    )\n}\n\nimpl_tuple_combination!(Tuple2Combination Tuple1Combination ; A, A, A ; a);\nimpl_tuple_combination!(Tuple3Combination Tuple2Combination ; A, A, A, A ; a b);\nimpl_tuple_combination!(Tuple4Combination Tuple3Combination ; A, A, A, A, A; a b c);\n\n/// An iterator adapter to apply `Into` conversion to each element.\n///\n/// See [`.map_into()`](../trait.Itertools.html#method.map_into) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MapInto<I, R> {\n    iter: I,\n    _res: PhantomData<R>,\n}\n\n/// Create a new [`MapInto`](struct.MapInto.html) iterator.\npub fn map_into<I, R>(iter: I) -> MapInto<I, R> {\n    MapInto {\n        iter,\n        _res: PhantomData,\n    }\n}\n\nimpl<I, R> Iterator for MapInto<I, R>\n    where I: Iterator,\n          I::Item: Into<R>,\n{\n    type Item = R;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter\n            .next()\n            .map(|i| i.into())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn fold<Acc, Fold>(self, init: Acc, mut fold_f: Fold) -> Acc\n        where Fold: FnMut(Acc, Self::Item) -> Acc,\n    {\n        self.iter.fold(init, move |acc, v| fold_f(acc, v.into()))\n    }\n}\n\nimpl<I, R> DoubleEndedIterator for MapInto<I, R>\n    where I: DoubleEndedIterator,\n          I::Item: Into<R>,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.iter\n            .next_back()\n            .map(|i| i.into())\n    }\n}\n\nimpl<I, R> ExactSizeIterator for MapInto<I, R>\nwhere\n    I: ExactSizeIterator,\n    I::Item: Into<R>,\n{}\n\n/// An iterator adapter to apply a transformation within a nested `Result`.\n///\n/// See [`.map_results()`](../trait.Itertools.html#method.map_results) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MapResults<I, F> {\n    iter: I,\n    f: F\n}\n\n/// Create a new `MapResults` iterator.\npub fn map_results<I, F, T, U, E>(iter: I, f: F) -> MapResults<I, F>\n    where I: Iterator<Item = Result<T, E>>,\n          F: FnMut(T) -> U,\n{\n    MapResults {\n        iter,\n        f,\n    }\n}\n\nimpl<I, F, T, U, E> Iterator for MapResults<I, F>\n    where I: Iterator<Item = Result<T, E>>,\n          F: FnMut(T) -> U,\n{\n    type Item = Result<U, E>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(|v| v.map(&mut self.f))\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn fold<Acc, Fold>(self, init: Acc, mut fold_f: Fold) -> Acc\n        where Fold: FnMut(Acc, Self::Item) -> Acc,\n    {\n        let mut f = self.f;\n        self.iter.fold(init, move |acc, v| fold_f(acc, v.map(&mut f)))\n    }\n\n    fn collect<C>(self) -> C\n        where C: FromIterator<Self::Item>\n    {\n        let mut f = self.f;\n        self.iter.map(move |v| v.map(&mut f)).collect()\n    }\n}\n\n/// An iterator adapter to get the positions of each element that matches a predicate.\n///\n/// See [`.positions()`](../trait.Itertools.html#method.positions) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Positions<I, F> {\n    iter: I,\n    f: F,\n    count: usize,\n}\n\n/// Create a new `Positions` iterator.\npub fn positions<I, F>(iter: I, f: F) -> Positions<I, F>\n    where I: Iterator,\n          F: FnMut(I::Item) -> bool,\n{\n    Positions {\n        iter,\n        f,\n        count: 0\n    }\n}\n\nimpl<I, F> Iterator for Positions<I, F>\n    where I: Iterator,\n          F: FnMut(I::Item) -> bool,\n{\n    type Item = usize;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        while let Some(v) = self.iter.next() {\n            let i = self.count;\n            self.count = i + 1;\n            if (self.f)(v) {\n                return Some(i);\n            }\n        }\n        None\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (0, self.iter.size_hint().1)\n    }\n}\n\nimpl<I, F> DoubleEndedIterator for Positions<I, F>\n    where I: DoubleEndedIterator + ExactSizeIterator,\n          F: FnMut(I::Item) -> bool,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        while let Some(v) = self.iter.next_back() {\n            if (self.f)(v) {\n                return Some(self.count + self.iter.len())\n            }\n        }\n        None\n    }\n}\n\n/// An iterator adapter to apply a mutating function to each element before yielding it.\n///\n/// See [`.update()`](../trait.Itertools.html#method.update) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Update<I, F> {\n    iter: I,\n    f: F,\n}\n\n/// Create a new `Update` iterator.\npub fn update<I, F>(iter: I, f: F) -> Update<I, F>\nwhere\n    I: Iterator,\n    F: FnMut(&mut I::Item),\n{\n    Update { iter, f }\n}\n\nimpl<I, F> Iterator for Update<I, F>\nwhere\n    I: Iterator,\n    F: FnMut(&mut I::Item),\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if let Some(mut v) = self.iter.next() {\n            (self.f)(&mut v);\n            Some(v)\n        } else {\n            None\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn fold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n        where G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        let mut f = self.f;\n        self.iter.fold(init, move |acc, mut v| { f(&mut v); g(acc, v) })\n    }\n\n    // if possible, re-use inner iterator specializations in collect\n    fn collect<C>(self) -> C\n        where C: FromIterator<Self::Item>\n    {\n        let mut f = self.f;\n        self.iter.map(move |mut v| { f(&mut v); v }).collect()\n    }\n}\n\nimpl<I, F> ExactSizeIterator for Update<I, F>\nwhere\n    I: ExactSizeIterator,\n    F: FnMut(&mut I::Item),\n{}\n\nimpl<I, F> DoubleEndedIterator for Update<I, F>\nwhere\n    I: DoubleEndedIterator,\n    F: FnMut(&mut I::Item),\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        if let Some(mut v) = self.iter.next_back() {\n            (self.f)(&mut v);\n            Some(v)\n        } else {\n            None\n        }\n    }\n}\n","traces":[{"line":42,"address":[4335292,4335184],"length":1,"stats":{"Line":3},"fn_name":"interleave<core::slice::Iter<u8>,core::slice::Iter<u8>>"},{"line":47,"address":[4335214],"length":1,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[4335307,4335357],"length":1,"stats":{"Line":6},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[4785392,4785504,4785616],"length":1,"stats":{"Line":5},"fn_name":"interleave_shortest<core::iter::sources::Repeat<i32>,alloc::vec::IntoIter<i32>>"},{"line":116,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":185,"address":[4209778,4209680],"length":1,"stats":{"Line":13},"fn_name":"put_back<core::ops::range::Range<i32>>"},{"line":190,"address":[4209703],"length":1,"stats":{"Line":13},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[4336630,4336274,4335952,4336208,4336017,4336560],"length":1,"stats":{"Line":8},"fn_name":"cartesian_product<core::str::Chars,core::ops::range::Range<i32>>"},{"line":306,"address":[4336228,4336587,4335978],"length":1,"stats":{"Line":9},"fn_name":null},{"line":308,"address":[4336348,4336688,4336059],"length":1,"stats":{"Line":8},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":353,"address":[5519055,5518960],"length":1,"stats":{"Line":1},"fn_name":"fold<itertools::adaptors::Product<quick::Iter<u16, quick::Inexact>, quick::Iter<u16, quick::Inexact>>,quick::Iter<u16, quick::Inexact>,(),closure-0>"},{"line":358,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":394,"address":[4232640],"length":1,"stats":{"Line":2},"fn_name":"batching<core::slice::Iter<core::option::Option<i32>>,closure-0>"},{"line":404,"address":[4232528],"length":1,"stats":{"Line":2},"fn_name":"next<i32,closure-0,core::slice::Iter<core::option::Option<i32>>>"},{"line":405,"address":[4232537],"length":1,"stats":{"Line":2},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[4336910,4336848],"length":1,"stats":{"Line":7},"fn_name":"step<core::ops::range::Range<i32>>"},{"line":438,"address":[4336868],"length":1,"stats":{"Line":7},"fn_name":null},{"line":440,"address":[4336922],"length":1,"stats":{"Line":7},"fn_name":null},{"line":441,"address":[4337077,4336977],"length":1,"stats":{"Line":7},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":511,"address":[4337120],"length":1,"stats":{"Line":3},"fn_name":"merge<itertools::adaptors::Step<core::ops::range::Range<i32>>,itertools::adaptors::Step<core::ops::range::Range<i32>>>"},{"line":516,"address":[4337127],"length":1,"stats":{"Line":3},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":550,"address":[4335504,4335599],"length":1,"stats":{"Line":5},"fn_name":"merge_by_new<itertools::adaptors::Step<core::ops::range::Range<i32>>,itertools::adaptors::Step<core::ops::range::Range<i32>>,itertools::adaptors::MergeLte>"},{"line":556,"address":[4335514],"length":1,"stats":{"Line":5},"fn_name":null},{"line":557,"address":[4335632,4335706],"length":1,"stats":{"Line":10},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":582,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":585,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":589,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":596,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":597,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":599,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":620,"address":[4788494,4785776,4789456,4788432,4787616,4786857,4790480,4790537,4789518,4785838,4786800,4787673],"length":1,"stats":{"Line":11},"fn_name":"next_with<core::slice::Iter<(i32, i32)>,(usize, &(i32, i32)),closure-0>"},{"line":624,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":626,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":628,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":631,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":632,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":641,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":643,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":692,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":693,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":726,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":727,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":744,"address":[4791904,4792094,4791806,4792048,4791662,4791616,4791760,4791950],"length":1,"stats":{"Line":9},"fn_name":"dedup_by<core::slice::Iter<(i32, i32)>,closure-1>"},{"line":748,"address":[4791684,4791828,4792116,4791972],"length":1,"stats":{"Line":9},"fn_name":null},{"line":757,"address":[4791568],"length":1,"stats":{"Line":4},"fn_name":"dedup<core::slice::Iter<i32>>"},{"line":760,"address":[4791585],"length":1,"stats":{"Line":4},"fn_name":null},{"line":776,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":777,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":778,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":779,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":783,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":784,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":787,"address":[4769840,4769914,4770346,4770272],"length":1,"stats":{"Line":2},"fn_name":"fold<core::slice::Iter<i32>,itertools::adaptors::DedupEq,(),closure-0>"},{"line":790,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":791,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":792,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":793,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":794,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":796,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":799,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":801,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":826,"address":[4784672,4784719,4784911,4785103,4784864,4785056],"length":1,"stats":{"Line":3},"fn_name":"dedup_by_with_count<core::slice::Iter<(i32, i32)>,closure-1>"},{"line":830,"address":[4784959,4784767,4785151],"length":1,"stats":{"Line":3},"fn_name":null},{"line":839,"address":[4783680],"length":1,"stats":{"Line":1},"fn_name":"dedup_with_count<core::slice::Iter<i32>>"},{"line":842,"address":[4783697],"length":1,"stats":{"Line":1},"fn_name":null},{"line":865,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":866,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":867,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":868,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":872,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":873,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":896,"address":[5538608],"length":1,"stats":{"Line":1},"fn_name":"take_while_ref<core::slice::Iter<u8>,closure-0>"},{"line":908,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":909,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":910,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":911,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":912,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":913,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":914,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":916,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":917,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":923,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":924,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":925,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":940,"address":[4782016],"length":1,"stats":{"Line":2},"fn_name":"while_some<core::iter::adapters::Map<core::ops::range::Range<i32>, closure-0>>"},{"line":949,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":950,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":951,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":952,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":956,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":957,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":958,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":983,"address":[4784576],"length":1,"stats":{"Line":3},"fn_name":"tuple_combinations<(i32, i32),core::ops::range::Range<i32>>"},{"line":989,"address":[4784591],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1001,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1002,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1012,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1020,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1021,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1049,"address":[4780005,4779952],"length":1,"stats":{"Line":3},"fn_name":"from<core::ops::range::Range<i32>>"},{"line":1050,"address":[4779967,4780017],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1052,"address":[4780027],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1053,"address":[4780067],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1054,"address":[4780074],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1065,"address":[4773216,4773275],"length":1,"stats":{"Line":3},"fn_name":"next<core::iter::adapters::Fuse<core::ops::range::Range<i32>>,i32>"},{"line":1066,"address":[4773432,4773490,4773326,4773228,4773287],"length":1,"stats":{"Line":15},"fn_name":null},{"line":1067,"address":[4773339,4773387],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1068,"address":[4773391],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1070,"address":[4773299,4773437,4773532],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1071,"address":[4773714,4773648,4773443,4773550],"length":1,"stats":{"Line":9},"fn_name":"{{closure}}<core::iter::adapters::Fuse<core::ops::range::Range<i32>>,i32>"},{"line":1072,"address":[4773664,4773736,4773823],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1073,"address":[4773847,4773749,4773904,4773915],"length":1,"stats":{"Line":10},"fn_name":"{{closure}}<core::iter::adapters::Fuse<core::ops::range::Range<i32>>,i32>"},{"line":1116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":235,"coverable":306},{"path":["/","home","kms","itertools","src","adaptors","multi_product.rs"],"content":"#![cfg(feature = \"use_std\")]\n\nuse crate::size_hint;\nuse crate::Itertools;\n\n#[derive(Clone)]\n/// An iterator adaptor that iterates over the cartesian product of\n/// multiple iterators of type `I`.\n///\n/// An iterator element type is `Vec<I>`.\n///\n/// See [`.multi_cartesian_product()`](../trait.Itertools.html#method.multi_cartesian_product)\n/// for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MultiProduct<I>(Vec<MultiProductIter<I>>)\n    where I: Iterator + Clone,\n          I::Item: Clone;\n\n/// Create a new cartesian product iterator over an arbitrary number\n/// of iterators of the same type.\n///\n/// Iterator element is of type `Vec<H::Item::Item>`.\npub fn multi_cartesian_product<H>(iters: H) -> MultiProduct<<H::Item as IntoIterator>::IntoIter>\n    where H: Iterator,\n          H::Item: IntoIterator,\n          <H::Item as IntoIterator>::IntoIter: Clone,\n          <H::Item as IntoIterator>::Item: Clone\n{\n    MultiProduct(iters.map(|i| MultiProductIter::new(i.into_iter())).collect())\n}\n\n#[derive(Clone, Debug)]\n/// Holds the state of a single iterator within a MultiProduct.\nstruct MultiProductIter<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    cur: Option<I::Item>,\n    iter: I,\n    iter_orig: I,\n}\n\n/// Holds the current state during an iteration of a MultiProduct.\n#[derive(Debug)]\nenum MultiProductIterState {\n    StartOfIter,\n    MidIter { on_first_iter: bool },\n}\n\nimpl<I> MultiProduct<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    /// Iterates the rightmost iterator, then recursively iterates iterators\n    /// to the left if necessary.\n    ///\n    /// Returns true if the iteration succeeded, else false.\n    fn iterate_last(\n        multi_iters: &mut [MultiProductIter<I>],\n        mut state: MultiProductIterState\n    ) -> bool {\n        use self::MultiProductIterState::*;\n\n        if let Some((last, rest)) = multi_iters.split_last_mut() {\n            let on_first_iter = match state {\n                StartOfIter => {\n                    let on_first_iter = !last.in_progress();\n                    state = MidIter { on_first_iter };\n                    on_first_iter\n                },\n                MidIter { on_first_iter } => on_first_iter\n            };\n\n            if !on_first_iter {\n                last.iterate();\n            }\n\n            if last.in_progress() {\n                true\n            } else if MultiProduct::iterate_last(rest, state) {\n                last.reset();\n                last.iterate();\n                // If iterator is None twice consecutively, then iterator is\n                // empty; whole product is empty.\n                last.in_progress()\n            } else {\n                false\n            }\n        } else {\n            // Reached end of iterator list. On initialisation, return true.\n            // At end of iteration (final iterator finishes), finish.\n            match state {\n                StartOfIter => false,\n                MidIter { on_first_iter } => on_first_iter\n            }\n        }\n    }\n\n    /// Returns the unwrapped value of the next iteration.\n    fn curr_iterator(&self) -> Vec<I::Item> {\n        self.0.iter().map(|multi_iter| {\n            multi_iter.cur.clone().unwrap()\n        }).collect()\n    }\n\n    /// Returns true if iteration has started and has not yet finished; false\n    /// otherwise.\n    fn in_progress(&self) -> bool {\n        if let Some(last) = self.0.last() {\n            last.in_progress()\n        } else {\n            false\n        }\n    }\n}\n\nimpl<I> MultiProductIter<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    fn new(iter: I) -> Self {\n        MultiProductIter {\n            cur: None,\n            iter: iter.clone(),\n            iter_orig: iter\n        }\n    }\n\n    /// Iterate the managed iterator.\n    fn iterate(&mut self) {\n        self.cur = self.iter.next();\n    }\n\n    /// Reset the managed iterator.\n    fn reset(&mut self) {\n        self.iter = self.iter_orig.clone();\n    }\n\n    /// Returns true if the current iterator has been started and has not yet\n    /// finished; false otherwise.\n    fn in_progress(&self) -> bool {\n        self.cur.is_some()\n    }\n}\n\nimpl<I> Iterator for MultiProduct<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    type Item = Vec<I::Item>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if MultiProduct::iterate_last(\n            &mut self.0,\n            MultiProductIterState::StartOfIter\n        ) {\n            Some(self.curr_iterator())\n        } else {\n            None\n        }\n    }\n\n    fn count(self) -> usize {\n        if self.0.len() == 0 {\n            return 0;\n        }\n\n        if !self.in_progress() {\n            return self.0.into_iter().fold(1, |acc, multi_iter| {\n                acc * multi_iter.iter.count()\n            });\n        }\n\n        self.0.into_iter().fold(\n            0,\n            |acc, MultiProductIter { iter, iter_orig, cur: _ }| {\n                let total_count = iter_orig.count();\n                let cur_count = iter.count();\n                acc * total_count + cur_count\n            }\n        )\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // Not ExactSizeIterator because size may be larger than usize\n        if self.0.len() == 0 {\n            return (0, Some(0));\n        }\n\n        if !self.in_progress() {\n            return self.0.iter().fold((1, Some(1)), |acc, multi_iter| {\n                size_hint::mul(acc, multi_iter.iter.size_hint())\n            });\n        }\n\n        self.0.iter().fold(\n            (0, Some(0)),\n            |acc, &MultiProductIter { ref iter, ref iter_orig, cur: _ }| {\n                let cur_size = iter.size_hint();\n                let total_size = iter_orig.size_hint();\n                size_hint::add(size_hint::mul(acc, total_size), cur_size)\n            }\n        )\n    }\n\n    fn last(self) -> Option<Self::Item> {\n        let iter_count = self.0.len();\n\n        let lasts: Self::Item = self.0.into_iter()\n            .map(|multi_iter| multi_iter.iter.last())\n            .while_some()\n            .collect();\n\n        if lasts.len() == iter_count {\n            Some(lasts)\n        } else {\n            None\n        }\n    }\n}\n","traces":[{"line":23,"address":[4751472],"length":1,"stats":{"Line":1},"fn_name":"multi_cartesian_product<quick::ShiftRange<quick::Inexact>>"},{"line":29,"address":[4751612,4751482,4751600],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}<quick::ShiftRange<quick::Inexact>>"},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":61,"coverable":73},{"path":["/","home","kms","itertools","src","combinations.rs"],"content":"use std::fmt;\n\nuse super::lazy_buffer::LazyBuffer;\n\n/// An iterator to iterate through all the `k`-length combinations in an iterator.\n///\n/// See [`.combinations()`](../trait.Itertools.html#method.combinations) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Combinations<I: Iterator> {\n    indices: Vec<usize>,\n    pool: LazyBuffer<I>,\n    first: bool,\n}\n\nimpl<I> Clone for Combinations<I>\n    where I: Clone + Iterator,\n          I::Item: Clone,\n{\n    clone_fields!(indices, pool, first);\n}\n\nimpl<I> fmt::Debug for Combinations<I>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(Combinations, indices, pool, first);\n}\n\n/// Create a new `Combinations` from a clonable iterator.\npub fn combinations<I>(iter: I, k: usize) -> Combinations<I>\n    where I: Iterator\n{\n    let mut pool: LazyBuffer<I> = LazyBuffer::new(iter);\n\n    for _ in 0..k {\n        if !pool.get_next() {\n            break;\n        }\n    }\n\n    Combinations {\n        indices: (0..k).collect(),\n        pool,\n        first: true,\n    }\n}\n\nimpl<I> Iterator for Combinations<I>\n    where I: Iterator,\n          I::Item: Clone\n{\n    type Item = Vec<I::Item>;\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.first {\n            if self.pool.is_done() {\n                return None;\n            }\n            self.first = false;\n        } else if self.indices.len() == 0 {\n            return None;\n        } else {\n            // Scan from the end, looking for an index to increment\n            let mut i: usize = self.indices.len() - 1;\n\n            // Check if we need to consume more from the iterator\n            if self.indices[i] == self.pool.len() - 1 {\n                self.pool.get_next(); // may change pool size\n            }\n\n            while self.indices[i] == i + self.pool.len() - self.indices.len() {\n                if i > 0 {\n                    i -= 1;\n                } else {\n                    // Reached the last combination\n                    return None;\n                }\n            }\n\n            // Increment index, and reset the ones to its right\n            self.indices[i] += 1;\n            for j in i+1..self.indices.len() {\n                self.indices[j] = self.indices[j - 1] + 1;\n            }\n        }\n\n        // Create result vector based on the indices\n        Some(self.indices.iter().map(|i| self.pool[*i].clone()).collect())\n    }\n}\n","traces":[{"line":30,"address":[4209888,4209948],"length":1,"stats":{"Line":3},"fn_name":"combinations<adaptors_no_collect::PanickingCounter>"},{"line":33,"address":[4209913],"length":1,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[4209963,4210065,4210259],"length":1,"stats":{"Line":10},"fn_name":null},{"line":36,"address":[4210178,4210253],"length":1,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[4210264],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[4210189],"length":1,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":54,"address":[4208034,4208145,4209027],"length":1,"stats":{"Line":8},"fn_name":null},{"line":55,"address":[4208091],"length":1,"stats":{"Line":3},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[4208431],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":6},"fn_name":null}],"covered":24,"coverable":24},{"path":["/","home","kms","itertools","src","combinations_with_replacement.rs"],"content":"use std::fmt;\n\nuse super::lazy_buffer::LazyBuffer;\n\n/// An iterator to iterate through all the `n`-length combinations in an iterator, with replacement.\n///\n/// See [`.combinations_with_replacement()`](../trait.Itertools.html#method.combinations_with_replacement) for more information.\n#[derive(Clone)]\npub struct CombinationsWithReplacement<I>\nwhere\n    I: Iterator,\n    I::Item: Clone,\n{\n    k: usize,\n    indices: Vec<usize>,\n    // The current known max index value. This increases as pool grows.\n    max_index: usize,\n    pool: LazyBuffer<I>,\n    first: bool,\n}\n\nimpl<I> fmt::Debug for CombinationsWithReplacement<I>\nwhere\n    I: Iterator + fmt::Debug,\n    I::Item: fmt::Debug + Clone,\n{\n    debug_fmt_fields!(Combinations, k, indices, max_index, pool, first);\n}\n\nimpl<I> CombinationsWithReplacement<I>\nwhere\n    I: Iterator,\n    I::Item: Clone,\n{\n    /// Map the current mask over the pool to get an output combination\n    fn current(&self) -> Vec<I::Item> {\n        self.indices.iter().map(|i| self.pool[*i].clone()).collect()\n    }\n}\n\n/// Create a new `CombinationsWithReplacement` from a clonable iterator.\npub fn combinations_with_replacement<I>(iter: I, k: usize) -> CombinationsWithReplacement<I>\nwhere\n    I: Iterator,\n    I::Item: Clone,\n{\n    let indices: Vec<usize> = vec![0; k];\n    let pool: LazyBuffer<I> = LazyBuffer::new(iter);\n\n    CombinationsWithReplacement {\n        k,\n        indices,\n        max_index: 0,\n        pool,\n        first: true,\n    }\n}\n\nimpl<I> Iterator for CombinationsWithReplacement<I>\nwhere\n    I: Iterator,\n    I::Item: Clone,\n{\n    type Item = Vec<I::Item>;\n    fn next(&mut self) -> Option<Self::Item> {\n        // If this is the first iteration, return early\n        if self.first {\n            // In empty edge cases, stop iterating immediately\n            return if self.k != 0 && !self.pool.get_next() {\n                None\n            // Otherwise, yield the initial state\n            } else {\n                self.first = false;\n                Some(self.current())\n            };\n        }\n\n        // Check if we need to consume more from the iterator\n        // This will run while we increment our first index digit\n        if self.pool.get_next() {\n            self.max_index = self.pool.len() - 1;\n        }\n\n        // Work out where we need to update our indices\n        let mut increment: Option<(usize, usize)> = None;\n        for (i, indices_int) in self.indices.iter().enumerate().rev() {\n            if indices_int < &self.max_index {\n                increment = Some((i, indices_int + 1));\n                break;\n            }\n        }\n\n        match increment {\n            // If we can update the indices further\n            Some((increment_from, increment_value)) => {\n                // We need to update the rightmost non-max value\n                // and all those to the right\n                for indices_index in increment_from..self.indices.len() {\n                    self.indices[indices_index] = increment_value\n                }\n                Some(self.current())\n            }\n            // Otherwise, we're done\n            None => None,\n        }\n    }\n}\n","traces":[{"line":36,"address":[4249376],"length":1,"stats":{"Line":2},"fn_name":"current<adaptors_no_collect::PanickingCounter>"},{"line":37,"address":[4249388,4249534,4249520],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}<adaptors_no_collect::PanickingCounter>"},{"line":42,"address":[4249053,4248976],"length":1,"stats":{"Line":2},"fn_name":"combinations_with_replacement<adaptors_no_collect::PanickingCounter>"},{"line":47,"address":[4249001],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[4249068],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[4247408],"length":1,"stats":{"Line":2},"fn_name":"next<adaptors_no_collect::PanickingCounter>"},{"line":67,"address":[4247426],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[4247695,4247490,4247650,4247522],"length":1,"stats":{"Line":6},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[4248823,4247713,4248793],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":87,"address":[4248204,4248127],"length":1,"stats":{"Line":4},"fn_name":null},{"line":88,"address":[4248215],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[4248369],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":24,"coverable":24},{"path":["/","home","kms","itertools","src","concat_impl.rs"],"content":"use crate::Itertools;\n\n/// Combine all an iterator's elements into one element by using `Extend`.\n///\n/// `IntoIterator`-enabled version of `.concat()`\n///\n/// This combinator will extend the first item with each of the rest of the\n/// items of the iterator. If the iterator is empty, the default value of\n/// `I::Item` is returned.\n///\n/// ```rust\n/// use itertools::concat;\n/// \n/// let input = vec![vec![1], vec![2, 3], vec![4, 5, 6]];\n/// assert_eq!(concat(input), vec![1, 2, 3, 4, 5, 6]);\n/// ```\npub fn concat<I>(iterable: I) -> I::Item\n    where I: IntoIterator,\n          I::Item: Extend<<<I as IntoIterator>::Item as IntoIterator>::Item> + IntoIterator + Default\n{\n    iterable.into_iter().fold1(|mut a, b| { a.extend(b); a }).unwrap_or_else(|| <_>::default())\n}\n","traces":[{"line":17,"address":[4858528,4858416],"length":1,"stats":{"Line":2},"fn_name":"concat<alloc::vec::IntoIter<alloc::vec::Vec<i32>>>"},{"line":21,"address":[4858972,4858423,4858672,4858535,4858684,4858816,4858640,4858828,4858960,4858652],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}<alloc::vec::IntoIter<alloc::vec::Vec<i32>>>"}],"covered":2,"coverable":2},{"path":["/","home","kms","itertools","src","cons_tuples_impl.rs"],"content":"\nmacro_rules! impl_cons_iter(\n    ($_A:ident, $_B:ident, ) => (); // stop\n\n    ($A:ident, $($B:ident,)*) => (\n        impl_cons_iter!($($B,)*);\n        #[allow(non_snake_case)]\n        impl<X, Iter, $($B),*> Iterator for ConsTuples<Iter, (($($B,)*), X)>\n            where Iter: Iterator<Item = (($($B,)*), X)>,\n        {\n            type Item = ($($B,)* X, );\n            fn next(&mut self) -> Option<Self::Item> {\n                self.iter.next().map(|(($($B,)*), x)| ($($B,)* x, ))\n            }\n\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.iter.size_hint()\n            }\n            fn fold<Acc, Fold>(self, accum: Acc, mut f: Fold) -> Acc\n                where Fold: FnMut(Acc, Self::Item) -> Acc,\n            {\n                self.iter.fold(accum, move |acc, (($($B,)*), x)| f(acc, ($($B,)* x, )))\n            }\n        }\n\n        #[allow(non_snake_case)]\n        impl<X, Iter, $($B),*> DoubleEndedIterator for ConsTuples<Iter, (($($B,)*), X)>\n            where Iter: DoubleEndedIterator<Item = (($($B,)*), X)>,\n        {\n            fn next_back(&mut self) -> Option<Self::Item> {\n                self.iter.next().map(|(($($B,)*), x)| ($($B,)* x, ))\n            }\n        }\n\n    );\n);\n\nimpl_cons_iter!(A, B, C, D, E, F, G, H,);\n\n/// An iterator that maps an iterator of tuples like\n/// `((A, B), C)` to an iterator of `(A, B, C)`.\n///\n/// Used by the `iproduct!()` macro.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Debug)]\npub struct ConsTuples<I, J>\n    where I: Iterator<Item=J>,\n{\n    iter: I,\n}\n\nimpl<I, J> Clone for ConsTuples<I, J>\n    where I: Clone + Iterator<Item=J>,\n{\n    clone_fields!(iter);\n}\n\n/// Create an iterator that maps for example iterators of\n/// `((A, B), C)` to `(A, B, C)`.\npub fn cons_tuples<I, J>(iterable: I) -> ConsTuples<I, J>\n    where I: Iterator<Item=J>\n{\n    ConsTuples { iter: iterable.into_iter() }\n}\n","traces":[{"line":12,"address":[4222416],"length":1,"stats":{"Line":4},"fn_name":"next<i32,itertools::adaptors::Product<itertools::adaptors::Product<core::iter::adapters::Cloned<core::slice::Iter<i32>>, core::iter::adapters::Cloned<core::slice::Iter<i32>>>, core::iter::adapters::Cloned<core::slice::Iter<i32>>>,i32,i32>"},{"line":13,"address":[4222503,4222428,4222496],"length":1,"stats":{"Line":12},"fn_name":"{{closure}}<i32,itertools::adaptors::Product<itertools::adaptors::Product<core::iter::adapters::Cloned<core::slice::Iter<i32>>, core::iter::adapters::Cloned<core::slice::Iter<i32>>>, core::iter::adapters::Cloned<core::slice::Iter<i32>>>,i32,i32>"},{"line":16,"address":[4684112],"length":1,"stats":{"Line":2},"fn_name":"size_hint<i32,itertools::adaptors::Product<itertools::adaptors::Product<core::ops::range::Range<i32>, core::ops::range::Range<i32>>, core::ops::range::Range<i32>>,i32,i32>"},{"line":17,"address":[4684124],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[5051872],"length":1,"stats":{"Line":1},"fn_name":"fold<u16,itertools::adaptors::Product<itertools::adaptors::Product<quick::Iter<u16, quick::Inexact>, quick::Iter<u16, quick::Inexact>>, quick::Iter<u16, quick::Inexact>>,u16,u16,(),closure-1>"},{"line":22,"address":[5052009,5051968,5051884],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}<u16,itertools::adaptors::Product<itertools::adaptors::Product<quick::Iter<u16, quick::Inexact>, quick::Iter<u16, quick::Inexact>>, quick::Iter<u16, quick::Inexact>>,u16,u16,(),closure-1>"},{"line":60,"address":[4222592],"length":1,"stats":{"Line":4},"fn_name":"cons_tuples<itertools::adaptors::Product<itertools::adaptors::Product<core::iter::adapters::Cloned<core::slice::Iter<i32>>, core::iter::adapters::Cloned<core::slice::Iter<i32>>>, core::iter::adapters::Cloned<core::slice::Iter<i32>>>,((i32, i32), i32)>"},{"line":63,"address":[4222602],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":8,"coverable":8},{"path":["/","home","kms","itertools","src","diff.rs"],"content":"//! \"Diff\"ing iterators for caching elements to sequential collections without requiring the new\n//! elements' iterator to be `Clone`.\n//!\n//! - [**Diff**](./enum.Diff.html) (produced by the [**diff_with**](./fn.diff_with.html) function)\n//! describes the difference between two non-`Clone` iterators `I` and `J` after breaking ASAP from\n//! a lock-step comparison.\n\nuse crate::free::put_back;\nuse crate::structs::PutBack;\n\n/// A type returned by the [`diff_with`](./fn.diff_with.html) function.\n///\n/// `Diff` represents the way in which the elements yielded by the iterator `I` differ to some\n/// iterator `J`.\npub enum Diff<I, J>\n    where I: Iterator,\n          J: Iterator\n{\n    /// The index of the first non-matching element along with both iterator's remaining elements\n    /// starting with the first mis-match.\n    FirstMismatch(usize, PutBack<I>, PutBack<J>),\n    /// The total number of elements that were in `J` along with the remaining elements of `I`.\n    Shorter(usize, PutBack<I>),\n    /// The total number of elements that were in `I` along with the remaining elements of `J`.\n    Longer(usize, PutBack<J>),\n}\n\n/// Compares every element yielded by both `i` and `j` with the given function in lock-step and\n/// returns a `Diff` which describes how `j` differs from `i`.\n///\n/// If the number of elements yielded by `j` is less than the number of elements yielded by `i`,\n/// the number of `j` elements yielded will be returned along with `i`'s remaining elements as\n/// `Diff::Shorter`.\n///\n/// If the two elements of a step differ, the index of those elements along with the remaining\n/// elements of both `i` and `j` are returned as `Diff::FirstMismatch`.\n///\n/// If `i` becomes exhausted before `j` becomes exhausted, the number of elements in `i` along with\n/// the remaining `j` elements will be returned as `Diff::Longer`.\npub fn diff_with<I, J, F>(i: I, j: J, is_equal: F)\n    -> Option<Diff<I::IntoIter, J::IntoIter>>\n    where I: IntoIterator,\n          J: IntoIterator,\n          F: Fn(&I::Item, &J::Item) -> bool\n{\n    let mut i = i.into_iter();\n    let mut j = j.into_iter();\n    let mut idx = 0;\n    while let Some(i_elem) = i.next() {\n        match j.next() {\n            None => return Some(Diff::Shorter(idx, put_back(i).with_value(i_elem))),\n            Some(j_elem) => if !is_equal(&i_elem, &j_elem) {\n                let remaining_i = put_back(i).with_value(i_elem);\n                let remaining_j = put_back(j).with_value(j_elem);\n                return Some(Diff::FirstMismatch(idx, remaining_i, remaining_j));\n            },\n        }\n        idx += 1;\n    }\n    j.next().map(|j_elem| Diff::Longer(idx, put_back(j).with_value(j_elem)))\n}\n","traces":[{"line":40,"address":[4760076,4759856,4757996,4757776,4761936,4762156],"length":1,"stats":{"Line":3},"fn_name":"diff_with<core::slice::Iter<i32>,core::iter::adapters::Map<alloc::vec::IntoIter<f64>, closure-0>,closure-1>"},{"line":46,"address":[4757799,4761959,4759879],"length":1,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[4760109,4757937,4760017,4762097,4758029,4762189],"length":1,"stats":{"Line":6},"fn_name":null},{"line":48,"address":[4758037,4762197,4760117],"length":1,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[4762377,4763549,4758057,4759541,4762217,4761743,4761214,4763823,4760297,4763638,4759134,4763701,4761558,4761621,4759478,4759663,4760137,4761469,4763294,4758217,4759389],"length":1,"stats":{"Line":11},"fn_name":null},{"line":50,"address":[4762410,4760227,4758147,4758250,4762307,4760330],"length":1,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[4758252,4762412,4760397,4760332,4762477,4760272,4762352,4758192,4758317],"length":1,"stats":{"Line":5},"fn_name":null},{"line":52,"address":[4762663,4758503,4760583],"length":1,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[4760703,4762783,4758623],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[4758701,4762861,4760781],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[4761141,4762967,4763221,4758807,4759061,4760887],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[4759098,4763950,4761685,4761178,4759790,4759605,4763765,4761870,4763258],"length":1,"stats":{"Line":6},"fn_name":null},{"line":60,"address":[4764286,4759175,4764542,4763335,4764016,4764030,4764272,4761255,4764528],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}<core::slice::Iter<i32>,core::iter::adapters::Map<alloc::vec::IntoIter<f64>, closure-0>,closure-1>"}],"covered":13,"coverable":13},{"path":["/","home","kms","itertools","src","either_or_both.rs"],"content":"use crate::EitherOrBoth::*;\n\nuse either::Either;\n\n/// Value that either holds a single A or B, or both.\n#[derive(Clone, PartialEq, Eq, Hash, Debug)]\npub enum EitherOrBoth<A, B> {\n    /// Both values are present.\n    Both(A, B),\n    /// Only the left value of type `A` is present.\n    Left(A),\n    /// Only the right value of type `B` is present.\n    Right(B),\n}\n\nimpl<A, B> EitherOrBoth<A, B> {\n    /// If `Left`, or `Both`, return true, otherwise, return false.\n    pub fn has_left(&self) -> bool {\n        self.as_ref().left().is_some()\n    }\n\n    /// If `Right`, or `Both`, return true, otherwise, return false.\n    pub fn has_right(&self) -> bool {\n        self.as_ref().right().is_some()\n    }\n\n    /// If Left, return true otherwise, return false.\n    /// Exclusive version of [`has_left`].\n    pub fn is_left(&self) -> bool {\n        match *self {\n            Left(_) => true,\n            _ => false,\n        }\n    }\n\n    /// If Right, return true otherwise, return false.\n    /// Exclusive version of [`has_right`].\n    pub fn is_right(&self) -> bool {\n        match *self {\n            Right(_) => true,\n            _ => false,\n        }\n    }\n\n    /// If Right, return true otherwise, return false.\n    /// Equivalent to `self.as_ref().both().is_some()`.\n    pub fn is_both(&self) -> bool {\n        self.as_ref().both().is_some()\n    }\n\n    /// If `Left`, or `Both`, return `Some` with the left value, otherwise, return `None`.\n    pub fn left(self) -> Option<A> {\n        match self {\n            Left(left) | Both(left, _) => Some(left),\n            _ => None,\n        }\n    }\n\n    /// If `Right`, or `Both`, return `Some` with the right value, otherwise, return `None`.\n    pub fn right(self) -> Option<B> {\n        match self {\n            Right(right) | Both(_, right) => Some(right),\n            _ => None,\n        }\n    }\n\n    /// If Both, return `Some` tuple containing left and right.\n    pub fn both(self) -> Option<(A, B)> {\n        match self {\n            Both(a, b) => Some((a, b)),\n            _ => None,\n        }\n    }\n\n    /// Converts from `&EitherOrBoth<A, B>` to `EitherOrBoth<&A, &B>`.\n    pub fn as_ref(&self) -> EitherOrBoth<&A, &B> {\n        match *self {\n            Left(ref left) => Left(left),\n            Right(ref right) => Right(right),\n            Both(ref left, ref right) => Both(left, right),\n        }\n    }\n\n    /// Converts from `&mut EitherOrBoth<A, B>` to `EitherOrBoth<&mut A, &mut B>`.\n    pub fn as_mut(&mut self) -> EitherOrBoth<&mut A, &mut B> {\n        match *self {\n            Left(ref mut left) => Left(left),\n            Right(ref mut right) => Right(right),\n            Both(ref mut left, ref mut right) => Both(left, right),\n        }\n    }\n\n    /// Convert `EitherOrBoth<A, B>` to `EitherOrBoth<B, A>`.\n    pub fn flip(self) -> EitherOrBoth<B, A> {\n        match self {\n            Left(a) => Right(a),\n            Right(b) => Left(b),\n            Both(a, b) => Both(b, a),\n        }\n    }\n\n    /// Apply the function `f` on the value `a` in `Left(a)` or `Both(a, b)` variants. If it is\n    /// present rewrapping the result in `self`'s original variant.\n    pub fn map_left<F, M>(self, f: F) -> EitherOrBoth<M, B>\n    where\n        F: FnOnce(A) -> M,\n    {\n        match self {\n            Both(a, b) => Both(f(a), b),\n            Left(a) => Left(f(a)),\n            Right(b) => Right(b),\n        }\n    }\n\n    /// Apply the function `f` on the value `b` in `Right(b)` or `Both(a, b)` variants.\n    /// If it is present rewrapping the result in `self`'s original variant.\n    pub fn map_right<F, M>(self, f: F) -> EitherOrBoth<A, M>\n    where\n        F: FnOnce(B) -> M,\n    {\n        match self {\n            Left(a) => Left(a),\n            Right(b) => Right(f(b)),\n            Both(a, b) => Both(a, f(b)),\n        }\n    }\n\n    /// Apply the functions `f` and `g` on the value `a` and `b` respectively;\n    /// found in `Left(a)`, `Right(b)`, or `Both(a, b)` variants.\n    /// The Result is rewrapped `self`'s original variant.\n    pub fn map_any<F, L, G, R>(self, f: F, g: G) -> EitherOrBoth<L, R>\n    where\n        F: FnOnce(A) -> L,\n        G: FnOnce(B) -> R,\n    {\n        match self {\n            Left(a) => Left(f(a)),\n            Right(b) => Right(g(b)),\n            Both(a, b) => Both(f(a), g(b)),\n        }\n    }\n\n    /// Apply the function `f` on the value `b` in `Right(b)` or `Both(a, _)` variants if it is\n    /// present.\n    pub fn left_and_then<F, L>(self, f: F) -> EitherOrBoth<L, B>\n    where\n        F: FnOnce(A) -> EitherOrBoth<L, B>,\n    {\n        match self {\n            Left(a) | Both(a, _) => f(a),\n            Right(b) => Right(b),\n        }\n    }\n\n    /// Apply the function `f` on the value `a`\n    /// in `Left(a)` or `Both(a, _)` variants if it is present.\n    pub fn right_and_then<F, R>(self, f: F) -> EitherOrBoth<A, R>\n    where\n        F: FnOnce(B) -> EitherOrBoth<A, R>,\n    {\n        match self {\n            Left(a) => Left(a),\n            Right(b) | Both(_, b) => f(b),\n        }\n    }\n}\n\nimpl<T> EitherOrBoth<T, T> {\n    /// Return either value of left, right, or the product of `f` applied where `Both` are present.\n    pub fn reduce<F>(self, f: F) -> T\n    where\n        F: FnOnce(T, T) -> T,\n    {\n        match self {\n            Left(a) => a,\n            Right(b) => b,\n            Both(a, b) => f(a, b),\n        }\n    }\n}\n\nimpl<A, B> Into<Option<Either<A, B>>> for EitherOrBoth<A, B> {\n    fn into(self) -> Option<Either<A, B>> {\n        match self {\n            EitherOrBoth::Left(l) => Some(Either::Left(l)),\n            EitherOrBoth::Right(r) => Some(Either::Right(r)),\n            _ => None,\n        }\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":8,"coverable":68},{"path":["/","home","kms","itertools","src","exactly_one_err.rs"],"content":"use std::iter::ExactSizeIterator;\n\nuse crate::size_hint;\n\n/// Iterator returned for the error case of `IterTools::exactly_one()`\n/// This iterator yields exactly the same elements as the input iterator.\n///\n/// During the execution of exactly_one the iterator must be mutated.  This wrapper\n/// effectively \"restores\" the state of the input iterator when it's handed back.\n///\n/// This is very similar to PutBackN except this iterator only supports 0-2 elements and does not\n/// use a `Vec`.\n#[derive(Debug, Clone)]\npub struct ExactlyOneError<I>\nwhere\n    I: Iterator,\n{\n    first_two: (Option<I::Item>, Option<I::Item>),\n    inner: I,\n}\n\nimpl<I> ExactlyOneError<I>\nwhere\n    I: Iterator,\n{\n    /// Creates a new `ExactlyOneErr` iterator.\n    pub(crate) fn new(first_two: (Option<I::Item>, Option<I::Item>), inner: I) -> Self {\n        Self { first_two, inner }\n    }\n}\n\nimpl<I> Iterator for ExactlyOneError<I>\nwhere\n    I: Iterator,\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.first_two\n            .0\n            .take()\n            .or_else(|| self.first_two.1.take())\n            .or_else(|| self.inner.next())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let mut additional_len = 0;\n        if self.first_two.0.is_some() {\n            additional_len += 1;\n        }\n        if self.first_two.1.is_some() {\n            additional_len += 1;\n        }\n        size_hint::add_scalar(self.inner.size_hint(), additional_len)\n    }\n}\n\nimpl<I> ExactSizeIterator for ExactlyOneError<I> where I: ExactSizeIterator {}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[4265961,4266016,4266272,4266025,4265598,4266281,4265854,4265952,4265726],"length":1,"stats":{"Line":12},"fn_name":"{{closure}}<core::iter::adapters::Filter<core::ops::range::Range<i32>, closure-3>>"},{"line":43,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":5,"coverable":13},{"path":["/","home","kms","itertools","src","format.rs"],"content":"use std::fmt;\nuse std::cell::RefCell;\n\n/// Format all iterator elements lazily, separated by `sep`.\n///\n/// The format value can only be formatted once, after that the iterator is\n/// exhausted.\n///\n/// See [`.format_with()`](../trait.Itertools.html#method.format_with) for more information.\n#[derive(Clone)]\npub struct FormatWith<'a, I, F> {\n    sep: &'a str,\n    /// FormatWith uses interior mutability because Display::fmt takes &self.\n    inner: RefCell<Option<(I, F)>>,\n}\n\n/// Format all iterator elements lazily, separated by `sep`.\n///\n/// The format value can only be formatted once, after that the iterator is\n/// exhausted.\n///\n/// See [`.format()`](../trait.Itertools.html#method.format)\n/// for more information.\n#[derive(Clone)]\npub struct Format<'a, I> {\n    sep: &'a str,\n    /// Format uses interior mutability because Display::fmt takes &self.\n    inner: RefCell<Option<I>>,\n}\n\npub fn new_format<'a, I, F>(iter: I, separator: &'a str, f: F) -> FormatWith<'a, I, F>\n    where I: Iterator,\n          F: FnMut(I::Item, &mut dyn FnMut(&dyn fmt::Display) -> fmt::Result) -> fmt::Result\n{\n    FormatWith {\n        sep: separator,\n        inner: RefCell::new(Some((iter, f))),\n    }\n}\n\npub fn new_format_default<'a, I>(iter: I, separator: &'a str) -> Format<'a, I>\n    where I: Iterator,\n{\n    Format {\n        sep: separator,\n        inner: RefCell::new(Some(iter)),\n    }\n}\n\nimpl<'a, I, F> fmt::Display for FormatWith<'a, I, F>\n    where I: Iterator,\n          F: FnMut(I::Item, &mut dyn  FnMut(&dyn fmt::Display) -> fmt::Result) -> fmt::Result\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let (mut iter, mut format) = match self.inner.borrow_mut().take() {\n            Some(t) => t,\n            None => panic!(\"FormatWith: was already formatted once\"),\n        };\n\n        if let Some(fst) = iter.next() {\n            format(fst, &mut |disp: &dyn fmt::Display| disp.fmt(f))?;\n            for elt in iter {\n                if self.sep.len() > 0 {\n\n                    f.write_str(self.sep)?;\n                }\n                format(elt, &mut |disp: &dyn fmt::Display| disp.fmt(f))?;\n            }\n        }\n        Ok(())\n    }\n}\n\nimpl<'a, I> Format<'a, I>\n    where I: Iterator,\n{\n    fn format<F>(&self, f: &mut fmt::Formatter, mut cb: F) -> fmt::Result\n        where F: FnMut(&I::Item, &mut fmt::Formatter) -> fmt::Result,\n    {\n        let mut iter = match self.inner.borrow_mut().take() {\n            Some(t) => t,\n            None => panic!(\"Format: was already formatted once\"),\n        };\n\n        if let Some(fst) = iter.next() {\n            cb(&fst, f)?;\n            for elt in iter {\n                if self.sep.len() > 0 {\n                    f.write_str(self.sep)?;\n                }\n                cb(&elt, f)?;\n            }\n        }\n        Ok(())\n    }\n}\n\nmacro_rules! impl_format {\n    ($($fmt_trait:ident)*) => {\n        $(\n            impl<'a, I> fmt::$fmt_trait for Format<'a, I>\n                where I: Iterator,\n                      I::Item: fmt::$fmt_trait,\n            {\n                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                    self.format(f, fmt::$fmt_trait::fmt)\n                }\n            }\n        )*\n    }\n}\n\nimpl_format!{Display Debug\n             UpperExp LowerExp UpperHex LowerHex Octal Binary Pointer}\n","traces":[{"line":41,"address":[4912768,4912592],"length":1,"stats":{"Line":2},"fn_name":"new_format_default<core::slice::Iter<f64>>"},{"line":46,"address":[4912629,4912805],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[4909398,4911030,4907766,4907696,4910960,4909328],"length":1,"stats":{"Line":3},"fn_name":"format<core::slice::Iter<i32>,fn(&&i32, &mut core::fmt::Formatter) -> core::result::Result<(), core::fmt::Error>>"},{"line":80,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[4907600,4907552,4907648],"length":1,"stats":{"Line":3},"fn_name":"fmt<core::slice::Iter<i32>>"},{"line":106,"address":[4907614,4907566,4907662],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":14,"coverable":26},{"path":["/","home","kms","itertools","src","free.rs"],"content":"//! Free functions that create iterator adaptors or call iterator methods.\n//!\n//! The benefit of free functions is that they accept any `IntoIterator` as\n//! argument, so the resulting code may be easier to read.\n\n#[cfg(feature = \"use_std\")]\nuse std::fmt::Display;\nuse std::iter::{self, Zip};\n#[cfg(feature = \"use_std\")]\ntype VecIntoIter<T> = ::std::vec::IntoIter<T>;\n\n#[cfg(feature = \"use_std\")]\nuse crate::Itertools;\n\npub use crate::adaptors::{\n    interleave,\n    merge,\n    put_back,\n};\n#[cfg(feature = \"use_std\")]\npub use crate::put_back_n_impl::put_back_n;\n#[cfg(feature = \"use_std\")]\npub use crate::multipeek_impl::multipeek;\n#[cfg(feature = \"use_std\")]\npub use crate::peek_nth::peek_nth;\n#[cfg(feature = \"use_std\")]\npub use crate::kmerge_impl::kmerge;\npub use crate::zip_eq_impl::zip_eq;\npub use crate::merge_join::merge_join_by;\n#[cfg(feature = \"use_std\")]\npub use crate::rciter_impl::rciter;\n\n/// Iterate `iterable` with a running index.\n///\n/// `IntoIterator` enabled version of `.enumerate()`.\n///\n/// ```\n/// use itertools::enumerate;\n///\n/// for (i, elt) in enumerate(&[1, 2, 3]) {\n///     /* loop body */\n/// }\n/// ```\npub fn enumerate<I>(iterable: I) -> iter::Enumerate<I::IntoIter>\n    where I: IntoIterator\n{\n    iterable.into_iter().enumerate()\n}\n\n/// Iterate `iterable` in reverse.\n///\n/// `IntoIterator` enabled version of `.rev()`.\n///\n/// ```\n/// use itertools::rev;\n///\n/// for elt in rev(&[1, 2, 3]) {\n///     /* loop body */\n/// }\n/// ```\npub fn rev<I>(iterable: I) -> iter::Rev<I::IntoIter>\n    where I: IntoIterator,\n          I::IntoIter: DoubleEndedIterator\n{\n    iterable.into_iter().rev()\n}\n\n/// Iterate `i` and `j` in lock step.\n///\n/// `IntoIterator` enabled version of `i.zip(j)`.\n///\n/// ```\n/// use itertools::zip;\n///\n/// let data = [1, 2, 3, 4, 5];\n/// for (a, b) in zip(&data, &data[1..]) {\n///     /* loop body */\n/// }\n/// ```\npub fn zip<I, J>(i: I, j: J) -> Zip<I::IntoIter, J::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator\n{\n    i.into_iter().zip(j)\n}\n\n/// Create an iterator that first iterates `i` and then `j`.\n///\n/// `IntoIterator` enabled version of `i.chain(j)`.\n///\n/// ```\n/// use itertools::chain;\n///\n/// for elt in chain(&[1, 2, 3], &[4]) {\n///     /* loop body */\n/// }\n/// ```\npub fn chain<I, J>(i: I, j: J) -> iter::Chain<<I as IntoIterator>::IntoIter, <J as IntoIterator>::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator<Item = I::Item>\n{\n    i.into_iter().chain(j)\n}\n\n/// Create an iterator that clones each element from &T to T\n///\n/// `IntoIterator` enabled version of `i.cloned()`.\n///\n/// ```\n/// use itertools::cloned;\n///\n/// assert_eq!(cloned(b\"abc\").next(), Some(b'a'));\n/// ```\npub fn cloned<'a, I, T: 'a>(iterable: I) -> iter::Cloned<I::IntoIter>\n    where I: IntoIterator<Item=&'a T>,\n          T: Clone,\n{\n    iterable.into_iter().cloned()\n}\n\n/// Perform a fold operation over the iterable.\n///\n/// `IntoIterator` enabled version of `i.fold(init, f)`\n///\n/// ```\n/// use itertools::fold;\n///\n/// assert_eq!(fold(&[1., 2., 3.], 0., |a, &b| f32::max(a, b)), 3.);\n/// ```\npub fn fold<I, B, F>(iterable: I, init: B, f: F) -> B\n    where I: IntoIterator,\n          F: FnMut(B, I::Item) -> B\n{\n    iterable.into_iter().fold(init, f)\n}\n\n/// Test whether the predicate holds for all elements in the iterable.\n///\n/// `IntoIterator` enabled version of `i.all(f)`\n///\n/// ```\n/// use itertools::all;\n///\n/// assert!(all(&[1, 2, 3], |elt| *elt > 0));\n/// ```\npub fn all<I, F>(iterable: I, f: F) -> bool\n    where I: IntoIterator,\n          F: FnMut(I::Item) -> bool\n{\n    iterable.into_iter().all(f)\n}\n\n/// Test whether the predicate holds for any elements in the iterable.\n///\n/// `IntoIterator` enabled version of `i.any(f)`\n///\n/// ```\n/// use itertools::any;\n///\n/// assert!(any(&[0, -1, 2], |elt| *elt > 0));\n/// ```\npub fn any<I, F>(iterable: I, f: F) -> bool\n    where I: IntoIterator,\n          F: FnMut(I::Item) -> bool\n{\n    iterable.into_iter().any(f)\n}\n\n/// Return the maximum value of the iterable.\n///\n/// `IntoIterator` enabled version of `i.max()`.\n///\n/// ```\n/// use itertools::max;\n///\n/// assert_eq!(max(0..10), Some(9));\n/// ```\npub fn max<I>(iterable: I) -> Option<I::Item>\n    where I: IntoIterator,\n          I::Item: Ord\n{\n    iterable.into_iter().max()\n}\n\n/// Return the minimum value of the iterable.\n///\n/// `IntoIterator` enabled version of `i.min()`.\n///\n/// ```\n/// use itertools::min;\n///\n/// assert_eq!(min(0..10), Some(0));\n/// ```\npub fn min<I>(iterable: I) -> Option<I::Item>\n    where I: IntoIterator,\n          I::Item: Ord\n{\n    iterable.into_iter().min()\n}\n\n\n/// Combine all iterator elements into one String, seperated by `sep`.\n///\n/// `IntoIterator` enabled version of `iterable.join(sep)`.\n///\n/// ```\n/// use itertools::join;\n///\n/// assert_eq!(join(&[1, 2, 3], \", \"), \"1, 2, 3\");\n/// ```\n#[cfg(feature = \"use_std\")]\npub fn join<I>(iterable: I, sep: &str) -> String\n    where I: IntoIterator,\n          I::Item: Display\n{\n    iterable.into_iter().join(sep)\n}\n\n/// Sort all iterator elements into a new iterator in ascending order.\n///\n/// `IntoIterator` enabled version of [`iterable.sorted()`][1].\n///\n/// [1]: trait.Itertools.html#method.sorted\n///\n/// ```\n/// use itertools::sorted;\n/// use itertools::assert_equal;\n///\n/// assert_equal(sorted(\"rust\".chars()), \"rstu\".chars());\n/// ```\n#[cfg(feature = \"use_std\")]\npub fn sorted<I>(iterable: I) -> VecIntoIter<I::Item>\n    where I: IntoIterator,\n          I::Item: Ord\n{\n    iterable.into_iter().sorted()\n}\n\n","traces":[{"line":44,"address":[5001808],"length":1,"stats":{"Line":1},"fn_name":"enumerate<&alloc::vec::Vec<u8>>"},{"line":47,"address":[5001820],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[5001584,5001472],"length":1,"stats":{"Line":1},"fn_name":"zip<&[i32],&[i32]>"},{"line":84,"address":[5001499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[4281232],"length":1,"stats":{"Line":3},"fn_name":"cloned<&[i32; 4],i32>"},{"line":118,"address":[4281241],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","kms","itertools","src","group_map.rs"],"content":"#![cfg(feature = \"use_std\")]\n\nuse std::collections::HashMap;\nuse std::hash::Hash;\nuse std::iter::Iterator;\n\n/// Return a `HashMap` of keys mapped to a list of their corresponding values.\n///\n/// See [`.into_group_map()`](../trait.Itertools.html#method.into_group_map)\n/// for more information.\npub fn into_group_map<I, K, V>(iter: I) -> HashMap<K, Vec<V>>\n    where I: Iterator<Item=(K, V)>,\n          K: Hash + Eq,\n{\n    let mut lookup = HashMap::new();\n\n    for (key, val) in iter {\n        lookup.entry(key).or_insert(Vec::new()).push(val);\n    }\n\n    lookup\n}","traces":[{"line":11,"address":[5811400,5811312],"length":1,"stats":{"Line":1},"fn_name":"into_group_map<core::iter::adapters::Map<alloc::vec::IntoIter<u8>, closure-0>,u8,u8>"},{"line":15,"address":[5811322],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[5812031,5812114,5811415,5811889,5811537],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[5811762,5812138,5812083],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[5811899],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":5,"coverable":5},{"path":["/","home","kms","itertools","src","groupbylazy.rs"],"content":"use std::cell::{Cell, RefCell};\nuse std::vec;\n\n/// A trait to unify FnMut for GroupBy with the chunk key in IntoChunks\ntrait KeyFunction<A> {\n    type Key;\n    fn call_mut(&mut self, arg: A) -> Self::Key;\n}\n\nimpl<'a, A, K, F: ?Sized> KeyFunction<A> for F\n    where F: FnMut(A) -> K\n{\n    type Key = K;\n    #[inline]\n    fn call_mut(&mut self, arg: A) -> Self::Key {\n        (*self)(arg)\n    }\n}\n\n\n/// ChunkIndex acts like the grouping key function for IntoChunks\n#[derive(Debug)]\nstruct ChunkIndex {\n    size: usize,\n    index: usize,\n    key: usize,\n}\n\nimpl ChunkIndex {\n    #[inline(always)]\n    fn new(size: usize) -> Self {\n        ChunkIndex {\n            size,\n            index: 0,\n            key: 0,\n        }\n    }\n}\n\nimpl<'a, A> KeyFunction<A> for ChunkIndex {\n    type Key = usize;\n    #[inline(always)]\n    fn call_mut(&mut self, _arg: A) -> Self::Key {\n        if self.index == self.size {\n            self.key += 1;\n            self.index = 0;\n        }\n        self.index += 1;\n        self.key\n    }\n}\n\n\nstruct GroupInner<K, I, F>\n    where I: Iterator\n{\n    key: F,\n    iter: I,\n    current_key: Option<K>,\n    current_elt: Option<I::Item>,\n    /// flag set if iterator is exhausted\n    done: bool,\n    /// Index of group we are currently buffering or visiting\n    top_group: usize,\n    /// Least index for which we still have elements buffered\n    oldest_buffered_group: usize,\n    /// Group index for `buffer[0]` -- the slots\n    /// bottom_group..oldest_buffered_group are unused and will be erased when\n    /// that range is large enough.\n    bottom_group: usize,\n    /// Buffered groups, from `bottom_group` (index 0) to `top_group`.\n    buffer: Vec<vec::IntoIter<I::Item>>,\n    /// index of last group iter that was dropped, usize::MAX == none\n    dropped_group: usize,\n}\n\nimpl<K, I, F> GroupInner<K, I, F>\n    where I: Iterator,\n          F: for<'a> KeyFunction<&'a I::Item, Key=K>,\n          K: PartialEq,\n{\n    /// `client`: Index of group that requests next element\n    #[inline(always)]\n    fn step(&mut self, client: usize) -> Option<I::Item> {\n        /*\n        println!(\"client={}, bottom_group={}, oldest_buffered_group={}, top_group={}, buffers=[{}]\",\n                 client, self.bottom_group, self.oldest_buffered_group,\n                 self.top_group,\n                 self.buffer.iter().map(|elt| elt.len()).format(\", \"));\n        */\n        if client < self.oldest_buffered_group {\n            None\n        } else if client < self.top_group ||\n            (client == self.top_group &&\n             self.buffer.len() > self.top_group - self.bottom_group)\n        {\n            self.lookup_buffer(client)\n        } else if self.done {\n            None\n        } else if self.top_group == client {\n            self.step_current()\n        } else {\n            self.step_buffering(client)\n        }\n    }\n\n    #[inline(never)]\n    fn lookup_buffer(&mut self, client: usize) -> Option<I::Item> {\n        // if `bufidx` doesn't exist in self.buffer, it might be empty\n        let bufidx = client - self.bottom_group;\n        if client < self.oldest_buffered_group {\n            return None;\n        }\n        let elt = self.buffer.get_mut(bufidx).and_then(|queue| queue.next());\n        if elt.is_none() && client == self.oldest_buffered_group {\n            // FIXME: VecDeque is unfortunately not zero allocation when empty,\n            // so we do this job manually.\n            // `bottom_group..oldest_buffered_group` is unused, and if it's large enough, erase it.\n            self.oldest_buffered_group += 1;\n            // skip forward further empty queues too\n            while self.buffer.get(self.oldest_buffered_group - self.bottom_group)\n                             .map_or(false, |buf| buf.len() == 0)\n            {\n                self.oldest_buffered_group += 1;\n            }\n\n            let nclear = self.oldest_buffered_group - self.bottom_group;\n            if nclear > 0 && nclear >= self.buffer.len() / 2 {\n                let mut i = 0;\n                self.buffer.retain(|buf| {\n                    i += 1;\n                    debug_assert!(buf.len() == 0 || i > nclear);\n                    i > nclear\n                });\n                self.bottom_group = self.oldest_buffered_group;\n            }\n        }\n        elt\n    }\n\n    /// Take the next element from the iterator, and set the done\n    /// flag if exhausted. Must not be called after done.\n    #[inline(always)]\n    fn next_element(&mut self) -> Option<I::Item> {\n        debug_assert!(!self.done);\n        match self.iter.next() {\n            None => { self.done = true; None }\n            otherwise => otherwise,\n        }\n    }\n\n\n    #[inline(never)]\n    fn step_buffering(&mut self, client: usize) -> Option<I::Item> {\n        // requested a later group -- walk through the current group up to\n        // the requested group index, and buffer the elements (unless\n        // the group is marked as dropped).\n        // Because the `Groups` iterator is always the first to request\n        // each group index, client is the next index efter top_group.\n        debug_assert!(self.top_group + 1 == client);\n        let mut group = Vec::new();\n\n        if let Some(elt) = self.current_elt.take() {\n            if self.top_group != self.dropped_group {\n                group.push(elt);\n            }\n        }\n        let mut first_elt = None; // first element of the next group\n\n        while let Some(elt) = self.next_element() {\n            let key = self.key.call_mut(&elt);\n            match self.current_key.take() {\n                None => {}\n                Some(old_key) => if old_key != key {\n                    self.current_key = Some(key);\n                    first_elt = Some(elt);\n                    break;\n                },\n            }\n            self.current_key = Some(key);\n            if self.top_group != self.dropped_group {\n                group.push(elt);\n            }\n        }\n\n        if self.top_group != self.dropped_group {\n            self.push_next_group(group);\n        }\n        if first_elt.is_some() {\n            self.top_group += 1;\n            debug_assert!(self.top_group == client);\n        }\n        first_elt\n    }\n\n    fn push_next_group(&mut self, group: Vec<I::Item>) {\n        // When we add a new buffered group, fill up slots between oldest_buffered_group and top_group\n        while self.top_group - self.bottom_group > self.buffer.len() {\n            if self.buffer.is_empty() {\n                self.bottom_group += 1;\n                self.oldest_buffered_group += 1;\n            } else {\n                self.buffer.push(Vec::new().into_iter());\n            }\n        }\n        self.buffer.push(group.into_iter());\n        debug_assert!(self.top_group + 1 - self.bottom_group == self.buffer.len());\n    }\n\n    /// This is the immediate case, where we use no buffering\n    #[inline]\n    fn step_current(&mut self) -> Option<I::Item> {\n        debug_assert!(!self.done);\n        if let elt @ Some(..) = self.current_elt.take() {\n            return elt;\n        }\n        match self.next_element() {\n            None => None,\n            Some(elt) => {\n                let key = self.key.call_mut(&elt);\n                match self.current_key.take() {\n                    None => {}\n                    Some(old_key) => if old_key != key {\n                        self.current_key = Some(key);\n                        self.current_elt = Some(elt);\n                        self.top_group += 1;\n                        return None;\n                    },\n                }\n                self.current_key = Some(key);\n                Some(elt)\n            }\n        }\n    }\n\n    /// Request the just started groups' key.\n    ///\n    /// `client`: Index of group\n    ///\n    /// **Panics** if no group key is available.\n    fn group_key(&mut self, client: usize) -> K {\n        // This can only be called after we have just returned the first\n        // element of a group.\n        // Perform this by simply buffering one more element, grabbing the\n        // next key.\n        debug_assert!(!self.done);\n        debug_assert!(client == self.top_group);\n        debug_assert!(self.current_key.is_some());\n        debug_assert!(self.current_elt.is_none());\n        let old_key = self.current_key.take().unwrap();\n        if let Some(elt) = self.next_element() {\n            let key = self.key.call_mut(&elt);\n            if old_key != key {\n                self.top_group += 1;\n            }\n            self.current_key = Some(key);\n            self.current_elt = Some(elt);\n        }\n        old_key\n    }\n}\n\nimpl<K, I, F> GroupInner<K, I, F>\n    where I: Iterator,\n{\n    /// Called when a group is dropped\n    fn drop_group(&mut self, client: usize) {\n        // It's only useful to track the maximal index\n        if self.dropped_group == !0 || client > self.dropped_group {\n            self.dropped_group = client;\n        }\n    }\n}\n\n/// `GroupBy` is the storage for the lazy grouping operation.\n///\n/// If the groups are consumed in their original order, or if each\n/// group is dropped without keeping it around, then `GroupBy` uses\n/// no allocations. It needs allocations only if several group iterators\n/// are alive at the same time.\n///\n/// This type implements `IntoIterator` (it is **not** an iterator\n/// itself), because the group iterators need to borrow from this\n/// value. It should be stored in a local variable or temporary and\n/// iterated.\n///\n/// See [`.group_by()`](../trait.Itertools.html#method.group_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct GroupBy<K, I, F>\n    where I: Iterator,\n{\n    inner: RefCell<GroupInner<K, I, F>>,\n    // the group iterator's current index. Keep this in the main value\n    // so that simultaneous iterators all use the same state.\n    index: Cell<usize>,\n}\n\n/// Create a new\npub fn new<K, J, F>(iter: J, f: F) -> GroupBy<K, J::IntoIter, F>\n    where J: IntoIterator,\n          F: FnMut(&J::Item) -> K,\n{\n    GroupBy {\n        inner: RefCell::new(GroupInner {\n            key: f,\n            iter: iter.into_iter(),\n            current_key: None,\n            current_elt: None,\n            done: false,\n            top_group: 0,\n            oldest_buffered_group: 0,\n            bottom_group: 0,\n            buffer: Vec::new(),\n            dropped_group: !0,\n        }),\n        index: Cell::new(0),\n    }\n}\n\nimpl<K, I, F> GroupBy<K, I, F>\n    where I: Iterator,\n{\n    /// `client`: Index of group that requests next element\n    fn step(&self, client: usize) -> Option<I::Item>\n        where F: FnMut(&I::Item) -> K,\n              K: PartialEq,\n    {\n        self.inner.borrow_mut().step(client)\n    }\n\n    /// `client`: Index of group\n    fn drop_group(&self, client: usize) {\n        self.inner.borrow_mut().drop_group(client)\n    }\n}\n\nimpl<'a, K, I, F> IntoIterator for &'a GroupBy<K, I, F>\n    where I: Iterator,\n          I::Item: 'a,\n          F: FnMut(&I::Item) -> K,\n          K: PartialEq\n{\n    type Item = (K, Group<'a, K, I, F>);\n    type IntoIter = Groups<'a, K, I, F>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        Groups { parent: self }\n    }\n}\n\n\n/// An iterator that yields the Group iterators.\n///\n/// Iterator element type is `(K, Group)`:\n/// the group's key `K` and the group's iterator.\n///\n/// See [`.group_by()`](../trait.Itertools.html#method.group_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Groups<'a, K: 'a, I: 'a, F: 'a>\n    where I: Iterator,\n          I::Item: 'a\n{\n    parent: &'a GroupBy<K, I, F>,\n}\n\nimpl<'a, K, I, F> Iterator for Groups<'a, K, I, F>\n    where I: Iterator,\n          I::Item: 'a,\n          F: FnMut(&I::Item) -> K,\n          K: PartialEq\n{\n    type Item = (K, Group<'a, K, I, F>);\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let index = self.parent.index.get();\n        self.parent.index.set(index + 1);\n        let inner = &mut *self.parent.inner.borrow_mut();\n        inner.step(index).map(|elt| {\n            let key = inner.group_key(index);\n            (key, Group {\n                parent: self.parent,\n                index,\n                first: Some(elt),\n            })\n        })\n    }\n}\n\n/// An iterator for the elements in a single group.\n///\n/// Iterator element type is `I::Item`.\npub struct Group<'a, K: 'a, I: 'a, F: 'a>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    parent: &'a GroupBy<K, I, F>,\n    index: usize,\n    first: Option<I::Item>,\n}\n\nimpl<'a, K, I, F> Drop for Group<'a, K, I, F>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    fn drop(&mut self) {\n        self.parent.drop_group(self.index);\n    }\n}\n\nimpl<'a, K, I, F> Iterator for Group<'a, K, I, F>\n    where I: Iterator,\n          I::Item: 'a,\n          F: FnMut(&I::Item) -> K,\n          K: PartialEq,\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        if let elt @ Some(..) = self.first.take() {\n            return elt;\n        }\n        self.parent.step(self.index)\n    }\n}\n\n///// IntoChunks /////\n\n/// Create a new\npub fn new_chunks<J>(iter: J, size: usize) -> IntoChunks<J::IntoIter>\n    where J: IntoIterator,\n{\n    IntoChunks {\n        inner: RefCell::new(GroupInner {\n            key: ChunkIndex::new(size),\n            iter: iter.into_iter(),\n            current_key: None,\n            current_elt: None,\n            done: false,\n            top_group: 0,\n            oldest_buffered_group: 0,\n            bottom_group: 0,\n            buffer: Vec::new(),\n            dropped_group: !0,\n        }),\n        index: Cell::new(0),\n    }\n}\n\n\n/// `ChunkLazy` is the storage for a lazy chunking operation.\n///\n/// `IntoChunks` behaves just like `GroupBy`: it is iterable, and\n/// it only buffers if several chunk iterators are alive at the same time.\n///\n/// This type implements `IntoIterator` (it is **not** an iterator\n/// itself), because the chunk iterators need to borrow from this\n/// value. It should be stored in a local variable or temporary and\n/// iterated.\n///\n/// Iterator element type is `Chunk`, each chunk's iterator.\n///\n/// See [`.chunks()`](../trait.Itertools.html#method.chunks) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct IntoChunks<I>\n    where I: Iterator,\n{\n    inner: RefCell<GroupInner<usize, I, ChunkIndex>>,\n    // the chunk iterator's current index. Keep this in the main value\n    // so that simultaneous iterators all use the same state.\n    index: Cell<usize>,\n}\n\n\nimpl<I> IntoChunks<I>\n    where I: Iterator,\n{\n    /// `client`: Index of chunk that requests next element\n    fn step(&self, client: usize) -> Option<I::Item> {\n        self.inner.borrow_mut().step(client)\n    }\n\n    /// `client`: Index of chunk\n    fn drop_group(&self, client: usize) {\n        self.inner.borrow_mut().drop_group(client)\n    }\n}\n\nimpl<'a, I> IntoIterator for &'a IntoChunks<I>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    type Item = Chunk<'a, I>;\n    type IntoIter = Chunks<'a, I>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        Chunks {\n            parent: self,\n        }\n    }\n}\n\n\n/// An iterator that yields the Chunk iterators.\n///\n/// Iterator element type is `Chunk`.\n///\n/// See [`.chunks()`](../trait.Itertools.html#method.chunks) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Chunks<'a, I: 'a>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    parent: &'a IntoChunks<I>,\n}\n\nimpl<'a, I> Iterator for Chunks<'a, I>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    type Item = Chunk<'a, I>;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let index = self.parent.index.get();\n        self.parent.index.set(index + 1);\n        let inner = &mut *self.parent.inner.borrow_mut();\n        inner.step(index).map(|elt| {\n            Chunk {\n                parent: self.parent,\n                index,\n                first: Some(elt),\n            }\n        })\n    }\n}\n\n/// An iterator for the elements in a single chunk.\n///\n/// Iterator element type is `I::Item`.\npub struct Chunk<'a, I: 'a>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    parent: &'a IntoChunks<I>,\n    index: usize,\n    first: Option<I::Item>,\n}\n\nimpl<'a, I> Drop for Chunk<'a, I>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    fn drop(&mut self) {\n        self.parent.drop_group(self.index);\n    }\n}\n\nimpl<'a, I> Iterator for Chunk<'a, I>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        if let elt @ Some(..) = self.first.take() {\n            return elt;\n        }\n        self.parent.step(self.index)\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":79},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":74},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":83},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":73},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":73},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":168,"address":[5179600,5187968,5164871,5173287,5190096,5175367,5166958,5185854,5183767,5160334,5169072,5171200,5177464,5181687,5162748],"length":1,"stats":{"Line":10},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":74},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":57},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":299,"address":[5222224,5220421,5220304,5222356,5222720,5216944,5217557,5220885,5219463,5217076,5222837,5218036,5217904,5221232,5217440,5218517,5218400,5219824,5216464,5218864,5220768,5218983,5221362,5221744,5221863,5216583,5219344,5219943],"length":1,"stats":{"Line":18},"fn_name":"new<&i32,core::slice::Iter<i32>,closure-2>"},{"line":304,"address":[5220445,5220909,5221385,5221887,5222380,5222861,5216607,5218060,5219007,5218541,5217581,5219967,5217100,5219487],"length":1,"stats":{"Line":18},"fn_name":null},{"line":316,"address":[5216795,5219675,5221093,5222075,5219195,5220155,5217297,5218725,5221597,5222577,5223045,5218257,5217765,5220629],"length":1,"stats":{"Line":18},"fn_name":null},{"line":324,"address":[5113047,5115127,5115668,5113591,5116708,5117703,5118208,5114096,5115088,5112548,5114132,5116672,5112052,5116128,5116167,5112016,5117664,5117204,5117168,5118247,5113008,5113552,5114592,5112512,5114628,5115632],"length":1,"stats":{"Line":17},"fn_name":"step<char,core::str::Chars,closure-0>"},{"line":328,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":430,"address":[5108944,5109050],"length":1,"stats":{"Line":2},"fn_name":"new_chunks<core::slice::Iter<i32>>"},{"line":434,"address":[5108969,5109164],"length":1,"stats":{"Line":4},"fn_name":null},{"line":446,"address":[5109387],"length":1,"stats":{"Line":2},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":151,"coverable":157},{"path":["/","home","kms","itertools","src","impl_macros.rs"],"content":"//! \n//! Implementation's internal macros\n\nmacro_rules! debug_fmt_fields {\n    ($tyname:ident, $($($field:ident).+),*) => {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            f.debug_struct(stringify!($tyname))\n                $(\n              .field(stringify!($($field).+), &self.$($field).+)\n              )*\n              .finish()\n        }\n    }\n}\n\nmacro_rules! clone_fields {\n    ($($field:ident),*) => {\n        fn clone(&self) -> Self {\n            Self {\n                $($field: self.$field.clone(),)*\n            }\n        }\n    }\n}\n","traces":[{"line":18,"address":[4251264,4251216],"length":1,"stats":{"Line":5},"fn_name":"clone<alloc::vec::IntoIter<usize>,alloc::vec::IntoIter<usize>,fn(&usize, &usize) -> core::cmp::Ordering>"},{"line":19,"address":[4251332],"length":1,"stats":{"Line":5},"fn_name":null},{"line":20,"address":[4251279,4251231],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","home","kms","itertools","src","intersperse.rs"],"content":"use std::iter::Fuse;\nuse super::size_hint;\n\n#[derive(Clone)]\n/// An iterator adaptor to insert a particular value\n/// between each element of the adapted iterator.\n///\n/// Iterator element type is `I::Item`\n///\n/// This iterator is *fused*.\n///\n/// See [`.intersperse()`](../trait.Itertools.html#method.intersperse) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Debug)]\npub struct Intersperse<I>\n    where I: Iterator\n{\n    element: I::Item,\n    iter: Fuse<I>,\n    peek: Option<I::Item>,\n}\n\n/// Create a new Intersperse iterator\npub fn intersperse<I>(iter: I, elt: I::Item) -> Intersperse<I>\n    where I: Iterator\n{\n    let mut iter = iter.fuse();\n    Intersperse {\n        peek: iter.next(),\n        iter,\n        element: elt,\n    }\n}\n\nimpl<I> Iterator for Intersperse<I>\n    where I: Iterator,\n          I::Item: Clone\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.peek.is_some() {\n            self.peek.take()\n        } else {\n            self.peek = self.iter.next();\n            if self.peek.is_some() {\n                Some(self.element.clone())\n            } else {\n                None\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // 2 * SH + { 1 or 0 }\n        let has_peek = self.peek.is_some() as usize;\n        let sh = self.iter.size_hint();\n        size_hint::add_scalar(size_hint::add(sh, sh), has_peek)\n    }\n\n    fn fold<B, F>(mut self, init: B, mut f: F) -> B where\n        Self: Sized, F: FnMut(B, Self::Item) -> B,\n    {\n        let mut accum = init;\n        \n        if let Some(x) = self.peek.take() {\n            accum = f(accum, x);\n        }\n\n        let element = &self.element;\n\n        self.iter.fold(accum,\n            |accum, x| {\n                let accum = f(accum, element.clone());\n                let accum = f(accum, x);\n                accum\n        })\n    }\n}\n","traces":[{"line":24,"address":[4210032,4210103],"length":1,"stats":{"Line":5},"fn_name":"intersperse<core::ops::range::Range<i32>>"},{"line":27,"address":[4210051],"length":1,"stats":{"Line":5},"fn_name":null},{"line":29,"address":[4607229,4606982],"length":1,"stats":{"Line":5},"fn_name":null},{"line":41,"address":[4209152],"length":1,"stats":{"Line":5},"fn_name":"next<core::ops::range::Range<i32>>"},{"line":42,"address":[4606232,4606295,4606377,4606458,4606516,4606137],"length":1,"stats":{"Line":14},"fn_name":null},{"line":43,"address":[4606433,4606201],"length":1,"stats":{"Line":4},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":46,"address":[4606550,4606462,4606236,4606252,4606362,4606577,4606335,4606477],"length":1,"stats":{"Line":14},"fn_name":null},{"line":47,"address":[4209269],"length":1,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[4207391,4208096,4207328,4207775,4208159,4207712],"length":1,"stats":{"Line":3},"fn_name":"fold<core::ops::range::Range<i32>,(),closure-0>"},{"line":64,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":67,"address":[4207841,4207457,4208225],"length":1,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":23,"coverable":24},{"path":["/","home","kms","itertools","src","kmerge_impl.rs"],"content":"use crate::size_hint;\nuse crate::Itertools;\n\nuse std::mem::replace;\nuse std::fmt;\n\n/// Head element and Tail iterator pair\n///\n/// `PartialEq`, `Eq`, `PartialOrd` and `Ord` are implemented by comparing sequences based on\n/// first items (which are guaranteed to exist).\n///\n/// The meanings of `PartialOrd` and `Ord` are reversed so as to turn the heap used in\n/// `KMerge` into a min-heap.\n#[derive(Debug)]\nstruct HeadTail<I>\n    where I: Iterator\n{\n    head: I::Item,\n    tail: I,\n}\n\nimpl<I> HeadTail<I>\n    where I: Iterator\n{\n    /// Constructs a `HeadTail` from an `Iterator`. Returns `None` if the `Iterator` is empty.\n    fn new(mut it: I) -> Option<HeadTail<I>> {\n        let head = it.next();\n        head.map(|h| {\n            HeadTail {\n                head: h,\n                tail: it,\n            }\n        })\n    }\n\n    /// Get the next element and update `head`, returning the old head in `Some`.\n    ///\n    /// Returns `None` when the tail is exhausted (only `head` then remains).\n    fn next(&mut self) -> Option<I::Item> {\n        if let Some(next) = self.tail.next() {\n            Some(replace(&mut self.head, next))\n        } else {\n            None\n        }\n    }\n\n    /// Hints at the size of the sequence, same as the `Iterator` method.\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add_scalar(self.tail.size_hint(), 1)\n    }\n}\n\nimpl<I> Clone for HeadTail<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    clone_fields!(head, tail);\n}\n\n/// Make `data` a heap (min-heap w.r.t the sorting).\nfn heapify<T, S>(data: &mut [T], mut less_than: S)\n    where S: FnMut(&T, &T) -> bool\n{\n    for i in (0..data.len() / 2).rev() {\n        sift_down(data, i, &mut less_than);\n    }\n}\n\n/// Sift down element at `index` (`heap` is a min-heap wrt the ordering)\nfn sift_down<T, S>(heap: &mut [T], index: usize, mut less_than: S)\n    where S: FnMut(&T, &T) -> bool\n{\n    debug_assert!(index <= heap.len());\n    let mut pos = index;\n    let mut child = 2 * pos + 1;\n    // the `pos` conditional is to avoid a bounds check\n    while pos < heap.len() && child < heap.len() {\n        let right = child + 1;\n\n        // pick the smaller of the two children\n        if right < heap.len() && less_than(&heap[right], &heap[child]) {\n            child = right;\n        }\n\n        // sift down is done if we are already in order\n        if !less_than(&heap[child], &heap[pos]) {\n            return;\n        }\n        heap.swap(pos, child);\n        pos = child;\n        child = 2 * pos + 1;\n    }\n}\n\n/// An iterator adaptor that merges an abitrary number of base iterators in ascending order.\n/// If all base iterators are sorted (ascending), the result is sorted.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.kmerge()`](../trait.Itertools.html#method.kmerge) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub type KMerge<I> = KMergeBy<I, KMergeByLt>;\n\npub trait KMergePredicate<T> {\n    fn kmerge_pred(&mut self, a: &T, b: &T) -> bool;\n}\n\n#[derive(Clone)]\npub struct KMergeByLt;\n\nimpl<T: PartialOrd> KMergePredicate<T> for KMergeByLt {\n    fn kmerge_pred(&mut self, a: &T, b: &T) -> bool {\n        a < b\n    }\n}\n\nimpl<T, F: FnMut(&T, &T)->bool> KMergePredicate<T> for F {\n    fn kmerge_pred(&mut self, a: &T, b: &T) -> bool {\n        self(a, b)\n    }\n}\n\n/// Create an iterator that merges elements of the contained iterators using\n/// the ordering function.\n///\n/// Equivalent to `iterable.into_iter().kmerge()`.\n///\n/// ```\n/// use itertools::kmerge;\n///\n/// for elt in kmerge(vec![vec![0, 2, 4], vec![1, 3, 5], vec![6, 7]]) {\n///     /* loop body */\n/// }\n/// ```\npub fn kmerge<I>(iterable: I) -> KMerge<<I::Item as IntoIterator>::IntoIter>\n    where I: IntoIterator,\n          I::Item: IntoIterator,\n          <<I as IntoIterator>::Item as IntoIterator>::Item: PartialOrd\n{\n    kmerge_by(iterable, KMergeByLt)\n}\n\n/// An iterator adaptor that merges an abitrary number of base iterators\n/// according to an ordering function.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.kmerge_by()`](../trait.Itertools.html#method.kmerge_by) for more\n/// information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct KMergeBy<I, F>\n    where I: Iterator,\n{\n    heap: Vec<HeadTail<I>>,\n    less_than: F,\n}\n\nimpl<I, F> fmt::Debug for KMergeBy<I, F>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(KMergeBy, heap);\n}\n\n/// Create an iterator that merges elements of the contained iterators.\n///\n/// Equivalent to `iterable.into_iter().kmerge_by(less_than)`.\npub fn kmerge_by<I, F>(iterable: I, mut less_than: F)\n    -> KMergeBy<<I::Item as IntoIterator>::IntoIter, F>\n    where I: IntoIterator,\n          I::Item: IntoIterator,\n          F: KMergePredicate<<<I as IntoIterator>::Item as IntoIterator>::Item>,\n{\n    let iter = iterable.into_iter();\n    let (lower, _) = iter.size_hint();\n    let mut heap: Vec<_> = Vec::with_capacity(lower);\n    heap.extend(iter.filter_map(|it| HeadTail::new(it.into_iter())));\n    heapify(&mut heap, |a, b| less_than.kmerge_pred(&a.head, &b.head));\n    KMergeBy { heap, less_than }\n}\n\nimpl<I, F> Clone for KMergeBy<I, F>\n    where I: Iterator + Clone,\n          I::Item: Clone,\n          F: Clone,\n{\n    clone_fields!(heap, less_than);\n}\n\nimpl<I, F> Iterator for KMergeBy<I, F>\n    where I: Iterator,\n          F: KMergePredicate<I::Item>\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.heap.is_empty() {\n            return None;\n        }\n        let result = if let Some(next) = self.heap[0].next() {\n            next\n        } else {\n            self.heap.swap_remove(0).head\n        };\n        let less_than = &mut self.less_than;\n        sift_down(&mut self.heap, 0, |a, b| less_than.kmerge_pred(&a.head, &b.head));\n        Some(result)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.heap.iter()\n                 .map(|i| i.size_hint())\n                 .fold1(size_hint::add)\n                 .unwrap_or((0, Some(0)))\n    }\n}\n","traces":[{"line":26,"address":[4264800,4265026,4264976,4264857],"length":1,"stats":{"Line":4},"fn_name":"new<core::ops::range::Range<i32>>"},{"line":27,"address":[4264983,4264815,4264872,4265042],"length":1,"stats":{"Line":10},"fn_name":null},{"line":28,"address":[4265152,4265232,4265054,4264884],"length":1,"stats":{"Line":11},"fn_name":"{{closure}}<itertools::adaptors::Step<core::ops::range::Range<i32>>>"},{"line":29,"address":[4265261,4265193],"length":1,"stats":{"Line":4},"fn_name":null},{"line":30,"address":[4265163,4265250],"length":1,"stats":{"Line":4},"fn_name":null},{"line":31,"address":[4265167,4265254],"length":1,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[4265527,4265488,4265280,4265326],"length":1,"stats":{"Line":3},"fn_name":"next<core::ops::range::Range<i32>>"},{"line":40,"address":[4265497,4265559,4265289,4265338,4265539,4265358],"length":1,"stats":{"Line":10},"fn_name":null},{"line":41,"address":[4265574,4265373],"length":1,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[4265708],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[4267056,4266720,4267436,4266428,4266384,4267100,4267392,4266048,4266764,4266092],"length":1,"stats":{"Line":10},"fn_name":"heapify<itertools::kmerge_impl::HeadTail<itertools::adaptors::Step<core::ops::range::Range<i32>>>,closure-1>"},{"line":64,"address":[4267414,4267456,4267620,4267022,4266112,4266834,4267506,4267694,4266742,4266784,4266070,4266162,4266276,4266406,4266448,4266350,4266498,4266612,4266686,4266948,4267120,4267078,4267170,4267284,4267358],"length":1,"stats":{"Line":38},"fn_name":null},{"line":65,"address":[4266992,4266656,4266320,4267328,4267664],"length":1,"stats":{"Line":8},"fn_name":null},{"line":70,"address":[4279760,4271014,4272400,4273872,4275430,4278288,4270928,4276902,4278374,4275344,4272486,4279846,4276816,4273958],"length":1,"stats":{"Line":15},"fn_name":"sift_down<itertools::kmerge_impl::HeadTail<core::ops::range::Range<i32>>,&mut closure-1>"},{"line":73,"address":[4272439,4273911,4273989,4275383,4278405,4279877,4270967,4271045,4272517,4275461,4276855,4279799,4276933,4278327],"length":1,"stats":{"Line":30},"fn_name":null},{"line":74,"address":[4278423,4279895,4272535,4275479,4274007,4271063,4276951],"length":1,"stats":{"Line":15},"fn_name":null},{"line":75,"address":[4273583,4275495,4276527,4272119,4279911,4272632,4278520,4271079,4279992,4280951,4272551,4275063,4271160,4274104,4275576,4276967,4274023,4277048,4278007,4279471,4278439],"length":1,"stats":{"Line":30},"fn_name":null},{"line":77,"address":[4274146,4272674,4277090,4277980,4276500,4278562,4275036,4275618,4273556,4271202,4272092,4279444,4280924,4280034],"length":1,"stats":{"Line":28},"fn_name":null},{"line":78,"address":[4277267,4280211,4275795,4278067,4276587,4281011,4271379,4275123,4274323,4273643,4278739,4272851,4279531,4272179],"length":1,"stats":{"Line":15},"fn_name":null},{"line":81,"address":[4281041,4272901,4271429,4274373,4276617,4275153,4277317,4275845,4278097,4280261,4278789,4272209,4273673,4279561],"length":1,"stats":{"Line":15},"fn_name":null},{"line":82,"address":[4271737,4279093,4280569,4276149,4277625,4274681,4273205],"length":1,"stats":{"Line":11},"fn_name":null},{"line":86,"address":[4275212,4277641,4272268,4276676,4278156,4273732,4276165,4274697,4279109,4279620,4271753,4281100,4280585,4273221],"length":1,"stats":{"Line":14},"fn_name":null},{"line":89,"address":[4273415,4271951,4276359,4274895,4279303,4277839,4280783],"length":1,"stats":{"Line":13},"fn_name":null},{"line":90,"address":[4274944,4277888,4279352,4280832,4272000,4273464,4276408],"length":1,"stats":{"Line":13},"fn_name":null},{"line":91,"address":[4273480,4273860,4272396,4275340,4276424,4277904,4278284,4279368,4280848,4281228,4274960,4275274,4276804,4272016,4272330,4281162,4276738,4278218,4279682,4279748,4273794],"length":1,"stats":{"Line":13},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":135,"address":[4265824,4265872,4265776,4265920,4265968],"length":1,"stats":{"Line":7},"fn_name":"kmerge<core::iter::adapters::Map<core::ops::range::Range<i32>, closure-0>>"},{"line":140,"address":[4265887,4265975,4265791,4265839,4265935],"length":1,"stats":{"Line":7},"fn_name":null},{"line":168,"address":[4268192,4267728,4268806,4268704,4269168,4267830,4269632,4269270,4269734,4268285],"length":1,"stats":{"Line":10},"fn_name":"kmerge_by<core::iter::adapters::Map<core::ops::range::Range<i32>, closure-0>,itertools::kmerge_impl::KMergeByLt>"},{"line":174,"address":[4268202,4267746,4268722,4269186,4269650],"length":1,"stats":{"Line":10},"fn_name":null},{"line":175,"address":[4267847,4268278,4268302,4268799,4268823,4269287,4269751,4267823,4269263,4269727],"length":1,"stats":{"Line":20},"fn_name":null},{"line":176,"address":[4269297,4269761,4267857,4268315,4268833],"length":1,"stats":{"Line":10},"fn_name":null},{"line":177,"address":[4270604,4270096,4270116,4268850,4269314,4270788,4267874,4270768,4269778,4270592,4270496,4270196,4268335,4270508,4270176],"length":1,"stats":{"Line":30},"fn_name":"{{closure}}<core::iter::adapters::Map<core::ops::range::Range<i32>, closure-0>,itertools::kmerge_impl::KMergeByLt>"},{"line":178,"address":[4270256,4270336,4268921,4270435,4269849,4269385,4270416,4268441,4270707,4270688,4270848,4267945,4270355,4270867,4270275],"length":1,"stats":{"Line":26},"fn_name":"{{closure}}<core::iter::adapters::Map<core::ops::range::Range<i32>, closure-0>,itertools::kmerge_impl::KMergeByLt>"},{"line":196,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":52,"coverable":53},{"path":["/","home","kms","itertools","src","lazy_buffer.rs"],"content":"use std::ops::Index;\n\n#[derive(Debug, Clone)]\npub struct LazyBuffer<I: Iterator> {\n    pub it: I,\n    done: bool,\n    buffer: Vec<I::Item>,\n}\n\nimpl<I> LazyBuffer<I>\nwhere\n    I: Iterator,\n{\n    pub fn new(it: I) -> LazyBuffer<I> {\n        LazyBuffer {\n            it,\n            done: false,\n            buffer: Vec::new(),\n        }\n    }\n\n    pub fn len(&self) -> usize {\n        self.buffer.len()\n    }\n\n    pub fn is_done(&self) -> bool {\n        self.done\n    }\n\n    pub fn get_next(&mut self) -> bool {\n        if self.done {\n            return false;\n        }\n        let next_item = self.it.next();\n        match next_item {\n            Some(x) => {\n                self.buffer.push(x);\n                true\n            }\n            None => {\n                self.done = true;\n                false\n            }\n        }\n    }\n}\n\nimpl<I, J> Index<J> for LazyBuffer<I>\nwhere\n    I: Iterator,\n    I::Item: Sized,\n    Vec<I::Item>: Index<J>\n{\n    type Output = <Vec<I::Item> as Index<J>>::Output;\n\n    fn index(&self, _index: J) -> &Self::Output {\n        self.buffer.index(_index)\n    }\n}\n","traces":[{"line":14,"address":[4682720,4682687,4682560,4682833],"length":1,"stats":{"Line":7},"fn_name":"new<core::ops::range::Range<usize>>"},{"line":18,"address":[4207637],"length":1,"stats":{"Line":7},"fn_name":null},{"line":22,"address":[4207552],"length":1,"stats":{"Line":5},"fn_name":"len<adaptors_no_collect::PanickingCounter>"},{"line":23,"address":[4682521,4682473],"length":1,"stats":{"Line":5},"fn_name":null},{"line":26,"address":[4682864,4682896],"length":1,"stats":{"Line":4},"fn_name":"is_done<core::ops::range::Range<usize>>"},{"line":27,"address":[4207765],"length":1,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[4682928,4683168,4682955,4683195],"length":1,"stats":{"Line":6},"fn_name":"get_next<core::ops::range::Range<i32>>"},{"line":31,"address":[4682937,4683177],"length":1,"stats":{"Line":6},"fn_name":null},{"line":32,"address":[4682999,4683238],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":36,"address":[4683289,4683018,4683051,4683257],"length":1,"stats":{"Line":13},"fn_name":null},{"line":37,"address":[4207911],"length":1,"stats":{"Line":7},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":6},"fn_name":null}],"covered":18,"coverable":19},{"path":["/","home","kms","itertools","src","lib.rs"],"content":"#![warn(missing_docs)]\n#![crate_name=\"itertools\"]\n#![cfg_attr(not(feature = \"use_std\"), no_std)]\n\n//! Extra iterator adaptors, functions and macros.\n//!\n//! To extend [`Iterator`] with methods in this crate, import\n//! the [`Itertools` trait](./trait.Itertools.html):\n//!\n//! ```\n//! use itertools::Itertools;\n//! ```\n//!\n//! Now, new methods like [`interleave`](./trait.Itertools.html#method.interleave)\n//! are available on all iterators:\n//!\n//! ```\n//! use itertools::Itertools;\n//!\n//! let it = (1..3).interleave(vec![-1, -2]);\n//! itertools::assert_equal(it, vec![1, -1, 2, -2]);\n//! ```\n//!\n//! Most iterator methods are also provided as functions (with the benefit\n//! that they convert parameters using [`IntoIterator`]):\n//!\n//! ```\n//! use itertools::interleave;\n//!\n//! for elt in interleave(&[1, 2, 3], &[2, 3, 4]) {\n//!     /* loop body */\n//! }\n//! ```\n//!\n//! ## Crate Features\n//!\n//! - `use_std`\n//!   - Enabled by default.\n//!   - Disable to compile itertools using `#![no_std]`. This disables\n//!     any items that depend on collections (like `group_by`, `unique`,\n//!     `kmerge`, `join` and many more).\n//!\n//! ## Rust Version\n//!\n//! This version of itertools requires Rust 1.32 or later.\n//!\n//! [`Iterator`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html\n#![doc(html_root_url=\"https://docs.rs/itertools/0.8/\")]\n\n#[cfg(not(feature = \"use_std\"))]\nextern crate core as std;\n\npub use either::Either;\n\n#[cfg(feature = \"use_std\")]\nuse std::collections::HashMap;\nuse std::iter::{IntoIterator, once};\nuse std::cmp::Ordering;\nuse std::fmt;\n#[cfg(feature = \"use_std\")]\nuse std::hash::Hash;\n#[cfg(feature = \"use_std\")]\nuse std::fmt::Write;\n#[cfg(feature = \"use_std\")]\ntype VecIntoIter<T> = ::std::vec::IntoIter<T>;\n#[cfg(feature = \"use_std\")]\nuse std::iter::FromIterator;\n\n#[macro_use]\nmod impl_macros;\n\n// for compatibility with no std and macros\n#[doc(hidden)]\npub use std::iter as __std_iter;\n\n/// The concrete iterator types.\npub mod structs {\n    pub use crate::adaptors::{\n        Dedup,\n        DedupBy,\n        DedupWithCount,\n        DedupByWithCount,\n        Interleave,\n        InterleaveShortest,\n        Product,\n        PutBack,\n        Batching,\n        MapInto,\n        MapResults,\n        Merge,\n        MergeBy,\n        TakeWhileRef,\n        WhileSome,\n        Coalesce,\n        TupleCombinations,\n        Positions,\n        Update,\n    };\n    #[allow(deprecated)]\n    pub use crate::adaptors::Step;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::adaptors::MultiProduct;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::combinations::Combinations;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::combinations_with_replacement::CombinationsWithReplacement;\n    pub use crate::cons_tuples_impl::ConsTuples;\n    pub use crate::exactly_one_err::ExactlyOneError;\n    pub use crate::format::{Format, FormatWith};\n    #[cfg(feature = \"use_std\")]\n    pub use crate::groupbylazy::{IntoChunks, Chunk, Chunks, GroupBy, Group, Groups};\n    pub use crate::intersperse::Intersperse;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::kmerge_impl::{KMerge, KMergeBy};\n    pub use crate::merge_join::MergeJoinBy;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::multipeek_impl::MultiPeek;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::peek_nth::PeekNth;\n    pub use crate::pad_tail::PadUsing;\n    pub use crate::peeking_take_while::PeekingTakeWhile;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::permutations::Permutations;\n    pub use crate::process_results_impl::ProcessResults;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::put_back_n_impl::PutBackN;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::rciter_impl::RcIter;\n    pub use crate::repeatn::RepeatN;\n    #[allow(deprecated)]\n    pub use crate::sources::{RepeatCall, Unfold, Iterate};\n    #[cfg(feature = \"use_std\")]\n    pub use crate::tee::Tee;\n    pub use crate::tuple_impl::{TupleBuffer, TupleWindows, CircularTupleWindows, Tuples};\n    #[cfg(feature = \"use_std\")]\n    pub use crate::unique_impl::{Unique, UniqueBy};\n    pub use crate::with_position::WithPosition;\n    pub use crate::zip_eq_impl::ZipEq;\n    pub use crate::zip_longest::ZipLongest;\n    pub use crate::ziptuple::Zip;\n}\n\n/// Traits helpful for using certain `Itertools` methods in generic contexts.\npub mod traits {\n    pub use crate::tuple_impl::HomogeneousTuple;\n}\n\n#[allow(deprecated)]\npub use crate::structs::*;\npub use crate::concat_impl::concat;\npub use crate::cons_tuples_impl::cons_tuples;\npub use crate::diff::diff_with;\npub use crate::diff::Diff;\n#[cfg(feature = \"use_std\")]\npub use crate::kmerge_impl::{kmerge_by};\npub use crate::minmax::MinMaxResult;\npub use crate::peeking_take_while::PeekingNext;\npub use crate::process_results_impl::process_results;\npub use crate::repeatn::repeat_n;\n#[allow(deprecated)]\npub use crate::sources::{repeat_call, unfold, iterate};\npub use crate::with_position::Position;\npub use crate::ziptuple::multizip;\nmod adaptors;\nmod either_or_both;\npub use crate::either_or_both::EitherOrBoth;\n#[doc(hidden)]\npub mod free;\n#[doc(inline)]\npub use crate::free::*;\nmod concat_impl;\nmod cons_tuples_impl;\n#[cfg(feature = \"use_std\")]\nmod combinations;\n#[cfg(feature = \"use_std\")]\nmod combinations_with_replacement;\nmod exactly_one_err;\nmod diff;\nmod format;\n#[cfg(feature = \"use_std\")]\nmod group_map;\n#[cfg(feature = \"use_std\")]\nmod groupbylazy;\nmod intersperse;\n#[cfg(feature = \"use_std\")]\nmod kmerge_impl;\n#[cfg(feature = \"use_std\")]\nmod lazy_buffer;\nmod merge_join;\nmod minmax;\n#[cfg(feature = \"use_std\")]\nmod multipeek_impl;\nmod pad_tail;\n#[cfg(feature = \"use_std\")]\nmod peek_nth;\nmod peeking_take_while;\n#[cfg(feature = \"use_std\")]\nmod permutations;\nmod process_results_impl;\n#[cfg(feature = \"use_std\")]\nmod put_back_n_impl;\n#[cfg(feature = \"use_std\")]\nmod rciter_impl;\nmod repeatn;\nmod size_hint;\nmod sources;\n#[cfg(feature = \"use_std\")]\nmod tee;\nmod tuple_impl;\n#[cfg(feature = \"use_std\")]\nmod unique_impl;\nmod with_position;\nmod zip_eq_impl;\nmod zip_longest;\nmod ziptuple;\n\n#[macro_export]\n/// Create an iterator over the “cartesian product” of iterators.\n///\n/// Iterator element type is like `(A, B, ..., E)` if formed\n/// from iterators `(I, J, ..., M)` with element types `I::Item = A`, `J::Item = B`, etc.\n///\n/// ```\n/// # use itertools::iproduct;\n/// #\n/// # fn main() {\n/// // Iterate over the coordinates of a 4 x 4 x 4 grid\n/// // from (0, 0, 0), (0, 0, 1), .., (0, 1, 0), (0, 1, 1), .. etc until (3, 3, 3)\n/// for (i, j, k) in iproduct!(0..4, 0..4, 0..4) {\n///    // ..\n/// }\n/// # }\n/// ```\nmacro_rules! iproduct {\n    (@flatten $I:expr,) => (\n        $I\n    );\n    (@flatten $I:expr, $J:expr, $($K:expr,)*) => (\n        iproduct!(@flatten $crate::cons_tuples(iproduct!($I, $J)), $($K,)*)\n    );\n    ($I:expr) => (\n        $crate::__std_iter::IntoIterator::into_iter($I)\n    );\n    ($I:expr, $J:expr) => (\n        $crate::Itertools::cartesian_product(iproduct!($I), iproduct!($J))\n    );\n    ($I:expr, $J:expr, $($K:expr),+) => (\n        iproduct!(@flatten iproduct!($I, $J), $($K,)+)\n    );\n}\n\n#[macro_export]\n/// Create an iterator running multiple iterators in lockstep.\n///\n/// The `izip!` iterator yields elements until any subiterator\n/// returns `None`.\n///\n/// This is a version of the standard ``.zip()`` that's supporting more than\n/// two iterators. The iterator element type is a tuple with one element\n/// from each of the input iterators. Just like ``.zip()``, the iteration stops\n/// when the shortest of the inputs reaches its end.\n///\n/// **Note:** The result of this macro is in the general case an iterator\n/// composed of repeated `.zip()` and a `.map()`; it has an anonymous type.\n/// The special cases of one and two arguments produce the equivalent of\n/// `$a.into_iter()` and `$a.into_iter().zip($b)` respectively.\n///\n/// Prefer this macro `izip!()` over [`multizip`] for the performance benefits\n/// of using the standard library `.zip()`.\n///\n/// [`multizip`]: fn.multizip.html\n///\n/// ```\n/// # use itertools::izip;\n/// #\n/// # fn main() {\n///\n/// // iterate over three sequences side-by-side\n/// let mut results = [0, 0, 0, 0];\n/// let inputs = [3, 7, 9, 6];\n///\n/// for (r, index, input) in izip!(&mut results, 0..10, &inputs) {\n///     *r = index * 10 + input;\n/// }\n///\n/// assert_eq!(results, [0 + 3, 10 + 7, 29, 36]);\n/// # }\n/// ```\nmacro_rules! izip {\n    // @closure creates a tuple-flattening closure for .map() call. usage:\n    // @closure partial_pattern => partial_tuple , rest , of , iterators\n    // eg. izip!( @closure ((a, b), c) => (a, b, c) , dd , ee )\n    ( @closure $p:pat => $tup:expr ) => {\n        |$p| $tup\n    };\n\n    // The \"b\" identifier is a different identifier on each recursion level thanks to hygiene.\n    ( @closure $p:pat => ( $($tup:tt)* ) , $_iter:expr $( , $tail:expr )* ) => {\n        izip!(@closure ($p, b) => ( $($tup)*, b ) $( , $tail )*)\n    };\n\n    // unary\n    ($first:expr $(,)*) => {\n        $crate::__std_iter::IntoIterator::into_iter($first)\n    };\n\n    // binary\n    ($first:expr, $second:expr $(,)*) => {\n        izip!($first)\n            .zip($second)\n    };\n\n    // n-ary where n > 2\n    ( $first:expr $( , $rest:expr )* $(,)* ) => {\n        izip!($first)\n            $(\n                .zip($rest)\n            )*\n            .map(\n                izip!(@closure a => (a) $( , $rest )*)\n            )\n    };\n}\n\n/// An [`Iterator`] blanket implementation that provides extra adaptors and\n/// methods.\n///\n/// This trait defines a number of methods. They are divided into two groups:\n///\n/// * *Adaptors* take an iterator and parameter as input, and return\n/// a new iterator value. These are listed first in the trait. An example\n/// of an adaptor is [`.interleave()`](#method.interleave)\n///\n/// * *Regular methods* are those that don't return iterators and instead\n/// return a regular value of some other kind.\n/// [`.next_tuple()`](#method.next_tuple) is an example and the first regular\n/// method in the list.\n///\n/// [`Iterator`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html\npub trait Itertools : Iterator {\n    // adaptors\n\n    /// Alternate elements from two iterators until both have run out.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = (1..7).interleave(vec![-1, -2]);\n    /// itertools::assert_equal(it, vec![1, -1, 2, -2, 3, 4, 5, 6]);\n    /// ```\n    fn interleave<J>(self, other: J) -> Interleave<Self, J::IntoIter>\n        where J: IntoIterator<Item = Self::Item>,\n              Self: Sized\n    {\n        interleave(self, other)\n    }\n\n    /// Alternate elements from two iterators until at least one of them has run\n    /// out.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = (1..7).interleave_shortest(vec![-1, -2]);\n    /// itertools::assert_equal(it, vec![1, -1, 2, -2, 3]);\n    /// ```\n    fn interleave_shortest<J>(self, other: J) -> InterleaveShortest<Self, J::IntoIter>\n        where J: IntoIterator<Item = Self::Item>,\n              Self: Sized\n    {\n        adaptors::interleave_shortest(self, other.into_iter())\n    }\n\n    /// An iterator adaptor to insert a particular value\n    /// between each element of the adapted iterator.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// itertools::assert_equal((0..3).intersperse(8), vec![0, 8, 1, 8, 2]);\n    /// ```\n    fn intersperse(self, element: Self::Item) -> Intersperse<Self>\n        where Self: Sized,\n              Self::Item: Clone\n    {\n        intersperse::intersperse(self, element)\n    }\n\n    /// Create an iterator which iterates over both this and the specified\n    /// iterator simultaneously, yielding pairs of two optional elements.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// As long as neither input iterator is exhausted yet, it yields two values\n    /// via `EitherOrBoth::Both`.\n    ///\n    /// When the parameter iterator is exhausted, it only yields a value from the\n    /// `self` iterator via `EitherOrBoth::Left`.\n    ///\n    /// When the `self` iterator is exhausted, it only yields a value from the\n    /// parameter iterator via `EitherOrBoth::Right`.\n    ///\n    /// When both iterators return `None`, all further invocations of `.next()`\n    /// will return `None`.\n    ///\n    /// Iterator element type is\n    /// [`EitherOrBoth<Self::Item, J::Item>`](enum.EitherOrBoth.html).\n    ///\n    /// ```rust\n    /// use itertools::EitherOrBoth::{Both, Right};\n    /// use itertools::Itertools;\n    /// let it = (0..1).zip_longest(1..3);\n    /// itertools::assert_equal(it, vec![Both(0, 1), Right(2)]);\n    /// ```\n    #[inline]\n    fn zip_longest<J>(self, other: J) -> ZipLongest<Self, J::IntoIter>\n        where J: IntoIterator,\n              Self: Sized\n    {\n        zip_longest::zip_longest(self, other.into_iter())\n    }\n\n    /// Create an iterator which iterates over both this and the specified\n    /// iterator simultaneously, yielding pairs of elements.\n    ///\n    /// **Panics** if the iterators reach an end and they are not of equal\n    /// lengths.\n    #[inline]\n    fn zip_eq<J>(self, other: J) -> ZipEq<Self, J::IntoIter>\n        where J: IntoIterator,\n              Self: Sized\n    {\n        zip_eq(self, other)\n    }\n\n    /// A “meta iterator adaptor”. Its closure receives a reference to the\n    /// iterator and may pick off as many elements as it likes, to produce the\n    /// next iterator element.\n    ///\n    /// Iterator element type is `B`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // An adaptor that gathers elements in pairs\n    /// let pit = (0..4).batching(|it| {\n    ///            match it.next() {\n    ///                None => None,\n    ///                Some(x) => match it.next() {\n    ///                    None => None,\n    ///                    Some(y) => Some((x, y)),\n    ///                }\n    ///            }\n    ///        });\n    ///\n    /// itertools::assert_equal(pit, vec![(0, 1), (2, 3)]);\n    /// ```\n    ///\n    fn batching<B, F>(self, f: F) -> Batching<Self, F>\n        where F: FnMut(&mut Self) -> Option<B>,\n              Self: Sized\n    {\n        adaptors::batching(self, f)\n    }\n\n    /// Return an *iterable* that can group iterator elements.\n    /// Consecutive elements that map to the same key (“runs”), are assigned\n    /// to the same group.\n    ///\n    /// `GroupBy` is the storage for the lazy grouping operation.\n    ///\n    /// If the groups are consumed in order, or if each group's iterator is\n    /// dropped without keeping it around, then `GroupBy` uses no\n    /// allocations.  It needs allocations only if several group iterators\n    /// are alive at the same time.\n    ///\n    /// This type implements `IntoIterator` (it is **not** an iterator\n    /// itself), because the group iterators need to borrow from this\n    /// value. It should be stored in a local variable or temporary and\n    /// iterated.\n    ///\n    /// Iterator element type is `(K, Group)`: the group's key and the\n    /// group iterator.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // group data into runs of larger than zero or not.\n    /// let data = vec![1, 3, -2, -2, 1, 0, 1, 2];\n    /// // groups:     |---->|------>|--------->|\n    ///\n    /// // Note: The `&` is significant here, `GroupBy` is iterable\n    /// // only by reference. You can also call `.into_iter()` explicitly.\n    /// let mut data_grouped = Vec::new();\n    /// for (key, group) in &data.into_iter().group_by(|elt| *elt >= 0) {\n    ///     data_grouped.push((key, group.collect()));\n    /// }\n    /// assert_eq!(data_grouped, vec![(true, vec![1, 3]), (false, vec![-2, -2]), (true, vec![1, 0, 1, 2])]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn group_by<K, F>(self, key: F) -> GroupBy<K, Self, F>\n        where Self: Sized,\n              F: FnMut(&Self::Item) -> K,\n              K: PartialEq,\n    {\n        groupbylazy::new(self, key)\n    }\n\n    /// Return an *iterable* that can chunk the iterator.\n    ///\n    /// Yield subiterators (chunks) that each yield a fixed number elements,\n    /// determined by `size`. The last chunk will be shorter if there aren't\n    /// enough elements.\n    ///\n    /// `IntoChunks` is based on `GroupBy`: it is iterable (implements\n    /// `IntoIterator`, **not** `Iterator`), and it only buffers if several\n    /// chunk iterators are alive at the same time.\n    ///\n    /// Iterator element type is `Chunk`, each chunk's iterator.\n    ///\n    /// **Panics** if `size` is 0.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![1, 1, 2, -2, 6, 0, 3, 1];\n    /// //chunk size=3 |------->|-------->|--->|\n    ///\n    /// // Note: The `&` is significant here, `IntoChunks` is iterable\n    /// // only by reference. You can also call `.into_iter()` explicitly.\n    /// for chunk in &data.into_iter().chunks(3) {\n    ///     // Check that the sum of each chunk is 4.\n    ///     assert_eq!(4, chunk.sum());\n    /// }\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn chunks(self, size: usize) -> IntoChunks<Self>\n        where Self: Sized,\n    {\n        assert!(size != 0);\n        groupbylazy::new_chunks(self, size)\n    }\n\n    /// Return an iterator over all contiguous windows producing tuples of\n    /// a specific size (up to 4).\n    ///\n    /// `tuple_windows` clones the iterator elements so that they can be\n    /// part of successive windows, this makes it most suited for iterators\n    /// of references and other values that are cheap to copy.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// let mut v = Vec::new();\n    /// for (a, b) in (1..5).tuple_windows() {\n    ///     v.push((a, b));\n    /// }\n    /// assert_eq!(v, vec![(1, 2), (2, 3), (3, 4)]);\n    ///\n    /// let mut it = (1..5).tuple_windows();\n    /// assert_eq!(Some((1, 2, 3)), it.next());\n    /// assert_eq!(Some((2, 3, 4)), it.next());\n    /// assert_eq!(None, it.next());\n    ///\n    /// // this requires a type hint\n    /// let it = (1..5).tuple_windows::<(_, _, _)>();\n    /// itertools::assert_equal(it, vec![(1, 2, 3), (2, 3, 4)]);\n    ///\n    /// // you can also specify the complete type\n    /// use itertools::TupleWindows;\n    /// use std::ops::Range;\n    ///\n    /// let it: TupleWindows<Range<u32>, (u32, u32, u32)> = (1..5).tuple_windows();\n    /// itertools::assert_equal(it, vec![(1, 2, 3), (2, 3, 4)]);\n    /// ```\n    fn tuple_windows<T>(self) -> TupleWindows<Self, T>\n        where Self: Sized + Iterator<Item = T::Item>,\n              T: traits::HomogeneousTuple,\n              T::Item: Clone\n    {\n        tuple_impl::tuple_windows(self)\n    }\n\n    /// Return an iterator over all windows, wrapping back to the first\n    /// elements when the window would otherwise exceed the length of the\n    /// iterator, producing tuples of a specific size (up to 4).\n    ///\n    /// `circular_tuple_windows` clones the iterator elements so that they can be\n    /// part of successive windows, this makes it most suited for iterators\n    /// of references and other values that are cheap to copy.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// let mut v = Vec::new();\n    /// for (a, b) in (1..5).circular_tuple_windows() {\n    ///     v.push((a, b));\n    /// }\n    /// assert_eq!(v, vec![(1, 2), (2, 3), (3, 4), (4, 1)]);\n    ///\n    /// let mut it = (1..5).circular_tuple_windows();\n    /// assert_eq!(Some((1, 2, 3)), it.next());\n    /// assert_eq!(Some((2, 3, 4)), it.next());\n    /// assert_eq!(Some((3, 4, 1)), it.next());\n    /// assert_eq!(Some((4, 1, 2)), it.next());\n    /// assert_eq!(None, it.next());\n    ///\n    /// // this requires a type hint\n    /// let it = (1..5).circular_tuple_windows::<(_, _, _)>();\n    /// itertools::assert_equal(it, vec![(1, 2, 3), (2, 3, 4), (3, 4, 1), (4, 1, 2)]);\n    /// ```\n    fn circular_tuple_windows<T>(self) -> CircularTupleWindows<Self, T>\n        where Self: Sized + Clone + Iterator<Item = T::Item> + ExactSizeIterator,\n              T: tuple_impl::TupleCollect + Clone,\n              T::Item: Clone\n    {\n        tuple_impl::circular_tuple_windows(self)\n    }\n    /// Return an iterator that groups the items in tuples of a specific size\n    /// (up to 4).\n    ///\n    /// See also the method [`.next_tuple()`](#method.next_tuple).\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// let mut v = Vec::new();\n    /// for (a, b) in (1..5).tuples() {\n    ///     v.push((a, b));\n    /// }\n    /// assert_eq!(v, vec![(1, 2), (3, 4)]);\n    ///\n    /// let mut it = (1..7).tuples();\n    /// assert_eq!(Some((1, 2, 3)), it.next());\n    /// assert_eq!(Some((4, 5, 6)), it.next());\n    /// assert_eq!(None, it.next());\n    ///\n    /// // this requires a type hint\n    /// let it = (1..7).tuples::<(_, _, _)>();\n    /// itertools::assert_equal(it, vec![(1, 2, 3), (4, 5, 6)]);\n    ///\n    /// // you can also specify the complete type\n    /// use itertools::Tuples;\n    /// use std::ops::Range;\n    ///\n    /// let it: Tuples<Range<u32>, (u32, u32, u32)> = (1..7).tuples();\n    /// itertools::assert_equal(it, vec![(1, 2, 3), (4, 5, 6)]);\n    /// ```\n    ///\n    /// See also [`Tuples::into_buffer`](structs/struct.Tuples.html#method.into_buffer).\n    fn tuples<T>(self) -> Tuples<Self, T>\n        where Self: Sized + Iterator<Item = T::Item>,\n              T: traits::HomogeneousTuple\n    {\n        tuple_impl::tuples(self)\n    }\n\n    /// Split into an iterator pair that both yield all elements from\n    /// the original iterator.\n    ///\n    /// **Note:** If the iterator is clonable, prefer using that instead\n    /// of using this method. It is likely to be more efficient.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// let xs = vec![0, 1, 2, 3];\n    ///\n    /// let (mut t1, t2) = xs.into_iter().tee();\n    /// itertools::assert_equal(t1.next(), Some(0));\n    /// itertools::assert_equal(t2, 0..4);\n    /// itertools::assert_equal(t1, 1..4);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn tee(self) -> (Tee<Self>, Tee<Self>)\n        where Self: Sized,\n              Self::Item: Clone\n    {\n        tee::new(self)\n    }\n\n    /// Return an iterator adaptor that steps `n` elements in the base iterator\n    /// for each iteration.\n    ///\n    /// The iterator steps by yielding the next element from the base iterator,\n    /// then skipping forward `n - 1` elements.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// **Panics** if the step is 0.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = (0..8).step(3);\n    /// itertools::assert_equal(it, vec![0, 3, 6]);\n    /// ```\n    #[deprecated(note=\"Use std .step_by() instead\", since=\"0.8\")]\n    #[allow(deprecated)]\n    fn step(self, n: usize) -> Step<Self>\n        where Self: Sized\n    {\n        adaptors::step(self, n)\n    }\n\n    /// Convert each item of the iterator using the `Into` trait.\n    ///\n    /// ```rust\n    /// use itertools::Itertools;\n    ///\n    /// (1i32..42i32).map_into::<f64>().collect_vec();\n    /// ```\n    fn map_into<R>(self) -> MapInto<Self, R>\n        where Self: Sized,\n              Self::Item: Into<R>,\n    {\n        adaptors::map_into(self)\n    }\n\n    /// Return an iterator adaptor that applies the provided closure\n    /// to every `Result::Ok` value. `Result::Err` values are\n    /// unchanged.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let input = vec![Ok(41), Err(false), Ok(11)];\n    /// let it = input.into_iter().map_results(|i| i + 1);\n    /// itertools::assert_equal(it, vec![Ok(42), Err(false), Ok(12)]);\n    /// ```\n    fn map_results<F, T, U, E>(self, f: F) -> MapResults<Self, F>\n        where Self: Iterator<Item = Result<T, E>> + Sized,\n              F: FnMut(T) -> U,\n    {\n        adaptors::map_results(self, f)\n    }\n\n    /// Return an iterator adaptor that merges the two base iterators in\n    /// ascending order.  If both base iterators are sorted (ascending), the\n    /// result is sorted.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a = (0..11).step(3);\n    /// let b = (0..11).step(5);\n    /// let it = a.merge(b);\n    /// itertools::assert_equal(it, vec![0, 0, 3, 5, 6, 9, 10]);\n    /// ```\n    fn merge<J>(self, other: J) -> Merge<Self, J::IntoIter>\n        where Self: Sized,\n              Self::Item: PartialOrd,\n              J: IntoIterator<Item = Self::Item>\n    {\n        merge(self, other)\n    }\n\n    /// Return an iterator adaptor that merges the two base iterators in order.\n    /// This is much like `.merge()` but allows for a custom ordering.\n    ///\n    /// This can be especially useful for sequences of tuples.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a = (0..).zip(\"bc\".chars());\n    /// let b = (0..).zip(\"ad\".chars());\n    /// let it = a.merge_by(b, |x, y| x.1 <= y.1);\n    /// itertools::assert_equal(it, vec![(0, 'a'), (0, 'b'), (1, 'c'), (1, 'd')]);\n    /// ```\n\n    fn merge_by<J, F>(self, other: J, is_first: F) -> MergeBy<Self, J::IntoIter, F>\n        where Self: Sized,\n              J: IntoIterator<Item = Self::Item>,\n              F: FnMut(&Self::Item, &Self::Item) -> bool\n    {\n        adaptors::merge_by_new(self, other.into_iter(), is_first)\n    }\n\n    /// Create an iterator that merges items from both this and the specified\n    /// iterator in ascending order.\n    ///\n    /// It chooses whether to pair elements based on the `Ordering` returned by the\n    /// specified compare function. At any point, inspecting the tip of the\n    /// iterators `I` and `J` as items `i` of type `I::Item` and `j` of type\n    /// `J::Item` respectively, the resulting iterator will:\n    ///\n    /// - Emit `EitherOrBoth::Left(i)` when `i < j`,\n    ///   and remove `i` from its source iterator\n    /// - Emit `EitherOrBoth::Right(j)` when `i > j`,\n    ///   and remove `j` from its source iterator\n    /// - Emit `EitherOrBoth::Both(i, j)` when  `i == j`,\n    ///   and remove both `i` and `j` from their respective source iterators\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// use itertools::EitherOrBoth::{Left, Right, Both};\n    ///\n    /// let ki = (0..10).step(3);\n    /// let ku = (0..10).step(5);\n    /// let ki_ku = ki.merge_join_by(ku, |i, j| i.cmp(j)).map(|either| {\n    ///     match either {\n    ///         Left(_) => \"Ki\",\n    ///         Right(_) => \"Ku\",\n    ///         Both(_, _) => \"KiKu\"\n    ///     }\n    /// });\n    ///\n    /// itertools::assert_equal(ki_ku, vec![\"KiKu\", \"Ki\", \"Ku\", \"Ki\", \"Ki\"]);\n    /// ```\n    #[inline]\n    fn merge_join_by<J, F>(self, other: J, cmp_fn: F) -> MergeJoinBy<Self, J::IntoIter, F>\n        where J: IntoIterator,\n              F: FnMut(&Self::Item, &J::Item) -> std::cmp::Ordering,\n              Self: Sized\n    {\n        merge_join_by(self, other, cmp_fn)\n    }\n\n    /// Return an iterator adaptor that flattens an iterator of iterators by\n    /// merging them in ascending order.\n    ///\n    /// If all base iterators are sorted (ascending), the result is sorted.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a = (0..6).step(3);\n    /// let b = (1..6).step(3);\n    /// let c = (2..6).step(3);\n    /// let it = vec![a, b, c].into_iter().kmerge();\n    /// itertools::assert_equal(it, vec![0, 1, 2, 3, 4, 5]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn kmerge(self) -> KMerge<<Self::Item as IntoIterator>::IntoIter>\n        where Self: Sized,\n              Self::Item: IntoIterator,\n              <Self::Item as IntoIterator>::Item: PartialOrd,\n    {\n        kmerge(self)\n    }\n\n    /// Return an iterator adaptor that flattens an iterator of iterators by\n    /// merging them according to the given closure.\n    ///\n    /// The closure `first` is called with two elements *a*, *b* and should\n    /// return `true` if *a* is ordered before *b*.\n    ///\n    /// If all base iterators are sorted according to `first`, the result is\n    /// sorted.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a = vec![-1f64, 2., 3., -5., 6., -7.];\n    /// let b = vec![0., 2., -4.];\n    /// let mut it = vec![a, b].into_iter().kmerge_by(|a, b| a.abs() < b.abs());\n    /// assert_eq!(it.next(), Some(0.));\n    /// assert_eq!(it.last(), Some(-7.));\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn kmerge_by<F>(self, first: F)\n        -> KMergeBy<<Self::Item as IntoIterator>::IntoIter, F>\n        where Self: Sized,\n              Self::Item: IntoIterator,\n              F: FnMut(&<Self::Item as IntoIterator>::Item,\n                       &<Self::Item as IntoIterator>::Item) -> bool\n    {\n        kmerge_by(self, first)\n    }\n\n    /// Return an iterator adaptor that iterates over the cartesian product of\n    /// the element sets of two iterators `self` and `J`.\n    ///\n    /// Iterator element type is `(Self::Item, J::Item)`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = (0..2).cartesian_product(\"αβ\".chars());\n    /// itertools::assert_equal(it, vec![(0, 'α'), (0, 'β'), (1, 'α'), (1, 'β')]);\n    /// ```\n    fn cartesian_product<J>(self, other: J) -> Product<Self, J::IntoIter>\n        where Self: Sized,\n              Self::Item: Clone,\n              J: IntoIterator,\n              J::IntoIter: Clone\n    {\n        adaptors::cartesian_product(self, other.into_iter())\n    }\n\n    /// Return an iterator adaptor that iterates over the cartesian product of\n    /// all subiterators returned by meta-iterator `self`.\n    ///\n    /// All provided iterators must yield the same `Item` type. To generate\n    /// the product of iterators yielding multiple types, use the\n    /// [`iproduct`](macro.iproduct.html) macro instead.\n    ///\n    ///\n    /// The iterator element type is `Vec<T>`, where `T` is the iterator element\n    /// of the subiterators.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// let mut multi_prod = (0..3).map(|i| (i * 2)..(i * 2 + 2))\n    ///     .multi_cartesian_product();\n    /// assert_eq!(multi_prod.next(), Some(vec![0, 2, 4]));\n    /// assert_eq!(multi_prod.next(), Some(vec![0, 2, 5]));\n    /// assert_eq!(multi_prod.next(), Some(vec![0, 3, 4]));\n    /// assert_eq!(multi_prod.next(), Some(vec![0, 3, 5]));\n    /// assert_eq!(multi_prod.next(), Some(vec![1, 2, 4]));\n    /// assert_eq!(multi_prod.next(), Some(vec![1, 2, 5]));\n    /// assert_eq!(multi_prod.next(), Some(vec![1, 3, 4]));\n    /// assert_eq!(multi_prod.next(), Some(vec![1, 3, 5]));\n    /// assert_eq!(multi_prod.next(), None);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn multi_cartesian_product(self) -> MultiProduct<<Self::Item as IntoIterator>::IntoIter>\n        where Self: Iterator + Sized,\n              Self::Item: IntoIterator,\n              <Self::Item as IntoIterator>::IntoIter: Clone,\n              <Self::Item as IntoIterator>::Item: Clone\n    {\n        adaptors::multi_cartesian_product(self)\n    }\n\n    /// Return an iterator adaptor that uses the passed-in closure to\n    /// optionally merge together consecutive elements.\n    ///\n    /// The closure `f` is passed two elements, `previous` and `current` and may\n    /// return either (1) `Ok(combined)` to merge the two values or\n    /// (2) `Err((previous', current'))` to indicate they can't be merged.\n    /// In (2), the value `previous'` is emitted by the iterator.\n    /// Either (1) `combined` or (2) `current'` becomes the previous value\n    /// when coalesce continues with the next pair of elements to merge. The\n    /// value that remains at the end is also emitted by the iterator.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // sum same-sign runs together\n    /// let data = vec![-1., -2., -3., 3., 1., 0., -1.];\n    /// itertools::assert_equal(data.into_iter().coalesce(|x, y|\n    ///         if (x >= 0.) == (y >= 0.) {\n    ///             Ok(x + y)\n    ///         } else {\n    ///             Err((x, y))\n    ///         }),\n    ///         vec![-6., 4., -1.]);\n    /// ```\n    fn coalesce<F>(self, f: F) -> Coalesce<Self, F>\n        where Self: Sized,\n              F: FnMut(Self::Item, Self::Item)\n                       -> Result<Self::Item, (Self::Item, Self::Item)>\n    {\n        adaptors::coalesce(self, f)\n    }\n\n    /// Remove duplicates from sections of consecutive identical elements.\n    /// If the iterator is sorted, all elements will be unique.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![1., 1., 2., 3., 3., 2., 2.];\n    /// itertools::assert_equal(data.into_iter().dedup(),\n    ///                         vec![1., 2., 3., 2.]);\n    /// ```\n    fn dedup(self) -> Dedup<Self>\n        where Self: Sized,\n              Self::Item: PartialEq,\n    {\n        adaptors::dedup(self)\n    }\n\n    /// Remove duplicates from sections of consecutive identical elements,\n    /// determining equality using a comparison function.\n    /// If the iterator is sorted, all elements will be unique.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![(0, 1.), (1, 1.), (0, 2.), (0, 3.), (1, 3.), (1, 2.), (2, 2.)];\n    /// itertools::assert_equal(data.into_iter().dedup_by(|x, y| x.1 == y.1),\n    ///                         vec![(0, 1.), (0, 2.), (0, 3.), (1, 2.)]);\n    /// ```\n    fn dedup_by<Cmp>(self, cmp: Cmp) -> DedupBy<Self, Cmp>\n        where Self: Sized,\n              Cmp: FnMut(&Self::Item, &Self::Item)->bool,\n    {\n        adaptors::dedup_by(self, cmp)\n    }\n\n    /// Remove duplicates from sections of consecutive identical elements, while keeping a count of\n    /// how many repeated elements were present.\n    /// If the iterator is sorted, all elements will be unique.\n    ///\n    /// Iterator element type is `(usize, Self::Item)`.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![1., 1., 2., 3., 3., 2., 2.];\n    /// itertools::assert_equal(data.into_iter().dedup_with_count(),\n    ///                         vec![(2, 1.), (1, 2.), (2, 3.), (2, 2.)]);\n    /// ```\n    fn dedup_with_count(self) -> DedupWithCount<Self>\n        where Self: Sized,\n    {\n        adaptors::dedup_with_count(self)\n    }\n\n    /// Remove duplicates from sections of consecutive identical elements, while keeping a count of\n    /// how many repeated elements were present.\n    /// This will determine equality using a comparison function.\n    /// If the iterator is sorted, all elements will be unique.\n    ///\n    /// Iterator element type is `(usize, Self::Item)`.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![(0, 1.), (1, 1.), (0, 2.), (0, 3.), (1, 3.), (1, 2.), (2, 2.)];\n    /// itertools::assert_equal(data.into_iter().dedup_by_with_count(|x, y| x.1 == y.1),\n    ///                         vec![(2, (0, 1.)), (1, (0, 2.)), (2, (0, 3.)), (2, (1, 2.))]);\n    /// ```\n    fn dedup_by_with_count<Cmp>(self, cmp: Cmp) -> DedupByWithCount<Self, Cmp>\n        where Self: Sized,\n              Cmp: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        adaptors::dedup_by_with_count(self, cmp)\n    }\n\n    /// Return an iterator adaptor that filters out elements that have\n    /// already been produced once during the iteration. Duplicates\n    /// are detected using hash and equality.\n    ///\n    /// Clones of visited elements are stored in a hash set in the\n    /// iterator.\n    ///\n    /// The iterator is stable, returning the non-duplicate items in the order\n    /// in which they occur in the adapted iterator. In a set of duplicate\n    /// items, the first item encountered is the item retained.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![10, 20, 30, 20, 40, 10, 50];\n    /// itertools::assert_equal(data.into_iter().unique(),\n    ///                         vec![10, 20, 30, 40, 50]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn unique(self) -> Unique<Self>\n        where Self: Sized,\n              Self::Item: Clone + Eq + Hash\n    {\n        unique_impl::unique(self)\n    }\n\n    /// Return an iterator adaptor that filters out elements that have\n    /// already been produced once during the iteration.\n    ///\n    /// Duplicates are detected by comparing the key they map to\n    /// with the keying function `f` by hash and equality.\n    /// The keys are stored in a hash set in the iterator.\n    ///\n    /// The iterator is stable, returning the non-duplicate items in the order\n    /// in which they occur in the adapted iterator. In a set of duplicate\n    /// items, the first item encountered is the item retained.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![\"a\", \"bb\", \"aa\", \"c\", \"ccc\"];\n    /// itertools::assert_equal(data.into_iter().unique_by(|s| s.len()),\n    ///                         vec![\"a\", \"bb\", \"ccc\"]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn unique_by<V, F>(self, f: F) -> UniqueBy<Self, V, F>\n        where Self: Sized,\n              V: Eq + Hash,\n              F: FnMut(&Self::Item) -> V\n    {\n        unique_impl::unique_by(self, f)\n    }\n\n    /// Return an iterator adaptor that borrows from this iterator and\n    /// takes items while the closure `accept` returns `true`.\n    ///\n    /// This adaptor can only be used on iterators that implement `PeekingNext`\n    /// like `.peekable()`, `put_back` and a few other collection iterators.\n    ///\n    /// The last and rejected element (first `false`) is still available when\n    /// `peeking_take_while` is done.\n    ///\n    ///\n    /// See also [`.take_while_ref()`](#method.take_while_ref)\n    /// which is a similar adaptor.\n    fn peeking_take_while<F>(&mut self, accept: F) -> PeekingTakeWhile<Self, F>\n        where Self: Sized + PeekingNext,\n              F: FnMut(&Self::Item) -> bool,\n    {\n        peeking_take_while::peeking_take_while(self, accept)\n    }\n\n    /// Return an iterator adaptor that borrows from a `Clone`-able iterator\n    /// to only pick off elements while the predicate `accept` returns `true`.\n    ///\n    /// It uses the `Clone` trait to restore the original iterator so that the\n    /// last and rejected element (first `false`) is still available when\n    /// `take_while_ref` is done.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut hexadecimals = \"0123456789abcdef\".chars();\n    ///\n    /// let decimals = hexadecimals.take_while_ref(|c| c.is_numeric())\n    ///                            .collect::<String>();\n    /// assert_eq!(decimals, \"0123456789\");\n    /// assert_eq!(hexadecimals.next(), Some('a'));\n    ///\n    /// ```\n    fn take_while_ref<F>(&mut self, accept: F) -> TakeWhileRef<Self, F>\n        where Self: Clone,\n              F: FnMut(&Self::Item) -> bool\n    {\n        adaptors::take_while_ref(self, accept)\n    }\n\n    /// Return an iterator adaptor that filters `Option<A>` iterator elements\n    /// and produces `A`. Stops on the first `None` encountered.\n    ///\n    /// Iterator element type is `A`, the unwrapped element.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // List all hexadecimal digits\n    /// itertools::assert_equal(\n    ///     (0..).map(|i| std::char::from_digit(i, 16)).while_some(),\n    ///     \"0123456789abcdef\".chars());\n    ///\n    /// ```\n    fn while_some<A>(self) -> WhileSome<Self>\n        where Self: Sized + Iterator<Item = Option<A>>\n    {\n        adaptors::while_some(self)\n    }\n\n    /// Return an iterator adaptor that iterates over the combinations of the\n    /// elements from an iterator.\n    ///\n    /// Iterator element can be any homogeneous tuple of type `Self::Item` with\n    /// size up to 4.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut v = Vec::new();\n    /// for (a, b) in (1..5).tuple_combinations() {\n    ///     v.push((a, b));\n    /// }\n    /// assert_eq!(v, vec![(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]);\n    ///\n    /// let mut it = (1..5).tuple_combinations();\n    /// assert_eq!(Some((1, 2, 3)), it.next());\n    /// assert_eq!(Some((1, 2, 4)), it.next());\n    /// assert_eq!(Some((1, 3, 4)), it.next());\n    /// assert_eq!(Some((2, 3, 4)), it.next());\n    /// assert_eq!(None, it.next());\n    ///\n    /// // this requires a type hint\n    /// let it = (1..5).tuple_combinations::<(_, _, _)>();\n    /// itertools::assert_equal(it, vec![(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]);\n    ///\n    /// // you can also specify the complete type\n    /// use itertools::TupleCombinations;\n    /// use std::ops::Range;\n    ///\n    /// let it: TupleCombinations<Range<u32>, (u32, u32, u32)> = (1..5).tuple_combinations();\n    /// itertools::assert_equal(it, vec![(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]);\n    /// ```\n    fn tuple_combinations<T>(self) -> TupleCombinations<Self, T>\n        where Self: Sized + Clone,\n              Self::Item: Clone,\n              T: adaptors::HasCombination<Self>,\n    {\n        adaptors::tuple_combinations(self)\n    }\n\n    /// Return an iterator adaptor that iterates over the `k`-length combinations of\n    /// the elements from an iterator.\n    ///\n    /// Iterator element type is `Vec<Self::Item>`. The iterator produces a new Vec per iteration,\n    /// and clones the iterator elements.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = (1..5).combinations(3);\n    /// itertools::assert_equal(it, vec![\n    ///     vec![1, 2, 3],\n    ///     vec![1, 2, 4],\n    ///     vec![1, 3, 4],\n    ///     vec![2, 3, 4],\n    /// ]);\n    /// ```\n    ///\n    /// Note: Combinations does not take into account the equality of the iterated values.\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = vec![1, 2, 2].into_iter().combinations(2);\n    /// itertools::assert_equal(it, vec![\n    ///     vec![1, 2], // Note: these are the same\n    ///     vec![1, 2], // Note: these are the same\n    ///     vec![2, 2],\n    /// ]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn combinations(self, k: usize) -> Combinations<Self>\n        where Self: Sized,\n              Self::Item: Clone\n    {\n        combinations::combinations(self, k)\n    }\n\n    /// Return an iterator that iterates over the `k`-length combinations of\n    /// the elements from an iterator, with replacement.\n    ///\n    /// Iterator element type is `Vec<Self::Item>`. The iterator produces a new Vec per iteration,\n    /// and clones the iterator elements.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = (1..4).combinations_with_replacement(2);\n    /// itertools::assert_equal(it, vec![\n    ///     vec![1, 1],\n    ///     vec![1, 2],\n    ///     vec![1, 3],\n    ///     vec![2, 2],\n    ///     vec![2, 3],\n    ///     vec![3, 3],\n    /// ]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn combinations_with_replacement(self, k: usize) -> CombinationsWithReplacement<Self>\n    where\n        Self: Sized,\n        Self::Item: Clone,\n    {\n        combinations_with_replacement::combinations_with_replacement(self, k)\n    }\n\n    /// Return an iterator adaptor that iterates over all k-permutations of the\n    /// elements from an iterator.\n    ///\n    /// Iterator element type is `Vec<Self::Item>` with length `k`. The iterator\n    /// produces a new Vec per iteration, and clones the iterator elements.\n    ///\n    /// If `k` is greater than the length of the input iterator, the resultant\n    /// iterator adaptor will be empty.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let perms = (5..8).permutations(2);\n    /// itertools::assert_equal(perms, vec![\n    ///     vec![5, 6],\n    ///     vec![5, 7],\n    ///     vec![6, 5],\n    ///     vec![6, 7],\n    ///     vec![7, 5],\n    ///     vec![7, 6],\n    /// ]);\n    /// ```\n    ///\n    /// Note: Permutations does not take into account the equality of the iterated values.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = vec![2, 2].into_iter().permutations(2);\n    /// itertools::assert_equal(it, vec![\n    ///     vec![2, 2], // Note: these are the same\n    ///     vec![2, 2], // Note: these are the same\n    /// ]);\n    /// ```\n    ///\n    /// Note: The source iterator is collected lazily, and will not be\n    /// re-iterated if the permutations adaptor is completed and re-iterated.\n    #[cfg(feature = \"use_std\")]\n    fn permutations(self, k: usize) -> Permutations<Self>\n        where Self: Sized,\n              Self::Item: Clone\n    {\n        permutations::permutations(self, k)\n    }\n\n    /// Return an iterator adaptor that pads the sequence to a minimum length of\n    /// `min` by filling missing elements using a closure `f`.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = (0..5).pad_using(10, |i| 2*i);\n    /// itertools::assert_equal(it, vec![0, 1, 2, 3, 4, 10, 12, 14, 16, 18]);\n    ///\n    /// let it = (0..10).pad_using(5, |i| 2*i);\n    /// itertools::assert_equal(it, vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n    ///\n    /// let it = (0..5).pad_using(10, |i| 2*i).rev();\n    /// itertools::assert_equal(it, vec![18, 16, 14, 12, 10, 4, 3, 2, 1, 0]);\n    /// ```\n    fn pad_using<F>(self, min: usize, f: F) -> PadUsing<Self, F>\n        where Self: Sized,\n              F: FnMut(usize) -> Self::Item\n    {\n        pad_tail::pad_using(self, min, f)\n    }\n\n    /// Return an iterator adaptor that wraps each element in a `Position` to\n    /// ease special-case handling of the first or last elements.\n    ///\n    /// Iterator element type is\n    /// [`Position<Self::Item>`](enum.Position.html)\n    ///\n    /// ```\n    /// use itertools::{Itertools, Position};\n    ///\n    /// let it = (0..4).with_position();\n    /// itertools::assert_equal(it,\n    ///                         vec![Position::First(0),\n    ///                              Position::Middle(1),\n    ///                              Position::Middle(2),\n    ///                              Position::Last(3)]);\n    ///\n    /// let it = (0..1).with_position();\n    /// itertools::assert_equal(it, vec![Position::Only(0)]);\n    /// ```\n    fn with_position(self) -> WithPosition<Self>\n        where Self: Sized,\n    {\n        with_position::with_position(self)\n    }\n\n    /// Return an iterator adaptor that yields the indices of all elements\n    /// satisfying a predicate, counted from the start of the iterator.\n    ///\n    /// Equivalent to `iter.enumerate().filter(|(_, v)| predicate(v)).map(|(i, _)| i)`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![1, 2, 3, 3, 4, 6, 7, 9];\n    /// itertools::assert_equal(data.iter().positions(|v| v % 2 == 0), vec![1, 4, 5]);\n    ///\n    /// itertools::assert_equal(data.iter().positions(|v| v % 2 == 1).rev(), vec![7, 6, 3, 2, 0]);\n    /// ```\n    fn positions<P>(self, predicate: P) -> Positions<Self, P>\n        where Self: Sized,\n              P: FnMut(Self::Item) -> bool,\n    {\n        adaptors::positions(self, predicate)\n    }\n\n    /// Return an iterator adaptor that applies a mutating function\n    /// to each element before yielding it.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let input = vec![vec![1], vec![3, 2, 1]];\n    /// let it = input.into_iter().update(|mut v| v.push(0));\n    /// itertools::assert_equal(it, vec![vec![1, 0], vec![3, 2, 1, 0]]);\n    /// ```\n    fn update<F>(self, updater: F) -> Update<Self, F>\n        where Self: Sized,\n              F: FnMut(&mut Self::Item),\n    {\n        adaptors::update(self, updater)\n    }\n\n    // non-adaptor methods\n    /// Advances the iterator and returns the next items grouped in a tuple of\n    /// a specific size (up to 4).\n    ///\n    /// If there are enough elements to be grouped in a tuple, then the tuple is\n    /// returned inside `Some`, otherwise `None` is returned.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut iter = 1..5;\n    ///\n    /// assert_eq!(Some((1, 2)), iter.next_tuple());\n    /// ```\n    fn next_tuple<T>(&mut self) -> Option<T>\n        where Self: Sized + Iterator<Item = T::Item>,\n              T: traits::HomogeneousTuple\n    {\n        T::collect_from_iter_no_buf(self)\n    }\n\n    /// Collects all items from the iterator into a tuple of a specific size\n    /// (up to 4).\n    ///\n    /// If the number of elements inside the iterator is **exactly** equal to\n    /// the tuple size, then the tuple is returned inside `Some`, otherwise\n    /// `None` is returned.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let iter = 1..3;\n    ///\n    /// if let Some((x, y)) = iter.collect_tuple() {\n    ///     assert_eq!((x, y), (1, 2))\n    /// } else {\n    ///     panic!(\"Expected two elements\")\n    /// }\n    /// ```\n    fn collect_tuple<T>(mut self) -> Option<T>\n        where Self: Sized + Iterator<Item = T::Item>,\n              T: traits::HomogeneousTuple\n    {\n        match self.next_tuple() {\n            elt @ Some(_) => match self.next() {\n                Some(_) => None,\n                None => elt,\n            },\n            _ => None\n        }\n    }\n\n\n    /// Find the position and value of the first element satisfying a predicate.\n    ///\n    /// The iterator is not advanced past the first element found.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let text = \"Hα\";\n    /// assert_eq!(text.chars().find_position(|ch| ch.is_lowercase()), Some((1, 'α')));\n    /// ```\n    fn find_position<P>(&mut self, mut pred: P) -> Option<(usize, Self::Item)>\n        where P: FnMut(&Self::Item) -> bool\n    {\n        let mut index = 0usize;\n        for elt in self {\n            if pred(&elt) {\n                return Some((index, elt));\n            }\n            index += 1;\n        }\n        None\n    }\n\n    /// Check whether all elements compare equal.\n    ///\n    /// Empty iterators are considered to have equal elements:\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![1, 1, 1, 2, 2, 3, 3, 3, 4, 5, 5];\n    /// assert!(!data.iter().all_equal());\n    /// assert!(data[0..3].iter().all_equal());\n    /// assert!(data[3..5].iter().all_equal());\n    /// assert!(data[5..8].iter().all_equal());\n    ///\n    /// let data : Option<usize> = None;\n    /// assert!(data.into_iter().all_equal());\n    /// ```\n    fn all_equal(&mut self) -> bool\n        where Self: Sized,\n              Self::Item: PartialEq,\n    {\n        match self.next() {\n            None => true,\n            Some(a) => self.all(|x| a == x),\n        }\n    }\n\n    /// Consume the first `n` elements from the iterator eagerly,\n    /// and return the same iterator again.\n    ///\n    /// It works similarly to *.skip(* `n` *)* except it is eager and\n    /// preserves the iterator type.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut iter = \"αβγ\".chars().dropping(2);\n    /// itertools::assert_equal(iter, \"γ\".chars());\n    /// ```\n    ///\n    /// *Fusing notes: if the iterator is exhausted by dropping,\n    /// the result of calling `.next()` again depends on the iterator implementation.*\n    fn dropping(mut self, n: usize) -> Self\n        where Self: Sized\n    {\n        if n > 0 {\n            self.nth(n - 1);\n        }\n        self\n    }\n\n    /// Consume the last `n` elements from the iterator eagerly,\n    /// and return the same iterator again.\n    ///\n    /// This is only possible on double ended iterators. `n` may be\n    /// larger than the number of elements.\n    ///\n    /// Note: This method is eager, dropping the back elements immediately and\n    /// preserves the iterator type.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let init = vec![0, 3, 6, 9].into_iter().dropping_back(1);\n    /// itertools::assert_equal(init, vec![0, 3, 6]);\n    /// ```\n    fn dropping_back(mut self, n: usize) -> Self\n        where Self: Sized,\n              Self: DoubleEndedIterator\n    {\n        if n > 0 {\n            (&mut self).rev().nth(n - 1);\n        }\n        self\n    }\n\n    /// Run the closure `f` eagerly on each element of the iterator.\n    ///\n    /// Consumes the iterator until its end.\n    ///\n    /// ```\n    /// use std::sync::mpsc::channel;\n    /// use itertools::Itertools;\n    ///\n    /// let (tx, rx) = channel();\n    ///\n    /// // use .foreach() to apply a function to each value -- sending it\n    /// (0..5).map(|x| x * 2 + 1).foreach(|x| { tx.send(x).unwrap(); } );\n    ///\n    /// drop(tx);\n    ///\n    /// itertools::assert_equal(rx.iter(), vec![1, 3, 5, 7, 9]);\n    /// ```\n    #[deprecated(note=\"Use .for_each() instead\", since=\"0.8\")]\n    fn foreach<F>(self, f: F)\n        where F: FnMut(Self::Item),\n              Self: Sized,\n    {\n        self.for_each(f)\n    }\n\n    /// Combine all an iterator's elements into one element by using `Extend`.\n    ///\n    /// This combinator will extend the first item with each of the rest of the\n    /// items of the iterator. If the iterator is empty, the default value of\n    /// `I::Item` is returned.\n    ///\n    /// ```rust\n    /// use itertools::Itertools;\n    ///\n    /// let input = vec![vec![1], vec![2, 3], vec![4, 5, 6]];\n    /// assert_eq!(input.into_iter().concat(),\n    ///            vec![1, 2, 3, 4, 5, 6]);\n    /// ```\n    fn concat(self) -> Self::Item\n        where Self: Sized,\n              Self::Item: Extend<<<Self as Iterator>::Item as IntoIterator>::Item> + IntoIterator + Default\n    {\n        concat(self)\n    }\n\n    /// `.collect_vec()` is simply a type specialization of `.collect()`,\n    /// for convenience.\n    #[cfg(feature = \"use_std\")]\n    fn collect_vec(self) -> Vec<Self::Item>\n        where Self: Sized\n    {\n        self.collect()\n    }\n\n    /// `.try_collect()` is more convenient way of writing\n    /// `.collect::<Result<_, _>>()`\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::{fs, io};\n    /// use itertools::Itertools;\n    ///\n    /// fn process_dir_entries(entries: &[fs::DirEntry]) {\n    ///     // ...\n    /// }\n    ///\n    /// fn do_stuff() -> std::io::Result<()> {\n    ///     let entries: Vec<_> = fs::read_dir(\".\")?.try_collect()?;\n    ///     process_dir_entries(&entries);\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn try_collect<T, U, E>(self) -> Result<U, E>\n    where\n        Self: Sized + Iterator<Item = Result<T, E>>,\n        Result<U, E>: FromIterator<Result<T, E>>,\n    {\n        self.collect()\n    }\n\n    /// Assign to each reference in `self` from the `from` iterator,\n    /// stopping at the shortest of the two iterators.\n    ///\n    /// The `from` iterator is queried for its next element before the `self`\n    /// iterator, and if either is exhausted the method is done.\n    ///\n    /// Return the number of elements written.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut xs = [0; 4];\n    /// xs.iter_mut().set_from(1..);\n    /// assert_eq!(xs, [1, 2, 3, 4]);\n    /// ```\n    #[inline]\n    fn set_from<'a, A: 'a, J>(&mut self, from: J) -> usize\n        where Self: Iterator<Item = &'a mut A>,\n              J: IntoIterator<Item = A>\n    {\n        let mut count = 0;\n        for elt in from {\n            match self.next() {\n                None => break,\n                Some(ptr) => *ptr = elt,\n            }\n            count += 1;\n        }\n        count\n    }\n\n    /// Combine all iterator elements into one String, separated by `sep`.\n    ///\n    /// Use the `Display` implementation of each element.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// assert_eq!([\"a\", \"b\", \"c\"].iter().join(\", \"), \"a, b, c\");\n    /// assert_eq!([1, 2, 3].iter().join(\", \"), \"1, 2, 3\");\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn join(&mut self, sep: &str) -> String\n        where Self::Item: std::fmt::Display\n    {\n        match self.next() {\n            None => String::new(),\n            Some(first_elt) => {\n                // estimate lower bound of capacity needed\n                let (lower, _) = self.size_hint();\n                let mut result = String::with_capacity(sep.len() * lower);\n                write!(&mut result, \"{}\", first_elt).unwrap();\n                for elt in self {\n                    result.push_str(sep);\n                    write!(&mut result, \"{}\", elt).unwrap();\n                }\n                result\n            }\n        }\n    }\n\n    /// Format all iterator elements, separated by `sep`.\n    ///\n    /// All elements are formatted (any formatting trait)\n    /// with `sep` inserted between each element.\n    ///\n    /// **Panics** if the formatter helper is formatted more than once.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = [1.1, 2.71828, -3.];\n    /// assert_eq!(\n    ///     format!(\"{:.2}\", data.iter().format(\", \")),\n    ///            \"1.10, 2.72, -3.00\");\n    /// ```\n    fn format(self, sep: &str) -> Format<Self>\n        where Self: Sized,\n    {\n        format::new_format_default(self, sep)\n    }\n\n    /// Format all iterator elements, separated by `sep`.\n    ///\n    /// This is a customizable version of `.format()`.\n    ///\n    /// The supplied closure `format` is called once per iterator element,\n    /// with two arguments: the element and a callback that takes a\n    /// `&Display` value, i.e. any reference to type that implements `Display`.\n    ///\n    /// Using `&format_args!(...)` is the most versatile way to apply custom\n    /// element formatting. The callback can be called multiple times if needed.\n    ///\n    /// **Panics** if the formatter helper is formatted more than once.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = [1.1, 2.71828, -3.];\n    /// let data_formatter = data.iter().format_with(\", \", |elt, f| f(&format_args!(\"{:.2}\", elt)));\n    /// assert_eq!(format!(\"{}\", data_formatter),\n    ///            \"1.10, 2.72, -3.00\");\n    ///\n    /// // .format_with() is recursively composable\n    /// let matrix = [[1., 2., 3.],\n    ///               [4., 5., 6.]];\n    /// let matrix_formatter = matrix.iter().format_with(\"\\n\", |row, f| {\n    ///                                 f(&row.iter().format_with(\", \", |elt, g| g(&elt)))\n    ///                              });\n    /// assert_eq!(format!(\"{}\", matrix_formatter),\n    ///            \"1, 2, 3\\n4, 5, 6\");\n    ///\n    ///\n    /// ```\n    fn format_with<F>(self, sep: &str, format: F) -> FormatWith<Self, F>\n        where Self: Sized,\n              F: FnMut(Self::Item, &mut dyn FnMut(&dyn fmt::Display) -> fmt::Result) -> fmt::Result,\n    {\n        format::new_format(self, sep, format)\n    }\n\n    /// Fold `Result` values from an iterator.\n    ///\n    /// Only `Ok` values are folded. If no error is encountered, the folded\n    /// value is returned inside `Ok`. Otherwise, the operation terminates\n    /// and returns the first `Err` value it encounters. No iterator elements are\n    /// consumed after the first error.\n    ///\n    /// The first accumulator value is the `start` parameter.\n    /// Each iteration passes the accumulator value and the next value inside `Ok`\n    /// to the fold function `f` and its return value becomes the new accumulator value.\n    ///\n    /// For example the sequence *Ok(1), Ok(2), Ok(3)* will result in a\n    /// computation like this:\n    ///\n    /// ```ignore\n    /// let mut accum = start;\n    /// accum = f(accum, 1);\n    /// accum = f(accum, 2);\n    /// accum = f(accum, 3);\n    /// ```\n    ///\n    /// With a `start` value of 0 and an addition as folding function,\n    /// this effectively results in *((0 + 1) + 2) + 3*\n    ///\n    /// ```\n    /// use std::ops::Add;\n    /// use itertools::Itertools;\n    ///\n    /// let values = [1, 2, -2, -1, 2, 1];\n    /// assert_eq!(\n    ///     values.iter()\n    ///           .map(Ok::<_, ()>)\n    ///           .fold_results(0, Add::add),\n    ///     Ok(3)\n    /// );\n    /// assert!(\n    ///     values.iter()\n    ///           .map(|&x| if x >= 0 { Ok(x) } else { Err(\"Negative number\") })\n    ///           .fold_results(0, Add::add)\n    ///           .is_err()\n    /// );\n    /// ```\n    fn fold_results<A, E, B, F>(&mut self, mut start: B, mut f: F) -> Result<B, E>\n        where Self: Iterator<Item = Result<A, E>>,\n              F: FnMut(B, A) -> B\n    {\n        for elt in self {\n            match elt {\n                Ok(v) => start = f(start, v),\n                Err(u) => return Err(u),\n            }\n        }\n        Ok(start)\n    }\n\n    /// Fold `Option` values from an iterator.\n    ///\n    /// Only `Some` values are folded. If no `None` is encountered, the folded\n    /// value is returned inside `Some`. Otherwise, the operation terminates\n    /// and returns `None`. No iterator elements are consumed after the `None`.\n    ///\n    /// This is the `Option` equivalent to `fold_results`.\n    ///\n    /// ```\n    /// use std::ops::Add;\n    /// use itertools::Itertools;\n    ///\n    /// let mut values = vec![Some(1), Some(2), Some(-2)].into_iter();\n    /// assert_eq!(values.fold_options(5, Add::add), Some(5 + 1 + 2 - 2));\n    ///\n    /// let mut more_values = vec![Some(2), None, Some(0)].into_iter();\n    /// assert!(more_values.fold_options(0, Add::add).is_none());\n    /// assert_eq!(more_values.next().unwrap(), Some(0));\n    /// ```\n    fn fold_options<A, B, F>(&mut self, mut start: B, mut f: F) -> Option<B>\n        where Self: Iterator<Item = Option<A>>,\n              F: FnMut(B, A) -> B\n    {\n        for elt in self {\n            match elt {\n                Some(v) => start = f(start, v),\n                None => return None,\n            }\n        }\n        Some(start)\n    }\n\n    /// Accumulator of the elements in the iterator.\n    ///\n    /// Like `.fold()`, without a base case. If the iterator is\n    /// empty, return `None`. With just one element, return it.\n    /// Otherwise elements are accumulated in sequence using the closure `f`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// assert_eq!((0..10).fold1(|x, y| x + y).unwrap_or(0), 45);\n    /// assert_eq!((0..0).fold1(|x, y| x * y), None);\n    /// ```\n    fn fold1<F>(mut self, f: F) -> Option<Self::Item>\n        where F: FnMut(Self::Item, Self::Item) -> Self::Item,\n              Self: Sized,\n    {\n        self.next().map(move |x| self.fold(x, f))\n    }\n\n    /// Accumulate the elements in the iterator in a tree-like manner.\n    ///\n    /// You can think of it as, while there's more than one item, repeatedly\n    /// combining adjacent items.  It does so in bottom-up-merge-sort order,\n    /// however, so that it needs only logarithmic stack space.\n    ///\n    /// This produces a call tree like the following (where the calls under\n    /// an item are done after reading that item):\n    ///\n    /// ```text\n    /// 1 2 3 4 5 6 7\n    /// │ │ │ │ │ │ │\n    /// └─f └─f └─f │\n    ///   │   │   │ │\n    ///   └───f   └─f\n    ///       │     │\n    ///       └─────f\n    /// ```\n    ///\n    /// Which, for non-associative functions, will typically produce a different\n    /// result than the linear call tree used by `fold1`:\n    ///\n    /// ```text\n    /// 1 2 3 4 5 6 7\n    /// │ │ │ │ │ │ │\n    /// └─f─f─f─f─f─f\n    /// ```\n    ///\n    /// If `f` is associative, prefer the normal `fold1` instead.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // The same tree as above\n    /// let num_strings = (1..8).map(|x| x.to_string());\n    /// assert_eq!(num_strings.tree_fold1(|x, y| format!(\"f({}, {})\", x, y)),\n    ///     Some(String::from(\"f(f(f(1, 2), f(3, 4)), f(f(5, 6), 7))\")));\n    ///\n    /// // Like fold1, an empty iterator produces None\n    /// assert_eq!((0..0).tree_fold1(|x, y| x * y), None);\n    ///\n    /// // tree_fold1 matches fold1 for associative operations...\n    /// assert_eq!((0..10).tree_fold1(|x, y| x + y),\n    ///     (0..10).fold1(|x, y| x + y));\n    /// // ...but not for non-associative ones\n    /// assert_ne!((0..10).tree_fold1(|x, y| x - y),\n    ///     (0..10).fold1(|x, y| x - y));\n    /// ```\n    fn tree_fold1<F>(mut self, mut f: F) -> Option<Self::Item>\n        where F: FnMut(Self::Item, Self::Item) -> Self::Item,\n              Self: Sized,\n    {\n        type State<T> = Result<T, Option<T>>;\n\n        fn inner0<T, II, FF>(it: &mut II, f: &mut FF) -> State<T>\n            where\n                II: Iterator<Item = T>,\n                FF: FnMut(T, T) -> T\n        {\n            // This function could be replaced with `it.next().ok_or(None)`,\n            // but half the useful tree_fold1 work is combining adjacent items,\n            // so put that in a form that LLVM is more likely to optimize well.\n\n            let a =\n                if let Some(v) = it.next() { v }\n                else { return Err(None) };\n            let b =\n                if let Some(v) = it.next() { v }\n                else { return Err(Some(a)) };\n            Ok(f(a, b))\n        }\n\n        fn inner<T, II, FF>(stop: usize, it: &mut II, f: &mut FF) -> State<T>\n            where\n                II: Iterator<Item = T>,\n                FF: FnMut(T, T) -> T\n        {\n            let mut x = inner0(it, f)?;\n            for height in 0..stop {\n                // Try to get another tree the same size with which to combine it,\n                // creating a new tree that's twice as big for next time around.\n                let next =\n                    if height == 0 {\n                        inner0(it, f)\n                    } else {\n                        inner(height, it, f)\n                    };\n                match next {\n                    Ok(y) => x = f(x, y),\n\n                    // If we ran out of items, combine whatever we did manage\n                    // to get.  It's better combined with the current value\n                    // than something in a parent frame, because the tree in\n                    // the parent is always as least as big as this one.\n                    Err(None) => return Err(Some(x)),\n                    Err(Some(y)) => return Err(Some(f(x, y))),\n                }\n            }\n            Ok(x)\n        }\n\n        match inner(usize::max_value(), &mut self, &mut f) {\n            Err(x) => x,\n            _ => unreachable!(),\n        }\n    }\n\n    /// An iterator method that applies a function, producing a single, final value.\n    ///\n    /// `fold_while()` is basically equivalent to `fold()` but with additional support for\n    /// early exit via short-circuiting.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// use itertools::FoldWhile::{Continue, Done};\n    ///\n    /// let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    ///\n    /// let mut result = 0;\n    ///\n    /// // for loop:\n    /// for i in &numbers {\n    ///     if *i > 5 {\n    ///         break;\n    ///     }\n    ///     result = result + i;\n    /// }\n    ///\n    /// // fold:\n    /// let result2 = numbers.iter().fold(0, |acc, x| {\n    ///     if *x > 5 { acc } else { acc + x }\n    /// });\n    ///\n    /// // fold_while:\n    /// let result3 = numbers.iter().fold_while(0, |acc, x| {\n    ///     if *x > 5 { Done(acc) } else { Continue(acc + x) }\n    /// }).into_inner();\n    ///\n    /// // they're the same\n    /// assert_eq!(result, result2);\n    /// assert_eq!(result2, result3);\n    /// ```\n    ///\n    /// The big difference between the computations of `result2` and `result3` is that while\n    /// `fold()` called the provided closure for every item of the callee iterator,\n    /// `fold_while()` actually stopped iterating as soon as it encountered `Fold::Done(_)`.\n    #[deprecated(note=\"Use .try_fold() instead\", since=\"0.8\")]\n    fn fold_while<B, F>(&mut self, init: B, mut f: F) -> FoldWhile<B>\n        where Self: Sized,\n              F: FnMut(B, Self::Item) -> FoldWhile<B>\n    {\n        let mut acc = init;\n        while let Some(item) = self.next() {\n            match f(acc, item) {\n                FoldWhile::Continue(res) => acc = res,\n                res @ FoldWhile::Done(_) => return res,\n            }\n        }\n        FoldWhile::Continue(acc)\n    }\n\n    /// Iterate over the entire iterator and add all the elements.\n    ///\n    /// An empty iterator returns `None`, otherwise `Some(sum)`.\n    ///\n    /// # Panics\n    ///\n    /// When calling `sum1()` and a primitive integer type is being returned, this\n    /// method will panic if the computation overflows and debug assertions are\n    /// enabled.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let empty_sum = (1..1).sum1::<i32>();\n    /// assert_eq!(empty_sum, None);\n    ///\n    /// let nonempty_sum = (1..11).sum1::<i32>();\n    /// assert_eq!(nonempty_sum, Some(55));\n    /// ```\n    fn sum1<S>(mut self) -> Option<S>\n        where Self: Sized,\n              S: std::iter::Sum<Self::Item>,\n    {\n        self.next()\n            .map(|first| once(first).chain(self).sum())\n    }\n\n    /// Iterate over the entire iterator and multiply all the elements.\n    ///\n    /// An empty iterator returns `None`, otherwise `Some(product)`.\n    ///\n    /// # Panics\n    ///\n    /// When calling `product1()` and a primitive integer type is being returned,\n    /// method will panic if the computation overflows and debug assertions are\n    /// enabled.\n    ///\n    /// # Examples\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let empty_product = (1..1).product1::<i32>();\n    /// assert_eq!(empty_product, None);\n    ///\n    /// let nonempty_product = (1..11).product1::<i32>();\n    /// assert_eq!(nonempty_product, Some(3628800));\n    /// ```\n    fn product1<P>(mut self) -> Option<P>\n        where Self: Sized,\n              P: std::iter::Product<Self::Item>,\n    {\n        self.next()\n            .map(|first| once(first).chain(self).product())\n    }\n\n\n    /// Sort all iterator elements into a new iterator in ascending order.\n    ///\n    /// **Note:** This consumes the entire iterator, uses the\n    /// `slice::sort()` method and returns the result as a new\n    /// iterator that owns its elements.\n    ///\n    /// The sorted iterator, if directly collected to a `Vec`, is converted\n    /// without any extra copying or allocation cost.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // sort the letters of the text in ascending order\n    /// let text = \"bdacfe\";\n    /// itertools::assert_equal(text.chars().sorted(),\n    ///                         \"abcdef\".chars());\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn sorted(self) -> VecIntoIter<Self::Item>\n        where Self: Sized,\n              Self::Item: Ord\n    {\n        // Use .sort() directly since it is not quite identical with\n        // .sort_by(Ord::cmp)\n        let mut v = Vec::from_iter(self);\n        v.sort();\n        v.into_iter()\n    }\n\n    /// Sort all iterator elements into a new iterator in ascending order.\n    ///\n    /// **Note:** This consumes the entire iterator, uses the\n    /// `slice::sort_by()` method and returns the result as a new\n    /// iterator that owns its elements.\n    ///\n    /// The sorted iterator, if directly collected to a `Vec`, is converted\n    /// without any extra copying or allocation cost.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // sort people in descending order by age\n    /// let people = vec![(\"Jane\", 20), (\"John\", 18), (\"Jill\", 30), (\"Jack\", 27)];\n    ///\n    /// let oldest_people_first = people\n    ///     .into_iter()\n    ///     .sorted_by(|a, b| Ord::cmp(&b.1, &a.1))\n    ///     .map(|(person, _age)| person);\n    ///\n    /// itertools::assert_equal(oldest_people_first,\n    ///                         vec![\"Jill\", \"Jack\", \"Jane\", \"John\"]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn sorted_by<F>(self, cmp: F) -> VecIntoIter<Self::Item>\n        where Self: Sized,\n              F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n    {\n        let mut v = Vec::from_iter(self);\n        v.sort_by(cmp);\n        v.into_iter()\n    }\n\n    /// Sort all iterator elements into a new iterator in ascending order.\n    ///\n    /// **Note:** This consumes the entire iterator, uses the\n    /// `slice::sort_by_key()` method and returns the result as a new\n    /// iterator that owns its elements.\n    ///\n    /// The sorted iterator, if directly collected to a `Vec`, is converted\n    /// without any extra copying or allocation cost.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // sort people in descending order by age\n    /// let people = vec![(\"Jane\", 20), (\"John\", 18), (\"Jill\", 30), (\"Jack\", 27)];\n    ///\n    /// let oldest_people_first = people\n    ///     .into_iter()\n    ///     .sorted_by_key(|x| -x.1)\n    ///     .map(|(person, _age)| person);\n    ///\n    /// itertools::assert_equal(oldest_people_first,\n    ///                         vec![\"Jill\", \"Jack\", \"Jane\", \"John\"]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn sorted_by_key<K, F>(self, f: F) -> VecIntoIter<Self::Item>\n        where Self: Sized,\n              K: Ord,\n              F: FnMut(&Self::Item) -> K,\n    {\n        let mut v = Vec::from_iter(self);\n        v.sort_by_key(f);\n        v.into_iter()\n    }\n\n    /// Collect all iterator elements into one of two\n    /// partitions. Unlike `Iterator::partition`, each partition may\n    /// have a distinct type.\n    ///\n    /// ```\n    /// use itertools::{Itertools, Either};\n    ///\n    /// let successes_and_failures = vec![Ok(1), Err(false), Err(true), Ok(2)];\n    ///\n    /// let (successes, failures): (Vec<_>, Vec<_>) = successes_and_failures\n    ///     .into_iter()\n    ///     .partition_map(|r| {\n    ///         match r {\n    ///             Ok(v) => Either::Left(v),\n    ///             Err(v) => Either::Right(v),\n    ///         }\n    ///     });\n    ///\n    /// assert_eq!(successes, [1, 2]);\n    /// assert_eq!(failures, [false, true]);\n    /// ```\n    fn partition_map<A, B, F, L, R>(self, mut predicate: F) -> (A, B)\n        where Self: Sized,\n              F: FnMut(Self::Item) -> Either<L, R>,\n              A: Default + Extend<L>,\n              B: Default + Extend<R>,\n    {\n        let mut left = A::default();\n        let mut right = B::default();\n\n        self.for_each(|val| match predicate(val) {\n            Either::Left(v) => left.extend(Some(v)),\n            Either::Right(v) => right.extend(Some(v)),\n        });\n\n        (left, right)\n    }\n\n    /// Return a `HashMap` of keys mapped to `Vec`s of values. Keys and values\n    /// are taken from `(Key, Value)` tuple pairs yielded by the input iterator.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![(0, 10), (2, 12), (3, 13), (0, 20), (3, 33), (2, 42)];\n    /// let lookup = data.into_iter().into_group_map();\n    ///\n    /// assert_eq!(lookup[&0], vec![10, 20]);\n    /// assert_eq!(lookup.get(&1), None);\n    /// assert_eq!(lookup[&2], vec![12, 42]);\n    /// assert_eq!(lookup[&3], vec![13, 33]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn into_group_map<K, V>(self) -> HashMap<K, Vec<V>>\n        where Self: Iterator<Item=(K, V)> + Sized,\n              K: Hash + Eq,\n    {\n        group_map::into_group_map(self)\n    }\n\n    /// Return the minimum and maximum elements in the iterator.\n    ///\n    /// The return type `MinMaxResult` is an enum of three variants:\n    ///\n    /// - `NoElements` if the iterator is empty.\n    /// - `OneElement(x)` if the iterator has exactly one element.\n    /// - `MinMax(x, y)` is returned otherwise, where `x <= y`. Two\n    ///    values are equal if and only if there is more than one\n    ///    element in the iterator and all elements are equal.\n    ///\n    /// On an iterator of length `n`, `minmax` does `1.5 * n` comparisons,\n    /// and so is faster than calling `min` and `max` separately which does\n    /// `2 * n` comparisons.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// use itertools::MinMaxResult::{NoElements, OneElement, MinMax};\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().minmax(), NoElements);\n    ///\n    /// let a = [1];\n    /// assert_eq!(a.iter().minmax(), OneElement(&1));\n    ///\n    /// let a = [1, 2, 3, 4, 5];\n    /// assert_eq!(a.iter().minmax(), MinMax(&1, &5));\n    ///\n    /// let a = [1, 1, 1, 1];\n    /// assert_eq!(a.iter().minmax(), MinMax(&1, &1));\n    /// ```\n    ///\n    /// The elements can be floats but no particular result is guaranteed\n    /// if an element is NaN.\n    fn minmax(self) -> MinMaxResult<Self::Item>\n        where Self: Sized, Self::Item: PartialOrd\n    {\n        minmax::minmax_impl(self, |_| (), |x, y, _, _| x < y)\n    }\n\n    /// Return the minimum and maximum element of an iterator, as determined by\n    /// the specified function.\n    ///\n    /// The return value is a variant of `MinMaxResult` like for `minmax()`.\n    ///\n    /// For the minimum, the first minimal element is returned.  For the maximum,\n    /// the last maximal element wins.  This matches the behavior of the standard\n    /// `Iterator::min()` and `Iterator::max()` methods.\n    ///\n    /// The keys can be floats but no particular result is guaranteed\n    /// if a key is NaN.\n    fn minmax_by_key<K, F>(self, key: F) -> MinMaxResult<Self::Item>\n        where Self: Sized, K: PartialOrd, F: FnMut(&Self::Item) -> K\n    {\n        minmax::minmax_impl(self, key, |_, _, xk, yk| xk < yk)\n    }\n\n    /// Return the minimum and maximum element of an iterator, as determined by\n    /// the specified comparison function.\n    ///\n    /// The return value is a variant of `MinMaxResult` like for `minmax()`.\n    ///\n    /// For the minimum, the first minimal element is returned.  For the maximum,\n    /// the last maximal element wins.  This matches the behavior of the standard\n    /// `Iterator::min()` and `Iterator::max()` methods.\n    fn minmax_by<F>(self, mut compare: F) -> MinMaxResult<Self::Item>\n        where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering\n    {\n        minmax::minmax_impl(\n            self,\n            |_| (),\n            |x, y, _, _| Ordering::Less == compare(x, y)\n        )\n    }\n\n    /// Return the position of the maximum element in the iterator.\n    ///\n    /// If several elements are equally maximum, the position of the\n    /// last of them is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_max(), None);\n    ///\n    /// let a = [-3, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_max(), Some(3));\n    ///\n    /// let a = [1, 1, -1, -1];\n    /// assert_eq!(a.iter().position_max(), Some(1));\n    /// ```\n    fn position_max(self) -> Option<usize>\n        where Self: Sized, Self::Item: Ord\n    {\n        self.enumerate()\n            .max_by(|x, y| Ord::cmp(&x.1, &y.1))\n            .map(|x| x.0)\n    }\n\n    /// Return the position of the maximum element in the iterator, as\n    /// determined by the specified function.\n    ///\n    /// If several elements are equally maximum, the position of the\n    /// last of them is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_max_by_key(|x| x.abs()), None);\n    ///\n    /// let a = [-3_i32, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_max_by_key(|x| x.abs()), Some(4));\n    ///\n    /// let a = [1_i32, 1, -1, -1];\n    /// assert_eq!(a.iter().position_max_by_key(|x| x.abs()), Some(3));\n    /// ```\n    fn position_max_by_key<K, F>(self, mut key: F) -> Option<usize>\n        where Self: Sized, K: Ord, F: FnMut(&Self::Item) -> K\n    {\n        self.enumerate()\n            .max_by(|x, y| Ord::cmp(&key(&x.1), &key(&y.1)))\n            .map(|x| x.0)\n    }\n\n    /// Return the position of the maximum element in the iterator, as\n    /// determined by the specified comparison function.\n    ///\n    /// If several elements are equally maximum, the position of the\n    /// last of them is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_max_by(|x, y| x.cmp(y)), None);\n    ///\n    /// let a = [-3_i32, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_max_by(|x, y| x.cmp(y)), Some(3));\n    ///\n    /// let a = [1_i32, 1, -1, -1];\n    /// assert_eq!(a.iter().position_max_by(|x, y| x.cmp(y)), Some(1));\n    /// ```\n    fn position_max_by<F>(self, mut compare: F) -> Option<usize>\n        where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering\n    {\n        self.enumerate()\n            .max_by(|x, y| compare(&x.1, &y.1))\n            .map(|x| x.0)\n    }\n\n    /// Return the position of the minimum element in the iterator.\n    ///\n    /// If several elements are equally minimum, the position of the\n    /// first of them is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_min(), None);\n    ///\n    /// let a = [-3, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_min(), Some(4));\n    ///\n    /// let a = [1, 1, -1, -1];\n    /// assert_eq!(a.iter().position_min(), Some(2));\n    /// ```\n    fn position_min(self) -> Option<usize>\n        where Self: Sized, Self::Item: Ord\n    {\n        self.enumerate()\n            .min_by(|x, y| Ord::cmp(&x.1, &y.1))\n            .map(|x| x.0)\n    }\n\n    /// Return the position of the minimum element in the iterator, as\n    /// determined by the specified function.\n    ///\n    /// If several elements are equally minimum, the position of the\n    /// first of them is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_min_by_key(|x| x.abs()), None);\n    ///\n    /// let a = [-3_i32, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_min_by_key(|x| x.abs()), Some(1));\n    ///\n    /// let a = [1_i32, 1, -1, -1];\n    /// assert_eq!(a.iter().position_min_by_key(|x| x.abs()), Some(0));\n    /// ```\n    fn position_min_by_key<K, F>(self, mut key: F) -> Option<usize>\n        where Self: Sized, K: Ord, F: FnMut(&Self::Item) -> K\n    {\n        self.enumerate()\n            .min_by(|x, y| Ord::cmp(&key(&x.1), &key(&y.1)))\n            .map(|x| x.0)\n    }\n\n    /// Return the position of the minimum element in the iterator, as\n    /// determined by the specified comparison function.\n    ///\n    /// If several elements are equally minimum, the position of the\n    /// first of them is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_min_by(|x, y| x.cmp(y)), None);\n    ///\n    /// let a = [-3_i32, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_min_by(|x, y| x.cmp(y)), Some(4));\n    ///\n    /// let a = [1_i32, 1, -1, -1];\n    /// assert_eq!(a.iter().position_min_by(|x, y| x.cmp(y)), Some(2));\n    /// ```\n    fn position_min_by<F>(self, mut compare: F) -> Option<usize>\n        where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering\n    {\n        self.enumerate()\n            .min_by(|x, y| compare(&x.1, &y.1))\n            .map(|x| x.0)\n    }\n\n    /// Return the positions of the minimum and maximum elements in\n    /// the iterator.\n    ///\n    /// The return type [`MinMaxResult`] is an enum of three variants:\n    ///\n    /// - `NoElements` if the iterator is empty.\n    /// - `OneElement(xpos)` if the iterator has exactly one element.\n    /// - `MinMax(xpos, ypos)` is returned otherwise, where the\n    ///    element at `xpos` ≤ the element at `ypos`. While the\n    ///    referenced elements themselves may be equal, `xpos` cannot\n    ///    be equal to `ypos`.\n    ///\n    /// On an iterator of length `n`, `position_minmax` does `1.5 * n`\n    /// comparisons, and so is faster than calling `positon_min` and\n    /// `position_max` separately which does `2 * n` comparisons.\n    ///\n    /// For the minimum, if several elements are equally minimum, the\n    /// position of the first of them is returned. For the maximum, if\n    /// several elements are equally maximum, the position of the last\n    /// of them is returned.\n    ///\n    /// The elements can be floats but no particular result is\n    /// guaranteed if an element is NaN.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// use itertools::MinMaxResult::{NoElements, OneElement, MinMax};\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_minmax(), NoElements);\n    ///\n    /// let a = [10];\n    /// assert_eq!(a.iter().position_minmax(), OneElement(0));\n    ///\n    /// let a = [-3, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_minmax(), MinMax(4, 3));\n    ///\n    /// let a = [1, 1, -1, -1];\n    /// assert_eq!(a.iter().position_minmax(), MinMax(2, 1));\n    /// ```\n    ///\n    /// [`MinMaxResult`]: enum.MinMaxResult.html\n    fn position_minmax(self) -> MinMaxResult<usize>\n        where Self: Sized, Self::Item: PartialOrd\n    {\n        use crate::MinMaxResult::{NoElements, OneElement, MinMax};\n        match minmax::minmax_impl(self.enumerate(), |_| (), |x, y, _, _| x.1 < y.1) {\n            NoElements => NoElements,\n            OneElement(x) => OneElement(x.0),\n            MinMax(x, y) => MinMax(x.0, y.0),\n        }\n    }\n\n    /// Return the postions of the minimum and maximum elements of an\n    /// iterator, as determined by the specified function.\n    ///\n    /// The return value is a variant of [`MinMaxResult`] like for\n    /// [`position_minmax`].\n    ///\n    /// For the minimum, if several elements are equally minimum, the\n    /// position of the first of them is returned. For the maximum, if\n    /// several elements are equally maximum, the position of the last\n    /// of them is returned.\n    ///\n    /// The keys can be floats but no particular result is guaranteed\n    /// if a key is NaN.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// use itertools::MinMaxResult::{NoElements, OneElement, MinMax};\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_minmax_by_key(|x| x.abs()), NoElements);\n    ///\n    /// let a = [10_i32];\n    /// assert_eq!(a.iter().position_minmax_by_key(|x| x.abs()), OneElement(0));\n    ///\n    /// let a = [-3_i32, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_minmax_by_key(|x| x.abs()), MinMax(1, 4));\n    ///\n    /// let a = [1_i32, 1, -1, -1];\n    /// assert_eq!(a.iter().position_minmax_by_key(|x| x.abs()), MinMax(0, 3));\n    /// ```\n    ///\n    /// [`MinMaxResult`]: enum.MinMaxResult.html\n    /// [`position_minmax`]: #method.position_minmax\n    fn position_minmax_by_key<K, F>(self, mut key: F) -> MinMaxResult<usize>\n        where Self: Sized, K: PartialOrd, F: FnMut(&Self::Item) -> K\n    {\n        use crate::MinMaxResult::{NoElements, OneElement, MinMax};\n        match self.enumerate().minmax_by_key(|e| key(&e.1)) {\n            NoElements => NoElements,\n            OneElement(x) => OneElement(x.0),\n            MinMax(x, y) => MinMax(x.0, y.0),\n        }\n    }\n\n    /// Return the postions of the minimum and maximum elements of an\n    /// iterator, as determined by the specified comparison function.\n    ///\n    /// The return value is a variant of [`MinMaxResult`] like for\n    /// [`position_minmax`].\n    ///\n    /// For the minimum, if several elements are equally minimum, the\n    /// position of the first of them is returned. For the maximum, if\n    /// several elements are equally maximum, the position of the last\n    /// of them is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// use itertools::MinMaxResult::{NoElements, OneElement, MinMax};\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_minmax_by(|x, y| x.cmp(y)), NoElements);\n    ///\n    /// let a = [10_i32];\n    /// assert_eq!(a.iter().position_minmax_by(|x, y| x.cmp(y)), OneElement(0));\n    ///\n    /// let a = [-3_i32, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_minmax_by(|x, y| x.cmp(y)), MinMax(4, 3));\n    ///\n    /// let a = [1_i32, 1, -1, -1];\n    /// assert_eq!(a.iter().position_minmax_by(|x, y| x.cmp(y)), MinMax(2, 1));\n    /// ```\n    ///\n    /// [`MinMaxResult`]: enum.MinMaxResult.html\n    /// [`position_minmax`]: #method.position_minmax\n    fn position_minmax_by<F>(self, mut compare: F) -> MinMaxResult<usize>\n        where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering\n    {\n        use crate::MinMaxResult::{NoElements, OneElement, MinMax};\n        match self.enumerate().minmax_by(|x, y| compare(&x.1, &y.1)) {\n            NoElements => NoElements,\n            OneElement(x) => OneElement(x.0),\n            MinMax(x, y) => MinMax(x.0, y.0),\n        }\n    }\n\n    /// If the iterator yields exactly one element, that element will be returned, otherwise\n    /// an error will be returned containing an iterator that has the same output as the input\n    /// iterator.\n    ///\n    /// This provides an additional layer of validation over just calling `Iterator::next()`.\n    /// If your assumption that there should only be one element yielded is false this provides\n    /// the opportunity to detect and handle that, preventing errors at a distance.\n    ///\n    /// # Examples\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// assert_eq!((0..10).filter(|&x| x == 2).exactly_one().unwrap(), 2);\n    /// assert!((0..10).filter(|&x| x > 1 && x < 4).exactly_one().unwrap_err().eq(2..4));\n    /// assert!((0..10).filter(|&x| x > 1 && x < 5).exactly_one().unwrap_err().eq(2..5));\n    /// assert!((0..10).filter(|&_| false).exactly_one().unwrap_err().eq(0..0));\n    /// ```\n    fn exactly_one(mut self) -> Result<Self::Item, ExactlyOneError<Self>>\n    where\n        Self: Sized,\n    {\n        match self.next() {\n            Some(first) => {\n                match self.next() {\n                    Some(second) => {\n                        Err(ExactlyOneError::new((Some(first), Some(second)), self))\n                    }\n                    None => {\n                        Ok(first)\n                    }\n                }\n            }\n            None => Err(ExactlyOneError::new((None, None), self)),\n        }\n    }\n\n    /// An iterator adaptor that allows the user to peek at multiple `.next()`\n    /// values without advancing the base iterator.\n    ///\n    /// # Examples\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut iter = (0..10).multipeek();\n    /// assert_eq!(iter.peek(), Some(&0));\n    /// assert_eq!(iter.peek(), Some(&1));\n    /// assert_eq!(iter.peek(), Some(&2));\n    /// assert_eq!(iter.next(), Some(0));\n    /// assert_eq!(iter.peek(), Some(&1));\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn multipeek(self) -> MultiPeek<Self>\n    where\n        Self: Sized,\n    {\n        multipeek_impl::multipeek(self)\n    }\n}\n\nimpl<T: ?Sized> Itertools for T where T: Iterator { }\n\n/// Return `true` if both iterables produce equal sequences\n/// (elements pairwise equal and sequences of the same length),\n/// `false` otherwise.\n///\n/// This is an `IntoIterator` enabled function that is similar to the standard\n/// library method `Iterator::eq`.\n///\n/// ```\n/// assert!(itertools::equal(vec![1, 2, 3], 1..4));\n/// assert!(!itertools::equal(&[0, 0], &[0, 0, 0]));\n/// ```\npub fn equal<I, J>(a: I, b: J) -> bool\n    where I: IntoIterator,\n          J: IntoIterator,\n          I::Item: PartialEq<J::Item>\n{\n    let mut ia = a.into_iter();\n    let mut ib = b.into_iter();\n    loop {\n        match ia.next() {\n            Some(x) => match ib.next() {\n                Some(y) => if x != y { return false; },\n                None => return false,\n            },\n            None => return ib.next().is_none()\n        }\n    }\n}\n\n/// Assert that two iterables produce equal sequences, with the same\n/// semantics as *equal(a, b)*.\n///\n/// **Panics** on assertion failure with a message that shows the\n/// two iteration elements.\n///\n/// ```ignore\n/// assert_equal(\"exceed\".split('c'), \"excess\".split('c'));\n/// // ^PANIC: panicked at 'Failed assertion Some(\"eed\") == Some(\"ess\") for iteration 1',\n/// ```\npub fn assert_equal<I, J>(a: I, b: J)\n    where I: IntoIterator,\n          J: IntoIterator,\n          I::Item: fmt::Debug + PartialEq<J::Item>,\n          J::Item: fmt::Debug,\n{\n    let mut ia = a.into_iter();\n    let mut ib = b.into_iter();\n    let mut i = 0;\n    loop {\n        match (ia.next(), ib.next()) {\n            (None, None) => return,\n            (a, b) => {\n                let equal = match (&a, &b) {\n                    (&Some(ref a), &Some(ref b)) => a == b,\n                    _ => false,\n                };\n                assert!(equal, \"Failed assertion {a:?} == {b:?} for iteration {i}\",\n                        i=i, a=a, b=b);\n                i += 1;\n            }\n        }\n    }\n}\n\n/// Partition a sequence using predicate `pred` so that elements\n/// that map to `true` are placed before elements which map to `false`.\n///\n/// The order within the partitions is arbitrary.\n///\n/// Return the index of the split point.\n///\n/// ```\n/// use itertools::partition;\n///\n/// # // use repeated numbers to not promise any ordering\n/// let mut data = [7, 1, 1, 7, 1, 1, 7];\n/// let split_index = partition(&mut data, |elt| *elt >= 3);\n///\n/// assert_eq!(data, [7, 7, 7, 1, 1, 1, 1]);\n/// assert_eq!(split_index, 3);\n/// ```\npub fn partition<'a, A: 'a, I, F>(iter: I, mut pred: F) -> usize\n    where I: IntoIterator<Item = &'a mut A>,\n          I::IntoIter: DoubleEndedIterator,\n          F: FnMut(&A) -> bool\n{\n    let mut split_index = 0;\n    let mut iter = iter.into_iter();\n    'main: while let Some(front) = iter.next() {\n        if !pred(front) {\n            loop {\n                match iter.next_back() {\n                    Some(back) => if pred(back) {\n                        std::mem::swap(front, back);\n                        break;\n                    },\n                    None => break 'main,\n                }\n            }\n        }\n        split_index += 1;\n    }\n    split_index\n}\n\n/// An enum used for controlling the execution of `.fold_while()`.\n///\n/// See [`.fold_while()`](trait.Itertools.html#method.fold_while) for more information.\n#[derive(Copy, Clone, Debug, Eq, PartialEq)]\npub enum FoldWhile<T> {\n    /// Continue folding with this value\n    Continue(T),\n    /// Fold is complete and will return this value\n    Done(T),\n}\n\nimpl<T> FoldWhile<T> {\n    /// Return the value in the continue or done.\n    pub fn into_inner(self) -> T {\n        match self {\n            FoldWhile::Continue(x) | FoldWhile::Done(x) => x,\n        }\n    }\n\n    /// Return true if `self` is `Done`, false if it is `Continue`.\n    pub fn is_done(&self) -> bool {\n        match *self {\n            FoldWhile::Continue(_) => false,\n            FoldWhile::Done(_) => true,\n        }\n    }\n}\n","traces":[{"line":355,"address":[5248000,5248096],"length":1,"stats":{"Line":2},"fn_name":"interleave<quick::Iter<i16, quick::Inexact>,quick::Iter<i16, quick::Inexact>>"},{"line":359,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":373,"address":[4586992,4587096],"length":1,"stats":{"Line":5},"fn_name":"interleave_shortest<core::iter::sources::Repeat<i32>,alloc::vec::IntoIter<i32>>"},{"line":377,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":392,"address":[4217728],"length":1,"stats":{"Line":5},"fn_name":"intersperse<core::ops::range::Range<i32>>"},{"line":396,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":426,"address":[4217433,4217136,4217271,4217328],"length":1,"stats":{"Line":8},"fn_name":"zip_longest<core::iter::adapters::Map<core::slice::Iter<i32>, closure-0>,core::iter::adapters::Map<core::slice::Iter<i32>, closure-1>>"},{"line":430,"address":[4232835,4232715,4232850],"length":1,"stats":{"Line":16},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[4229040],"length":1,"stats":{"Line":2},"fn_name":"batching<core::slice::Iter<core::option::Option<i32>>,i32,closure-0>"},{"line":473,"address":[4229054],"length":1,"stats":{"Line":2},"fn_name":null},{"line":511,"address":[4208464,4208672,4208736,4208560,4208400,4208512,4208608,4208784],"length":1,"stats":{"Line":18},"fn_name":"group_by<core::str::Chars,char,closure-5>"},{"line":516,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":547,"address":[4579552,4579488],"length":1,"stats":{"Line":2},"fn_name":"chunks<core::slice::Iter<i32>>"},{"line":550,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":585,"address":[4259024,4258976,4258928,4258880],"length":1,"stats":{"Line":8},"fn_name":"tuple_windows<core::iter::adapters::Cloned<core::slice::Iter<i32>>,(i32, i32)>"},{"line":590,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[4259072,4259120,4259168,4259216],"length":1,"stats":{"Line":8},"fn_name":"tuples<core::iter::adapters::Cloned<core::slice::Iter<i32>>,(i32, i32, i32, i32)>"},{"line":662,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":683,"address":[4257568],"length":1,"stats":{"Line":3},"fn_name":"tee<core::iter::adapters::Cloned<core::slice::Iter<i32>>>"},{"line":687,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":708,"address":[4328480],"length":1,"stats":{"Line":7},"fn_name":"step<core::ops::range::Range<i32>>"},{"line":711,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":743,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":760,"address":[4337616],"length":1,"stats":{"Line":3},"fn_name":"merge<itertools::adaptors::Step<core::ops::range::Range<i32>>,itertools::adaptors::Step<core::ops::range::Range<i32>>>"},{"line":765,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":784,"address":[4302200,4301984],"length":1,"stats":{"Line":2},"fn_name":"merge_by<alloc::collections::btree::map::IntoIter<&str, i32>,alloc::collections::btree::map::IntoIter<&str, i32>,closure-0>"},{"line":789,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":824,"address":[4308320],"length":1,"stats":{"Line":1},"fn_name":"merge_join_by<alloc::vec::IntoIter<usize>,alloc::vec::IntoIter<usize>,fn(&usize, &usize) -> core::cmp::Ordering>"},{"line":829,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":849,"address":[4258032,4257936,4257808,4257984,4257888],"length":1,"stats":{"Line":5},"fn_name":"kmerge<core::iter::adapters::Map<alloc::vec::IntoIter<i32>, closure-0>>"},{"line":854,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":878,"address":[4687264,4687424,4687344],"length":1,"stats":{"Line":3},"fn_name":"kmerge_by<alloc::vec::IntoIter<alloc::vec::Vec<i16>>,closure-0>"},{"line":885,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":899,"address":[4281239,4281104],"length":1,"stats":{"Line":8},"fn_name":"cartesian_product<core::iter::adapters::Cloned<core::slice::Iter<i32>>,core::iter::adapters::Cloned<core::slice::Iter<i32>>>"},{"line":905,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":934,"address":[5249680],"length":1,"stats":{"Line":1},"fn_name":"multi_cartesian_product<quick::ShiftRange<quick::Inexact>>"},{"line":940,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":976,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":993,"address":[4579440],"length":1,"stats":{"Line":4},"fn_name":"dedup<core::slice::Iter<i32>>"},{"line":997,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1015,"address":[4579984,4580032,4579936],"length":1,"stats":{"Line":5},"fn_name":"dedup_by<core::slice::Iter<(i32, i32)>,closure-2>"},{"line":1019,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1037,"address":[4578016],"length":1,"stats":{"Line":1},"fn_name":"dedup_with_count<core::slice::Iter<i32>>"},{"line":1040,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1059,"address":[4578064,4578112],"length":1,"stats":{"Line":2},"fn_name":"dedup_by_with_count<core::slice::Iter<(i32, i32)>,closure-0>"},{"line":1063,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1085,"address":[4258080],"length":1,"stats":{"Line":4},"fn_name":"unique<core::iter::adapters::Rev<core::slice::Iter<i32>>>"},{"line":1089,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1111,"address":[4258400],"length":1,"stats":{"Line":3},"fn_name":"unique_by<core::iter::adapters::Rev<core::slice::Iter<&str>>,alloc::string::String,closure-1>"},{"line":1116,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1131,"address":[4209808,4209840],"length":1,"stats":{"Line":9},"fn_name":"peeking_take_while<itertools::adaptors::PutBack<core::ops::range::Range<i32>>,closure-0>"},{"line":1135,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1156,"address":[4862864],"length":1,"stats":{"Line":1},"fn_name":"take_while_ref<core::slice::Iter<u8>,closure-0>"},{"line":1160,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1177,"address":[4257056],"length":1,"stats":{"Line":2},"fn_name":"while_some<core::iter::adapters::Map<core::ops::range::Range<i32>, closure-0>,i32>"},{"line":1180,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1216,"address":[4812800],"length":1,"stats":{"Line":3},"fn_name":"tuple_combinations<core::ops::range::Range<i32>,(i32, i32)>"},{"line":1221,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1254,"address":[4243376],"length":1,"stats":{"Line":3},"fn_name":"combinations<adaptors_no_collect::PanickingCounter>"},{"line":1258,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1281,"address":[4243504],"length":1,"stats":{"Line":2},"fn_name":"combinations_with_replacement<adaptors_no_collect::PanickingCounter>"},{"line":1286,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1327,"address":[4243440],"length":1,"stats":{"Line":5},"fn_name":"permutations<adaptors_no_collect::PanickingCounter>"},{"line":1331,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1351,"address":[4812976],"length":1,"stats":{"Line":6},"fn_name":"pad_using<core::ops::range::Range<i32>,closure-0>"},{"line":1355,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1377,"address":[4862816],"length":1,"stats":{"Line":2},"fn_name":"with_position<core::slice::Iter<u8>>"},{"line":1380,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1434,"address":[4258496],"length":1,"stats":{"Line":3},"fn_name":"next_tuple<core::iter::adapters::Cloned<core::slice::Iter<i32>>,(i32, i32)>"},{"line":1438,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1459,"address":[4258544,4258601],"length":1,"stats":{"Line":2},"fn_name":"collect_tuple<core::iter::adapters::Cloned<core::slice::Iter<i32>>,(i32, i32)>"},{"line":1463,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":1464,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1465,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1466,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1468,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1483,"address":[4325488,4325565],"length":1,"stats":{"Line":1},"fn_name":"find_position<Iterator,closure-1>"},{"line":1486,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1487,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1488,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1489,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1491,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1493,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1512,"address":[4208832,4208867],"length":1,"stats":{"Line":2},"fn_name":"all_equal<core::str::Chars>"},{"line":1516,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1517,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1518,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1537,"address":[4217325,4217296],"length":1,"stats":{"Line":2},"fn_name":"dropping<core::slice::Iter<i32>>"},{"line":1540,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1541,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1543,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1565,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1566,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1568,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1589,"address":[4217248],"length":1,"stats":{"Line":2},"fn_name":"foreach<core::slice::Iter<i32>,closure-0>"},{"line":1593,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1609,"address":[5029312,5029392],"length":1,"stats":{"Line":2},"fn_name":"concat<alloc::vec::IntoIter<alloc::vec::Vec<()>>>"},{"line":1613,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1619,"address":[4257104],"length":1,"stats":{"Line":9},"fn_name":"collect_vec<core::iter::adapters::Map<itertools::groupbylazy::Groups<char, core::str::Chars, closure-3>, closure-4>>"},{"line":1622,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1651,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1670,"address":[4218090,4217456,4217524,4218016],"length":1,"stats":{"Line":2},"fn_name":"set_from<core::slice::IterMut<i32>,i32,core::ops::range::Range<i32>>"},{"line":1674,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1675,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1676,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1677,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1678,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1680,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1682,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1696,"address":[4578160,4578248],"length":1,"stats":{"Line":1},"fn_name":"join<core::slice::Iter<i32>>"},{"line":1699,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1700,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1701,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1703,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1704,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1705,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1706,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1707,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1708,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1710,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1730,"address":[4579760,4579680],"length":1,"stats":{"Line":2},"fn_name":"format<core::slice::Iter<i32>>"},{"line":1733,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1772,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1821,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1822,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1823,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1824,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1827,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1853,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1854,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1855,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1856,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1859,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1874,"address":[4328596,4328544],"length":1,"stats":{"Line":7},"fn_name":"fold1<core::ops::range::Range<i32>,closure-1>"},{"line":1878,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":1929,"address":[4328288,4328302],"length":1,"stats":{"Line":3},"fn_name":"tree_fold1<core::ops::range::Range<i32>,closure-0>"},{"line":1933,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1935,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1936,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1937,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1938,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1944,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1945,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1946,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1947,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1948,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1949,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1950,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1953,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1954,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1955,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1956,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1958,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":1959,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1962,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1963,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1964,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1966,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1968,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1969,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1975,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1976,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1979,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1982,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1983,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1984,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2028,"address":[5028144,5028203],"length":1,"stats":{"Line":1},"fn_name":"fold_while<alloc::vec::IntoIter<i32>,i32,closure-0>"},{"line":2032,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2033,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":2034,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2035,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2036,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2039,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2063,"address":[4281340,4281296],"length":1,"stats":{"Line":1},"fn_name":"sum1<core::iter::adapters::Cloned<core::slice::Iter<i32>>,i32>"},{"line":2067,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2068,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":2091,"address":[4281564,4281520],"length":1,"stats":{"Line":1},"fn_name":"product1<core::iter::adapters::Cloned<core::slice::Iter<i32>>,i32>"},{"line":2095,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2096,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":2124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2153,"address":[4258128,4258224],"length":1,"stats":{"Line":2},"fn_name":"sorted_by<core::iter::adapters::Cloned<core::slice::Iter<i32>>,closure-0>"},{"line":2157,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2158,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":2159,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2186,"address":[4257392,4257296],"length":1,"stats":{"Line":2},"fn_name":"sorted_by_key<core::iter::adapters::Cloned<core::slice::Iter<i32>>,i32,closure-0>"},{"line":2191,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2192,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":2193,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2249,"address":[6299952],"length":1,"stats":{"Line":1},"fn_name":"into_group_map<core::iter::adapters::Map<alloc::vec::IntoIter<u8>, closure-0>,u8,u8>"},{"line":2253,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2291,"address":[4579840],"length":1,"stats":{"Line":5},"fn_name":"minmax<core::slice::Iter<test_std::minmax::Val>>"},{"line":2294,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":2308,"address":[4577968],"length":1,"stats":{"Line":1},"fn_name":"minmax_by_key<core::slice::Iter<test_std::minmax::Val>,u32,closure-0>"},{"line":2311,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":2322,"address":[4580661,4580608],"length":1,"stats":{"Line":1},"fn_name":"minmax_by<core::slice::Iter<test_std::minmax::Val>,closure-1>"},{"line":2325,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2326,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2327,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2328,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":2354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2439,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2465,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2466,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2493,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2494,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2495,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2545,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2546,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2547,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2548,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2549,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2591,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2592,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2593,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2594,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2595,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2634,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2635,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2636,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2637,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2638,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2659,"address":[4278176,4280219,4277200,4278267,4280128,4279152,4277291,4279243],"length":1,"stats":{"Line":5},"fn_name":"exactly_one<core::iter::adapters::Filter<core::ops::range::Range<i32>, closure-1>>"},{"line":2663,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":2664,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":2665,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":2666,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":2667,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":2669,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2670,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2674,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":2697,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2714,"address":[5440064,5441072,5437135,5450573,5454832,5436992,5442080,5448513,5452780,5453910,5455025,5445152,5458153,5459024,5460112,5449497,5438016,5443088,5445307,5461168,5443231,5460261,5447473,5451737,5446409,5456077,5441233,5456960,5458016,5449360,5444277,5453792,5440205,5436028,5442238,5438153,5446272,5447312,5450400,5451600,5435888,5444128,5439161,5452640,5439024,5455936,5457143,5459205,5461305,5448352],"length":1,"stats":{"Line":25},"fn_name":"equal<core::iter::adapters::Map<core::slice::Windows<u8>, closure-0>,itertools::tuple_impl::TupleWindows<core::slice::Iter<u8>, (&u8, &u8)>>"},{"line":2719,"address":[5439031,5443095,5453809,5459041,5461175,5448359,5436999,5445159,5451607,5447319,5452647,5440076,5456972,5444135,5460119,5446279,5435895,5458023,5449367,5455948,5438023,5450407,5442087,5454849,5441079],"length":1,"stats":{"Line":25},"fn_name":null},{"line":2720,"address":[5453930,5458097,5459125,5457051,5460193,5437073,5447393,5451681,5453875,5454933,5445236,5446353,5448433,5450514,5435969,5443169,5452721,5461249,5456027,5440155,5439105,5441153,5438097,5442170,5449441,5444209],"length":1,"stats":{"Line":26},"fn_name":null},{"line":2721,"address":[5442926,5449512,5456092,5455040,5456799,5457865,5457158,5439176,5439903,5441248,5443246,5441921,5446121,5449201,5450588,5437150,5444997,5440923,5452485,5453630,5453948,5438168,5440220,5454679,5448528,5455777,5436043,5451443,5451752,5458871,5452795,5461320,5462047,5448193,5450239,5443981,5442253,5445322,5459220,5459957,5458168,5437855,5444292,5446424,5447151,5447488,5461011,5438871,5460276,5436842],"length":1,"stats":{"Line":50},"fn_name":null},{"line":2722,"address":[5459227,5450731,5440232,5443266,5452844,5459326,5443341,5442362,5445442,5448540,5453989,5437179,5436055,5446557,5461337,5441284,5450647,5460315,5452807,5446484,5447600,5445334,5451854,5447531,5444312,5447500,5444321,5437170,5448564,5444377,5440251,5459265,5438180,5438260,5446441,5456188,5449529,5449572,5458180,5436079,5451793,5455146,5448637,5451764,5450610,5460296,5438199,5457193,5461453,5436163,5454054,5457165,5452928,5453970,5449645,5456127,5455047,5439193,5441260,5437235,5457254,5456099,5458199,5440312,5442289,5461380,5443285,5442265,5455085,5441357,5445358,5458260,5439309,5439236,5460371],"length":1,"stats":{"Line":50},"fn_name":null},{"line":2723,"address":[5461569,5451958,5440416,5446673,5456190,5443451,5458262,5459281,5461455,5451809,5443343,5454162,5454005,5457256,5460373,5448639,5458215,5445387,5460323,5442318,5441313,5436306,5449647,5439311,5451856,5454056,5446559,5445444,5455148,5449761,5460481,5442364,5437187,5448753,5459430,5446513,5452930,5450676,5447602,5452873,5447557,5437345,5438262,5455250,5456292,5461409,5457358,5437237,5436108,5440267,5457209,5441359,5441473,5443293,5458364,5438364,5442478,5438215,5436165,5444487,5439425,5456143,5453071,5444329,5440314,5448593,5444379,5445585,5439265,5447709,5450733,5450874,5455101,5449601,5459328],"length":1,"stats":{"Line":50},"fn_name":null},{"line":2724,"address":[5445697,5442562,5446757,5450986,5436264,5443563,5448755,5458324,5458366,5454258,5442480,5459432,5447674,5451918,5440376,5441475,5444489,5460483,5460593,5438460,5450832,5439509,5445543,5455346,5451960,5436418,5449763,5441439,5450876,5444447,5457360,5461653,5445587,5453073,5456294,5452054,5449727,5455252,5440512,5453029,5437457,5457318,5437305,5439427,5453183,5461535,5461571,5460441,5438324,5455210,5436308,5458460,5444599,5454122,5454164,5438366,5459526,5448719,5448837,5443411,5446675,5440418,5437347,5456252,5446639,5443453,5459390,5441557,5442444,5447795,5449845,5456388,5447711,5457454,5439391],"length":1,"stats":{"Line":50},"fn_name":null},{"line":2725,"address":[5442468,5457348,5445575,5455240,5437335,5458354,5456282,5436296,5448743,5446663,5443441,5438354,5459420,5441463,5439415,5460471,5440406,5454152,5451948,5461559,5450864,5449751,5444477,5453061,5447699],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2727,"address":[5437577,5460361,5437225,5443331,5446860,5450711,5445814,5447895,5438245,5449948,5452171,5436535,5439612,5438577,5441337,5457239,5448930,5455131,5459643,5447582,5456173,5444367,5460713,5440629,5458245,5448617,5449625,5454030,5458577,5459311,5451839,5457571,5454385,5456505,5441650,5440297,5461433,5446537,5442342,5442655,5436143,5439289,5443683,5444719,5445422,5451113,5455463,5452908,5453300,5461756],"length":1,"stats":{"Line":50},"fn_name":null},{"line":2742,"address":[4229729,4229584],"length":1,"stats":{"Line":49},"fn_name":"assert_equal<itertools::zip_longest::ZipLongest<itertools::adaptors::Batching<core::slice::Iter<core::option::Option<i32>>, closure-0>, core::iter::adapters::Cloned<core::slice::Iter<i32>>>,alloc::vec::Vec<itertools::either_or_both::EitherOrBoth<i32, i32>>>"},{"line":2748,"address":[4229591],"length":1,"stats":{"Line":49},"fn_name":null},{"line":2749,"address":[4229670],"length":1,"stats":{"Line":69},"fn_name":null},{"line":2750,"address":[4229744],"length":1,"stats":{"Line":50},"fn_name":null},{"line":2751,"address":[4230691,4229755],"length":1,"stats":{"Line":101},"fn_name":null},{"line":2752,"address":[4229775,4229813,4229914],"length":1,"stats":{"Line":101},"fn_name":null},{"line":2753,"address":[4229884,4229925],"length":1,"stats":{"Line":102},"fn_name":null},{"line":2754,"address":[4229984],"length":1,"stats":{"Line":51},"fn_name":null},{"line":2755,"address":[4230176,4230044,4230228],"length":1,"stats":{"Line":102},"fn_name":null},{"line":2756,"address":[4230076,4230182],"length":1,"stats":{"Line":102},"fn_name":null},{"line":2757,"address":[4230168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2759,"address":[4230237],"length":1,"stats":{"Line":51},"fn_name":null},{"line":2760,"address":[4230328,4230470,4230418],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2761,"address":[4230863,4230833,4230682,4230250],"length":1,"stats":{"Line":103},"fn_name":null},{"line":2784,"address":[4238048,4237617,4237056,4237121,4237552,4238113],"length":1,"stats":{"Line":4},"fn_name":"partition<i32,&mut [i32; 9],closure-2>"},{"line":2789,"address":[4237068,4237564,4238060],"length":1,"stats":{"Line":4},"fn_name":null},{"line":2790,"address":[4237077,4237573,4238069],"length":1,"stats":{"Line":4},"fn_name":null},{"line":2791,"address":[4238158,4237445,4237119,4238437,4237662,4238135,4237639,4237941,4237166,4237143,4237615,4238111],"length":1,"stats":{"Line":16},"fn_name":null},{"line":2792,"address":[4237206,4237399,4237895,4238198,4238391,4237702],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2793,"address":[4237873,4238369,4237377],"length":1,"stats":{"Line":3},"fn_name":null},{"line":2794,"address":[4237805,4238249,4237753,4237257,4238301,4237309],"length":1,"stats":{"Line":4},"fn_name":null},{"line":2795,"address":[4237282,4238274,4238303,4237807,4237778,4237311],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2796,"address":[4237875,4238371,4237379],"length":1,"stats":{"Line":4},"fn_name":null},{"line":2799,"address":[4237307,4237803,4238299],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2803,"address":[4238405,4237505,4238497,4237413,4237909,4238001],"length":1,"stats":{"Line":4},"fn_name":null},{"line":2805,"address":[4237401,4238393,4237897],"length":1,"stats":{"Line":4},"fn_name":null},{"line":2821,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2822,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2823,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":2828,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2829,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2830,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2831,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":212,"coverable":298},{"path":["/","home","kms","itertools","src","merge_join.rs"],"content":"use std::cmp::Ordering;\nuse std::iter::Fuse;\nuse std::fmt;\n\nuse super::adaptors::{PutBack, put_back};\nuse crate::either_or_both::EitherOrBoth;\n\n/// Return an iterator adaptor that merge-joins items from the two base iterators in ascending order.\n///\n/// See [`.merge_join_by()`](trait.Itertools.html#method.merge_join_by) for more information.\npub fn merge_join_by<I, J, F>(left: I, right: J, cmp_fn: F)\n    -> MergeJoinBy<I::IntoIter, J::IntoIter, F>\n    where I: IntoIterator,\n          J: IntoIterator,\n          F: FnMut(&I::Item, &J::Item) -> Ordering\n{\n    MergeJoinBy {\n        left: put_back(left.into_iter().fuse()),\n        right: put_back(right.into_iter().fuse()),\n        cmp_fn,\n    }\n}\n\n/// An iterator adaptor that merge-joins items from the two base iterators in ascending order.\n///\n/// See [`.merge_join_by()`](../trait.Itertools.html#method.merge_join_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MergeJoinBy<I: Iterator, J: Iterator, F> {\n    left: PutBack<Fuse<I>>,\n    right: PutBack<Fuse<J>>,\n    cmp_fn: F\n}\n\nimpl<I, J, F> Clone for MergeJoinBy<I, J, F>\n    where I: Iterator,\n          J: Iterator,\n          PutBack<Fuse<I>>: Clone,\n          PutBack<Fuse<J>>: Clone,\n          F: Clone,\n{\n    clone_fields!(left, right, cmp_fn);\n}\n\nimpl<I, J, F> fmt::Debug for MergeJoinBy<I, J, F>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n          J: Iterator + fmt::Debug,\n          J::Item: fmt::Debug,\n{\n    debug_fmt_fields!(MergeJoinBy, left, right);\n}\n\nimpl<I, J, F> Iterator for MergeJoinBy<I, J, F>\n    where I: Iterator,\n          J: Iterator,\n          F: FnMut(&I::Item, &J::Item) -> Ordering\n{\n    type Item = EitherOrBoth<I::Item, J::Item>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match (self.left.next(), self.right.next()) {\n            (None, None) => None,\n            (Some(left), None) =>\n                Some(EitherOrBoth::Left(left)),\n            (None, Some(right)) =>\n                Some(EitherOrBoth::Right(right)),\n            (Some(left), Some(right)) => {\n                match (self.cmp_fn)(&left, &right) {\n                    Ordering::Equal =>\n                        Some(EitherOrBoth::Both(left, right)),\n                    Ordering::Less => {\n                        self.right.put_back(right);\n                        Some(EitherOrBoth::Left(left))\n                    },\n                    Ordering::Greater => {\n                        self.left.put_back(left);\n                        Some(EitherOrBoth::Right(right))\n                    }\n                }\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (a_lower, a_upper) = self.left.size_hint();\n        let (b_lower, b_upper) = self.right.size_hint();\n\n        let lower = ::std::cmp::max(a_lower, b_lower);\n\n        let upper = match (a_upper, b_upper) {\n            (Some(x), Some(y)) => x.checked_add(y),\n            _ => None,\n        };\n\n        (lower, upper)\n    }\n\n    fn count(mut self) -> usize {\n        let mut count = 0;\n        loop {\n            match (self.left.next(), self.right.next()) {\n                (None, None) => break count,\n                (Some(_left), None) => break count + 1 + self.left.into_parts().1.count(),\n                (None, Some(_right)) => break count + 1 + self.right.into_parts().1.count(),\n                (Some(left), Some(right)) => {\n                    count += 1;\n                    match (self.cmp_fn)(&left, &right) {\n                        Ordering::Equal => {}\n                        Ordering::Less => self.right.put_back(right),\n                        Ordering::Greater => self.left.put_back(left),\n                    }\n                }\n            }\n        }\n    }\n\n    fn last(mut self) -> Option<Self::Item> {\n        let mut previous_element = None;\n        loop {\n            match (self.left.next(), self.right.next()) {\n                (None, None) => break previous_element,\n                (Some(left), None) => {\n                    break Some(EitherOrBoth::Left(\n                        self.left.into_parts().1.last().unwrap_or(left),\n                    ))\n                }\n                (None, Some(right)) => {\n                    break Some(EitherOrBoth::Right(\n                        self.right.into_parts().1.last().unwrap_or(right),\n                    ))\n                }\n                (Some(left), Some(right)) => {\n                    previous_element = match (self.cmp_fn)(&left, &right) {\n                        Ordering::Equal => Some(EitherOrBoth::Both(left, right)),\n                        Ordering::Less => {\n                            self.right.put_back(right);\n                            Some(EitherOrBoth::Left(left))\n                        }\n                        Ordering::Greater => {\n                            self.left.put_back(left);\n                            Some(EitherOrBoth::Right(right))\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n        loop {\n            if n == 0 {\n                break self.next();\n            }\n            n -= 1;\n            match (self.left.next(), self.right.next()) {\n                (None, None) => break None,\n                (Some(_left), None) => break self.left.nth(n).map(EitherOrBoth::Left),\n                (None, Some(_right)) => break self.right.nth(n).map(EitherOrBoth::Right),\n                (Some(left), Some(right)) => match (self.cmp_fn)(&left, &right) {\n                    Ordering::Equal => {}\n                    Ordering::Less => self.right.put_back(right),\n                    Ordering::Greater => self.left.put_back(left),\n                },\n            }\n        }\n    }\n}\n","traces":[{"line":11,"address":[4261568,4262000,4263728,4262864,4263838,4261246,4262974,4262110,4261136,4263296,4262542,4262432,4263406,4261678],"length":1,"stats":{"Line":9},"fn_name":"merge_join_by<alloc::vec::Vec<u32>,alloc::vec::Vec<u32>,closure-0>"},{"line":18,"address":[4262585,4262010,4263017,4263306,4261289,4261146,4263738,4263881,4262874,4263449,4262153,4261721,4262442,4261578],"length":1,"stats":{"Line":18},"fn_name":null},{"line":19,"address":[4263543,4261296,4261728,4262247,4262592,4263024,4261815,4262679,4263888,4262160,4263111,4263975,4261383,4263456],"length":1,"stats":{"Line":18},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":51,"coverable":74},{"path":["/","home","kms","itertools","src","minmax.rs"],"content":"\n/// `MinMaxResult` is an enum returned by `minmax`. See `Itertools::minmax()` for\n/// more detail.\n#[derive(Copy, Clone, PartialEq, Debug)]\npub enum MinMaxResult<T> {\n    /// Empty iterator\n    NoElements,\n\n    /// Iterator with one element, so the minimum and maximum are the same\n    OneElement(T),\n\n    /// More than one element in the iterator, the first element is not larger\n    /// than the second\n    MinMax(T, T)\n}\n\nimpl<T: Clone> MinMaxResult<T> {\n    /// `into_option` creates an `Option` of type `(T, T)`. The returned `Option`\n    /// has variant `None` if and only if the `MinMaxResult` has variant\n    /// `NoElements`. Otherwise `Some((x, y))` is returned where `x <= y`.\n    /// If the `MinMaxResult` has variant `OneElement(x)`, performing this\n    /// operation will make one clone of `x`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::MinMaxResult::{self, NoElements, OneElement, MinMax};\n    ///\n    /// let r: MinMaxResult<i32> = NoElements;\n    /// assert_eq!(r.into_option(), None);\n    ///\n    /// let r = OneElement(1);\n    /// assert_eq!(r.into_option(), Some((1, 1)));\n    ///\n    /// let r = MinMax(1, 2);\n    /// assert_eq!(r.into_option(), Some((1, 2)));\n    /// ```\n    pub fn into_option(self) -> Option<(T,T)> {\n        match self {\n            MinMaxResult::NoElements => None,\n            MinMaxResult::OneElement(x) => Some((x.clone(), x)),\n            MinMaxResult::MinMax(x, y) => Some((x, y))\n        }\n    }\n}\n\n/// Implementation guts for `minmax` and `minmax_by_key`.\npub fn minmax_impl<I, K, F, L>(mut it: I, mut key_for: F,\n                               mut lt: L) -> MinMaxResult<I::Item>\n    where I: Iterator,\n          F: FnMut(&I::Item) -> K,\n          L: FnMut(&I::Item, &I::Item, &K, &K) -> bool,\n{\n    let (mut min, mut max, mut min_key, mut max_key) = match it.next() {\n        None => return MinMaxResult::NoElements,\n        Some(x) => {\n            match it.next() {\n                None => return MinMaxResult::OneElement(x),\n                Some(y) => {\n                    let xk = key_for(&x);\n                    let yk = key_for(&y);\n                    if !lt(&y, &x, &yk, &xk) {(x, y, xk, yk)} else {(y, x, yk, xk)}\n                }\n            }\n        }\n    };\n\n    loop {\n        // `first` and `second` are the two next elements we want to look\n        // at.  We first compare `first` and `second` (#1). The smaller one\n        // is then compared to current minimum (#2). The larger one is\n        // compared to current maximum (#3). This way we do 3 comparisons\n        // for 2 elements.\n        let first = match it.next() {\n            None => break,\n            Some(x) => x\n        };\n        let second = match it.next() {\n            None => {\n                let first_key = key_for(&first);\n                if lt(&first, &min, &first_key, &min_key) {\n                    min = first;\n                } else if !lt(&first, &max, &first_key, &max_key) {\n                    max = first;\n                }\n                break;\n            }\n            Some(x) => x\n        };\n        let first_key = key_for(&first);\n        let second_key = key_for(&second);\n        if !lt(&second, &first, &second_key, &first_key) {\n            if lt(&first, &min, &first_key, &min_key) {\n                min = first;\n                min_key = first_key;\n            }\n            if !lt(&second, &max, &second_key, &max_key) {\n                max = second;\n                max_key = second_key;\n            }\n        } else {\n            if lt(&second, &min, &second_key, &min_key) {\n                min = second;\n                min_key = second_key;\n            }\n            if !lt(&first, &max, &first_key, &max_key) {\n                max = first;\n                max_key = first_key;\n            }\n        }\n    }\n\n    MinMaxResult::MinMax(min, max)\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[4875254,4871680,4882113,4868084,4875136,4878560,4871817,4878678,4881984,4867952],"length":1,"stats":{"Line":7},"fn_name":"minmax_impl<core::slice::Iter<test_std::minmax::Val>,u32,closure-0,closure-0>"},{"line":54,"address":[4867978,4882180,4884648,4871714,4875154,4877785,4874352,4868107,4871884,4878578,4878745,4882010,4882133,4878698,4875321,4881209,4875274,4870776,4871837,4868154],"length":1,"stats":{"Line":19},"fn_name":null},{"line":55,"address":[4882149,4878755,4875331,4868123,4871853,4871894,4868164,4875290,4878714,4882190],"length":1,"stats":{"Line":9},"fn_name":null},{"line":56,"address":[4875393,4878817,4882255,4871959,4868229],"length":1,"stats":{"Line":6},"fn_name":null},{"line":57,"address":[4878907,4868325,4882295,4875483,4875433,4878857,4871999,4872049,4882345,4868269],"length":1,"stats":{"Line":6},"fn_name":null},{"line":58,"address":[4872024,4868300,4878882,4875485,4868327,4872051,4882347,4878909,4875458,4882320],"length":1,"stats":{"Line":9},"fn_name":null},{"line":59,"address":[4882434,4868414,4875572,4878996,4872138],"length":1,"stats":{"Line":5},"fn_name":null},{"line":60,"address":[4882458,4872162,4868438,4879020,4875596],"length":1,"stats":{"Line":5},"fn_name":null},{"line":61,"address":[4872201,4882497,4875635,4879059,4868498,4868548],"length":1,"stats":{"Line":6},"fn_name":null},{"line":62,"address":[4868563,4872368,4882664,4882654,4868685,4879226,4875792,4868695,4879103,4872358,4872245,4875802,4882541,4879216,4875679],"length":1,"stats":{"Line":14},"fn_name":null},{"line":68,"address":[4877643,4884506,4870634,4874210,4874462,4881319,4877895,4884758,4881067,4870914],"length":1,"stats":{"Line":10},"fn_name":null},{"line":74,"address":[4876078,4882890,4882940,4872594,4868977,4876028,4869027,4879502,4872644,4879452],"length":1,"stats":{"Line":5},"fn_name":null},{"line":75,"address":[4882952,4879477,4872656,4876090,4869039,4879514,4872619,4876053,4869002,4882915],"length":1,"stats":{"Line":7},"fn_name":null},{"line":76,"address":[4872665,4869048,4876099,4879523,4882961],"length":1,"stats":{"Line":5},"fn_name":null},{"line":78,"address":[4874477,4876196,4879620,4883058,4881334,4883094,4870929,4869181,4872762,4879656,4876232,4884773,4869145,4877910,4872798],"length":1,"stats":{"Line":10},"fn_name":null},{"line":79,"address":[4872770,4876204,4879628,4883066,4869153],"length":1,"stats":{"Line":5},"fn_name":null},{"line":80,"address":[4872808,4876242,4883104,4869191,4879666],"length":1,"stats":{"Line":5},"fn_name":null},{"line":81,"address":[4872847,4880024,4883259,4883143,4879705,4877961,4876600,4869564,4879821,4881385,4869361,4873166,4876397,4884824,4869245,4872963,4874528,4876281,4883462,4870980],"length":1,"stats":{"Line":16},"fn_name":null},{"line":82,"address":[4873086,4876520,4879944,4883382,4869484,4884803,4870959,4877940,4874507,4881364],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[4871006,4873124,4876558,4884850,4883420,4869522,4883275,4879837,4879982,4881411,4872979,4877987,4874554,4876413,4869377],"length":1,"stats":{"Line":12},"fn_name":null},{"line":84,"address":[4874533,4870985,4883428,4873132,4879990,4884829,4869530,4876566,4877966,4881390],"length":1,"stats":{"Line":4},"fn_name":null},{"line":86,"address":[4883498,4873202,4869600,4876636,4880060],"length":1,"stats":{"Line":5},"fn_name":null},{"line":88,"address":[4880069,4869609,4883507,4876645,4873211],"length":1,"stats":{"Line":5},"fn_name":null},{"line":90,"address":[4876737,4873303,4878013,4874580,4871032,4880161,4884876,4869705,4883599,4881437],"length":1,"stats":{"Line":10},"fn_name":null},{"line":91,"address":[4869728,4873319,4876753,4880177,4883615],"length":1,"stats":{"Line":5},"fn_name":null},{"line":92,"address":[4870345,4870555,4874131,4877355,4880779,4877564,4869790,4880988,4884217,4873921,4876800,4883662,4873366,4884427,4880224],"length":1,"stats":{"Line":12},"fn_name":null},{"line":93,"address":[4881565,4883905,4871186,4885004,4877043,4878141,4873609,4880467,4870033,4874708],"length":1,"stats":{"Line":5},"fn_name":null},{"line":94,"address":[4873726,4884022,4871135,4877160,4884975,4870150,4880584,4881536,4878112,4874679],"length":1,"stats":{"Line":4},"fn_name":null},{"line":95,"address":[4871156,4878133,4874700,4881557,4884996],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[4881599,4884064,4877202,4885038,4878175,4870192,4873768,4871242,4880626,4874742],"length":1,"stats":{"Line":5},"fn_name":null},{"line":98,"address":[4885009,4873887,4878146,4871191,4870311,4874713,4880745,4881570,4884183,4877321],"length":1,"stats":{"Line":4},"fn_name":null},{"line":99,"address":[4878167,4885030,4874734,4871212,4881591],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[4869915,4873491,4878209,4885072,4870354,4883787,4876925,4877364,4884226,4873930,4871298,4881633,4874776,4880349,4880788],"length":1,"stats":{"Line":10},"fn_name":null},{"line":103,"address":[4871247,4877370,4870360,4884232,4873936,4874747,4880794,4878180,4881604,4885043],"length":1,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[4885064,4874768,4881625,4878201,4871268],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[4878242,4873978,4885106,4880836,4884274,4881666,4871354,4874810,4870402,4877412],"length":1,"stats":{"Line":8},"fn_name":null},{"line":107,"address":[4874781,4884393,4878214,4881638,4885077,4874097,4870521,4877531,4871303,4880955],"length":1,"stats":{"Line":8},"fn_name":null},{"line":108,"address":[4878234,4885098,4871324,4881658,4874802],"length":1,"stats":{"Line":4},"fn_name":null},{"line":113,"address":[4872526,4879384,4882822,4875960,4868909],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":43,"coverable":44},{"path":["/","home","kms","itertools","src","multipeek_impl.rs"],"content":"use std::iter::Fuse;\nuse std::collections::VecDeque;\nuse crate::size_hint;\nuse crate::PeekingNext;\n\n/// See [`multipeek()`](../fn.multipeek.html) for more information.\n#[derive(Clone, Debug)]\npub struct MultiPeek<I>\n    where I: Iterator\n{\n    iter: Fuse<I>,\n    buf: VecDeque<I::Item>,\n    index: usize,\n}\n\n/// An iterator adaptor that allows the user to peek at multiple `.next()`\n/// values without advancing the base iterator.\npub fn multipeek<I>(iterable: I) -> MultiPeek<I::IntoIter>\n    where I: IntoIterator\n{\n    MultiPeek {\n        iter: iterable.into_iter().fuse(),\n        buf: VecDeque::new(),\n        index: 0,\n    }\n}\n\nimpl<I> MultiPeek<I>\n    where I: Iterator\n{\n    /// Reset the peeking “cursor”\n    pub fn reset_peek(&mut self) {\n        self.index = 0;\n    }\n}\n\nimpl<I: Iterator> MultiPeek<I> {\n    /// Works exactly like `.next()` with the only difference that it doesn't\n    /// advance itself. `.peek()` can be called multiple times, to peek\n    /// further ahead.\n    pub fn peek(&mut self) -> Option<&I::Item> {\n        let ret = if self.index < self.buf.len() {\n            Some(&self.buf[self.index])\n        } else {\n            match self.iter.next() {\n                Some(x) => {\n                    self.buf.push_back(x);\n                    Some(&self.buf[self.index])\n                }\n                None => return None,\n            }\n        };\n\n        self.index += 1;\n        ret\n    }\n}\n\nimpl<I> PeekingNext for MultiPeek<I>\n    where I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool\n    {\n        if self.buf.is_empty() {\n            if let Some(r) = self.peek() {\n                if !accept(r) { return None }\n            }\n        } else {\n            if let Some(r) = self.buf.get(0) {\n                if !accept(r) { return None }\n            }\n        }\n        self.next()\n    }\n}\n\nimpl<I> Iterator for MultiPeek<I>\n    where I: Iterator\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.index = 0;\n        self.buf.pop_front().or_else(|| self.iter.next())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add_scalar(self.iter.size_hint(), self.buf.len())\n    }\n}\n\n// Same size\nimpl<I> ExactSizeIterator for MultiPeek<I>\n    where I: ExactSizeIterator\n{}\n\n\n","traces":[{"line":18,"address":[5229464,5229200,5228992,5228784,5229256,5229048,5228840,5229408],"length":1,"stats":{"Line":5},"fn_name":"multipeek<core::iter::adapters::Map<core::slice::Iter<u8>, closure-1>>"},{"line":22,"address":[5229268,5229009,5229060,5229425,5229476,5228801,5229217,5228852],"length":1,"stats":{"Line":10},"fn_name":null},{"line":23,"address":[5228876,5229084,5229500,5229292],"length":1,"stats":{"Line":5},"fn_name":null},{"line":32,"address":[5227520],"length":1,"stats":{"Line":1},"fn_name":"reset_peek<core::iter::adapters::Cloned<core::slice::Iter<i32>>>"},{"line":33,"address":[5227525],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[5227552,5228002,5228368,5228418,5227602,5227952],"length":1,"stats":{"Line":4},"fn_name":"peek<core::iter::adapters::Cloned<core::slice::Iter<i32>>>"},{"line":42,"address":[5227561,5227692,5227961,5228311,5228508,5228727,5227624,5228024,5228377,5227897,5228092,5228440],"length":1,"stats":{"Line":15},"fn_name":null},{"line":43,"address":[5228049,5228465,5227649],"length":1,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[5228540,5228445,5227720,5228029,5228124,5227629],"length":1,"stats":{"Line":4},"fn_name":null},{"line":46,"address":[5227722,5228126,5228513,5228542,5227694,5228097],"length":1,"stats":{"Line":8},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[5224861,5224816,5224384,5226112,5226544,5226589,5227021,5224429,5226157,5226976,5225293,5225725,5225248,5225680],"length":1,"stats":{"Line":7},"fn_name":"peeking_next<core::iter::adapters::Map<core::slice::Iter<u8>, closure-0>,closure-6>"},{"line":65,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":27,"coverable":27},{"path":["/","home","kms","itertools","src","pad_tail.rs"],"content":"use std::iter::Fuse;\nuse crate::size_hint;\n\n/// An iterator adaptor that pads a sequence to a minimum length by filling\n/// missing elements using a closure.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.pad_using()`](../trait.Itertools.html#method.pad_using) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct PadUsing<I, F> {\n    iter: Fuse<I>,\n    min: usize,\n    pos: usize,\n    filler: F,\n}\n\n/// Create a new **PadUsing** iterator.\npub fn pad_using<I, F>(iter: I, min: usize, filler: F) -> PadUsing<I, F>\n    where I: Iterator,\n          F: FnMut(usize) -> I::Item\n{\n    PadUsing {\n        iter: iter.fuse(),\n        min,\n        pos: 0,\n        filler,\n    }\n}\n\nimpl<I, F> Iterator for PadUsing<I, F>\n    where I: Iterator,\n          F: FnMut(usize) -> I::Item\n{\n    type Item = I::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.iter.next() {\n            None => {\n                if self.pos < self.min {\n                    let e = Some((self.filler)(self.pos));\n                    self.pos += 1;\n                    e\n                } else {\n                    None\n                }\n            },\n            e => {\n                self.pos += 1;\n                e\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let tail = self.min.saturating_sub(self.pos);\n        size_hint::max(self.iter.size_hint(), (tail, Some(tail)))\n    }\n}\n\nimpl<I, F> DoubleEndedIterator for PadUsing<I, F>\n    where I: DoubleEndedIterator + ExactSizeIterator,\n          F: FnMut(usize) -> I::Item\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        if self.min == 0 {\n            self.iter.next_back()\n        } else if self.iter.len() >= self.min {\n            self.min -= 1;\n            self.iter.next_back()\n        } else {\n            self.min -= 1;\n            Some((self.filler)(self.min))\n        }\n    }\n}\n\nimpl<I, F> ExactSizeIterator for PadUsing<I, F>\n    where I: ExactSizeIterator,\n          F: FnMut(usize) -> I::Item\n{}\n","traces":[{"line":20,"address":[4260147,4260176,4260336,4260434,4260016,4260307],"length":1,"stats":{"Line":6},"fn_name":"pad_using<alloc::vec::IntoIter<usize>,closure-1>"},{"line":25,"address":[4260031,4260356,4260191],"length":1,"stats":{"Line":6},"fn_name":null},{"line":39,"address":[5335630,5336103,5336064,5335584,5336528,5336567],"length":1,"stats":{"Line":6},"fn_name":"next<quick::Iter<i8, quick::Exact>,closure-0>"},{"line":40,"address":[4259138,4258457,4259420,4259634,4258667,4258924],"length":1,"stats":{"Line":12},"fn_name":null},{"line":41,"address":[4259464,4258506,4258968],"length":1,"stats":{"Line":6},"fn_name":null},{"line":42,"address":[4258980,4259505,4259476,4258663,4258522,4259131,4258549,4259009,4259627],"length":1,"stats":{"Line":17},"fn_name":null},{"line":43,"address":[4259011,4259507,4258551],"length":1,"stats":{"Line":5},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":47,"address":[5336156,5336620,5335682],"length":1,"stats":{"Line":6},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":51,"address":[5336309,5336430,5336894,5335835,5335956,5336773],"length":1,"stats":{"Line":5},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":16,"coverable":24},{"path":["/","home","kms","itertools","src","peek_nth.rs"],"content":"use crate::size_hint;\nuse crate::PeekingNext;\nuse std::collections::VecDeque;\nuse std::iter::Fuse;\n\n/// See [`peek_nth()`](../fn.peek_nth.html) for more information.\n#[derive(Clone, Debug)]\npub struct PeekNth<I>\nwhere\n    I: Iterator,\n{\n    iter: Fuse<I>,\n    buf: VecDeque<I::Item>,\n}\n\n/// A drop-in replacement for `std::iter::Peekable` which adds a `peek_nth`\n/// method allowing the user to `peek` at a value several iterations forward\n/// without advancing the base iterator.\n///\n/// This differs from `multipeek` in that subsequent calls to `peek` or\n/// `peek_nth` will always return the same value until `next` is called\n/// (making `reset_peek` unnecessary).\npub fn peek_nth<I>(iterable: I) -> PeekNth<I::IntoIter>\nwhere\n    I: IntoIterator,\n{\n    PeekNth {\n        iter: iterable.into_iter().fuse(),\n        buf: VecDeque::new(),\n    }\n}\n\nimpl<I> PeekNth<I>\nwhere\n    I: Iterator,\n{\n    /// Works exactly like the `peek` method in `std::iter::Peekable`\n    pub fn peek(&mut self) -> Option<&I::Item> {\n        self.peek_nth(0)\n    }\n\n    /// Returns a reference to the `nth` value without advancing the iterator.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```rust\n    /// use itertools::peek_nth;\n    ///\n    /// let xs = vec![1,2,3];\n    /// let mut iter = peek_nth(xs.iter());\n    ///\n    /// assert_eq!(iter.peek_nth(0), Some(&&1));\n    /// assert_eq!(iter.next(), Some(&1));\n    ///\n    /// // The iterator does not advance even if we call `peek_nth` multiple times\n    /// assert_eq!(iter.peek_nth(0), Some(&&2));\n    /// assert_eq!(iter.peek_nth(1), Some(&&3));\n    /// assert_eq!(iter.next(), Some(&2));\n    ///\n    /// // Calling `peek_nth` past the end of the iterator will return `None`\n    /// assert_eq!(iter.peek_nth(1), None);\n    /// ```\n    pub fn peek_nth(&mut self, n: usize) -> Option<&I::Item> {\n        let unbuffered_items = (n + 1).saturating_sub(self.buf.len());\n\n        self.buf.extend(self.iter.by_ref().take(unbuffered_items));\n\n        self.buf.get(n)\n    }\n}\n\nimpl<I> Iterator for PeekNth<I>\nwhere\n    I: Iterator,\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.buf.pop_front().or_else(|| self.iter.next())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add_scalar(self.iter.size_hint(), self.buf.len())\n    }\n}\n\nimpl<I> ExactSizeIterator for PeekNth<I> where I: ExactSizeIterator {}\n\nimpl<I> PeekingNext for PeekNth<I>\nwhere\n    I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n    where\n        F: FnOnce(&Self::Item) -> bool,\n    {\n        self.peek().filter(|item| accept(item))?;\n        self.next()\n    }\n}\n","traces":[{"line":23,"address":[4293768,4293904,4293960,4293576,4293520,4293712],"length":1,"stats":{"Line":4},"fn_name":"peek_nth<core::iter::adapters::Map<core::slice::Iter<u8>, closure-1>>"},{"line":28,"address":[4864790,4864851],"length":1,"stats":{"Line":8},"fn_name":null},{"line":29,"address":[4293804,4293996,4293612],"length":1,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[4864544],"length":1,"stats":{"Line":3},"fn_name":"peek_nth<quick::Iter<u16, quick::Exact>>"},{"line":66,"address":[4293294,4293274,4293514,4293484,4293054,4293244],"length":1,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[4293205,4293445],"length":1,"stats":{"Line":3},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[4290768,4290260,4290804,4289952,4291076,4289988,4290224,4291312,4290496,4291348,4291584,4290532,4291040,4291620],"length":1,"stats":{"Line":7},"fn_name":"peeking_next<core::iter::adapters::Map<core::slice::Iter<u8>, closure-0>,closure-1>"},{"line":99,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":5},"fn_name":null}],"covered":16,"coverable":16},{"path":["/","home","kms","itertools","src","peeking_take_while.rs"],"content":"use std::iter::Peekable;\nuse crate::PutBack;\n#[cfg(feature = \"use_std\")]\nuse crate::PutBackN;\n\n/// An iterator that allows peeking at an element before deciding to accept it.\n///\n/// See [`.peeking_take_while()`](trait.Itertools.html#method.peeking_take_while)\n/// for more information.\n///\n/// This is implemented by peeking adaptors like peekable and put back,\n/// but also by a few iterators that can be peeked natively, like the slice’s\n/// by reference iterator (`std::slice::Iter`).\npub trait PeekingNext : Iterator {\n    /// Pass a reference to the next iterator element to the closure `accept`;\n    /// if `accept` returns true, return it as the next element,\n    /// else None.\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool;\n}\n\nimpl<I> PeekingNext for Peekable<I>\n    where I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool\n    {\n        if let Some(r) = self.peek() {\n            if !accept(r) {\n                return None;\n            }\n        }\n        self.next()\n    }\n}\n\nimpl<I> PeekingNext for PutBack<I>\n    where I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool\n    {\n        if let Some(r) = self.next() {\n            if !accept(&r) {\n                self.put_back(r);\n                return None;\n            }\n            Some(r)\n        } else {\n            None\n        }\n    }\n}\n\n#[cfg(feature = \"use_std\")]\nimpl<I> PeekingNext for PutBackN<I>\n    where I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool\n    {\n        if let Some(r) = self.next() {\n            if !accept(&r) {\n                self.put_back(r);\n                return None;\n            }\n            Some(r)\n        } else {\n            None\n        }\n    }\n}\n\n/// An iterator adaptor that takes items while a closure returns `true`.\n///\n/// See [`.peeking_take_while()`](../trait.Itertools.html#method.peeking_take_while)\n/// for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct PeekingTakeWhile<'a, I: 'a, F>\n    where I: Iterator,\n{\n    iter: &'a mut I,\n    f: F,\n}\n\n/// Create a PeekingTakeWhile\npub fn peeking_take_while<I, F>(iter: &mut I, f: F) -> PeekingTakeWhile<I, F>\n    where I: Iterator,\n{\n    PeekingTakeWhile {\n        iter,\n        f,\n    }\n}\n\nimpl<'a, I, F> Iterator for PeekingTakeWhile<'a, I, F>\n    where I: PeekingNext,\n          F: FnMut(&I::Item) -> bool,\n\n{\n    type Item = I::Item;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.peeking_next(&mut self.f)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, hi) = self.iter.size_hint();\n        (0, hi)\n    }\n}\n\n// Some iterators are so lightweight we can simply clone them to save their\n// state and use that for peeking.\nmacro_rules! peeking_next_by_clone {\n    ([$($typarm:tt)*] $type_:ty) => {\n        impl<$($typarm)*> PeekingNext for $type_ {\n            fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n                where F: FnOnce(&Self::Item) -> bool\n            {\n                let saved_state = self.clone();\n                if let Some(r) = self.next() {\n                    if !accept(&r) {\n                        *self = saved_state;\n                    } else {\n                        return Some(r)\n                    }\n                }\n                None\n            }\n        }\n    }\n}\n\npeeking_next_by_clone! { ['a, T] ::std::slice::Iter<'a, T> }\npeeking_next_by_clone! { ['a] ::std::str::Chars<'a> }\npeeking_next_by_clone! { ['a] ::std::str::CharIndices<'a> }\npeeking_next_by_clone! { ['a] ::std::str::Bytes<'a> }\npeeking_next_by_clone! { ['a, T] ::std::option::Iter<'a, T> }\npeeking_next_by_clone! { ['a, T] ::std::result::Iter<'a, T> }\npeeking_next_by_clone! { [T] ::std::iter::Empty<T> }\n#[cfg(feature = \"use_std\")]\npeeking_next_by_clone! { ['a, T] ::std::collections::linked_list::Iter<'a, T> }\n#[cfg(feature = \"use_std\")]\npeeking_next_by_clone! { ['a, T] ::std::collections::vec_deque::Iter<'a, T> }\n\n// cloning a Rev has no extra overhead; peekable and put backs are never DEI.\npeeking_next_by_clone! { [I: Clone + PeekingNext + DoubleEndedIterator]\n                         ::std::iter::Rev<I> }\n","traces":[{"line":25,"address":[4241545,4241504],"length":1,"stats":{"Line":1},"fn_name":"peeking_next<core::ops::range::Range<i32>,&mut closure-0>"},{"line":28,"address":[4241648,4241566,4241518],"length":1,"stats":{"Line":3},"fn_name":null},{"line":29,"address":[4241602],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[4241650],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[4241671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[4208742,4209104,4209158,4208688],"length":1,"stats":{"Line":2},"fn_name":"peeking_next<core::ops::range::Range<i32>,&mut closure-0>"},{"line":43,"address":[4208702,4209211,4209174,4208795,4209118,4208758],"length":1,"stats":{"Line":5},"fn_name":null},{"line":44,"address":[4208818,4209234],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[4239152,4239206,4239622,4239568],"length":1,"stats":{"Line":2},"fn_name":"peeking_next<core::ops::range::Range<i32>,&mut closure-0>"},{"line":62,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[4238784,4238560,4238752,4238688,4238592,4238816,4238624,4238720,4238656],"length":1,"stats":{"Line":9},"fn_name":"peeking_take_while<itertools::put_back_n_impl::PutBackN<core::ops::range::Range<i32>>,closure-1>"},{"line":102,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[4230656,4230352,4230398,4230702],"length":1,"stats":{"Line":4},"fn_name":"peeking_next<i32,&mut closure-1>"},{"line":120,"address":[4230415,4230670,4230366,4230719],"length":1,"stats":{"Line":8},"fn_name":null},{"line":121,"address":[4230734,4230572,4230876,4230430],"length":1,"stats":{"Line":6},"fn_name":null},{"line":122,"address":[4230492,4230796],"length":1,"stats":{"Line":4},"fn_name":null},{"line":123,"address":[4230854,4230550],"length":1,"stats":{"Line":3},"fn_name":null},{"line":125,"address":[4230538,4230842],"length":1,"stats":{"Line":4},"fn_name":null},{"line":128,"address":[4230584,4230888],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":29,"coverable":32},{"path":["/","home","kms","itertools","src","permutations.rs"],"content":"use std::fmt;\nuse std::iter::once;\n\nuse super::lazy_buffer::LazyBuffer;\n\n/// An iterator adaptor that iterates through all the `k`-permutations of the\n/// elements from an iterator.\n///\n/// See [`.permutations()`](../trait.Itertools.html#method.permutations) for\n/// more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Permutations<I: Iterator> {\n    vals: LazyBuffer<I>,\n    state: PermutationState,\n}\n\nimpl<I> Clone for Permutations<I>\n    where I: Clone + Iterator,\n          I::Item: Clone,\n{\n    clone_fields!(vals, state);\n}\n\n#[derive(Clone, Debug)]\nenum PermutationState {\n    StartUnknownLen {\n        k: usize,\n    },\n    OngoingUnknownLen {\n        k: usize,\n        min_n: usize,\n    },\n    Complete(CompleteState),\n    Empty,\n}\n\n#[derive(Clone, Debug)]\nenum CompleteState {\n    Start {\n        n: usize,\n        k: usize,\n    },\n    Ongoing {\n        indices: Vec<usize>,\n        cycles: Vec<usize>,\n    }\n}\n\nenum CompleteStateRemaining {\n    Known(usize),\n    Overflow,\n}\n\nimpl<I> fmt::Debug for Permutations<I>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(Permutations, vals, state);\n}\n\npub fn permutations<I: Iterator>(iter: I, k: usize) -> Permutations<I> {\n    let mut vals = LazyBuffer::new(iter);\n\n    if k == 0 {\n        // Special case, yields single empty vec; `n` is irrelevant\n        let state = PermutationState::Complete(CompleteState::Start { n: 0, k: 0 });\n\n        return Permutations {\n            vals,\n            state\n        };\n    }\n\n    let mut enough_vals = true;\n\n    while vals.len() < k {\n        if !vals.get_next() {\n            enough_vals = false;\n            break;\n        }\n    }\n\n    let state = if enough_vals {\n        PermutationState::StartUnknownLen { k }\n    } else {\n        PermutationState::Empty\n    };\n\n    Permutations {\n        vals,\n        state\n    }\n}\n\nimpl<I> Iterator for Permutations<I>\nwhere\n    I: Iterator,\n    I::Item: Clone\n{\n    type Item = Vec<I::Item>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.advance();\n\n        let &mut Permutations { ref vals, ref state } = self;\n\n        match state {\n            &PermutationState::StartUnknownLen { .. } => panic!(\"unexpected iterator state\"),\n            &PermutationState::OngoingUnknownLen { k, min_n } => {\n                let latest_idx = min_n - 1;\n                let indices = (0..(k - 1)).chain(once(latest_idx));\n\n                Some(indices.map(|i| vals[i].clone()).collect())\n            }\n            &PermutationState::Complete(CompleteState::Start { .. }) => None,\n            &PermutationState::Complete(CompleteState::Ongoing { ref indices, ref cycles }) => {\n                let k = cycles.len();\n\n                Some(indices[0..k].iter().map(|&i| vals[i].clone()).collect())\n            },\n            &PermutationState::Empty => None\n        }\n    }\n\n    fn count(self) -> usize {\n        let Permutations { vals, state } = self;\n\n        fn from_complete(complete_state: CompleteState) -> usize {\n            match complete_state.remaining() {\n                CompleteStateRemaining::Known(count) => count,\n                CompleteStateRemaining::Overflow => {\n                    panic!(\"Iterator count greater than usize::MAX\");\n                }\n            }\n        }\n\n        match state {\n            PermutationState::StartUnknownLen { k } => {\n                let n = vals.len() + vals.it.count();\n                let complete_state = CompleteState::Start { n, k };\n\n                from_complete(complete_state)\n            }\n            PermutationState::OngoingUnknownLen { k, min_n } => {\n                let prev_iteration_count = min_n - k + 1;\n                let n = vals.len() + vals.it.count();\n                let complete_state = CompleteState::Start { n, k };\n\n                from_complete(complete_state) - prev_iteration_count\n            },\n            PermutationState::Complete(state) => from_complete(state),\n            PermutationState::Empty => 0\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        match self.state {\n            PermutationState::StartUnknownLen { .. } |\n            PermutationState::OngoingUnknownLen { .. } => (0, None), // TODO can we improve this lower bound?\n            PermutationState::Complete(ref state) => match state.remaining() {\n                CompleteStateRemaining::Known(count) => (count, Some(count)),\n                CompleteStateRemaining::Overflow => (::std::usize::MAX, None)\n            }\n            PermutationState::Empty => (0, Some(0))\n        }\n    }\n}\n\nimpl<I> Permutations<I>\nwhere\n    I: Iterator,\n    I::Item: Clone\n{\n    fn advance(&mut self) {\n        let &mut Permutations { ref mut vals, ref mut state } = self;\n\n        *state = match state {\n            &mut PermutationState::StartUnknownLen { k } => {\n                PermutationState::OngoingUnknownLen { k, min_n: k }\n            }\n            &mut PermutationState::OngoingUnknownLen { k, min_n } => {\n                if vals.get_next() {\n                    PermutationState::OngoingUnknownLen { k, min_n: min_n + 1 }\n                } else {\n                    let n = min_n;\n                    let prev_iteration_count = n - k + 1;\n                    let mut complete_state = CompleteState::Start { n, k };\n\n                    // Advance the complete-state iterator to the correct point\n                    for _ in 0..(prev_iteration_count + 1) {\n                        complete_state.advance();\n                    }\n\n                    PermutationState::Complete(complete_state)\n                }\n            }\n            &mut PermutationState::Complete(ref mut state) => {\n                state.advance();\n\n                return;\n            }\n            &mut PermutationState::Empty => { return; }\n        };\n    }\n}\n\nimpl CompleteState {\n    fn advance(&mut self) {\n        *self = match self {\n            &mut CompleteState::Start { n, k } => {\n                let indices = (0..n).collect();\n                let cycles = ((n - k)..n).rev().collect();\n\n                CompleteState::Ongoing {\n                    cycles,\n                    indices\n                }\n            },\n            &mut CompleteState::Ongoing { ref mut indices, ref mut cycles } => {\n                let n = indices.len();\n                let k = cycles.len();\n\n                for i in (0..k).rev() {\n                    if cycles[i] == 0 {\n                        cycles[i] = n - i - 1;\n\n                        let to_push = indices.remove(i);\n                        indices.push(to_push);\n                    } else {\n                        let swap_index = n - cycles[i];\n                        indices.swap(i, swap_index);\n\n                        cycles[i] -= 1;\n                        return;\n                    }\n                }\n\n                CompleteState::Start { n, k }\n            }\n        }\n    }\n\n    fn remaining(&self) -> CompleteStateRemaining {\n        use self::CompleteStateRemaining::{Known, Overflow};\n\n        match self {\n            &CompleteState::Start { n, k } => {\n                if n < k {\n                    return Known(0);\n                }\n\n                let count: Option<usize> = (n - k + 1..n + 1).fold(Some(1), |acc, i| {\n                    acc.and_then(|acc| acc.checked_mul(i))\n                });\n\n                match count {\n                    Some(count) => Known(count),\n                    None => Overflow\n                }\n            }\n            &CompleteState::Ongoing { ref indices, ref cycles } => {\n                let mut count: usize = 0;\n\n                for (i, &c) in cycles.iter().enumerate() {\n                    let radix = indices.len() - i;\n                    let next_count = count.checked_mul(radix)\n                        .and_then(|count| count.checked_add(c));\n\n                    count = match next_count {\n                        Some(count) => count,\n                        None => { return Overflow; }\n                    };\n                }\n\n                Known(count)\n            }\n        }\n    }\n}\n","traces":[{"line":61,"address":[4250816,4250882],"length":1,"stats":{"Line":5},"fn_name":"permutations<adaptors_no_collect::PanickingCounter>"},{"line":62,"address":[4250844],"length":1,"stats":{"Line":5},"fn_name":null},{"line":64,"address":[4250897],"length":1,"stats":{"Line":5},"fn_name":null},{"line":66,"address":[4250921],"length":1,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[4251119],"length":1,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[4251016],"length":1,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[4251064],"length":1,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[4250908],"length":1,"stats":{"Line":4},"fn_name":null},{"line":76,"address":[4251208,4250916,4251264],"length":1,"stats":{"Line":12},"fn_name":null},{"line":77,"address":[4251243],"length":1,"stats":{"Line":4},"fn_name":null},{"line":78,"address":[4251266],"length":1,"stats":{"Line":3},"fn_name":null},{"line":83,"address":[4251296,4251274],"length":1,"stats":{"Line":7},"fn_name":null},{"line":86,"address":[4251284],"length":1,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[4561646,4561616],"length":1,"stats":{"Line":1},"fn_name":"from_complete"},{"line":129,"address":[4561663,4561735,4561620],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[4561678,4561737],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[4561705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[4772428,4772092],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[4561830,4561792],"length":1,"stats":{"Line":2},"fn_name":"advance"},{"line":209,"address":[4562308,4562607,4563080,4561845],"length":1,"stats":{"Line":6},"fn_name":null},{"line":210,"address":[4561847,4561807],"length":1,"stats":{"Line":4},"fn_name":null},{"line":211,"address":[4561887],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[4561945,4563290,4562072],"length":1,"stats":{"Line":4},"fn_name":null},{"line":214,"address":[4562200],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[4562104],"length":1,"stats":{"Line":2},"fn_name":null},{"line":216,"address":[4562152],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[4562313],"length":1,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[4562357],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[4562379],"length":1,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[4562898,4562401,4562612],"length":1,"stats":{"Line":3},"fn_name":null},{"line":224,"address":[4562662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[4562745,4563170],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[4562846],"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[4562876],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[4563230,4562700,4562913],"length":1,"stats":{"Line":2},"fn_name":null},{"line":231,"address":[4562946],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[4563260,4563002],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[4562563],"length":1,"stats":{"Line":2},"fn_name":null},{"line":243,"address":[4563376],"length":1,"stats":{"Line":1},"fn_name":"remaining"},{"line":246,"address":[4563756,4563408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[4563388,4563410],"length":1,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[4563441],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[4563488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[4559792],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":253,"address":[4559742,4559816,4559728],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":256,"address":[4563714],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[4563718,4563688],"length":1,"stats":{"Line":2},"fn_name":null},{"line":258,"address":[4563705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[4563761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[4563799],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[4563811,4564358,4564040],"length":1,"stats":{"Line":2},"fn_name":null},{"line":265,"address":[4564363,4564141],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[4564203,4564250],"length":1,"stats":{"Line":2},"fn_name":null},{"line":267,"address":[4559872,4559886],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":269,"address":[4564324,4564350],"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[4564293,4564326],"length":1,"stats":{"Line":2},"fn_name":null},{"line":271,"address":[4564310],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[4564013],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":104,"coverable":113},{"path":["/","home","kms","itertools","src","process_results_impl.rs"],"content":"\n/// An iterator that produces only the `T` values as long as the\n/// inner iterator produces `Ok(T)`.\n///\n/// Used by [`process_results`](../fn.process_results.html), see its docs\n/// for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Debug)]\npub struct ProcessResults<'a, I, E: 'a> {\n    error: &'a mut Result<(), E>,\n    iter: I,\n}\n\nimpl<'a, I, T, E> Iterator for ProcessResults<'a, I, E>\n    where I: Iterator<Item = Result<T, E>>\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.iter.next() {\n            Some(Ok(x)) => Some(x),\n            Some(Err(e)) => {\n                *self.error = Err(e);\n                None\n            }\n            None => None,\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, hi) = self.iter.size_hint();\n        (0, hi)\n    }\n}\n\n/// “Lift” a function of the values of an iterator so that it can process\n/// an iterator of `Result` values instead.\n///\n/// `iterable` is an iterator or iterable with `Result<T, E>` elements, where\n/// `T` is the value type and `E` the error type.\n///\n/// `processor` is a closure that receives an adapted version of the iterable\n/// as the only argument — the adapted iterator produces elements of type `T`,\n/// as long as the original iterator produces `Ok` values.\n///\n/// If the original iterable produces an error at any point, the adapted\n/// iterator ends and the `process_results` function will return the\n/// error iself.\n///\n/// Otherwise, the return value from the closure is returned wrapped\n/// inside `Ok`.\n///\n/// # Example\n///\n/// ```\n/// use itertools::process_results;\n///\n/// type R = Result<i32, &'static str>;\n///\n/// let first_values: Vec<R> = vec![Ok(1), Ok(0), Ok(3)];\n/// let second_values: Vec<R> = vec![Ok(2), Ok(1), Err(\"overflow\")];\n///\n/// // “Lift” the iterator .max() method to work on the values in Results using process_results\n///\n/// let first_max = process_results(first_values, |iter| iter.max().unwrap_or(0));\n/// let second_max = process_results(second_values, |iter| iter.max().unwrap_or(0));\n///\n/// assert_eq!(first_max, Ok(3));\n/// assert!(second_max.is_err());\n/// ```\npub fn process_results<I, F, T, E, R>(iterable: I, processor: F) -> Result<R, E>\n    where I: IntoIterator<Item = Result<T, E>>,\n          F: FnOnce(ProcessResults<I::IntoIter, E>) -> R\n{\n    let iter = iterable.into_iter();\n    let mut error = Ok(());\n\n    let result = processor(ProcessResults { error: &mut error, iter });\n\n    error.map(|_| result)\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","home","kms","itertools","src","put_back_n_impl.rs"],"content":"use crate::size_hint;\n\n/// An iterator adaptor that allows putting multiple\n/// items in front of the iterator.\n///\n/// Iterator element type is `I::Item`.\n#[derive(Debug, Clone)]\npub struct PutBackN<I: Iterator> {\n    top: Vec<I::Item>,\n    iter: I,\n}\n\n/// Create an iterator where you can put back multiple values to the front\n/// of the iteration.\n///\n/// Iterator element type is `I::Item`.\npub fn put_back_n<I>(iterable: I) -> PutBackN<I::IntoIter>\n    where I: IntoIterator\n{\n    PutBackN {\n        top: Vec::new(),\n        iter: iterable.into_iter(),\n    }\n}\n\nimpl<I: Iterator> PutBackN<I> {\n    /// Puts x in front of the iterator.\n    /// The values are yielded in order of the most recently put back\n    /// values first.\n    ///\n    /// ```rust\n    /// use itertools::put_back_n;\n    ///\n    /// let mut it = put_back_n(1..5);\n    /// it.next();\n    /// it.put_back(1);\n    /// it.put_back(0);\n    ///\n    /// assert!(itertools::equal(it, 0..5));\n    /// ```\n    #[inline]\n    pub fn put_back(&mut self, x: I::Item) {\n        self.top.push(x);\n    }\n}\n\nimpl<I: Iterator> Iterator for PutBackN<I> {\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.top.pop().or_else(|| self.iter.next())\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add_scalar(self.iter.size_hint(), self.top.len())\n    }\n}\n\n","traces":[{"line":17,"address":[5814240,5814293],"length":1,"stats":{"Line":3},"fn_name":"put_back_n<alloc::vec::IntoIter<u8>>"},{"line":21,"address":[5814250],"length":1,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[4240046],"length":1,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[4862349],"length":1,"stats":{"Line":3},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","kms","itertools","src","rciter_impl.rs"],"content":"\nuse std::iter::IntoIterator;\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n/// A wrapper for `Rc<RefCell<I>>`, that implements the `Iterator` trait.\n#[derive(Debug)]\npub struct RcIter<I> {\n    /// The boxed iterator.\n    pub rciter: Rc<RefCell<I>>,\n}\n\n/// Return an iterator inside a `Rc<RefCell<_>>` wrapper.\n///\n/// The returned `RcIter` can be cloned, and each clone will refer back to the\n/// same original iterator.\n///\n/// `RcIter` allows doing interesting things like using `.zip()` on an iterator with\n/// itself, at the cost of runtime borrow checking which may have a performance\n/// penalty.\n///\n/// Iterator element type is `Self::Item`.\n///\n/// ```\n/// use itertools::rciter;\n/// use itertools::zip;\n///\n/// // In this example a range iterator is created and we iterate it using\n/// // three separate handles (two of them given to zip).\n/// // We also use the IntoIterator implementation for `&RcIter`.\n///\n/// let mut iter = rciter(0..9);\n/// let mut z = zip(&iter, &iter);\n///\n/// assert_eq!(z.next(), Some((0, 1)));\n/// assert_eq!(z.next(), Some((2, 3)));\n/// assert_eq!(z.next(), Some((4, 5)));\n/// assert_eq!(iter.next(), Some(6));\n/// assert_eq!(z.next(), Some((7, 8)));\n/// assert_eq!(z.next(), None);\n/// ```\n///\n/// **Panics** in iterator methods if a borrow error is encountered in the\n/// iterator methods. It can only happen if the `RcIter` is reentered in\n/// `.next()`, i.e. if it somehow participates in an “iterator knot”\n/// where it is an adaptor of itself.\npub fn rciter<I>(iterable: I) -> RcIter<I::IntoIter>\n    where I: IntoIterator\n{\n    RcIter { rciter: Rc::new(RefCell::new(iterable.into_iter())) }\n}\n\nimpl<I> Clone for RcIter<I> {\n    #[inline]\n    clone_fields!(rciter);\n}\n\nimpl<A, I> Iterator for RcIter<I>\n    where I: Iterator<Item = A>\n{\n    type Item = A;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.rciter.borrow_mut().next()\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // To work sanely with other API that assume they own an iterator,\n        // so it can't change in other places, we can't guarantee as much\n        // in our size_hint. Other clones may drain values under our feet.\n        let (_, hi) = self.rciter.borrow().size_hint();\n        (0, hi)\n    }\n}\n\nimpl<I> DoubleEndedIterator for RcIter<I>\n    where I: DoubleEndedIterator\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.rciter.borrow_mut().next_back()\n    }\n}\n\n/// Return an iterator from `&RcIter<I>` (by simply cloning it).\nimpl<'a, I> IntoIterator for &'a RcIter<I>\n    where I: Iterator\n{\n    type Item = I::Item;\n    type IntoIter = RcIter<I>;\n\n    fn into_iter(self) -> RcIter<I> {\n        self.clone()\n    }\n}\n","traces":[{"line":47,"address":[4700016,4699920],"length":1,"stats":{"Line":3},"fn_name":"rciter<core::ops::range::Range<i32>>"},{"line":50,"address":[4700030,4699932],"length":1,"stats":{"Line":3},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":9,"coverable":11},{"path":["/","home","kms","itertools","src","repeatn.rs"],"content":"\n/// An iterator that produces *n* repetitions of an element.\n///\n/// See [`repeat_n()`](../fn.repeat_n.html) for more information.\n#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n#[derive(Clone, Debug)]\npub struct RepeatN<A> {\n    elt: Option<A>,\n    n: usize,\n}\n\n/// Create an iterator that produces `n` repetitions of `element`.\npub fn repeat_n<A>(element: A, n: usize) -> RepeatN<A>\n    where A: Clone,\n{\n    if n == 0 {\n        RepeatN { elt: None, n, }\n    } else {\n        RepeatN { elt: Some(element), n, }\n    }\n}\n\nimpl<A> Iterator for RepeatN<A>\n    where A: Clone\n{\n    type Item = A;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.n > 1 {\n            self.n -= 1;\n            self.elt.as_ref().cloned()\n        } else {\n            self.n = 0;\n            self.elt.take()\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (self.n, Some(self.n))\n    }\n}\n\nimpl<A> DoubleEndedIterator for RepeatN<A>\n    where A: Clone\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.next()\n    }\n}\n\nimpl<A> ExactSizeIterator for RepeatN<A>\n    where A: Clone\n{}\n","traces":[{"line":13,"address":[4316192,4316368],"length":1,"stats":{"Line":3},"fn_name":"repeat_n<test_core::count_clones::Foo>"},{"line":16,"address":[4958480,4958555],"length":1,"stats":{"Line":6},"fn_name":null},{"line":19,"address":[4316417,4316236],"length":1,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[4958192],"length":1,"stats":{"Line":3},"fn_name":"next<i32>"},{"line":29,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":30,"address":[4316103,4315915,4315788,4315885,4315976,4316073],"length":1,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":11,"coverable":13},{"path":["/","home","kms","itertools","src","size_hint.rs"],"content":"//! Arithmetic on **Iterator** *.size_hint()* values.\n//!\n\nuse std::usize;\nuse std::cmp;\n\n/// **SizeHint** is the return type of **Iterator::size_hint()**.\npub type SizeHint = (usize, Option<usize>);\n\n/// Add **SizeHint** correctly.\n#[inline]\npub fn add(a: SizeHint, b: SizeHint) -> SizeHint {\n    let min = a.0.checked_add(b.0).unwrap_or(usize::MAX);\n    let max = match (a.1, b.1) {\n        (Some(x), Some(y)) => x.checked_add(y),\n        _ => None,\n    };\n\n    (min, max)\n}\n\n/// Add **x** correctly to a **SizeHint**.\n#[inline]\npub fn add_scalar(sh: SizeHint, x: usize) -> SizeHint {\n    let (mut low, mut hi) = sh;\n    low = low.saturating_add(x);\n    hi = hi.and_then(|elt| elt.checked_add(x));\n    (low, hi)\n}\n\n/// Sbb **x** correctly to a **SizeHint**.\n#[inline]\n#[allow(dead_code)]\npub fn sub_scalar(sh: SizeHint, x: usize) -> SizeHint {\n    let (mut low, mut hi) = sh;\n    low = low.saturating_sub(x);\n    hi = hi.map(|elt| elt.saturating_sub(x));\n    (low, hi)\n}\n\n\n/// Multiply **SizeHint** correctly\n///\n/// ```ignore\n/// use std::usize;\n/// use itertools::size_hint;\n///\n/// assert_eq!(size_hint::mul((3, Some(4)), (3, Some(4))),\n///            (9, Some(16)));\n///\n/// assert_eq!(size_hint::mul((3, Some(4)), (usize::MAX, None)),\n///            (usize::MAX, None));\n///\n/// assert_eq!(size_hint::mul((3, None), (0, Some(0))),\n///            (0, Some(0)));\n/// ```\n#[inline]\npub fn mul(a: SizeHint, b: SizeHint) -> SizeHint {\n    let low = a.0.checked_mul(b.0).unwrap_or(usize::MAX);\n    let hi = match (a.1, b.1) {\n        (Some(x), Some(y)) => x.checked_mul(y),\n        (Some(0), None) | (None, Some(0)) => Some(0),\n        _ => None,\n    };\n    (low, hi)\n}\n\n/// Multiply **x** correctly with a **SizeHint**.\n#[inline]\npub fn mul_scalar(sh: SizeHint, x: usize) -> SizeHint {\n    let (mut low, mut hi) = sh;\n    low = low.saturating_mul(x);\n    hi = hi.and_then(|elt| elt.checked_mul(x));\n    (low, hi)\n}\n\n/// Return the maximum\n#[inline]\npub fn max(a: SizeHint, b: SizeHint) -> SizeHint {\n    let (a_lower, a_upper) = a;\n    let (b_lower, b_upper) = b;\n\n    let lower = cmp::max(a_lower, b_lower);\n\n    let upper = match (a_upper, b_upper) {\n        (Some(x), Some(y)) => Some(cmp::max(x, y)),\n        _ => None,\n    };\n\n    (lower, upper)\n}\n\n/// Return the minimum\n#[inline]\npub fn min(a: SizeHint, b: SizeHint) -> SizeHint {\n    let (a_lower, a_upper) = a;\n    let (b_lower, b_upper) = b;\n    let lower = cmp::min(a_lower, b_lower);\n    let upper = match (a_upper, b_upper) {\n        (Some(u1), Some(u2)) => Some(cmp::min(u1, u2)),\n        _ => a_upper.or(b_upper),\n    };\n    (lower, upper)\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":27,"address":[4556368,4556382],"length":1,"stats":{"Line":18},"fn_name":"{{closure}}"},{"line":28,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[4556446,4556432],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[4556480,4556494],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":83,"address":[4220174],"length":1,"stats":{"Line":3},"fn_name":null},{"line":85,"address":[4220328,4220208],"length":1,"stats":{"Line":5},"fn_name":null},{"line":86,"address":[4220251,4220330],"length":1,"stats":{"Line":6},"fn_name":null},{"line":87,"address":[4220319],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[4220359],"length":1,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":38,"coverable":43},{"path":["/","home","kms","itertools","src","sources.rs"],"content":"//! Iterators that are sources (produce elements from parameters,\n//! not from another iterator).\n#![allow(deprecated)]\n\nuse std::fmt;\nuse std::mem;\n\n/// See [`repeat_call`](../fn.repeat_call.html) for more information.\n#[derive(Clone)]\n#[deprecated(note=\"Use std repeat_with() instead\", since=\"0.8\")]\npub struct RepeatCall<F> {\n    f: F,\n}\n\nimpl<F> fmt::Debug for RepeatCall<F>\n{\n    debug_fmt_fields!(RepeatCall, );\n}\n\n/// An iterator source that produces elements indefinitely by calling\n/// a given closure.\n///\n/// Iterator element type is the return type of the closure.\n///\n/// ```\n/// use itertools::repeat_call;\n/// use itertools::Itertools;\n/// use std::collections::BinaryHeap;\n///\n/// let mut heap = BinaryHeap::from(vec![2, 5, 3, 7, 8]);\n///\n/// // extract each element in sorted order\n/// for element in repeat_call(|| heap.pop()).while_some() {\n///     print!(\"{}\", element);\n/// }\n///\n/// itertools::assert_equal(\n///     repeat_call(|| 1).take(5),\n///     vec![1, 1, 1, 1, 1]\n/// );\n/// ```\n#[deprecated(note=\"Use std repeat_with() instead\", since=\"0.8\")]\npub fn repeat_call<F, A>(function: F) -> RepeatCall<F>\n    where F: FnMut() -> A\n{\n    RepeatCall { f: function }\n}\n\nimpl<A, F> Iterator for RepeatCall<F>\n    where F: FnMut() -> A\n{\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        Some((self.f)())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (usize::max_value(), None)\n    }\n}\n\n/// Creates a new unfold source with the specified closure as the \"iterator\n/// function\" and an initial state to eventually pass to the closure\n///\n/// `unfold` is a general iterator builder: it has a mutable state value,\n/// and a closure with access to the state that produces the next value.\n///\n/// This more or less equivalent to a regular struct with an `Iterator`\n/// implementation, and is useful for one-off iterators.\n///\n/// ```\n/// // an iterator that yields sequential Fibonacci numbers,\n/// // and stops at the maximum representable value.\n///\n/// use itertools::unfold;\n///\n/// let (mut x1, mut x2) = (1u32, 1u32);\n/// let mut fibonacci = unfold((), move |_| {\n///     // Attempt to get the next Fibonacci number\n///     let next = x1.saturating_add(x2);\n///\n///     // Shift left: ret <- x1 <- x2 <- next\n///     let ret = x1;\n///     x1 = x2;\n///     x2 = next;\n///\n///     // If addition has saturated at the maximum, we are finished\n///     if ret == x1 && ret > 1 {\n///         return None;\n///     }\n///\n///     Some(ret)\n/// });\n///\n/// itertools::assert_equal(fibonacci.by_ref().take(8),\n///                         vec![1, 1, 2, 3, 5, 8, 13, 21]);\n/// assert_eq!(fibonacci.last(), Some(2_971_215_073))\n/// ```\npub fn unfold<A, St, F>(initial_state: St, f: F) -> Unfold<St, F>\n    where F: FnMut(&mut St) -> Option<A>\n{\n    Unfold {\n        f,\n        state: initial_state,\n    }\n}\n\nimpl<St, F> fmt::Debug for Unfold<St, F>\n    where St: fmt::Debug,\n{\n    debug_fmt_fields!(Unfold, state);\n}\n\n/// See [`unfold`](../fn.unfold.html) for more information.\n#[derive(Clone)]\n#[must_use = \"iterators are lazy and do nothing unless consumed\"]\npub struct Unfold<St, F> {\n    f: F,\n    /// Internal state that will be passed to the closure on the next iteration\n    pub state: St,\n}\n\nimpl<A, St, F> Iterator for Unfold<St, F>\n    where F: FnMut(&mut St) -> Option<A>\n{\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        (self.f)(&mut self.state)\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // no possible known bounds at this point\n        (0, None)\n    }\n}\n\n/// An iterator that infinitely applies function to value and yields results.\n///\n/// This `struct` is created by the [`iterate()`] function. See its documentation for more.\n///\n/// [`iterate()`]: ../fn.iterate.html\n#[derive(Clone)]\n#[must_use = \"iterators are lazy and do nothing unless consumed\"]\npub struct Iterate<St, F> {\n    state: St,\n    f: F,\n}\n\nimpl<St, F> fmt::Debug for Iterate<St, F>\n    where St: fmt::Debug,\n{\n    debug_fmt_fields!(Iterate, state);\n}\n\nimpl<St, F> Iterator for Iterate<St, F>\n    where F: FnMut(&St) -> St\n{\n    type Item = St;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let next_state = (self.f)(&self.state);\n        Some(mem::replace(&mut self.state, next_state))\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (usize::max_value(), None)\n    }\n}\n\n/// Creates a new iterator that infinitely applies function to value and yields results.\n///\n/// ```\n/// use itertools::iterate;\n///\n/// itertools::assert_equal(iterate(1, |&i| i * 3).take(5), vec![1, 3, 9, 27, 81]);\n/// ```\npub fn iterate<St, F>(initial_value: St, f: F) -> Iterate<St, F>\n    where F: FnMut(&St) -> St\n{\n    Iterate {\n        state: initial_value,\n        f,\n    }\n}\n","traces":[{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":13},{"path":["/","home","kms","itertools","src","tee.rs"],"content":"use super::size_hint;\n\nuse std::cell::RefCell;\nuse std::collections::VecDeque;\nuse std::rc::Rc;\n\n/// Common buffer object for the two tee halves\n#[derive(Debug)]\nstruct TeeBuffer<A, I> {\n    backlog: VecDeque<A>,\n    iter: I,\n    /// The owner field indicates which id should read from the backlog\n    owner: bool,\n}\n\n/// One half of an iterator pair where both return the same elements.\n///\n/// See [`.tee()`](../trait.Itertools.html#method.tee) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Debug)]\npub struct Tee<I>\n    where I: Iterator\n{\n    rcbuffer: Rc<RefCell<TeeBuffer<I::Item, I>>>,\n    id: bool,\n}\n\npub fn new<I>(iter: I) -> (Tee<I>, Tee<I>)\n    where I: Iterator\n{\n    let buffer = TeeBuffer{backlog: VecDeque::new(), iter, owner: false};\n    let t1 = Tee{rcbuffer: Rc::new(RefCell::new(buffer)), id: true};\n    let t2 = Tee{rcbuffer: t1.rcbuffer.clone(), id: false};\n    (t1, t2)\n}\n\nimpl<I> Iterator for Tee<I>\n    where I: Iterator,\n          I::Item: Clone\n{\n    type Item = I::Item;\n    fn next(&mut self) -> Option<Self::Item> {\n        // .borrow_mut may fail here -- but only if the user has tied some kind of weird\n        // knot where the iterator refers back to itself.\n        let mut buffer = self.rcbuffer.borrow_mut();\n        if buffer.owner == self.id {\n            match buffer.backlog.pop_front() {\n                None => {}\n                some_elt => return some_elt,\n            }\n        }\n        match buffer.iter.next() {\n            None => None,\n            Some(elt) => {\n                buffer.backlog.push_back(elt.clone());\n                buffer.owner = !self.id;\n                Some(elt)\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let buffer = self.rcbuffer.borrow();\n        let sh = buffer.iter.size_hint();\n\n        if buffer.owner == self.id {\n            let log_len = buffer.backlog.len();\n            size_hint::add_scalar(sh, log_len)\n        } else {\n            sh\n        }\n    }\n}\n\nimpl<I> ExactSizeIterator for Tee<I>\n    where I: ExactSizeIterator,\n          I::Item: Clone\n{}\n","traces":[{"line":28,"address":[4957264,4957325,4957712,4957768],"length":1,"stats":{"Line":3},"fn_name":"new<core::slice::Iter<u8>>"},{"line":31,"address":[4957340,4957284,4957722,4957783],"length":1,"stats":{"Line":6},"fn_name":null},{"line":32,"address":[4597812],"length":1,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[4597936],"length":1,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[4597967],"length":1,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[4596912,4596987],"length":1,"stats":{"Line":3},"fn_name":"next<core::iter::adapters::Cloned<core::slice::Iter<i32>>>"},{"line":45,"address":[4597007,4596924,4596985],"length":1,"stats":{"Line":9},"fn_name":null},{"line":46,"address":[4597219,4597027],"length":1,"stats":{"Line":6},"fn_name":null},{"line":47,"address":[4597083],"length":1,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[4597131],"length":1,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[4955955,4955171,4955225,4956009],"length":1,"stats":{"Line":6},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":53,"address":[4956079,4955291,4955318,4956106],"length":1,"stats":{"Line":6},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":24,"coverable":24},{"path":["/","home","kms","itertools","src","tuple_impl.rs"],"content":"//! Some iterator that produces tuples\n\nuse std::iter::Fuse;\nuse std::iter::Take;\nuse std::iter::Cycle;\nuse std::marker::PhantomData;\n\n// `HomogeneousTuple` is a public facade for `TupleCollect`, allowing\n// tuple-related methods to be used by clients in generic contexts, while\n// hiding the implementation details of `TupleCollect`.\n// See https://github.com/rust-itertools/itertools/issues/387\n\n/// Implemented for homogeneous tuples of size up to 4.\npub trait HomogeneousTuple\n    : TupleCollect\n{}\n\nimpl<T: TupleCollect> HomogeneousTuple for T {}\n\n/// An iterator over a incomplete tuple.\n///\n/// See [`.tuples()`](../trait.Itertools.html#method.tuples) and\n/// [`Tuples::into_buffer()`](struct.Tuples.html#method.into_buffer).\n#[derive(Clone, Debug)]\npub struct TupleBuffer<T>\n    where T: HomogeneousTuple\n{\n    cur: usize,\n    buf: T::Buffer,\n}\n\nimpl<T> TupleBuffer<T>\n    where T: HomogeneousTuple\n{\n    fn new(buf: T::Buffer) -> Self {\n        TupleBuffer {\n            cur: 0,\n            buf,\n        }\n    }\n}\n\nimpl<T> Iterator for TupleBuffer<T>\n    where T: HomogeneousTuple\n{\n    type Item = T::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let s = self.buf.as_mut();\n        if let Some(ref mut item) = s.get_mut(self.cur) {\n            self.cur += 1;\n            item.take()\n        } else {\n            None\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let buffer = &self.buf.as_ref()[self.cur..];\n        let len = if buffer.len() == 0 {\n            0\n        } else {\n            buffer.iter()\n                  .position(|x| x.is_none())\n                  .unwrap_or(buffer.len())\n        };\n        (len, Some(len))\n    }\n}\n\nimpl<T> ExactSizeIterator for TupleBuffer<T>\n    where T: HomogeneousTuple\n{\n}\n\n/// An iterator that groups the items in tuples of a specific size.\n///\n/// See [`.tuples()`](../trait.Itertools.html#method.tuples) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Tuples<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    iter: Fuse<I>,\n    buf: T::Buffer,\n}\n\n/// Create a new tuples iterator.\npub fn tuples<I, T>(iter: I) -> Tuples<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    Tuples {\n        iter: iter.fuse(),\n        buf: Default::default(),\n    }\n}\n\nimpl<I, T> Iterator for Tuples<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        T::collect_from_iter(&mut self.iter, &mut self.buf)\n    }\n}\n\nimpl<I, T> Tuples<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    /// Return a buffer with the produced items that was not enough to be grouped in a tuple.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut iter = (0..5).tuples();\n    /// assert_eq!(Some((0, 1, 2)), iter.next());\n    /// assert_eq!(None, iter.next());\n    /// itertools::assert_equal(vec![3, 4], iter.into_buffer());\n    /// ```\n    pub fn into_buffer(self) -> TupleBuffer<T> {\n        TupleBuffer::new(self.buf)\n    }\n}\n\n\n/// An iterator over all contiguous windows that produces tuples of a specific size.\n///\n/// See [`.tuple_windows()`](../trait.Itertools.html#method.tuple_windows) for more\n/// information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Clone, Debug)]\npub struct TupleWindows<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    iter: I,\n    last: Option<T>,\n}\n\n/// Create a new tuple windows iterator.\npub fn tuple_windows<I, T>(mut iter: I) -> TupleWindows<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple,\n          T::Item: Clone\n{\n    use std::iter::once;\n\n    let mut last = None;\n    if T::num_items() != 1 {\n        // put in a duplicate item in front of the tuple; this simplifies\n        // .next() function.\n        if let Some(item) = iter.next() {\n            let iter = once(item.clone()).chain(once(item)).chain(&mut iter);\n            last = T::collect_from_iter_no_buf(iter);\n        }\n    }\n\n    TupleWindows {\n        last,\n        iter,\n    }\n}\n\nimpl<I, T> Iterator for TupleWindows<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple + Clone,\n          T::Item: Clone\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if T::num_items() == 1 {\n            return T::collect_from_iter_no_buf(&mut self.iter)\n        }\n        if let Some(ref mut last) = self.last {\n            if let Some(new) = self.iter.next() {\n                last.left_shift_push(new);\n                return Some(last.clone());\n            }\n        }\n        None\n    }\n}\n\n/// An iterator over all windows,wrapping back to the first elements when the\n/// window would otherwise exceed the length of the iterator, producing tuples\n/// of a specific size.\n///\n/// See [`.circular_tuple_windows()`](../trait.Itertools.html#method.circular_tuple_windows) for more\n/// information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Debug)]\npub struct CircularTupleWindows<I, T: Clone>\n    where I: Iterator<Item = T::Item> + Clone,\n          T: TupleCollect + Clone\n{\n    iter: Take<TupleWindows<Cycle<I>, T>>,\n    phantom_data: PhantomData<T>\n}\n\npub fn circular_tuple_windows<I, T>(iter: I) -> CircularTupleWindows<I, T>\n    where I: Iterator<Item = T::Item> + Clone + ExactSizeIterator,\n          T: TupleCollect + Clone,\n          T::Item: Clone\n{\n    let len = iter.len();\n    let iter = tuple_windows(iter.cycle()).take(len);\n\n    CircularTupleWindows {\n        iter: iter,\n        phantom_data: PhantomData{}\n    }\n}\n\nimpl<I, T> Iterator for CircularTupleWindows<I, T>\n    where I: Iterator<Item = T::Item> + Clone,\n          T: TupleCollect + Clone,\n          T::Item: Clone\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next()\n    }\n}\n\npub trait TupleCollect: Sized {\n    type Item;\n    type Buffer: Default + AsRef<[Option<Self::Item>]> + AsMut<[Option<Self::Item>]>;\n\n    fn collect_from_iter<I>(iter: I, buf: &mut Self::Buffer) -> Option<Self>\n        where I: IntoIterator<Item = Self::Item>;\n\n    fn collect_from_iter_no_buf<I>(iter: I) -> Option<Self>\n        where I: IntoIterator<Item = Self::Item>;\n\n    fn num_items() -> usize;\n\n    fn left_shift_push(&mut self, item: Self::Item);\n}\n\nmacro_rules! impl_tuple_collect {\n    ($N:expr; $A:ident ; $($X:ident),* ; $($Y:ident),* ; $($Y_rev:ident),*) => (\n        impl<$A> TupleCollect for ($($X),*,) {\n            type Item = $A;\n            type Buffer = [Option<$A>; $N - 1];\n\n            #[allow(unused_assignments, unused_mut)]\n            fn collect_from_iter<I>(iter: I, buf: &mut Self::Buffer) -> Option<Self>\n                where I: IntoIterator<Item = $A>\n            {\n                let mut iter = iter.into_iter();\n                $(\n                    let mut $Y = None;\n                )*\n\n                loop {\n                    $(\n                        $Y = iter.next();\n                        if $Y.is_none() {\n                            break\n                        }\n                    )*\n                    return Some(($($Y.unwrap()),*,))\n                }\n\n                let mut i = 0;\n                let mut s = buf.as_mut();\n                $(\n                    if i < s.len() {\n                        s[i] = $Y;\n                        i += 1;\n                    }\n                )*\n                return None;\n            }\n\n            #[allow(unused_assignments)]\n            fn collect_from_iter_no_buf<I>(iter: I) -> Option<Self>\n                where I: IntoIterator<Item = $A>\n            {\n                let mut iter = iter.into_iter();\n                loop {\n                    $(\n                        let $Y = if let Some($Y) = iter.next() {\n                            $Y\n                        } else {\n                            break;\n                        };\n                    )*\n                    return Some(($($Y),*,))\n                }\n\n                return None;\n            }\n\n            fn num_items() -> usize {\n                $N\n            }\n\n            fn left_shift_push(&mut self, item: $A) {\n                use std::mem::replace;\n\n                let &mut ($(ref mut $Y),*,) = self;\n                let tmp = item;\n                $(\n                    let tmp = replace($Y_rev, tmp);\n                )*\n                drop(tmp);\n            }\n        }\n    )\n}\n\nimpl_tuple_collect!(1; A; A; a; a);\nimpl_tuple_collect!(2; A; A, A; a, b; b, a);\nimpl_tuple_collect!(3; A; A, A, A; a, b, c; c, b, a);\nimpl_tuple_collect!(4; A; A, A, A, A; a, b, c, d; d, c, b, a);\n","traces":[{"line":35,"address":[4234384,4234544,4234448,4234480],"length":1,"stats":{"Line":5},"fn_name":"new<(i32, i32, i32)>"},{"line":48,"address":[4217488,4217040,4217264,4216832],"length":1,"stats":{"Line":5},"fn_name":"next<(i32)>"},{"line":49,"address":[4217273,4216841,4217497,4217049],"length":1,"stats":{"Line":5},"fn_name":null},{"line":50,"address":[4217076,4217432,4216861,4217585,4217208,4216993,4217137,4217361,4217524,4216922,4217300,4217656],"length":1,"stats":{"Line":13},"fn_name":null},{"line":51,"address":[4217253,4217477,4217597,4217008,4217671,4217701,4217038,4216934,4217223,4217373,4217149,4217447],"length":1,"stats":{"Line":5},"fn_name":null},{"line":52,"address":[4217411,4216972,4217187,4217635],"length":1,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[4216914,4217129,4217577,4217353],"length":1,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[4234836,4234784,4235104,4234944,4234675,4235155,4234624,4234996],"length":1,"stats":{"Line":8},"fn_name":"tuples<core::iter::adapters::Cloned<core::slice::Iter<i32>>,(i32, i32, i32)>"},{"line":95,"address":[4235121,4234961,4234641,4234801],"length":1,"stats":{"Line":8},"fn_name":null},{"line":96,"address":[4235013,4234867,4235167,4234692,4234848],"length":1,"stats":{"Line":10},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":125,"address":[4234144,4234224,4234177,4234304,4234257,4234101,4234080,4234346],"length":1,"stats":{"Line":5},"fn_name":"into_buffer<core::iter::adapters::Cloned<core::slice::Iter<i32>>,(i32)>"},{"line":126,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":146,"address":[4232666,4231274,4231946,4231872,4233360,4233434,4232592,4231200],"length":1,"stats":{"Line":8},"fn_name":"tuple_windows<core::iter::adapters::Cloned<core::slice::Iter<i32>>,(i32)>"},{"line":153,"address":[4231220,4231892,4232612,4233380],"length":1,"stats":{"Line":8},"fn_name":null},{"line":154,"address":[4231262,4231934,4231966,4233244,4231294,4232686,4231765,4232654,4233422,4233968,4232486,4233454],"length":1,"stats":{"Line":22},"fn_name":null},{"line":157,"address":[4231314,4232706,4231986,4233474],"length":1,"stats":{"Line":6},"fn_name":null},{"line":158,"address":[4233167,4232070,4233904,4232129,4232420,4232790,4231398,4233558,4231457,4232849,4233617,4231709],"length":1,"stats":{"Line":12},"fn_name":null},{"line":159,"address":[4232245,4233733,4233189,4231735,4232442,4231573,4232968,4233926],"length":1,"stats":{"Line":12},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[4226884,4223300,4219072,4220368,4220468,4223184,4226752,4219122],"length":1,"stats":{"Line":8},"fn_name":"collect_from_iter<i32,&mut core::iter::adapters::Fuse<core::iter::adapters::Cloned<core::slice::Iter<i32>>>>"},{"line":257,"address":[4223210,4219089,4226778,4220394],"length":1,"stats":{"Line":8},"fn_name":null},{"line":259,"address":[4226899,4219137,4220483,4223315],"length":1,"stats":{"Line":8},"fn_name":null},{"line":264,"address":[4220602,4227249,4223604,4224618,4219175,4223630,4221310,4220646,4226983,4227296,4223531,4228650,4228711,4220529,4221362,4224557,4228589,4220663,4227322,4228528,4223380,4224679,4223484,4227223,4227103,4227150,4227176,4223557,4219158,4219540],"length":1,"stats":{"Line":60},"fn_name":null},{"line":265,"address":[4228694,4228755,4224601,4221348,4228633,4227196,4220619,4219569,4227342,4219192,4227269,4228572,4223650,4220680,4221400,4223504,4223577,4224723,4227123,4224662],"length":1,"stats":{"Line":40},"fn_name":null},{"line":266,"address":[4227244,4227171,4227317,4227397,4220661,4223552,4223705,4223625,4220732],"length":1,"stats":{"Line":12},"fn_name":null},{"line":269,"address":[4223669,4220737,4223710,4227402,4219205,4227361,4220699,4219267],"length":1,"stats":{"Line":16},"fn_name":null},{"line":272,"address":[4220544,4219232,4227004,4223401],"length":1,"stats":{"Line":8},"fn_name":null},{"line":273,"address":[4223413,4223959,4220556,4219241,4227016,4219330,4220896,4227726],"length":1,"stats":{"Line":16},"fn_name":null},{"line":275,"address":[4224150,4219351,4228108,4223983,4227750,4221084,4228275,4224317,4220917,4227941],"length":1,"stats":{"Line":20},"fn_name":null},{"line":276,"address":[4221440,4225335,4224039,4229180,4228164,4225254,4229305,4219596,4229604,4224779,4227997,4229520,4221140,4229055,4228331,4219686,4225001,4220973,4224876,4224206,4221537,4221662,4224373,4225126,4219404,4229439,4227818,4228824,4228930,4221790],"length":1,"stats":{"Line":18},"fn_name":null},{"line":277,"address":[4224940,4221476,4219486,4229119,4221234,4229571,4228869,4224468,4224301,4229244,4221760,4225386,4219810,4228092,4219780,4228426,4229409,4225224,4227925,4225065,4219632,4228259,4221601,4224134,4221837,4221068,4229487,4225302,4224815,4229655,4228994],"length":1,"stats":{"Line":24},"fn_name":null},{"line":280,"address":[4221258,4224492,4228450,4219499],"length":1,"stats":{"Line":8},"fn_name":null},{"line":284,"address":[4230573,4220074,4226043,4230528,4229835,4225517,4222704,4225472,4229760,4220048,4219824,4222746,4225968,4222363,4222288,4219880,4221904,4221933],"length":1,"stats":{"Line":11},"fn_name":"collect_from_iter_no_buf<i32,core::iter::adapters::chain::Chain<core::iter::adapters::chain::Chain<core::iter::sources::Once<i32>, core::iter::sources::Once<i32>>, &mut core::iter::adapters::Cloned<core::slice::Iter<i32>>>>"},{"line":287,"address":[4222298,4220057,4222716,4225978,4221916,4225487,4230543,4219828,4229770],"length":1,"stats":{"Line":11},"fn_name":null},{"line":290,"address":[4225600,4222383,4219897,4230656,4222019,4230301,4222864,4222446,4220110,4222826,4225645,4230854,4230326,4222588,4230805,4230992,4226212,4220136,4225671,4225745,4221987,4226126,4229969,4222763,4222110,4221950,4220091,4222185,4219942,4230779,4229918,4226279,4230593,4222944,4222800,4222890,4222484,4229892,4226177,4225719,4230204,4230276,4230071,4230701,4230942,4225824,4229855,4230630,4226063,4225799,4225574,4226314,4230967,4225537,4230106,4219916,4222519,4226411,4226100,4222420,4230727,4222078,4226386,4230004,4230170,4230879],"length":1,"stats":{"Line":81},"fn_name":null},{"line":291,"address":[4222029,4222120,4230813,4225608,4226328,4230218,4230120,4225679,4230664,4225753,4230735,4222834,4219950,4222898,4222454,4229929,4226226,4230890,4220144,4230018,4222533,4226137],"length":1,"stats":{"Line":27},"fn_name":null},{"line":293,"address":[4222563,4230920,4230764,4229961,4230162,4222155,4226364,4222065,4226264,4222856,4225704,4226268,4226169,4230056,4225637,4225708,4230158,4230254,4230693,4230842,4225777,4230060,4222476,4230768,4222922,4230846],"length":1,"stats":{"Line":10},"fn_name":null},{"line":296,"address":[4230345,4226431,4219995,4222199,4231011,4220189,4222961,4222605,4225841],"length":1,"stats":{"Line":11},"fn_name":null},{"line":299,"address":[4225557,4219972,4222783,4229875,4220166,4221962,4222403,4226083,4230613],"length":1,"stats":{"Line":6},"fn_name":null},{"line":302,"address":[4223040,4231184,4226576,4220240],"length":1,"stats":{"Line":8},"fn_name":"num_items<i32>"},{"line":306,"address":[4226592,4219008,4223056,4220256],"length":1,"stats":{"Line":6},"fn_name":"left_shift_push<i32>"},{"line":309,"address":[4219021,4220269,4226604,4223068],"length":1,"stats":{"Line":6},"fn_name":null},{"line":310,"address":[4220295,4226658,4219031,4223107],"length":1,"stats":{"Line":6},"fn_name":null},{"line":312,"address":[4220303,4223115,4226666,4219039],"length":1,"stats":{"Line":6},"fn_name":null},{"line":314,"address":[4220339,4223169,4226738,4219057],"length":1,"stats":{"Line":6},"fn_name":null}],"covered":61,"coverable":64},{"path":["/","home","kms","itertools","src","unique_impl.rs"],"content":"\nuse std::collections::HashMap;\nuse std::collections::hash_map::{Entry};\nuse std::hash::Hash;\nuse std::fmt;\n\n/// An iterator adapter to filter out duplicate elements.\n///\n/// See [`.unique_by()`](../trait.Itertools.html#method.unique) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct UniqueBy<I: Iterator, V, F> {\n    iter: I,\n    // Use a hashmap for the entry API\n    used: HashMap<V, ()>,\n    f: F,\n}\n\nimpl<I, V, F> fmt::Debug for UniqueBy<I, V, F>\n    where I: Iterator + fmt::Debug,\n          V: fmt::Debug + Hash + Eq,\n{\n    debug_fmt_fields!(UniqueBy, iter, used);\n}\n\n/// Create a new `UniqueBy` iterator.\npub fn unique_by<I, V, F>(iter: I, f: F) -> UniqueBy<I, V, F>\n    where V: Eq + Hash,\n          F: FnMut(&I::Item) -> V,\n          I: Iterator,\n{\n    UniqueBy {\n        iter,\n        used: HashMap::new(),\n        f,\n    }\n}\n\n// count the number of new unique keys in iterable (`used` is the set already seen)\nfn count_new_keys<I, K>(mut used: HashMap<K, ()>, iterable: I) -> usize\n    where I: IntoIterator<Item=K>,\n          K: Hash + Eq,\n{\n    let iter = iterable.into_iter();\n    let current_used = used.len();\n    used.extend(iter.map(|key| (key, ())));\n    used.len() - current_used\n}\n\nimpl<I, V, F> Iterator for UniqueBy<I, V, F>\n    where I: Iterator,\n          V: Eq + Hash,\n          F: FnMut(&I::Item) -> V\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        while let Some(v) = self.iter.next() {\n            let key = (self.f)(&v);\n            if self.used.insert(key, ()).is_none() {\n                return Some(v);\n            }\n        }\n        None\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, hi) = self.iter.size_hint();\n        ((low > 0 && self.used.is_empty()) as usize, hi)\n    }\n\n    fn count(self) -> usize {\n        let mut key_f = self.f;\n        count_new_keys(self.used, self.iter.map(move |elt| key_f(&elt)))\n    }\n}\n\nimpl<I, V, F> DoubleEndedIterator for UniqueBy<I, V, F>\n    where I: DoubleEndedIterator,\n          V: Eq + Hash,\n          F: FnMut(&I::Item) -> V\n{\n    fn next_back(&mut self) -> Option<I::Item> {\n        while let Some(v) = self.iter.next_back() {\n            let key = (self.f)(&v);\n            if self.used.insert(key, ()).is_none() {\n                return Some(v);\n            }\n        }\n        None\n    }\n}\n\nimpl<I> Iterator for Unique<I>\n    where I: Iterator,\n          I::Item: Eq + Hash + Clone\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        while let Some(v) = self.iter.iter.next() {\n            if let Entry::Vacant(entry) = self.iter.used.entry(v) {\n                let elt = entry.key().clone();\n                entry.insert(());\n                return Some(elt);\n            }\n        }\n        None\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, hi) = self.iter.iter.size_hint();\n        ((low > 0 && self.iter.used.is_empty()) as usize, hi)\n    }\n\n    fn count(self) -> usize {\n        count_new_keys(self.iter.used, self.iter.iter)\n    }\n}\n\nimpl<I> DoubleEndedIterator for Unique<I>\n    where I: DoubleEndedIterator,\n          I::Item: Eq + Hash + Clone\n{\n    fn next_back(&mut self) -> Option<I::Item> {\n        while let Some(v) = self.iter.iter.next_back() {\n            if let Entry::Vacant(entry) = self.iter.used.entry(v) {\n                let elt = entry.key().clone();\n                entry.insert(());\n                return Some(elt);\n            }\n        }\n        None\n    }\n}\n\n/// An iterator adapter to filter out duplicate elements.\n///\n/// See [`.unique()`](../trait.Itertools.html#method.unique) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Unique<I: Iterator> {\n    iter: UniqueBy<I, I::Item, ()>,\n}\n\nimpl<I> fmt::Debug for Unique<I>\n    where I: Iterator + fmt::Debug,\n          I::Item: Hash + Eq + fmt::Debug,\n{\n    debug_fmt_fields!(Unique, iter);\n}\n\npub fn unique<I>(iter: I) -> Unique<I>\n    where I: Iterator,\n          I::Item: Eq + Hash,\n{\n    Unique {\n        iter: UniqueBy {\n            iter,\n            used: HashMap::new(),\n            f: (),\n        }\n    }\n}\n","traces":[{"line":27,"address":[4594236,4593792,4593952,4594076,4593916,4594112],"length":1,"stats":{"Line":3},"fn_name":"unique_by<core::slice::Iter<&str>,alloc::string::String,closure-0>"},{"line":34,"address":[4593992,4593832,4594152],"length":1,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[4960825,4960768],"length":1,"stats":{"Line":1},"fn_name":"count_new_keys<core::iter::adapters::Cloned<core::slice::Iter<i8>>,i8>"},{"line":44,"address":[4960785,4960842],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[4960867,4960896],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[4961133,4960901,4961120],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}<core::iter::adapters::Cloned<core::slice::Iter<i8>>,i8>"},{"line":47,"address":[4960960,4961076],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[4592278,4591841,4591926,4592193],"length":1,"stats":{"Line":4},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[4593568,4593344,4593526,4593750],"length":1,"stats":{"Line":4},"fn_name":"unique<core::slice::Iter<i32>>"},{"line":160,"address":[4593417,4593641],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":40,"coverable":46},{"path":["/","home","kms","itertools","src","with_position.rs"],"content":"use std::iter::{Fuse,Peekable};\n\n/// An iterator adaptor that wraps each element in an [`Position`](../enum.Position.html).\n///\n/// Iterator element type is `Position<I::Item>`.\n///\n/// See [`.with_position()`](../trait.Itertools.html#method.with_position) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct WithPosition<I>\n    where I: Iterator,\n{\n    handled_first: bool,\n    peekable: Peekable<Fuse<I>>,\n}\n\nimpl<I> Clone for WithPosition<I>\n    where I: Clone + Iterator,\n          I::Item: Clone,\n{\n    clone_fields!(handled_first, peekable);\n}\n\n/// Create a new `WithPosition` iterator.\npub fn with_position<I>(iter: I) -> WithPosition<I>\n    where I: Iterator,\n{\n    WithPosition {\n        handled_first: false,\n        peekable: iter.fuse().peekable(),\n    }\n}\n\n/// A value yielded by `WithPosition`.\n/// Indicates the position of this element in the iterator results.\n///\n/// See [`.with_position()`](trait.Itertools.html#method.with_position) for more information.\n#[derive(Copy, Clone, Debug, PartialEq)]\npub enum Position<T> {\n    /// This is the first element.\n    First(T),\n    /// This is neither the first nor the last element.\n    Middle(T),\n    /// This is the last element.\n    Last(T),\n    /// This is the only element.\n    Only(T),\n}\n\nimpl<T> Position<T> {\n    /// Return the inner value.\n    pub fn into_inner(self) -> T {\n        match self {\n            Position::First(x) |\n            Position::Middle(x) |\n            Position::Last(x) |\n            Position::Only(x) => x,\n        }\n    }\n}\n\nimpl<I: Iterator> Iterator for WithPosition<I> {\n    type Item = Position<I::Item>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.peekable.next() {\n            Some(item) => {\n                if !self.handled_first {\n                    // Haven't seen the first item yet, and there is one to give.\n                    self.handled_first = true;\n                    // Peek to see if this is also the last item,\n                    // in which case tag it as `Only`.\n                    match self.peekable.peek() {\n                        Some(_) => Some(Position::First(item)),\n                        None => Some(Position::Only(item)),\n                    }\n                } else {\n                    // Have seen the first item, and there's something left.\n                    // Peek to see if this is the last item.\n                    match self.peekable.peek() {\n                        Some(_) => Some(Position::Middle(item)),\n                        None => Some(Position::Last(item)),\n                    }\n                }\n            }\n            // Iterator is finished.\n            None => None,\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.peekable.size_hint()\n    }\n}\n\nimpl<I> ExactSizeIterator for WithPosition<I>\n    where I: ExactSizeIterator,\n{ }\n","traces":[{"line":24,"address":[5956208,5956096],"length":1,"stats":{"Line":2},"fn_name":"with_position<quick::Iter<u8, quick::Exact>>"},{"line":29,"address":[5956225,5956118],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[5954976,5955015,5955424,5955472],"length":1,"stats":{"Line":2},"fn_name":"next<quick::Iter<u8, quick::Exact>>"},{"line":65,"address":[5955518,5955048,5955436,5954985],"length":1,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":16,"coverable":22},{"path":["/","home","kms","itertools","src","zip_eq_impl.rs"],"content":"use super::size_hint;\n\n/// An iterator which iterates two other iterators simultaneously\n///\n/// See [`.zip_eq()`](../trait.Itertools.html#method.zip_eq) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct ZipEq<I, J> {\n    a: I,\n    b: J,\n}\n\n/// Iterate `i` and `j` in lock step.\n///\n/// **Panics** if the iterators are not of the same length.\n///\n/// `IntoIterator` enabled version of `i.zip_eq(j)`.\n///\n/// ```\n/// use itertools::zip_eq;\n///\n/// let data = [1, 2, 3, 4, 5];\n/// for (a, b) in zip_eq(&data[..data.len() - 1], &data[1..]) {\n///     /* loop body */\n/// }\n/// ```\npub fn zip_eq<I, J>(i: I, j: J) -> ZipEq<I::IntoIter, J::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator\n{\n    ZipEq {\n        a: i.into_iter(),\n        b: j.into_iter(),\n    }\n}\n\nimpl<I, J> Iterator for ZipEq<I, J>\n    where I: Iterator,\n          J: Iterator\n{\n    type Item = (I::Item, J::Item);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match (self.a.next(), self.b.next()) {\n            (None, None) => None,\n            (Some(a), Some(b)) => Some((a, b)),\n            (None, Some(_)) | (Some(_), None) =>\n            panic!(\"itertools: .zip_eq() reached end of one iterator before the other\")\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::min(self.a.size_hint(), self.b.size_hint())\n    }\n}\n\nimpl<I, J> ExactSizeIterator for ZipEq<I, J>\n    where I: ExactSizeIterator,\n          J: ExactSizeIterator\n{}\n","traces":[{"line":27,"address":[4219888,4219664,4219996,4219772],"length":1,"stats":{"Line":3},"fn_name":"zip_eq<&[i32; 0],&[i32; 3]>"},{"line":32,"address":[4219681,4219905],"length":1,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[4219736,4219960],"length":1,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[4218327,4218288],"length":1,"stats":{"Line":3},"fn_name":"next<core::slice::Iter<i32>,core::slice::Iter<i32>>"},{"line":44,"address":[4218542,4218566,4218440,4218339,4218297,4218417],"length":1,"stats":{"Line":7},"fn_name":null},{"line":45,"address":[4218393,4218431,4218520],"length":1,"stats":{"Line":6},"fn_name":null},{"line":46,"address":[4218544,4218445],"length":1,"stats":{"Line":4},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":7,"coverable":11},{"path":["/","home","kms","itertools","src","zip_longest.rs"],"content":"use std::cmp::Ordering::{Equal, Greater, Less};\nuse super::size_hint;\nuse std::iter::Fuse;\n\nuse crate::either_or_both::EitherOrBoth;\n\n// ZipLongest originally written by SimonSapin,\n// and dedicated to itertools https://github.com/rust-lang/rust/pull/19283\n\n/// An iterator which iterates two other iterators simultaneously\n///\n/// This iterator is *fused*.\n///\n/// See [`.zip_longest()`](../trait.Itertools.html#method.zip_longest) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct ZipLongest<T, U> {\n    a: Fuse<T>,\n    b: Fuse<U>,\n}\n\n/// Create a new `ZipLongest` iterator.\npub fn zip_longest<T, U>(a: T, b: U) -> ZipLongest<T, U> \n    where T: Iterator,\n          U: Iterator\n{\n    ZipLongest {\n        a: a.fuse(),\n        b: b.fuse(),\n    }\n}\n\nimpl<T, U> Iterator for ZipLongest<T, U>\n    where T: Iterator,\n          U: Iterator\n{\n    type Item = EitherOrBoth<T::Item, U::Item>;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        match (self.a.next(), self.b.next()) {\n            (None, None) => None,\n            (Some(a), None) => Some(EitherOrBoth::Left(a)),\n            (None, Some(b)) => Some(EitherOrBoth::Right(b)),\n            (Some(a), Some(b)) => Some(EitherOrBoth::Both(a, b)),\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::max(self.a.size_hint(), self.b.size_hint())\n    }\n}\n\nimpl<T, U> DoubleEndedIterator for ZipLongest<T, U>\n    where T: DoubleEndedIterator + ExactSizeIterator,\n          U: DoubleEndedIterator + ExactSizeIterator\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        match self.a.len().cmp(&self.b.len()) {\n            Equal => match (self.a.next_back(), self.b.next_back()) {\n                (None, None) => None,\n                (Some(a), Some(b)) => Some(EitherOrBoth::Both(a, b)),\n                // These can only happen if .len() is inconsistent with .next_back()\n                (Some(a), None) => Some(EitherOrBoth::Left(a)),\n                (None, Some(b)) => Some(EitherOrBoth::Right(b)),\n            },\n            Greater => self.a.next_back().map(EitherOrBoth::Left),\n            Less => self.b.next_back().map(EitherOrBoth::Right),\n        }\n    }\n}\n\nimpl<T, U> ExactSizeIterator for ZipLongest<T, U>\n    where T: ExactSizeIterator,\n          U: ExactSizeIterator\n{}\n","traces":[{"line":23,"address":[5350592,5351120,5350703,5350816,5351238,5351344,5350950,5351463],"length":1,"stats":{"Line":8},"fn_name":"zip_longest<itertools::adaptors::DedupBy<quick::Iter<i16, quick::Exact>, itertools::adaptors::DedupEq>,quick::Iter<i16, quick::Exact>>"},{"line":28,"address":[5350826,5350614,5351157,5351366],"length":1,"stats":{"Line":8},"fn_name":null},{"line":29,"address":[4213255,4213479,4213028,4212807],"length":1,"stats":{"Line":8},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":41,"address":[4210993,4211270,4211526,4210969,4211088,4211481,4211505,4211014,4211360,4211600,4211373,4210915,4211427,4210861,4210848,4210703,4210758,4211215],"length":1,"stats":{"Line":33},"fn_name":null},{"line":42,"address":[5346933,5347989,5346431,5347487,5347461,5346553,5347609,5348015,5348137,5346405,5346959,5347081],"length":1,"stats":{"Line":18},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":44,"address":[5346498,5347554,5348082,5347026],"length":1,"stats":{"Line":5},"fn_name":null},{"line":45,"address":[4211018,4211530],"length":1,"stats":{"Line":6},"fn_name":null},{"line":50,"address":[5348480,5348576,5348384],"length":1,"stats":{"Line":5},"fn_name":"size_hint<quick::Iter<i16, quick::Exact>,itertools::adaptors::DedupBy<quick::Iter<i16, quick::Exact>, itertools::adaptors::DedupEq>>"},{"line":51,"address":[5348492,5348588,5348396],"length":1,"stats":{"Line":5},"fn_name":null},{"line":60,"address":[4211904,4211965],"length":1,"stats":{"Line":1},"fn_name":"next_back<core::iter::adapters::Map<core::slice::Iter<i32>, closure-0>,core::iter::adapters::Map<core::slice::Iter<i32>, closure-1>>"},{"line":61,"address":[4212094,4211919,4211980,4212606,4212575,4212555],"length":1,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[4212437,4212511,4212417,4212231,4212318,4212096,4212215,4212023,4212393],"length":1,"stats":{"Line":3},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[4212419,4212236],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[4212323],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[4212441],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[4212516],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[4212570,4212062],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":17,"coverable":20},{"path":["/","home","kms","itertools","src","ziptuple.rs"],"content":"use super::size_hint;\n\n/// See [`multizip`](../fn.multizip.html) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Zip<T> {\n    t: T,\n}\n\n/// An iterator that generalizes *.zip()* and allows running multiple iterators in lockstep.\n///\n/// The iterator `Zip<(I, J, ..., M)>` is formed from a tuple of iterators (or values that\n/// implement `IntoIterator`) and yields elements\n/// until any of the subiterators yields `None`.\n///\n/// The iterator element type is a tuple like like `(A, B, ..., E)` where `A` to `E` are the\n/// element types of the subiterator.\n///\n/// **Note:** The result of this macro is a value of a named type (`Zip<(I, J,\n/// ..)>` of each component iterator `I, J, ...`) if each component iterator is\n/// nameable.\n///\n/// Prefer [`izip!()`] over `multizip` for the performance benefits of using the\n/// standard library `.zip()`. Prefer `multizip` if a nameable type is needed.\n///\n/// [`izip!()`]: macro.izip.html\n///\n/// ```\n/// use itertools::multizip;\n///\n/// // iterate over three sequences side-by-side\n/// let mut results = [0, 0, 0, 0];\n/// let inputs = [3, 7, 9, 6];\n///\n/// for (r, index, input) in multizip((&mut results, 0..10, &inputs)) {\n///     *r = index * 10 + input;\n/// }\n///\n/// assert_eq!(results, [0 + 3, 10 + 7, 29, 36]);\n/// ```\npub fn multizip<T, U>(t: U) -> Zip<T>\n    where Zip<T>: From<U>,\n          Zip<T>: Iterator,\n{\n    Zip::from(t)\n}\n\nmacro_rules! impl_zip_iter {\n    ($($B:ident),*) => (\n        #[allow(non_snake_case)]\n        impl<$($B: IntoIterator),*> From<($($B,)*)> for Zip<($($B::IntoIter,)*)> {\n            fn from(t: ($($B,)*)) -> Self {\n                let ($($B,)*) = t;\n                Zip { t: ($($B.into_iter(),)*) }\n            }\n        }\n\n        #[allow(non_snake_case)]\n        #[allow(unused_assignments)]\n        impl<$($B),*> Iterator for Zip<($($B,)*)>\n            where\n            $(\n                $B: Iterator,\n            )*\n        {\n            type Item = ($($B::Item,)*);\n\n            fn next(&mut self) -> Option<Self::Item>\n            {\n                let ($(ref mut $B,)*) = self.t;\n\n                // NOTE: Just like iter::Zip, we check the iterators\n                // for None in order. We may finish unevenly (some\n                // iterators gave n + 1 elements, some only n).\n                $(\n                    let $B = match $B.next() {\n                        None => return None,\n                        Some(elt) => elt\n                    };\n                )*\n                Some(($($B,)*))\n            }\n\n            fn size_hint(&self) -> (usize, Option<usize>)\n            {\n                let sh = (::std::usize::MAX, None);\n                let ($(ref $B,)*) = self.t;\n                $(\n                    let sh = size_hint::min($B.size_hint(), sh);\n                )*\n                sh\n            }\n        }\n\n        #[allow(non_snake_case)]\n        impl<$($B),*> ExactSizeIterator for Zip<($($B,)*)> where\n            $(\n                $B: ExactSizeIterator,\n            )*\n        { }\n    );\n}\n\nimpl_zip_iter!(A);\nimpl_zip_iter!(A, B);\nimpl_zip_iter!(A, B, C);\nimpl_zip_iter!(A, B, C, D);\nimpl_zip_iter!(A, B, C, D, E);\nimpl_zip_iter!(A, B, C, D, E, F);\nimpl_zip_iter!(A, B, C, D, E, F, G);\nimpl_zip_iter!(A, B, C, D, E, F, G, H);\n","traces":[{"line":41,"address":[4595936],"length":1,"stats":{"Line":7},"fn_name":"multizip<(itertools::groupbylazy::Group<char, core::str::Chars, closure-3>, itertools::groupbylazy::Group<char, core::str::Chars, closure-3>, itertools::groupbylazy::Group<char, core::str::Chars, closure-3>, itertools::groupbylazy::Group<char, core::str::Chars, closure-3>),(itertools::groupbylazy::Group<char, core::str::Chars, closure-3>, itertools::groupbylazy::Group<char, core::str::Chars, closure-3>, itertools::groupbylazy::Group<char, core::str::Chars, closure-3>, itertools::groupbylazy::Group<char, core::str::Chars, closure-3>)>"},{"line":45,"address":[4321159,4321079,4321239],"length":1,"stats":{"Line":7},"fn_name":null},{"line":52,"address":[4953385,4953216,4954208,4954372,4953712,4953853],"length":1,"stats":{"Line":7},"fn_name":"from<quick::Iter<i16, quick::Exact>,quick::Iter<i16, quick::Exact>,quick::Iter<i16, quick::Exact>>"},{"line":53,"address":[4318922,4320107,4319450],"length":1,"stats":{"Line":7},"fn_name":null},{"line":54,"address":[4595321,4595156],"length":1,"stats":{"Line":7},"fn_name":null},{"line":68,"address":[4317986,4316636,4316544,4317872,4317204,4317104],"length":1,"stats":{"Line":7},"fn_name":"next<core::ops::range::Range<usize>,core::ops::range::Range<i32>,core::ops::range::Range<i8>>"},{"line":70,"address":[4317119,4316559,4317887],"length":1,"stats":{"Line":7},"fn_name":null},{"line":76,"address":[4318518,4316869,4318634,4317234,4317171,4318480,4316665,4317522,4317338,4318612,4317953,4318345,4317639,4317311,4316934,4316597,4316741,4318587,4318213,4316831,4316959,4318378,4317664,4317440,4316768,4317402,4318656,4318246,4318016,4317555,4317689,4318134,4318098],"length":1,"stats":{"Line":39},"fn_name":null},{"line":77,"address":[4317420,4316753,4317530,4318396,4318525,4316786,4317219,4316651,4317357,4317447,4317264,4317562,4316849,4318045,4318253,4318023,4318353,4318141,4318385,4318534,4316885,4317323,4316775,4316694,4317572,4318116,4318264,4317345,4316876,4318001,4318501,4317459,4318152,4316672,4318221,4317241],"length":1,"stats":{"Line":52},"fn_name":null},{"line":78,"address":[4316698,4317461,4316788,4318049,4318270,4318154,4317268,4317359,4316887,4317578,4318405,4318539],"length":1,"stats":{"Line":21},"fn_name":null},{"line":81,"address":[4316984,4318683,4317711],"length":1,"stats":{"Line":5},"fn_name":null},{"line":84,"address":[4952352,4952784,4951920],"length":1,"stats":{"Line":3},"fn_name":"size_hint<quick::Iter<i16, quick::Exact>,quick::Iter<i16, quick::Exact>,quick::Iter<i16, quick::Exact>>"},{"line":86,"address":[4952367,4952799,4951935],"length":1,"stats":{"Line":3},"fn_name":null},{"line":87,"address":[4952837,4952405,4951973],"length":1,"stats":{"Line":3},"fn_name":null},{"line":89,"address":[4952017,4952449,4952881],"length":1,"stats":{"Line":3},"fn_name":null},{"line":91,"address":[4953152,4952288,4952720],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":16,"coverable":16},{"path":["/","home","kms","itertools","tests","adaptors_no_collect.rs"],"content":"use itertools::Itertools;\n\nstruct PanickingCounter {\n    curr: usize,\n    max: usize,\n}\n\nimpl Iterator for PanickingCounter {\n    type Item = ();\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.curr += 1;\n\n        if self.curr == self.max {\n            panic!(\n                \"Input iterator reached maximum of {} suggesting collection by adaptor\",\n                self.max\n            );\n        }\n\n        Some(())\n    }\n}\n\nfn no_collect_test<A, T>(to_adaptor: T)\n    where A: Iterator, T: Fn(PanickingCounter) -> A\n{\n    let counter = PanickingCounter { curr: 0, max: 10_000 };\n    let adaptor = to_adaptor(counter);\n\n    for _ in adaptor.take(5) {}\n}\n\n#[test]\nfn permutations_no_collect() {\n    no_collect_test(|iter| iter.permutations(5))\n}\n\n#[test]\nfn combinations_no_collect() {\n    no_collect_test(|iter| iter.combinations(5))\n}\n\n#[test]\nfn combinations_with_replacement_no_collect() {\n    no_collect_test(|iter| iter.combinations_with_replacement(5))\n}","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[4245008,4245100,4243568,4244384,4244304,4243660],"length":1,"stats":{"Line":3},"fn_name":"no_collect_test<itertools::permutations::Permutations<adaptors_no_collect::PanickingCounter>,closure-0>"},{"line":28,"address":[4243575,4244311,4245015],"length":1,"stats":{"Line":3},"fn_name":null},{"line":29,"address":[4243601,4244337,4245041],"length":1,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[4243818,4244510,4244860,4244168,4245589,4245239,4245115,4244399,4243675],"length":1,"stats":{"Line":6},"fn_name":null},{"line":35,"address":[4255568],"length":1,"stats":{"Line":3},"fn_name":"permutations_no_collect"},{"line":36,"address":[4245760,4245782],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":40,"address":[4245829,4245824],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":41,"address":[4245878,4245856],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":45,"address":[4245920,4245925],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":46,"address":[4245974,4245952],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"}],"covered":13,"coverable":16},{"path":["/","home","kms","itertools","tests","fold_specialization.rs"],"content":"use itertools::Itertools;\n\n#[test]\nfn specialization_intersperse() {\n    let mut iter = (1..2).intersperse(0);\n    iter.clone().for_each(|x| assert_eq!(Some(x), iter.next()));\n\n    let mut iter = (1..3).intersperse(0);\n    iter.clone().for_each(|x| assert_eq!(Some(x), iter.next()));\n\n    let mut iter = (1..4).intersperse(0);\n    iter.clone().for_each(|x| assert_eq!(Some(x), iter.next()));\n}\n","traces":[{"line":4,"address":[4211965,4211920],"length":1,"stats":{"Line":3},"fn_name":"specialization_intersperse"},{"line":5,"address":[4211929],"length":1,"stats":{"Line":1},"fn_name":null},{"line":6,"address":[4211990],"length":1,"stats":{"Line":3},"fn_name":null},{"line":8,"address":[4212036],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[4212084],"length":1,"stats":{"Line":3},"fn_name":null},{"line":11,"address":[4212136],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[4212205],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","kms","itertools","tests","merge_join.rs"],"content":"use itertools::EitherOrBoth;\nuse itertools::free::merge_join_by;\n\n#[test]\nfn empty() {\n    let left: Vec<u32> = vec![];\n    let right: Vec<u32> = vec![];\n    let expected_result: Vec<EitherOrBoth<u32, u32>> = vec![];\n    let actual_result = merge_join_by(left, right, |l, r| l.cmp(r))\n        .collect::<Vec<_>>();\n    assert_eq!(expected_result, actual_result);\n}\n\n#[test]\nfn left_only() {\n    let left: Vec<u32> = vec![1,2,3];\n    let right: Vec<u32> = vec![];\n    let expected_result: Vec<EitherOrBoth<u32, u32>> = vec![\n        EitherOrBoth::Left(1),\n        EitherOrBoth::Left(2),\n        EitherOrBoth::Left(3)\n    ];\n    let actual_result = merge_join_by(left, right, |l, r| l.cmp(r))\n        .collect::<Vec<_>>();\n    assert_eq!(expected_result, actual_result);\n}\n\n#[test]\nfn right_only() {\n    let left: Vec<u32> = vec![];\n    let right: Vec<u32> = vec![1,2,3];\n    let expected_result: Vec<EitherOrBoth<u32, u32>> = vec![\n        EitherOrBoth::Right(1),\n        EitherOrBoth::Right(2),\n        EitherOrBoth::Right(3)\n    ];\n    let actual_result = merge_join_by(left, right, |l, r| l.cmp(r))\n        .collect::<Vec<_>>();\n    assert_eq!(expected_result, actual_result);\n}\n\n#[test]\nfn first_left_then_right() {\n    let left: Vec<u32> = vec![1,2,3];\n    let right: Vec<u32> = vec![4,5,6];\n    let expected_result: Vec<EitherOrBoth<u32, u32>> = vec![\n        EitherOrBoth::Left(1),\n        EitherOrBoth::Left(2),\n        EitherOrBoth::Left(3),\n        EitherOrBoth::Right(4),\n        EitherOrBoth::Right(5),\n        EitherOrBoth::Right(6)\n    ];\n    let actual_result = merge_join_by(left, right, |l, r| l.cmp(r))\n        .collect::<Vec<_>>();\n    assert_eq!(expected_result, actual_result);\n}\n\n#[test]\nfn first_right_then_left() {\n    let left: Vec<u32> = vec![4,5,6];\n    let right: Vec<u32> = vec![1,2,3];\n    let expected_result: Vec<EitherOrBoth<u32, u32>> = vec![\n        EitherOrBoth::Right(1),\n        EitherOrBoth::Right(2),\n        EitherOrBoth::Right(3),\n        EitherOrBoth::Left(4),\n        EitherOrBoth::Left(5),\n        EitherOrBoth::Left(6)\n    ];\n    let actual_result = merge_join_by(left, right, |l, r| l.cmp(r))\n        .collect::<Vec<_>>();\n    assert_eq!(expected_result, actual_result);\n}\n\n#[test]\nfn interspersed_left_and_right() {\n    let left: Vec<u32> = vec![1,3,5];\n    let right: Vec<u32> = vec![2,4,6];\n    let expected_result: Vec<EitherOrBoth<u32, u32>> = vec![\n        EitherOrBoth::Left(1),\n        EitherOrBoth::Right(2),\n        EitherOrBoth::Left(3),\n        EitherOrBoth::Right(4),\n        EitherOrBoth::Left(5),\n        EitherOrBoth::Right(6)\n    ];\n    let actual_result = merge_join_by(left, right, |l, r| l.cmp(r))\n        .collect::<Vec<_>>();\n    assert_eq!(expected_result, actual_result);\n}\n\n#[test]\nfn overlapping_left_and_right() {\n    let left: Vec<u32> = vec![1,3,4,6];\n    let right: Vec<u32> = vec![2,3,4,5];\n    let expected_result: Vec<EitherOrBoth<u32, u32>> = vec![\n        EitherOrBoth::Left(1),\n        EitherOrBoth::Right(2),\n        EitherOrBoth::Both(3, 3),\n        EitherOrBoth::Both(4, 4),\n        EitherOrBoth::Right(5),\n        EitherOrBoth::Left(6)\n    ];\n    let actual_result = merge_join_by(left, right, |l, r| l.cmp(r))\n        .collect::<Vec<_>>();\n    assert_eq!(expected_result, actual_result);\n}\n","traces":[{"line":5,"address":[4240952,4240896],"length":1,"stats":{"Line":3},"fn_name":"empty"},{"line":6,"address":[4240907,4240967],"length":1,"stats":{"Line":2},"fn_name":null},{"line":7,"address":[4240984,4241033],"length":1,"stats":{"Line":2},"fn_name":null},{"line":8,"address":[4241050],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[4231683,4231664],"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":11,"address":[4241381,4241250],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[4241856,4241937],"length":1,"stats":{"Line":3},"fn_name":"left_only"},{"line":16,"address":[4241863,4241952],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[4242018,4241969],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[4242036,4242107],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4242041],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[4242063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[4242085],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[4231763,4231744],"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":25,"address":[4242484,4242353],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[4231792,4231797],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":30,"address":[4242971,4243031],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[4243049,4243110],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[4243128,4243199],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[4243133],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[4243155],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[4243177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[4231824,4231843],"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":39,"address":[4243445,4243576],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4231872,4231877],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":44,"address":[4244144,4244055],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[4244162,4244223],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[4244241,4244378],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[4244246],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[4244268],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[4244290],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[4244312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[4244334],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[4244356],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[4231923,4231904],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":56,"address":[4244821,4244690],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4231952,4231957],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":61,"address":[4245303,4245392],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[4245410,4245471],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[4245489,4245626],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[4245494],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[4245516],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[4245538],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[4245560],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[4245582],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[4245604],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[4232003,4231984],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":73,"address":[4246069,4245938],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[4232032,4232037],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":78,"address":[4246551,4246640],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[4246719,4246658],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[4246874,4246737],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[4246742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[4246764],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[4246786],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[4246808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[4246830],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[4246852],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[4232064,4232083],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":90,"address":[4247317,4247186],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[4232112,4232117],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":95,"address":[4247799,4247895],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[4247913,4247989],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[4248007,4248166],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[4248012],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[4248034],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[4248056],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[4248089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[4248122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[4248144],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[4232163,4232144],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":107,"address":[4248609,4248478],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":72,"coverable":72},{"path":["/","home","kms","itertools","tests","peeking_take_while.rs"],"content":"use itertools::Itertools;\nuse itertools::{put_back, put_back_n};\n\n#[test]\nfn peeking_take_while_peekable() {\n    let mut r = (0..10).peekable();\n    r.peeking_take_while(|x| *x <= 3).count();\n    assert_eq!(r.next(), Some(4));\n}\n\n#[test]\nfn peeking_take_while_put_back() {\n    let mut r = put_back(0..10);\n    r.peeking_take_while(|x| *x <= 3).count();\n    assert_eq!(r.next(), Some(4));\n    r.peeking_take_while(|_| true).count();\n    assert_eq!(r.next(), None);\n}\n\n#[test]\nfn peeking_take_while_put_back_n() {\n    let mut r = put_back_n(6..10);\n    for elt in (0..6).rev() {\n        r.put_back(elt);\n    }\n    r.peeking_take_while(|x| *x <= 3).count();\n    assert_eq!(r.next(), Some(4));\n    r.peeking_take_while(|_| true).count();\n    assert_eq!(r.next(), None);\n}\n\n#[test]\nfn peeking_take_while_slice_iter() {\n    let v = [1, 2, 3, 4, 5, 6];\n    let mut r = v.iter();\n    r.peeking_take_while(|x| **x <= 3).count();\n    assert_eq!(r.next(), Some(&4));\n    r.peeking_take_while(|_| true).count();\n    assert_eq!(r.next(), None);\n}\n\n#[test]\nfn peeking_take_while_slice_iter_rev() {\n    let v = [1, 2, 3, 4, 5, 6];\n    let mut r = v.iter().rev();\n    r.peeking_take_while(|x| **x >= 3).count();\n    assert_eq!(r.next(), Some(&2));\n    r.peeking_take_while(|_| true).count();\n    assert_eq!(r.next(), None);\n}\n","traces":[{"line":5,"address":[4220048],"length":1,"stats":{"Line":3},"fn_name":"peeking_take_while_peekable"},{"line":6,"address":[4220055],"length":1,"stats":{"Line":1},"fn_name":null},{"line":7,"address":[4227680,4227693],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":8,"address":[4220119,4220211],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[4227733,4227728],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":13,"address":[4220487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[4227773,4227760],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":15,"address":[4220551,4220682],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[4227808,4227821,4227833],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":17,"address":[4220976,4221101],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[4227845,4227840],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":22,"address":[4221399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[4221698,4221764,4221579,4221465],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[4221742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[4221683,4221777],"length":1,"stats":{"Line":4},"fn_name":null},{"line":27,"address":[4221964,4221792],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[4222271,4221949],"length":1,"stats":{"Line":4},"fn_name":null},{"line":29,"address":[4222286,4222441],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[4222768],"length":1,"stats":{"Line":3},"fn_name":"peeking_take_while_slice_iter"},{"line":34,"address":[4222775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[4222833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[4222851],"length":1,"stats":{"Line":3},"fn_name":null},{"line":37,"address":[4222876,4223012],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[4222992,4223296],"length":1,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[4223301,4223425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4223712],"length":1,"stats":{"Line":3},"fn_name":"peeking_take_while_slice_iter_rev"},{"line":44,"address":[4223719],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[4223773],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[4223832],"length":1,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[4224002,4223860],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[4223979,4224286],"length":1,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[4224418,4224291],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":32,"coverable":32},{"path":["/","home","kms","itertools","tests","quick.rs"],"content":"//! The purpose of these tests is to cover corner cases of iterators\n//! and adaptors.\n//!\n//! In particular we test the tedious size_hint and exact size correctness.\n\nuse quickcheck as qc;\nuse std::default::Default;\nuse std::ops::Range;\nuse std::cmp::{max, min, Ordering};\nuse std::collections::HashSet;\nuse itertools::Itertools;\nuse itertools::{\n    multizip,\n    EitherOrBoth,\n    iproduct,\n    izip,\n};\nuse itertools::free::{\n    cloned,\n    enumerate,\n    multipeek,\n    peek_nth,\n    put_back,\n    put_back_n,\n    rciter,\n    zip,\n    zip_eq,\n};\n\nuse rand::Rng;\nuse rand::seq::SliceRandom;\nuse quickcheck::TestResult;\n\n/// Trait for size hint modifier types\ntrait HintKind: Copy + Send + qc::Arbitrary {\n    fn loosen_bounds(&self, org_hint: (usize, Option<usize>)) -> (usize, Option<usize>);\n}\n\n/// Exact size hint variant that leaves hints unchanged\n#[derive(Clone, Copy, Debug)]\nstruct Exact {}\n\nimpl HintKind for Exact {\n    fn loosen_bounds(&self, org_hint: (usize, Option<usize>)) -> (usize, Option<usize>) {\n        org_hint\n    }\n}\n\nimpl qc::Arbitrary for Exact {\n    fn arbitrary<G: qc::Gen>(_: &mut G) -> Self {\n        Exact {}\n    }\n}\n\n/// Inexact size hint variant to simulate imprecise (but valid) size hints\n///\n/// Will always decrease the lower bound and increase the upper bound\n/// of the size hint by set amounts.\n#[derive(Clone, Copy, Debug)]\nstruct Inexact {\n    underestimate: usize,\n    overestimate: usize,\n}\n\nimpl HintKind for Inexact {\n    fn loosen_bounds(&self, org_hint: (usize, Option<usize>)) -> (usize, Option<usize>) {\n        let (org_lower, org_upper) = org_hint;\n        (org_lower.saturating_sub(self.underestimate),\n         org_upper.and_then(move |x| x.checked_add(self.overestimate)))\n    }\n}\n\nimpl qc::Arbitrary for Inexact {\n    fn arbitrary<G: qc::Gen>(g: &mut G) -> Self {\n        let ue_value = usize::arbitrary(g);\n        let oe_value = usize::arbitrary(g);\n        // Compensate for quickcheck using extreme values too rarely\n        let ue_choices = &[0, ue_value, usize::max_value()];\n        let oe_choices = &[0, oe_value, usize::max_value()];\n        Inexact {\n            underestimate: *ue_choices.choose(g).unwrap(),\n            overestimate: *oe_choices.choose(g).unwrap(),\n        }\n    }\n\n    fn shrink(&self) -> Box<dyn Iterator<Item=Self>> {\n        let underestimate_value = self.underestimate;\n        let overestimate_value = self.overestimate;\n        Box::new(\n            underestimate_value.shrink().flat_map(move |ue_value|\n                overestimate_value.shrink().map(move |oe_value|\n                    Inexact {\n                        underestimate: ue_value,\n                        overestimate: oe_value,\n                    }\n                )\n            )\n        )\n    }\n}\n\n/// Our base iterator that we can impl Arbitrary for\n///\n/// By default we'll return inexact bounds estimates for size_hint\n/// to make tests harder to pass.\n///\n/// NOTE: Iter is tricky and is not fused, to help catch bugs.\n/// At the end it will return None once, then return Some(0),\n/// then return None again.\n#[derive(Clone, Debug)]\nstruct Iter<T, SK: HintKind = Inexact> {\n    iterator: Range<T>,\n    // fuse/done flag\n    fuse_flag: i32,\n    hint_kind: SK,\n}\n\nimpl<T, HK> Iter<T, HK> where HK: HintKind\n{\n    fn new(it: Range<T>, hint_kind: HK) -> Self {\n        Iter {\n            iterator: it,\n            fuse_flag: 0,\n            hint_kind,\n        }\n    }\n}\n\nimpl<T, HK> Iterator for Iter<T, HK>\n    where Range<T>: Iterator,\n          <Range<T> as Iterator>::Item: Default,\n          HK: HintKind,\n{\n    type Item = <Range<T> as Iterator>::Item;\n\n    fn next(&mut self) -> Option<Self::Item>\n    {\n        let elt = self.iterator.next();\n        if elt.is_none() {\n            self.fuse_flag += 1;\n            // check fuse flag\n            if self.fuse_flag == 2 {\n                return Some(Default::default())\n            }\n        }\n        elt\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>)\n    {\n        let org_hint = self.iterator.size_hint();\n        self.hint_kind.loosen_bounds(org_hint)\n    }\n}\n\nimpl<T, HK> DoubleEndedIterator for Iter<T, HK>\n    where Range<T>: DoubleEndedIterator,\n          <Range<T> as Iterator>::Item: Default,\n          HK: HintKind\n{\n    fn next_back(&mut self) -> Option<Self::Item> { self.iterator.next_back() }\n}\n\nimpl<T> ExactSizeIterator for Iter<T, Exact> where Range<T>: ExactSizeIterator,\n    <Range<T> as Iterator>::Item: Default,\n{ }\n\nimpl<T, HK> qc::Arbitrary for Iter<T, HK>\n    where T: qc::Arbitrary,\n          HK: HintKind,\n{\n    fn arbitrary<G: qc::Gen>(g: &mut G) -> Self\n    {\n        Iter::new(T::arbitrary(g)..T::arbitrary(g), HK::arbitrary(g))\n    }\n\n    fn shrink(&self) -> Box<dyn Iterator<Item=Iter<T, HK>>>\n    {\n        let r = self.iterator.clone();\n        let hint_kind = self.hint_kind;\n        Box::new(\n            r.start.shrink().flat_map(move |a|\n                r.end.shrink().map(move |b|\n                    Iter::new(a.clone()..b, hint_kind)\n                )\n            )\n        )\n    }\n}\n\n/// A meta-iterator which yields `Iter<i32>`s whose start/endpoints are\n/// increased or decreased linearly on each iteration.\n#[derive(Clone, Debug)]\nstruct ShiftRange<HK = Inexact> {\n    range_start: i32,\n    range_end: i32,\n    start_step: i32,\n    end_step: i32,\n    iter_count: u32,\n    hint_kind: HK,\n}\n\nimpl<HK> Iterator for ShiftRange<HK> where HK: HintKind {\n    type Item = Iter<i32, HK>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.iter_count == 0 {\n            return None;\n        }\n\n        let iter = Iter::new(self.range_start..self.range_end, self.hint_kind);\n\n        self.range_start += self.start_step;\n        self.range_end += self.end_step;\n        self.iter_count -= 1;\n\n        Some(iter)\n    }\n}\n\nimpl ExactSizeIterator for ShiftRange<Exact> { }\n\nimpl<HK> qc::Arbitrary for ShiftRange<HK>\n    where HK: HintKind\n{\n    fn arbitrary<G: qc::Gen>(g: &mut G) -> Self {\n        const MAX_STARTING_RANGE_DIFF: i32 = 32;\n        const MAX_STEP_MODULO: i32 = 8;\n        const MAX_ITER_COUNT: u32 = 3;\n\n        let range_start = qc::Arbitrary::arbitrary(g);\n        let range_end = range_start + g.gen_range(0, MAX_STARTING_RANGE_DIFF + 1);\n        let start_step = g.gen_range(-MAX_STEP_MODULO, MAX_STEP_MODULO + 1);\n        let end_step = g.gen_range(-MAX_STEP_MODULO, MAX_STEP_MODULO + 1);\n        let iter_count = g.gen_range(0, MAX_ITER_COUNT + 1);\n        let hint_kind = qc::Arbitrary::arbitrary(g);\n\n        ShiftRange {\n            range_start,\n            range_end,\n            start_step,\n            end_step,\n            iter_count,\n            hint_kind,\n        }\n    }\n}\n\nfn correct_count<I, F>(get_it: F) -> bool\nwhere\n    I: Iterator,\n    F: Fn() -> I\n{\n    let mut counts = vec![get_it().count()];\n\n    'outer: loop {\n        let mut it = get_it();\n\n        for _ in 0..(counts.len() - 1) {\n            if let None = it.next() {\n                panic!(\"Iterator shouldn't be finished, may not be deterministic\");\n            }\n        }\n\n        if let None = it.next() {\n            break 'outer;\n        }\n\n        counts.push(it.count());\n    }\n\n    let total_actual_count = counts.len() - 1;\n\n    for (i, returned_count) in counts.into_iter().enumerate() {\n        let actual_count = total_actual_count - i;\n        if actual_count != returned_count {\n            println!(\"Total iterations: {} True count: {} returned count: {}\", i, actual_count, returned_count);\n\n            return false;\n        }\n    }\n\n    true\n}\n\nfn correct_size_hint<I: Iterator>(mut it: I) -> bool {\n    // record size hint at each iteration\n    let initial_hint = it.size_hint();\n    let mut hints = Vec::with_capacity(initial_hint.0 + 1);\n    hints.push(initial_hint);\n    while let Some(_) = it.next() {\n        hints.push(it.size_hint())\n    }\n\n    let mut true_count = hints.len(); // start off +1 too much\n\n    // check all the size hints\n    for &(low, hi) in &hints {\n        true_count -= 1;\n        if low > true_count ||\n            (hi.is_some() && hi.unwrap() < true_count)\n        {\n            println!(\"True size: {:?}, size hint: {:?}\", true_count, (low, hi));\n            //println!(\"All hints: {:?}\", hints);\n            return false\n        }\n    }\n    true\n}\n\nfn exact_size<I: ExactSizeIterator>(mut it: I) -> bool {\n    // check every iteration\n    let (mut low, mut hi) = it.size_hint();\n    if Some(low) != hi { return false; }\n    while let Some(_) = it.next() {\n        let (xlow, xhi) = it.size_hint();\n        if low != xlow + 1 { return false; }\n        low = xlow;\n        hi = xhi;\n        if Some(low) != hi { return false; }\n    }\n    let (low, hi) = it.size_hint();\n    low == 0 && hi == Some(0)\n}\n\n// Exact size for this case, without ExactSizeIterator\nfn exact_size_for_this<I: Iterator>(mut it: I) -> bool {\n    // check every iteration\n    let (mut low, mut hi) = it.size_hint();\n    if Some(low) != hi { return false; }\n    while let Some(_) = it.next() {\n        let (xlow, xhi) = it.size_hint();\n        if low != xlow + 1 { return false; }\n        low = xlow;\n        hi = xhi;\n        if Some(low) != hi { return false; }\n    }\n    let (low, hi) = it.size_hint();\n    low == 0 && hi == Some(0)\n}\n\n/*\n * NOTE: Range<i8> is broken!\n * (all signed ranges are)\n#[quickcheck]\nfn size_range_i8(a: Iter<i8>) -> bool {\n    exact_size(a)\n}\n\n#[quickcheck]\nfn size_range_i16(a: Iter<i16>) -> bool {\n    exact_size(a)\n}\n\n#[quickcheck]\nfn size_range_u8(a: Iter<u8>) -> bool {\n    exact_size(a)\n}\n */\n\nmacro_rules! quickcheck {\n    // accept several property function definitions\n    // The property functions can use pattern matching and `mut` as usual\n    // in the function arguments, but the functions can not be generic.\n    {$($(#$attr:tt)* fn $fn_name:ident($($arg:tt)*) -> $ret:ty { $($code:tt)* })*} => (\n        $(\n            #[test]\n            $(#$attr)*\n            fn $fn_name() {\n                fn prop($($arg)*) -> $ret {\n                    $($code)*\n                }\n                ::quickcheck::quickcheck(quickcheck!(@fn prop [] $($arg)*));\n            }\n        )*\n    );\n    // parse argument list (with patterns allowed) into prop as fn(_, _) -> _\n    (@fn $f:ident [$($t:tt)*]) => {\n        $f as fn($($t),*) -> _\n    };\n    (@fn $f:ident [$($p:tt)*] : $($tail:tt)*) => {\n        quickcheck!(@fn $f [$($p)* _] $($tail)*)\n    };\n    (@fn $f:ident [$($p:tt)*] $t:tt $($tail:tt)*) => {\n        quickcheck!(@fn $f [$($p)*] $($tail)*)\n    };\n}\n\nquickcheck! {\n\n    fn size_product(a: Iter<u16>, b: Iter<u16>) -> bool {\n        correct_size_hint(a.cartesian_product(b))\n    }\n    fn size_product3(a: Iter<u16>, b: Iter<u16>, c: Iter<u16>) -> bool {\n        correct_size_hint(iproduct!(a, b, c))\n    }\n\n    fn correct_cartesian_product3(a: Iter<u16>, b: Iter<u16>, c: Iter<u16>,\n                                  take_manual: usize) -> ()\n    {\n        // test correctness of iproduct through regular iteration (take)\n        // and through fold.\n        let ac = a.clone();\n        let br = &b.clone();\n        let cr = &c.clone();\n        let answer: Vec<_> = ac.flat_map(move |ea| br.clone().flat_map(move |eb| cr.clone().map(move |ec| (ea, eb, ec)))).collect();\n        let mut product_iter = iproduct!(a, b, c);\n        let mut actual = Vec::new();\n\n        actual.extend((&mut product_iter).take(take_manual));\n        if actual.len() == take_manual {\n            product_iter.fold((), |(), elt| actual.push(elt));\n        }\n        assert_eq!(answer, actual);\n    }\n\n    fn size_multi_product(a: ShiftRange) -> bool {\n        correct_size_hint(a.multi_cartesian_product())\n    }\n    fn correct_multi_product3(a: ShiftRange, take_manual: usize) -> () {\n        // Fix no. of iterators at 3\n        let a = ShiftRange { iter_count: 3, ..a };\n\n        // test correctness of MultiProduct through regular iteration (take)\n        // and through fold.\n        let mut iters = a.clone();\n        let i0 = iters.next().unwrap();\n        let i1r = &iters.next().unwrap();\n        let i2r = &iters.next().unwrap();\n        let answer: Vec<_> = i0.flat_map(move |ei0| i1r.clone().flat_map(move |ei1| i2r.clone().map(move |ei2| vec![ei0, ei1, ei2]))).collect();\n        let mut multi_product = a.clone().multi_cartesian_product();\n        let mut actual = Vec::new();\n\n        actual.extend((&mut multi_product).take(take_manual));\n        if actual.len() == take_manual {\n            multi_product.fold((), |(), elt| actual.push(elt));\n        }\n        assert_eq!(answer, actual);\n\n        assert_eq!(answer.into_iter().last(), a.clone().multi_cartesian_product().last());\n    }\n\n    #[allow(deprecated)]\n    fn size_step(a: Iter<i16, Exact>, s: usize) -> bool {\n        let mut s = s;\n        if s == 0 {\n            s += 1; // never zero\n        }\n        let filt = a.clone().dedup();\n        correct_size_hint(filt.step(s)) &&\n            exact_size(a.step(s))\n    }\n\n    #[allow(deprecated)]\n    fn equal_step(a: Iter<i16>, s: usize) -> bool {\n        let mut s = s;\n        if s == 0 {\n            s += 1; // never zero\n        }\n        let mut i = 0;\n        itertools::equal(a.clone().step(s), a.filter(|_| {\n            let keep = i % s == 0;\n            i += 1;\n            keep\n        }))\n    }\n\n    #[allow(deprecated)]\n    fn equal_step_vec(a: Vec<i16>, s: usize) -> bool {\n        let mut s = s;\n        if s == 0 {\n            s += 1; // never zero\n        }\n        let mut i = 0;\n        itertools::equal(a.iter().step(s), a.iter().filter(|_| {\n            let keep = i % s == 0;\n            i += 1;\n            keep\n        }))\n    }\n\n    fn size_multipeek(a: Iter<u16, Exact>, s: u8) -> bool {\n        let mut it = multipeek(a);\n        // peek a few times\n        for _ in 0..s {\n            it.peek();\n        }\n        exact_size(it)\n    }\n\n    fn size_peek_nth(a: Iter<u16, Exact>, s: u8) -> bool {\n        let mut it = peek_nth(a);\n        // peek a few times\n        for n in 0..s {\n            it.peek_nth(n as usize);\n        }\n        exact_size(it)\n    }\n\n    fn equal_merge(a: Vec<i16>, b: Vec<i16>) -> bool {\n        let mut sa = a.clone();\n        let mut sb = b.clone();\n        sa.sort();\n        sb.sort();\n        let mut merged = sa.clone();\n        merged.extend(sb.iter().cloned());\n        merged.sort();\n        itertools::equal(&merged, sa.iter().merge(&sb))\n    }\n    fn size_merge(a: Iter<u16>, b: Iter<u16>) -> bool {\n        correct_size_hint(a.merge(b))\n    }\n    fn size_zip(a: Iter<i16, Exact>, b: Iter<i16, Exact>, c: Iter<i16, Exact>) -> bool {\n        let filt = a.clone().dedup();\n        correct_size_hint(multizip((filt, b.clone(), c.clone()))) &&\n            exact_size(multizip((a, b, c)))\n    }\n    fn size_zip_rc(a: Iter<i16>, b: Iter<i16>) -> bool {\n        let rc = rciter(a.clone());\n        correct_size_hint(multizip((&rc, &rc, b)))\n    }\n\n    fn size_zip_macro(a: Iter<i16, Exact>, b: Iter<i16, Exact>, c: Iter<i16, Exact>) -> bool {\n        let filt = a.clone().dedup();\n        correct_size_hint(izip!(filt, b.clone(), c.clone())) &&\n            exact_size(izip!(a, b, c))\n    }\n    fn equal_kmerge(a: Vec<i16>, b: Vec<i16>, c: Vec<i16>) -> bool {\n        use itertools::free::kmerge;\n        let mut sa = a.clone();\n        let mut sb = b.clone();\n        let mut sc = c.clone();\n        sa.sort();\n        sb.sort();\n        sc.sort();\n        let mut merged = sa.clone();\n        merged.extend(sb.iter().cloned());\n        merged.extend(sc.iter().cloned());\n        merged.sort();\n        itertools::equal(merged.into_iter(), kmerge(vec![sa, sb, sc]))\n    }\n\n    // Any number of input iterators\n    fn equal_kmerge_2(mut inputs: Vec<Vec<i16>>) -> bool {\n        use itertools::free::kmerge;\n        // sort the inputs\n        for input in &mut inputs {\n            input.sort();\n        }\n        let mut merged = inputs.concat();\n        merged.sort();\n        itertools::equal(merged.into_iter(), kmerge(inputs))\n    }\n\n    // Any number of input iterators\n    fn equal_kmerge_by_ge(mut inputs: Vec<Vec<i16>>) -> bool {\n        // sort the inputs\n        for input in &mut inputs {\n            input.sort();\n            input.reverse();\n        }\n        let mut merged = inputs.concat();\n        merged.sort();\n        merged.reverse();\n        itertools::equal(merged.into_iter(),\n                         inputs.into_iter().kmerge_by(|x, y| x >= y))\n    }\n\n    // Any number of input iterators\n    fn equal_kmerge_by_lt(mut inputs: Vec<Vec<i16>>) -> bool {\n        // sort the inputs\n        for input in &mut inputs {\n            input.sort();\n        }\n        let mut merged = inputs.concat();\n        merged.sort();\n        itertools::equal(merged.into_iter(),\n                         inputs.into_iter().kmerge_by(|x, y| x < y))\n    }\n\n    // Any number of input iterators\n    fn equal_kmerge_by_le(mut inputs: Vec<Vec<i16>>) -> bool {\n        // sort the inputs\n        for input in &mut inputs {\n            input.sort();\n        }\n        let mut merged = inputs.concat();\n        merged.sort();\n        itertools::equal(merged.into_iter(),\n                         inputs.into_iter().kmerge_by(|x, y| x <= y))\n    }\n    fn size_kmerge(a: Iter<i16>, b: Iter<i16>, c: Iter<i16>) -> bool {\n        use itertools::free::kmerge;\n        correct_size_hint(kmerge(vec![a, b, c]))\n    }\n    fn equal_zip_eq(a: Vec<i32>, b: Vec<i32>) -> bool {\n        let len = std::cmp::min(a.len(), b.len());\n        let a = &a[..len];\n        let b = &b[..len];\n        itertools::equal(zip_eq(a, b), zip(a, b))\n    }\n    fn size_zip_longest(a: Iter<i16, Exact>, b: Iter<i16, Exact>) -> bool {\n        let filt = a.clone().dedup();\n        let filt2 = b.clone().dedup();\n        correct_size_hint(filt.zip_longest(b.clone())) &&\n        correct_size_hint(a.clone().zip_longest(filt2)) &&\n            exact_size(a.zip_longest(b))\n    }\n    fn size_2_zip_longest(a: Iter<i16>, b: Iter<i16>) -> bool {\n        let it = a.clone().zip_longest(b.clone());\n        let jt = a.clone().zip_longest(b.clone());\n        itertools::equal(a.clone(),\n                         it.filter_map(|elt| match elt {\n                             EitherOrBoth::Both(x, _) => Some(x),\n                             EitherOrBoth::Left(x) => Some(x),\n                             _ => None,\n                         }\n                         ))\n            &&\n        itertools::equal(b.clone(),\n                         jt.filter_map(|elt| match elt {\n                             EitherOrBoth::Both(_, y) => Some(y),\n                             EitherOrBoth::Right(y) => Some(y),\n                             _ => None,\n                         }\n                         ))\n    }\n    fn size_interleave(a: Iter<i16>, b: Iter<i16>) -> bool {\n        correct_size_hint(a.interleave(b))\n    }\n    fn exact_interleave(a: Iter<i16, Exact>, b: Iter<i16, Exact>) -> bool {\n        exact_size_for_this(a.interleave(b))\n    }\n    fn size_interleave_shortest(a: Iter<i16>, b: Iter<i16>) -> bool {\n        correct_size_hint(a.interleave_shortest(b))\n    }\n    fn exact_interleave_shortest(a: Vec<()>, b: Vec<()>) -> bool {\n        exact_size_for_this(a.iter().interleave_shortest(&b))\n    }\n    fn size_intersperse(a: Iter<i16>, x: i16) -> bool {\n        correct_size_hint(a.intersperse(x))\n    }\n    fn equal_intersperse(a: Vec<i32>, x: i32) -> bool {\n        let mut inter = false;\n        let mut i = 0;\n        for elt in a.iter().cloned().intersperse(x) {\n            if inter {\n                if elt != x { return false }\n            } else {\n                if elt != a[i] { return false }\n                i += 1;\n            }\n            inter = !inter;\n        }\n        true\n    }\n\n    fn equal_combinations_2(a: Vec<u8>) -> bool {\n        let mut v = Vec::new();\n        for (i, x) in enumerate(&a) {\n            for y in &a[i + 1..] {\n                v.push((x, y));\n            }\n        }\n        itertools::equal(a.iter().tuple_combinations::<(_, _)>(), v)\n    }\n\n    fn collect_tuple_matches_size(a: Iter<i16>) -> bool {\n        let size = a.clone().count();\n        a.collect_tuple::<(_, _, _)>().is_some() == (size == 3)\n    }\n\n    fn correct_permutations(vals: HashSet<i32>, k: usize) -> () {\n        // Test permutations only on iterators of distinct integers, to prevent\n        // false positives.\n\n        const MAX_N: usize = 5;\n\n        let n = min(vals.len(), MAX_N);\n        let vals: HashSet<i32> = vals.into_iter().take(n).collect();\n\n        let perms = vals.iter().permutations(k);\n\n        let mut actual = HashSet::new();\n\n        for perm in perms {\n            assert_eq!(perm.len(), k);\n\n            let all_items_valid = perm.iter().all(|p| vals.contains(p));\n            assert!(all_items_valid, \"perm contains value not from input: {:?}\", perm);\n\n            // Check that all perm items are distinct\n            let distinct_len = {\n                let perm_set: HashSet<_> = perm.iter().collect();\n                perm_set.len()\n            };\n            assert_eq!(perm.len(), distinct_len);\n\n            // Check that the perm is new\n            assert!(actual.insert(perm.clone()), \"perm already encountered: {:?}\", perm);\n        }\n    }\n\n    fn permutations_lexic_order(a: usize, b: usize) -> () {\n        let a = a % 6;\n        let b = b % 6;\n\n        let n = max(a, b);\n        let k = min (a, b);\n\n        let expected_first: Vec<usize> = (0..k).collect();\n        let expected_last: Vec<usize> = ((n - k)..n).rev().collect();\n\n        let mut perms = (0..n).permutations(k);\n\n        let mut curr_perm = match perms.next() {\n            Some(p) => p,\n            None => { return; }\n        };\n\n        assert_eq!(expected_first, curr_perm);\n\n        while let Some(next_perm) = perms.next() {\n            assert!(\n                next_perm > curr_perm,\n                \"next perm isn't greater-than current; next_perm={:?} curr_perm={:?} n={}\",\n                next_perm, curr_perm, n\n            );\n\n            curr_perm = next_perm;\n        }\n\n        assert_eq!(expected_last, curr_perm);\n\n    }\n\n    fn permutations_count(n: usize, k: usize) -> bool {\n        let n = n % 6;\n\n        correct_count(|| (0..n).permutations(k))\n    }\n\n    fn permutations_size(a: Iter<i32>, k: usize) -> bool {\n        correct_size_hint(a.take(5).permutations(k))\n    }\n\n    fn permutations_k0_yields_once(n: usize) -> () {\n        let k = 0;\n        let expected: Vec<Vec<usize>> = vec![vec![]];\n        let actual = (0..n).permutations(k).collect_vec();\n\n        assert_eq!(expected, actual);\n    }\n}\n\nquickcheck! {\n    fn equal_dedup(a: Vec<i32>) -> bool {\n        let mut b = a.clone();\n        b.dedup();\n        itertools::equal(&b, a.iter().dedup())\n    }\n}\n\nquickcheck! {\n    fn equal_dedup_by(a: Vec<(i32, i32)>) -> bool {\n        let mut b = a.clone();\n        b.dedup_by(|x, y| x.0==y.0);\n        itertools::equal(&b, a.iter().dedup_by(|x, y| x.0==y.0))\n    }\n}\n\nquickcheck! {\n    fn size_dedup(a: Vec<i32>) -> bool {\n        correct_size_hint(a.iter().dedup())\n    }\n}\n\nquickcheck! {\n    fn size_dedup_by(a: Vec<(i32, i32)>) -> bool {\n        correct_size_hint(a.iter().dedup_by(|x, y| x.0==y.0))\n    }\n}\n\nquickcheck! {\n    fn exact_repeatn((n, x): (usize, i32)) -> bool {\n        let it = itertools::repeat_n(x, n);\n        exact_size(it)\n    }\n}\n\nquickcheck! {\n    fn size_put_back(a: Vec<u8>, x: Option<u8>) -> bool {\n        let mut it = put_back(a.into_iter());\n        match x {\n            Some(t) => it.put_back(t),\n            None => {}\n        }\n        correct_size_hint(it)\n    }\n}\n\nquickcheck! {\n    fn size_put_backn(a: Vec<u8>, b: Vec<u8>) -> bool {\n        let mut it = put_back_n(a.into_iter());\n        for elt in b {\n            it.put_back(elt)\n        }\n        correct_size_hint(it)\n    }\n}\n\nquickcheck! {\n    fn size_tee(a: Vec<u8>) -> bool {\n        let (mut t1, mut t2) = a.iter().tee();\n        t1.next();\n        t1.next();\n        t2.next();\n        exact_size(t1) && exact_size(t2)\n    }\n}\n\nquickcheck! {\n    fn size_tee_2(a: Vec<u8>) -> bool {\n        let (mut t1, mut t2) = a.iter().dedup().tee();\n        t1.next();\n        t1.next();\n        t2.next();\n        correct_size_hint(t1) && correct_size_hint(t2)\n    }\n}\n\nquickcheck! {\n    fn size_take_while_ref(a: Vec<u8>, stop: u8) -> bool {\n        correct_size_hint(a.iter().take_while_ref(|x| **x != stop))\n    }\n}\n\nquickcheck! {\n    fn equal_partition(a: Vec<i32>) -> bool {\n        let mut a = a;\n        let mut ap = a.clone();\n        let split_index = itertools::partition(&mut ap, |x| *x >= 0);\n        let parted = (0..split_index).all(|i| ap[i] >= 0) &&\n            (split_index..a.len()).all(|i| ap[i] < 0);\n\n        a.sort();\n        ap.sort();\n        parted && (a == ap)\n    }\n}\n\nquickcheck! {\n    fn size_combinations(it: Iter<i16>) -> bool {\n        correct_size_hint(it.tuple_combinations::<(_, _)>())\n    }\n}\n\nquickcheck! {\n    fn equal_combinations(it: Iter<i16>) -> bool {\n        let values = it.clone().collect_vec();\n        let mut cmb = it.tuple_combinations();\n        for i in 0..values.len() {\n            for j in i+1..values.len() {\n                let pair = (values[i], values[j]);\n                if pair != cmb.next().unwrap() {\n                    return false;\n                }\n            }\n        }\n        cmb.next() == None\n    }\n}\n\nquickcheck! {\n    fn size_pad_tail(it: Iter<i8>, pad: u8) -> bool {\n        correct_size_hint(it.clone().pad_using(pad as usize, |_| 0)) &&\n            correct_size_hint(it.dropping(1).rev().pad_using(pad as usize, |_| 0))\n    }\n}\n\nquickcheck! {\n    fn size_pad_tail2(it: Iter<i8, Exact>, pad: u8) -> bool {\n        exact_size(it.pad_using(pad as usize, |_| 0))\n    }\n}\n\nquickcheck! {\n    fn size_unique(it: Iter<i8>) -> bool {\n        correct_size_hint(it.unique())\n    }\n\n    fn count_unique(it: Vec<i8>, take_first: u8) -> () {\n        let answer = {\n            let mut v = it.clone();\n            v.sort(); v.dedup();\n            v.len()\n        };\n        let mut iter = cloned(&it).unique();\n        let first_count = (&mut iter).take(take_first as usize).count();\n        let rest_count = iter.count();\n        assert_eq!(answer, first_count + rest_count);\n    }\n}\n\nquickcheck! {\n    fn fuzz_group_by_lazy_1(it: Iter<u8>) -> bool {\n        let jt = it.clone();\n        let groups = it.group_by(|k| *k);\n        let res = itertools::equal(jt, groups.into_iter().flat_map(|(_, x)| x));\n        res\n    }\n}\n\nquickcheck! {\n    fn fuzz_group_by_lazy_2(data: Vec<u8>) -> bool {\n        let groups = data.iter().group_by(|k| *k / 10);\n        let res = itertools::equal(data.iter(), groups.into_iter().flat_map(|(_, x)| x));\n        res\n    }\n}\n\nquickcheck! {\n    fn fuzz_group_by_lazy_3(data: Vec<u8>) -> bool {\n        let grouper = data.iter().group_by(|k| *k / 10);\n        let groups = grouper.into_iter().collect_vec();\n        let res = itertools::equal(data.iter(), groups.into_iter().flat_map(|(_, x)| x));\n        res\n    }\n}\n\nquickcheck! {\n    fn fuzz_group_by_lazy_duo(data: Vec<u8>, order: Vec<(bool, bool)>) -> bool {\n        let grouper = data.iter().group_by(|k| *k / 3);\n        let mut groups1 = grouper.into_iter();\n        let mut groups2 = grouper.into_iter();\n        let mut elts = Vec::<&u8>::new();\n        let mut old_groups = Vec::new();\n\n        let tup1 = |(_, b)| b;\n        for &(ord, consume_now) in &order {\n            let iter = &mut [&mut groups1, &mut groups2][ord as usize];\n            match iter.next() {\n                Some((_, gr)) => if consume_now {\n                    for og in old_groups.drain(..) {\n                        elts.extend(og);\n                    }\n                    elts.extend(gr);\n                } else {\n                    old_groups.push(gr);\n                },\n                None => break,\n            }\n        }\n        for og in old_groups.drain(..) {\n            elts.extend(og);\n        }\n        for gr in groups1.map(&tup1) { elts.extend(gr); }\n        for gr in groups2.map(&tup1) { elts.extend(gr); }\n        itertools::assert_equal(&data, elts);\n        true\n    }\n}\n\nquickcheck! {\n    fn equal_chunks_lazy(a: Vec<u8>, size: u8) -> bool {\n        let mut size = size;\n        if size == 0 {\n            size += 1;\n        }\n        let chunks = a.iter().chunks(size as usize);\n        let it = a.chunks(size as usize);\n        for (a, b) in chunks.into_iter().zip(it) {\n            if !itertools::equal(a, b) {\n                return false;\n            }\n        }\n        true\n    }\n}\n\nquickcheck! {\n    fn equal_tuple_windows_1(a: Vec<u8>) -> bool {\n        let x = a.windows(1).map(|s| (&s[0], ));\n        let y = a.iter().tuple_windows::<(_,)>();\n        itertools::equal(x, y)\n    }\n\n    fn equal_tuple_windows_2(a: Vec<u8>) -> bool {\n        let x = a.windows(2).map(|s| (&s[0], &s[1]));\n        let y = a.iter().tuple_windows::<(_, _)>();\n        itertools::equal(x, y)\n    }\n\n    fn equal_tuple_windows_3(a: Vec<u8>) -> bool {\n        let x = a.windows(3).map(|s| (&s[0], &s[1], &s[2]));\n        let y = a.iter().tuple_windows::<(_, _, _)>();\n        itertools::equal(x, y)\n    }\n\n    fn equal_tuple_windows_4(a: Vec<u8>) -> bool {\n        let x = a.windows(4).map(|s| (&s[0], &s[1], &s[2], &s[3]));\n        let y = a.iter().tuple_windows::<(_, _, _, _)>();\n        itertools::equal(x, y)\n    }\n\n    fn equal_tuples_1(a: Vec<u8>) -> bool {\n        let x = a.chunks(1).map(|s| (&s[0], ));\n        let y = a.iter().tuples::<(_,)>();\n        itertools::equal(x, y)\n    }\n\n    fn equal_tuples_2(a: Vec<u8>) -> bool {\n        let x = a.chunks(2).filter(|s| s.len() == 2).map(|s| (&s[0], &s[1]));\n        let y = a.iter().tuples::<(_, _)>();\n        itertools::equal(x, y)\n    }\n\n    fn equal_tuples_3(a: Vec<u8>) -> bool {\n        let x = a.chunks(3).filter(|s| s.len() == 3).map(|s| (&s[0], &s[1], &s[2]));\n        let y = a.iter().tuples::<(_, _, _)>();\n        itertools::equal(x, y)\n    }\n\n    fn equal_tuples_4(a: Vec<u8>) -> bool {\n        let x = a.chunks(4).filter(|s| s.len() == 4).map(|s| (&s[0], &s[1], &s[2], &s[3]));\n        let y = a.iter().tuples::<(_, _, _, _)>();\n        itertools::equal(x, y)\n    }\n\n    fn exact_tuple_buffer(a: Vec<u8>) -> bool {\n        let mut iter = a.iter().tuples::<(_, _, _, _)>();\n        (&mut iter).last();\n        let buffer = iter.into_buffer();\n        assert_eq!(buffer.len(), a.len() % 4);\n        exact_size(buffer)\n    }\n}\n\n// with_position\nquickcheck! {\n    fn with_position_exact_size_1(a: Vec<u8>) -> bool {\n        exact_size_for_this(a.iter().with_position())\n    }\n    fn with_position_exact_size_2(a: Iter<u8, Exact>) -> bool {\n        exact_size_for_this(a.with_position())\n    }\n}\n\nquickcheck! {\n    fn correct_group_map_modulo_key(a: Vec<u8>, modulo: u8) -> () {\n        let modulo = if modulo == 0 { 1 } else { modulo }; // Avoid `% 0`\n        let count = a.len();\n        let lookup = a.into_iter().map(|i| (i % modulo, i)).into_group_map();\n\n        assert_eq!(lookup.values().flat_map(|vals| vals.iter()).count(), count);\n\n        for (&key, vals) in lookup.iter() {\n            assert!(vals.iter().all(|&val| val % modulo == key));\n        }\n    }\n}\n\n/// A peculiar type: Equality compares both tuple items, but ordering only the\n/// first item.  This is so we can check the stability property easily.\n#[derive(Clone, Debug, PartialEq, Eq)]\nstruct Val(u32, u32);\n\nimpl PartialOrd<Val> for Val {\n    fn partial_cmp(&self, other: &Val) -> Option<Ordering> {\n        self.0.partial_cmp(&other.0)\n    }\n}\n\nimpl Ord for Val {\n    fn cmp(&self, other: &Val) -> Ordering {\n        self.0.cmp(&other.0)\n    }\n}\n\nimpl qc::Arbitrary for Val {\n    fn arbitrary<G: qc::Gen>(g: &mut G) -> Self {\n        let (x, y) = <(u32, u32)>::arbitrary(g);\n        Val(x, y)\n    }\n    fn shrink(&self) -> Box<dyn Iterator<Item = Self>> {\n        Box::new((self.0, self.1).shrink().map(|(x, y)| Val(x, y)))\n    }\n}\n\nquickcheck! {\n    fn minmax(a: Vec<Val>) -> bool {\n        use itertools::MinMaxResult;\n\n\n        let minmax = a.iter().minmax();\n        let expected = match a.len() {\n            0 => MinMaxResult::NoElements,\n            1 => MinMaxResult::OneElement(&a[0]),\n            _ => MinMaxResult::MinMax(a.iter().min().unwrap(),\n                                      a.iter().max().unwrap()),\n        };\n        minmax == expected\n    }\n}\n\nquickcheck! {\n    fn minmax_f64(a: Vec<f64>) -> TestResult {\n        use itertools::MinMaxResult;\n\n        if a.iter().any(|x| x.is_nan()) {\n            return TestResult::discard();\n        }\n\n        let min = cloned(&a).fold1(f64::min);\n        let max = cloned(&a).fold1(f64::max);\n\n        let minmax = cloned(&a).minmax();\n        let expected = match a.len() {\n            0 => MinMaxResult::NoElements,\n            1 => MinMaxResult::OneElement(min.unwrap()),\n            _ => MinMaxResult::MinMax(min.unwrap(), max.unwrap()),\n        };\n        TestResult::from_bool(minmax == expected)\n    }\n}\n\nquickcheck! {\n    #[allow(deprecated)]\n    fn tree_fold1_f64(mut a: Vec<f64>) -> TestResult {\n        fn collapse_adjacent<F>(x: Vec<f64>, mut f: F) -> Vec<f64>\n            where F: FnMut(f64, f64) -> f64\n        {\n            let mut out = Vec::new();\n            for i in (0..x.len()).step(2) {\n                if i == x.len()-1 {\n                    out.push(x[i])\n                } else {\n                    out.push(f(x[i], x[i+1]));\n                }\n            }\n            out\n        }\n\n        if a.iter().any(|x| x.is_nan()) {\n            return TestResult::discard();\n        }\n\n        let actual = a.iter().cloned().tree_fold1(f64::atan2);\n\n        while a.len() > 1 {\n            a = collapse_adjacent(a, f64::atan2);\n        }\n        let expected = a.pop();\n\n        TestResult::from_bool(actual == expected)\n    }\n}\n\nquickcheck! {\n    fn exactly_one_i32(a: Vec<i32>) -> TestResult {\n        let ret = a.iter().cloned().exactly_one();\n        match a.len() {\n            1 => TestResult::from_bool(ret.unwrap() == a[0]),\n            _ => TestResult::from_bool(ret.unwrap_err().eq(a.iter().cloned())),\n        }\n    }\n}\n","traces":[{"line":1,"address":[5324373],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":136,"address":[5252982,5253184,5251780,5251744,5253220,5251984,5253684,5252704,5253648,5252022,5252260,5252944,5253408,5252224,5252502,5252464,5252740,5253446],"length":1,"stats":{"Line":9},"fn_name":"next<i8,quick::Inexact>"},{"line":138,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":149,"address":[5254656,5254544,5253984,5254096,5253872,5254208,5254320,5254432],"length":1,"stats":{"Line":8},"fn_name":"size_hint<i16,quick::Inexact>"},{"line":151,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":161,"address":[5254768,5254777],"length":1,"stats":{"Line":2},"fn_name":"next_back<i8,quick::Inexact>"},{"line":172,"address":[5256560,5255248,5255040,5255295,5255518,5255920,5256383,5255071,5256128,5254862,5255472,5256336,5256606,5254832,5255696,5255951,5256158,5255742],"length":1,"stats":{"Line":9},"fn_name":"arbitrary<u8,quick::Exact,quickcheck::arbitrary::StdThreadGen>"},{"line":174,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":177,"address":[5257175,5258153,5259008,5259401,5258400,5258096,5256839,5258457,5258704,5257815,5258759,5259065,5259344,5257511,5257760,5256784,5257456,5257120],"length":1,"stats":{"Line":0},"fn_name":"shrink<i8,quick::Inexact>"},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[5263718,5263632],"length":1,"stats":{"Line":1},"fn_name":"correct_count<itertools::permutations::Permutations<core::ops::range::Range<usize>>,closure-0>"},{"line":254,"address":[5265439,5263655,5263741,5263758],"length":1,"stats":{"Line":3},"fn_name":null},{"line":256,"address":[5264554],"length":1,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[5263833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[5264110,5265604,5263848,5264261],"length":1,"stats":{"Line":2},"fn_name":null},{"line":260,"address":[5264160],"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[5264210],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[5264100,5264270],"length":1,"stats":{"Line":2},"fn_name":null},{"line":269,"address":[5264382],"length":1,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[5264564,5265656,5264355],"length":1,"stats":{"Line":2},"fn_name":null},{"line":274,"address":[5264786,5264600,5264821,5264983],"length":1,"stats":{"Line":3},"fn_name":null},{"line":275,"address":[5265736,5265706,5264919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":276,"address":[5264965],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[5264996],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[5265368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[5265421],"length":1,"stats":{"Line":1},"fn_name":null},{"line":286,"address":[5281113,5288784,5273360,5283664,5268313,5295241,5274656,5286240,5284976,5291384,5296508,5270873,5268272,5269577,5278585,5265744,5267065,5265785,5277289,5272137,5282336,5273395,5288825,5290048,5278544,5279808,5282377,5291344,5270832,5287577,5293929,5292633,5279849,5292592,5285017,5296464,5281072,5286275,5269536,5272096,5283705,5267024,5293888,5277248,5275952,5275993,5295200,5274697,5290089,5287536],"length":1,"stats":{"Line":25},"fn_name":"correct_size_hint<itertools::adaptors::Product<quick::Iter<u16, quick::Inexact>, quick::Iter<u16, quick::Inexact>>>"},{"line":288,"address":[5267047,5286260,5281095,5293911,5279831,5288807,5278567,5290071,5291377,5265767,5273380,5282359,5277271,5268295,5269559,5274679,5275975,5284999,5295223,5296501,5287559,5272119,5292615,5270855,5283687],"length":1,"stats":{"Line":25},"fn_name":null},{"line":289,"address":[5291399,5266920,5287421,5277142,5277365,5268328,5269653,5285080,5270888,5292477,5270936,5282392,5273468,5286348,5272200,5279912,5289935,5281176,5284859,5269423,5275845,5293944,5269592,5293992,5278600,5279693,5288888,5295083,5283551,5295304,5267128,5286290,5272152,5276008,5282453,5285032,5265800,5278437,5295256,5296581,5273410,5278648,5274541,5288840,5267080,5276069,5288678,5281128,5293781,5274712,5292709,5291236,5291447,5292648,5290104,5283720,5296523,5282222,5268166,5287592,5280958,5274773,5287640,5273247,5270726,5268376,5277304,5283768,5286125,5290165,5271983,5279864,5296349,5297631,5265848],"length":1,"stats":{"Line":50},"fn_name":null},{"line":290,"address":[5268383,5278655,5283775,5287647,5295311,5296588,5265855,5286355,5267135,5281183,5282460,5269660,5285087,5292716,5270943,5274780,5277372,5291454,5288895,5273475,5276076,5290172,5293999,5272207,5279919],"length":1,"stats":{"Line":25},"fn_name":null},{"line":291,"address":[5282515,5292902,5294054,5281369,5289082,5290357,5295391,5287727,5286586,5294257,5289109,5277585,5279999,5286410,5267316,5295523,5267190,5273530,5277452,5281263,5284033,5285142,5290252,5292929,5295366,5276290,5290227,5270998,5277427,5278867,5272287,5280105,5273653,5272394,5276156,5278735,5281396,5271130,5272421,5269715,5271023,5283830,5277558,5287828,5276131,5283855,5295496,5288950,5266067,5286533,5282699,5279974,5278710,5294230,5265910,5271157,5272262,5296643,5267215,5274860,5285167,5280132,5291531,5296763,5269874,5287852,5268597,5296665,5285272,5292771,5281238,5285299,5265935,5268570,5288975,5274835,5268463,5292796,5296787,5274993,5266094,5267340,5269740,5269847,5276263,5268438,5278840,5291509,5274966,5273706,5282540,5290384,5282672,5294079,5273560,5284006,5286440,5291629,5291653,5287702],"length":1,"stats":{"Line":75},"fn_name":null},{"line":292,"address":[5290327,5282642,5283976,5271100,5295466,5292872,5266037,5277528,5287798,5296733,5278810,5272364,5281339,5276233,5269817,5267286,5280075,5268540,5285242,5286503,5289052,5291599,5274936,5294200,5273623],"length":1,"stats":{"Line":25},"fn_name":null},{"line":295,"address":[5287862,5294245,5266082,5269862,5272431,5284043,5295511,5275003,5276300,5290372,5296775,5280120,5280142,5276278,5291641,5273694,5268607,5282709,5294267,5267328,5281406,5281384,5284021,5286574,5295533,5269884,5285287,5278855,5268585,5271145,5282687,5271167,5277573,5277595,5289119,5290394,5266104,5273716,5274981,5292917,5267350,5285309,5286596,5289097,5291663,5278877,5292939,5272409,5296797,5287840],"length":1,"stats":{"Line":50},"fn_name":null},{"line":298,"address":[5271310,5273732,5269900,5292095,5266120,5284186,5290537,5281549,5281422,5290410,5289262,5274145,5280158,5267366,5268750,5288294,5294410,5276316,5279309,5294283,5277611,5269039,5266536,5273856,5275146,5272863,5280285,5285452,5283141,5280574,5289551,5277738,5276732,5266247,5282725,5285741,5267493,5272574,5293082,5289135,5296940,5297229,5270027,5286612,5272447,5288005,5284475,5290826,5293371,5275435,5294699,5296813,5295549,5275019,5284059,5291806,5295965,5295676,5268623,5278027,5271183,5281838,5291679,5292955,5286736,5271599,5267782,5278893,5270316,5279020,5285325,5282852,5287025,5287878,5276443],"length":1,"stats":{"Line":50},"fn_name":null},{"line":299,"address":[5279105,5275231,5286177,5270778,5277194,5289347,5281634,5290622,5279745,5293167,5284911,5274593,5294495,5295135,5286821,5272659,5277823,5284271,5291288,5292529,5291891,5287473,5295761,5297025,5297683,5281010,5296401,5282274,5288090,5271395,5288730,5272035,5270112,5289987,5275897,5293833,5276528,5278489,5285537,5269475,5273941,5280370,5283603,5266972,5267578,5273299,5266332,5268218,5268835,5282937],"length":1,"stats":{"Line":25},"fn_name":null},{"line":300,"address":[5283102,5285581,5286986,5293211,5285642,5291935,5269000,5284315,5268879,5272703,5297190,5284436,5284376,5293332,5276693,5290727,5290787,5291996,5276572,5286926,5290666,5272824,5282981,5288134,5295805,5270217,5267622,5297130,5267683,5277988,5275396,5279210,5276633,5295926,5294539,5271439,5266497,5271560,5273985,5272764,5275336,5270156,5266376,5285702,5294660,5277867,5292056,5279149,5280475,5277928,5289452,5280535,5289391,5270277,5268940,5281799,5274106,5288255,5294600,5283042,5280414,5266437,5295866,5297069,5271500,5267743,5281678,5281739,5286865,5274046,5288195,5275275,5279270,5289512,5293272],"length":1,"stats":{"Line":75},"fn_name":null},{"line":301,"address":[5293348,5275313,5285619,5292072,5274122,5279187,5280487,5284353,5270293,5289429,5275412,5281751,5276645,5283118,5289528,5285654,5271576,5295843,5283054,5293284,5270229,5271477,5281716,5279222,5295942,5290739,5294676,5287002,5279286,5297206,5274058,5276709,5294612,5267660,5267759,5289464,5274023,5283019,5267695,5285718,5272741,5286938,5288172,5277940,5297107,5269016,5275348,5277905,5290704,5292008,5268917,5288271,5297142,5284452,5280551,5270194,5294577,5290803,5295878,5291973,5276610,5266414,5280452,5286903,5278004,5266513,5266449,5284388,5271512,5268952,5281815,5288207,5293249,5272840,5272776],"length":1,"stats":{"Line":50},"fn_name":null},{"line":303,"address":[5285746,5275440,5274150,5290831,5271604,5276737,5281843,5294704,5283146,5272868,5293376,5288299,5278032,5279314,5270321,5266541,5280579,5292100,5289556,5287030,5269044,5284480,5295970,5297234,5267787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[5282155,5268099,5289868,5288611,5297544,5279626,5286058,5269356,5287340,5283458,5293688,5277049,5278344,5280891,5275752,5291143,5295016,5270633,5274460,5271916,5266853,5284792,5296282,5273180,5292410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[5271284,5281523,5268724,5287979,5291780,5267467,5275120,5280259,5290511,5293056,5294384,5286713,5296914,5266221,5270001,5273833,5295650,5282826,5272548,5278994,5277712,5276417,5284160,5289236,5285426],"length":1,"stats":{"Line":25},"fn_name":null},{"line":311,"address":[5301984,5304160,5300608,5302016,5297776,5301296,5299200,5303440,5300576,5303408,5301328,5298512,5302672,5299856,5298480,5302710,5304128,5299888,5299168,5297744],"length":1,"stats":{"Line":10},"fn_name":"exact_size<itertools::zip_longest::ZipLongest<quick::Iter<i16, quick::Exact>, quick::Iter<i16, quick::Exact>>>"},{"line":313,"address":[5301343,5302031,5299873,5300623,5299903,5304175,5300593,5298497,5297761,5299185,5301313,5302725,5302703,5303425,5303455,5297791,5298527,5299215,5302001,5304145],"length":1,"stats":{"Line":20},"fn_name":null},{"line":314,"address":[5297875,5300717,5301373,5299989,5298611,5302811,5302107,5303485,5299299,5302819,5298603,5298557,5299291,5299933,5302061,5297867,5302115,5303549,5304251,5301427,5302755,5300653,5299245,5297821,5299997,5300709,5304205,5304259,5301419,5303541],"length":1,"stats":{"Line":20},"fn_name":null},{"line":315,"address":[5304451,5301087,5299995,5300758,5299646,5302146,5299617,5299490,5304257,5303189,5300309,5300199,5301458,5303751,5303861,5303878,5301739,5300355,5300715,5302314,5298970,5302860,5303030,5299600,5298811,5299330,5302473,5300326,5304607,5298117,5304561,5303143,5301756,5297873,5304578,5298247,5301785,5304290,5298276,5302817,5298924,5303590,5297906,5302444,5303547,5301425,5298642,5298609,5301041,5302427,5302113,5301058,5303907,5301626,5298230,5303160,5300038,5300928,5299297,5298941],"length":1,"stats":{"Line":40},"fn_name":null},{"line":316,"address":[5302215,5298018,5299397,5301527,5302931,5300106,5303658,5304358,5298712,5300829],"length":1,"stats":{"Line":10},"fn_name":null},{"line":317,"address":[5299449,5302986,5303145,5303364,5303710,5303766,5303856,5304082,5301043,5301734,5300530,5300943,5301036,5304772,5303863,5299135,5298441,5301262,5304466,5303138,5304556,5304563,5304410,5301950,5299595,5302638,5300214,5301641,5303045,5298919,5298767,5298926,5299505,5298826,5298132,5299602,5301741,5300311,5298073,5302329,5302429,5300884,5300158,5300304,5302270,5302422,5301582,5298225,5299811,5298232],"length":1,"stats":{"Line":20},"fn_name":null},{"line":318,"address":[5304471,5299510,5298831,5303771,5300219,5300948,5298137,5302334,5301646,5303050],"length":1,"stats":{"Line":10},"fn_name":null},{"line":319,"address":[5298844,5298150,5299520,5303781,5300229,5303063,5300961,5302347,5304481,5301659],"length":1,"stats":{"Line":10},"fn_name":null},{"line":320,"address":[5302446,5302373,5304507,5299619,5298176,5301758,5301052,5303162,5300255,5298870,5301750,5303089,5300987,5298249,5301060,5303880,5300328,5300320,5299611,5302438,5304572,5298241,5303154,5298935,5299546,5303872,5303807,5304580,5301685,5298943],"length":1,"stats":{"Line":20},"fn_name":null},{"line":322,"address":[5301778,5302466,5298975,5300360,5301790,5299639,5298269,5298963,5302478,5303912,5303900,5304600,5299651,5301080,5303182,5298281,5304612,5301092,5300348,5303194],"length":1,"stats":{"Line":20},"fn_name":null},{"line":323,"address":[5299699,5299023,5301838,5303960,5298329,5304726,5300408,5304036,5300484,5303242,5301216,5302526,5302592,5304660,5298395,5301140,5299765,5301904,5299089,5303318],"length":1,"stats":{"Line":20},"fn_name":null},{"line":327,"address":[5306240,5305552,5304816,5306272,5306960,5304848,5306928,5305520],"length":1,"stats":{"Line":4},"fn_name":"exact_size_for_this<itertools::with_position::WithPosition<quick::Iter<u8, quick::Exact>>>"},{"line":329,"address":[5304833,5306257,5306287,5306945,5306975,5305567,5304863,5305537],"length":1,"stats":{"Line":8},"fn_name":null},{"line":330,"address":[5305646,5306371,5306317,5305597,5304939,5307051,5304893,5304947,5306363,5307005,5307059,5305654],"length":1,"stats":{"Line":8},"fn_name":null},{"line":331,"address":[5306013,5306702,5305996,5306572,5306369,5305685,5305155,5306402,5306685,5305883,5307251,5307361,5304978,5307090,5305311,5304945,5305282,5305652,5305265,5306042,5307057,5306731,5307378,5307407],"length":1,"stats":{"Line":16},"fn_name":null},{"line":332,"address":[5306473,5305062,5307158,5305784],"length":1,"stats":{"Line":4},"fn_name":null},{"line":333,"address":[5306528,5305267,5306587,5306687,5307363,5305476,5306207,5305170,5307572,5307356,5305991,5306680,5305114,5306896,5305898,5305839,5305998,5307210,5305260,5307266],"length":1,"stats":{"Line":8},"fn_name":null},{"line":334,"address":[5306592,5305175,5305903,5307271],"length":1,"stats":{"Line":4},"fn_name":null},{"line":335,"address":[5305185,5305916,5306605,5307281],"length":1,"stats":{"Line":4},"fn_name":null},{"line":336,"address":[5305284,5306631,5306015,5305211,5305276,5306007,5306696,5306704,5307372,5307380,5305942,5307307],"length":1,"stats":{"Line":8},"fn_name":null},{"line":338,"address":[5307400,5307412,5305304,5305316,5306724,5306047,5306035,5306736],"length":1,"stats":{"Line":8},"fn_name":null},{"line":339,"address":[5306161,5305430,5306784,5307460,5305364,5306095,5306850,5307526],"length":1,"stats":{"Line":8},"fn_name":null},{"line":369,"address":[5316517,5318437,5317525,5317632,5315749,5317008,5316709,5321253,5313749,5315365,5315360,5315301,5316677,5315397,5319461,5320672,5317493,5317520,5319136,5316160,5321189,5316901,5313717,5316128,5318917,5318752,5317301,5317557,5321749,5314197,5322704,5321184,5315781,5318064,5317077,5318912,5316069,5316101,5316869,5316581,5314192,5315205,5315776,5313744,5318133,5316613,5321632,5316672,5316741,5314661,5316640,5316864,5317392,5317104,5315968,5316165,5316773,5314224,5318597,5317552,5314688,5317461,5315973,5320293,5321248,5315328,5315872,5321637,5316096,5321669,5316576,5318005,5318277,5317109,5315877,5314229,5315237,5317488,5318432,5318592,5314693,5316608,5319141,5315269,5316133,5317072,5317872,5314944,5317637,5317296,5320288,5317840,5318789,5315712,5315717,5317040,5319456,5314949,5321157,5318096,5317045,5313680,5313712,5315264,5320005,5319877,5316064,5318128,5315296,5314656,5315333,5316645,5316512,5318069,5321664,5318757,5315744,5316549,5317909,5317424,5321152,5315200,5317397,5320000,5315232,5318000,5318784,5317877,5321221,5316544,5321744,5316768,5316896,5317013,5320677,5321216,5322709,5317429,5313685,5317264,5318101,5317904,5316704,5317269,5315392,5319872,5318272,5317456,5316736,5317845],"length":1,"stats":{"Line":225},"fn_name":"{{closure}}"},{"line":370,"address":[5794896,5778961,5809808,5772704,5806576,5804192,5767856,5782688,5778608,5790144,5776333,5766536,5792720,5803564,5792944,5790346,5809115,5771392,5777136,5780624,5804912,5795449,5793673,5777197,5795184,5773240,5777933,5804972,5806528,5796512,5789888,5797288,5789661,5776272,5780976,5793536,5788624,5790496,5785877,5788899,5781728,5795296,5803504,5792755,5775613,5804604,5774032,5804544,5780752,5777872,5781088,5810673,5773456,5806432,5802876,5785760,5791616,5767984,5770544,5780352,5780496,5793632,5797776,5767744,5774132,5797216,5797914,5796880,5775552,5810576,5772560,5808509,5771792,5790696,5771462,5788784,5771844,5788512,5802540,5781763,5790944,5809925,5809008,5796816,5770976,5771046,5803916,5803856,5778928,5770240,5790170,5791041,5769888,5795392,5793008,5805280,5789632,5792240,5801450,5791696,5790320,5780783,5804252,5770581,5808432,5779376,5802480,5796544,5779920,5766480,5792160,5803152,5782864,5781135,5766128,5765984,5801408,5803212,5805360,5806286,5789917,5802816,5806256,5773200,5782934,5790624],"length":1,"stats":{"Line":75},"fn_name":"prop"},{"line":373,"address":[5776257,5792145,5795281,5782673,5780481,5780961,5788609,5771777,5795169,5767841,5790929,5792705,5803841,5770529,5773185,5805265,5770961,5803489,5788497,5782849,5802465,5775537,5785745,5790305,5791601,5778593,5789873,5795377,5780337,5790481,5804177,5794881,5766113,5790129,5781713,5796801,5806241,5777121,5797201,5780737,5777857,5802801,5788769,5779905,5769873,5773441,5779361,5771377,5766465,5797761,5801393,5793617,5781073,5780609,5804897,5796497,5804529,5770225,5793521,5810561,5808993,5792929,5809793,5767729,5772545,5774017,5778913,5803137,5790609,5765969,5772689,5789617,5806513,5806417,5808417],"length":1,"stats":{"Line":75},"fn_name":null},{"line":392,"address":[5765991],"length":1,"stats":{"Line":1},"fn_name":null},{"line":395,"address":[5766135],"length":1,"stats":{"Line":1},"fn_name":null},{"line":403,"address":[5766495],"length":1,"stats":{"Line":1},"fn_name":null},{"line":404,"address":[5766551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":405,"address":[5766585],"length":1,"stats":{"Line":1},"fn_name":null},{"line":406,"address":[5313776,5313856,5313873,5313985,5313789,5313968],"length":1,"stats":{"Line":7},"fn_name":"{{closure}}"},{"line":407,"address":[5766901,5766762],"length":1,"stats":{"Line":2},"fn_name":null},{"line":408,"address":[5767044],"length":1,"stats":{"Line":1},"fn_name":null},{"line":410,"address":[5767051],"length":1,"stats":{"Line":1},"fn_name":null},{"line":411,"address":[5767135,5767241],"length":1,"stats":{"Line":2},"fn_name":null},{"line":412,"address":[5314121,5314080],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":414,"address":[5767251,5767362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":418,"address":[5767748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":422,"address":[5767871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":426,"address":[5767961],"length":1,"stats":{"Line":1},"fn_name":null},{"line":427,"address":[5767999],"length":1,"stats":{"Line":1},"fn_name":null},{"line":428,"address":[5768041],"length":1,"stats":{"Line":1},"fn_name":null},{"line":429,"address":[5768099],"length":1,"stats":{"Line":1},"fn_name":null},{"line":430,"address":[5314496,5314480,5314272,5314256,5314368,5314384],"length":1,"stats":{"Line":7},"fn_name":"{{closure}}"},{"line":431,"address":[5768335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":432,"address":[5768381],"length":1,"stats":{"Line":1},"fn_name":null},{"line":434,"address":[5768388],"length":1,"stats":{"Line":1},"fn_name":null},{"line":435,"address":[5768484,5768590],"length":1,"stats":{"Line":2},"fn_name":null},{"line":436,"address":[5314600,5314592],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":438,"address":[5768600,5768759],"length":1,"stats":{"Line":1},"fn_name":null},{"line":440,"address":[5769077,5768693],"length":1,"stats":{"Line":2},"fn_name":null},{"line":445,"address":[5769915],"length":1,"stats":{"Line":1},"fn_name":null},{"line":446,"address":[5769925],"length":1,"stats":{"Line":1},"fn_name":null},{"line":447,"address":[5770210,5769933,5770180],"length":1,"stats":{"Line":1},"fn_name":null},{"line":449,"address":[5769971],"length":1,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[5770174,5770129,5770017],"length":1,"stats":{"Line":3},"fn_name":null},{"line":451,"address":[5770153,5770071],"length":1,"stats":{"Line":2},"fn_name":null},{"line":456,"address":[5770252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":457,"address":[5770262],"length":1,"stats":{"Line":1},"fn_name":null},{"line":458,"address":[5770523,5770275,5770493],"length":1,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[5770313],"length":1,"stats":{"Line":1},"fn_name":null},{"line":461,"address":[5314720],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":462,"address":[5314734,5314877],"length":1,"stats":{"Line":1},"fn_name":null},{"line":463,"address":[5314937,5314907,5314813],"length":1,"stats":{"Line":1},"fn_name":null},{"line":464,"address":[5314862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":470,"address":[5770556],"length":1,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[5770634,5770566],"length":1,"stats":{"Line":1},"fn_name":null},{"line":472,"address":[5770596,5770908],"length":1,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[5770648],"length":1,"stats":{"Line":1},"fn_name":null},{"line":475,"address":[5314976],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":476,"address":[5314990,5315133],"length":1,"stats":{"Line":1},"fn_name":null},{"line":477,"address":[5315069,5315193,5315163],"length":1,"stats":{"Line":1},"fn_name":null},{"line":478,"address":[5315118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":483,"address":[5771003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":485,"address":[5771061,5771277,5771247],"length":1,"stats":{"Line":2},"fn_name":null},{"line":486,"address":[5771270],"length":1,"stats":{"Line":1},"fn_name":null},{"line":488,"address":[5771168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":492,"address":[5771419],"length":1,"stats":{"Line":1},"fn_name":null},{"line":494,"address":[5771644,5771689,5771477],"length":1,"stats":{"Line":2},"fn_name":null},{"line":495,"address":[5771670],"length":1,"stats":{"Line":1},"fn_name":null},{"line":497,"address":[5771584],"length":1,"stats":{"Line":1},"fn_name":null},{"line":501,"address":[5771815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":502,"address":[5771875],"length":1,"stats":{"Line":1},"fn_name":null},{"line":503,"address":[5771912,5771972],"length":1,"stats":{"Line":2},"fn_name":null},{"line":504,"address":[5771994],"length":1,"stats":{"Line":1},"fn_name":null},{"line":505,"address":[5772056],"length":1,"stats":{"Line":1},"fn_name":null},{"line":506,"address":[5772071,5772147],"length":1,"stats":{"Line":2},"fn_name":null},{"line":507,"address":[5772189],"length":1,"stats":{"Line":1},"fn_name":null},{"line":508,"address":[5772243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":511,"address":[5772567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":514,"address":[5772756],"length":1,"stats":{"Line":1},"fn_name":null},{"line":515,"address":[5773182,5773009,5773169,5772802],"length":1,"stats":{"Line":3},"fn_name":null},{"line":516,"address":[5773148,5772879],"length":1,"stats":{"Line":2},"fn_name":null},{"line":519,"address":[5773255,5773207],"length":1,"stats":{"Line":2},"fn_name":null},{"line":520,"address":[5773275],"length":1,"stats":{"Line":1},"fn_name":null},{"line":524,"address":[5773508],"length":1,"stats":{"Line":1},"fn_name":null},{"line":525,"address":[5315465],"length":1,"stats":{"Line":4},"fn_name":null},{"line":526,"address":[5315609],"length":1,"stats":{"Line":3},"fn_name":null},{"line":530,"address":[5774039,5774147],"length":1,"stats":{"Line":2},"fn_name":null},{"line":531,"address":[5774223,5774171],"length":1,"stats":{"Line":2},"fn_name":null},{"line":532,"address":[5774247],"length":1,"stats":{"Line":1},"fn_name":null},{"line":533,"address":[5774262],"length":1,"stats":{"Line":1},"fn_name":null},{"line":534,"address":[5774320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":535,"address":[5774378],"length":1,"stats":{"Line":1},"fn_name":null},{"line":536,"address":[5774446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":537,"address":[5774469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":538,"address":[5774577],"length":1,"stats":{"Line":1},"fn_name":null},{"line":539,"address":[5774677],"length":1,"stats":{"Line":1},"fn_name":null},{"line":540,"address":[5774723,5775350],"length":1,"stats":{"Line":1},"fn_name":null},{"line":547,"address":[5775719,5775800,5775559,5775633],"length":1,"stats":{"Line":3},"fn_name":null},{"line":548,"address":[5775754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":550,"address":[5775702,5775823],"length":1,"stats":{"Line":2},"fn_name":null},{"line":551,"address":[5775838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":552,"address":[5775884,5776159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":558,"address":[5776353,5776279,5776451,5776593],"length":1,"stats":{"Line":3},"fn_name":null},{"line":559,"address":[5776501],"length":1,"stats":{"Line":1},"fn_name":null},{"line":560,"address":[5776547],"length":1,"stats":{"Line":1},"fn_name":null},{"line":562,"address":[5776616,5776431],"length":1,"stats":{"Line":2},"fn_name":null},{"line":563,"address":[5776631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":564,"address":[5776677],"length":1,"stats":{"Line":1},"fn_name":null},{"line":565,"address":[5776880,5776723],"length":1,"stats":{"Line":2},"fn_name":null},{"line":566,"address":[5315827,5315808],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":572,"address":[5777143,5777217,5777303,5777384],"length":1,"stats":{"Line":3},"fn_name":null},{"line":573,"address":[5777338],"length":1,"stats":{"Line":1},"fn_name":null},{"line":575,"address":[5777286,5777407],"length":1,"stats":{"Line":2},"fn_name":null},{"line":576,"address":[5777422],"length":1,"stats":{"Line":1},"fn_name":null},{"line":577,"address":[5777468,5777625],"length":1,"stats":{"Line":2},"fn_name":null},{"line":578,"address":[5315923,5315904],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":584,"address":[5777953,5778120,5777879,5778039],"length":1,"stats":{"Line":3},"fn_name":null},{"line":585,"address":[5778074],"length":1,"stats":{"Line":1},"fn_name":null},{"line":587,"address":[5778022,5778143],"length":1,"stats":{"Line":2},"fn_name":null},{"line":588,"address":[5778158],"length":1,"stats":{"Line":1},"fn_name":null},{"line":589,"address":[5778361,5778204],"length":1,"stats":{"Line":2},"fn_name":null},{"line":590,"address":[5316000,5316019],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":594,"address":[5778615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":597,"address":[5778935,5778976,5779021],"length":1,"stats":{"Line":3},"fn_name":null},{"line":598,"address":[5779057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":599,"address":[5779114],"length":1,"stats":{"Line":1},"fn_name":null},{"line":600,"address":[5779177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":603,"address":[5779413],"length":1,"stats":{"Line":1},"fn_name":null},{"line":604,"address":[5779459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":605,"address":[5779849,5779896,5779659,5779505,5779883,5779709],"length":1,"stats":{"Line":5},"fn_name":null},{"line":606,"address":[5779775,5779673],"length":1,"stats":{"Line":2},"fn_name":null},{"line":607,"address":[5779862,5779582],"length":1,"stats":{"Line":2},"fn_name":null},{"line":610,"address":[5779927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":611,"address":[5779999],"length":1,"stats":{"Line":1},"fn_name":null},{"line":612,"address":[5780315,5780064,5780328,5780190],"length":1,"stats":{"Line":3},"fn_name":null},{"line":613,"address":[5316271,5316300,5316192],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":614,"address":[5316234,5316273],"length":1,"stats":{"Line":2},"fn_name":null},{"line":615,"address":[5316302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":616,"address":[5316264],"length":1,"stats":{"Line":1},"fn_name":null},{"line":620,"address":[5780286,5780098],"length":1,"stats":{"Line":2},"fn_name":null},{"line":621,"address":[5316460,5316431,5316352],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":622,"address":[5316433,5316394],"length":1,"stats":{"Line":2},"fn_name":null},{"line":623,"address":[5316462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":624,"address":[5316424],"length":1,"stats":{"Line":1},"fn_name":null},{"line":629,"address":[5780359],"length":1,"stats":{"Line":1},"fn_name":null},{"line":632,"address":[5780530],"length":1,"stats":{"Line":1},"fn_name":null},{"line":635,"address":[5780628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":638,"address":[5780766,5780805,5780866],"length":1,"stats":{"Line":3},"fn_name":null},{"line":641,"address":[5780985],"length":1,"stats":{"Line":1},"fn_name":null},{"line":644,"address":[5781099],"length":1,"stats":{"Line":1},"fn_name":null},{"line":645,"address":[5781104],"length":1,"stats":{"Line":1},"fn_name":null},{"line":646,"address":[5781397,5781613,5781203,5781118,5781343,5781150],"length":1,"stats":{"Line":5},"fn_name":null},{"line":647,"address":[5781494,5781441],"length":1,"stats":{"Line":2},"fn_name":null},{"line":648,"address":[5781496,5781481],"length":1,"stats":{"Line":1},"fn_name":null},{"line":650,"address":[5781556,5781585,5781448],"length":1,"stats":{"Line":2},"fn_name":null},{"line":651,"address":[5781596,5781678,5781560],"length":1,"stats":{"Line":2},"fn_name":null},{"line":653,"address":[5781601],"length":1,"stats":{"Line":1},"fn_name":null},{"line":655,"address":[5781618],"length":1,"stats":{"Line":1},"fn_name":null},{"line":659,"address":[5781735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":660,"address":[5781778,5781834,5781996,5782287],"length":1,"stats":{"Line":3},"fn_name":null},{"line":661,"address":[5782094,5782402,5782292,5782637],"length":1,"stats":{"Line":2},"fn_name":null},{"line":662,"address":[5782342],"length":1,"stats":{"Line":1},"fn_name":null},{"line":665,"address":[5781967,5782407],"length":1,"stats":{"Line":2},"fn_name":null},{"line":669,"address":[5782692],"length":1,"stats":{"Line":1},"fn_name":null},{"line":670,"address":[5782735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":679,"address":[5782949,5782879],"length":1,"stats":{"Line":2},"fn_name":null},{"line":680,"address":[5782997],"length":1,"stats":{"Line":1},"fn_name":null},{"line":682,"address":[5783153,5783209],"length":1,"stats":{"Line":2},"fn_name":null},{"line":684,"address":[5783225],"length":1,"stats":{"Line":1},"fn_name":null},{"line":686,"address":[5783232,5785346,5785594,5783380,5785520,5783402],"length":1,"stats":{"Line":5},"fn_name":null},{"line":687,"address":[5783832,5785568,5783670],"length":1,"stats":{"Line":2},"fn_name":null},{"line":689,"address":[5316800,5316814],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":690,"address":[5784311,5784366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":694,"address":[5784544,5784332],"length":1,"stats":{"Line":2},"fn_name":null},{"line":695,"address":[5784594],"length":1,"stats":{"Line":1},"fn_name":null},{"line":697,"address":[5784811,5784660],"length":1,"stats":{"Line":1},"fn_name":null},{"line":700,"address":[5785137,5784801,5785184],"length":1,"stats":{"Line":2},"fn_name":null},{"line":705,"address":[5785783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":706,"address":[5785819],"length":1,"stats":{"Line":1},"fn_name":null},{"line":708,"address":[5785845],"length":1,"stats":{"Line":1},"fn_name":null},{"line":709,"address":[5785892],"length":1,"stats":{"Line":1},"fn_name":null},{"line":711,"address":[5785922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":712,"address":[5785980,5786109,5788336],"length":1,"stats":{"Line":2},"fn_name":null},{"line":714,"address":[5786144],"length":1,"stats":{"Line":1},"fn_name":null},{"line":716,"address":[5786227,5786310],"length":1,"stats":{"Line":1},"fn_name":null},{"line":717,"address":[5786252,5786316],"length":1,"stats":{"Line":2},"fn_name":null},{"line":718,"address":[5786496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":721,"address":[5788015,5786550,5786523],"length":1,"stats":{"Line":2},"fn_name":null},{"line":723,"address":[5787046,5786545,5786904,5788123,5788292],"length":1,"stats":{"Line":3},"fn_name":null},{"line":724,"address":[5787145,5787034],"length":1,"stats":{"Line":1},"fn_name":null},{"line":725,"address":[5787013],"length":1,"stats":{"Line":1},"fn_name":null},{"line":730,"address":[5787079,5788182],"length":1,"stats":{"Line":1},"fn_name":null},{"line":733,"address":[5787542,5787657],"length":1,"stats":{"Line":1},"fn_name":null},{"line":738,"address":[5788526],"length":1,"stats":{"Line":1},"fn_name":null},{"line":740,"address":[5316940,5316928],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":744,"address":[5788636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":748,"address":[5788796],"length":1,"stats":{"Line":1},"fn_name":null},{"line":749,"address":[5788815,5788914],"length":1,"stats":{"Line":1},"fn_name":null},{"line":750,"address":[5788998],"length":1,"stats":{"Line":1},"fn_name":null},{"line":752,"address":[5789233,5789102],"length":1,"stats":{"Line":1},"fn_name":null},{"line":758,"address":[5789646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":759,"address":[5789678],"length":1,"stats":{"Line":1},"fn_name":null},{"line":760,"address":[5789702,5789731],"length":1,"stats":{"Line":2},"fn_name":null},{"line":766,"address":[5789902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":767,"address":[5317136,5317154],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":768,"address":[5317200,5317218],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":774,"address":[5790182,5790240,5790153],"length":1,"stats":{"Line":3},"fn_name":null},{"line":780,"address":[5317328,5317346],"length":1,"stats":{"Line":5},"fn_name":"{{closure}}"},{"line":785,"address":[5790509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":786,"address":[5790527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":787,"address":[5790546],"length":1,"stats":{"Line":1},"fn_name":null},{"line":793,"address":[5790711,5790644],"length":1,"stats":{"Line":2},"fn_name":null},{"line":794,"address":[5790777,5790750],"length":1,"stats":{"Line":1},"fn_name":null},{"line":795,"address":[5790752,5790734],"length":1,"stats":{"Line":2},"fn_name":null},{"line":798,"address":[5790779],"length":1,"stats":{"Line":1},"fn_name":null},{"line":804,"address":[5791056,5790951],"length":1,"stats":{"Line":2},"fn_name":null},{"line":805,"address":[5791357,5791240,5791064,5791293],"length":1,"stats":{"Line":3},"fn_name":null},{"line":806,"address":[5791337],"length":1,"stats":{"Line":1},"fn_name":null},{"line":808,"address":[5791362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":814,"address":[5791623,5791738],"length":1,"stats":{"Line":2},"fn_name":null},{"line":815,"address":[5791802],"length":1,"stats":{"Line":1},"fn_name":null},{"line":816,"address":[5791846],"length":1,"stats":{"Line":1},"fn_name":null},{"line":817,"address":[5791858],"length":1,"stats":{"Line":1},"fn_name":null},{"line":818,"address":[5791865,5791953],"length":1,"stats":{"Line":2},"fn_name":null},{"line":824,"address":[5792282,5792167],"length":1,"stats":{"Line":2},"fn_name":null},{"line":825,"address":[5792363],"length":1,"stats":{"Line":1},"fn_name":null},{"line":826,"address":[5792410],"length":1,"stats":{"Line":1},"fn_name":null},{"line":827,"address":[5792422],"length":1,"stats":{"Line":1},"fn_name":null},{"line":828,"address":[5792517,5792429],"length":1,"stats":{"Line":2},"fn_name":null},{"line":834,"address":[5317597,5317584],"length":1,"stats":{"Line":5},"fn_name":"{{closure}}"},{"line":840,"address":[5792951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":841,"address":[5792981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":842,"address":[5317677,5317664],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":843,"address":[5317726,5317712],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":844,"address":[5317776,5317790],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":846,"address":[5793320,5793188],"length":1,"stats":{"Line":2},"fn_name":null},{"line":847,"address":[5793327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":848,"address":[5793373,5793442],"length":1,"stats":{"Line":2},"fn_name":null},{"line":854,"address":[5793540],"length":1,"stats":{"Line":1},"fn_name":null},{"line":860,"address":[5793639,5793688],"length":1,"stats":{"Line":2},"fn_name":null},{"line":861,"address":[5793717],"length":1,"stats":{"Line":1},"fn_name":null},{"line":862,"address":[5794009,5793763,5793893,5794275,5793808],"length":1,"stats":{"Line":4},"fn_name":null},{"line":863,"address":[5794844,5794280,5794059,5794613],"length":1,"stats":{"Line":2},"fn_name":null},{"line":864,"address":[5794330],"length":1,"stats":{"Line":1},"fn_name":null},{"line":865,"address":[5794436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":866,"address":[5794674,5794618],"length":1,"stats":{"Line":0},"fn_name":null},{"line":870,"address":[5793994,5794681],"length":1,"stats":{"Line":2},"fn_name":null},{"line":876,"address":[5317956,5317936,5317951],"length":1,"stats":{"Line":5},"fn_name":"{{closure}}"},{"line":877,"address":[5317968,5317983,5317988],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":883,"address":[5318052,5318032,5318047],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":889,"address":[5795300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":893,"address":[5795407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":894,"address":[5795431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":895,"address":[5795524,5795464,5795554],"length":1,"stats":{"Line":3},"fn_name":null},{"line":896,"address":[5795561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":898,"address":[5795621],"length":1,"stats":{"Line":1},"fn_name":null},{"line":899,"address":[5795671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":900,"address":[5795741],"length":1,"stats":{"Line":1},"fn_name":null},{"line":901,"address":[5796034,5796450,5795862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":907,"address":[5796519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":908,"address":[5318173,5318160],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":909,"address":[5318203,5318192],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":910,"address":[5796735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":916,"address":[5318304,5318318],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":917,"address":[5318363,5318352],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":918,"address":[5797097],"length":1,"stats":{"Line":1},"fn_name":null},{"line":924,"address":[5318464,5318478],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":925,"address":[5797386,5797342],"length":1,"stats":{"Line":2},"fn_name":null},{"line":926,"address":[5318523,5318512],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":927,"address":[5797599],"length":1,"stats":{"Line":1},"fn_name":null},{"line":933,"address":[5318624,5318638],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":934,"address":[5797995],"length":1,"stats":{"Line":1},"fn_name":null},{"line":935,"address":[5798060,5798028],"length":1,"stats":{"Line":2},"fn_name":null},{"line":936,"address":[5798076],"length":1,"stats":{"Line":1},"fn_name":null},{"line":937,"address":[5798083],"length":1,"stats":{"Line":1},"fn_name":null},{"line":939,"address":[5318683,5318672],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":940,"address":[5800666,5798185,5798114],"length":1,"stats":{"Line":3},"fn_name":null},{"line":941,"address":[5798415,5798315,5801228],"length":1,"stats":{"Line":2},"fn_name":null},{"line":942,"address":[5798497,5798431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":943,"address":[5799120,5798499,5798454],"length":1,"stats":{"Line":3},"fn_name":null},{"line":944,"address":[5798787,5799052,5798647,5800553,5800659,5798714],"length":1,"stats":{"Line":5},"fn_name":null},{"line":945,"address":[5800593],"length":1,"stats":{"Line":1},"fn_name":null},{"line":947,"address":[5799057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":949,"address":[5798565],"length":1,"stats":{"Line":1},"fn_name":null},{"line":951,"address":[5799169],"length":1,"stats":{"Line":1},"fn_name":null},{"line":954,"address":[5799190,5800833,5799270,5798400,5799535,5800727],"length":1,"stats":{"Line":5},"fn_name":null},{"line":955,"address":[5800767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":957,"address":[5799540,5799924,5800840],"length":1,"stats":{"Line":2},"fn_name":null},{"line":958,"address":[5800318,5799891,5799947,5800994],"length":1,"stats":{"Line":2},"fn_name":null},{"line":959,"address":[5800255],"length":1,"stats":{"Line":1},"fn_name":null},{"line":966,"address":[5801420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":967,"address":[5801436,5801495],"length":1,"stats":{"Line":1},"fn_name":null},{"line":968,"address":[5802361,5801465],"length":1,"stats":{"Line":0},"fn_name":null},{"line":970,"address":[5801509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":971,"address":[5801595],"length":1,"stats":{"Line":1},"fn_name":null},{"line":972,"address":[5802087,5801673,5802351,5802201],"length":1,"stats":{"Line":3},"fn_name":null},{"line":973,"address":[5802057,5802273],"length":1,"stats":{"Line":2},"fn_name":null},{"line":974,"address":[5802092],"length":1,"stats":{"Line":0},"fn_name":null},{"line":977,"address":[5802036],"length":1,"stats":{"Line":1},"fn_name":null},{"line":983,"address":[5318816,5318839],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":984,"address":[5802584],"length":1,"stats":{"Line":1},"fn_name":null},{"line":985,"address":[5802663],"length":1,"stats":{"Line":1},"fn_name":null},{"line":989,"address":[5318967,5318944],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":990,"address":[5802920],"length":1,"stats":{"Line":1},"fn_name":null},{"line":991,"address":[5802999],"length":1,"stats":{"Line":1},"fn_name":null},{"line":995,"address":[5319168,5319196],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":996,"address":[5803256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":997,"address":[5803335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1001,"address":[5319516,5319488],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":1002,"address":[5803608],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1003,"address":[5803687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1007,"address":[5319904,5319927],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":1008,"address":[5803960],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1009,"address":[5804039],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1013,"address":[5320096,5320032,5320046,5320119],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":1014,"address":[5804313],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1015,"address":[5804395],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1019,"address":[5320320,5320412,5320384,5320334],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":1020,"address":[5804665],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1021,"address":[5804747],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1025,"address":[5320704,5320796,5320768,5320718],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":1026,"address":[5805033],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1027,"address":[5805115],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1031,"address":[5805402,5805287],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1032,"address":[5805430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1033,"address":[5805437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1034,"address":[5805753,5805529],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1035,"address":[5805691],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1042,"address":[5806298,5806356,5806260],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1045,"address":[5806451],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1051,"address":[5806543,5806591],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1052,"address":[5806615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1053,"address":[5321294,5321280],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1055,"address":[5321422,5321408],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":1057,"address":[5807728,5807466,5806995,5807331],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1058,"address":[5321502,5321488],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1069,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1070,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1075,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1076,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1081,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1082,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1083,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1085,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1086,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1095,"address":[5808563,5808447],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1096,"address":[5808706,5808578,5808652],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1097,"address":[5808640,5808595],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1098,"address":[5808669],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1099,"address":[5808721,5808873,5808623],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1100,"address":[5808785],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1102,"address":[5808922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1110,"address":[5321710,5321696],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":1111,"address":[5809231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1114,"address":[5809214,5809291],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1115,"address":[5809345],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1117,"address":[5809426],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1118,"address":[5809621,5809468,5809559],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1119,"address":[5809497,5809547],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1120,"address":[5809564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1121,"address":[5809517,5809623],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1123,"address":[5809711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1130,"address":[5321824,5321867],"length":1,"stats":{"Line":1},"fn_name":"collapse_adjacent<fn(f64, f64) -> f64>"},{"line":1133,"address":[5321847],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1134,"address":[5322009,5321882,5322193,5321917,5322563],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1135,"address":[5322561,5322631,5322243,5322394],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1136,"address":[5322345],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1138,"address":[5322693,5322404,5322663,5322320],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1141,"address":[5322148],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1144,"address":[5321790,5321776],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":1145,"address":[5810024],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1148,"address":[5809995,5810082],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1150,"address":[5810370,5810196],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1151,"address":[5810257],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1153,"address":[5810239,5810380],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1155,"address":[5810419],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1161,"address":[5810594,5810713],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1162,"address":[5811013,5810755,5811161],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1163,"address":[5810784,5810864],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1164,"address":[5810790,5811026],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":450,"coverable":480},{"path":["/","home","kms","itertools","tests","specializations.rs"],"content":"use itertools::{EitherOrBoth, Itertools};\nuse std::fmt::Debug;\nuse std::ops::BitXor;\nuse quickcheck::quickcheck;\n\nstruct Unspecialized<I>(I);\nimpl<I> Iterator for Unspecialized<I>\nwhere\n    I: Iterator,\n{\n    type Item = I::Item;\n\n    #[inline(always)]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.0.next()\n    }\n\n    #[inline(always)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.0.size_hint()\n    }\n}\n\nfn check_specialized<'a, V, IterItem, Iter, F>(iterator: &Iter, mapper: F)\nwhere\n    V: Eq + Debug,\n    IterItem: 'a,\n    Iter: Iterator<Item = IterItem> + Clone + 'a,\n    F: Fn(Box<dyn Iterator<Item = IterItem> + 'a>) -> V,\n{\n    assert_eq!(\n        mapper(Box::new(Unspecialized(iterator.clone()))),\n        mapper(Box::new(iterator.clone()))\n    )\n}\n\nfn check_specialized_count_last_nth_sizeh<'a, IterItem, Iter>(\n    it: &Iter,\n    known_expected_size: Option<usize>,\n) where\n    IterItem: 'a + Eq + Debug,\n    Iter: Iterator<Item = IterItem> + Clone + 'a,\n{\n    let size = it.clone().count();\n    if let Some(expected_size) = known_expected_size {\n        assert_eq!(size, expected_size);\n    }\n    check_specialized(it, |i| i.count());\n    check_specialized(it, |i| i.last());\n    for n in 0..size + 2 {\n        check_specialized(it, |mut i| i.nth(n));\n    }\n    let mut it_sh = it.clone();\n    for n in 0..size + 2 {\n        let len = it_sh.clone().count();\n        let (min, max) = it_sh.size_hint();\n        assert_eq!((size - n.min(size)), len);\n        assert!(min <= len);\n        if let Some(max) = max {\n            assert!(len <= max);\n        }\n        it_sh.next();\n    }\n}\n\nfn check_specialized_fold_xor<'a, IterItem, Iter>(it: &Iter)\nwhere\n    IterItem: 'a\n        + BitXor\n        + Eq\n        + Debug\n        + BitXor<<IterItem as BitXor>::Output, Output = <IterItem as BitXor>::Output>\n        + Clone,\n    <IterItem as BitXor>::Output:\n        BitXor<Output = <IterItem as BitXor>::Output> + Eq + Debug + Clone,\n    Iter: Iterator<Item = IterItem> + Clone + 'a,\n{\n    check_specialized(it, |mut i| {\n        let first = i.next().map(|f| f.clone() ^ (f.clone() ^ f));\n        i.fold(first, |acc, v: IterItem| acc.map(move |a| v ^ a))\n    });\n}\n\nfn put_back_test(test_vec: Vec<i32>, known_expected_size: Option<usize>) {\n    {\n        // Lexical lifetimes support\n        let pb = itertools::put_back(test_vec.iter());\n        check_specialized_count_last_nth_sizeh(&pb, known_expected_size);\n        check_specialized_fold_xor(&pb);\n    }\n\n    let mut pb = itertools::put_back(test_vec.into_iter());\n    pb.put_back(1);\n    check_specialized_count_last_nth_sizeh(&pb, known_expected_size.map(|x| x + 1));\n    check_specialized_fold_xor(&pb)\n}\n\n#[test]\nfn put_back() {\n    put_back_test(vec![7, 4, 1], Some(3));\n}\n\nquickcheck! {\n    fn put_back_qc(test_vec: Vec<i32>) -> () {\n        put_back_test(test_vec, None)\n    }\n}\n\nfn merge_join_by_test(i1: Vec<usize>, i2: Vec<usize>, known_expected_size: Option<usize>) {\n    let i1 = i1.into_iter();\n    let i2 = i2.into_iter();\n    let mjb = i1.clone().merge_join_by(i2.clone(), std::cmp::Ord::cmp);\n    check_specialized_count_last_nth_sizeh(&mjb, known_expected_size);\n    // Rust 1.24 compatibility:\n    fn eob_left_z(eob: EitherOrBoth<usize, usize>) -> usize {\n        eob.left().unwrap_or(0)\n    }\n    fn eob_right_z(eob: EitherOrBoth<usize, usize>) -> usize {\n        eob.left().unwrap_or(0)\n    }\n    fn eob_both_z(eob: EitherOrBoth<usize, usize>) -> usize {\n        let (a, b) = eob.both().unwrap_or((0, 0));\n        assert_eq!(a, b);\n        a\n    }\n    check_specialized_fold_xor(&mjb.clone().map(eob_left_z));\n    check_specialized_fold_xor(&mjb.clone().map(eob_right_z));\n    check_specialized_fold_xor(&mjb.clone().map(eob_both_z));\n\n    // And the other way around\n    let mjb = i2.merge_join_by(i1, std::cmp::Ord::cmp);\n    check_specialized_count_last_nth_sizeh(&mjb, known_expected_size);\n    check_specialized_fold_xor(&mjb.clone().map(eob_left_z));\n    check_specialized_fold_xor(&mjb.clone().map(eob_right_z));\n    check_specialized_fold_xor(&mjb.clone().map(eob_both_z));\n}\n\n#[test]\nfn merge_join_by() {\n    let i1 = vec![1, 3, 5, 7, 8, 9];\n    let i2 = vec![0, 3, 4, 5];\n    merge_join_by_test(i1, i2, Some(8));\n}\n\nquickcheck! {\n    fn merge_join_by_qc(i1: Vec<usize>, i2: Vec<usize>) -> () {\n        merge_join_by_test(i1, i2, None)\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[4265264,4258037,4263525,4270064,4260800,4264368,4268128,4261733,4269024,4269062,4266176,4270032,4258950,4261696,4258912,4259952,4262592,4263488,4264400,4265296,4260832,4266214,4267184,4267216,4268160,4258000,4259920,4262624],"length":1,"stats":{"Line":25},"fn_name":"check_specialized<core::option::Option<itertools::either_or_both::EitherOrBoth<usize, usize>>,itertools::either_or_both::EitherOrBoth<usize, usize>,itertools::merge_join::MergeJoinBy<alloc::vec::IntoIter<usize>, alloc::vec::IntoIter<usize>, fn(&usize, &usize) -> core::cmp::Ordering>,closure-2>"},{"line":31,"address":[4269535,4268631,4270425,4270511,4262204,4267730,4268545,4264773,4269642,4258519,4262215,4268642,4263995,4266687,4270522,4259423,4262118,4263984,4269631,4265693,4263106,4264870,4263095,4266794,4265790,4258439,4260325,4263898,4263009,4267644,4266783,4258530,4260422,4265779,4261325,4261314,4264859,4259519,4259530,4267741,4260411,4261234],"length":1,"stats":{"Line":56},"fn_name":null},{"line":32,"address":[4261713,4265424,4263653,4270194,4266229,4267196,4262754,4258965,4263540,4258052,4265311,4259932,4261029,4268140,4262639,4264380,4260080,4260812,4264528,4265276,4258927,4262604,4267231,4267413,4261863,4268290,4261748,4266411,4269039,4269259,4270044,4264415,4270079,4259967,4263505,4268175,4260847,4258017,4266191,4258234,4269077,4259147],"length":1,"stats":{"Line":84},"fn_name":null},{"line":33,"address":[4270348,4265505,4268456,4266589,4262835,4258290,4259237,4260149,4263821,4261085,4262029,4267567,4268371,4258375,4262920,4264597,4261170,4264696,4260248,4259325,4265604,4266501,4267482,4269349,4263722,4269437,4261944,4270263],"length":1,"stats":{"Line":53},"fn_name":null},{"line":37,"address":[4275062,4273030,4270966,4270912,4275008,4272976],"length":1,"stats":{"Line":5},"fn_name":"check_specialized_count_last_nth_sizeh<itertools::either_or_both::EitherOrBoth<usize, usize>,itertools::merge_join::MergeJoinBy<alloc::vec::IntoIter<usize>, alloc::vec::IntoIter<usize>, fn(&usize, &usize) -> core::cmp::Ordering>>"},{"line":44,"address":[4270981,4275039,4275077,4273007,4270943,4273045],"length":1,"stats":{"Line":12},"fn_name":null},{"line":45,"address":[4271130,4273066,4273194,4275098,4271002,4275226],"length":1,"stats":{"Line":9},"fn_name":null},{"line":46,"address":[4271142,4273097,4271033,4273206,4275129,4275238],"length":1,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[4277075,4271440,4273504,4277139,4277120,4275536,4277184,4277203,4277056],"length":1,"stats":{"Line":15},"fn_name":"{{closure}}<&i32,itertools::adaptors::PutBack<core::slice::Iter<i32>>>"},{"line":49,"address":[4277395,4277248,4277331,4277270,4271453,4273517,4275549,4277376,4277312],"length":1,"stats":{"Line":18},"fn_name":"{{closure}}<itertools::either_or_both::EitherOrBoth<usize, usize>,itertools::merge_join::MergeJoinBy<alloc::vec::IntoIter<usize>, alloc::vec::IntoIter<usize>, fn(&usize, &usize) -> core::cmp::Ordering>>"},{"line":50,"address":[4271466,4272855,4275854,4271671,4271758,4275562,4273735,4276941,4274885,4273530,4273822,4275767],"length":1,"stats":{"Line":12},"fn_name":null},{"line":51,"address":[4273785,4275817,4277440,4271721,4277552,4277571,4277462,4277664,4277683],"length":1,"stats":{"Line":18},"fn_name":"{{closure}}<itertools::either_or_both::EitherOrBoth<usize, usize>,itertools::merge_join::MergeJoinBy<alloc::vec::IntoIter<usize>, alloc::vec::IntoIter<usize>, fn(&usize, &usize) -> core::cmp::Ordering>>"},{"line":53,"address":[4275744,4271648,4273712],"length":1,"stats":{"Line":6},"fn_name":null},{"line":54,"address":[4271763,4276971,4271990,4273827,4274028,4275975,4276928,4273930,4274872,4272842,4274915,4275859,4276086,4271879,4272885],"length":1,"stats":{"Line":18},"fn_name":null},{"line":55,"address":[4274094,4276152,4272056],"length":1,"stats":{"Line":6},"fn_name":null},{"line":56,"address":[4274150,4276208,4272112],"length":1,"stats":{"Line":6},"fn_name":null},{"line":57,"address":[4274997,4272167,4274205,4274424,4274967,4277053,4277023,4276482,4272937,4276263,4272967,4272386],"length":1,"stats":{"Line":6},"fn_name":null},{"line":58,"address":[4274747,4276805,4272350,4272709,4274388,4276446],"length":1,"stats":{"Line":6},"fn_name":null},{"line":59,"address":[4276792,4276881,4272785,4274734,4272742,4272696,4274780,4276838,4274823],"length":1,"stats":{"Line":18},"fn_name":null},{"line":60,"address":[4274796,4272787,4276854,4272758,4274825,4276883],"length":1,"stats":{"Line":6},"fn_name":null},{"line":62,"address":[4272833,4274863,4276921],"length":1,"stats":{"Line":6},"fn_name":null},{"line":66,"address":[4277824,4277792,4277808,4277776,4277840],"length":1,"stats":{"Line":10},"fn_name":"check_specialized_fold_xor<i32,itertools::adaptors::PutBack<alloc::vec::IntoIter<i32>>>"},{"line":78,"address":[4277813,4279520,4280213,4277797,4277845,4279744,4280352,4280160,4280407,4279790,4277781,4277829,4279575,4279991,4279936],"length":1,"stats":{"Line":20},"fn_name":"{{closure}}<usize,core::iter::adapters::Map<itertools::merge_join::MergeJoinBy<alloc::vec::IntoIter<usize>, alloc::vec::IntoIter<usize>, fn(&usize, &usize) -> core::cmp::Ordering>, fn(itertools::either_or_both::EitherOrBoth<usize, usize>) -> usize>>"},{"line":79,"address":[4277856,4279597,4278464,4278057,4280179,4278265,4279539,4280233,4279763,4278473,4280013,4279955,4277864,4278256,4278681,4278048,4280371,4279807,4280429,4278672],"length":1,"stats":{"Line":40},"fn_name":"{{closure}}<i32,itertools::adaptors::PutBack<alloc::vec::IntoIter<i32>>>"},{"line":80,"address":[4278940,4279200,4280264,4278880,4279838,4278990,4278976,4279221,4279634,4279304,4279360,4280050,4278928,4279086,4279120,4279280,4279440,4279024,4279037,4279464,4280466,4278894,4279072,4279384,4279142],"length":1,"stats":{"Line":50},"fn_name":"{{closure}}<usize,core::iter::adapters::Map<itertools::merge_join::MergeJoinBy<alloc::vec::IntoIter<usize>, alloc::vec::IntoIter<usize>, fn(&usize, &usize) -> core::cmp::Ordering>, fn(itertools::either_or_both::EitherOrBoth<usize, usize>) -> usize>>"},{"line":84,"address":[4210432,4210487],"length":1,"stats":{"Line":1},"fn_name":"put_back_test"},{"line":87,"address":[4210470,4210502],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[4210555],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[4210582],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[4210589],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[4210682],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[4210743,4210689],"length":1,"stats":{"Line":5},"fn_name":null},{"line":95,"address":[4210755],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[4213040],"length":1,"stats":{"Line":3},"fn_name":"put_back"},{"line":100,"address":[4213044],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[4213172],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[4210864,4211035],"length":1,"stats":{"Line":1},"fn_name":"merge_join_by_test"},{"line":110,"address":[4210881],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[4211050,4210975],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[4211058,4212060],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[4211161],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[4212336],"length":1,"stats":{"Line":2},"fn_name":"eob_left_z"},{"line":116,"address":[4212340],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[4212432],"length":1,"stats":{"Line":2},"fn_name":"eob_right_z"},{"line":119,"address":[4212436],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[4212528],"length":1,"stats":{"Line":2},"fn_name":"eob_both_z"},{"line":122,"address":[4212535],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[4212650,4212764],"length":1,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[4212744],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[4211243,4211202],"length":1,"stats":{"Line":4},"fn_name":null},{"line":127,"address":[4211311],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[4211405],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[4211483],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[4211582],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[4211623,4211664],"length":1,"stats":{"Line":4},"fn_name":null},{"line":134,"address":[4211732],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[4211826],"length":1,"stats":{"Line":2},"fn_name":null},{"line":139,"address":[4213232,4213331],"length":1,"stats":{"Line":3},"fn_name":"merge_join_by"},{"line":140,"address":[4213346,4213239],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[4213364],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[4213436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[4213620],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":64,"coverable":66},{"path":["/","home","kms","itertools","tests","test_core.rs"],"content":"//! Licensed under the Apache License, Version 2.0\n//! http://www.apache.org/licenses/LICENSE-2.0 or the MIT license\n//! http://opensource.org/licenses/MIT, at your\n//! option. This file may not be copied, modified, or distributed\n//! except according to those terms.\n#![no_std]\n\nuse core::iter;\nuse itertools as it;\nuse crate::it::Itertools;\nuse crate::it::interleave;\nuse crate::it::multizip;\nuse crate::it::free::put_back;\nuse crate::it::iproduct;\nuse crate::it::izip;\n\n#[test]\nfn product2() {\n    let s = \"αβ\";\n\n    let mut prod = iproduct!(s.chars(), 0..2);\n    assert!(prod.next() == Some(('α', 0)));\n    assert!(prod.next() == Some(('α', 1)));\n    assert!(prod.next() == Some(('β', 0)));\n    assert!(prod.next() == Some(('β', 1)));\n    assert!(prod.next() == None);\n}\n\n#[test]\nfn product_temporary() {\n    for (_x, _y, _z) in iproduct!(\n        [0, 1, 2].iter().cloned(),\n        [0, 1, 2].iter().cloned(),\n        [0, 1, 2].iter().cloned())\n    {\n        // ok\n    }\n}\n\n\n#[test]\nfn izip_macro() {\n    let mut zip = izip!(2..3);\n    assert!(zip.next() == Some(2));\n    assert!(zip.next().is_none());\n\n    let mut zip = izip!(0..3, 0..2, 0..2i8);\n    for i in 0..2 {\n        assert!((i as usize, i, i as i8) == zip.next().unwrap());\n    }\n    assert!(zip.next().is_none());\n\n    let xs: [isize; 0] = [];\n    let mut zip = izip!(0..3, 0..2, 0..2i8, &xs);\n    assert!(zip.next().is_none());\n}\n\n#[test]\nfn izip2() {\n    let _zip1: iter::Zip<_, _> = izip!(1.., 2..);\n    let _zip2: iter::Zip<_, _> = izip!(1.., 2.., );\n}\n\n#[test]\nfn izip3() {\n    let mut zip: iter::Map<iter::Zip<_, _>, _> = izip!(0..3, 0..2, 0..2i8);\n    for i in 0..2 {\n        assert!((i as usize, i, i as i8) == zip.next().unwrap());\n    }\n    assert!(zip.next().is_none());\n}\n\n#[test]\nfn multizip3() {\n    let mut zip = multizip((0..3, 0..2, 0..2i8));\n    for i in 0..2 {\n        assert!((i as usize, i, i as i8) == zip.next().unwrap());\n    }\n    assert!(zip.next().is_none());\n\n    let xs: [isize; 0] = [];\n    let mut zip = multizip((0..3, 0..2, 0..2i8, xs.iter()));\n    assert!(zip.next().is_none());\n\n    for (_, _, _, _, _) in multizip((0..3, 0..2, xs.iter(), &xs, xs.to_vec())) {\n        /* test compiles */\n    }\n}\n\n#[test]\nfn write_to() {\n    let xs = [7, 9, 8];\n    let mut ys = [0; 5];\n    let cnt = ys.iter_mut().set_from(xs.iter().map(|x| *x));\n    assert!(cnt == xs.len());\n    assert!(ys == [7, 9, 8, 0, 0]);\n\n    let cnt = ys.iter_mut().set_from(0..10);\n    assert!(cnt == ys.len());\n    assert!(ys == [0, 1, 2, 3, 4]);\n}\n\n#[test]\nfn test_interleave() {\n    let xs: [u8; 0]  = [];\n    let ys = [7u8, 9, 8, 10];\n    let zs = [2u8, 77];\n    let it = interleave(xs.iter(), ys.iter());\n    it::assert_equal(it, ys.iter());\n\n    let rs = [7u8, 2, 9, 77, 8, 10];\n    let it = interleave(ys.iter(), zs.iter());\n    it::assert_equal(it, rs.iter());\n}\n\n#[allow(deprecated)]\n#[test]\nfn foreach() {\n    let xs = [1i32, 2, 3];\n    let mut sum = 0;\n    xs.iter().foreach(|elt| sum += *elt);\n    assert!(sum == 6);\n}\n\n#[test]\nfn dropping() {\n    let xs = [1, 2, 3];\n    let mut it = xs.iter().dropping(2);\n    assert_eq!(it.next(), Some(&3));\n    assert!(it.next().is_none());\n    let mut it = xs.iter().dropping(5);\n    assert!(it.next().is_none());\n}\n\n#[test]\nfn batching() {\n    let xs = [0, 1, 2, 1, 3];\n    let ys = [(0, 1), (2, 1)];\n\n    // An iterator that gathers elements up in pairs\n    let pit = xs.iter().cloned().batching(|it| {\n               match it.next() {\n                   None => None,\n                   Some(x) => match it.next() {\n                       None => None,\n                       Some(y) => Some((x, y)),\n                   }\n               }\n           });\n    it::assert_equal(pit, ys.iter().cloned());\n}\n\n#[test]\nfn test_put_back() {\n    let xs = [0, 1, 1, 1, 2, 1, 3, 3];\n    let mut pb = put_back(xs.iter().cloned());\n    pb.next();\n    pb.put_back(1);\n    pb.put_back(0);\n    it::assert_equal(pb, xs.iter().cloned());\n}\n\n#[allow(deprecated)]\n#[test]\nfn step() {\n    it::assert_equal((0..10).step(1), 0..10);\n    it::assert_equal((0..10).step(2), (0..10).filter(|x: &i32| *x % 2 == 0));\n    it::assert_equal((0..10).step(10), 0..1);\n}\n\n#[allow(deprecated)]\n#[test]\nfn merge() {\n    it::assert_equal((0..10).step(2).merge((1..10).step(2)), 0..10);\n}\n\n\n#[test]\nfn repeatn() {\n    let s = \"α\";\n    let mut it = it::repeat_n(s, 3);\n    assert_eq!(it.len(), 3);\n    assert_eq!(it.next(), Some(s));\n    assert_eq!(it.next(), Some(s));\n    assert_eq!(it.next(), Some(s));\n    assert_eq!(it.next(), None);\n    assert_eq!(it.next(), None);\n}\n\n#[test]\nfn count_clones() {\n    // Check that RepeatN only clones N - 1 times.\n\n    use core::cell::Cell;\n    #[derive(PartialEq, Debug)]\n    struct Foo {\n        n: Cell<usize>\n    }\n\n    impl Clone for Foo\n    {\n        fn clone(&self) -> Self\n        {\n            let n = self.n.get();\n            self.n.set(n + 1);\n            Foo { n: Cell::new(n + 1) }\n        }\n    }\n\n\n    for n in 0..10 {\n        let f = Foo{n: Cell::new(0)};\n        let it = it::repeat_n(f, n);\n        // drain it\n        let last = it.last();\n        if n == 0 {\n            assert_eq!(last, None);\n        } else {\n            assert_eq!(last, Some(Foo{n: Cell::new(n - 1)}));\n        }\n    }\n}\n\n#[test]\nfn part() {\n    let mut data = [7, 1, 1, 9, 1, 1, 3];\n    let i = it::partition(&mut data, |elt| *elt >= 3);\n    assert_eq!(i, 3);\n    assert_eq!(data, [7, 3, 9, 1, 1, 1, 1]);\n\n    let i = it::partition(&mut data, |elt| *elt == 1);\n    assert_eq!(i, 4);\n    assert_eq!(data, [1, 1, 1, 1, 9, 3, 7]);\n\n    let mut data = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let i = it::partition(&mut data, |elt| *elt % 3 == 0);\n    assert_eq!(i, 3);\n    assert_eq!(data, [9, 6, 3, 4, 5, 2, 7, 8, 1]);\n}\n\n#[test]\nfn tree_fold1() {\n    for i in 0..100 {\n        assert_eq!((0..i).tree_fold1(|x, y| x + y), (0..i).fold1(|x, y| x + y));\n    }\n}\n\n#[test]\nfn exactly_one() {\n    assert_eq!((0..10).filter(|&x| x == 2).exactly_one().unwrap(), 2);\n    assert!((0..10).filter(|&x| x > 1 && x < 4).exactly_one().unwrap_err().eq(2..4));\n    assert!((0..10).filter(|&x| x > 1 && x < 5).exactly_one().unwrap_err().eq(2..5));\n    assert!((0..10).filter(|&_| false).exactly_one().unwrap_err().eq(0..0));\n}\n\n#[test]\nfn sum1() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq!(v[..0].iter().cloned().sum1::<i32>(), None);\n    assert_eq!(v[1..2].iter().cloned().sum1::<i32>(), Some(1));\n    assert_eq!(v[1..3].iter().cloned().sum1::<i32>(), Some(3));\n    assert_eq!(v.iter().cloned().sum1::<i32>(), Some(55));\n}\n\n#[test]\nfn product1() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq!(v[..0].iter().cloned().product1::<i32>(), None);\n    assert_eq!(v[..1].iter().cloned().product1::<i32>(), Some(0));\n    assert_eq!(v[1..3].iter().cloned().product1::<i32>(), Some(2));\n    assert_eq!(v[1..5].iter().cloned().product1::<i32>(), Some(24));\n}\n","traces":[{"line":18,"address":[4239328],"length":1,"stats":{"Line":3},"fn_name":"product2"},{"line":19,"address":[4239342],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[4239359],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[4239501,4239593],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[4239715,4239565,4239649],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[4239687,4239771,4239837],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[4239893,4239959,4239809],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[4239931,4240060,4240015,4240107],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[4282528,4282533],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":31,"address":[4240410,4240276,4240196,4240575],"length":1,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[4240126],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[4240218],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[4240352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[4240720],"length":1,"stats":{"Line":3},"fn_name":"izip_macro"},{"line":43,"address":[4240727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[4240769,4240858],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[4240999,4240830,4240907],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[4240934,4241048],"length":1,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[4241184,4241326,4241491],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[4241370,4241503],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[4241637,4241552,4241300],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[4241686,4241579],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[4241912,4241959,4241849],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[4241968],"length":1,"stats":{"Line":3},"fn_name":"izip2"},{"line":60,"address":[4241972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[4242019],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[4282789,4282784],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":66,"address":[4242087],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[4242571,4242270,4242409],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[4242453,4242583],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[4242632,4242721,4242386,4242674],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[4242736,4242911],"length":1,"stats":{"Line":3},"fn_name":"multizip3"},{"line":75,"address":[4242743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[4242926,4243065,4243227],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[4243109,4243239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[4243288,4243042,4243411],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[4243460,4243319],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[4243593,4243721],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[4243645,4244054,4244097,4243772],"length":1,"stats":{"Line":3},"fn_name":null},{"line":91,"address":[4244336],"length":1,"stats":{"Line":3},"fn_name":"write_to"},{"line":92,"address":[4244343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[4244367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[4244402],"length":1,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[4244507,4244603],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[4244574,4244656,4244705],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[4244675,4244754],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[4244811,4244910],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[4245031,4244984,4244963,4244881],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[4245040],"length":1,"stats":{"Line":3},"fn_name":"test_interleave"},{"line":106,"address":[4245051],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[4245071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[4245081],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[4245159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[4245239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[4245287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[4245376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[4245472],"length":1,"stats":{"Line":3},"fn_name":"foreach"},{"line":119,"address":[4245476],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[4245500],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[4245508],"length":1,"stats":{"Line":3},"fn_name":null},{"line":122,"address":[4245633,4245592,4245566],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[4245648],"length":1,"stats":{"Line":3},"fn_name":"dropping"},{"line":127,"address":[4245655],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[4245685],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[4245749,4245894],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[4246263,4245868,4246199],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[4246327,4246226],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[4246348,4246460,4246411],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[4246464],"length":1,"stats":{"Line":3},"fn_name":"batching"},{"line":137,"address":[4246471],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[4246511],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[4246587],"length":1,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[4283217,4283275,4283382,4283262],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[4283269,4283247],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[4283277,4283318,4283331],"length":1,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[4283325,4283303],"length":1,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[4283333],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[4246671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[4246784],"length":1,"stats":{"Line":3},"fn_name":"test_put_back"},{"line":155,"address":[4246791],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[4246855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[4246928],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[4246938],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[4246955],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[4246965],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[4247088],"length":1,"stats":{"Line":3},"fn_name":"step"},{"line":166,"address":[4247095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[4247168],"length":1,"stats":{"Line":3},"fn_name":null},{"line":168,"address":[4247262],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[4247360],"length":1,"stats":{"Line":3},"fn_name":"merge"},{"line":174,"address":[4247367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[4247536],"length":1,"stats":{"Line":3},"fn_name":"repeatn"},{"line":180,"address":[4247550],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[4247570],"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[4247762,4247604],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[4248263,4248092,4247729],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[4248237,4248769,4248598],"length":1,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[4248743,4249104,4249275],"length":1,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[4249593,4249249,4249718],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[4250030,4250129,4249692],"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[4250432],"length":1,"stats":{"Line":3},"fn_name":"count_clones"},{"line":202,"address":[4251712],"length":1,"stats":{"Line":1},"fn_name":"clone"},{"line":204,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[4250585,4251670,4250439],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[4250639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[4250662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[4250691],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[4250752,4251362,4250897],"length":1,"stats":{"Line":3},"fn_name":null},{"line":217,"address":[4250902,4250806],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[4250763,4251705,4251212,4251367,4251675],"length":1,"stats":{"Line":2},"fn_name":null},{"line":225,"address":[4252224],"length":1,"stats":{"Line":3},"fn_name":"part"},{"line":226,"address":[4252231],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[4252308],"length":1,"stats":{"Line":3},"fn_name":null},{"line":228,"address":[4252336,4252528],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[4252432,4252865,4252897],"length":1,"stats":{"Line":2},"fn_name":null},{"line":231,"address":[4252871],"length":1,"stats":{"Line":3},"fn_name":null},{"line":232,"address":[4253431,4253239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[4253335,4253899,4253768],"length":1,"stats":{"Line":2},"fn_name":null},{"line":235,"address":[4253774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[4253873],"length":1,"stats":{"Line":3},"fn_name":null},{"line":237,"address":[4254406,4254217],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[4254710,4254724,4254313],"length":1,"stats":{"Line":2},"fn_name":null},{"line":242,"address":[4255040],"length":1,"stats":{"Line":3},"fn_name":"tree_fold1"},{"line":243,"address":[4255343,4255141,4255047],"length":1,"stats":{"Line":2},"fn_name":null},{"line":244,"address":[4255348,4255167],"length":1,"stats":{"Line":5},"fn_name":null},{"line":249,"address":[4255664],"length":1,"stats":{"Line":3},"fn_name":"exactly_one"},{"line":250,"address":[4255671,4255912],"length":1,"stats":{"Line":3},"fn_name":null},{"line":251,"address":[4256380,4255858,4256217],"length":1,"stats":{"Line":4},"fn_name":null},{"line":252,"address":[4256429,4256592,4256322],"length":1,"stats":{"Line":4},"fn_name":null},{"line":253,"address":[4256810,4256534,4256641,4256761],"length":1,"stats":{"Line":4},"fn_name":null},{"line":257,"address":[4256816],"length":1,"stats":{"Line":3},"fn_name":"sum1"},{"line":258,"address":[4256830],"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[4257202,4256850],"length":1,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[4257832,4257553,4257120],"length":1,"stats":{"Line":2},"fn_name":null},{"line":261,"address":[4258183,4258410,4257750],"length":1,"stats":{"Line":2},"fn_name":null},{"line":262,"address":[4258875,4258725,4258374],"length":1,"stats":{"Line":2},"fn_name":null},{"line":266,"address":[4259184],"length":1,"stats":{"Line":3},"fn_name":"product1"},{"line":267,"address":[4259198],"length":1,"stats":{"Line":1},"fn_name":null},{"line":268,"address":[4259218,4259550],"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[4259488,4259901,4260180],"length":1,"stats":{"Line":2},"fn_name":null},{"line":270,"address":[4260810,4260098,4260531],"length":1,"stats":{"Line":2},"fn_name":null},{"line":271,"address":[4261306,4260728,4261131],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":144,"coverable":144},{"path":["/","home","kms","itertools","tests","test_std.rs"],"content":"use permutohedron;\nuse itertools as it;\nuse crate::it::Itertools;\nuse crate::it::multizip;\nuse crate::it::multipeek;\nuse crate::it::peek_nth;\nuse crate::it::free::rciter;\nuse crate::it::free::put_back_n;\nuse crate::it::FoldWhile;\nuse crate::it::cloned;\nuse crate::it::iproduct;\nuse crate::it::izip;\n\n#[test]\nfn product3() {\n    let prod = iproduct!(0..3, 0..2, 0..2);\n    assert_eq!(prod.size_hint(), (12, Some(12)));\n    let v = prod.collect_vec();\n    for i in 0..3 {\n        for j in 0..2 {\n            for k in 0..2 {\n                assert!((i, j, k) == v[(i * 2 * 2 + j * 2 + k) as usize]);\n            }\n        }\n    }\n    for (_, _, _, _) in iproduct!(0..3, 0..2, 0..2, 0..3) {\n        /* test compiles */\n    }\n}\n\n#[test]\nfn interleave_shortest() {\n    let v0: Vec<i32> = vec![0, 2, 4];\n    let v1: Vec<i32> = vec![1, 3, 5, 7];\n    let it = v0.into_iter().interleave_shortest(v1.into_iter());\n    assert_eq!(it.size_hint(), (6, Some(6)));\n    assert_eq!(it.collect_vec(), vec![0, 1, 2, 3, 4, 5]);\n\n    let v0: Vec<i32> = vec![0, 2, 4, 6, 8];\n    let v1: Vec<i32> = vec![1, 3, 5];\n    let it = v0.into_iter().interleave_shortest(v1.into_iter());\n    assert_eq!(it.size_hint(), (7, Some(7)));\n    assert_eq!(it.collect_vec(), vec![0, 1, 2, 3, 4, 5, 6]);\n\n    let i0 = ::std::iter::repeat(0);\n    let v1: Vec<_> = vec![1, 3, 5];\n    let it = i0.interleave_shortest(v1.into_iter());\n    assert_eq!(it.size_hint(), (7, Some(7)));\n\n    let v0: Vec<_> = vec![0, 2, 4];\n    let i1 = ::std::iter::repeat(1);\n    let it = v0.into_iter().interleave_shortest(i1);\n    assert_eq!(it.size_hint(), (6, Some(6)));\n}\n\n\n#[test]\nfn unique_by() {\n    let xs = [\"aaa\", \"bbbbb\", \"aa\", \"ccc\", \"bbbb\", \"aaaaa\", \"cccc\"];\n    let ys = [\"aaa\", \"bbbbb\", \"ccc\"];\n    it::assert_equal(ys.iter(), xs.iter().unique_by(|x| x[..2].to_string()));\n    it::assert_equal(ys.iter(), xs.iter().rev().unique_by(|x| x[..2].to_string()).rev());\n    let ys_rev = [\"cccc\", \"aaaaa\", \"bbbb\"];\n    it::assert_equal(ys_rev.iter(), xs.iter().unique_by(|x| x[..2].to_string()).rev());\n}\n\n#[test]\nfn unique() {\n    let xs = [0, 1, 2, 3, 2, 1, 3];\n    let ys = [0, 1, 2, 3];\n    it::assert_equal(ys.iter(), xs.iter().unique());\n    it::assert_equal(ys.iter(), xs.iter().rev().unique().rev());\n    let ys_rev = [3, 1, 2, 0];\n    it::assert_equal(ys_rev.iter(), xs.iter().unique().rev());\n\n    let xs = [0, 1];\n    let ys = [0, 1];\n    it::assert_equal(ys.iter(), xs.iter().unique());\n    it::assert_equal(ys.iter(), xs.iter().rev().unique().rev());\n    let ys_rev = [1, 0];\n    it::assert_equal(ys_rev.iter(), xs.iter().unique().rev());\n}\n\n#[test]\nfn intersperse() {\n    let xs = [\"a\", \"\", \"b\", \"c\"];\n    let v: Vec<&str> = xs.iter().map(|x| x.clone()).intersperse(\", \").collect();\n    let text: String = v.concat();\n    assert_eq!(text, \"a, , b, c\".to_string());\n\n    let ys = [0, 1, 2, 3];\n    let mut it = ys[..0].iter().map(|x| *x).intersperse(1);\n    assert!(it.next() == None);\n}\n\n#[test]\nfn dedup() {\n    let xs = [0, 1, 1, 1, 2, 1, 3, 3];\n    let ys = [0, 1, 2, 1, 3];\n    it::assert_equal(ys.iter(), xs.iter().dedup());\n    let xs = [0, 0, 0, 0, 0];\n    let ys = [0];\n    it::assert_equal(ys.iter(), xs.iter().dedup());\n\n    let xs = [0, 1, 1, 1, 2, 1, 3, 3];\n    let ys = [0, 1, 2, 1, 3];\n    let mut xs_d = Vec::new();\n    xs.iter().dedup().fold((), |(), &elt| xs_d.push(elt));\n    assert_eq!(&xs_d, &ys);\n}\n\n#[test]\nfn dedup_by() {\n    let xs = [(0, 0), (0, 1), (1, 1), (2, 1), (0, 2), (3, 1), (0, 3), (1, 3)];\n    let ys = [(0, 0), (0, 1), (0, 2), (3, 1), (0, 3)];\n    it::assert_equal(ys.iter(), xs.iter().dedup_by(|x, y| x.1==y.1));\n    let xs = [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)];\n    let ys = [(0, 1)];\n    it::assert_equal(ys.iter(), xs.iter().dedup_by(|x, y| x.0==y.0));\n\n    let xs = [(0, 0), (0, 1), (1, 1), (2, 1), (0, 2), (3, 1), (0, 3), (1, 3)];\n    let ys = [(0, 0), (0, 1), (0, 2), (3, 1), (0, 3)];\n    let mut xs_d = Vec::new();\n    xs.iter().dedup_by(|x, y| x.1==y.1).fold((), |(), &elt| xs_d.push(elt));\n    assert_eq!(&xs_d, &ys);\n}\n\n#[test]\nfn dedup_with_count() {\n    let xs: [i32; 8] = [0, 1, 1, 1, 2, 1, 3, 3];\n    let ys: [(usize, &i32); 5] = [(1, &0), (3, &1), (1, &2), (1, &1), (2, &3)];\n\n    it::assert_equal(ys.iter().cloned(), xs.iter().dedup_with_count());\n\n    let xs: [i32; 5] = [0, 0, 0, 0, 0];\n    let ys: [(usize, &i32); 1] = [(5, &0)];\n\n    it::assert_equal(ys.iter().cloned(), xs.iter().dedup_with_count());\n}\n\n\n#[test]\nfn dedup_by_with_count() {\n    let xs = [(0, 0), (0, 1), (1, 1), (2, 1), (0, 2), (3, 1), (0, 3), (1, 3)];\n    let ys = [(1, &(0, 0)), (3, &(0, 1)), (1, &(0, 2)), (1, &(3, 1)), (2, &(0, 3))];\n\n    it::assert_equal(ys.iter().cloned(), xs.iter().dedup_by_with_count(|x, y| x.1==y.1));\n\n    let xs = [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)];\n    let ys = [( 5, &(0, 1))];\n\n    it::assert_equal(ys.iter().cloned(), xs.iter().dedup_by_with_count(|x, y| x.0==y.0));\n}\n\n#[test]\nfn all_equal() {\n    assert!(\"\".chars().all_equal());\n    assert!(\"A\".chars().all_equal());\n    assert!(!\"AABBCCC\".chars().all_equal());\n    assert!(\"AAAAAAA\".chars().all_equal());\n    for (_key, mut sub) in &\"AABBCCC\".chars().group_by(|&x| x) {\n        assert!(sub.all_equal());\n    }\n}\n\n#[test]\nfn test_put_back_n() {\n    let xs = [0, 1, 1, 1, 2, 1, 3, 3];\n    let mut pb = put_back_n(xs.iter().cloned());\n    pb.next();\n    pb.next();\n    pb.put_back(1);\n    pb.put_back(0);\n    it::assert_equal(pb, xs.iter().cloned());\n}\n\n#[test]\nfn tee() {\n    let xs  = [0, 1, 2, 3];\n    let (mut t1, mut t2) = xs.iter().cloned().tee();\n    assert_eq!(t1.next(), Some(0));\n    assert_eq!(t2.next(), Some(0));\n    assert_eq!(t1.next(), Some(1));\n    assert_eq!(t1.next(), Some(2));\n    assert_eq!(t1.next(), Some(3));\n    assert_eq!(t1.next(), None);\n    assert_eq!(t2.next(), Some(1));\n    assert_eq!(t2.next(), Some(2));\n    assert_eq!(t1.next(), None);\n    assert_eq!(t2.next(), Some(3));\n    assert_eq!(t2.next(), None);\n    assert_eq!(t1.next(), None);\n    assert_eq!(t2.next(), None);\n\n    let (t1, t2) = xs.iter().cloned().tee();\n    it::assert_equal(t1, xs.iter().cloned());\n    it::assert_equal(t2, xs.iter().cloned());\n\n    let (t1, t2) = xs.iter().cloned().tee();\n    it::assert_equal(t1.zip(t2), xs.iter().cloned().zip(xs.iter().cloned()));\n}\n\n\n#[test]\nfn test_rciter() {\n    let xs = [0, 1, 1, 1, 2, 1, 3, 5, 6];\n\n    let mut r1 = rciter(xs.iter().cloned());\n    let mut r2 = r1.clone();\n    assert_eq!(r1.next(), Some(0));\n    assert_eq!(r2.next(), Some(1));\n    let mut z = r1.zip(r2);\n    assert_eq!(z.next(), Some((1, 1)));\n    assert_eq!(z.next(), Some((2, 1)));\n    assert_eq!(z.next(), Some((3, 5)));\n    assert_eq!(z.next(), None);\n\n    // test intoiterator\n    let r1 = rciter(0..5);\n    let mut z = izip!(&r1, r1);\n    assert_eq!(z.next(), Some((0, 1)));\n}\n\n#[allow(deprecated)]\n#[test]\nfn trait_pointers() {\n    struct ByRef<'r, I: ?Sized>(&'r mut I) ;\n\n    impl<'r, X, I: ?Sized> Iterator for ByRef<'r, I> where\n        I: 'r + Iterator<Item=X>\n    {\n        type Item = X;\n        fn next(&mut self) -> Option<Self::Item>\n        {\n            self.0.next()\n        }\n    }\n\n    let mut it = Box::new(0..10) as Box<dyn Iterator<Item=i32>>;\n    assert_eq!(it.next(), Some(0));\n\n    {\n        /* make sure foreach works on non-Sized */\n        let jt: &mut dyn Iterator<Item = i32> = &mut *it;\n        assert_eq!(jt.next(), Some(1));\n\n        {\n            let mut r = ByRef(jt);\n            assert_eq!(r.next(), Some(2));\n        }\n\n        assert_eq!(jt.find_position(|x| *x == 4), Some((1, 4)));\n        jt.foreach(|_| ());\n    }\n}\n\n#[test]\nfn merge_by() {\n    let odd : Vec<(u32, &str)> = vec![(1, \"hello\"), (3, \"world\"), (5, \"!\")];\n    let even = vec![(2, \"foo\"), (4, \"bar\"), (6, \"baz\")];\n    let expected = vec![(1, \"hello\"), (2, \"foo\"), (3, \"world\"), (4, \"bar\"), (5, \"!\"), (6, \"baz\")];\n    let results = odd.iter().merge_by(even.iter(), |a, b| a.0 <= b.0);\n    it::assert_equal(results, expected.iter());\n}\n\n#[test]\nfn merge_by_btree() {\n    use std::collections::BTreeMap;\n    let mut bt1 = BTreeMap::new();\n    bt1.insert(\"hello\", 1);\n    bt1.insert(\"world\", 3);\n    let mut bt2 = BTreeMap::new();\n    bt2.insert(\"foo\", 2);\n    bt2.insert(\"bar\", 4);\n    let results = bt1.into_iter().merge_by(bt2.into_iter(), |a, b| a.0 <= b.0 );\n    let expected = vec![(\"bar\", 4), (\"foo\", 2), (\"hello\", 1), (\"world\", 3)];\n    it::assert_equal(results, expected.into_iter());\n}\n\n#[allow(deprecated)]\n#[test]\nfn kmerge() {\n    let its = (0..4).map(|s| (s..10).step(4));\n\n    it::assert_equal(its.kmerge(), 0..10);\n}\n\n#[allow(deprecated)]\n#[test]\nfn kmerge_2() {\n    let its = vec![3, 2, 1, 0].into_iter().map(|s| (s..10).step(4));\n\n    it::assert_equal(its.kmerge(), 0..10);\n}\n\n#[test]\nfn kmerge_empty() {\n    let its = (0..4).map(|_| 0..0);\n    assert_eq!(its.kmerge().next(), None);\n}\n\n#[test]\nfn kmerge_size_hint() {\n    let its = (0..5).map(|_| (0..10));\n    assert_eq!(its.kmerge().size_hint(), (50, Some(50)));\n}\n\n#[test]\nfn kmerge_empty_size_hint() {\n    let its = (0..5).map(|_| (0..0));\n    assert_eq!(its.kmerge().size_hint(), (0, Some(0)));\n}\n\n#[test]\nfn join() {\n    let many = [1, 2, 3];\n    let one  = [1];\n    let none: Vec<i32> = vec![];\n\n    assert_eq!(many.iter().join(\", \"), \"1, 2, 3\");\n    assert_eq!( one.iter().join(\", \"), \"1\");\n    assert_eq!(none.iter().join(\", \"), \"\");\n}\n\n#[test]\nfn sorted_by() {\n    let sc = [3, 4, 1, 2].iter().cloned().sorted_by(|&a, &b| {\n        a.cmp(&b)\n    });\n    it::assert_equal(sc, vec![1, 2, 3, 4]);\n\n    let v = (0..5).sorted_by(|&a, &b| a.cmp(&b).reverse());\n    it::assert_equal(v, vec![4, 3, 2, 1, 0]);\n}\n\n#[test]\nfn sorted_by_key() {\n    let sc = [3, 4, 1, 2].iter().cloned().sorted_by_key(|&x| x);\n    it::assert_equal(sc, vec![1, 2, 3, 4]);\n\n    let v = (0..5).sorted_by_key(|&x| -x);\n    it::assert_equal(v, vec![4, 3, 2, 1, 0]);\n}\n\n#[test]\nfn test_multipeek() {\n    let nums = vec![1u8,2,3,4,5];\n\n    let mp = multipeek(nums.iter().map(|&x| x));\n    assert_eq!(nums, mp.collect::<Vec<_>>());\n\n    let mut mp = multipeek(nums.iter().map(|&x| x));\n    assert_eq!(mp.peek(), Some(&1));\n    assert_eq!(mp.next(), Some(1));\n    assert_eq!(mp.peek(), Some(&2));\n    assert_eq!(mp.peek(), Some(&3));\n    assert_eq!(mp.next(), Some(2));\n    assert_eq!(mp.peek(), Some(&3));\n    assert_eq!(mp.peek(), Some(&4));\n    assert_eq!(mp.peek(), Some(&5));\n    assert_eq!(mp.peek(), None);\n    assert_eq!(mp.next(), Some(3));\n    assert_eq!(mp.next(), Some(4));\n    assert_eq!(mp.peek(), Some(&5));\n    assert_eq!(mp.peek(), None);\n    assert_eq!(mp.next(), Some(5));\n    assert_eq!(mp.next(), None);\n    assert_eq!(mp.peek(), None);\n\n}\n\n#[test]\nfn test_multipeek_reset() {\n    let data = [1, 2, 3, 4];\n\n    let mut mp = multipeek(cloned(&data));\n    assert_eq!(mp.peek(), Some(&1));\n    assert_eq!(mp.next(), Some(1));\n    assert_eq!(mp.peek(), Some(&2));\n    assert_eq!(mp.peek(), Some(&3));\n    mp.reset_peek();\n    assert_eq!(mp.peek(), Some(&2));\n    assert_eq!(mp.next(), Some(2));\n}\n\n#[test]\nfn test_multipeek_peeking_next() {\n    use crate::it::PeekingNext;\n    let nums = vec![1u8,2,3,4,5,6,7];\n\n    let mut mp = multipeek(nums.iter().map(|&x| x));\n    assert_eq!(mp.peeking_next(|&x| x != 0), Some(1));\n    assert_eq!(mp.next(), Some(2));\n    assert_eq!(mp.peek(), Some(&3));\n    assert_eq!(mp.peek(), Some(&4));\n    assert_eq!(mp.peeking_next(|&x| x == 3), Some(3));\n    assert_eq!(mp.peek(), Some(&4));\n    assert_eq!(mp.peeking_next(|&x| x != 4), None);\n    assert_eq!(mp.peeking_next(|&x| x == 4), Some(4));\n    assert_eq!(mp.peek(), Some(&5));\n    assert_eq!(mp.peek(), Some(&6));\n    assert_eq!(mp.peeking_next(|&x| x != 5), None);\n    assert_eq!(mp.peek(), Some(&7));\n    assert_eq!(mp.peeking_next(|&x| x == 5), Some(5));\n    assert_eq!(mp.peeking_next(|&x| x == 6), Some(6));\n    assert_eq!(mp.peek(), Some(&7));\n    assert_eq!(mp.peek(), None);\n    assert_eq!(mp.next(), Some(7));\n    assert_eq!(mp.peek(), None);\n}\n\n#[test]\nfn test_peek_nth() {\n    let nums = vec![1u8,2,3,4,5];\n\n    let iter = peek_nth(nums.iter().map(|&x| x));\n    assert_eq!(nums, iter.collect::<Vec<_>>());\n\n    let mut iter = peek_nth(nums.iter().map(|&x| x));\n\n    assert_eq!(iter.peek_nth(0), Some(&1));\n    assert_eq!(iter.peek_nth(0), Some(&1));\n    assert_eq!(iter.next(), Some(1));\n\n    assert_eq!(iter.peek_nth(0), Some(&2));\n    assert_eq!(iter.peek_nth(1), Some(&3));\n    assert_eq!(iter.next(), Some(2));\n\n    assert_eq!(iter.peek_nth(0), Some(&3));\n    assert_eq!(iter.peek_nth(1), Some(&4));\n    assert_eq!(iter.peek_nth(2), Some(&5));\n    assert_eq!(iter.peek_nth(3), None);\n\n    assert_eq!(iter.next(), Some(3));\n    assert_eq!(iter.next(), Some(4));\n\n    assert_eq!(iter.peek_nth(0), Some(&5));\n    assert_eq!(iter.peek_nth(1), None);\n    assert_eq!(iter.next(), Some(5));\n    assert_eq!(iter.next(), None);\n\n    assert_eq!(iter.peek_nth(0), None);\n    assert_eq!(iter.peek_nth(1), None);\n}\n\n#[test]\nfn test_peek_nth_peeking_next() {\n    use it::PeekingNext;\n    let nums = vec![1u8,2,3,4,5,6,7];\n    let mut iter = peek_nth(nums.iter().map(|&x| x));\n\n    assert_eq!(iter.peeking_next(|&x| x != 0), Some(1));\n    assert_eq!(iter.next(), Some(2));\n\n    assert_eq!(iter.peek_nth(0), Some(&3));\n    assert_eq!(iter.peek_nth(1), Some(&4));\n    assert_eq!(iter.peeking_next(|&x| x == 3), Some(3));\n    assert_eq!(iter.peek(), Some(&4));\n\n    assert_eq!(iter.peeking_next(|&x| x != 4), None);\n    assert_eq!(iter.peeking_next(|&x| x == 4), Some(4));\n    assert_eq!(iter.peek_nth(0), Some(&5));\n    assert_eq!(iter.peek_nth(1), Some(&6));\n\n    assert_eq!(iter.peeking_next(|&x| x != 5), None);\n    assert_eq!(iter.peek(), Some(&5));\n\n    assert_eq!(iter.peeking_next(|&x| x == 5), Some(5));\n    assert_eq!(iter.peeking_next(|&x| x == 6), Some(6));\n    assert_eq!(iter.peek_nth(0), Some(&7));\n    assert_eq!(iter.peek_nth(1), None);\n    assert_eq!(iter.next(), Some(7));\n    assert_eq!(iter.peek(), None);\n}\n\n#[test]\nfn pad_using() {\n    it::assert_equal((0..0).pad_using(1, |_| 1), 1..2);\n\n    let v: Vec<usize> = vec![0, 1, 2];\n    let r = v.into_iter().pad_using(5, |n| n);\n    it::assert_equal(r, vec![0, 1, 2, 3, 4]);\n\n    let v: Vec<usize> = vec![0, 1, 2];\n    let r = v.into_iter().pad_using(1, |_| panic!());\n    it::assert_equal(r, vec![0, 1, 2]);\n}\n\n#[test]\nfn group_by() {\n    for (ch1, sub) in &\"AABBCCC\".chars().group_by(|&x| x) {\n        for ch2 in sub {\n            assert_eq!(ch1, ch2);\n        }\n    }\n\n    for (ch1, sub) in &\"AAABBBCCCCDDDD\".chars().group_by(|&x| x) {\n        for ch2 in sub {\n            assert_eq!(ch1, ch2);\n            if ch1 == 'C' {\n                break;\n            }\n        }\n    }\n\n    let toupper = |ch: &char| ch.to_uppercase().nth(0).unwrap();\n\n    // try all possible orderings\n    for indices in permutohedron::Heap::new(&mut [0, 1, 2, 3]) {\n        let groups = \"AaaBbbccCcDDDD\".chars().group_by(&toupper);\n        let mut subs = groups.into_iter().collect_vec();\n\n        for &idx in &indices[..] {\n            let (key, text) = match idx {\n                 0 => ('A', \"Aaa\".chars()),\n                 1 => ('B', \"Bbb\".chars()),\n                 2 => ('C', \"ccCc\".chars()),\n                 3 => ('D', \"DDDD\".chars()),\n                 _ => unreachable!(),\n            };\n            assert_eq!(key, subs[idx].0);\n            it::assert_equal(&mut subs[idx].1, text);\n        }\n    }\n\n    let groups = \"AAABBBCCCCDDDD\".chars().group_by(|&x| x);\n    let mut subs = groups.into_iter().map(|(_, g)| g).collect_vec();\n\n    let sd = subs.pop().unwrap();\n    let sc = subs.pop().unwrap();\n    let sb = subs.pop().unwrap();\n    let sa = subs.pop().unwrap();\n    for (a, b, c, d) in multizip((sa, sb, sc, sd)) {\n        assert_eq!(a, 'A');\n        assert_eq!(b, 'B');\n        assert_eq!(c, 'C');\n        assert_eq!(d, 'D');\n    }\n\n    // check that the key closure is called exactly n times\n    {\n        let mut ntimes = 0;\n        let text = \"AABCCC\";\n        for (_, sub) in &text.chars().group_by(|&x| { ntimes += 1; x}) {\n            for _ in sub {\n            }\n        }\n        assert_eq!(ntimes, text.len());\n    }\n\n    {\n        let mut ntimes = 0;\n        let text = \"AABCCC\";\n        for _ in &text.chars().group_by(|&x| { ntimes += 1; x}) {\n        }\n        assert_eq!(ntimes, text.len());\n    }\n\n    {\n        let text = \"ABCCCDEEFGHIJJKK\";\n        let gr = text.chars().group_by(|&x| x);\n        it::assert_equal(gr.into_iter().flat_map(|(_, sub)| sub), text.chars());\n    }\n}\n\n#[test]\nfn group_by_lazy_2() {\n    let data = vec![0, 1];\n    let groups = data.iter().group_by(|k| *k);\n    let gs = groups.into_iter().collect_vec();\n    it::assert_equal(data.iter(), gs.into_iter().flat_map(|(_k, g)| g));\n\n    let data = vec![0, 1, 1, 0, 0];\n    let groups = data.iter().group_by(|k| *k);\n    let mut gs = groups.into_iter().collect_vec();\n    gs[1..].reverse();\n    it::assert_equal(&[0, 0, 0, 1, 1], gs.into_iter().flat_map(|(_, g)| g));\n\n    let grouper = data.iter().group_by(|k| *k);\n    let mut groups = Vec::new();\n    for (k, group) in &grouper {\n        if *k == 1 {\n            groups.push(group);\n        }\n    }\n    it::assert_equal(&mut groups[0], &[1, 1]);\n\n    let data = vec![0, 0, 0, 1, 1, 0, 0, 2, 2, 3, 3];\n    let grouper = data.iter().group_by(|k| *k);\n    let mut groups = Vec::new();\n    for (i, (_, group)) in grouper.into_iter().enumerate() {\n        if i < 2 {\n            groups.push(group);\n        } else if i < 4 {\n            for _ in group {\n            }\n        } else {\n            groups.push(group);\n        }\n    }\n    it::assert_equal(&mut groups[0], &[0, 0, 0]);\n    it::assert_equal(&mut groups[1], &[1, 1]);\n    it::assert_equal(&mut groups[2], &[3, 3]);\n\n    // use groups as chunks\n    let data = vec![0, 0, 0, 1, 1, 0, 0, 2, 2, 3, 3];\n    let mut i = 0;\n    let grouper = data.iter().group_by(move |_| { let k = i / 3; i += 1; k });\n    for (i, group) in &grouper {\n        match i {\n            0 => it::assert_equal(group, &[0, 0, 0]),\n            1 => it::assert_equal(group, &[1, 1, 0]),\n            2 => it::assert_equal(group, &[0, 2, 2]),\n            3 => it::assert_equal(group, &[3, 3]),\n            _ => unreachable!(),\n        }\n    }\n}\n\n#[test]\nfn group_by_lazy_3() {\n    // test consuming each group on the lap after it was produced\n    let data = vec![0, 0, 0, 1, 1, 0, 0, 1, 1, 2, 2];\n    let grouper = data.iter().group_by(|elt| *elt);\n    let mut last = None;\n    for (key, group) in &grouper {\n        if let Some(gr) = last.take() {\n            for elt in gr {\n                assert!(elt != key && i32::abs(elt - key) == 1);\n            }\n        }\n        last = Some(group);\n    }\n}\n\n#[test]\nfn chunks() {\n    let data = vec![0, 0, 0, 1, 1, 0, 0, 2, 2, 3, 3];\n    let grouper = data.iter().chunks(3);\n    for (i, chunk) in grouper.into_iter().enumerate() {\n        match i {\n            0 => it::assert_equal(chunk, &[0, 0, 0]),\n            1 => it::assert_equal(chunk, &[1, 1, 0]),\n            2 => it::assert_equal(chunk, &[0, 2, 2]),\n            3 => it::assert_equal(chunk, &[3, 3]),\n            _ => unreachable!(),\n        }\n    }\n}\n\n#[test]\nfn concat_empty() {\n    let data: Vec<Vec<()>> = Vec::new();\n    assert_eq!(data.into_iter().concat(), Vec::new())\n}\n\n#[test]\nfn concat_non_empty() {\n    let data = vec![vec![1,2,3], vec![4,5,6], vec![7,8,9]];\n    assert_eq!(data.into_iter().concat(), vec![1,2,3,4,5,6,7,8,9])\n}\n\n#[test]\nfn combinations() {\n    assert!((1..3).combinations(5).next().is_none());\n\n    let it = (1..3).combinations(2);\n    it::assert_equal(it, vec![\n        vec![1, 2],\n        ]);\n\n    let it = (1..5).combinations(2);\n    it::assert_equal(it, vec![\n        vec![1, 2],\n        vec![1, 3],\n        vec![1, 4],\n        vec![2, 3],\n        vec![2, 4],\n        vec![3, 4],\n        ]);\n\n    it::assert_equal((0..0).tuple_combinations::<(_, _)>(), <Vec<_>>::new());\n    it::assert_equal((0..1).tuple_combinations::<(_, _)>(), <Vec<_>>::new());\n    it::assert_equal((0..2).tuple_combinations::<(_, _)>(), vec![(0, 1)]);\n\n    it::assert_equal((0..0).combinations(2), <Vec<Vec<_>>>::new());\n    it::assert_equal((0..1).combinations(1), vec![vec![0]]);\n    it::assert_equal((0..2).combinations(1), vec![vec![0], vec![1]]);\n    it::assert_equal((0..2).combinations(2), vec![vec![0, 1]]);\n}\n\n#[test]\nfn combinations_of_too_short() {\n    for i in 1..10 {\n        assert!((0..0).combinations(i).next().is_none());\n        assert!((0..i - 1).combinations(i).next().is_none());\n    }\n}\n\n\n#[test]\nfn combinations_zero() {\n    it::assert_equal((1..3).combinations(0), vec![vec![]]);\n    it::assert_equal((0..0).combinations(0), vec![vec![]]);\n}\n\n#[test]\nfn permutations_zero() {\n    it::assert_equal((1..3).permutations(0), vec![vec![]]);\n    it::assert_equal((0..0).permutations(0), vec![vec![]]);\n}\n\n#[test]\nfn combinations_with_replacement() {\n    // Pool smaller than n\n    it::assert_equal((0..1).combinations_with_replacement(2), vec![vec![0, 0]]);\n    // Pool larger than n\n    it::assert_equal(\n        (0..3).combinations_with_replacement(2),\n        vec![\n            vec![0, 0],\n            vec![0, 1],\n            vec![0, 2],\n            vec![1, 1],\n            vec![1, 2],\n            vec![2, 2],\n        ],\n    );\n    // Zero size\n    it::assert_equal(\n        (0..3).combinations_with_replacement(0),\n        vec![vec![]],\n    );\n    // Zero size on empty pool\n    it::assert_equal(\n        (0..0).combinations_with_replacement(0),\n        vec![vec![]],\n    );\n    // Empty pool\n    it::assert_equal(\n        (0..0).combinations_with_replacement(2),\n        <Vec<Vec<_>>>::new(),\n    );\n}\n\n#[test]\nfn diff_mismatch() {\n    let a = vec![1, 2, 3, 4];\n    let b = vec![1.0, 5.0, 3.0, 4.0];\n    let b_map = b.into_iter().map(|f| f as i32);\n    let diff = it::diff_with(a.iter(), b_map, |a, b| *a == b);\n\n    assert!(match diff {\n        Some(it::Diff::FirstMismatch(1, _, from_diff)) =>\n            from_diff.collect::<Vec<_>>() == vec![5, 3, 4],\n        _ => false,\n    });\n}\n\n#[test]\nfn diff_longer() {\n    let a = vec![1, 2, 3, 4];\n    let b = vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0];\n    let b_map = b.into_iter().map(|f| f as i32);\n    let diff = it::diff_with(a.iter(), b_map, |a, b| *a == b);\n\n    assert!(match diff {\n        Some(it::Diff::Longer(_, remaining)) =>\n            remaining.collect::<Vec<_>>() == vec![5, 6],\n        _ => false,\n    });\n}\n\n#[test]\nfn diff_shorter() {\n    let a = vec![1, 2, 3, 4];\n    let b = vec![1.0, 2.0];\n    let b_map = b.into_iter().map(|f| f as i32);\n    let diff = it::diff_with(a.iter(), b_map, |a, b| *a == b);\n\n    assert!(match diff {\n        Some(it::Diff::Shorter(len, _)) => len == 2,\n        _ => false,\n    });\n}\n\n#[test]\nfn minmax() {\n    use std::cmp::Ordering;\n    use crate::it::MinMaxResult;\n\n    // A peculiar type: Equality compares both tuple items, but ordering only the\n    // first item.  This is so we can check the stability property easily.\n    #[derive(Clone, Debug, PartialEq, Eq)]\n    struct Val(u32, u32);\n\n    impl PartialOrd<Val> for Val {\n        fn partial_cmp(&self, other: &Val) -> Option<Ordering> {\n            self.0.partial_cmp(&other.0)\n        }\n    }\n\n    impl Ord for Val {\n        fn cmp(&self, other: &Val) -> Ordering {\n            self.0.cmp(&other.0)\n        }\n    }\n\n    assert_eq!(None::<Option<u32>>.iter().minmax(), MinMaxResult::NoElements);\n\n    assert_eq!(Some(1u32).iter().minmax(), MinMaxResult::OneElement(&1));\n\n    let data = vec![Val(0, 1), Val(2, 0), Val(0, 2), Val(1, 0), Val(2, 1)];\n\n    let minmax = data.iter().minmax();\n    assert_eq!(minmax, MinMaxResult::MinMax(&Val(0, 1), &Val(2, 1)));\n\n    let (min, max) = data.iter().minmax_by_key(|v| v.1).into_option().unwrap();\n    assert_eq!(min, &Val(2, 0));\n    assert_eq!(max, &Val(0, 2));\n\n    let (min, max) = data.iter().minmax_by(|x, y| x.1.cmp(&y.1)).into_option().unwrap();\n    assert_eq!(min, &Val(2, 0));\n    assert_eq!(max, &Val(0, 2));\n}\n\n#[test]\nfn format() {\n    let data = [0, 1, 2, 3];\n    let ans1 = \"0, 1, 2, 3\";\n    let ans2 = \"0--1--2--3\";\n\n    let t1 = format!(\"{}\", data.iter().format(\", \"));\n    assert_eq!(t1, ans1);\n    let t2 = format!(\"{:?}\", data.iter().format(\"--\"));\n    assert_eq!(t2, ans2);\n\n    let dataf = [1.1, 2.71828, -22.];\n    let t3 = format!(\"{:.2e}\", dataf.iter().format(\", \"));\n    assert_eq!(t3, \"1.10e0, 2.72e0, -2.20e1\");\n}\n\n#[test]\nfn while_some() {\n    let ns = (1..10).map(|x| if x % 5 != 0 { Some(x) } else { None })\n                    .while_some();\n    it::assert_equal(ns, vec![1, 2, 3, 4]);\n}\n\n#[allow(deprecated)]\n#[test]\nfn fold_while() {\n    let mut iterations = 0;\n    let vec = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    let sum = vec.into_iter().fold_while(0, |acc, item| {\n        iterations += 1;\n        let new_sum = acc.clone() + item;\n        if new_sum <= 20 {\n            FoldWhile::Continue(new_sum)\n        } else {\n            FoldWhile::Done(acc)\n        }\n    }).into_inner();\n    assert_eq!(iterations, 6);\n    assert_eq!(sum, 15);\n}\n\n#[test]\nfn tree_fold1() {\n    let x = [\n        \"\",\n        \"0\",\n        \"0 1 x\",\n        \"0 1 x 2 x\",\n        \"0 1 x 2 3 x x\",\n        \"0 1 x 2 3 x x 4 x\",\n        \"0 1 x 2 3 x x 4 5 x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 9 x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 9 x 10 x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 9 x 10 11 x x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 9 x 10 11 x x 12 x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 9 x 10 11 x x 12 13 x x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 9 x 10 11 x x 12 13 x 14 x x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 9 x 10 11 x x 12 13 x 14 15 x x x x\",\n    ];\n    for (i, &s) in x.iter().enumerate() {\n        let expected = if s == \"\" { None } else { Some(s.to_string()) };\n        let num_strings = (0..i).map(|x| x.to_string());\n        let actual = num_strings.tree_fold1(|a, b| format!(\"{} {} x\", a, b));\n        assert_eq!(actual, expected);\n    }\n}\n","traces":[{"line":15,"address":[4328928,4328992],"length":1,"stats":{"Line":3},"fn_name":"product3"},{"line":16,"address":[4329007,4328935],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[4329236,4329430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[4329361],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[4330135,4329846,4329955,4329733],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[4330140,4329999,4330320],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[4330184,4330325,4330613],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[4330618,4331248,4330369],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[4330659,4331117,4329901],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[4331548,4331408],"length":1,"stats":{"Line":3},"fn_name":"interleave_shortest"},{"line":33,"address":[4331415,4331563],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[4331581,4331666],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[4335983,4331674],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[4332106,4331879],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[4332454,4331992],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[4333044],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[4333124,4333191],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[4333199,4336117],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[4333631,4333404],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4333517,4333979],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[4334568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[4334600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[4334648],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[4334879,4334946,4334760],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[4335248,4334895],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[4335261],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[4335283],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[4335511,4335392,4335535],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[4336544],"length":1,"stats":{"Line":3},"fn_name":"unique_by"},{"line":59,"address":[4336600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4336734],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[4336794],"length":1,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[4692448,4692465],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":63,"address":[4337071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[4337131],"length":1,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[4337264],"length":1,"stats":{"Line":3},"fn_name":"unique"},{"line":69,"address":[4337271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[4337348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[4337392],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[4337524],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[4337714],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[4337758],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[4337899],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[4337921],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[4337943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[4338051],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[4338205],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[4338227],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[4338522,4338368],"length":1,"stats":{"Line":3},"fn_name":"intersperse"},{"line":86,"address":[4338396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[4338483,4338553],"length":1,"stats":{"Line":4},"fn_name":null},{"line":88,"address":[4338648],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[4338720,4338860],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[4339203],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[4339247],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[4339495,4339389,4339474],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[4339648,4339834],"length":1,"stats":{"Line":3},"fn_name":"dedup"},{"line":98,"address":[4339655],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[4339743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[4339798,4339849],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[4339929],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[4339984],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[4339995],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[4340103],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[4340191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[4340246],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[4340272,4340340],"length":1,"stats":{"Line":4},"fn_name":null},{"line":109,"address":[4340522,4340379],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[4341560,4340864],"length":1,"stats":{"Line":3},"fn_name":"dedup_by"},{"line":114,"address":[4340871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[4341271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[4341575,4341521],"length":1,"stats":{"Line":4},"fn_name":null},{"line":117,"address":[4341658],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[4341908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[4341958],"length":1,"stats":{"Line":3},"fn_name":null},{"line":121,"address":[4342066],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[4342466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[4342716],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[4342810,4342742],"length":1,"stats":{"Line":6},"fn_name":null},{"line":125,"address":[4342849,4342992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[4343328],"length":1,"stats":{"Line":3},"fn_name":"dedup_with_count"},{"line":130,"address":[4343363],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[4343427],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[4343687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[4343824],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[4343879],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[4343931],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[4344080],"length":1,"stats":{"Line":3},"fn_name":"dedup_by_with_count"},{"line":144,"address":[4344122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[4344536],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[4344796],"length":1,"stats":{"Line":3},"fn_name":null},{"line":149,"address":[4344933],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[4345183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[4345235],"length":1,"stats":{"Line":3},"fn_name":null},{"line":156,"address":[4345376,4345419],"length":1,"stats":{"Line":3},"fn_name":"all_equal"},{"line":157,"address":[4345487,4345383,4345434],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[4345458,4345517,4345570],"length":1,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[4345655,4345541,4345600],"length":1,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[4345741,4345685,4345626],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[4346331,4346158,4346415,4345716,4345771,4346269],"length":1,"stats":{"Line":7},"fn_name":null},{"line":162,"address":[4346228,4346174,4346393],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[4346496,4346613],"length":1,"stats":{"Line":3},"fn_name":"test_put_back_n"},{"line":168,"address":[4346503],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[4346638,4346583],"length":1,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[4346686],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[4346698],"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[4346715],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[4346729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[4346943,4346736],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[4347170,4347024],"length":1,"stats":{"Line":3},"fn_name":"tee"},{"line":179,"address":[4347031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[4347131,4347201],"length":1,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[4347539,4347319,4347380],"length":1,"stats":{"Line":2},"fn_name":null},{"line":182,"address":[4347884,4347515,4348043],"length":1,"stats":{"Line":2},"fn_name":null},{"line":183,"address":[4348547,4348019,4348388],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[4348892,4348523,4349051],"length":1,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[4349396,4349027,4349555],"length":1,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[4349900,4349531,4350059],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[4350563,4350035,4350404],"length":1,"stats":{"Line":2},"fn_name":null},{"line":188,"address":[4351067,4350539,4350908],"length":1,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[4351412,4351571,4351043],"length":1,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[4351547,4351916,4352075],"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[4352420,4352579,4352051],"length":1,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[4352924,4352555,4353083],"length":1,"stats":{"Line":2},"fn_name":null},{"line":193,"address":[4353059,4353428,4353594],"length":1,"stats":{"Line":2},"fn_name":null},{"line":195,"address":[4353568,4353948],"length":1,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[4355052,4354078,4354211],"length":1,"stats":{"Line":2},"fn_name":null},{"line":197,"address":[4354289,4355093],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[4354472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[4354716,4354617,4355186],"length":1,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[4355376,4355545],"length":1,"stats":{"Line":3},"fn_name":"test_rciter"},{"line":206,"address":[4355383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[4355506,4355576],"length":1,"stats":{"Line":2},"fn_name":null},{"line":209,"address":[4355642],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[4355876,4355689],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[4356398,4356221,4355852],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[4356348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[4356909,4356752,4356877],"length":1,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[4356899,4357379,4357255],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[4357849,4357369,4357725],"length":1,"stats":{"Line":2},"fn_name":null},{"line":216,"address":[4357839,4358195,4358344],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[4358651,4358293],"length":1,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[4358675],"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[4358858,4358882,4358739],"length":1,"stats":{"Line":2},"fn_name":null},{"line":226,"address":[4359456,4359562],"length":1,"stats":{"Line":3},"fn_name":"trait_pointers"},{"line":233,"address":[4693680],"length":1,"stats":{"Line":1},"fn_name":"next<i32,Iterator>"},{"line":235,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":239,"address":[4359585,4359463,4359560],"length":1,"stats":{"Line":3},"fn_name":null},{"line":240,"address":[4359859,4359659,4359616],"length":1,"stats":{"Line":2},"fn_name":null},{"line":244,"address":[4359786],"length":1,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[4360395,4360204,4359818],"length":1,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[4360331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[4360889,4360734,4360371],"length":1,"stats":{"Line":2},"fn_name":null},{"line":252,"address":[4360855,4361199,4361317],"length":1,"stats":{"Line":4},"fn_name":null},{"line":253,"address":[4361291],"length":1,"stats":{"Line":3},"fn_name":null},{"line":258,"address":[4361943,4361664],"length":1,"stats":{"Line":3},"fn_name":"merge_by"},{"line":259,"address":[4361671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[4361968],"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[4362209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[4362724,4362637],"length":1,"stats":{"Line":4},"fn_name":null},{"line":263,"address":[4362803],"length":1,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[4363072,4363139],"length":1,"stats":{"Line":3},"fn_name":"merge_by_btree"},{"line":269,"address":[4363079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[4363154],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[4363183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[4363217],"length":1,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[4363224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[4363261],"length":1,"stats":{"Line":1},"fn_name":null},{"line":275,"address":[4363290,4364012],"length":1,"stats":{"Line":3},"fn_name":null},{"line":276,"address":[4363474],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[4364067,4363768],"length":1,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[4364208],"length":1,"stats":{"Line":3},"fn_name":"kmerge"},{"line":283,"address":[4364212],"length":1,"stats":{"Line":3},"fn_name":null},{"line":285,"address":[4364249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[4364320],"length":1,"stats":{"Line":3},"fn_name":"kmerge_2"},{"line":291,"address":[4364327],"length":1,"stats":{"Line":3},"fn_name":null},{"line":293,"address":[4364418],"length":1,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[4364544,4364590],"length":1,"stats":{"Line":3},"fn_name":"kmerge_empty"},{"line":298,"address":[4364551],"length":1,"stats":{"Line":3},"fn_name":null},{"line":299,"address":[4364605],"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[4365104,4365150],"length":1,"stats":{"Line":3},"fn_name":"kmerge_size_hint"},{"line":304,"address":[4365111],"length":1,"stats":{"Line":3},"fn_name":null},{"line":305,"address":[4365165],"length":1,"stats":{"Line":1},"fn_name":null},{"line":309,"address":[4365648,4365694],"length":1,"stats":{"Line":3},"fn_name":"kmerge_empty_size_hint"},{"line":310,"address":[4365655],"length":1,"stats":{"Line":3},"fn_name":null},{"line":311,"address":[4365709],"length":1,"stats":{"Line":1},"fn_name":null},{"line":315,"address":[4366192,4366279],"length":1,"stats":{"Line":3},"fn_name":"join"},{"line":316,"address":[4366203],"length":1,"stats":{"Line":1},"fn_name":null},{"line":317,"address":[4366236],"length":1,"stats":{"Line":1},"fn_name":null},{"line":318,"address":[4366247],"length":1,"stats":{"Line":1},"fn_name":null},{"line":320,"address":[4366307,4366423],"length":1,"stats":{"Line":2},"fn_name":null},{"line":321,"address":[4366910],"length":1,"stats":{"Line":1},"fn_name":null},{"line":322,"address":[4367460],"length":1,"stats":{"Line":1},"fn_name":null},{"line":326,"address":[4368112,4368308],"length":1,"stats":{"Line":3},"fn_name":"sorted_by"},{"line":327,"address":[4368126],"length":1,"stats":{"Line":3},"fn_name":null},{"line":328,"address":[4694505],"length":1,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[4368595,4368323,4368210],"length":1,"stats":{"Line":1},"fn_name":null},{"line":332,"address":[4368372],"length":1,"stats":{"Line":3},"fn_name":null},{"line":333,"address":[4368618,4368421],"length":1,"stats":{"Line":1},"fn_name":null},{"line":337,"address":[4368688,4368884],"length":1,"stats":{"Line":3},"fn_name":"sorted_by_key"},{"line":338,"address":[4368702],"length":1,"stats":{"Line":3},"fn_name":null},{"line":339,"address":[4369171,4368899,4368786],"length":1,"stats":{"Line":1},"fn_name":null},{"line":341,"address":[4368948],"length":1,"stats":{"Line":3},"fn_name":null},{"line":342,"address":[4368997,4369194],"length":1,"stats":{"Line":1},"fn_name":null},{"line":346,"address":[4369264,4369337],"length":1,"stats":{"Line":3},"fn_name":"test_multipeek"},{"line":347,"address":[4369277],"length":1,"stats":{"Line":1},"fn_name":null},{"line":349,"address":[4369453,4369360],"length":1,"stats":{"Line":4},"fn_name":null},{"line":350,"address":[4369507],"length":1,"stats":{"Line":1},"fn_name":null},{"line":352,"address":[4370083],"length":1,"stats":{"Line":3},"fn_name":null},{"line":353,"address":[4370410,4370223,4370372],"length":1,"stats":{"Line":2},"fn_name":null},{"line":354,"address":[4370386,4370755,4370908],"length":1,"stats":{"Line":2},"fn_name":null},{"line":355,"address":[4371394,4370890,4371254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":356,"address":[4371886,4371376,4371740],"length":1,"stats":{"Line":2},"fn_name":null},{"line":357,"address":[4371862,4372384,4372231],"length":1,"stats":{"Line":2},"fn_name":null},{"line":358,"address":[4372730,4372870,4372366],"length":1,"stats":{"Line":2},"fn_name":null},{"line":359,"address":[4372852,4373356,4373216],"length":1,"stats":{"Line":2},"fn_name":null},{"line":360,"address":[4373338,4373702,4373842],"length":1,"stats":{"Line":2},"fn_name":null},{"line":361,"address":[4374188,4374334,4373824],"length":1,"stats":{"Line":2},"fn_name":null},{"line":362,"address":[4374679,4374838,4374310],"length":1,"stats":{"Line":2},"fn_name":null},{"line":363,"address":[4375183,4375336,4374814],"length":1,"stats":{"Line":2},"fn_name":null},{"line":364,"address":[4375682,4375822,4375318],"length":1,"stats":{"Line":2},"fn_name":null},{"line":365,"address":[4375804,4376314,4376168],"length":1,"stats":{"Line":2},"fn_name":null},{"line":366,"address":[4376659,4376290,4376818],"length":1,"stats":{"Line":2},"fn_name":null},{"line":367,"address":[4376794,4377163,4377307],"length":1,"stats":{"Line":2},"fn_name":null},{"line":368,"address":[4377740,4377292,4377614],"length":1,"stats":{"Line":2},"fn_name":null},{"line":373,"address":[4378128,4378210],"length":1,"stats":{"Line":3},"fn_name":"test_multipeek_reset"},{"line":374,"address":[4378135],"length":1,"stats":{"Line":1},"fn_name":null},{"line":376,"address":[4378179,4378225],"length":1,"stats":{"Line":2},"fn_name":null},{"line":377,"address":[4378262,4378411,4378449],"length":1,"stats":{"Line":2},"fn_name":null},{"line":378,"address":[4378425,4378947,4378794],"length":1,"stats":{"Line":2},"fn_name":null},{"line":379,"address":[4378929,4379293,4379433],"length":1,"stats":{"Line":2},"fn_name":null},{"line":380,"address":[4379415,4379779,4379911],"length":1,"stats":{"Line":2},"fn_name":null},{"line":381,"address":[4379901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":382,"address":[4380257,4380414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":383,"address":[4380720,4380396,4380856],"length":1,"stats":{"Line":2},"fn_name":null},{"line":387,"address":[4381200,4381281],"length":1,"stats":{"Line":3},"fn_name":"test_multipeek_peeking_next"},{"line":389,"address":[4381213],"length":1,"stats":{"Line":1},"fn_name":null},{"line":391,"address":[4381397,4381304],"length":1,"stats":{"Line":4},"fn_name":null},{"line":392,"address":[4381664,4381626,4381459],"length":1,"stats":{"Line":4},"fn_name":null},{"line":393,"address":[4381640,4382009,4382162],"length":1,"stats":{"Line":2},"fn_name":null},{"line":394,"address":[4382144,4382648,4382508],"length":1,"stats":{"Line":2},"fn_name":null},{"line":395,"address":[4382994,4382630,4383140],"length":1,"stats":{"Line":2},"fn_name":null},{"line":396,"address":[4383485,4383638,4383116],"length":1,"stats":{"Line":4},"fn_name":null},{"line":397,"address":[4383620,4384130,4383984],"length":1,"stats":{"Line":2},"fn_name":null},{"line":398,"address":[4384106,4384475,4384634],"length":1,"stats":{"Line":4},"fn_name":null},{"line":399,"address":[4385132,4384610,4384979],"length":1,"stats":{"Line":4},"fn_name":null},{"line":400,"address":[4385478,4385114,4385618],"length":1,"stats":{"Line":2},"fn_name":null},{"line":401,"address":[4385600,4385964,4386110],"length":1,"stats":{"Line":2},"fn_name":null},{"line":402,"address":[4386455,4386086,4386608],"length":1,"stats":{"Line":4},"fn_name":null},{"line":403,"address":[4386954,4387100,4386590],"length":1,"stats":{"Line":2},"fn_name":null},{"line":404,"address":[4387445,4387076,4387604],"length":1,"stats":{"Line":4},"fn_name":null},{"line":405,"address":[4388102,4387949,4387580],"length":1,"stats":{"Line":4},"fn_name":null},{"line":406,"address":[4388448,4388588,4388084],"length":1,"stats":{"Line":2},"fn_name":null},{"line":407,"address":[4388570,4389080,4388934],"length":1,"stats":{"Line":2},"fn_name":null},{"line":408,"address":[4389425,4389056,4389569],"length":1,"stats":{"Line":2},"fn_name":null},{"line":409,"address":[4389876,4390002,4389554],"length":1,"stats":{"Line":2},"fn_name":null},{"line":413,"address":[4390441,4390368],"length":1,"stats":{"Line":3},"fn_name":"test_peek_nth"},{"line":414,"address":[4390381],"length":1,"stats":{"Line":1},"fn_name":null},{"line":416,"address":[4390464,4390557],"length":1,"stats":{"Line":4},"fn_name":null},{"line":417,"address":[4390611],"length":1,"stats":{"Line":1},"fn_name":null},{"line":419,"address":[4391187],"length":1,"stats":{"Line":3},"fn_name":null},{"line":421,"address":[4391516,4391331,4391480],"length":1,"stats":{"Line":2},"fn_name":null},{"line":422,"address":[4391862,4391498,4392008],"length":1,"stats":{"Line":2},"fn_name":null},{"line":423,"address":[4392510,4391984,4392353],"length":1,"stats":{"Line":2},"fn_name":null},{"line":425,"address":[4392492,4393001,4392856],"length":1,"stats":{"Line":2},"fn_name":null},{"line":426,"address":[4393493,4393347,4392983],"length":1,"stats":{"Line":2},"fn_name":null},{"line":427,"address":[4393838,4393995,4393469],"length":1,"stats":{"Line":2},"fn_name":null},{"line":429,"address":[4393977,4394341,4394486],"length":1,"stats":{"Line":2},"fn_name":null},{"line":430,"address":[4394832,4394468,4394977],"length":1,"stats":{"Line":2},"fn_name":null},{"line":431,"address":[4395468,4394959,4395323],"length":1,"stats":{"Line":2},"fn_name":null},{"line":432,"address":[4395960,4395450,4395814],"length":1,"stats":{"Line":2},"fn_name":null},{"line":434,"address":[4396305,4395936,4396464],"length":1,"stats":{"Line":2},"fn_name":null},{"line":435,"address":[4396809,4396966,4396440],"length":1,"stats":{"Line":2},"fn_name":null},{"line":437,"address":[4396948,4397457,4397312],"length":1,"stats":{"Line":2},"fn_name":null},{"line":438,"address":[4397803,4397949,4397439],"length":1,"stats":{"Line":2},"fn_name":null},{"line":439,"address":[4397925,4398294,4398453],"length":1,"stats":{"Line":2},"fn_name":null},{"line":440,"address":[4398798,4398955,4398429],"length":1,"stats":{"Line":2},"fn_name":null},{"line":442,"address":[4399295,4398937,4399431],"length":1,"stats":{"Line":2},"fn_name":null},{"line":443,"address":[4399416,4399864,4399738],"length":1,"stats":{"Line":2},"fn_name":null},{"line":447,"address":[4400337,4400256],"length":1,"stats":{"Line":3},"fn_name":"test_peek_nth_peeking_next"},{"line":449,"address":[4400269],"length":1,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[4400360,4400453],"length":1,"stats":{"Line":4},"fn_name":null},{"line":452,"address":[4400515,4400720,4400682],"length":1,"stats":{"Line":4},"fn_name":null},{"line":453,"address":[4401222,4401065,4400696],"length":1,"stats":{"Line":2},"fn_name":null},{"line":455,"address":[4401204,4401568,4401713],"length":1,"stats":{"Line":2},"fn_name":null},{"line":456,"address":[4402059,4402205,4401695],"length":1,"stats":{"Line":2},"fn_name":null},{"line":457,"address":[4402550,4402703,4402181],"length":1,"stats":{"Line":4},"fn_name":null},{"line":458,"address":[4402685,4403195,4403049],"length":1,"stats":{"Line":2},"fn_name":null},{"line":460,"address":[4403699,4403540,4403171],"length":1,"stats":{"Line":4},"fn_name":null},{"line":461,"address":[4404044,4403675,4404201],"length":1,"stats":{"Line":4},"fn_name":null},{"line":462,"address":[4404547,4404183,4404692],"length":1,"stats":{"Line":2},"fn_name":null},{"line":463,"address":[4404674,4405184,4405038],"length":1,"stats":{"Line":2},"fn_name":null},{"line":465,"address":[4405682,4405160,4405529],"length":1,"stats":{"Line":4},"fn_name":null},{"line":466,"address":[4406174,4406028,4405664],"length":1,"stats":{"Line":2},"fn_name":null},{"line":468,"address":[4406150,4406519,4406678],"length":1,"stats":{"Line":4},"fn_name":null},{"line":469,"address":[4407023,4407180,4406654],"length":1,"stats":{"Line":4},"fn_name":null},{"line":470,"address":[4407671,4407526,4407162],"length":1,"stats":{"Line":2},"fn_name":null},{"line":471,"address":[4407653,4408163,4408017],"length":1,"stats":{"Line":2},"fn_name":null},{"line":472,"address":[4408502,4408139,4408646],"length":1,"stats":{"Line":2},"fn_name":null},{"line":473,"address":[4409079,4408953,4408631],"length":1,"stats":{"Line":2},"fn_name":null},{"line":477,"address":[4409504,4409440],"length":1,"stats":{"Line":3},"fn_name":"pad_using"},{"line":478,"address":[4409519,4409447],"length":1,"stats":{"Line":4},"fn_name":null},{"line":480,"address":[4409553],"length":1,"stats":{"Line":1},"fn_name":null},{"line":481,"address":[4409612],"length":1,"stats":{"Line":3},"fn_name":null},{"line":482,"address":[4410245,4409695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":484,"address":[4409893],"length":1,"stats":{"Line":1},"fn_name":null},{"line":485,"address":[4409955],"length":1,"stats":{"Line":1},"fn_name":null},{"line":486,"address":[4410271,4410050],"length":1,"stats":{"Line":1},"fn_name":null},{"line":490,"address":[4410467,4410352],"length":1,"stats":{"Line":3},"fn_name":"group_by"},{"line":491,"address":[4410887,4411542,4419825,4419945,4410372,4410482],"length":1,"stats":{"Line":7},"fn_name":null},{"line":492,"address":[4411052,4410905,4411191,4419879,4411000],"length":1,"stats":{"Line":4},"fn_name":null},{"line":493,"address":[4411196,4411096],"length":1,"stats":{"Line":1},"fn_name":null},{"line":497,"address":[4420001,4411554,4411991,4420121,4412677],"length":1,"stats":{"Line":6},"fn_name":null},{"line":498,"address":[4412009,4412104,4412659,4420055],"length":1,"stats":{"Line":4},"fn_name":null},{"line":499,"address":[4412321,4412187],"length":1,"stats":{"Line":1},"fn_name":null},{"line":500,"address":[4412302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":501,"address":[4412664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":506,"address":[4696222,4696208],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":509,"address":[4412682,4414580,4412915],"length":1,"stats":{"Line":2},"fn_name":null},{"line":510,"address":[4413180],"length":1,"stats":{"Line":1},"fn_name":null},{"line":511,"address":[4413254],"length":1,"stats":{"Line":1},"fn_name":null},{"line":513,"address":[4413518,4413408,4414562,4413323],"length":1,"stats":{"Line":3},"fn_name":null},{"line":514,"address":[4413897,4413814,4413731,4413977],"length":1,"stats":{"Line":4},"fn_name":null},{"line":515,"address":[4413653,4413571],"length":1,"stats":{"Line":2},"fn_name":null},{"line":516,"address":[4413736],"length":1,"stats":{"Line":1},"fn_name":null},{"line":517,"address":[4413819],"length":1,"stats":{"Line":1},"fn_name":null},{"line":518,"address":[4413899],"length":1,"stats":{"Line":1},"fn_name":null},{"line":521,"address":[4414186,4414023],"length":1,"stats":{"Line":1},"fn_name":null},{"line":522,"address":[4414532,4414152],"length":1,"stats":{"Line":2},"fn_name":null},{"line":526,"address":[4412881,4414585],"length":1,"stats":{"Line":4},"fn_name":null},{"line":527,"address":[4414622,4414694],"length":1,"stats":{"Line":4},"fn_name":null},{"line":529,"address":[4414717,4414762],"length":1,"stats":{"Line":2},"fn_name":null},{"line":530,"address":[4414786],"length":1,"stats":{"Line":1},"fn_name":null},{"line":531,"address":[4414840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":532,"address":[4414894],"length":1,"stats":{"Line":1},"fn_name":null},{"line":533,"address":[4414924,4415323,4416950,4415367],"length":1,"stats":{"Line":3},"fn_name":null},{"line":534,"address":[4415528,4415724],"length":1,"stats":{"Line":1},"fn_name":null},{"line":535,"address":[4416168,4415625],"length":1,"stats":{"Line":1},"fn_name":null},{"line":536,"address":[4416612,4416069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":537,"address":[4416955,4416513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":542,"address":[4417293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":543,"address":[4417305],"length":1,"stats":{"Line":1},"fn_name":null},{"line":544,"address":[4418007,4420288,4417813,4417332,4420394],"length":1,"stats":{"Line":6},"fn_name":null},{"line":545,"address":[4420328,4417823,4417967,4417918],"length":1,"stats":{"Line":3},"fn_name":null},{"line":548,"address":[4418012,4418240],"length":1,"stats":{"Line":1},"fn_name":null},{"line":552,"address":[4418159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":553,"address":[4418171],"length":1,"stats":{"Line":1},"fn_name":null},{"line":554,"address":[4420476,4418198,4418576,4419019,4419004],"length":1,"stats":{"Line":6},"fn_name":null},{"line":556,"address":[4419228,4419024],"length":1,"stats":{"Line":1},"fn_name":null},{"line":560,"address":[4419165],"length":1,"stats":{"Line":1},"fn_name":null},{"line":561,"address":[4419556,4419192],"length":1,"stats":{"Line":4},"fn_name":null},{"line":562,"address":[4419621,4419571,4420483],"length":1,"stats":{"Line":4},"fn_name":null},{"line":567,"address":[4421077,4420960],"length":1,"stats":{"Line":3},"fn_name":"group_by_lazy_2"},{"line":568,"address":[4420967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":569,"address":[4421201,4421100],"length":1,"stats":{"Line":4},"fn_name":null},{"line":570,"address":[4421216,4421269],"length":1,"stats":{"Line":2},"fn_name":null},{"line":571,"address":[4421285],"length":1,"stats":{"Line":3},"fn_name":null},{"line":573,"address":[4421506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":574,"address":[4421680,4421576],"length":1,"stats":{"Line":4},"fn_name":null},{"line":575,"address":[4421695,4421748],"length":1,"stats":{"Line":2},"fn_name":null},{"line":576,"address":[4421756],"length":1,"stats":{"Line":1},"fn_name":null},{"line":577,"address":[4421830],"length":1,"stats":{"Line":3},"fn_name":null},{"line":579,"address":[4421946],"length":1,"stats":{"Line":3},"fn_name":null},{"line":580,"address":[4422047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":581,"address":[4424978,4425088,4422103,4422062,4422563,4422144],"length":1,"stats":{"Line":5},"fn_name":null},{"line":582,"address":[4422531,4425058],"length":1,"stats":{"Line":2},"fn_name":null},{"line":583,"address":[4422468],"length":1,"stats":{"Line":1},"fn_name":null},{"line":586,"address":[4422568,4422453],"length":1,"stats":{"Line":2},"fn_name":null},{"line":588,"address":[4422600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":589,"address":[4422712,4422816],"length":1,"stats":{"Line":4},"fn_name":null},{"line":590,"address":[4422831],"length":1,"stats":{"Line":1},"fn_name":null},{"line":591,"address":[4422884,4422846,4423625,4425176,4422938,4425276],"length":1,"stats":{"Line":5},"fn_name":null},{"line":592,"address":[4425248,4423615,4423318],"length":1,"stats":{"Line":3},"fn_name":null},{"line":593,"address":[4423263],"length":1,"stats":{"Line":1},"fn_name":null},{"line":594,"address":[4423611,4423250],"length":1,"stats":{"Line":2},"fn_name":null},{"line":595,"address":[4423381,4423575,4423527],"length":1,"stats":{"Line":2},"fn_name":null},{"line":598,"address":[4423323],"length":1,"stats":{"Line":1},"fn_name":null},{"line":601,"address":[4423235,4423630],"length":1,"stats":{"Line":2},"fn_name":null},{"line":602,"address":[4423662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":603,"address":[4423706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":606,"address":[4423747],"length":1,"stats":{"Line":1},"fn_name":null},{"line":607,"address":[4423851],"length":1,"stats":{"Line":1},"fn_name":null},{"line":608,"address":[4423870,4423932],"length":1,"stats":{"Line":4},"fn_name":null},{"line":609,"address":[4424044,4425332,4424670,4423986,4425450],"length":1,"stats":{"Line":4},"fn_name":null},{"line":610,"address":[4424521,4424652,4424454,4424588],"length":1,"stats":{"Line":4},"fn_name":null},{"line":611,"address":[4424392,4425394],"length":1,"stats":{"Line":2},"fn_name":null},{"line":612,"address":[4424459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":613,"address":[4424526],"length":1,"stats":{"Line":1},"fn_name":null},{"line":614,"address":[4424590],"length":1,"stats":{"Line":1},"fn_name":null},{"line":621,"address":[4425872,4426017],"length":1,"stats":{"Line":3},"fn_name":"group_by_lazy_3"},{"line":623,"address":[4425879],"length":1,"stats":{"Line":1},"fn_name":null},{"line":624,"address":[4426037,4426108],"length":1,"stats":{"Line":4},"fn_name":null},{"line":625,"address":[4426115],"length":1,"stats":{"Line":1},"fn_name":null},{"line":626,"address":[4427091,4426202,4426132,4427189,4427581],"length":1,"stats":{"Line":4},"fn_name":null},{"line":627,"address":[4426521,4427171],"length":1,"stats":{"Line":2},"fn_name":null},{"line":628,"address":[4426743,4426597,4426794,4426969],"length":1,"stats":{"Line":3},"fn_name":null},{"line":629,"address":[4426860,4426974],"length":1,"stats":{"Line":1},"fn_name":null},{"line":632,"address":[4427464,4427290],"length":1,"stats":{"Line":1},"fn_name":null},{"line":637,"address":[4427760,4427897],"length":1,"stats":{"Line":3},"fn_name":"chunks"},{"line":638,"address":[4427767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":639,"address":[4427917,4427993],"length":1,"stats":{"Line":2},"fn_name":null},{"line":640,"address":[4428061,4428743,4428815,4428932,4428005],"length":1,"stats":{"Line":4},"fn_name":null},{"line":641,"address":[4428594,4428661,4428725,4428527],"length":1,"stats":{"Line":4},"fn_name":null},{"line":642,"address":[4428465,4428879],"length":1,"stats":{"Line":2},"fn_name":null},{"line":643,"address":[4428532],"length":1,"stats":{"Line":1},"fn_name":null},{"line":644,"address":[4428599],"length":1,"stats":{"Line":1},"fn_name":null},{"line":645,"address":[4428663],"length":1,"stats":{"Line":1},"fn_name":null},{"line":652,"address":[4429072,4429091],"length":1,"stats":{"Line":3},"fn_name":"concat_empty"},{"line":653,"address":[4429079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":654,"address":[4429210,4429106,4429326],"length":1,"stats":{"Line":2},"fn_name":null},{"line":658,"address":[4429696,4429778],"length":1,"stats":{"Line":3},"fn_name":"concat_non_empty"},{"line":659,"address":[4429793,4429713],"length":1,"stats":{"Line":1},"fn_name":null},{"line":660,"address":[4430062,4430269,4430371,4430395],"length":1,"stats":{"Line":3},"fn_name":null},{"line":664,"address":[4430948,4430816],"length":1,"stats":{"Line":3},"fn_name":"combinations"},{"line":665,"address":[4430823,4431118,4430973],"length":1,"stats":{"Line":2},"fn_name":null},{"line":667,"address":[4431062],"length":1,"stats":{"Line":1},"fn_name":null},{"line":668,"address":[4431337,4431148],"length":1,"stats":{"Line":1},"fn_name":null},{"line":669,"address":[4431277],"length":1,"stats":{"Line":1},"fn_name":null},{"line":672,"address":[4431450],"length":1,"stats":{"Line":1},"fn_name":null},{"line":673,"address":[4432023,4431759,4431825,4431957,4431693,4431891,4431504],"length":1,"stats":{"Line":1},"fn_name":null},{"line":674,"address":[4431633],"length":1,"stats":{"Line":1},"fn_name":null},{"line":675,"address":[4431718],"length":1,"stats":{"Line":1},"fn_name":null},{"line":676,"address":[4431784],"length":1,"stats":{"Line":1},"fn_name":null},{"line":677,"address":[4431850],"length":1,"stats":{"Line":1},"fn_name":null},{"line":678,"address":[4431916],"length":1,"stats":{"Line":1},"fn_name":null},{"line":679,"address":[4431982],"length":1,"stats":{"Line":1},"fn_name":null},{"line":682,"address":[4432259,4433735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":683,"address":[4432370,4433776],"length":1,"stats":{"Line":1},"fn_name":null},{"line":684,"address":[4432481,4433817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":686,"address":[4432675,4433843],"length":1,"stats":{"Line":1},"fn_name":null},{"line":687,"address":[4432791,4433884],"length":1,"stats":{"Line":1},"fn_name":null},{"line":688,"address":[4433910,4433053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":689,"address":[4433936,4433399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":693,"address":[4434469,4434416],"length":1,"stats":{"Line":3},"fn_name":"combinations_of_too_short"},{"line":694,"address":[4434489,4434550,4434989,4434423],"length":1,"stats":{"Line":3},"fn_name":null},{"line":695,"address":[4434582,4434777],"length":1,"stats":{"Line":1},"fn_name":null},{"line":696,"address":[4434747,4434807,4434994],"length":1,"stats":{"Line":2},"fn_name":null},{"line":702,"address":[4435207,4435136],"length":1,"stats":{"Line":3},"fn_name":"combinations_zero"},{"line":703,"address":[4435665,4435147,4435232],"length":1,"stats":{"Line":2},"fn_name":null},{"line":704,"address":[4435688,4435402],"length":1,"stats":{"Line":1},"fn_name":null},{"line":708,"address":[4435879,4435808],"length":1,"stats":{"Line":3},"fn_name":"permutations_zero"},{"line":709,"address":[4435819,4435904,4436355],"length":1,"stats":{"Line":2},"fn_name":null},{"line":710,"address":[4436378,4436092],"length":1,"stats":{"Line":1},"fn_name":null},{"line":714,"address":[4436496,4436592],"length":1,"stats":{"Line":3},"fn_name":"combinations_with_replacement"},{"line":716,"address":[4436617,4436503,4438188],"length":1,"stats":{"Line":2},"fn_name":null},{"line":719,"address":[4436815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":720,"address":[4437176,4436887,4437044,4436978,4437242,4437110,4437308],"length":1,"stats":{"Line":1},"fn_name":null},{"line":721,"address":[4436918],"length":1,"stats":{"Line":1},"fn_name":null},{"line":722,"address":[4437003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":723,"address":[4437069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":724,"address":[4437135],"length":1,"stats":{"Line":1},"fn_name":null},{"line":725,"address":[4437201],"length":1,"stats":{"Line":1},"fn_name":null},{"line":726,"address":[4437267],"length":1,"stats":{"Line":1},"fn_name":null},{"line":731,"address":[4437548],"length":1,"stats":{"Line":1},"fn_name":null},{"line":732,"address":[4437692,4437615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":736,"address":[4437809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":737,"address":[4437951,4437876],"length":1,"stats":{"Line":1},"fn_name":null},{"line":741,"address":[4438064],"length":1,"stats":{"Line":1},"fn_name":null},{"line":742,"address":[4438134],"length":1,"stats":{"Line":1},"fn_name":null},{"line":747,"address":[4438712,4438624],"length":1,"stats":{"Line":3},"fn_name":"diff_mismatch"},{"line":748,"address":[4438631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":749,"address":[4438737],"length":1,"stats":{"Line":1},"fn_name":null},{"line":750,"address":[4438829],"length":1,"stats":{"Line":3},"fn_name":null},{"line":751,"address":[4438911],"length":1,"stats":{"Line":3},"fn_name":null},{"line":753,"address":[4439403,4439209,4439465],"length":1,"stats":{"Line":1},"fn_name":null},{"line":754,"address":[4439034,4439214],"length":1,"stats":{"Line":2},"fn_name":null},{"line":755,"address":[4439252,4439130],"length":1,"stats":{"Line":2},"fn_name":null},{"line":756,"address":[4439201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":761,"address":[4439976,4439888],"length":1,"stats":{"Line":3},"fn_name":"diff_longer"},{"line":762,"address":[4439895],"length":1,"stats":{"Line":1},"fn_name":null},{"line":763,"address":[4440001],"length":1,"stats":{"Line":1},"fn_name":null},{"line":764,"address":[4440124],"length":1,"stats":{"Line":3},"fn_name":null},{"line":765,"address":[4440206],"length":1,"stats":{"Line":3},"fn_name":null},{"line":767,"address":[4440742,4440504,4440680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":768,"address":[4440329,4440509],"length":1,"stats":{"Line":2},"fn_name":null},{"line":769,"address":[4440536,4440425],"length":1,"stats":{"Line":2},"fn_name":null},{"line":770,"address":[4440496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":775,"address":[4441248,4441168],"length":1,"stats":{"Line":3},"fn_name":"diff_shorter"},{"line":776,"address":[4441175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":777,"address":[4441273],"length":1,"stats":{"Line":1},"fn_name":null},{"line":778,"address":[4441337],"length":1,"stats":{"Line":3},"fn_name":null},{"line":779,"address":[4441413],"length":1,"stats":{"Line":3},"fn_name":null},{"line":781,"address":[4441625,4441610,4441600,4441653],"length":1,"stats":{"Line":2},"fn_name":null},{"line":782,"address":[4441526,4441612],"length":1,"stats":{"Line":2},"fn_name":null},{"line":783,"address":[4441602],"length":1,"stats":{"Line":0},"fn_name":null},{"line":788,"address":[4441856,4441824],"length":1,"stats":{"Line":3},"fn_name":"minmax"},{"line":798,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":799,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":804,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":805,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":809,"address":[4441871,4442024,4441838],"length":1,"stats":{"Line":2},"fn_name":null},{"line":811,"address":[4442003,4442327,4442719],"length":1,"stats":{"Line":2},"fn_name":null},{"line":813,"address":[4442456],"length":1,"stats":{"Line":1},"fn_name":null},{"line":815,"address":[4443030,4443134],"length":1,"stats":{"Line":2},"fn_name":null},{"line":816,"address":[4443149,4443281],"length":1,"stats":{"Line":1},"fn_name":null},{"line":818,"address":[4443255,4443635],"length":1,"stats":{"Line":4},"fn_name":null},{"line":819,"address":[4443993,4443799],"length":1,"stats":{"Line":1},"fn_name":null},{"line":820,"address":[4444338,4444378,4443905],"length":1,"stats":{"Line":2},"fn_name":null},{"line":822,"address":[4444732,4444352],"length":1,"stats":{"Line":4},"fn_name":null},{"line":823,"address":[4445069,4444884],"length":1,"stats":{"Line":1},"fn_name":null},{"line":824,"address":[4444984,4445399,4445375],"length":1,"stats":{"Line":2},"fn_name":null},{"line":828,"address":[4446528,4446384],"length":1,"stats":{"Line":3},"fn_name":"format"},{"line":829,"address":[4446405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":830,"address":[4446449],"length":1,"stats":{"Line":1},"fn_name":null},{"line":831,"address":[4446469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":833,"address":[4446550,4446489],"length":1,"stats":{"Line":2},"fn_name":null},{"line":834,"address":[4446808,4446966],"length":1,"stats":{"Line":1},"fn_name":null},{"line":835,"address":[4446940,4447304],"length":1,"stats":{"Line":2},"fn_name":null},{"line":836,"address":[4447568,4447780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":838,"address":[4447697],"length":1,"stats":{"Line":1},"fn_name":null},{"line":839,"address":[4448094,4447754],"length":1,"stats":{"Line":2},"fn_name":null},{"line":840,"address":[4448357,4448487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":844,"address":[4448896],"length":1,"stats":{"Line":3},"fn_name":"while_some"},{"line":845,"address":[4448900],"length":1,"stats":{"Line":3},"fn_name":null},{"line":847,"address":[4448958],"length":1,"stats":{"Line":1},"fn_name":null},{"line":852,"address":[4449194,4449072],"length":1,"stats":{"Line":3},"fn_name":"fold_while"},{"line":853,"address":[4449079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":854,"address":[4449087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":855,"address":[4449209,4449329],"length":1,"stats":{"Line":3},"fn_name":null},{"line":856,"address":[4698353,4698489],"length":1,"stats":{"Line":1},"fn_name":null},{"line":857,"address":[4698519,4698549,4698393],"length":1,"stats":{"Line":1},"fn_name":null},{"line":858,"address":[4698458,4698435],"length":1,"stats":{"Line":2},"fn_name":null},{"line":859,"address":[4698460],"length":1,"stats":{"Line":1},"fn_name":null},{"line":861,"address":[4698442],"length":1,"stats":{"Line":1},"fn_name":null},{"line":863,"address":[4449309,4449348],"length":1,"stats":{"Line":2},"fn_name":null},{"line":864,"address":[4449365,4449555],"length":1,"stats":{"Line":1},"fn_name":null},{"line":865,"address":[4449842,4449459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":869,"address":[4450664,4450144],"length":1,"stats":{"Line":3},"fn_name":"tree_fold1"},{"line":870,"address":[4450283],"length":1,"stats":{"Line":1},"fn_name":null},{"line":889,"address":[4450843,4450679,4450634,4451671],"length":1,"stats":{"Line":3},"fn_name":null},{"line":890,"address":[4450963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":891,"address":[4451086],"length":1,"stats":{"Line":3},"fn_name":null},{"line":892,"address":[4451173],"length":1,"stats":{"Line":3},"fn_name":null},{"line":893,"address":[4451230,4451361],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":529,"coverable":534},{"path":["/","home","kms","itertools","tests","tuples.rs"],"content":"use itertools::Itertools;\n\n#[test]\nfn tuples() {\n    let v = [1, 2, 3, 4, 5];\n    let mut iter = v.iter().cloned().tuples();\n    assert_eq!(Some((1,)), iter.next());\n    assert_eq!(Some((2,)), iter.next());\n    assert_eq!(Some((3,)), iter.next());\n    assert_eq!(Some((4,)), iter.next());\n    assert_eq!(Some((5,)), iter.next());\n    assert_eq!(None, iter.next());\n    assert_eq!(None, iter.into_buffer().next());\n\n    let mut iter = v.iter().cloned().tuples();\n    assert_eq!(Some((1, 2)), iter.next());\n    assert_eq!(Some((3, 4)), iter.next());\n    assert_eq!(None, iter.next());\n    itertools::assert_equal(vec![5], iter.into_buffer());\n\n    let mut iter = v.iter().cloned().tuples();\n    assert_eq!(Some((1, 2, 3)), iter.next());\n    assert_eq!(None, iter.next());\n    itertools::assert_equal(vec![4, 5], iter.into_buffer());\n\n    let mut iter = v.iter().cloned().tuples();\n    assert_eq!(Some((1, 2, 3, 4)), iter.next());\n    assert_eq!(None, iter.next());\n    itertools::assert_equal(vec![5], iter.into_buffer());\n}\n\n#[test]\nfn tuple_windows() {\n    let v = [1, 2, 3, 4, 5];\n\n    let mut iter = v.iter().cloned().tuple_windows();\n    assert_eq!(Some((1,)), iter.next());\n    assert_eq!(Some((2,)), iter.next());\n    assert_eq!(Some((3,)), iter.next());\n\n    let mut iter = v.iter().cloned().tuple_windows();\n    assert_eq!(Some((1, 2)), iter.next());\n    assert_eq!(Some((2, 3)), iter.next());\n    assert_eq!(Some((3, 4)), iter.next());\n    assert_eq!(Some((4, 5)), iter.next());\n    assert_eq!(None, iter.next());\n\n    let mut iter = v.iter().cloned().tuple_windows();\n    assert_eq!(Some((1, 2, 3)), iter.next());\n    assert_eq!(Some((2, 3, 4)), iter.next());\n    assert_eq!(Some((3, 4, 5)), iter.next());\n    assert_eq!(None, iter.next());\n\n    let mut iter = v.iter().cloned().tuple_windows();\n    assert_eq!(Some((1, 2, 3, 4)), iter.next());\n    assert_eq!(Some((2, 3, 4, 5)), iter.next());\n    assert_eq!(None, iter.next());\n\n    let v = [1, 2, 3];\n    let mut iter = v.iter().cloned().tuple_windows::<(_, _, _, _)>();\n    assert_eq!(None, iter.next());\n}\n\n#[test]\nfn next_tuple() {\n    let v = [1, 2, 3, 4, 5];\n    let mut iter = v.iter();\n    assert_eq!(iter.next_tuple().map(|(&x, &y)| (x, y)), Some((1, 2)));\n    assert_eq!(iter.next_tuple().map(|(&x, &y)| (x, y)), Some((3, 4)));\n    assert_eq!(iter.next_tuple::<(_, _)>(), None);\n}\n\n#[test]\nfn collect_tuple() {\n    let v = [1, 2];\n    let iter = v.iter().cloned();\n    assert_eq!(iter.collect_tuple(), Some((1, 2)));\n\n    let v = [1];\n    let iter = v.iter().cloned();\n    assert_eq!(iter.collect_tuple::<(_, _)>(), None);\n\n    let v = [1, 2, 3];\n    let iter = v.iter().cloned();\n    assert_eq!(iter.collect_tuple::<(_, _)>(), None);\n}\n","traces":[{"line":4,"address":[4235533,4235376],"length":1,"stats":{"Line":3},"fn_name":"tuples"},{"line":5,"address":[4235383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":6,"address":[4235494,4235564],"length":1,"stats":{"Line":2},"fn_name":null},{"line":7,"address":[4235817,4235630],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[4236321,4235793,4236162],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9,"address":[4236666,4236297,4236825],"length":1,"stats":{"Line":2},"fn_name":null},{"line":10,"address":[4236801,4237170,4237329],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[4237674,4237305,4237833],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[4238371,4237809,4238178],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[4238305,4238717],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[4239275],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[4239531,4239392],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[4239869,4240001,4239521],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[4240493,4239991,4240339],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4243415,4240450,4240831],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[4240954],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[4241071,4241210],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[4241200,4241548,4241708],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[4242046,4243485,4241664],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[4242185],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[4242423,4242290],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[4242413,4242873,4242725],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[4243555,4242830,4243173],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[4243760],"length":1,"stats":{"Line":3},"fn_name":"tuple_windows"},{"line":34,"address":[4243767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[4243822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[4244088,4243933],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[4244527,4244398,4244064],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[4244976,4244503,4244837],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[4244934,4245295],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[4245496,4245345],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4245806,4245929,4245470],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[4245903,4246239,4246362],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[4246336,4246672,4246795],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[4246769,4247105,4247244],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[4247202,4247563],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[4247764,4247613],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[4248074,4247738,4248197],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[4248507,4248171,4248630],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[4249079,4248604,4248940],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[4249037,4249398],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[4249599,4249448],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[4250032,4249573,4249909],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[4250006,4250330,4250490],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[4250421],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4250454,4250779],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[4250817,4250944],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[4251232],"length":1,"stats":{"Line":3},"fn_name":"next_tuple"},{"line":66,"address":[4251239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[4251307],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[4251328,4251521],"length":1,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[4251490,4251800,4251958],"length":1,"stats":{"Line":4},"fn_name":null},{"line":70,"address":[4252343,4252244,4251932],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[4252624],"length":1,"stats":{"Line":3},"fn_name":"collect_tuple"},{"line":75,"address":[4252631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[4252653],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[4252727,4252913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[4252860],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[4252871,4253208],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[4253229,4253425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[4253356],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[4253389,4253714],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[4253870,4253735],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":63,"coverable":63},{"path":["/","home","kms","itertools","tests","zip.rs"],"content":"use itertools::Itertools;\nuse itertools::EitherOrBoth::{Both, Left, Right};\nuse itertools::free::zip_eq;\n\n#[test]\nfn zip_longest_fused() {\n    let a = [Some(1), None, Some(3), Some(4)];\n    let b = [1, 2, 3];\n\n    let unfused = a.iter().batching(|it| *it.next().unwrap())\n        .zip_longest(b.iter().cloned());\n    itertools::assert_equal(unfused,\n                       vec![Both(1, 1), Right(2), Right(3)]);\n}\n\n#[test]\nfn test_zip_longest_size_hint() {\n    let c = (1..10).cycle();\n    let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let v2 = &[10, 11, 12];\n\n    assert_eq!(c.zip_longest(v.iter()).size_hint(), (std::usize::MAX, None));\n\n    assert_eq!(v.iter().zip_longest(v2.iter()).size_hint(), (10, Some(10)));\n}\n\n#[test]\nfn test_double_ended_zip_longest() {\n    let xs = [1, 2, 3, 4, 5, 6];\n    let ys = [1, 2, 3, 7];\n    let a = xs.iter().map(|&x| x);\n    let b = ys.iter().map(|&x| x);\n    let mut it = a.zip_longest(b);\n    assert_eq!(it.next(), Some(Both(1, 1)));\n    assert_eq!(it.next(), Some(Both(2, 2)));\n    assert_eq!(it.next_back(), Some(Left(6)));\n    assert_eq!(it.next_back(), Some(Left(5)));\n    assert_eq!(it.next_back(), Some(Both(4, 7)));\n    assert_eq!(it.next(), Some(Both(3, 3)));\n    assert_eq!(it.next(), None);\n}\n\n\n#[should_panic]\n#[test]\nfn zip_eq_panic1()\n{\n    let a = [1, 2];\n    let b = [1, 2, 3];\n\n    zip_eq(&a, &b).count();\n}\n\n#[should_panic]\n#[test]\nfn zip_eq_panic2()\n{\n    let a: [i32; 0] = [];\n    let b = [1, 2, 3];\n\n    zip_eq(&a, &b).count();\n}\n\n","traces":[{"line":6,"address":[4214016,4214021],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":7,"address":[4232887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[4233007],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[4214062,4214048],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":11,"address":[4233093],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[4233399,4233180],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[4233212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[4233440],"length":1,"stats":{"Line":3},"fn_name":"test_zip_longest_size_hint"},{"line":18,"address":[4233447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[4233510],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[4233530],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[4233538,4233793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[4234263,4234072,4233757],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[4214149,4214144],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":29,"address":[4234551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[4234617],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[4214176,4214189],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":32,"address":[4214237,4214224],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":33,"address":[4234809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[4234854,4235005],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[4235438,4234979,4235315],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[4235412,4235748,4235871],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[4235845,4236304,4236181],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[4236278,4236614,4236731],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[4237017,4237134,4236705],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[4237108,4237420,4237519],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[4214272,4214277],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":48,"address":[4237812],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[4237828],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[4237852],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[4214309,4214304],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":59,"address":[4237892],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[4237916],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":33,"coverable":33}]}