{"files":[{"path":["/","usr","src","itertools","benches","bench1.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, Criterion};\nuse itertools::Itertools;\nuse itertools::free::cloned;\nuse itertools::iproduct;\n\nuse std::iter::repeat;\nuse std::cmp;\nuse std::ops::{Add, Range};\n\nmod extra;\n\nuse crate::extra::ZipSlices;\n\nfn slice_iter(c: &mut Criterion) {\n    let xs: Vec<_> = repeat(1i32).take(20).collect();\n\n    c.bench_function(\"slice iter\", move |b| {\n        b.iter(|| for elt in xs.iter() {\n            black_box(elt);\n        })\n    });\n}\n\nfn slice_iter_rev(c: &mut Criterion) {\n    let xs: Vec<_> = repeat(1i32).take(20).collect();\n\n    c.bench_function(\"slice iter rev\", move |b| {\n        b.iter(|| for elt in xs.iter().rev() {\n            black_box(elt);\n        })\n    });\n}\n\nfn zip_default_zip(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zip default zip\", move |b| {\n        b.iter(|| {\n            for (&x, &y) in xs.iter().zip(&ys) {\n                black_box(x);\n                black_box(y);\n            }\n        })\n    });\n}\n\nfn zipdot_i32_default_zip(c: &mut Criterion) {\n    let xs = vec![2; 1024];\n    let ys = vec![2; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot i32 default zip\", move |b| {\n        b.iter(|| {\n            let mut s = 0;\n            for (&x, &y) in xs.iter().zip(&ys) {\n                s += x * y;\n            }\n            s\n        })\n    });\n}\n\nfn zipdot_f32_default_zip(c: &mut Criterion) {\n    let xs = vec![2f32; 1024];\n    let ys = vec![2f32; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot f32 default zip\", move |b| {\n        b.iter(|| {\n            let mut s = 0.;\n            for (&x, &y) in xs.iter().zip(&ys) {\n                s += x * y;\n            }\n            s\n        })\n    });\n}\n\nfn zip_default_zip3(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n    let zs = vec![0; 766];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n    let zs = black_box(zs);\n\n    c.bench_function(\"zip default zip3\", move |b| {\n        b.iter(|| {\n            for ((&x, &y), &z) in xs.iter().zip(&ys).zip(&zs) {\n                black_box(x);\n                black_box(y);\n                black_box(z);\n            }\n        })\n    });\n}\n\nfn zip_slices_ziptuple(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n\n    c.bench_function(\"zip slices ziptuple\", move |b| {\n        b.iter(|| {\n            let xs = black_box(&xs);\n            let ys = black_box(&ys);\n            for (&x, &y) in itertools::multizip((xs, ys)) {\n                black_box(x);\n                black_box(y);\n            }\n        })\n    });\n}\n\nfn zipslices(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipslices\", move |b| {\n        b.iter(|| {\n            for (&x, &y) in ZipSlices::new(&xs, &ys) {\n                black_box(x);\n                black_box(y);\n            }\n        })\n    });\n}\n\nfn zipslices_mut(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n    let xs = black_box(xs);\n    let mut ys = black_box(ys);\n\n    c.bench_function(\"zipslices mut\", move |b| {\n        b.iter(|| {\n            for (&x, &mut y) in ZipSlices::from_slices(&xs[..], &mut ys[..]) {\n                black_box(x);\n                black_box(y);\n            }\n        })\n    });\n}\n\nfn zipdot_i32_zipslices(c: &mut Criterion) {\n    let xs = vec![2; 1024];\n    let ys = vec![2; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot i32 zipslices\", move |b| {\n        b.iter(|| {\n            let mut s = 0i32;\n            for (&x, &y) in ZipSlices::new(&xs, &ys) {\n                s += x * y;\n            }\n            s\n        })\n    });\n}\n\nfn zipdot_f32_zipslices(c: &mut Criterion) {\n    let xs = vec![2f32; 1024];\n    let ys = vec![2f32; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot f32 zipslices\", move |b| {\n        b.iter(|| {\n            let mut s = 0.;\n            for (&x, &y) in ZipSlices::new(&xs, &ys) {\n                s += x * y;\n            }\n            s\n        })\n    });\n}\n\nfn zip_checked_counted_loop(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zip checked counted loop\", move |b| {\n        b.iter(|| {\n            // Must slice to equal lengths, and then bounds checks are eliminated!\n            let len = cmp::min(xs.len(), ys.len());\n            let xs = &xs[..len];\n            let ys = &ys[..len];\n\n            for i in 0..len {\n                let x = xs[i];\n                let y = ys[i];\n                black_box(x);\n                black_box(y);\n            }\n        })\n    });\n}\n\nfn zipdot_i32_checked_counted_loop(c: &mut Criterion) {\n    let xs = vec![2; 1024];\n    let ys = vec![2; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot i32 checked counted loop\", move |b| {\n        b.iter(|| {\n            // Must slice to equal lengths, and then bounds checks are eliminated!\n            let len = cmp::min(xs.len(), ys.len());\n            let xs = &xs[..len];\n            let ys = &ys[..len];\n\n            let mut s = 0i32;\n\n            for i in 0..len {\n                s += xs[i] * ys[i];\n            }\n            s\n        })\n    });\n}\n\nfn zipdot_f32_checked_counted_loop(c: &mut Criterion) {\n    let xs = vec![2f32; 1024];\n    let ys = vec![2f32; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot f32 checked counted loop\", move |b| {\n        b.iter(|| {\n            // Must slice to equal lengths, and then bounds checks are eliminated!\n            let len = cmp::min(xs.len(), ys.len());\n            let xs = &xs[..len];\n            let ys = &ys[..len];\n\n            let mut s = 0.;\n\n            for i in 0..len {\n                s += xs[i] * ys[i];\n            }\n            s\n        })\n    });\n}\n\nfn zipdot_f32_checked_counted_unrolled_loop(c: &mut Criterion) {\n    let xs = vec![2f32; 1024];\n    let ys = vec![2f32; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot f32 checked counted unrolled loop\", move |b| {\n        b.iter(|| {\n            // Must slice to equal lengths, and then bounds checks are eliminated!\n            let len = cmp::min(xs.len(), ys.len());\n            let mut xs = &xs[..len];\n            let mut ys = &ys[..len];\n\n            let mut s = 0.;\n            let (mut p0, mut p1, mut p2, mut p3, mut p4, mut p5, mut p6, mut p7) =\n                (0., 0., 0., 0., 0., 0., 0., 0.);\n\n            // how to unroll and have bounds checks eliminated (by cristicbz)\n            // split sum into eight parts to enable vectorization (by bluss)\n            while xs.len() >= 8 {\n                p0 += xs[0] * ys[0];\n                p1 += xs[1] * ys[1];\n                p2 += xs[2] * ys[2];\n                p3 += xs[3] * ys[3];\n                p4 += xs[4] * ys[4];\n                p5 += xs[5] * ys[5];\n                p6 += xs[6] * ys[6];\n                p7 += xs[7] * ys[7];\n\n                xs = &xs[8..];\n                ys = &ys[8..];\n            }\n            s += p0 + p4;\n            s += p1 + p5;\n            s += p2 + p6;\n            s += p3 + p7;\n\n            for i in 0..xs.len() {\n                s += xs[i] * ys[i];\n            }\n            s\n        })\n    });\n}\n\nfn zip_unchecked_counted_loop(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zip unchecked counted loop\", move |b| {\n        b.iter(|| {\n            let len = cmp::min(xs.len(), ys.len());\n            for i in 0..len {\n                unsafe {\n                let x = *xs.get_unchecked(i);\n                let y = *ys.get_unchecked(i);\n                black_box(x);\n                black_box(y);\n                }\n            }\n        })\n    });\n}\n\nfn zipdot_i32_unchecked_counted_loop(c: &mut Criterion) {\n    let xs = vec![2; 1024];\n    let ys = vec![2; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot i32 unchecked counted loop\", move |b| {\n        b.iter(|| {\n            let len = cmp::min(xs.len(), ys.len());\n            let mut s = 0i32;\n            for i in 0..len {\n                unsafe {\n                let x = *xs.get_unchecked(i);\n                let y = *ys.get_unchecked(i);\n                s += x * y;\n                }\n            }\n            s\n        })\n    });\n}\n\nfn zipdot_f32_unchecked_counted_loop(c: &mut Criterion) {\n    let xs = vec![2.; 1024];\n    let ys = vec![2.; 768];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n\n    c.bench_function(\"zipdot f32 unchecked counted loop\", move |b| {\n        b.iter(|| {\n            let len = cmp::min(xs.len(), ys.len());\n            let mut s = 0f32;\n            for i in 0..len {\n                unsafe {\n                let x = *xs.get_unchecked(i);\n                let y = *ys.get_unchecked(i);\n                s += x * y;\n                }\n            }\n            s\n        })\n    });\n}\n\nfn zip_unchecked_counted_loop3(c: &mut Criterion) {\n    let xs = vec![0; 1024];\n    let ys = vec![0; 768];\n    let zs = vec![0; 766];\n    let xs = black_box(xs);\n    let ys = black_box(ys);\n    let zs = black_box(zs);\n\n    c.bench_function(\"zip unchecked counted loop3\", move |b| {\n        b.iter(|| {\n            let len = cmp::min(xs.len(), cmp::min(ys.len(), zs.len()));\n            for i in 0..len {\n                unsafe {\n                let x = *xs.get_unchecked(i);\n                let y = *ys.get_unchecked(i);\n                let z = *zs.get_unchecked(i);\n                black_box(x);\n                black_box(y);\n                black_box(z);\n                }\n            }\n        })\n    });\n}\n\nfn group_by_lazy_1(c: &mut Criterion) {\n    let mut data = vec![0; 1024];\n    for (index, elt) in data.iter_mut().enumerate() {\n        *elt = index / 10;\n    }\n\n    let data = black_box(data);\n\n    c.bench_function(\"group by lazy 1\", move |b| {\n        b.iter(|| {\n            for (_key, group) in &data.iter().group_by(|elt| **elt) {\n                for elt in group {\n                    black_box(elt);\n                }\n            }\n        })\n    });\n}\n\nfn group_by_lazy_2(c: &mut Criterion) {\n    let mut data = vec![0; 1024];\n    for (index, elt) in data.iter_mut().enumerate() {\n        *elt = index / 2;\n    }\n\n    let data = black_box(data);\n\n    c.bench_function(\"group by lazy 2\", move |b| {\n        b.iter(|| {\n            for (_key, group) in &data.iter().group_by(|elt| **elt) {\n                for elt in group {\n                    black_box(elt);\n                }\n            }\n        })\n    });\n}\n\nfn slice_chunks(c: &mut Criterion) {\n    let data = vec![0; 1024];\n\n    let data = black_box(data);\n    let sz = black_box(10);\n\n    c.bench_function(\"slice chunks\", move |b| {\n        b.iter(|| {\n            for group in data.chunks(sz) {\n                for elt in group {\n                    black_box(elt);\n                }\n            }\n        })\n    });\n}\n\nfn chunks_lazy_1(c: &mut Criterion) {\n    let data = vec![0; 1024];\n\n    let data = black_box(data);\n    let sz = black_box(10);\n\n    c.bench_function(\"chunks lazy 1\", move |b| {\n        b.iter(|| {\n            for group in &data.iter().chunks(sz) {\n                for elt in group {\n                    black_box(elt);\n                }\n            }\n        })\n    });\n}\n\nfn equal(c: &mut Criterion) {\n    let data = vec![7; 1024];\n    let l = data.len();\n    let alpha = black_box(&data[1..]);\n    let beta = black_box(&data[..l - 1]);\n\n    c.bench_function(\"equal\", move |b| {\n        b.iter(|| {\n            itertools::equal(alpha, beta)\n        })\n    });\n}\n\nfn merge_default(c: &mut Criterion) {\n    let mut data1 = vec![0; 1024];\n    let mut data2 = vec![0; 800];\n    let mut x = 0;\n    for (_, elt) in data1.iter_mut().enumerate() {\n        *elt = x;\n        x += 1;\n    }\n\n    let mut y = 0;\n    for (i, elt) in data2.iter_mut().enumerate() {\n        *elt += y;\n        if i % 3 == 0 {\n            y += 3;\n        } else {\n            y += 0;\n        }\n    }\n    let data1 = black_box(data1);\n    let data2 = black_box(data2);\n\n    c.bench_function(\"merge default\", move |b| {\n        b.iter(|| {\n            data1.iter().merge(&data2).count()\n        })\n    });\n}\n\nfn merge_by_cmp(c: &mut Criterion) {\n    let mut data1 = vec![0; 1024];\n    let mut data2 = vec![0; 800];\n    let mut x = 0;\n    for (_, elt) in data1.iter_mut().enumerate() {\n        *elt = x;\n        x += 1;\n    }\n\n    let mut y = 0;\n    for (i, elt) in data2.iter_mut().enumerate() {\n        *elt += y;\n        if i % 3 == 0 {\n            y += 3;\n        } else {\n            y += 0;\n        }\n    }\n    let data1 = black_box(data1);\n    let data2 = black_box(data2);\n\n    c.bench_function(\"merge by cmp\", move |b| {\n        b.iter(|| {\n            data1.iter().merge_by(&data2, PartialOrd::le).count()\n        })\n    });\n}\n\nfn merge_by_lt(c: &mut Criterion) {\n    let mut data1 = vec![0; 1024];\n    let mut data2 = vec![0; 800];\n    let mut x = 0;\n    for (_, elt) in data1.iter_mut().enumerate() {\n        *elt = x;\n        x += 1;\n    }\n\n    let mut y = 0;\n    for (i, elt) in data2.iter_mut().enumerate() {\n        *elt += y;\n        if i % 3 == 0 {\n            y += 3;\n        } else {\n            y += 0;\n        }\n    }\n    let data1 = black_box(data1);\n    let data2 = black_box(data2);\n\n    c.bench_function(\"merge by lt\", move |b| {\n        b.iter(|| {\n            data1.iter().merge_by(&data2, |a, b| a <= b).count()\n        })\n    });\n}\n\nfn kmerge_default(c: &mut Criterion) {\n    let mut data1 = vec![0; 1024];\n    let mut data2 = vec![0; 800];\n    let mut x = 0;\n    for (_, elt) in data1.iter_mut().enumerate() {\n        *elt = x;\n        x += 1;\n    }\n\n    let mut y = 0;\n    for (i, elt) in data2.iter_mut().enumerate() {\n        *elt += y;\n        if i % 3 == 0 {\n            y += 3;\n        } else {\n            y += 0;\n        }\n    }\n    let data1 = black_box(data1);\n    let data2 = black_box(data2);\n    let its = &[data1.iter(), data2.iter()];\n\n    c.bench_function(\"kmerge default\", move |b| {\n        b.iter(|| {\n            its.iter().cloned().kmerge().count()\n        })\n    });\n}\n\nfn kmerge_tenway(c: &mut Criterion) {\n    let mut data = vec![0; 10240];\n\n    let mut state = 1729u16;\n    fn rng(state: &mut u16) -> u16 {\n        let new = state.wrapping_mul(31421) + 6927;\n        *state = new;\n        new\n    }\n\n    for elt in &mut data {\n        *elt = rng(&mut state);\n    }\n\n    let mut chunks = Vec::new();\n    let mut rest = &mut data[..];\n    while rest.len() > 0 {\n        let chunk_len = 1 + rng(&mut state) % 512;\n        let chunk_len = cmp::min(rest.len(), chunk_len as usize);\n        let (fst, tail) = {rest}.split_at_mut(chunk_len);\n        fst.sort();\n        chunks.push(fst.iter().cloned());\n        rest = tail;\n    }\n\n    // println!(\"Chunk lengths: {}\", chunks.iter().format_with(\", \", |elt, f| f(&elt.len())));\n\n    c.bench_function(\"kmerge tenway\", move |b| {\n        b.iter(|| {\n            chunks.iter().cloned().kmerge().count()\n        })\n    });\n}\n\nfn fast_integer_sum<I>(iter: I) -> I::Item\n    where I: IntoIterator,\n          I::Item: Default + Add<Output=I::Item>\n{\n    iter.into_iter().fold(<_>::default(), |x, y| x + y)\n}\n\nfn step_vec_2(c: &mut Criterion) {\n    let v = vec![0; 1024];\n\n    c.bench_function(\"step vec 2\", move |b| {\n        b.iter(|| {\n            fast_integer_sum(cloned(v.iter().step_by(2)))\n        })\n    });\n}\n\nfn step_vec_10(c: &mut Criterion) {\n    let v = vec![0; 1024];\n\n    c.bench_function(\"step vec 10\", move |b| {\n        b.iter(|| {\n            fast_integer_sum(cloned(v.iter().step_by(10)))\n        })\n    });\n}\n\nfn step_range_2(c: &mut Criterion) {\n    let v = black_box(0..1024);\n\n    c.bench_function(\"step range 2\", move |b| {\n        b.iter(|| {\n            fast_integer_sum(v.clone().step_by(2))\n        })\n    });\n}\n\nfn step_range_10(c: &mut Criterion) {\n    let v = black_box(0..1024);\n\n    c.bench_function(\"step range 10\", move |b| {\n        b.iter(|| {\n            fast_integer_sum(v.clone().step_by(10))\n        })\n    });\n}\n\nfn cartesian_product_iterator(c: &mut Criterion) {\n    let xs = vec![0; 16];\n\n    c.bench_function(\"cartesian product iterator\", move |b| {\n        b.iter(|| {\n            let mut sum = 0;\n            for (&x, &y, &z) in iproduct!(&xs, &xs, &xs) {\n                sum += x;\n                sum += y;\n                sum += z;\n            }\n            sum\n        })\n    });\n}\n\nfn cartesian_product_fold(c: &mut Criterion) {\n    let xs = vec![0; 16];\n\n    c.bench_function(\"cartesian product fold\", move |b| {\n        b.iter(|| {\n            let mut sum = 0;\n            iproduct!(&xs, &xs, &xs).fold((), |(), (&x, &y, &z)| {\n                sum += x;\n                sum += y;\n                sum += z;\n            });\n            sum\n        })\n    });\n}\n\nfn multi_cartesian_product_iterator(c: &mut Criterion) {\n    let xs = [vec![0; 16], vec![0; 16], vec![0; 16]];\n\n    c.bench_function(\"multi cartesian product iterator\", move |b| {\n        b.iter(|| {\n            let mut sum = 0;\n            for x in xs.iter().multi_cartesian_product() {\n                sum += x[0];\n                sum += x[1];\n                sum += x[2];\n            }\n            sum\n        })\n    });\n}\n\nfn multi_cartesian_product_fold(c: &mut Criterion) {\n    let xs = [vec![0; 16], vec![0; 16], vec![0; 16]];\n\n    c.bench_function(\"multi cartesian product fold\", move |b| {\n        b.iter(|| {\n            let mut sum = 0;\n            xs.iter().multi_cartesian_product().fold((), |(), x| {\n                sum += x[0];\n                sum += x[1];\n                sum += x[2];\n            });\n            sum\n        })\n    });\n}\n\nfn cartesian_product_nested_for(c: &mut Criterion) {\n    let xs = vec![0; 16];\n\n    c.bench_function(\"cartesian product nested for\", move |b| {\n        b.iter(|| {\n            let mut sum = 0;\n            for &x in &xs {\n                for &y in &xs {\n                    for &z in &xs {\n                        sum += x;\n                        sum += y;\n                        sum += z;\n                    }\n                }\n            }\n            sum\n        })\n    });\n}\n\nfn all_equal(c: &mut Criterion) {\n    let mut xs = vec![0; 5_000_000];\n    xs.extend(vec![1; 5_000_000]);\n\n    c.bench_function(\"all equal\", move |b| {\n        b.iter(|| xs.iter().all_equal())\n    });\n}\n\nfn all_equal_for(c: &mut Criterion) {\n    let mut xs = vec![0; 5_000_000];\n    xs.extend(vec![1; 5_000_000]);\n\n    c.bench_function(\"all equal for\", move |b| {\n        b.iter(|| {\n            for &x in &xs {\n                if x != xs[0] {\n                    return false;\n                }\n            }\n            true\n        })\n    });\n}\n\nfn all_equal_default(c: &mut Criterion) {\n    let mut xs = vec![0; 5_000_000];\n    xs.extend(vec![1; 5_000_000]);\n\n    c.bench_function(\"all equal default\", move |b| {\n        b.iter(|| xs.iter().dedup().nth(1).is_none())\n    });\n}\n\nconst PERM_COUNT: usize = 6;\n\nfn permutations_iter(c: &mut Criterion) {\n    struct NewIterator(Range<usize>);\n\n    impl Iterator for NewIterator {\n        type Item = usize;\n\n        fn next(&mut self) -> Option<Self::Item> {\n            self.0.next()\n        }\n    }\n\n    c.bench_function(\"permutations iter\", move |b| {\n        b.iter(|| {\n            for _ in NewIterator(0..PERM_COUNT).permutations(PERM_COUNT) {\n\n            }\n        })\n    });\n}\n\nfn permutations_range(c: &mut Criterion) {\n    c.bench_function(\"permutations range\", move |b| {\n        b.iter(|| {\n            for _ in (0..PERM_COUNT).permutations(PERM_COUNT) {\n\n            }\n        })\n    });\n}\n\nfn permutations_slice(c: &mut Criterion) {\n    let v = (0..PERM_COUNT).collect_vec();\n\n    c.bench_function(\"permutations slice\", move |b| {\n        b.iter(|| {\n            for _ in v.as_slice().iter().permutations(PERM_COUNT) {\n\n            }\n        })\n    });\n}\n\ncriterion_group!(\n    benches,\n    slice_iter,\n    slice_iter_rev,\n    zip_default_zip,\n    zipdot_i32_default_zip,\n    zipdot_f32_default_zip,\n    zip_default_zip3,\n    zip_slices_ziptuple,\n    zipslices,\n    zipslices_mut,\n    zipdot_i32_zipslices,\n    zipdot_f32_zipslices,\n    zip_checked_counted_loop,\n    zipdot_i32_checked_counted_loop,\n    zipdot_f32_checked_counted_loop,\n    zipdot_f32_checked_counted_unrolled_loop,\n    zip_unchecked_counted_loop,\n    zipdot_i32_unchecked_counted_loop,\n    zipdot_f32_unchecked_counted_loop,\n    zip_unchecked_counted_loop3,\n    group_by_lazy_1,\n    group_by_lazy_2,\n    slice_chunks,\n    chunks_lazy_1,\n    equal,\n    merge_default,\n    merge_by_cmp,\n    merge_by_lt,\n    kmerge_default,\n    kmerge_tenway,\n    step_vec_2,\n    step_vec_10,\n    step_range_2,\n    step_range_10,\n    cartesian_product_iterator,\n    cartesian_product_fold,\n    multi_cartesian_product_iterator,\n    multi_cartesian_product_fold,\n    cartesian_product_nested_for,\n    all_equal,\n    all_equal_for,\n    all_equal_default,\n    permutations_iter,\n    permutations_range,\n    permutations_slice,\n);\ncriterion_main!(benches);\n","traces":[{"line":794,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":795,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","usr","src","itertools","benches","extra","zipslices.rs"],"content":"use std::cmp;\n\n// Note: There are different ways to implement ZipSlices.\n// This version performed the best in benchmarks.\n//\n// I also implemented a version with three pointes (tptr, tend, uptr),\n// that mimiced slice::Iter and only checked bounds by using tptr == tend,\n// but that was inferior to this solution.\n\n/// An iterator which iterates two slices simultaneously.\n///\n/// `ZipSlices` acts like a double-ended `.zip()` iterator.\n///\n/// It was intended to be more efficient than `.zip()`, and it was, then\n/// rustc changed how it optimizes so it can not promise improved performance\n/// at this time.\n///\n/// Note that elements past the end of the shortest of the two slices are ignored.\n///\n/// Iterator element type for `ZipSlices<T, U>` is `(T::Item, U::Item)`. For example,\n/// for a `ZipSlices<&'a [A], &'b mut [B]>`, the element type is `(&'a A, &'b mut B)`.\n#[derive(Clone)]\npub struct ZipSlices<T, U> {\n    t: T,\n    u: U,\n    len: usize,\n    index: usize,\n}\n\nimpl<'a, 'b, A, B> ZipSlices<&'a [A], &'b [B]> {\n    /// Create a new `ZipSlices` from slices `a` and `b`.\n    ///\n    /// Act like a double-ended `.zip()` iterator, but more efficiently.\n    ///\n    /// Note that elements past the end of the shortest of the two slices are ignored.\n    #[inline(always)]\n    pub fn new(a: &'a [A], b: &'b [B]) -> Self {\n        let minl = cmp::min(a.len(), b.len());\n        ZipSlices {\n            t: a,\n            u: b,\n            len: minl,\n            index: 0,\n        }\n    }\n}\n\nimpl<T, U> ZipSlices<T, U>\n    where T: Slice,\n          U: Slice\n{\n    /// Create a new `ZipSlices` from slices `a` and `b`.\n    ///\n    /// Act like a double-ended `.zip()` iterator, but more efficiently.\n    ///\n    /// Note that elements past the end of the shortest of the two slices are ignored.\n    #[inline(always)]\n    pub fn from_slices(a: T, b: U) -> Self {\n        let minl = cmp::min(a.len(), b.len());\n        ZipSlices {\n            t: a,\n            u: b,\n            len: minl,\n            index: 0,\n        }\n    }\n}\n\nimpl<T, U> Iterator for ZipSlices<T, U>\n    where T: Slice,\n          U: Slice\n{\n    type Item = (T::Item, U::Item);\n\n    #[inline(always)]\n    fn next(&mut self) -> Option<Self::Item> {\n        unsafe {\n            if self.index >= self.len {\n                None\n            } else {\n                let i = self.index;\n                self.index += 1;\n                Some((\n                    self.t.get_unchecked(i),\n                    self.u.get_unchecked(i)))\n            }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let len = self.len - self.index;\n        (len, Some(len))\n    }\n}\n\nimpl<T, U> DoubleEndedIterator for ZipSlices<T, U>\n    where T: Slice,\n          U: Slice\n{\n    #[inline(always)]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        unsafe {\n            if self.index >= self.len {\n                None\n            } else {\n                self.len -= 1;\n                let i = self.len;\n                Some((\n                    self.t.get_unchecked(i),\n                    self.u.get_unchecked(i)))\n            }\n        }\n    }\n}\n\nimpl<T, U> ExactSizeIterator for ZipSlices<T, U>\n    where T: Slice,\n          U: Slice\n{}\n\nunsafe impl<T, U> Slice for ZipSlices<T, U>\n    where T: Slice,\n          U: Slice\n{\n    type Item = (T::Item, U::Item);\n\n    fn len(&self) -> usize {\n        self.len - self.index\n    }\n\n    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n        (self.t.get_unchecked(i),\n         self.u.get_unchecked(i))\n    }\n}\n\n/// A helper trait to let `ZipSlices` accept both `&[T]` and `&mut [T]`.\n///\n/// Unsafe trait because:\n///\n/// - Implementors must guarantee that `get_unchecked` is valid for all indices `0..len()`.\npub unsafe trait Slice {\n    /// The type of a reference to the slice's elements\n    type Item;\n    #[doc(hidden)]\n    fn len(&self) -> usize;\n    #[doc(hidden)]\n    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item;\n}\n\nunsafe impl<'a, T> Slice for &'a [T] {\n    type Item = &'a T;\n    #[inline(always)]\n    fn len(&self) -> usize { (**self).len() }\n    #[inline(always)]\n    unsafe fn get_unchecked(&mut self, i: usize) -> &'a T {\n        debug_assert!(i < self.len());\n        (**self).get_unchecked(i)\n    }\n}\n\nunsafe impl<'a, T> Slice for &'a mut [T] {\n    type Item = &'a mut T;\n    #[inline(always)]\n    fn len(&self) -> usize { (**self).len() }\n    #[inline(always)]\n    unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut T {\n        debug_assert!(i < self.len());\n        // override the lifetime constraints of &mut &'a mut [T]\n        (*(*self as *mut [T])).get_unchecked_mut(i)\n    }\n}\n\n#[test]\nfn zipslices() {\n\n    let xs = [1, 2, 3, 4, 5, 6];\n    let ys = [1, 2, 3, 7];\n    ::itertools::assert_equal(ZipSlices::new(&xs, &ys), xs.iter().zip(&ys));\n\n    let xs = [1, 2, 3, 4, 5, 6];\n    let mut ys = [0; 6];\n    for (x, y) in ZipSlices::from_slices(&xs[..], &mut ys[..]) {\n        *y = *x;\n    }\n    ::itertools::assert_equal(&xs, &ys);\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":34},{"path":["/","usr","src","itertools","benches","fold_specialization.rs"],"content":"use criterion::{criterion_group, criterion_main, Criterion};\nuse itertools::Itertools;\n\nstruct Unspecialized<I>(I);\n\nimpl<I> Iterator for Unspecialized<I>\nwhere I: Iterator\n{\n    type Item = I::Item;\n\n    #[inline(always)]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.0.next()\n    }\n\n    #[inline(always)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.0.size_hint()\n    }\n}\n\nmod specialization {\n    use super::*;\n\n    pub mod intersperse {\n        use super::*;\n\n        pub fn external(c: &mut Criterion)\n        {\n            let arr = [1; 1024];\n\n            c.bench_function(\"external\", move |b| {\n                b.iter(|| {\n                    let mut sum = 0;\n                    for &x in arr.iter().intersperse(&0) {\n                        sum += x;\n                    }\n                    sum\n                })\n            });\n        }\n\n        pub fn internal_specialized(c: &mut Criterion)\n        {\n            let arr = [1; 1024];\n\n            c.bench_function(\"internal specialized\", move |b| {\n                b.iter(|| {\n                    arr.iter().intersperse(&0).fold(0, |acc, x| acc + x)\n                })\n            });\n        }\n\n        pub fn internal_unspecialized(c: &mut Criterion)\n        {\n            let arr = [1; 1024];\n\n            c.bench_function(\"internal unspecialized\", move |b| {\n                b.iter(|| {\n                    Unspecialized(arr.iter().intersperse(&0)).fold(0, |acc, x| acc + x)\n                })\n            });\n        }\n    }\n}\n\ncriterion_group!(\n    benches,\n    specialization::intersperse::external,\n    specialization::intersperse::internal_specialized,\n    specialization::intersperse::internal_unspecialized,\n);\ncriterion_main!(benches);\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","usr","src","itertools","benches","tree_fold1.rs"],"content":"use criterion::{criterion_group, criterion_main, Criterion};\nuse itertools::{Itertools, cloned};\n\ntrait IterEx : Iterator {\n    // Another efficient implementation against which to compare,\n    // but needs `std` so is less desirable.\n    fn tree_fold1_vec<F>(self, mut f: F) -> Option<Self::Item>\n        where F: FnMut(Self::Item, Self::Item) -> Self::Item,\n              Self: Sized,\n    {\n        let hint = self.size_hint().0;\n        let cap = std::mem::size_of::<usize>() * 8 - hint.leading_zeros() as usize;\n        let mut stack = Vec::with_capacity(cap);\n        self.enumerate().for_each(|(mut i, mut x)| {\n            while (i & 1) != 0 {\n                x = f(stack.pop().unwrap(), x);\n                i >>= 1;\n            }\n            stack.push(x);\n        });\n        stack.into_iter().fold1(f)\n    }\n}\nimpl<T:Iterator> IterEx for T {}\n\nmacro_rules! def_benchs {\n    ($N:expr,\n     $FUN:ident,\n     $BENCH_NAME:ident,\n     ) => (\n        mod $BENCH_NAME {\n            use super::*;\n\n            pub fn sum(c: &mut Criterion) {\n                let v: Vec<u32> = (0.. $N).collect();\n\n                c.bench_function(&(stringify!($BENCH_NAME).replace('_', \" \") + \" sum\"), move |b| {\n                    b.iter(|| {\n                        cloned(&v).$FUN(|x, y| x + y)\n                    })\n                });\n            }\n\n            pub fn complex_iter(c: &mut Criterion) {\n                let u = (3..).take($N / 2);\n                let v = (5..).take($N / 2);\n                let it = u.chain(v);\n\n                c.bench_function(&(stringify!($BENCH_NAME).replace('_', \" \") + \" complex iter\"), move |b| {\n                    b.iter(|| {\n                        it.clone().map(|x| x as f32).$FUN(f32::atan2)\n                    })\n                });\n            }\n\n            pub fn string_format(c: &mut Criterion) {\n                // This goes quadratic with linear `fold1`, so use a smaller\n                // size to not waste too much time in travis.  The allocations\n                // in here are so expensive anyway that it'll still take\n                // way longer per iteration than the other two benchmarks.\n                let v: Vec<u32> = (0.. ($N/4)).collect();\n\n                c.bench_function(&(stringify!($BENCH_NAME).replace('_', \" \") + \" string format\"), move |b| {\n                    b.iter(|| {\n                        cloned(&v).map(|x| x.to_string()).$FUN(|x, y| format!(\"{} + {}\", x, y))\n                    })\n                });\n            }\n        }\n\n        criterion_group!(\n            $BENCH_NAME,\n            $BENCH_NAME::sum,\n            $BENCH_NAME::complex_iter,\n            $BENCH_NAME::string_format,\n        );\n    )\n}\n\ndef_benchs!{\n    10_000,\n    fold1,\n    fold1_10k,\n}\n\ndef_benchs!{\n    10_000,\n    tree_fold1,\n    tree_fold1_stack_10k,\n}\n\ndef_benchs!{\n    10_000,\n    tree_fold1_vec,\n    tree_fold1_vec_10k,\n}\n\ndef_benchs!{\n    100,\n    fold1,\n    fold1_100,\n}\n\ndef_benchs!{\n    100,\n    tree_fold1,\n    tree_fold1_stack_100,\n}\n\ndef_benchs!{\n    100,\n    tree_fold1_vec,\n    tree_fold1_vec_100,\n}\n\ndef_benchs!{\n    8,\n    fold1,\n    fold1_08,\n}\n\ndef_benchs!{\n    8,\n    tree_fold1,\n    tree_fold1_stack_08,\n}\n\ndef_benchs!{\n    8,\n    tree_fold1_vec,\n    tree_fold1_vec_08,\n}\n\ncriterion_main!(\n    fold1_10k,\n    tree_fold1_stack_10k,\n    tree_fold1_vec_10k,\n    fold1_100,\n    tree_fold1_stack_100,\n    tree_fold1_vec_100,\n    fold1_08,\n    tree_fold1_stack_08,\n    tree_fold1_vec_08,\n);\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":9},{"path":["/","usr","src","itertools","src","adaptors","mod.rs"],"content":"//! Licensed under the Apache License, Version 2.0\n//! http://www.apache.org/licenses/LICENSE-2.0 or the MIT license\n//! http://opensource.org/licenses/MIT, at your\n//! option. This file may not be copied, modified, or distributed\n//! except according to those terms.\n\nmod multi_product;\n#[cfg(feature = \"use_std\")]\npub use self::multi_product::*;\n\nuse std::fmt;\nuse std::mem::replace;\nuse std::iter::{Fuse, Peekable, FromIterator, FusedIterator};\nuse std::marker::PhantomData;\nuse crate::size_hint;\n\n/// An iterator adaptor that alternates elements from two iterators until both\n/// run out.\n///\n/// This iterator is *fused*.\n///\n/// See [`.interleave()`](../trait.Itertools.html#method.interleave) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Interleave<I, J> {\n    a: Fuse<I>,\n    b: Fuse<J>,\n    flag: bool,\n}\n\n/// Create an iterator that interleaves elements in `i` and `j`.\n///\n/// `IntoIterator` enabled version of `i.interleave(j)`.\n///\n/// ```\n/// use itertools::interleave;\n///\n/// for elt in interleave(&[1, 2, 3], &[2, 3, 4]) {\n///     /* loop body */\n/// }\n/// ```\npub fn interleave<I, J>(i: I, j: J) -> Interleave<<I as IntoIterator>::IntoIter, <J as IntoIterator>::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator<Item = I::Item>\n{\n    Interleave {\n        a: i.into_iter().fuse(),\n        b: j.into_iter().fuse(),\n        flag: false,\n    }\n}\n\nimpl<I, J> Iterator for Interleave<I, J>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.flag = !self.flag;\n        if self.flag {\n            match self.a.next() {\n                None => self.b.next(),\n                r => r,\n            }\n        } else {\n            match self.b.next() {\n                None => self.a.next(),\n                r => r,\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add(self.a.size_hint(), self.b.size_hint())\n    }\n}\n\n/// An iterator adaptor that alternates elements from the two iterators until\n/// one of them runs out.\n///\n/// This iterator is *fused*.\n///\n/// See [`.interleave_shortest()`](../trait.Itertools.html#method.interleave_shortest)\n/// for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct InterleaveShortest<I, J>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    it0: I,\n    it1: J,\n    phase: bool, // false ==> it0, true ==> it1\n}\n\n/// Create a new `InterleaveShortest` iterator.\npub fn interleave_shortest<I, J>(a: I, b: J) -> InterleaveShortest<I, J>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    InterleaveShortest {\n        it0: a,\n        it1: b,\n        phase: false,\n    }\n}\n\nimpl<I, J> Iterator for InterleaveShortest<I, J>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    type Item = I::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.phase {\n            false => match self.it0.next() {\n                None => None,\n                e => {\n                    self.phase = true;\n                    e\n                }\n            },\n            true => match self.it1.next() {\n                None => None,\n                e => {\n                    self.phase = false;\n                    e\n                }\n            },\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (curr_hint, next_hint) = {\n            let it0_hint = self.it0.size_hint();\n            let it1_hint = self.it1.size_hint();\n            if self.phase {\n                (it1_hint, it0_hint)\n            } else {\n                (it0_hint, it1_hint)\n            }\n        };\n        let (curr_lower, curr_upper) = curr_hint;\n        let (next_lower, next_upper) = next_hint;\n        let (combined_lower, combined_upper) =\n            size_hint::mul_scalar(size_hint::min(curr_hint, next_hint), 2);\n        let lower =\n            if curr_lower > next_lower {\n                combined_lower + 1\n            } else {\n                combined_lower\n            };\n        let upper = {\n            let extra_elem = match (curr_upper, next_upper) {\n                (_, None) => false,\n                (None, Some(_)) => true,\n                (Some(curr_max), Some(next_max)) => curr_max > next_max,\n            };\n            if extra_elem {\n                combined_upper.and_then(|x| x.checked_add(1))\n            } else {\n                combined_upper\n            }\n        };\n        (lower, upper)\n    }\n}\n\n#[derive(Clone, Debug)]\n/// An iterator adaptor that allows putting back a single\n/// item to the front of the iterator.\n///\n/// Iterator element type is `I::Item`.\npub struct PutBack<I>\n    where I: Iterator\n{\n    top: Option<I::Item>,\n    iter: I,\n}\n\n/// Create an iterator where you can put back a single item\npub fn put_back<I>(iterable: I) -> PutBack<I::IntoIter>\n    where I: IntoIterator\n{\n    PutBack {\n        top: None,\n        iter: iterable.into_iter(),\n    }\n}\n\nimpl<I> PutBack<I>\n    where I: Iterator\n{\n    /// put back value `value` (builder method)\n    pub fn with_value(mut self, value: I::Item) -> Self {\n        self.put_back(value);\n        self\n    }\n\n    /// Split the `PutBack` into its parts.\n    #[inline]\n    pub fn into_parts(self) -> (Option<I::Item>, I) {\n        let PutBack{top, iter} = self;\n        (top, iter)\n    }\n\n    /// Put back a single value to the front of the iterator.\n    ///\n    /// If a value is already in the put back slot, it is overwritten.\n    #[inline]\n    pub fn put_back(&mut self, x: I::Item) {\n        self.top = Some(x)\n    }\n}\n\nimpl<I> Iterator for PutBack<I>\n    where I: Iterator\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.top {\n            None => self.iter.next(),\n            ref mut some => some.take(),\n        }\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // Not ExactSizeIterator because size may be larger than usize\n        size_hint::add_scalar(self.iter.size_hint(), self.top.is_some() as usize)\n    }\n\n    fn count(self) -> usize {\n        self.iter.count() + (self.top.is_some() as usize)\n    }\n\n    fn last(self) -> Option<Self::Item> {\n        self.iter.last().or(self.top)\n    }\n\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        match self.top {\n            None => self.iter.nth(n),\n            ref mut some => {\n                if n == 0 {\n                    some.take()\n                } else {\n                    *some = None;\n                    self.iter.nth(n - 1)\n                }\n            }\n        }\n    }\n\n    fn all<G>(&mut self, mut f: G) -> bool\n        where G: FnMut(Self::Item) -> bool\n    {\n        if let Some(elt) = self.top.take() {\n            if !f(elt) {\n                return false;\n            }\n        }\n        self.iter.all(f)\n    }\n\n    fn fold<Acc, G>(mut self, init: Acc, mut f: G) -> Acc\n        where G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        let mut accum = init;\n        if let Some(elt) = self.top.take() {\n            accum = f(accum, elt);\n        }\n        self.iter.fold(accum, f)\n    }\n}\n\n#[derive(Debug, Clone)]\n/// An iterator adaptor that iterates over the cartesian product of\n/// the element sets of two iterators `I` and `J`.\n///\n/// Iterator element type is `(I::Item, J::Item)`.\n///\n/// See [`.cartesian_product()`](../trait.Itertools.html#method.cartesian_product) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Product<I, J>\n    where I: Iterator\n{\n    a: I,\n    a_cur: Option<I::Item>,\n    b: J,\n    b_orig: J,\n}\n\n/// Create a new cartesian product iterator\n///\n/// Iterator element type is `(I::Item, J::Item)`.\npub fn cartesian_product<I, J>(mut i: I, j: J) -> Product<I, J>\n    where I: Iterator,\n          J: Clone + Iterator,\n          I::Item: Clone\n{\n    Product {\n        a_cur: i.next(),\n        a: i,\n        b: j.clone(),\n        b_orig: j,\n    }\n}\n\nimpl<I, J> Iterator for Product<I, J>\n    where I: Iterator,\n          J: Clone + Iterator,\n          I::Item: Clone\n{\n    type Item = (I::Item, J::Item);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let elt_b = match self.b.next() {\n            None => {\n                self.b = self.b_orig.clone();\n                match self.b.next() {\n                    None => return None,\n                    Some(x) => {\n                        self.a_cur = self.a.next();\n                        x\n                    }\n                }\n            }\n            Some(x) => x\n        };\n        match self.a_cur {\n            None => None,\n            Some(ref a) => {\n                Some((a.clone(), elt_b))\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let has_cur = self.a_cur.is_some() as usize;\n        // Not ExactSizeIterator because size may be larger than usize\n        let (b_min, b_max) = self.b.size_hint();\n\n        // Compute a * b_orig + b for both lower and upper bound\n        size_hint::add(\n            size_hint::mul(self.a.size_hint(), self.b_orig.size_hint()),\n            (b_min * has_cur, b_max.map(move |x| x * has_cur)))\n    }\n\n    fn fold<Acc, G>(mut self, mut accum: Acc, mut f: G) -> Acc\n        where G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        // use a split loop to handle the loose a_cur as well as avoiding to\n        // clone b_orig at the end.\n        if let Some(mut a) = self.a_cur.take() {\n            let mut b = self.b;\n            loop {\n                accum = b.fold(accum, |acc, elt| f(acc, (a.clone(), elt)));\n\n                // we can only continue iterating a if we had a first element;\n                if let Some(next_a) = self.a.next() {\n                    b = self.b_orig.clone();\n                    a = next_a;\n                } else {\n                    break;\n                }\n            }\n        }\n        accum\n    }\n}\n\n/// A “meta iterator adaptor”. Its closure receives a reference to the iterator\n/// and may pick off as many elements as it likes, to produce the next iterator element.\n///\n/// Iterator element type is *X*, if the return type of `F` is *Option\\<X\\>*.\n///\n/// See [`.batching()`](../trait.Itertools.html#method.batching) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Batching<I, F> {\n    f: F,\n    iter: I,\n}\n\nimpl<I, F> fmt::Debug for Batching<I, F> where I: fmt::Debug {\n    debug_fmt_fields!(Batching, iter);\n}\n\n/// Create a new Batching iterator.\npub fn batching<I, F>(iter: I, f: F) -> Batching<I, F> {\n    Batching { f, iter }\n}\n\nimpl<B, F, I> Iterator for Batching<I, F>\n    where I: Iterator,\n          F: FnMut(&mut I) -> Option<B>\n{\n    type Item = B;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        (self.f)(&mut self.iter)\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // No information about closue behavior\n        (0, None)\n    }\n}\n\n/// An iterator adaptor that steps a number elements in the base iterator\n/// for each iteration.\n///\n/// The iterator steps by yielding the next element from the base iterator,\n/// then skipping forward *n-1* elements.\n///\n/// See [`.step()`](../trait.Itertools.html#method.step) for more information.\n#[deprecated(note=\"Use std .step_by() instead\", since=\"0.8\")]\n#[allow(deprecated)]\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Step<I> {\n    iter: Fuse<I>,\n    skip: usize,\n}\n\n/// Create a `Step` iterator.\n///\n/// **Panics** if the step is 0.\n#[allow(deprecated)]\npub fn step<I>(iter: I, step: usize) -> Step<I>\n    where I: Iterator\n{\n    assert!(step != 0);\n    Step {\n        iter: iter.fuse(),\n        skip: step - 1,\n    }\n}\n\n#[allow(deprecated)]\nimpl<I> Iterator for Step<I>\n    where I: Iterator\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let elt = self.iter.next();\n        if self.skip > 0 {\n            self.iter.nth(self.skip - 1);\n        }\n        elt\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, high) = self.iter.size_hint();\n        let div = |x: usize| {\n            if x == 0 {\n                0\n            } else {\n                1 + (x - 1) / (self.skip + 1)\n            }\n        };\n        (div(low), high.map(div))\n    }\n}\n\n// known size\n#[allow(deprecated)]\nimpl<I> ExactSizeIterator for Step<I>\n    where I: ExactSizeIterator\n{}\n\npub trait MergePredicate<T> {\n    fn merge_pred(&mut self, a: &T, b: &T) -> bool;\n}\n\n#[derive(Clone)]\npub struct MergeLte;\n\nimpl<T: PartialOrd> MergePredicate<T> for MergeLte {\n    fn merge_pred(&mut self, a: &T, b: &T) -> bool {\n        a <= b\n    }\n}\n\n/// An iterator adaptor that merges the two base iterators in ascending order.\n/// If both base iterators are sorted (ascending), the result is sorted.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.merge()`](../trait.Itertools.html#method.merge_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub type Merge<I, J> = MergeBy<I, J, MergeLte>;\n\n/// Create an iterator that merges elements in `i` and `j`.\n///\n/// `IntoIterator` enabled version of `i.merge(j)`.\n///\n/// ```\n/// use itertools::merge;\n///\n/// for elt in merge(&[1, 2, 3], &[2, 3, 4]) {\n///     /* loop body */\n/// }\n/// ```\npub fn merge<I, J>(i: I, j: J) -> Merge<<I as IntoIterator>::IntoIter, <J as IntoIterator>::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator<Item = I::Item>,\n          I::Item: PartialOrd\n{\n    merge_by_new(i, j, MergeLte)\n}\n\n/// An iterator adaptor that merges the two base iterators in ascending order.\n/// If both base iterators are sorted (ascending), the result is sorted.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.merge_by()`](../trait.Itertools.html#method.merge_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MergeBy<I, J, F>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    a: Peekable<I>,\n    b: Peekable<J>,\n    fused: Option<bool>,\n    cmp: F,\n}\n\nimpl<I, J, F> fmt::Debug for MergeBy<I, J, F>\n    where I: Iterator + fmt::Debug, J: Iterator<Item = I::Item> + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(MergeBy, a, b);\n}\n\nimpl<T, F: FnMut(&T, &T)->bool> MergePredicate<T> for F {\n    fn merge_pred(&mut self, a: &T, b: &T) -> bool {\n        self(a, b)\n    }\n}\n\n/// Create a `MergeBy` iterator.\npub fn merge_by_new<I, J, F>(a: I, b: J, cmp: F) -> MergeBy<I::IntoIter, J::IntoIter, F>\n    where I: IntoIterator,\n          J: IntoIterator<Item = I::Item>,\n          F: MergePredicate<I::Item>,\n{\n    MergeBy {\n        a: a.into_iter().peekable(),\n        b: b.into_iter().peekable(),\n        fused: None,\n        cmp,\n    }\n}\n\nimpl<I, J, F> Clone for MergeBy<I, J, F>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>,\n          Peekable<I>: Clone,\n          Peekable<J>: Clone,\n          F: Clone\n{\n    clone_fields!(a, b, fused, cmp);\n}\n\nimpl<I, J, F> Iterator for MergeBy<I, J, F>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>,\n          F: MergePredicate<I::Item>\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let less_than = match self.fused {\n            Some(lt) => lt,\n            None => match (self.a.peek(), self.b.peek()) {\n                (Some(a), Some(b)) => self.cmp.merge_pred(a, b),\n                (Some(_), None) => {\n                    self.fused = Some(true);\n                    true\n                }\n                (None, Some(_)) => {\n                    self.fused = Some(false);\n                    false\n                }\n                (None, None) => return None,\n            }\n        };\n        if less_than {\n            self.a.next()\n        } else {\n            self.b.next()\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // Not ExactSizeIterator because size may be larger than usize\n        size_hint::add(self.a.size_hint(), self.b.size_hint())\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct CoalesceCore<I, T>\n    where I: Iterator\n{\n    iter: I,\n    last: Option<T>,\n}\n\nimpl<I, T> CoalesceCore<I, T>\n    where I: Iterator\n{\n    fn next_with<F>(&mut self, mut f: F) -> Option<T>\n        where F: FnMut(T, I::Item) -> Result<T, (T, T)>\n    {\n        // this fuses the iterator\n        let mut last = match self.last.take() {\n            None => return None,\n            Some(x) => x,\n        };\n        for next in &mut self.iter {\n            match f(last, next) {\n                Ok(joined) => last = joined,\n                Err((last_, next_)) => {\n                    self.last = Some(next_);\n                    return Some(last_);\n                }\n            }\n        }\n\n        Some(last)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, hi) = size_hint::add_scalar(self.iter.size_hint(),\n                                              self.last.is_some() as usize);\n        ((low > 0) as usize, hi)\n    }\n}\n\n/// An iterator adaptor that may join together adjacent elements.\n///\n/// See [`.coalesce()`](../trait.Itertools.html#method.coalesce) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Coalesce<I, F>\n    where I: Iterator\n{\n    iter: CoalesceCore<I, I::Item>,\n    f: F,\n}\n\nimpl<I: Clone, F: Clone> Clone for Coalesce<I, F>\n    where I: Iterator,\n          I::Item: Clone\n{\n    clone_fields!(iter, f);\n}\n\nimpl<I, F> fmt::Debug for Coalesce<I, F>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(Coalesce, iter);\n}\n\n/// Create a new `Coalesce`.\npub fn coalesce<I, F>(mut iter: I, f: F) -> Coalesce<I, F>\n    where I: Iterator\n{\n    Coalesce {\n        iter: CoalesceCore {\n            last: iter.next(),\n            iter,\n        },\n        f,\n    }\n}\n\nimpl<I, F> Iterator for Coalesce<I, F>\n    where I: Iterator,\n          F: FnMut(I::Item, I::Item) -> Result<I::Item, (I::Item, I::Item)>\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next_with(&mut self.f)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\n/// An iterator adaptor that removes repeated duplicates, determining equality using a comparison function.\n///\n/// See [`.dedup_by()`](../trait.Itertools.html#method.dedup_by) or [`.dedup()`](../trait.Itertools.html#method.dedup) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct DedupBy<I, Pred>\n    where I: Iterator\n{\n    iter: CoalesceCore<I, I::Item>,\n    dedup_pred: Pred,\n}\n\npub trait DedupPredicate<T> { // TODO replace by Fn(&T, &T)->bool once Rust supports it\n    fn dedup_pair(&mut self, a: &T, b: &T) -> bool;\n}\n\n#[derive(Clone)]\npub struct DedupEq;\n\nimpl<T: PartialEq> DedupPredicate<T> for DedupEq {\n    fn dedup_pair(&mut self, a: &T, b: &T) -> bool {\n        a == b\n    }\n}\n\nimpl<T, F: FnMut(&T, &T)->bool> DedupPredicate<T> for F {\n    fn dedup_pair(&mut self, a: &T, b: &T) -> bool {\n        self(a, b)\n    }\n}\n\n/// An iterator adaptor that removes repeated duplicates.\n///\n/// See [`.dedup()`](../trait.Itertools.html#method.dedup) for more information.\npub type Dedup<I>=DedupBy<I, DedupEq>;\n\nimpl<I: Clone, Pred: Clone> Clone for DedupBy<I, Pred>\n    where I: Iterator,\n          I::Item: Clone,\n{\n    clone_fields!(iter, dedup_pred);\n}\n\n/// Create a new `DedupBy`.\npub fn dedup_by<I, Pred>(mut iter: I, dedup_pred: Pred) -> DedupBy<I, Pred>\n    where I: Iterator,\n{\n    DedupBy {\n        iter: CoalesceCore {\n            last: iter.next(),\n            iter,\n        },\n        dedup_pred,\n    }\n}\n\n/// Create a new `Dedup`.\npub fn dedup<I>(iter: I) -> Dedup<I>\n    where I: Iterator\n{\n    dedup_by(iter, DedupEq)\n}\n\nimpl<I, Pred> fmt::Debug for DedupBy<I, Pred>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(Dedup, iter);\n}\n\nimpl<I, Pred> Iterator for DedupBy<I, Pred>\n    where I: Iterator,\n          Pred: DedupPredicate<I::Item>,\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let ref mut dedup_pred = self.dedup_pred;\n        self.iter.next_with(|x, y| {\n            if dedup_pred.dedup_pair(&x, &y) { Ok(x) } else { Err((x, y)) }\n        })\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn fold<Acc, G>(self, mut accum: Acc, mut f: G) -> Acc\n        where G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        if let Some(mut last) = self.iter.last {\n            let mut dedup_pred = self.dedup_pred;\n            accum = self.iter.iter.fold(accum, |acc, elt| {\n                if dedup_pred.dedup_pair(&elt, &last) {\n                    acc\n                } else {\n                    f(acc, replace(&mut last, elt))\n                }\n            });\n            f(accum, last)\n        } else {\n            accum\n        }\n    }\n}\n\n/// An iterator adaptor that removes repeated duplicates, while keeping a count of how many\n/// repeated elements were present. This will determine equality using a comparison function.\n///\n/// See [`.dedup_by_with_count()`](../trait.Itertools.html#method.dedup_by_with_count) or\n/// [`.dedup_with_count()`](../trait.Itertools.html#method.dedup_with_count) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct DedupByWithCount<I, Pred>\n    where I: Iterator\n{\n    iter: CoalesceCore<I, (usize, I::Item)>,\n    dedup_pred: Pred,\n}\n\n/// An iterator adaptor that removes repeated duplicates, while keeping a count of how many\n/// repeated elements were present.\n///\n/// See [`.dedup_with_count()`](../trait.Itertools.html#method.dedup_with_count) for more information.\npub type DedupWithCount<I> = DedupByWithCount<I, DedupEq>;\n\n/// Create a new `DedupByWithCount`.\npub fn dedup_by_with_count<I, Pred>(mut iter: I, dedup_pred: Pred) -> DedupByWithCount<I, Pred>\n    where I: Iterator,\n{\n    DedupByWithCount {\n        iter: CoalesceCore {\n            last: iter.next().map(|v| (1, v)),\n            iter,\n        },\n        dedup_pred,\n    }\n}\n\n/// Create a new `DedupWithCount`.\npub fn dedup_with_count<I>(iter: I) -> DedupWithCount<I>\n    where I: Iterator\n{\n    dedup_by_with_count(iter, DedupEq)\n}\n\nimpl<I, Pred> fmt::Debug for DedupByWithCount<I, Pred>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(Dedup, iter);\n}\n\nimpl<I: Clone, Pred: Clone> Clone for DedupByWithCount<I, Pred>\n    where I: Iterator,\n          I::Item: Clone,\n{\n    clone_fields!(iter, dedup_pred);\n}\n\nimpl<I, Pred> Iterator for DedupByWithCount<I, Pred>\n    where I: Iterator,\n          Pred: DedupPredicate<I::Item>,\n{\n    type Item = (usize, I::Item);\n\n    fn next(&mut self) -> Option<(usize, I::Item)> {\n        let ref mut dedup_pred = self.dedup_pred;\n        self.iter.next_with(|(c, x), y| {\n            if dedup_pred.dedup_pair(&x, &y) { Ok((c + 1, x)) } else { Err(((c, x), (1, y))) }\n        })\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\nimpl<I: Iterator, Pred: DedupPredicate<I::Item>> FusedIterator for DedupByWithCount<I, Pred> {}\n\n/// An iterator adaptor that borrows from a `Clone`-able iterator\n/// to only pick off elements while the predicate returns `true`.\n///\n/// See [`.take_while_ref()`](../trait.Itertools.html#method.take_while_ref) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct TakeWhileRef<'a, I: 'a, F> {\n    iter: &'a mut I,\n    f: F,\n}\n\nimpl<'a, I, F> fmt::Debug for TakeWhileRef<'a, I, F>\n    where I: Iterator + fmt::Debug,\n{\n    debug_fmt_fields!(TakeWhileRef, iter);\n}\n\n/// Create a new `TakeWhileRef` from a reference to clonable iterator.\npub fn take_while_ref<I, F>(iter: &mut I, f: F) -> TakeWhileRef<I, F>\n    where I: Iterator + Clone\n{\n    TakeWhileRef { iter, f }\n}\n\nimpl<'a, I, F> Iterator for TakeWhileRef<'a, I, F>\n    where I: Iterator + Clone,\n          F: FnMut(&I::Item) -> bool\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let old = self.iter.clone();\n        match self.iter.next() {\n            None => None,\n            Some(elt) => {\n                if (self.f)(&elt) {\n                    Some(elt)\n                } else {\n                    *self.iter = old;\n                    None\n                }\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, hi) = self.iter.size_hint();\n        (0, hi)\n    }\n}\n\n/// An iterator adaptor that filters `Option<A>` iterator elements\n/// and produces `A`. Stops on the first `None` encountered.\n///\n/// See [`.while_some()`](../trait.Itertools.html#method.while_some) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct WhileSome<I> {\n    iter: I,\n}\n\n/// Create a new `WhileSome<I>`.\npub fn while_some<I>(iter: I) -> WhileSome<I> {\n    WhileSome { iter }\n}\n\nimpl<I, A> Iterator for WhileSome<I>\n    where I: Iterator<Item = Option<A>>\n{\n    type Item = A;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.iter.next() {\n            None | Some(None) => None,\n            Some(elt) => elt,\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let sh = self.iter.size_hint();\n        (0, sh.1)\n    }\n}\n\n/// An iterator to iterate through all combinations in a `Clone`-able iterator that produces tuples\n/// of a specific size.\n///\n/// See [`.tuple_combinations()`](../trait.Itertools.html#method.tuple_combinations) for more\n/// information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct TupleCombinations<I, T>\n    where I: Iterator,\n          T: HasCombination<I>\n{\n    iter: T::Combination,\n    _mi: PhantomData<I>,\n    _mt: PhantomData<T>\n}\n\npub trait HasCombination<I>: Sized {\n    type Combination: From<I> + Iterator<Item = Self>;\n}\n\n/// Create a new `TupleCombinations` from a clonable iterator.\npub fn tuple_combinations<T, I>(iter: I) -> TupleCombinations<I, T>\n    where I: Iterator + Clone,\n          I::Item: Clone,\n          T: HasCombination<I>,\n{\n    TupleCombinations {\n        iter: T::Combination::from(iter),\n        _mi: PhantomData,\n        _mt: PhantomData,\n    }\n}\n\nimpl<I, T> Iterator for TupleCombinations<I, T>\n    where I: Iterator,\n          T: HasCombination<I>,\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next()\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct Tuple1Combination<I> {\n    iter: I,\n}\n\nimpl<I> From<I> for Tuple1Combination<I> {\n    fn from(iter: I) -> Self {\n        Tuple1Combination { iter }\n    }\n}\n\nimpl<I: Iterator> Iterator for Tuple1Combination<I> {\n    type Item = (I::Item,);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(|x| (x,))\n    }\n}\n\nimpl<I: Iterator> HasCombination<I> for (I::Item,) {\n    type Combination = Tuple1Combination<I>;\n}\n\nmacro_rules! impl_tuple_combination {\n    ($C:ident $P:ident ; $A:ident, $($I:ident),* ; $($X:ident)*) => (\n        #[derive(Clone, Debug)]\n        pub struct $C<I: Iterator> {\n            item: Option<I::Item>,\n            iter: I,\n            c: $P<I>,\n        }\n\n        impl<I: Iterator + Clone> From<I> for $C<I> {\n            fn from(mut iter: I) -> Self {\n                $C {\n                    item: iter.next(),\n                    iter: iter.clone(),\n                    c: $P::from(iter),\n                }\n            }\n        }\n\n        impl<I: Iterator + Clone> From<I> for $C<Fuse<I>> {\n            fn from(iter: I) -> Self {\n                let mut iter = iter.fuse();\n                $C {\n                    item: iter.next(),\n                    iter: iter.clone(),\n                    c: $P::from(iter),\n                }\n            }\n        }\n\n        impl<I, $A> Iterator for $C<I>\n            where I: Iterator<Item = $A> + Clone,\n                  I::Item: Clone\n        {\n            type Item = ($($I),*);\n\n            fn next(&mut self) -> Option<Self::Item> {\n                if let Some(($($X),*,)) = self.c.next() {\n                    let z = self.item.clone().unwrap();\n                    Some((z, $($X),*))\n                } else {\n                    self.item = self.iter.next();\n                    self.item.clone().and_then(|z| {\n                        self.c = $P::from(self.iter.clone());\n                        self.c.next().map(|($($X),*,)| (z, $($X),*))\n                    })\n                }\n            }\n        }\n\n        impl<I, $A> HasCombination<I> for ($($I),*)\n            where I: Iterator<Item = $A> + Clone,\n                  I::Item: Clone\n        {\n            type Combination = $C<Fuse<I>>;\n        }\n    )\n}\n\nimpl_tuple_combination!(Tuple2Combination Tuple1Combination ; A, A, A ; a);\nimpl_tuple_combination!(Tuple3Combination Tuple2Combination ; A, A, A, A ; a b);\nimpl_tuple_combination!(Tuple4Combination Tuple3Combination ; A, A, A, A, A; a b c);\n\n/// An iterator adapter to apply `Into` conversion to each element.\n///\n/// See [`.map_into()`](../trait.Itertools.html#method.map_into) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MapInto<I, R> {\n    iter: I,\n    _res: PhantomData<R>,\n}\n\n/// Create a new [`MapInto`](struct.MapInto.html) iterator.\npub fn map_into<I, R>(iter: I) -> MapInto<I, R> {\n    MapInto {\n        iter,\n        _res: PhantomData,\n    }\n}\n\nimpl<I, R> Iterator for MapInto<I, R>\n    where I: Iterator,\n          I::Item: Into<R>,\n{\n    type Item = R;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter\n            .next()\n            .map(|i| i.into())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn fold<Acc, Fold>(self, init: Acc, mut fold_f: Fold) -> Acc\n        where Fold: FnMut(Acc, Self::Item) -> Acc,\n    {\n        self.iter.fold(init, move |acc, v| fold_f(acc, v.into()))\n    }\n}\n\nimpl<I, R> DoubleEndedIterator for MapInto<I, R>\n    where I: DoubleEndedIterator,\n          I::Item: Into<R>,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.iter\n            .next_back()\n            .map(|i| i.into())\n    }\n}\n\nimpl<I, R> ExactSizeIterator for MapInto<I, R>\nwhere\n    I: ExactSizeIterator,\n    I::Item: Into<R>,\n{}\n\n/// An iterator adapter to apply a transformation within a nested `Result`.\n///\n/// See [`.map_results()`](../trait.Itertools.html#method.map_results) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MapResults<I, F> {\n    iter: I,\n    f: F\n}\n\n/// Create a new `MapResults` iterator.\npub fn map_results<I, F, T, U, E>(iter: I, f: F) -> MapResults<I, F>\n    where I: Iterator<Item = Result<T, E>>,\n          F: FnMut(T) -> U,\n{\n    MapResults {\n        iter,\n        f,\n    }\n}\n\nimpl<I, F, T, U, E> Iterator for MapResults<I, F>\n    where I: Iterator<Item = Result<T, E>>,\n          F: FnMut(T) -> U,\n{\n    type Item = Result<U, E>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(|v| v.map(&mut self.f))\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn fold<Acc, Fold>(self, init: Acc, mut fold_f: Fold) -> Acc\n        where Fold: FnMut(Acc, Self::Item) -> Acc,\n    {\n        let mut f = self.f;\n        self.iter.fold(init, move |acc, v| fold_f(acc, v.map(&mut f)))\n    }\n\n    fn collect<C>(self) -> C\n        where C: FromIterator<Self::Item>\n    {\n        let mut f = self.f;\n        self.iter.map(move |v| v.map(&mut f)).collect()\n    }\n}\n\n/// An iterator adapter to get the positions of each element that matches a predicate.\n///\n/// See [`.positions()`](../trait.Itertools.html#method.positions) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Positions<I, F> {\n    iter: I,\n    f: F,\n    count: usize,\n}\n\n/// Create a new `Positions` iterator.\npub fn positions<I, F>(iter: I, f: F) -> Positions<I, F>\n    where I: Iterator,\n          F: FnMut(I::Item) -> bool,\n{\n    Positions {\n        iter,\n        f,\n        count: 0\n    }\n}\n\nimpl<I, F> Iterator for Positions<I, F>\n    where I: Iterator,\n          F: FnMut(I::Item) -> bool,\n{\n    type Item = usize;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        while let Some(v) = self.iter.next() {\n            let i = self.count;\n            self.count = i + 1;\n            if (self.f)(v) {\n                return Some(i);\n            }\n        }\n        None\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (0, self.iter.size_hint().1)\n    }\n}\n\nimpl<I, F> DoubleEndedIterator for Positions<I, F>\n    where I: DoubleEndedIterator + ExactSizeIterator,\n          F: FnMut(I::Item) -> bool,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        while let Some(v) = self.iter.next_back() {\n            if (self.f)(v) {\n                return Some(self.count + self.iter.len())\n            }\n        }\n        None\n    }\n}\n\n/// An iterator adapter to apply a mutating function to each element before yielding it.\n///\n/// See [`.update()`](../trait.Itertools.html#method.update) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Update<I, F> {\n    iter: I,\n    f: F,\n}\n\n/// Create a new `Update` iterator.\npub fn update<I, F>(iter: I, f: F) -> Update<I, F>\nwhere\n    I: Iterator,\n    F: FnMut(&mut I::Item),\n{\n    Update { iter, f }\n}\n\nimpl<I, F> Iterator for Update<I, F>\nwhere\n    I: Iterator,\n    F: FnMut(&mut I::Item),\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if let Some(mut v) = self.iter.next() {\n            (self.f)(&mut v);\n            Some(v)\n        } else {\n            None\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn fold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n        where G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        let mut f = self.f;\n        self.iter.fold(init, move |acc, mut v| { f(&mut v); g(acc, v) })\n    }\n\n    // if possible, re-use inner iterator specializations in collect\n    fn collect<C>(self) -> C\n        where C: FromIterator<Self::Item>\n    {\n        let mut f = self.f;\n        self.iter.map(move |mut v| { f(&mut v); v }).collect()\n    }\n}\n\nimpl<I, F> ExactSizeIterator for Update<I, F>\nwhere\n    I: ExactSizeIterator,\n    F: FnMut(&mut I::Item),\n{}\n\nimpl<I, F> DoubleEndedIterator for Update<I, F>\nwhere\n    I: DoubleEndedIterator,\n    F: FnMut(&mut I::Item),\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        if let Some(mut v) = self.iter.next_back() {\n            (self.f)(&mut v);\n            Some(v)\n        } else {\n            None\n        }\n    }\n}\n","traces":[{"line":42,"address":[4270855,4270736],"length":1,"stats":{"Line":3},"fn_name":"interleave<core::slice::Iter<u8>,core::slice::Iter<u8>>"},{"line":47,"address":[4270775],"length":1,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[4270934,4270880],"length":1,"stats":{"Line":6},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[4885184,4885088,4884928],"length":1,"stats":{"Line":5},"fn_name":"interleave_shortest<alloc::vec::IntoIter<i32>,alloc::vec::IntoIter<i32>>"},{"line":116,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":185,"address":[4267904,4268030],"length":1,"stats":{"Line":11},"fn_name":"put_back<core::iter::adapters::fuse::Fuse<alloc::vec::IntoIter<u32>>>"},{"line":190,"address":[4267919],"length":1,"stats":{"Line":11},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[4267840],"length":1,"stats":{"Line":12},"fn_name":"put_back<core::iter::adapters::fuse::Fuse<alloc::vec::IntoIter<u32>>>"},{"line":215,"address":[4267853],"length":1,"stats":{"Line":12},"fn_name":null},{"line":224,"address":[4267632],"length":1,"stats":{"Line":12},"fn_name":"next<core::iter::adapters::fuse::Fuse<alloc::vec::IntoIter<u32>>>"},{"line":225,"address":[4267707],"length":1,"stats":{"Line":12},"fn_name":null},{"line":226,"address":[4267641,4267694],"length":1,"stats":{"Line":24},"fn_name":null},{"line":227,"address":[4267662],"length":1,"stats":{"Line":12},"fn_name":null},{"line":231,"address":[4267728],"length":1,"stats":{"Line":10},"fn_name":"size_hint<core::iter::adapters::fuse::Fuse<alloc::vec::IntoIter<u32>>>"},{"line":233,"address":[4267740],"length":1,"stats":{"Line":12},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[4883264,4883856,4883319,4883587,4883520,4883792],"length":1,"stats":{"Line":8},"fn_name":"cartesian_product<itertools::adaptors::Product<core::ops::range::Range<i32>, core::ops::range::Range<i32>>,core::ops::range::Range<i32>>"},{"line":306,"address":[4883544,4883279,4883810],"length":1,"stats":{"Line":9},"fn_name":null},{"line":308,"address":[4883363,4883641,4883924],"length":1,"stats":{"Line":8},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":353,"address":[4651920,4652015],"length":1,"stats":{"Line":1},"fn_name":"fold<itertools::adaptors::Product<quick::Iter<u16, quick::Inexact>, quick::Iter<u16, quick::Inexact>>,quick::Iter<u16, quick::Inexact>,(),closure-0>"},{"line":358,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":394,"address":[4214880],"length":1,"stats":{"Line":2},"fn_name":"batching<core::slice::Iter<core::option::Option<i32>>,closure-0>"},{"line":404,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[4889792,4889865],"length":1,"stats":{"Line":7},"fn_name":"step<core::ops::range::Range<i32>>"},{"line":438,"address":[4889812],"length":1,"stats":{"Line":7},"fn_name":null},{"line":440,"address":[4889877],"length":1,"stats":{"Line":7},"fn_name":null},{"line":441,"address":[4889937,4890032],"length":1,"stats":{"Line":7},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":511,"address":[4272688],"length":1,"stats":{"Line":3},"fn_name":"merge<itertools::adaptors::Step<core::ops::range::Range<i32>>,itertools::adaptors::Step<core::ops::range::Range<i32>>>"},{"line":516,"address":[4272695],"length":1,"stats":{"Line":3},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":550,"address":[4882283,4881696,4881842,4882160],"length":1,"stats":{"Line":5},"fn_name":"merge_by_new<alloc::collections::btree::map::IntoIter<&str, i32>,alloc::collections::btree::map::IntoIter<&str, i32>,closure-0>"},{"line":556,"address":[4881706,4882202],"length":1,"stats":{"Line":5},"fn_name":null},{"line":557,"address":[4881875,4882316,4882368,4881998],"length":1,"stats":{"Line":10},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":582,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":585,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":589,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":596,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":597,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":599,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":620,"address":[4887440,4888944,4885343,4885936,4888351,4885999,4887508,4886592,4888288,4886660,4885280,4889012],"length":1,"stats":{"Line":11},"fn_name":"next_with<core::slice::Iter<i32>,&i32,closure-0>"},{"line":624,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":626,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":628,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":631,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":632,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":641,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":643,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":692,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":693,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":726,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":727,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":744,"address":[4890128,4890416,4890174,4890560,4890272,4890318,4890462,4890606],"length":1,"stats":{"Line":9},"fn_name":"dedup_by<core::slice::Iter<(i32, i32)>,closure-1>"},{"line":748,"address":[4890196,4890628,4890484,4890340],"length":1,"stats":{"Line":9},"fn_name":null},{"line":757,"address":[4890080],"length":1,"stats":{"Line":4},"fn_name":"dedup<core::slice::Iter<i32>>"},{"line":760,"address":[4890101],"length":1,"stats":{"Line":4},"fn_name":null},{"line":776,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":777,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":778,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":779,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":783,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":784,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":787,"address":[4869578,4869994,4869920,4869504],"length":1,"stats":{"Line":2},"fn_name":"fold<core::slice::Iter<(i32, i32)>,closure-2,(),closure-3>"},{"line":790,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":791,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":792,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":793,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":794,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":796,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":799,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":801,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":826,"address":[4884639,4884447,4884255,4884208,4884400,4884592],"length":1,"stats":{"Line":3},"fn_name":"dedup_by_with_count<core::slice::Iter<(i32, i32)>,closure-0>"},{"line":830,"address":[4884686,4884494,4884302],"length":1,"stats":{"Line":3},"fn_name":null},{"line":839,"address":[4883216],"length":1,"stats":{"Line":1},"fn_name":"dedup_with_count<core::slice::Iter<i32>>"},{"line":842,"address":[4883237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":865,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":866,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":867,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":868,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":872,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":873,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":896,"address":[4670960],"length":1,"stats":{"Line":1},"fn_name":"take_while_ref<core::slice::Iter<u8>,closure-0>"},{"line":908,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":909,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":910,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":911,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":912,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":913,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":914,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":916,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":917,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":923,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":924,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":925,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":940,"address":[4881664],"length":1,"stats":{"Line":2},"fn_name":"while_some<core::iter::adapters::Map<core::ops::range::Range<i32>, closure-0>>"},{"line":949,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":950,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":951,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":952,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":956,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":957,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":958,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":983,"address":[4884112],"length":1,"stats":{"Line":3},"fn_name":"tuple_combinations<(i32, i32),core::ops::range::Range<i32>>"},{"line":989,"address":[4884127],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1001,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1002,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1012,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1020,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1021,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1049,"address":[4879661,4879616],"length":1,"stats":{"Line":3},"fn_name":"from<core::ops::range::Range<i32>>"},{"line":1050,"address":[4879673,4879631],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1051,"address":[4879781],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1052,"address":[4879683],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1053,"address":[4879723],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1054,"address":[4879730],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1065,"address":[4872795,4872736],"length":1,"stats":{"Line":3},"fn_name":"next<core::iter::adapters::fuse::Fuse<core::ops::range::Range<i32>>,i32>"},{"line":1066,"address":[4872748,4872846,4872956,4873013,4872807],"length":1,"stats":{"Line":15},"fn_name":null},{"line":1067,"address":[4872915,4872859],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1068,"address":[4872919],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1070,"address":[4873053,4872819,4872961],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1071,"address":[4873238,4872967,4873071,4873168],"length":1,"stats":{"Line":9},"fn_name":"{{closure}}<core::iter::adapters::fuse::Fuse<core::ops::range::Range<i32>>,i32>"},{"line":1072,"address":[4873260,4873184,4873352],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1073,"address":[4873408,4873371,4873420,4873273],"length":1,"stats":{"Line":10},"fn_name":"{{closure}}<core::iter::adapters::fuse::Fuse<core::ops::range::Range<i32>>,i32>"},{"line":1116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":235,"coverable":307},{"path":["/","usr","src","itertools","src","adaptors","multi_product.rs"],"content":"#![cfg(feature = \"use_std\")]\n\nuse crate::size_hint;\nuse crate::Itertools;\n\n#[derive(Clone)]\n/// An iterator adaptor that iterates over the cartesian product of\n/// multiple iterators of type `I`.\n///\n/// An iterator element type is `Vec<I>`.\n///\n/// See [`.multi_cartesian_product()`](../trait.Itertools.html#method.multi_cartesian_product)\n/// for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MultiProduct<I>(Vec<MultiProductIter<I>>)\n    where I: Iterator + Clone,\n          I::Item: Clone;\n\n/// Create a new cartesian product iterator over an arbitrary number\n/// of iterators of the same type.\n///\n/// Iterator element is of type `Vec<H::Item::Item>`.\npub fn multi_cartesian_product<H>(iters: H) -> MultiProduct<<H::Item as IntoIterator>::IntoIter>\n    where H: Iterator,\n          H::Item: IntoIterator,\n          <H::Item as IntoIterator>::IntoIter: Clone,\n          <H::Item as IntoIterator>::Item: Clone\n{\n    MultiProduct(iters.map(|i| MultiProductIter::new(i.into_iter())).collect())\n}\n\n#[derive(Clone, Debug)]\n/// Holds the state of a single iterator within a MultiProduct.\nstruct MultiProductIter<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    cur: Option<I::Item>,\n    iter: I,\n    iter_orig: I,\n}\n\n/// Holds the current state during an iteration of a MultiProduct.\n#[derive(Debug)]\nenum MultiProductIterState {\n    StartOfIter,\n    MidIter { on_first_iter: bool },\n}\n\nimpl<I> MultiProduct<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    /// Iterates the rightmost iterator, then recursively iterates iterators\n    /// to the left if necessary.\n    ///\n    /// Returns true if the iteration succeeded, else false.\n    fn iterate_last(\n        multi_iters: &mut [MultiProductIter<I>],\n        mut state: MultiProductIterState\n    ) -> bool {\n        use self::MultiProductIterState::*;\n\n        if let Some((last, rest)) = multi_iters.split_last_mut() {\n            let on_first_iter = match state {\n                StartOfIter => {\n                    let on_first_iter = !last.in_progress();\n                    state = MidIter { on_first_iter };\n                    on_first_iter\n                },\n                MidIter { on_first_iter } => on_first_iter\n            };\n\n            if !on_first_iter {\n                last.iterate();\n            }\n\n            if last.in_progress() {\n                true\n            } else if MultiProduct::iterate_last(rest, state) {\n                last.reset();\n                last.iterate();\n                // If iterator is None twice consecutively, then iterator is\n                // empty; whole product is empty.\n                last.in_progress()\n            } else {\n                false\n            }\n        } else {\n            // Reached end of iterator list. On initialisation, return true.\n            // At end of iteration (final iterator finishes), finish.\n            match state {\n                StartOfIter => false,\n                MidIter { on_first_iter } => on_first_iter\n            }\n        }\n    }\n\n    /// Returns the unwrapped value of the next iteration.\n    fn curr_iterator(&self) -> Vec<I::Item> {\n        self.0.iter().map(|multi_iter| {\n            multi_iter.cur.clone().unwrap()\n        }).collect()\n    }\n\n    /// Returns true if iteration has started and has not yet finished; false\n    /// otherwise.\n    fn in_progress(&self) -> bool {\n        if let Some(last) = self.0.last() {\n            last.in_progress()\n        } else {\n            false\n        }\n    }\n}\n\nimpl<I> MultiProductIter<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    fn new(iter: I) -> Self {\n        MultiProductIter {\n            cur: None,\n            iter: iter.clone(),\n            iter_orig: iter\n        }\n    }\n\n    /// Iterate the managed iterator.\n    fn iterate(&mut self) {\n        self.cur = self.iter.next();\n    }\n\n    /// Reset the managed iterator.\n    fn reset(&mut self) {\n        self.iter = self.iter_orig.clone();\n    }\n\n    /// Returns true if the current iterator has been started and has not yet\n    /// finished; false otherwise.\n    fn in_progress(&self) -> bool {\n        self.cur.is_some()\n    }\n}\n\nimpl<I> Iterator for MultiProduct<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    type Item = Vec<I::Item>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if MultiProduct::iterate_last(\n            &mut self.0,\n            MultiProductIterState::StartOfIter\n        ) {\n            Some(self.curr_iterator())\n        } else {\n            None\n        }\n    }\n\n    fn count(self) -> usize {\n        if self.0.len() == 0 {\n            return 0;\n        }\n\n        if !self.in_progress() {\n            return self.0.into_iter().fold(1, |acc, multi_iter| {\n                acc * multi_iter.iter.count()\n            });\n        }\n\n        self.0.into_iter().fold(\n            0,\n            |acc, MultiProductIter { iter, iter_orig, cur: _ }| {\n                let total_count = iter_orig.count();\n                let cur_count = iter.count();\n                acc * total_count + cur_count\n            }\n        )\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // Not ExactSizeIterator because size may be larger than usize\n        if self.0.len() == 0 {\n            return (0, Some(0));\n        }\n\n        if !self.in_progress() {\n            return self.0.iter().fold((1, Some(1)), |acc, multi_iter| {\n                size_hint::mul(acc, multi_iter.iter.size_hint())\n            });\n        }\n\n        self.0.iter().fold(\n            (0, Some(0)),\n            |acc, &MultiProductIter { ref iter, ref iter_orig, cur: _ }| {\n                let cur_size = iter.size_hint();\n                let total_size = iter_orig.size_hint();\n                size_hint::add(size_hint::mul(acc, total_size), cur_size)\n            }\n        )\n    }\n\n    fn last(self) -> Option<Self::Item> {\n        let iter_count = self.0.len();\n\n        let lasts: Self::Item = self.0.into_iter()\n            .map(|multi_iter| multi_iter.iter.last())\n            .while_some()\n            .collect();\n\n        if lasts.len() == iter_count {\n            Some(lasts)\n        } else {\n            None\n        }\n    }\n}\n","traces":[{"line":23,"address":[6028752],"length":1,"stats":{"Line":1},"fn_name":"multi_cartesian_product<quick::ShiftRange<quick::Inexact>>"},{"line":29,"address":[6028880,6028762,6028892],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}<quick::ShiftRange<quick::Inexact>>"},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":60,"coverable":73},{"path":["/","usr","src","itertools","src","combinations.rs"],"content":"use std::fmt;\n\nuse super::lazy_buffer::LazyBuffer;\n\n/// An iterator to iterate through all the `k`-length combinations in an iterator.\n///\n/// See [`.combinations()`](../trait.Itertools.html#method.combinations) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Combinations<I: Iterator> {\n    indices: Vec<usize>,\n    pool: LazyBuffer<I>,\n    first: bool,\n}\n\nimpl<I> Clone for Combinations<I>\n    where I: Clone + Iterator,\n          I::Item: Clone,\n{\n    clone_fields!(indices, pool, first);\n}\n\nimpl<I> fmt::Debug for Combinations<I>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(Combinations, indices, pool, first);\n}\n\n/// Create a new `Combinations` from a clonable iterator.\npub fn combinations<I>(iter: I, k: usize) -> Combinations<I>\n    where I: Iterator\n{\n    let mut pool: LazyBuffer<I> = LazyBuffer::new(iter);\n\n    for _ in 0..k {\n        if !pool.get_next() {\n            break;\n        }\n    }\n\n    Combinations {\n        indices: (0..k).collect(),\n        pool,\n        first: true,\n    }\n}\n\nimpl<I> Iterator for Combinations<I>\n    where I: Iterator,\n          I::Item: Clone\n{\n    type Item = Vec<I::Item>;\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.first {\n            if self.pool.is_done() {\n                return None;\n            }\n            self.first = false;\n        } else if self.indices.len() == 0 {\n            return None;\n        } else {\n            // Scan from the end, looking for an index to increment\n            let mut i: usize = self.indices.len() - 1;\n\n            // Check if we need to consume more from the iterator\n            if self.indices[i] == self.pool.len() - 1 {\n                self.pool.get_next(); // may change pool size\n            }\n\n            while self.indices[i] == i + self.pool.len() - self.indices.len() {\n                if i > 0 {\n                    i -= 1;\n                } else {\n                    // Reached the last combination\n                    return None;\n                }\n            }\n\n            // Increment index, and reset the ones to its right\n            self.indices[i] += 1;\n            for j in i+1..self.indices.len() {\n                self.indices[j] = self.indices[j - 1] + 1;\n            }\n        }\n\n        // Create result vector based on the indices\n        Some(self.indices.iter().map(|i| self.pool[*i].clone()).collect())\n    }\n}\n","traces":[{"line":30,"address":[4231824,4231888],"length":1,"stats":{"Line":4},"fn_name":"combinations<adaptors_no_collect::PanickingCounter>"},{"line":33,"address":[4231858],"length":1,"stats":{"Line":4},"fn_name":null},{"line":35,"address":[4232005,4231903,4232191],"length":1,"stats":{"Line":11},"fn_name":null},{"line":36,"address":[4232185,4232110],"length":1,"stats":{"Line":8},"fn_name":null},{"line":37,"address":[4232196],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[4232121],"length":1,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":54,"address":[4230033,4230962,4229922],"length":1,"stats":{"Line":8},"fn_name":null},{"line":55,"address":[4229979],"length":1,"stats":{"Line":4},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[4230331],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":6},"fn_name":null}],"covered":24,"coverable":24},{"path":["/","usr","src","itertools","src","combinations_with_replacement.rs"],"content":"use std::fmt;\n\nuse super::lazy_buffer::LazyBuffer;\n\n/// An iterator to iterate through all the `n`-length combinations in an iterator, with replacement.\n///\n/// See [`.combinations_with_replacement()`](../trait.Itertools.html#method.combinations_with_replacement) for more information.\n#[derive(Clone)]\npub struct CombinationsWithReplacement<I>\nwhere\n    I: Iterator,\n    I::Item: Clone,\n{\n    k: usize,\n    indices: Vec<usize>,\n    // The current known max index value. This increases as pool grows.\n    max_index: usize,\n    pool: LazyBuffer<I>,\n    first: bool,\n}\n\nimpl<I> fmt::Debug for CombinationsWithReplacement<I>\nwhere\n    I: Iterator + fmt::Debug,\n    I::Item: fmt::Debug + Clone,\n{\n    debug_fmt_fields!(Combinations, k, indices, max_index, pool, first);\n}\n\nimpl<I> CombinationsWithReplacement<I>\nwhere\n    I: Iterator,\n    I::Item: Clone,\n{\n    /// Map the current mask over the pool to get an output combination\n    fn current(&self) -> Vec<I::Item> {\n        self.indices.iter().map(|i| self.pool[*i].clone()).collect()\n    }\n}\n\n/// Create a new `CombinationsWithReplacement` from a clonable iterator.\npub fn combinations_with_replacement<I>(iter: I, k: usize) -> CombinationsWithReplacement<I>\nwhere\n    I: Iterator,\n    I::Item: Clone,\n{\n    let indices: Vec<usize> = vec![0; k];\n    let pool: LazyBuffer<I> = LazyBuffer::new(iter);\n\n    CombinationsWithReplacement {\n        k,\n        indices,\n        max_index: 0,\n        pool,\n        first: true,\n    }\n}\n\nimpl<I> Iterator for CombinationsWithReplacement<I>\nwhere\n    I: Iterator,\n    I::Item: Clone,\n{\n    type Item = Vec<I::Item>;\n    fn next(&mut self) -> Option<Self::Item> {\n        // If this is the first iteration, return early\n        if self.first {\n            // In empty edge cases, stop iterating immediately\n            return if self.k != 0 && !self.pool.get_next() {\n                None\n            // Otherwise, yield the initial state\n            } else {\n                self.first = false;\n                Some(self.current())\n            };\n        }\n\n        // Check if we need to consume more from the iterator\n        // This will run while we increment our first index digit\n        if self.pool.get_next() {\n            self.max_index = self.pool.len() - 1;\n        }\n\n        // Work out where we need to update our indices\n        let mut increment: Option<(usize, usize)> = None;\n        for (i, indices_int) in self.indices.iter().enumerate().rev() {\n            if indices_int < &self.max_index {\n                increment = Some((i, indices_int + 1));\n                break;\n            }\n        }\n\n        match increment {\n            // If we can update the indices further\n            Some((increment_from, increment_value)) => {\n                // We need to update the rightmost non-max value\n                // and all those to the right\n                for indices_index in increment_from..self.indices.len() {\n                    self.indices[indices_index] = increment_value\n                }\n                Some(self.current())\n            }\n            // Otherwise, we're done\n            None => None,\n        }\n    }\n}\n","traces":[{"line":36,"address":[4254016],"length":1,"stats":{"Line":2},"fn_name":"current<adaptors_no_collect::PanickingCounter>"},{"line":37,"address":[4254028,4254160,4254181],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}<adaptors_no_collect::PanickingCounter>"},{"line":42,"address":[4253702,4253600],"length":1,"stats":{"Line":2},"fn_name":"combinations_with_replacement<adaptors_no_collect::PanickingCounter>"},{"line":47,"address":[4253634],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[4253717],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[4252128],"length":1,"stats":{"Line":2},"fn_name":"next<adaptors_no_collect::PanickingCounter>"},{"line":67,"address":[4252146],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[4252401,4252215,4252239,4252356],"length":1,"stats":{"Line":6},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[4253427,4253457,4252426],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":87,"address":[4252880,4252805],"length":1,"stats":{"Line":4},"fn_name":null},{"line":88,"address":[4252891],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[4253032],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":24,"coverable":24},{"path":["/","usr","src","itertools","src","concat_impl.rs"],"content":"use crate::Itertools;\n\n/// Combine all an iterator's elements into one element by using `Extend`.\n///\n/// `IntoIterator`-enabled version of `.concat()`\n///\n/// This combinator will extend the first item with each of the rest of the\n/// items of the iterator. If the iterator is empty, the default value of\n/// `I::Item` is returned.\n///\n/// ```rust\n/// use itertools::concat;\n/// \n/// let input = vec![vec![1], vec![2, 3], vec![4, 5, 6]];\n/// assert_eq!(concat(input), vec![1, 2, 3, 4, 5, 6]);\n/// ```\npub fn concat<I>(iterable: I) -> I::Item\n    where I: IntoIterator,\n          I::Item: Extend<<<I as IntoIterator>::Item as IntoIterator>::Item> + IntoIterator + Default\n{\n    iterable.into_iter().fold1(|mut a, b| { a.extend(b); a }).unwrap_or_else(|| <_>::default())\n}\n","traces":[{"line":17,"address":[4669680,4669792],"length":1,"stats":{"Line":2},"fn_name":"concat<alloc::vec::IntoIter<alloc::vec::Vec<()>>>"},{"line":21,"address":[4669687,4670048,4669916,4670060,4670092,4670124,4669799,4670080,4670112,4669904],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}<alloc::vec::IntoIter<alloc::vec::Vec<i32>>>"}],"covered":2,"coverable":2},{"path":["/","usr","src","itertools","src","cons_tuples_impl.rs"],"content":"\nmacro_rules! impl_cons_iter(\n    ($_A:ident, $_B:ident, ) => (); // stop\n\n    ($A:ident, $($B:ident,)*) => (\n        impl_cons_iter!($($B,)*);\n        #[allow(non_snake_case)]\n        impl<X, Iter, $($B),*> Iterator for ConsTuples<Iter, (($($B,)*), X)>\n            where Iter: Iterator<Item = (($($B,)*), X)>,\n        {\n            type Item = ($($B,)* X, );\n            fn next(&mut self) -> Option<Self::Item> {\n                self.iter.next().map(|(($($B,)*), x)| ($($B,)* x, ))\n            }\n\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.iter.size_hint()\n            }\n            fn fold<Acc, Fold>(self, accum: Acc, mut f: Fold) -> Acc\n                where Fold: FnMut(Acc, Self::Item) -> Acc,\n            {\n                self.iter.fold(accum, move |acc, (($($B,)*), x)| f(acc, ($($B,)* x, )))\n            }\n        }\n\n        #[allow(non_snake_case)]\n        impl<X, Iter, $($B),*> DoubleEndedIterator for ConsTuples<Iter, (($($B,)*), X)>\n            where Iter: DoubleEndedIterator<Item = (($($B,)*), X)>,\n        {\n            fn next_back(&mut self) -> Option<Self::Item> {\n                self.iter.next().map(|(($($B,)*), x)| ($($B,)* x, ))\n            }\n        }\n\n    );\n);\n\nimpl_cons_iter!(A, B, C, D, E, F, G, H,);\n\n/// An iterator that maps an iterator of tuples like\n/// `((A, B), C)` to an iterator of `(A, B, C)`.\n///\n/// Used by the `iproduct!()` macro.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Debug)]\npub struct ConsTuples<I, J>\n    where I: Iterator<Item=J>,\n{\n    iter: I,\n}\n\nimpl<I, J> Clone for ConsTuples<I, J>\n    where I: Clone + Iterator<Item=J>,\n{\n    clone_fields!(iter);\n}\n\n/// Create an iterator that maps for example iterators of\n/// `((A, B), C)` to `(A, B, C)`.\npub fn cons_tuples<I, J>(iterable: I) -> ConsTuples<I, J>\n    where I: Iterator<Item=J>\n{\n    ConsTuples { iter: iterable.into_iter() }\n}\n","traces":[{"line":12,"address":[4709536,4709680],"length":1,"stats":{"Line":4},"fn_name":"next<i32,itertools::adaptors::Product<itertools::adaptors::Product<core::ops::range::Range<i32>, core::ops::range::Range<i32>>, core::ops::range::Range<i32>>,i32,i32>"},{"line":13,"address":[4709548,4709692,4709751,4709600,4709744,4709607],"length":1,"stats":{"Line":12},"fn_name":"{{closure}}<i32,itertools::adaptors::Product<itertools::adaptors::Product<core::ops::range::Range<i32>, core::ops::range::Range<i32>>, core::ops::range::Range<i32>>,i32,i32>"},{"line":16,"address":[4709648],"length":1,"stats":{"Line":2},"fn_name":"size_hint<i32,itertools::adaptors::Product<itertools::adaptors::Product<core::ops::range::Range<i32>, core::ops::range::Range<i32>>, core::ops::range::Range<i32>>,i32,i32>"},{"line":17,"address":[4709665],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[5057776],"length":1,"stats":{"Line":1},"fn_name":"fold<u16,itertools::adaptors::Product<itertools::adaptors::Product<quick::Iter<u16, quick::Inexact>, quick::Iter<u16, quick::Inexact>>, quick::Iter<u16, quick::Inexact>>,u16,u16,(),closure-1>"},{"line":22,"address":[5057914,5057872,5057791],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}<u16,itertools::adaptors::Product<itertools::adaptors::Product<quick::Iter<u16, quick::Inexact>, quick::Iter<u16, quick::Inexact>>, quick::Iter<u16, quick::Inexact>>,u16,u16,(),closure-1>"},{"line":60,"address":[4709952,4710064],"length":1,"stats":{"Line":4},"fn_name":"cons_tuples<itertools::adaptors::Product<itertools::cons_tuples_impl::ConsTuples<itertools::adaptors::Product<itertools::adaptors::Product<core::ops::range::Range<i32>, core::ops::range::Range<i32>>, core::ops::range::Range<i32>>, ((i32, i32), i32)>, core::ops::range::Range<i32>>,((i32, i32, i32), i32)>"},{"line":63,"address":[4710074,4709962],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":8,"coverable":8},{"path":["/","usr","src","itertools","src","diff.rs"],"content":"//! \"Diff\"ing iterators for caching elements to sequential collections without requiring the new\n//! elements' iterator to be `Clone`.\n//!\n//! - [**Diff**](./enum.Diff.html) (produced by the [**diff_with**](./fn.diff_with.html) function)\n//! describes the difference between two non-`Clone` iterators `I` and `J` after breaking ASAP from\n//! a lock-step comparison.\n\nuse crate::free::put_back;\nuse crate::structs::PutBack;\n\n/// A type returned by the [`diff_with`](./fn.diff_with.html) function.\n///\n/// `Diff` represents the way in which the elements yielded by the iterator `I` differ to some\n/// iterator `J`.\npub enum Diff<I, J>\n    where I: Iterator,\n          J: Iterator\n{\n    /// The index of the first non-matching element along with both iterator's remaining elements\n    /// starting with the first mis-match.\n    FirstMismatch(usize, PutBack<I>, PutBack<J>),\n    /// The total number of elements that were in `J` along with the remaining elements of `I`.\n    Shorter(usize, PutBack<I>),\n    /// The total number of elements that were in `I` along with the remaining elements of `J`.\n    Longer(usize, PutBack<J>),\n}\n\n/// Compares every element yielded by both `i` and `j` with the given function in lock-step and\n/// returns a `Diff` which describes how `j` differs from `i`.\n///\n/// If the number of elements yielded by `j` is less than the number of elements yielded by `i`,\n/// the number of `j` elements yielded will be returned along with `i`'s remaining elements as\n/// `Diff::Shorter`.\n///\n/// If the two elements of a step differ, the index of those elements along with the remaining\n/// elements of both `i` and `j` are returned as `Diff::FirstMismatch`.\n///\n/// If `i` becomes exhausted before `j` becomes exhausted, the number of elements in `i` along with\n/// the remaining `j` elements will be returned as `Diff::Longer`.\npub fn diff_with<I, J, F>(i: I, j: J, is_equal: F)\n    -> Option<Diff<I::IntoIter, J::IntoIter>>\n    where I: IntoIterator,\n          J: IntoIterator,\n          F: Fn(&I::Item, &J::Item) -> bool\n{\n    let mut i = i.into_iter();\n    let mut j = j.into_iter();\n    let mut idx = 0;\n    while let Some(i_elem) = i.next() {\n        match j.next() {\n            None => return Some(Diff::Shorter(idx, put_back(i).with_value(i_elem))),\n            Some(j_elem) => if !is_equal(&i_elem, &j_elem) {\n                let remaining_i = put_back(i).with_value(i_elem);\n                let remaining_j = put_back(j).with_value(j_elem);\n                return Some(Diff::FirstMismatch(idx, remaining_i, remaining_j));\n            },\n        }\n        idx += 1;\n    }\n    j.next().map(|j_elem| Diff::Longer(idx, put_back(j).with_value(j_elem)))\n}\n","traces":[{"line":40,"address":[5137565,5135584,5139136,5139341,5135789,5137360],"length":1,"stats":{"Line":3},"fn_name":"diff_with<core::slice::Iter<i32>,core::iter::adapters::Map<alloc::vec::IntoIter<f64>, closure-0>,closure-1>"},{"line":46,"address":[5139162,5135610,5137386],"length":1,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[5139374,5137506,5139282,5135822,5135730,5137598],"length":1,"stats":{"Line":6},"fn_name":null},{"line":48,"address":[5135830,5137606,5139382],"length":1,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[5139402,5137626,5135908,5137684,5140426,5138650,5136874,5135850,5139460],"length":1,"stats":{"Line":9},"fn_name":null},{"line":50,"address":[5137716,5137865,5135940,5139641,5136089,5139492],"length":1,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[5139643,5136091,5139529,5135977,5136156,5137867,5137753,5137932,5139708],"length":1,"stats":{"Line":5},"fn_name":null},{"line":52,"address":[5139552,5138120,5139896,5136000,5136344,5137776],"length":1,"stats":{"Line":6},"fn_name":null},{"line":53,"address":[5136363,5139915,5138139],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[5138217,5136441,5139993],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[5140099,5140353,5136801,5136547,5138323,5138577],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[5137294,5138590,5136814,5140366,5140846,5139070],"length":1,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[5141424,5141185,5141168,5136887,5141441,5138663,5140912,5140439,5140929],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}<core::slice::Iter<i32>,core::iter::adapters::Map<alloc::vec::IntoIter<f64>, closure-0>,closure-1>"}],"covered":13,"coverable":13},{"path":["/","usr","src","itertools","src","either_or_both.rs"],"content":"use crate::EitherOrBoth::*;\n\nuse either::Either;\n\n/// Value that either holds a single A or B, or both.\n#[derive(Clone, PartialEq, Eq, Hash, Debug)]\npub enum EitherOrBoth<A, B> {\n    /// Both values are present.\n    Both(A, B),\n    /// Only the left value of type `A` is present.\n    Left(A),\n    /// Only the right value of type `B` is present.\n    Right(B),\n}\n\nimpl<A, B> EitherOrBoth<A, B> {\n    /// If `Left`, or `Both`, return true, otherwise, return false.\n    pub fn has_left(&self) -> bool {\n        self.as_ref().left().is_some()\n    }\n\n    /// If `Right`, or `Both`, return true, otherwise, return false.\n    pub fn has_right(&self) -> bool {\n        self.as_ref().right().is_some()\n    }\n\n    /// If Left, return true otherwise, return false.\n    /// Exclusive version of [`has_left`].\n    pub fn is_left(&self) -> bool {\n        match *self {\n            Left(_) => true,\n            _ => false,\n        }\n    }\n\n    /// If Right, return true otherwise, return false.\n    /// Exclusive version of [`has_right`].\n    pub fn is_right(&self) -> bool {\n        match *self {\n            Right(_) => true,\n            _ => false,\n        }\n    }\n\n    /// If Right, return true otherwise, return false.\n    /// Equivalent to `self.as_ref().both().is_some()`.\n    pub fn is_both(&self) -> bool {\n        self.as_ref().both().is_some()\n    }\n\n    /// If `Left`, or `Both`, return `Some` with the left value, otherwise, return `None`.\n    pub fn left(self) -> Option<A> {\n        match self {\n            Left(left) | Both(left, _) => Some(left),\n            _ => None,\n        }\n    }\n\n    /// If `Right`, or `Both`, return `Some` with the right value, otherwise, return `None`.\n    pub fn right(self) -> Option<B> {\n        match self {\n            Right(right) | Both(_, right) => Some(right),\n            _ => None,\n        }\n    }\n\n    /// If Both, return `Some` tuple containing left and right.\n    pub fn both(self) -> Option<(A, B)> {\n        match self {\n            Both(a, b) => Some((a, b)),\n            _ => None,\n        }\n    }\n\n    /// Converts from `&EitherOrBoth<A, B>` to `EitherOrBoth<&A, &B>`.\n    pub fn as_ref(&self) -> EitherOrBoth<&A, &B> {\n        match *self {\n            Left(ref left) => Left(left),\n            Right(ref right) => Right(right),\n            Both(ref left, ref right) => Both(left, right),\n        }\n    }\n\n    /// Converts from `&mut EitherOrBoth<A, B>` to `EitherOrBoth<&mut A, &mut B>`.\n    pub fn as_mut(&mut self) -> EitherOrBoth<&mut A, &mut B> {\n        match *self {\n            Left(ref mut left) => Left(left),\n            Right(ref mut right) => Right(right),\n            Both(ref mut left, ref mut right) => Both(left, right),\n        }\n    }\n\n    /// Convert `EitherOrBoth<A, B>` to `EitherOrBoth<B, A>`.\n    pub fn flip(self) -> EitherOrBoth<B, A> {\n        match self {\n            Left(a) => Right(a),\n            Right(b) => Left(b),\n            Both(a, b) => Both(b, a),\n        }\n    }\n\n    /// Apply the function `f` on the value `a` in `Left(a)` or `Both(a, b)` variants. If it is\n    /// present rewrapping the result in `self`'s original variant.\n    pub fn map_left<F, M>(self, f: F) -> EitherOrBoth<M, B>\n    where\n        F: FnOnce(A) -> M,\n    {\n        match self {\n            Both(a, b) => Both(f(a), b),\n            Left(a) => Left(f(a)),\n            Right(b) => Right(b),\n        }\n    }\n\n    /// Apply the function `f` on the value `b` in `Right(b)` or `Both(a, b)` variants.\n    /// If it is present rewrapping the result in `self`'s original variant.\n    pub fn map_right<F, M>(self, f: F) -> EitherOrBoth<A, M>\n    where\n        F: FnOnce(B) -> M,\n    {\n        match self {\n            Left(a) => Left(a),\n            Right(b) => Right(f(b)),\n            Both(a, b) => Both(a, f(b)),\n        }\n    }\n\n    /// Apply the functions `f` and `g` on the value `a` and `b` respectively;\n    /// found in `Left(a)`, `Right(b)`, or `Both(a, b)` variants.\n    /// The Result is rewrapped `self`'s original variant.\n    pub fn map_any<F, L, G, R>(self, f: F, g: G) -> EitherOrBoth<L, R>\n    where\n        F: FnOnce(A) -> L,\n        G: FnOnce(B) -> R,\n    {\n        match self {\n            Left(a) => Left(f(a)),\n            Right(b) => Right(g(b)),\n            Both(a, b) => Both(f(a), g(b)),\n        }\n    }\n\n    /// Apply the function `f` on the value `b` in `Right(b)` or `Both(a, _)` variants if it is\n    /// present.\n    pub fn left_and_then<F, L>(self, f: F) -> EitherOrBoth<L, B>\n    where\n        F: FnOnce(A) -> EitherOrBoth<L, B>,\n    {\n        match self {\n            Left(a) | Both(a, _) => f(a),\n            Right(b) => Right(b),\n        }\n    }\n\n    /// Apply the function `f` on the value `a`\n    /// in `Left(a)` or `Both(a, _)` variants if it is present.\n    pub fn right_and_then<F, R>(self, f: F) -> EitherOrBoth<A, R>\n    where\n        F: FnOnce(B) -> EitherOrBoth<A, R>,\n    {\n        match self {\n            Left(a) => Left(a),\n            Right(b) | Both(_, b) => f(b),\n        }\n    }\n}\n\nimpl<T> EitherOrBoth<T, T> {\n    /// Return either value of left, right, or the product of `f` applied where `Both` are present.\n    pub fn reduce<F>(self, f: F) -> T\n    where\n        F: FnOnce(T, T) -> T,\n    {\n        match self {\n            Left(a) => a,\n            Right(b) => b,\n            Both(a, b) => f(a, b),\n        }\n    }\n}\n\nimpl<A, B> Into<Option<Either<A, B>>> for EitherOrBoth<A, B> {\n    fn into(self) -> Option<Either<A, B>> {\n        match self {\n            EitherOrBoth::Left(l) => Some(Either::Left(l)),\n            EitherOrBoth::Right(r) => Some(Either::Right(r)),\n            _ => None,\n        }\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":8,"coverable":68},{"path":["/","usr","src","itertools","src","exactly_one_err.rs"],"content":"use std::iter::ExactSizeIterator;\n\nuse crate::size_hint;\n\n/// Iterator returned for the error case of `IterTools::exactly_one()`\n/// This iterator yields exactly the same elements as the input iterator.\n///\n/// During the execution of exactly_one the iterator must be mutated.  This wrapper\n/// effectively \"restores\" the state of the input iterator when it's handed back.\n///\n/// This is very similar to PutBackN except this iterator only supports 0-2 elements and does not\n/// use a `Vec`.\n#[derive(Debug, Clone)]\npub struct ExactlyOneError<I>\nwhere\n    I: Iterator,\n{\n    first_two: (Option<I::Item>, Option<I::Item>),\n    inner: I,\n}\n\nimpl<I> ExactlyOneError<I>\nwhere\n    I: Iterator,\n{\n    /// Creates a new `ExactlyOneErr` iterator.\n    pub(crate) fn new(first_two: (Option<I::Item>, Option<I::Item>), inner: I) -> Self {\n        Self { first_two, inner }\n    }\n}\n\nimpl<I> Iterator for ExactlyOneError<I>\nwhere\n    I: Iterator,\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.first_two\n            .0\n            .take()\n            .or_else(|| self.first_two.1.take())\n            .or_else(|| self.inner.next())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let mut additional_len = 0;\n        if self.first_two.0.is_some() {\n            additional_len += 1;\n        }\n        if self.first_two.1.is_some() {\n            additional_len += 1;\n        }\n        size_hint::add_scalar(self.inner.size_hint(), additional_len)\n    }\n}\n\nimpl<I> ExactSizeIterator for ExactlyOneError<I> where I: ExactSizeIterator {}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[4301497,4301545,4301038,4301632,4301536,4301166,4301294,4301488,4301641],"length":1,"stats":{"Line":12},"fn_name":"{{closure}}<core::iter::adapters::Filter<core::ops::range::Range<i32>, closure-3>>"},{"line":43,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":5,"coverable":13},{"path":["/","usr","src","itertools","src","format.rs"],"content":"use std::fmt;\nuse std::cell::RefCell;\n\n/// Format all iterator elements lazily, separated by `sep`.\n///\n/// The format value can only be formatted once, after that the iterator is\n/// exhausted.\n///\n/// See [`.format_with()`](../trait.Itertools.html#method.format_with) for more information.\n#[derive(Clone)]\npub struct FormatWith<'a, I, F> {\n    sep: &'a str,\n    /// FormatWith uses interior mutability because Display::fmt takes &self.\n    inner: RefCell<Option<(I, F)>>,\n}\n\n/// Format all iterator elements lazily, separated by `sep`.\n///\n/// The format value can only be formatted once, after that the iterator is\n/// exhausted.\n///\n/// See [`.format()`](../trait.Itertools.html#method.format)\n/// for more information.\n#[derive(Clone)]\npub struct Format<'a, I> {\n    sep: &'a str,\n    /// Format uses interior mutability because Display::fmt takes &self.\n    inner: RefCell<Option<I>>,\n}\n\npub fn new_format<'a, I, F>(iter: I, separator: &'a str, f: F) -> FormatWith<'a, I, F>\n    where I: Iterator,\n          F: FnMut(I::Item, &mut dyn FnMut(&dyn fmt::Display) -> fmt::Result) -> fmt::Result\n{\n    FormatWith {\n        sep: separator,\n        inner: RefCell::new(Some((iter, f))),\n    }\n}\n\npub fn new_format_default<'a, I>(iter: I, separator: &'a str) -> Format<'a, I>\n    where I: Iterator,\n{\n    Format {\n        sep: separator,\n        inner: RefCell::new(Some(iter)),\n    }\n}\n\nimpl<'a, I, F> fmt::Display for FormatWith<'a, I, F>\n    where I: Iterator,\n          F: FnMut(I::Item, &mut dyn  FnMut(&dyn fmt::Display) -> fmt::Result) -> fmt::Result\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let (mut iter, mut format) = match self.inner.borrow_mut().take() {\n            Some(t) => t,\n            None => panic!(\"FormatWith: was already formatted once\"),\n        };\n\n        if let Some(fst) = iter.next() {\n            format(fst, &mut |disp: &dyn fmt::Display| disp.fmt(f))?;\n            for elt in iter {\n                if self.sep.len() > 0 {\n\n                    f.write_str(self.sep)?;\n                }\n                format(elt, &mut |disp: &dyn fmt::Display| disp.fmt(f))?;\n            }\n        }\n        Ok(())\n    }\n}\n\nimpl<'a, I> Format<'a, I>\n    where I: Iterator,\n{\n    fn format<F>(&self, f: &mut fmt::Formatter, mut cb: F) -> fmt::Result\n        where F: FnMut(&I::Item, &mut fmt::Formatter) -> fmt::Result,\n    {\n        let mut iter = match self.inner.borrow_mut().take() {\n            Some(t) => t,\n            None => panic!(\"Format: was already formatted once\"),\n        };\n\n        if let Some(fst) = iter.next() {\n            cb(&fst, f)?;\n            for elt in iter {\n                if self.sep.len() > 0 {\n                    f.write_str(self.sep)?;\n                }\n                cb(&elt, f)?;\n            }\n        }\n        Ok(())\n    }\n}\n\nmacro_rules! impl_format {\n    ($($fmt_trait:ident)*) => {\n        $(\n            impl<'a, I> fmt::$fmt_trait for Format<'a, I>\n                where I: Iterator,\n                      I::Item: fmt::$fmt_trait,\n            {\n                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                    self.format(f, fmt::$fmt_trait::fmt)\n                }\n            }\n        )*\n    }\n}\n\nimpl_format!{Display Debug\n             UpperExp LowerExp UpperHex LowerHex Octal Binary Pointer}\n","traces":[{"line":41,"address":[4896400,4896256],"length":1,"stats":{"Line":2},"fn_name":"new_format_default<core::slice::Iter<f64>>"},{"line":46,"address":[4896283,4896427],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[4891696,4894820,4893216,4891780,4894736,4893300],"length":1,"stats":{"Line":3},"fn_name":"format<core::slice::Iter<i32>,fn(&&i32, &mut core::fmt::Formatter) -> core::result::Result<(), core::fmt::Error>>"},{"line":80,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[4891552,4891600,4891648],"length":1,"stats":{"Line":3},"fn_name":"fmt<core::slice::Iter<i32>>"},{"line":106,"address":[4891566,4891614,4891662],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":14,"coverable":26},{"path":["/","usr","src","itertools","src","free.rs"],"content":"//! Free functions that create iterator adaptors or call iterator methods.\n//!\n//! The benefit of free functions is that they accept any `IntoIterator` as\n//! argument, so the resulting code may be easier to read.\n\n#[cfg(feature = \"use_std\")]\nuse std::fmt::Display;\nuse std::iter::{self, Zip};\n#[cfg(feature = \"use_std\")]\ntype VecIntoIter<T> = ::std::vec::IntoIter<T>;\n\n#[cfg(feature = \"use_std\")]\nuse crate::Itertools;\n\npub use crate::adaptors::{\n    interleave,\n    merge,\n    put_back,\n};\n#[cfg(feature = \"use_std\")]\npub use crate::put_back_n_impl::put_back_n;\n#[cfg(feature = \"use_std\")]\npub use crate::multipeek_impl::multipeek;\n#[cfg(feature = \"use_std\")]\npub use crate::peek_nth::peek_nth;\n#[cfg(feature = \"use_std\")]\npub use crate::kmerge_impl::kmerge;\npub use crate::zip_eq_impl::zip_eq;\npub use crate::merge_join::merge_join_by;\n#[cfg(feature = \"use_std\")]\npub use crate::rciter_impl::rciter;\n\n/// Iterate `iterable` with a running index.\n///\n/// `IntoIterator` enabled version of `.enumerate()`.\n///\n/// ```\n/// use itertools::enumerate;\n///\n/// for (i, elt) in enumerate(&[1, 2, 3]) {\n///     /* loop body */\n/// }\n/// ```\npub fn enumerate<I>(iterable: I) -> iter::Enumerate<I::IntoIter>\n    where I: IntoIterator\n{\n    iterable.into_iter().enumerate()\n}\n\n/// Iterate `iterable` in reverse.\n///\n/// `IntoIterator` enabled version of `.rev()`.\n///\n/// ```\n/// use itertools::rev;\n///\n/// for elt in rev(&[1, 2, 3]) {\n///     /* loop body */\n/// }\n/// ```\npub fn rev<I>(iterable: I) -> iter::Rev<I::IntoIter>\n    where I: IntoIterator,\n          I::IntoIter: DoubleEndedIterator\n{\n    iterable.into_iter().rev()\n}\n\n/// Iterate `i` and `j` in lock step.\n///\n/// `IntoIterator` enabled version of `i.zip(j)`.\n///\n/// ```\n/// use itertools::zip;\n///\n/// let data = [1, 2, 3, 4, 5];\n/// for (a, b) in zip(&data, &data[1..]) {\n///     /* loop body */\n/// }\n/// ```\npub fn zip<I, J>(i: I, j: J) -> Zip<I::IntoIter, J::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator\n{\n    i.into_iter().zip(j)\n}\n\n/// Create an iterator that first iterates `i` and then `j`.\n///\n/// `IntoIterator` enabled version of `i.chain(j)`.\n///\n/// ```\n/// use itertools::chain;\n///\n/// for elt in chain(&[1, 2, 3], &[4]) {\n///     /* loop body */\n/// }\n/// ```\npub fn chain<I, J>(i: I, j: J) -> iter::Chain<<I as IntoIterator>::IntoIter, <J as IntoIterator>::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator<Item = I::Item>\n{\n    i.into_iter().chain(j)\n}\n\n/// Create an iterator that clones each element from &T to T\n///\n/// `IntoIterator` enabled version of `i.cloned()`.\n///\n/// ```\n/// use itertools::cloned;\n///\n/// assert_eq!(cloned(b\"abc\").next(), Some(b'a'));\n/// ```\npub fn cloned<'a, I, T: 'a>(iterable: I) -> iter::Cloned<I::IntoIter>\n    where I: IntoIterator<Item=&'a T>,\n          T: Clone,\n{\n    iterable.into_iter().cloned()\n}\n\n/// Perform a fold operation over the iterable.\n///\n/// `IntoIterator` enabled version of `i.fold(init, f)`\n///\n/// ```\n/// use itertools::fold;\n///\n/// assert_eq!(fold(&[1., 2., 3.], 0., |a, &b| f32::max(a, b)), 3.);\n/// ```\npub fn fold<I, B, F>(iterable: I, init: B, f: F) -> B\n    where I: IntoIterator,\n          F: FnMut(B, I::Item) -> B\n{\n    iterable.into_iter().fold(init, f)\n}\n\n/// Test whether the predicate holds for all elements in the iterable.\n///\n/// `IntoIterator` enabled version of `i.all(f)`\n///\n/// ```\n/// use itertools::all;\n///\n/// assert!(all(&[1, 2, 3], |elt| *elt > 0));\n/// ```\npub fn all<I, F>(iterable: I, f: F) -> bool\n    where I: IntoIterator,\n          F: FnMut(I::Item) -> bool\n{\n    iterable.into_iter().all(f)\n}\n\n/// Test whether the predicate holds for any elements in the iterable.\n///\n/// `IntoIterator` enabled version of `i.any(f)`\n///\n/// ```\n/// use itertools::any;\n///\n/// assert!(any(&[0, -1, 2], |elt| *elt > 0));\n/// ```\npub fn any<I, F>(iterable: I, f: F) -> bool\n    where I: IntoIterator,\n          F: FnMut(I::Item) -> bool\n{\n    iterable.into_iter().any(f)\n}\n\n/// Return the maximum value of the iterable.\n///\n/// `IntoIterator` enabled version of `i.max()`.\n///\n/// ```\n/// use itertools::max;\n///\n/// assert_eq!(max(0..10), Some(9));\n/// ```\npub fn max<I>(iterable: I) -> Option<I::Item>\n    where I: IntoIterator,\n          I::Item: Ord\n{\n    iterable.into_iter().max()\n}\n\n/// Return the minimum value of the iterable.\n///\n/// `IntoIterator` enabled version of `i.min()`.\n///\n/// ```\n/// use itertools::min;\n///\n/// assert_eq!(min(0..10), Some(0));\n/// ```\npub fn min<I>(iterable: I) -> Option<I::Item>\n    where I: IntoIterator,\n          I::Item: Ord\n{\n    iterable.into_iter().min()\n}\n\n\n/// Combine all iterator elements into one String, seperated by `sep`.\n///\n/// `IntoIterator` enabled version of `iterable.join(sep)`.\n///\n/// ```\n/// use itertools::join;\n///\n/// assert_eq!(join(&[1, 2, 3], \", \"), \"1, 2, 3\");\n/// ```\n#[cfg(feature = \"use_std\")]\npub fn join<I>(iterable: I, sep: &str) -> String\n    where I: IntoIterator,\n          I::Item: Display\n{\n    iterable.into_iter().join(sep)\n}\n\n/// Sort all iterator elements into a new iterator in ascending order.\n///\n/// `IntoIterator` enabled version of [`iterable.sorted()`][1].\n///\n/// [1]: trait.Itertools.html#method.sorted\n///\n/// ```\n/// use itertools::sorted;\n/// use itertools::assert_equal;\n///\n/// assert_equal(sorted(\"rust\".chars()), \"rstu\".chars());\n/// ```\n#[cfg(feature = \"use_std\")]\npub fn sorted<I>(iterable: I) -> VecIntoIter<I::Item>\n    where I: IntoIterator,\n          I::Item: Ord\n{\n    iterable.into_iter().sorted()\n}\n\n","traces":[{"line":44,"address":[5080976],"length":1,"stats":{"Line":1},"fn_name":"enumerate<&alloc::vec::Vec<u8>>"},{"line":47,"address":[5080993],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[5080787,5080672],"length":1,"stats":{"Line":1},"fn_name":"zip<&[i32],&[i32]>"},{"line":84,"address":[5080699],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[4683488],"length":1,"stats":{"Line":3},"fn_name":"cloned<&[i32; 4],i32>"},{"line":118,"address":[4683497],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","usr","src","itertools","src","group_map.rs"],"content":"#![cfg(feature = \"use_std\")]\n\nuse std::collections::HashMap;\nuse std::hash::Hash;\nuse std::iter::Iterator;\n\n/// Return a `HashMap` of keys mapped to a list of their corresponding values.\n///\n/// See [`.into_group_map()`](../trait.Itertools.html#method.into_group_map)\n/// for more information.\npub fn into_group_map<I, K, V>(iter: I) -> HashMap<K, Vec<V>>\n    where I: Iterator<Item=(K, V)>,\n          K: Hash + Eq,\n{\n    let mut lookup = HashMap::new();\n\n    for (key, val) in iter {\n        lookup.entry(key).or_insert(Vec::new()).push(val);\n    }\n\n    lookup\n}","traces":[{"line":11,"address":[5806752,5806832],"length":1,"stats":{"Line":1},"fn_name":"into_group_map<core::iter::adapters::Map<alloc::vec::IntoIter<u8>, closure-0>,u8,u8>"},{"line":15,"address":[5806762],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[5806847,5806957,5807124,5807345],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[5807116,5807180,5807483,5807221],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","usr","src","itertools","src","groupbylazy.rs"],"content":"use std::cell::{Cell, RefCell};\nuse std::vec;\n\n/// A trait to unify FnMut for GroupBy with the chunk key in IntoChunks\ntrait KeyFunction<A> {\n    type Key;\n    fn call_mut(&mut self, arg: A) -> Self::Key;\n}\n\nimpl<'a, A, K, F: ?Sized> KeyFunction<A> for F\n    where F: FnMut(A) -> K\n{\n    type Key = K;\n    #[inline]\n    fn call_mut(&mut self, arg: A) -> Self::Key {\n        (*self)(arg)\n    }\n}\n\n\n/// ChunkIndex acts like the grouping key function for IntoChunks\n#[derive(Debug)]\nstruct ChunkIndex {\n    size: usize,\n    index: usize,\n    key: usize,\n}\n\nimpl ChunkIndex {\n    #[inline(always)]\n    fn new(size: usize) -> Self {\n        ChunkIndex {\n            size,\n            index: 0,\n            key: 0,\n        }\n    }\n}\n\nimpl<'a, A> KeyFunction<A> for ChunkIndex {\n    type Key = usize;\n    #[inline(always)]\n    fn call_mut(&mut self, _arg: A) -> Self::Key {\n        if self.index == self.size {\n            self.key += 1;\n            self.index = 0;\n        }\n        self.index += 1;\n        self.key\n    }\n}\n\n\nstruct GroupInner<K, I, F>\n    where I: Iterator\n{\n    key: F,\n    iter: I,\n    current_key: Option<K>,\n    current_elt: Option<I::Item>,\n    /// flag set if iterator is exhausted\n    done: bool,\n    /// Index of group we are currently buffering or visiting\n    top_group: usize,\n    /// Least index for which we still have elements buffered\n    oldest_buffered_group: usize,\n    /// Group index for `buffer[0]` -- the slots\n    /// bottom_group..oldest_buffered_group are unused and will be erased when\n    /// that range is large enough.\n    bottom_group: usize,\n    /// Buffered groups, from `bottom_group` (index 0) to `top_group`.\n    buffer: Vec<vec::IntoIter<I::Item>>,\n    /// index of last group iter that was dropped, usize::MAX == none\n    dropped_group: usize,\n}\n\nimpl<K, I, F> GroupInner<K, I, F>\n    where I: Iterator,\n          F: for<'a> KeyFunction<&'a I::Item, Key=K>,\n          K: PartialEq,\n{\n    /// `client`: Index of group that requests next element\n    #[inline(always)]\n    fn step(&mut self, client: usize) -> Option<I::Item> {\n        /*\n        println!(\"client={}, bottom_group={}, oldest_buffered_group={}, top_group={}, buffers=[{}]\",\n                 client, self.bottom_group, self.oldest_buffered_group,\n                 self.top_group,\n                 self.buffer.iter().map(|elt| elt.len()).format(\", \"));\n        */\n        if client < self.oldest_buffered_group {\n            None\n        } else if client < self.top_group ||\n            (client == self.top_group &&\n             self.buffer.len() > self.top_group - self.bottom_group)\n        {\n            self.lookup_buffer(client)\n        } else if self.done {\n            None\n        } else if self.top_group == client {\n            self.step_current()\n        } else {\n            self.step_buffering(client)\n        }\n    }\n\n    #[inline(never)]\n    fn lookup_buffer(&mut self, client: usize) -> Option<I::Item> {\n        // if `bufidx` doesn't exist in self.buffer, it might be empty\n        let bufidx = client - self.bottom_group;\n        if client < self.oldest_buffered_group {\n            return None;\n        }\n        let elt = self.buffer.get_mut(bufidx).and_then(|queue| queue.next());\n        if elt.is_none() && client == self.oldest_buffered_group {\n            // FIXME: VecDeque is unfortunately not zero allocation when empty,\n            // so we do this job manually.\n            // `bottom_group..oldest_buffered_group` is unused, and if it's large enough, erase it.\n            self.oldest_buffered_group += 1;\n            // skip forward further empty queues too\n            while self.buffer.get(self.oldest_buffered_group - self.bottom_group)\n                             .map_or(false, |buf| buf.len() == 0)\n            {\n                self.oldest_buffered_group += 1;\n            }\n\n            let nclear = self.oldest_buffered_group - self.bottom_group;\n            if nclear > 0 && nclear >= self.buffer.len() / 2 {\n                let mut i = 0;\n                self.buffer.retain(|buf| {\n                    i += 1;\n                    debug_assert!(buf.len() == 0 || i > nclear);\n                    i > nclear\n                });\n                self.bottom_group = self.oldest_buffered_group;\n            }\n        }\n        elt\n    }\n\n    /// Take the next element from the iterator, and set the done\n    /// flag if exhausted. Must not be called after done.\n    #[inline(always)]\n    fn next_element(&mut self) -> Option<I::Item> {\n        debug_assert!(!self.done);\n        match self.iter.next() {\n            None => { self.done = true; None }\n            otherwise => otherwise,\n        }\n    }\n\n\n    #[inline(never)]\n    fn step_buffering(&mut self, client: usize) -> Option<I::Item> {\n        // requested a later group -- walk through the current group up to\n        // the requested group index, and buffer the elements (unless\n        // the group is marked as dropped).\n        // Because the `Groups` iterator is always the first to request\n        // each group index, client is the next index efter top_group.\n        debug_assert!(self.top_group + 1 == client);\n        let mut group = Vec::new();\n\n        if let Some(elt) = self.current_elt.take() {\n            if self.top_group != self.dropped_group {\n                group.push(elt);\n            }\n        }\n        let mut first_elt = None; // first element of the next group\n\n        while let Some(elt) = self.next_element() {\n            let key = self.key.call_mut(&elt);\n            match self.current_key.take() {\n                None => {}\n                Some(old_key) => if old_key != key {\n                    self.current_key = Some(key);\n                    first_elt = Some(elt);\n                    break;\n                },\n            }\n            self.current_key = Some(key);\n            if self.top_group != self.dropped_group {\n                group.push(elt);\n            }\n        }\n\n        if self.top_group != self.dropped_group {\n            self.push_next_group(group);\n        }\n        if first_elt.is_some() {\n            self.top_group += 1;\n            debug_assert!(self.top_group == client);\n        }\n        first_elt\n    }\n\n    fn push_next_group(&mut self, group: Vec<I::Item>) {\n        // When we add a new buffered group, fill up slots between oldest_buffered_group and top_group\n        while self.top_group - self.bottom_group > self.buffer.len() {\n            if self.buffer.is_empty() {\n                self.bottom_group += 1;\n                self.oldest_buffered_group += 1;\n            } else {\n                self.buffer.push(Vec::new().into_iter());\n            }\n        }\n        self.buffer.push(group.into_iter());\n        debug_assert!(self.top_group + 1 - self.bottom_group == self.buffer.len());\n    }\n\n    /// This is the immediate case, where we use no buffering\n    #[inline]\n    fn step_current(&mut self) -> Option<I::Item> {\n        debug_assert!(!self.done);\n        if let elt @ Some(..) = self.current_elt.take() {\n            return elt;\n        }\n        match self.next_element() {\n            None => None,\n            Some(elt) => {\n                let key = self.key.call_mut(&elt);\n                match self.current_key.take() {\n                    None => {}\n                    Some(old_key) => if old_key != key {\n                        self.current_key = Some(key);\n                        self.current_elt = Some(elt);\n                        self.top_group += 1;\n                        return None;\n                    },\n                }\n                self.current_key = Some(key);\n                Some(elt)\n            }\n        }\n    }\n\n    /// Request the just started groups' key.\n    ///\n    /// `client`: Index of group\n    ///\n    /// **Panics** if no group key is available.\n    fn group_key(&mut self, client: usize) -> K {\n        // This can only be called after we have just returned the first\n        // element of a group.\n        // Perform this by simply buffering one more element, grabbing the\n        // next key.\n        debug_assert!(!self.done);\n        debug_assert!(client == self.top_group);\n        debug_assert!(self.current_key.is_some());\n        debug_assert!(self.current_elt.is_none());\n        let old_key = self.current_key.take().unwrap();\n        if let Some(elt) = self.next_element() {\n            let key = self.key.call_mut(&elt);\n            if old_key != key {\n                self.top_group += 1;\n            }\n            self.current_key = Some(key);\n            self.current_elt = Some(elt);\n        }\n        old_key\n    }\n}\n\nimpl<K, I, F> GroupInner<K, I, F>\n    where I: Iterator,\n{\n    /// Called when a group is dropped\n    fn drop_group(&mut self, client: usize) {\n        // It's only useful to track the maximal index\n        if self.dropped_group == !0 || client > self.dropped_group {\n            self.dropped_group = client;\n        }\n    }\n}\n\n/// `GroupBy` is the storage for the lazy grouping operation.\n///\n/// If the groups are consumed in their original order, or if each\n/// group is dropped without keeping it around, then `GroupBy` uses\n/// no allocations. It needs allocations only if several group iterators\n/// are alive at the same time.\n///\n/// This type implements `IntoIterator` (it is **not** an iterator\n/// itself), because the group iterators need to borrow from this\n/// value. It should be stored in a local variable or temporary and\n/// iterated.\n///\n/// See [`.group_by()`](../trait.Itertools.html#method.group_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct GroupBy<K, I, F>\n    where I: Iterator,\n{\n    inner: RefCell<GroupInner<K, I, F>>,\n    // the group iterator's current index. Keep this in the main value\n    // so that simultaneous iterators all use the same state.\n    index: Cell<usize>,\n}\n\n/// Create a new\npub fn new<K, J, F>(iter: J, f: F) -> GroupBy<K, J::IntoIter, F>\n    where J: IntoIterator,\n          F: FnMut(&J::Item) -> K,\n{\n    GroupBy {\n        inner: RefCell::new(GroupInner {\n            key: f,\n            iter: iter.into_iter(),\n            current_key: None,\n            current_elt: None,\n            done: false,\n            top_group: 0,\n            oldest_buffered_group: 0,\n            bottom_group: 0,\n            buffer: Vec::new(),\n            dropped_group: !0,\n        }),\n        index: Cell::new(0),\n    }\n}\n\nimpl<K, I, F> GroupBy<K, I, F>\n    where I: Iterator,\n{\n    /// `client`: Index of group that requests next element\n    fn step(&self, client: usize) -> Option<I::Item>\n        where F: FnMut(&I::Item) -> K,\n              K: PartialEq,\n    {\n        self.inner.borrow_mut().step(client)\n    }\n\n    /// `client`: Index of group\n    fn drop_group(&self, client: usize) {\n        self.inner.borrow_mut().drop_group(client)\n    }\n}\n\nimpl<'a, K, I, F> IntoIterator for &'a GroupBy<K, I, F>\n    where I: Iterator,\n          I::Item: 'a,\n          F: FnMut(&I::Item) -> K,\n          K: PartialEq\n{\n    type Item = (K, Group<'a, K, I, F>);\n    type IntoIter = Groups<'a, K, I, F>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        Groups { parent: self }\n    }\n}\n\n\n/// An iterator that yields the Group iterators.\n///\n/// Iterator element type is `(K, Group)`:\n/// the group's key `K` and the group's iterator.\n///\n/// See [`.group_by()`](../trait.Itertools.html#method.group_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Groups<'a, K: 'a, I: 'a, F: 'a>\n    where I: Iterator,\n          I::Item: 'a\n{\n    parent: &'a GroupBy<K, I, F>,\n}\n\nimpl<'a, K, I, F> Iterator for Groups<'a, K, I, F>\n    where I: Iterator,\n          I::Item: 'a,\n          F: FnMut(&I::Item) -> K,\n          K: PartialEq\n{\n    type Item = (K, Group<'a, K, I, F>);\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let index = self.parent.index.get();\n        self.parent.index.set(index + 1);\n        let inner = &mut *self.parent.inner.borrow_mut();\n        inner.step(index).map(|elt| {\n            let key = inner.group_key(index);\n            (key, Group {\n                parent: self.parent,\n                index,\n                first: Some(elt),\n            })\n        })\n    }\n}\n\n/// An iterator for the elements in a single group.\n///\n/// Iterator element type is `I::Item`.\npub struct Group<'a, K: 'a, I: 'a, F: 'a>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    parent: &'a GroupBy<K, I, F>,\n    index: usize,\n    first: Option<I::Item>,\n}\n\nimpl<'a, K, I, F> Drop for Group<'a, K, I, F>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    fn drop(&mut self) {\n        self.parent.drop_group(self.index);\n    }\n}\n\nimpl<'a, K, I, F> Iterator for Group<'a, K, I, F>\n    where I: Iterator,\n          I::Item: 'a,\n          F: FnMut(&I::Item) -> K,\n          K: PartialEq,\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        if let elt @ Some(..) = self.first.take() {\n            return elt;\n        }\n        self.parent.step(self.index)\n    }\n}\n\n///// IntoChunks /////\n\n/// Create a new\npub fn new_chunks<J>(iter: J, size: usize) -> IntoChunks<J::IntoIter>\n    where J: IntoIterator,\n{\n    IntoChunks {\n        inner: RefCell::new(GroupInner {\n            key: ChunkIndex::new(size),\n            iter: iter.into_iter(),\n            current_key: None,\n            current_elt: None,\n            done: false,\n            top_group: 0,\n            oldest_buffered_group: 0,\n            bottom_group: 0,\n            buffer: Vec::new(),\n            dropped_group: !0,\n        }),\n        index: Cell::new(0),\n    }\n}\n\n\n/// `ChunkLazy` is the storage for a lazy chunking operation.\n///\n/// `IntoChunks` behaves just like `GroupBy`: it is iterable, and\n/// it only buffers if several chunk iterators are alive at the same time.\n///\n/// This type implements `IntoIterator` (it is **not** an iterator\n/// itself), because the chunk iterators need to borrow from this\n/// value. It should be stored in a local variable or temporary and\n/// iterated.\n///\n/// Iterator element type is `Chunk`, each chunk's iterator.\n///\n/// See [`.chunks()`](../trait.Itertools.html#method.chunks) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct IntoChunks<I>\n    where I: Iterator,\n{\n    inner: RefCell<GroupInner<usize, I, ChunkIndex>>,\n    // the chunk iterator's current index. Keep this in the main value\n    // so that simultaneous iterators all use the same state.\n    index: Cell<usize>,\n}\n\n\nimpl<I> IntoChunks<I>\n    where I: Iterator,\n{\n    /// `client`: Index of chunk that requests next element\n    fn step(&self, client: usize) -> Option<I::Item> {\n        self.inner.borrow_mut().step(client)\n    }\n\n    /// `client`: Index of chunk\n    fn drop_group(&self, client: usize) {\n        self.inner.borrow_mut().drop_group(client)\n    }\n}\n\nimpl<'a, I> IntoIterator for &'a IntoChunks<I>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    type Item = Chunk<'a, I>;\n    type IntoIter = Chunks<'a, I>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        Chunks {\n            parent: self,\n        }\n    }\n}\n\n\n/// An iterator that yields the Chunk iterators.\n///\n/// Iterator element type is `Chunk`.\n///\n/// See [`.chunks()`](../trait.Itertools.html#method.chunks) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Chunks<'a, I: 'a>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    parent: &'a IntoChunks<I>,\n}\n\nimpl<'a, I> Iterator for Chunks<'a, I>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    type Item = Chunk<'a, I>;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let index = self.parent.index.get();\n        self.parent.index.set(index + 1);\n        let inner = &mut *self.parent.inner.borrow_mut();\n        inner.step(index).map(|elt| {\n            Chunk {\n                parent: self.parent,\n                index,\n                first: Some(elt),\n            }\n        })\n    }\n}\n\n/// An iterator for the elements in a single chunk.\n///\n/// Iterator element type is `I::Item`.\npub struct Chunk<'a, I: 'a>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    parent: &'a IntoChunks<I>,\n    index: usize,\n    first: Option<I::Item>,\n}\n\nimpl<'a, I> Drop for Chunk<'a, I>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    fn drop(&mut self) {\n        self.parent.drop_group(self.index);\n    }\n}\n\nimpl<'a, I> Iterator for Chunk<'a, I>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        if let elt @ Some(..) = self.first.take() {\n            return elt;\n        }\n        self.parent.step(self.index)\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":79},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":74},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":83},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":121},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":73},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":168,"address":[4807963,4820580,4831467,4816948,4815165,4833649,4822349,4824132,4809757,4811595,4825901,4813389,4827738,4829611,4818779],"length":1,"stats":{"Line":10},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":57},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":299,"address":[4863796,4866064,4864640,4864273,4861360,4860400,4865600,4861014,4865233,4862288,4861476,4860033,4865718,4863680,4862406,4866180,4860896,4863216,4861824,4864144,4864758,4865104,4861940,4862752,4862870,4860528,4863332,4859904],"length":1,"stats":{"Line":18},"fn_name":"new<char,core::str::Chars,&closure-2>"},{"line":304,"address":[4865257,4862430,4865742,4860057,4861500,4863356,4863820,4864297,4864782,4866204,4860551,4861038,4862894,4861964],"length":1,"stats":{"Line":18},"fn_name":null},{"line":316,"address":[4865454,4865930,4862148,4861226,4860763,4861684,4862618,4863082,4863540,4864004,4864970,4866388,4860254,4864494],"length":1,"stats":{"Line":18},"fn_name":null},{"line":324,"address":[4770004,4767792,4770928,4767831,4765808,4764820,4768336,4768880,4770964,4770484,4770448,4766352,4766832,4765303,4766868,4767312,4768375,4765847,4767348,4765264,4768919,4769463,4764784,4766388,4769424,4769968],"length":1,"stats":{"Line":17},"fn_name":"step<char,core::str::Chars,&closure-2>"},{"line":328,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":430,"address":[4761696,4761808],"length":1,"stats":{"Line":2},"fn_name":"new_chunks<core::slice::Iter<i32>>"},{"line":434,"address":[4761730,4761922],"length":1,"stats":{"Line":4},"fn_name":null},{"line":446,"address":[4762145],"length":1,"stats":{"Line":2},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":150,"coverable":157},{"path":["/","usr","src","itertools","src","impl_macros.rs"],"content":"//! \n//! Implementation's internal macros\n\nmacro_rules! debug_fmt_fields {\n    ($tyname:ident, $($($field:ident).+),*) => {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            f.debug_struct(stringify!($tyname))\n                $(\n              .field(stringify!($($field).+), &self.$($field).+)\n              )*\n              .finish()\n        }\n    }\n}\n\nmacro_rules! clone_fields {\n    ($($field:ident),*) => {\n        fn clone(&self) -> Self {\n            Self {\n                $($field: self.$field.clone(),)*\n            }\n        }\n    }\n}\n","traces":[{"line":18,"address":[4391328,4391280],"length":1,"stats":{"Line":5},"fn_name":"clone<core::iter::adapters::Cloned<core::slice::Iter<i32>>>"},{"line":19,"address":[4391302,4391350],"length":1,"stats":{"Line":5},"fn_name":null},{"line":20,"address":[4391289,4391337],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","usr","src","itertools","src","intersperse.rs"],"content":"use std::iter::Fuse;\nuse super::size_hint;\n\n#[derive(Clone)]\n/// An iterator adaptor to insert a particular value\n/// between each element of the adapted iterator.\n///\n/// Iterator element type is `I::Item`\n///\n/// This iterator is *fused*.\n///\n/// See [`.intersperse()`](../trait.Itertools.html#method.intersperse) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Debug)]\npub struct Intersperse<I>\n    where I: Iterator\n{\n    element: I::Item,\n    iter: Fuse<I>,\n    peek: Option<I::Item>,\n}\n\n/// Create a new Intersperse iterator\npub fn intersperse<I>(iter: I, elt: I::Item) -> Intersperse<I>\n    where I: Iterator\n{\n    let mut iter = iter.fuse();\n    Intersperse {\n        peek: iter.next(),\n        iter,\n        element: elt,\n    }\n}\n\nimpl<I> Iterator for Intersperse<I>\n    where I: Iterator,\n          I::Item: Clone\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.peek.is_some() {\n            self.peek.take()\n        } else {\n            self.peek = self.iter.next();\n            if self.peek.is_some() {\n                Some(self.element.clone())\n            } else {\n                None\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // 2 * SH + { 1 or 0 }\n        let has_peek = self.peek.is_some() as usize;\n        let sh = self.iter.size_hint();\n        size_hint::add_scalar(size_hint::add(sh, sh), has_peek)\n    }\n\n    fn fold<B, F>(mut self, init: B, mut f: F) -> B where\n        Self: Sized, F: FnMut(B, Self::Item) -> B,\n    {\n        let mut accum = init;\n        \n        if let Some(x) = self.peek.take() {\n            accum = f(accum, x);\n        }\n\n        let element = &self.element;\n\n        self.iter.fold(accum,\n            |accum, x| {\n                let accum = f(accum, element.clone());\n                let accum = f(accum, x);\n                accum\n        })\n    }\n}\n","traces":[{"line":24,"address":[5032979,5033201,5032864,5033104],"length":1,"stats":{"Line":5},"fn_name":"intersperse<core::iter::adapters::Map<core::slice::Iter<&str>, closure-0>>"},{"line":27,"address":[4215453],"length":1,"stats":{"Line":5},"fn_name":null},{"line":29,"address":[5032962,5033187],"length":1,"stats":{"Line":5},"fn_name":null},{"line":41,"address":[4214608],"length":1,"stats":{"Line":5},"fn_name":"next<core::ops::range::Range<i32>>"},{"line":42,"address":[4214617,4214707,4214761],"length":1,"stats":{"Line":14},"fn_name":null},{"line":43,"address":[4214687],"length":1,"stats":{"Line":4},"fn_name":null},{"line":45,"address":[5032397,5032487,5032114,5032241,5032338,5032159],"length":1,"stats":{"Line":15},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[4214718],"length":1,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[5032607],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[4213616,4213315,4213248,4212880,4212947,4213683],"length":1,"stats":{"Line":3},"fn_name":"fold<core::ops::range::Range<i32>,(),closure-0>"},{"line":64,"address":[4213260,4213628,4212892],"length":1,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":23,"coverable":24},{"path":["/","usr","src","itertools","src","kmerge_impl.rs"],"content":"use crate::size_hint;\nuse crate::Itertools;\n\nuse std::mem::replace;\nuse std::fmt;\n\n/// Head element and Tail iterator pair\n///\n/// `PartialEq`, `Eq`, `PartialOrd` and `Ord` are implemented by comparing sequences based on\n/// first items (which are guaranteed to exist).\n///\n/// The meanings of `PartialOrd` and `Ord` are reversed so as to turn the heap used in\n/// `KMerge` into a min-heap.\n#[derive(Debug)]\nstruct HeadTail<I>\n    where I: Iterator\n{\n    head: I::Item,\n    tail: I,\n}\n\nimpl<I> HeadTail<I>\n    where I: Iterator\n{\n    /// Constructs a `HeadTail` from an `Iterator`. Returns `None` if the `Iterator` is empty.\n    fn new(mut it: I) -> Option<HeadTail<I>> {\n        let head = it.next();\n        head.map(|h| {\n            HeadTail {\n                head: h,\n                tail: it,\n            }\n        })\n    }\n\n    /// Get the next element and update `head`, returning the old head in `Some`.\n    ///\n    /// Returns `None` when the tail is exhausted (only `head` then remains).\n    fn next(&mut self) -> Option<I::Item> {\n        if let Some(next) = self.tail.next() {\n            Some(replace(&mut self.head, next))\n        } else {\n            None\n        }\n    }\n\n    /// Hints at the size of the sequence, same as the `Iterator` method.\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add_scalar(self.tail.size_hint(), 1)\n    }\n}\n\nimpl<I> Clone for HeadTail<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    clone_fields!(head, tail);\n}\n\n/// Make `data` a heap (min-heap w.r.t the sorting).\nfn heapify<T, S>(data: &mut [T], mut less_than: S)\n    where S: FnMut(&T, &T) -> bool\n{\n    for i in (0..data.len() / 2).rev() {\n        sift_down(data, i, &mut less_than);\n    }\n}\n\n/// Sift down element at `index` (`heap` is a min-heap wrt the ordering)\nfn sift_down<T, S>(heap: &mut [T], index: usize, mut less_than: S)\n    where S: FnMut(&T, &T) -> bool\n{\n    debug_assert!(index <= heap.len());\n    let mut pos = index;\n    let mut child = 2 * pos + 1;\n    // the `pos` conditional is to avoid a bounds check\n    while pos < heap.len() && child < heap.len() {\n        let right = child + 1;\n\n        // pick the smaller of the two children\n        if right < heap.len() && less_than(&heap[right], &heap[child]) {\n            child = right;\n        }\n\n        // sift down is done if we are already in order\n        if !less_than(&heap[child], &heap[pos]) {\n            return;\n        }\n        heap.swap(pos, child);\n        pos = child;\n        child = 2 * pos + 1;\n    }\n}\n\n/// An iterator adaptor that merges an abitrary number of base iterators in ascending order.\n/// If all base iterators are sorted (ascending), the result is sorted.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.kmerge()`](../trait.Itertools.html#method.kmerge) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub type KMerge<I> = KMergeBy<I, KMergeByLt>;\n\npub trait KMergePredicate<T> {\n    fn kmerge_pred(&mut self, a: &T, b: &T) -> bool;\n}\n\n#[derive(Clone)]\npub struct KMergeByLt;\n\nimpl<T: PartialOrd> KMergePredicate<T> for KMergeByLt {\n    fn kmerge_pred(&mut self, a: &T, b: &T) -> bool {\n        a < b\n    }\n}\n\nimpl<T, F: FnMut(&T, &T)->bool> KMergePredicate<T> for F {\n    fn kmerge_pred(&mut self, a: &T, b: &T) -> bool {\n        self(a, b)\n    }\n}\n\n/// Create an iterator that merges elements of the contained iterators using\n/// the ordering function.\n///\n/// Equivalent to `iterable.into_iter().kmerge()`.\n///\n/// ```\n/// use itertools::kmerge;\n///\n/// for elt in kmerge(vec![vec![0, 2, 4], vec![1, 3, 5], vec![6, 7]]) {\n///     /* loop body */\n/// }\n/// ```\npub fn kmerge<I>(iterable: I) -> KMerge<<I::Item as IntoIterator>::IntoIter>\n    where I: IntoIterator,\n          I::Item: IntoIterator,\n          <<I as IntoIterator>::Item as IntoIterator>::Item: PartialOrd\n{\n    kmerge_by(iterable, KMergeByLt)\n}\n\n/// An iterator adaptor that merges an abitrary number of base iterators\n/// according to an ordering function.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.kmerge_by()`](../trait.Itertools.html#method.kmerge_by) for more\n/// information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct KMergeBy<I, F>\n    where I: Iterator,\n{\n    heap: Vec<HeadTail<I>>,\n    less_than: F,\n}\n\nimpl<I, F> fmt::Debug for KMergeBy<I, F>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(KMergeBy, heap);\n}\n\n/// Create an iterator that merges elements of the contained iterators.\n///\n/// Equivalent to `iterable.into_iter().kmerge_by(less_than)`.\npub fn kmerge_by<I, F>(iterable: I, mut less_than: F)\n    -> KMergeBy<<I::Item as IntoIterator>::IntoIter, F>\n    where I: IntoIterator,\n          I::Item: IntoIterator,\n          F: KMergePredicate<<<I as IntoIterator>::Item as IntoIterator>::Item>,\n{\n    let iter = iterable.into_iter();\n    let (lower, _) = iter.size_hint();\n    let mut heap: Vec<_> = Vec::with_capacity(lower);\n    heap.extend(iter.filter_map(|it| HeadTail::new(it.into_iter())));\n    heapify(&mut heap, |a, b| less_than.kmerge_pred(&a.head, &b.head));\n    KMergeBy { heap, less_than }\n}\n\nimpl<I, F> Clone for KMergeBy<I, F>\n    where I: Iterator + Clone,\n          I::Item: Clone,\n          F: Clone,\n{\n    clone_fields!(heap, less_than);\n}\n\nimpl<I, F> Iterator for KMergeBy<I, F>\n    where I: Iterator,\n          F: KMergePredicate<I::Item>\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.heap.is_empty() {\n            return None;\n        }\n        let result = if let Some(next) = self.heap[0].next() {\n            next\n        } else {\n            self.heap.swap_remove(0).head\n        };\n        let less_than = &mut self.less_than;\n        sift_down(&mut self.heap, 0, |a, b| less_than.kmerge_pred(&a.head, &b.head));\n        Some(result)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.heap.iter()\n                 .map(|i| i.size_hint())\n                 .fold1(size_hint::add)\n                 .unwrap_or((0, Some(0)))\n    }\n}\n","traces":[{"line":26,"address":[4962976,4962800,4962850,4963033],"length":1,"stats":{"Line":4},"fn_name":"new<itertools::adaptors::Step<core::ops::range::Range<i32>>>"},{"line":27,"address":[4962991,4963048,4962866,4962807],"length":1,"stats":{"Line":10},"fn_name":null},{"line":28,"address":[4963060,4963232,4962878,4963152],"length":1,"stats":{"Line":10},"fn_name":"{{closure}}<itertools::adaptors::Step<core::ops::range::Range<i32>>>"},{"line":29,"address":[4963250,4963188],"length":1,"stats":{"Line":5},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[4963456,4963264,4963382,4963571],"length":1,"stats":{"Line":4},"fn_name":"next<core::ops::range::Range<i32>>"},{"line":40,"address":[4963513,4963273,4963331,4963465],"length":1,"stats":{"Line":10},"fn_name":null},{"line":41,"address":[4963351,4963533],"length":1,"stats":{"Line":6},"fn_name":null},{"line":43,"address":[4963505,4963323],"length":1,"stats":{"Line":4},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[4963660],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[4964640,4964960,4964050,4964370,4965010,4965280,4964690,4964000,4964320,4965330],"length":1,"stats":{"Line":10},"fn_name":"heapify<itertools::kmerge_impl::HeadTail<core::ops::range::Range<i32>>,closure-1>"},{"line":64,"address":[4964710,4965567,4964287,4964070,4964120,4964390,4964440,4964871,4965350,4965030,4965191,4965247,4965400,4964678,4965318,4964038,4964607,4964760,4964998,4965080,4964231,4964927,4965511,4964358,4964551],"length":1,"stats":{"Line":38},"fn_name":null},{"line":65,"address":[4964277,4964597,4965237,4965557,4964917],"length":1,"stats":{"Line":8},"fn_name":null},{"line":70,"address":[4970158,4971488,4974288,4972880,4975680,4974366,4975758,4977072,4977150,4968750,4968672,4970080,4972958,4971566],"length":1,"stats":{"Line":15},"fn_name":"sift_down<itertools::kmerge_impl::HeadTail<core::ops::range::Range<i32>>,&mut closure-1>"},{"line":73,"address":[4974397,4971597,4974351,4975743,4975789,4977135,4972943,4970189,4968781,4977181,4970143,4968735,4971551,4972989],"length":1,"stats":{"Line":30},"fn_name":null},{"line":74,"address":[4975815,4971623,4968807,4973015,4974423,4977207,4970215],"length":1,"stats":{"Line":15},"fn_name":null},{"line":75,"address":[4975391,4975823,4970223,4974512,4971712,4973104,4973991,4970304,4968815,4974431,4975904,4971631,4977296,4972591,4969783,4971191,4973023,4978183,4968896,4976783,4977215],"length":1,"stats":{"Line":30},"fn_name":null},{"line":77,"address":[4971164,4978156,4968938,4972564,4969756,4973964,4974554,4970346,4975364,4971754,4976756,4977338,4975946,4973146],"length":1,"stats":{"Line":28},"fn_name":null},{"line":78,"address":[4974707,4969843,4971907,4975451,4973299,4969091,4978243,4977491,4970499,4971251,4976099,4974051,4972651,4976843],"length":1,"stats":{"Line":15},"fn_name":null},{"line":81,"address":[4969151,4970559,4974081,4975481,4976873,4974767,4971281,4977551,4971967,4973359,4976159,4972681,4969873,4978273],"length":1,"stats":{"Line":15},"fn_name":null},{"line":82,"address":[4975028,4970824,4972228,4973624,4976420,4977816,4969416],"length":1,"stats":{"Line":11},"fn_name":null},{"line":86,"address":[4969424,4974146,4976938,4971346,4973632,4972746,4969938,4975036,4975546,4976428,4978338,4972236,4977824,4970832],"length":1,"stats":{"Line":14},"fn_name":null},{"line":89,"address":[4975223,4971023,4972423,4969615,4976615,4973823,4978015],"length":1,"stats":{"Line":13},"fn_name":null},{"line":90,"address":[4971072,4969664,4972472,4975272,4973872,4976664,4978064],"length":1,"stats":{"Line":13},"fn_name":null},{"line":91,"address":[4978080,4974280,4977072,4973888,4971414,4972488,4978406,4978472,4974214,4970072,4969680,4970006,4975288,4976680,4972880,4975614,4971088,4972814,4975680,4971480,4977006],"length":1,"stats":{"Line":13},"fn_name":"sift_down<itertools::kmerge_impl::HeadTail<core::ops::range::Range<i32>>,&mut closure-1>"},{"line":112,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":135,"address":[4963952,4963728,4963808,4963856,4963904],"length":1,"stats":{"Line":7},"fn_name":"kmerge<core::iter::adapters::Map<alloc::vec::IntoIter<i32>, closure-0>>"},{"line":140,"address":[4963828,4963876,4963735,4963924,4963972],"length":1,"stats":{"Line":7},"fn_name":null},{"line":168,"address":[4966154,4967606,4967040,4966678,4967142,4966064,4965702,4967504,4965600,4966576],"length":1,"stats":{"Line":10},"fn_name":"kmerge_by<core::iter::adapters::Map<core::ops::range::Range<i32>, closure-0>,itertools::kmerge_impl::KMergeByLt>"},{"line":174,"address":[4967064,4965624,4966074,4966600,4967528],"length":1,"stats":{"Line":10},"fn_name":null},{"line":175,"address":[4967623,4966695,4967599,4965719,4967159,4966671,4966147,4966171,4967135,4965695],"length":1,"stats":{"Line":20},"fn_name":null},{"line":176,"address":[4967641,4966192,4965737,4967177,4966713],"length":1,"stats":{"Line":10},"fn_name":null},{"line":177,"address":[4967968,4966202,4968304,4968576,4967187,4968108,4968096,4968448,4967651,4968473,4968329,4966723,4968588,4965747,4967993],"length":1,"stats":{"Line":30},"fn_name":"{{closure}}<core::iter::adapters::Map<core::ops::range::Range<i32>, closure-0>,itertools::kmerge_impl::KMergeByLt>"},{"line":178,"address":[4965818,4967722,4968048,4968403,4968256,4968192,4968211,4968275,4966308,4966794,4967258,4968384,4968547,4968067,4968528],"length":1,"stats":{"Line":26},"fn_name":"{{closure}}<core::iter::adapters::Map<core::ops::range::Range<i32>, closure-0>,itertools::kmerge_impl::KMergeByLt>"},{"line":196,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":51,"coverable":53},{"path":["/","usr","src","itertools","src","lazy_buffer.rs"],"content":"use std::ops::Index;\n\n#[derive(Debug, Clone)]\npub struct LazyBuffer<I: Iterator> {\n    pub it: I,\n    done: bool,\n    buffer: Vec<I::Item>,\n}\n\nimpl<I> LazyBuffer<I>\nwhere\n    I: Iterator,\n{\n    pub fn new(it: I) -> LazyBuffer<I> {\n        LazyBuffer {\n            it,\n            done: false,\n            buffer: Vec::new(),\n        }\n    }\n\n    pub fn len(&self) -> usize {\n        self.buffer.len()\n    }\n\n    pub fn is_done(&self) -> bool {\n        self.done\n    }\n\n    pub fn get_next(&mut self) -> bool {\n        if self.done {\n            return false;\n        }\n        let next_item = self.it.next();\n        match next_item {\n            Some(x) => {\n                self.buffer.push(x);\n                true\n            }\n            None => {\n                self.done = true;\n                false\n            }\n        }\n    }\n}\n\nimpl<I, J> Index<J> for LazyBuffer<I>\nwhere\n    I: Iterator,\n    I::Item: Sized,\n    Vec<I::Item>: Index<J>\n{\n    type Output = <Vec<I::Item> as Index<J>>::Output;\n\n    fn index(&self, _index: J) -> &Self::Output {\n        self.buffer.index(_index)\n    }\n}\n","traces":[{"line":14,"address":[4605669,4605408,4605513,4605552],"length":1,"stats":{"Line":8},"fn_name":"new<core::ops::range::Range<i32>>"},{"line":18,"address":[4229515],"length":1,"stats":{"Line":9},"fn_name":null},{"line":22,"address":[4229440],"length":1,"stats":{"Line":5},"fn_name":"len<adaptors_no_collect::PanickingCounter>"},{"line":23,"address":[4605337,4605369],"length":1,"stats":{"Line":5},"fn_name":null},{"line":26,"address":[4605712,4605696],"length":1,"stats":{"Line":4},"fn_name":"is_done<core::ops::range::Range<usize>>"},{"line":27,"address":[4229637],"length":1,"stats":{"Line":4},"fn_name":null},{"line":30,"address":[4605904,4605728,4605868,4606028],"length":1,"stats":{"Line":7},"fn_name":"get_next<core::ops::range::Range<usize>>"},{"line":31,"address":[4605737,4605913],"length":1,"stats":{"Line":7},"fn_name":null},{"line":32,"address":[4605774,4605949],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":36,"address":[4605825,4605793,4605968,4606000],"length":1,"stats":{"Line":14},"fn_name":null},{"line":37,"address":[4229747],"length":1,"stats":{"Line":8},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":5},"fn_name":null}],"covered":18,"coverable":19},{"path":["/","usr","src","itertools","src","lib.rs"],"content":"#![warn(missing_docs)]\n#![crate_name=\"itertools\"]\n#![cfg_attr(not(feature = \"use_std\"), no_std)]\n\n//! Extra iterator adaptors, functions and macros.\n//!\n//! To extend [`Iterator`] with methods in this crate, import\n//! the [`Itertools` trait](./trait.Itertools.html):\n//!\n//! ```\n//! use itertools::Itertools;\n//! ```\n//!\n//! Now, new methods like [`interleave`](./trait.Itertools.html#method.interleave)\n//! are available on all iterators:\n//!\n//! ```\n//! use itertools::Itertools;\n//!\n//! let it = (1..3).interleave(vec![-1, -2]);\n//! itertools::assert_equal(it, vec![1, -1, 2, -2]);\n//! ```\n//!\n//! Most iterator methods are also provided as functions (with the benefit\n//! that they convert parameters using [`IntoIterator`]):\n//!\n//! ```\n//! use itertools::interleave;\n//!\n//! for elt in interleave(&[1, 2, 3], &[2, 3, 4]) {\n//!     /* loop body */\n//! }\n//! ```\n//!\n//! ## Crate Features\n//!\n//! - `use_std`\n//!   - Enabled by default.\n//!   - Disable to compile itertools using `#![no_std]`. This disables\n//!     any items that depend on collections (like `group_by`, `unique`,\n//!     `kmerge`, `join` and many more).\n//!\n//! ## Rust Version\n//!\n//! This version of itertools requires Rust 1.32 or later.\n//!\n//! [`Iterator`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html\n#![doc(html_root_url=\"https://docs.rs/itertools/0.8/\")]\n\n#[cfg(not(feature = \"use_std\"))]\nextern crate core as std;\n\npub use either::Either;\n\n#[cfg(feature = \"use_std\")]\nuse std::collections::HashMap;\nuse std::iter::{IntoIterator, once};\nuse std::cmp::Ordering;\nuse std::fmt;\n#[cfg(feature = \"use_std\")]\nuse std::hash::Hash;\n#[cfg(feature = \"use_std\")]\nuse std::fmt::Write;\n#[cfg(feature = \"use_std\")]\ntype VecIntoIter<T> = ::std::vec::IntoIter<T>;\n#[cfg(feature = \"use_std\")]\nuse std::iter::FromIterator;\n\n#[macro_use]\nmod impl_macros;\n\n// for compatibility with no std and macros\n#[doc(hidden)]\npub use std::iter as __std_iter;\n\n/// The concrete iterator types.\npub mod structs {\n    pub use crate::adaptors::{\n        Dedup,\n        DedupBy,\n        DedupWithCount,\n        DedupByWithCount,\n        Interleave,\n        InterleaveShortest,\n        Product,\n        PutBack,\n        Batching,\n        MapInto,\n        MapResults,\n        Merge,\n        MergeBy,\n        TakeWhileRef,\n        WhileSome,\n        Coalesce,\n        TupleCombinations,\n        Positions,\n        Update,\n    };\n    #[allow(deprecated)]\n    pub use crate::adaptors::Step;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::adaptors::MultiProduct;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::combinations::Combinations;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::combinations_with_replacement::CombinationsWithReplacement;\n    pub use crate::cons_tuples_impl::ConsTuples;\n    pub use crate::exactly_one_err::ExactlyOneError;\n    pub use crate::format::{Format, FormatWith};\n    #[cfg(feature = \"use_std\")]\n    pub use crate::groupbylazy::{IntoChunks, Chunk, Chunks, GroupBy, Group, Groups};\n    pub use crate::intersperse::Intersperse;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::kmerge_impl::{KMerge, KMergeBy};\n    pub use crate::merge_join::MergeJoinBy;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::multipeek_impl::MultiPeek;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::peek_nth::PeekNth;\n    pub use crate::pad_tail::PadUsing;\n    pub use crate::peeking_take_while::PeekingTakeWhile;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::permutations::Permutations;\n    pub use crate::process_results_impl::ProcessResults;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::put_back_n_impl::PutBackN;\n    #[cfg(feature = \"use_std\")]\n    pub use crate::rciter_impl::RcIter;\n    pub use crate::repeatn::RepeatN;\n    #[allow(deprecated)]\n    pub use crate::sources::{RepeatCall, Unfold, Iterate};\n    #[cfg(feature = \"use_std\")]\n    pub use crate::tee::Tee;\n    pub use crate::tuple_impl::{TupleBuffer, TupleWindows, CircularTupleWindows, Tuples};\n    #[cfg(feature = \"use_std\")]\n    pub use crate::unique_impl::{Unique, UniqueBy};\n    pub use crate::with_position::WithPosition;\n    pub use crate::zip_eq_impl::ZipEq;\n    pub use crate::zip_longest::ZipLongest;\n    pub use crate::ziptuple::Zip;\n}\n\n/// Traits helpful for using certain `Itertools` methods in generic contexts.\npub mod traits {\n    pub use crate::tuple_impl::HomogeneousTuple;\n}\n\n#[allow(deprecated)]\npub use crate::structs::*;\npub use crate::concat_impl::concat;\npub use crate::cons_tuples_impl::cons_tuples;\npub use crate::diff::diff_with;\npub use crate::diff::Diff;\n#[cfg(feature = \"use_std\")]\npub use crate::kmerge_impl::{kmerge_by};\npub use crate::minmax::MinMaxResult;\npub use crate::peeking_take_while::PeekingNext;\npub use crate::process_results_impl::process_results;\npub use crate::repeatn::repeat_n;\n#[allow(deprecated)]\npub use crate::sources::{repeat_call, unfold, iterate};\npub use crate::with_position::Position;\npub use crate::ziptuple::multizip;\nmod adaptors;\nmod either_or_both;\npub use crate::either_or_both::EitherOrBoth;\n#[doc(hidden)]\npub mod free;\n#[doc(inline)]\npub use crate::free::*;\nmod concat_impl;\nmod cons_tuples_impl;\n#[cfg(feature = \"use_std\")]\nmod combinations;\n#[cfg(feature = \"use_std\")]\nmod combinations_with_replacement;\nmod exactly_one_err;\nmod diff;\nmod format;\n#[cfg(feature = \"use_std\")]\nmod group_map;\n#[cfg(feature = \"use_std\")]\nmod groupbylazy;\nmod intersperse;\n#[cfg(feature = \"use_std\")]\nmod kmerge_impl;\n#[cfg(feature = \"use_std\")]\nmod lazy_buffer;\nmod merge_join;\nmod minmax;\n#[cfg(feature = \"use_std\")]\nmod multipeek_impl;\nmod pad_tail;\n#[cfg(feature = \"use_std\")]\nmod peek_nth;\nmod peeking_take_while;\n#[cfg(feature = \"use_std\")]\nmod permutations;\nmod process_results_impl;\n#[cfg(feature = \"use_std\")]\nmod put_back_n_impl;\n#[cfg(feature = \"use_std\")]\nmod rciter_impl;\nmod repeatn;\nmod size_hint;\nmod sources;\n#[cfg(feature = \"use_std\")]\nmod tee;\nmod tuple_impl;\n#[cfg(feature = \"use_std\")]\nmod unique_impl;\nmod with_position;\nmod zip_eq_impl;\nmod zip_longest;\nmod ziptuple;\n\n#[macro_export]\n/// Create an iterator over the “cartesian product” of iterators.\n///\n/// Iterator element type is like `(A, B, ..., E)` if formed\n/// from iterators `(I, J, ..., M)` with element types `I::Item = A`, `J::Item = B`, etc.\n///\n/// ```\n/// # use itertools::iproduct;\n/// #\n/// # fn main() {\n/// // Iterate over the coordinates of a 4 x 4 x 4 grid\n/// // from (0, 0, 0), (0, 0, 1), .., (0, 1, 0), (0, 1, 1), .. etc until (3, 3, 3)\n/// for (i, j, k) in iproduct!(0..4, 0..4, 0..4) {\n///    // ..\n/// }\n/// # }\n/// ```\nmacro_rules! iproduct {\n    (@flatten $I:expr,) => (\n        $I\n    );\n    (@flatten $I:expr, $J:expr, $($K:expr,)*) => (\n        iproduct!(@flatten $crate::cons_tuples(iproduct!($I, $J)), $($K,)*)\n    );\n    ($I:expr) => (\n        $crate::__std_iter::IntoIterator::into_iter($I)\n    );\n    ($I:expr, $J:expr) => (\n        $crate::Itertools::cartesian_product(iproduct!($I), iproduct!($J))\n    );\n    ($I:expr, $J:expr, $($K:expr),+) => (\n        iproduct!(@flatten iproduct!($I, $J), $($K,)+)\n    );\n}\n\n#[macro_export]\n/// Create an iterator running multiple iterators in lockstep.\n///\n/// The `izip!` iterator yields elements until any subiterator\n/// returns `None`.\n///\n/// This is a version of the standard ``.zip()`` that's supporting more than\n/// two iterators. The iterator element type is a tuple with one element\n/// from each of the input iterators. Just like ``.zip()``, the iteration stops\n/// when the shortest of the inputs reaches its end.\n///\n/// **Note:** The result of this macro is in the general case an iterator\n/// composed of repeated `.zip()` and a `.map()`; it has an anonymous type.\n/// The special cases of one and two arguments produce the equivalent of\n/// `$a.into_iter()` and `$a.into_iter().zip($b)` respectively.\n///\n/// Prefer this macro `izip!()` over [`multizip`] for the performance benefits\n/// of using the standard library `.zip()`.\n///\n/// [`multizip`]: fn.multizip.html\n///\n/// ```\n/// # use itertools::izip;\n/// #\n/// # fn main() {\n///\n/// // iterate over three sequences side-by-side\n/// let mut results = [0, 0, 0, 0];\n/// let inputs = [3, 7, 9, 6];\n///\n/// for (r, index, input) in izip!(&mut results, 0..10, &inputs) {\n///     *r = index * 10 + input;\n/// }\n///\n/// assert_eq!(results, [0 + 3, 10 + 7, 29, 36]);\n/// # }\n/// ```\nmacro_rules! izip {\n    // @closure creates a tuple-flattening closure for .map() call. usage:\n    // @closure partial_pattern => partial_tuple , rest , of , iterators\n    // eg. izip!( @closure ((a, b), c) => (a, b, c) , dd , ee )\n    ( @closure $p:pat => $tup:expr ) => {\n        |$p| $tup\n    };\n\n    // The \"b\" identifier is a different identifier on each recursion level thanks to hygiene.\n    ( @closure $p:pat => ( $($tup:tt)* ) , $_iter:expr $( , $tail:expr )* ) => {\n        izip!(@closure ($p, b) => ( $($tup)*, b ) $( , $tail )*)\n    };\n\n    // unary\n    ($first:expr $(,)*) => {\n        $crate::__std_iter::IntoIterator::into_iter($first)\n    };\n\n    // binary\n    ($first:expr, $second:expr $(,)*) => {\n        izip!($first)\n            .zip($second)\n    };\n\n    // n-ary where n > 2\n    ( $first:expr $( , $rest:expr )* $(,)* ) => {\n        izip!($first)\n            $(\n                .zip($rest)\n            )*\n            .map(\n                izip!(@closure a => (a) $( , $rest )*)\n            )\n    };\n}\n\n/// An [`Iterator`] blanket implementation that provides extra adaptors and\n/// methods.\n///\n/// This trait defines a number of methods. They are divided into two groups:\n///\n/// * *Adaptors* take an iterator and parameter as input, and return\n/// a new iterator value. These are listed first in the trait. An example\n/// of an adaptor is [`.interleave()`](#method.interleave)\n///\n/// * *Regular methods* are those that don't return iterators and instead\n/// return a regular value of some other kind.\n/// [`.next_tuple()`](#method.next_tuple) is an example and the first regular\n/// method in the list.\n///\n/// [`Iterator`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html\npub trait Itertools : Iterator {\n    // adaptors\n\n    /// Alternate elements from two iterators until both have run out.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = (1..7).interleave(vec![-1, -2]);\n    /// itertools::assert_equal(it, vec![1, -1, 2, -2, 3, 4, 5, 6]);\n    /// ```\n    fn interleave<J>(self, other: J) -> Interleave<Self, J::IntoIter>\n        where J: IntoIterator<Item = Self::Item>,\n              Self: Sized\n    {\n        interleave(self, other)\n    }\n\n    /// Alternate elements from two iterators until at least one of them has run\n    /// out.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = (1..7).interleave_shortest(vec![-1, -2]);\n    /// itertools::assert_equal(it, vec![1, -1, 2, -2, 3]);\n    /// ```\n    fn interleave_shortest<J>(self, other: J) -> InterleaveShortest<Self, J::IntoIter>\n        where J: IntoIterator<Item = Self::Item>,\n              Self: Sized\n    {\n        adaptors::interleave_shortest(self, other.into_iter())\n    }\n\n    /// An iterator adaptor to insert a particular value\n    /// between each element of the adapted iterator.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// itertools::assert_equal((0..3).intersperse(8), vec![0, 8, 1, 8, 2]);\n    /// ```\n    fn intersperse(self, element: Self::Item) -> Intersperse<Self>\n        where Self: Sized,\n              Self::Item: Clone\n    {\n        intersperse::intersperse(self, element)\n    }\n\n    /// Create an iterator which iterates over both this and the specified\n    /// iterator simultaneously, yielding pairs of two optional elements.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// As long as neither input iterator is exhausted yet, it yields two values\n    /// via `EitherOrBoth::Both`.\n    ///\n    /// When the parameter iterator is exhausted, it only yields a value from the\n    /// `self` iterator via `EitherOrBoth::Left`.\n    ///\n    /// When the `self` iterator is exhausted, it only yields a value from the\n    /// parameter iterator via `EitherOrBoth::Right`.\n    ///\n    /// When both iterators return `None`, all further invocations of `.next()`\n    /// will return `None`.\n    ///\n    /// Iterator element type is\n    /// [`EitherOrBoth<Self::Item, J::Item>`](enum.EitherOrBoth.html).\n    ///\n    /// ```rust\n    /// use itertools::EitherOrBoth::{Both, Right};\n    /// use itertools::Itertools;\n    /// let it = (0..1).zip_longest(1..3);\n    /// itertools::assert_equal(it, vec![Both(0, 1), Right(2)]);\n    /// ```\n    #[inline]\n    fn zip_longest<J>(self, other: J) -> ZipLongest<Self, J::IntoIter>\n        where J: IntoIterator,\n              Self: Sized\n    {\n        zip_longest::zip_longest(self, other.into_iter())\n    }\n\n    /// Create an iterator which iterates over both this and the specified\n    /// iterator simultaneously, yielding pairs of elements.\n    ///\n    /// **Panics** if the iterators reach an end and they are not of equal\n    /// lengths.\n    #[inline]\n    fn zip_eq<J>(self, other: J) -> ZipEq<Self, J::IntoIter>\n        where J: IntoIterator,\n              Self: Sized\n    {\n        zip_eq(self, other)\n    }\n\n    /// A “meta iterator adaptor”. Its closure receives a reference to the\n    /// iterator and may pick off as many elements as it likes, to produce the\n    /// next iterator element.\n    ///\n    /// Iterator element type is `B`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // An adaptor that gathers elements in pairs\n    /// let pit = (0..4).batching(|it| {\n    ///            match it.next() {\n    ///                None => None,\n    ///                Some(x) => match it.next() {\n    ///                    None => None,\n    ///                    Some(y) => Some((x, y)),\n    ///                }\n    ///            }\n    ///        });\n    ///\n    /// itertools::assert_equal(pit, vec![(0, 1), (2, 3)]);\n    /// ```\n    ///\n    fn batching<B, F>(self, f: F) -> Batching<Self, F>\n        where F: FnMut(&mut Self) -> Option<B>,\n              Self: Sized\n    {\n        adaptors::batching(self, f)\n    }\n\n    /// Return an *iterable* that can group iterator elements.\n    /// Consecutive elements that map to the same key (“runs”), are assigned\n    /// to the same group.\n    ///\n    /// `GroupBy` is the storage for the lazy grouping operation.\n    ///\n    /// If the groups are consumed in order, or if each group's iterator is\n    /// dropped without keeping it around, then `GroupBy` uses no\n    /// allocations.  It needs allocations only if several group iterators\n    /// are alive at the same time.\n    ///\n    /// This type implements `IntoIterator` (it is **not** an iterator\n    /// itself), because the group iterators need to borrow from this\n    /// value. It should be stored in a local variable or temporary and\n    /// iterated.\n    ///\n    /// Iterator element type is `(K, Group)`: the group's key and the\n    /// group iterator.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // group data into runs of larger than zero or not.\n    /// let data = vec![1, 3, -2, -2, 1, 0, 1, 2];\n    /// // groups:     |---->|------>|--------->|\n    ///\n    /// // Note: The `&` is significant here, `GroupBy` is iterable\n    /// // only by reference. You can also call `.into_iter()` explicitly.\n    /// let mut data_grouped = Vec::new();\n    /// for (key, group) in &data.into_iter().group_by(|elt| *elt >= 0) {\n    ///     data_grouped.push((key, group.collect()));\n    /// }\n    /// assert_eq!(data_grouped, vec![(true, vec![1, 3]), (false, vec![-2, -2]), (true, vec![1, 0, 1, 2])]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn group_by<K, F>(self, key: F) -> GroupBy<K, Self, F>\n        where Self: Sized,\n              F: FnMut(&Self::Item) -> K,\n              K: PartialEq,\n    {\n        groupbylazy::new(self, key)\n    }\n\n    /// Return an *iterable* that can chunk the iterator.\n    ///\n    /// Yield subiterators (chunks) that each yield a fixed number elements,\n    /// determined by `size`. The last chunk will be shorter if there aren't\n    /// enough elements.\n    ///\n    /// `IntoChunks` is based on `GroupBy`: it is iterable (implements\n    /// `IntoIterator`, **not** `Iterator`), and it only buffers if several\n    /// chunk iterators are alive at the same time.\n    ///\n    /// Iterator element type is `Chunk`, each chunk's iterator.\n    ///\n    /// **Panics** if `size` is 0.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![1, 1, 2, -2, 6, 0, 3, 1];\n    /// //chunk size=3 |------->|-------->|--->|\n    ///\n    /// // Note: The `&` is significant here, `IntoChunks` is iterable\n    /// // only by reference. You can also call `.into_iter()` explicitly.\n    /// for chunk in &data.into_iter().chunks(3) {\n    ///     // Check that the sum of each chunk is 4.\n    ///     assert_eq!(4, chunk.sum());\n    /// }\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn chunks(self, size: usize) -> IntoChunks<Self>\n        where Self: Sized,\n    {\n        assert!(size != 0);\n        groupbylazy::new_chunks(self, size)\n    }\n\n    /// Return an iterator over all contiguous windows producing tuples of\n    /// a specific size (up to 4).\n    ///\n    /// `tuple_windows` clones the iterator elements so that they can be\n    /// part of successive windows, this makes it most suited for iterators\n    /// of references and other values that are cheap to copy.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// let mut v = Vec::new();\n    /// for (a, b) in (1..5).tuple_windows() {\n    ///     v.push((a, b));\n    /// }\n    /// assert_eq!(v, vec![(1, 2), (2, 3), (3, 4)]);\n    ///\n    /// let mut it = (1..5).tuple_windows();\n    /// assert_eq!(Some((1, 2, 3)), it.next());\n    /// assert_eq!(Some((2, 3, 4)), it.next());\n    /// assert_eq!(None, it.next());\n    ///\n    /// // this requires a type hint\n    /// let it = (1..5).tuple_windows::<(_, _, _)>();\n    /// itertools::assert_equal(it, vec![(1, 2, 3), (2, 3, 4)]);\n    ///\n    /// // you can also specify the complete type\n    /// use itertools::TupleWindows;\n    /// use std::ops::Range;\n    ///\n    /// let it: TupleWindows<Range<u32>, (u32, u32, u32)> = (1..5).tuple_windows();\n    /// itertools::assert_equal(it, vec![(1, 2, 3), (2, 3, 4)]);\n    /// ```\n    fn tuple_windows<T>(self) -> TupleWindows<Self, T>\n        where Self: Sized + Iterator<Item = T::Item>,\n              T: traits::HomogeneousTuple,\n              T::Item: Clone\n    {\n        tuple_impl::tuple_windows(self)\n    }\n\n    /// Return an iterator over all windows, wrapping back to the first\n    /// elements when the window would otherwise exceed the length of the\n    /// iterator, producing tuples of a specific size (up to 4).\n    ///\n    /// `circular_tuple_windows` clones the iterator elements so that they can be\n    /// part of successive windows, this makes it most suited for iterators\n    /// of references and other values that are cheap to copy.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// let mut v = Vec::new();\n    /// for (a, b) in (1..5).circular_tuple_windows() {\n    ///     v.push((a, b));\n    /// }\n    /// assert_eq!(v, vec![(1, 2), (2, 3), (3, 4), (4, 1)]);\n    ///\n    /// let mut it = (1..5).circular_tuple_windows();\n    /// assert_eq!(Some((1, 2, 3)), it.next());\n    /// assert_eq!(Some((2, 3, 4)), it.next());\n    /// assert_eq!(Some((3, 4, 1)), it.next());\n    /// assert_eq!(Some((4, 1, 2)), it.next());\n    /// assert_eq!(None, it.next());\n    ///\n    /// // this requires a type hint\n    /// let it = (1..5).circular_tuple_windows::<(_, _, _)>();\n    /// itertools::assert_equal(it, vec![(1, 2, 3), (2, 3, 4), (3, 4, 1), (4, 1, 2)]);\n    /// ```\n    fn circular_tuple_windows<T>(self) -> CircularTupleWindows<Self, T>\n        where Self: Sized + Clone + Iterator<Item = T::Item> + ExactSizeIterator,\n              T: tuple_impl::TupleCollect + Clone,\n              T::Item: Clone\n    {\n        tuple_impl::circular_tuple_windows(self)\n    }\n    /// Return an iterator that groups the items in tuples of a specific size\n    /// (up to 4).\n    ///\n    /// See also the method [`.next_tuple()`](#method.next_tuple).\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// let mut v = Vec::new();\n    /// for (a, b) in (1..5).tuples() {\n    ///     v.push((a, b));\n    /// }\n    /// assert_eq!(v, vec![(1, 2), (3, 4)]);\n    ///\n    /// let mut it = (1..7).tuples();\n    /// assert_eq!(Some((1, 2, 3)), it.next());\n    /// assert_eq!(Some((4, 5, 6)), it.next());\n    /// assert_eq!(None, it.next());\n    ///\n    /// // this requires a type hint\n    /// let it = (1..7).tuples::<(_, _, _)>();\n    /// itertools::assert_equal(it, vec![(1, 2, 3), (4, 5, 6)]);\n    ///\n    /// // you can also specify the complete type\n    /// use itertools::Tuples;\n    /// use std::ops::Range;\n    ///\n    /// let it: Tuples<Range<u32>, (u32, u32, u32)> = (1..7).tuples();\n    /// itertools::assert_equal(it, vec![(1, 2, 3), (4, 5, 6)]);\n    /// ```\n    ///\n    /// See also [`Tuples::into_buffer`](structs/struct.Tuples.html#method.into_buffer).\n    fn tuples<T>(self) -> Tuples<Self, T>\n        where Self: Sized + Iterator<Item = T::Item>,\n              T: traits::HomogeneousTuple\n    {\n        tuple_impl::tuples(self)\n    }\n\n    /// Split into an iterator pair that both yield all elements from\n    /// the original iterator.\n    ///\n    /// **Note:** If the iterator is clonable, prefer using that instead\n    /// of using this method. It is likely to be more efficient.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// let xs = vec![0, 1, 2, 3];\n    ///\n    /// let (mut t1, t2) = xs.into_iter().tee();\n    /// itertools::assert_equal(t1.next(), Some(0));\n    /// itertools::assert_equal(t2, 0..4);\n    /// itertools::assert_equal(t1, 1..4);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn tee(self) -> (Tee<Self>, Tee<Self>)\n        where Self: Sized,\n              Self::Item: Clone\n    {\n        tee::new(self)\n    }\n\n    /// Return an iterator adaptor that steps `n` elements in the base iterator\n    /// for each iteration.\n    ///\n    /// The iterator steps by yielding the next element from the base iterator,\n    /// then skipping forward `n - 1` elements.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// **Panics** if the step is 0.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = (0..8).step(3);\n    /// itertools::assert_equal(it, vec![0, 3, 6]);\n    /// ```\n    #[deprecated(note=\"Use std .step_by() instead\", since=\"0.8\")]\n    #[allow(deprecated)]\n    fn step(self, n: usize) -> Step<Self>\n        where Self: Sized\n    {\n        adaptors::step(self, n)\n    }\n\n    /// Convert each item of the iterator using the `Into` trait.\n    ///\n    /// ```rust\n    /// use itertools::Itertools;\n    ///\n    /// (1i32..42i32).map_into::<f64>().collect_vec();\n    /// ```\n    fn map_into<R>(self) -> MapInto<Self, R>\n        where Self: Sized,\n              Self::Item: Into<R>,\n    {\n        adaptors::map_into(self)\n    }\n\n    /// Return an iterator adaptor that applies the provided closure\n    /// to every `Result::Ok` value. `Result::Err` values are\n    /// unchanged.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let input = vec![Ok(41), Err(false), Ok(11)];\n    /// let it = input.into_iter().map_results(|i| i + 1);\n    /// itertools::assert_equal(it, vec![Ok(42), Err(false), Ok(12)]);\n    /// ```\n    fn map_results<F, T, U, E>(self, f: F) -> MapResults<Self, F>\n        where Self: Iterator<Item = Result<T, E>> + Sized,\n              F: FnMut(T) -> U,\n    {\n        adaptors::map_results(self, f)\n    }\n\n    /// Return an iterator adaptor that merges the two base iterators in\n    /// ascending order.  If both base iterators are sorted (ascending), the\n    /// result is sorted.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a = (0..11).step(3);\n    /// let b = (0..11).step(5);\n    /// let it = a.merge(b);\n    /// itertools::assert_equal(it, vec![0, 0, 3, 5, 6, 9, 10]);\n    /// ```\n    fn merge<J>(self, other: J) -> Merge<Self, J::IntoIter>\n        where Self: Sized,\n              Self::Item: PartialOrd,\n              J: IntoIterator<Item = Self::Item>\n    {\n        merge(self, other)\n    }\n\n    /// Return an iterator adaptor that merges the two base iterators in order.\n    /// This is much like `.merge()` but allows for a custom ordering.\n    ///\n    /// This can be especially useful for sequences of tuples.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a = (0..).zip(\"bc\".chars());\n    /// let b = (0..).zip(\"ad\".chars());\n    /// let it = a.merge_by(b, |x, y| x.1 <= y.1);\n    /// itertools::assert_equal(it, vec![(0, 'a'), (0, 'b'), (1, 'c'), (1, 'd')]);\n    /// ```\n\n    fn merge_by<J, F>(self, other: J, is_first: F) -> MergeBy<Self, J::IntoIter, F>\n        where Self: Sized,\n              J: IntoIterator<Item = Self::Item>,\n              F: FnMut(&Self::Item, &Self::Item) -> bool\n    {\n        adaptors::merge_by_new(self, other.into_iter(), is_first)\n    }\n\n    /// Create an iterator that merges items from both this and the specified\n    /// iterator in ascending order.\n    ///\n    /// It chooses whether to pair elements based on the `Ordering` returned by the\n    /// specified compare function. At any point, inspecting the tip of the\n    /// iterators `I` and `J` as items `i` of type `I::Item` and `j` of type\n    /// `J::Item` respectively, the resulting iterator will:\n    ///\n    /// - Emit `EitherOrBoth::Left(i)` when `i < j`,\n    ///   and remove `i` from its source iterator\n    /// - Emit `EitherOrBoth::Right(j)` when `i > j`,\n    ///   and remove `j` from its source iterator\n    /// - Emit `EitherOrBoth::Both(i, j)` when  `i == j`,\n    ///   and remove both `i` and `j` from their respective source iterators\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// use itertools::EitherOrBoth::{Left, Right, Both};\n    ///\n    /// let ki = (0..10).step(3);\n    /// let ku = (0..10).step(5);\n    /// let ki_ku = ki.merge_join_by(ku, |i, j| i.cmp(j)).map(|either| {\n    ///     match either {\n    ///         Left(_) => \"Ki\",\n    ///         Right(_) => \"Ku\",\n    ///         Both(_, _) => \"KiKu\"\n    ///     }\n    /// });\n    ///\n    /// itertools::assert_equal(ki_ku, vec![\"KiKu\", \"Ki\", \"Ku\", \"Ki\", \"Ki\"]);\n    /// ```\n    #[inline]\n    fn merge_join_by<J, F>(self, other: J, cmp_fn: F) -> MergeJoinBy<Self, J::IntoIter, F>\n        where J: IntoIterator,\n              F: FnMut(&Self::Item, &J::Item) -> std::cmp::Ordering,\n              Self: Sized\n    {\n        merge_join_by(self, other, cmp_fn)\n    }\n\n    /// Return an iterator adaptor that flattens an iterator of iterators by\n    /// merging them in ascending order.\n    ///\n    /// If all base iterators are sorted (ascending), the result is sorted.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a = (0..6).step(3);\n    /// let b = (1..6).step(3);\n    /// let c = (2..6).step(3);\n    /// let it = vec![a, b, c].into_iter().kmerge();\n    /// itertools::assert_equal(it, vec![0, 1, 2, 3, 4, 5]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn kmerge(self) -> KMerge<<Self::Item as IntoIterator>::IntoIter>\n        where Self: Sized,\n              Self::Item: IntoIterator,\n              <Self::Item as IntoIterator>::Item: PartialOrd,\n    {\n        kmerge(self)\n    }\n\n    /// Return an iterator adaptor that flattens an iterator of iterators by\n    /// merging them according to the given closure.\n    ///\n    /// The closure `first` is called with two elements *a*, *b* and should\n    /// return `true` if *a* is ordered before *b*.\n    ///\n    /// If all base iterators are sorted according to `first`, the result is\n    /// sorted.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a = vec![-1f64, 2., 3., -5., 6., -7.];\n    /// let b = vec![0., 2., -4.];\n    /// let mut it = vec![a, b].into_iter().kmerge_by(|a, b| a.abs() < b.abs());\n    /// assert_eq!(it.next(), Some(0.));\n    /// assert_eq!(it.last(), Some(-7.));\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn kmerge_by<F>(self, first: F)\n        -> KMergeBy<<Self::Item as IntoIterator>::IntoIter, F>\n        where Self: Sized,\n              Self::Item: IntoIterator,\n              F: FnMut(&<Self::Item as IntoIterator>::Item,\n                       &<Self::Item as IntoIterator>::Item) -> bool\n    {\n        kmerge_by(self, first)\n    }\n\n    /// Return an iterator adaptor that iterates over the cartesian product of\n    /// the element sets of two iterators `self` and `J`.\n    ///\n    /// Iterator element type is `(Self::Item, J::Item)`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = (0..2).cartesian_product(\"αβ\".chars());\n    /// itertools::assert_equal(it, vec![(0, 'α'), (0, 'β'), (1, 'α'), (1, 'β')]);\n    /// ```\n    fn cartesian_product<J>(self, other: J) -> Product<Self, J::IntoIter>\n        where Self: Sized,\n              Self::Item: Clone,\n              J: IntoIterator,\n              J::IntoIter: Clone\n    {\n        adaptors::cartesian_product(self, other.into_iter())\n    }\n\n    /// Return an iterator adaptor that iterates over the cartesian product of\n    /// all subiterators returned by meta-iterator `self`.\n    ///\n    /// All provided iterators must yield the same `Item` type. To generate\n    /// the product of iterators yielding multiple types, use the\n    /// [`iproduct`](macro.iproduct.html) macro instead.\n    ///\n    ///\n    /// The iterator element type is `Vec<T>`, where `T` is the iterator element\n    /// of the subiterators.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// let mut multi_prod = (0..3).map(|i| (i * 2)..(i * 2 + 2))\n    ///     .multi_cartesian_product();\n    /// assert_eq!(multi_prod.next(), Some(vec![0, 2, 4]));\n    /// assert_eq!(multi_prod.next(), Some(vec![0, 2, 5]));\n    /// assert_eq!(multi_prod.next(), Some(vec![0, 3, 4]));\n    /// assert_eq!(multi_prod.next(), Some(vec![0, 3, 5]));\n    /// assert_eq!(multi_prod.next(), Some(vec![1, 2, 4]));\n    /// assert_eq!(multi_prod.next(), Some(vec![1, 2, 5]));\n    /// assert_eq!(multi_prod.next(), Some(vec![1, 3, 4]));\n    /// assert_eq!(multi_prod.next(), Some(vec![1, 3, 5]));\n    /// assert_eq!(multi_prod.next(), None);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn multi_cartesian_product(self) -> MultiProduct<<Self::Item as IntoIterator>::IntoIter>\n        where Self: Iterator + Sized,\n              Self::Item: IntoIterator,\n              <Self::Item as IntoIterator>::IntoIter: Clone,\n              <Self::Item as IntoIterator>::Item: Clone\n    {\n        adaptors::multi_cartesian_product(self)\n    }\n\n    /// Return an iterator adaptor that uses the passed-in closure to\n    /// optionally merge together consecutive elements.\n    ///\n    /// The closure `f` is passed two elements, `previous` and `current` and may\n    /// return either (1) `Ok(combined)` to merge the two values or\n    /// (2) `Err((previous', current'))` to indicate they can't be merged.\n    /// In (2), the value `previous'` is emitted by the iterator.\n    /// Either (1) `combined` or (2) `current'` becomes the previous value\n    /// when coalesce continues with the next pair of elements to merge. The\n    /// value that remains at the end is also emitted by the iterator.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // sum same-sign runs together\n    /// let data = vec![-1., -2., -3., 3., 1., 0., -1.];\n    /// itertools::assert_equal(data.into_iter().coalesce(|x, y|\n    ///         if (x >= 0.) == (y >= 0.) {\n    ///             Ok(x + y)\n    ///         } else {\n    ///             Err((x, y))\n    ///         }),\n    ///         vec![-6., 4., -1.]);\n    /// ```\n    fn coalesce<F>(self, f: F) -> Coalesce<Self, F>\n        where Self: Sized,\n              F: FnMut(Self::Item, Self::Item)\n                       -> Result<Self::Item, (Self::Item, Self::Item)>\n    {\n        adaptors::coalesce(self, f)\n    }\n\n    /// Remove duplicates from sections of consecutive identical elements.\n    /// If the iterator is sorted, all elements will be unique.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![1., 1., 2., 3., 3., 2., 2.];\n    /// itertools::assert_equal(data.into_iter().dedup(),\n    ///                         vec![1., 2., 3., 2.]);\n    /// ```\n    fn dedup(self) -> Dedup<Self>\n        where Self: Sized,\n              Self::Item: PartialEq,\n    {\n        adaptors::dedup(self)\n    }\n\n    /// Remove duplicates from sections of consecutive identical elements,\n    /// determining equality using a comparison function.\n    /// If the iterator is sorted, all elements will be unique.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![(0, 1.), (1, 1.), (0, 2.), (0, 3.), (1, 3.), (1, 2.), (2, 2.)];\n    /// itertools::assert_equal(data.into_iter().dedup_by(|x, y| x.1 == y.1),\n    ///                         vec![(0, 1.), (0, 2.), (0, 3.), (1, 2.)]);\n    /// ```\n    fn dedup_by<Cmp>(self, cmp: Cmp) -> DedupBy<Self, Cmp>\n        where Self: Sized,\n              Cmp: FnMut(&Self::Item, &Self::Item)->bool,\n    {\n        adaptors::dedup_by(self, cmp)\n    }\n\n    /// Remove duplicates from sections of consecutive identical elements, while keeping a count of\n    /// how many repeated elements were present.\n    /// If the iterator is sorted, all elements will be unique.\n    ///\n    /// Iterator element type is `(usize, Self::Item)`.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![1., 1., 2., 3., 3., 2., 2.];\n    /// itertools::assert_equal(data.into_iter().dedup_with_count(),\n    ///                         vec![(2, 1.), (1, 2.), (2, 3.), (2, 2.)]);\n    /// ```\n    fn dedup_with_count(self) -> DedupWithCount<Self>\n        where Self: Sized,\n    {\n        adaptors::dedup_with_count(self)\n    }\n\n    /// Remove duplicates from sections of consecutive identical elements, while keeping a count of\n    /// how many repeated elements were present.\n    /// This will determine equality using a comparison function.\n    /// If the iterator is sorted, all elements will be unique.\n    ///\n    /// Iterator element type is `(usize, Self::Item)`.\n    ///\n    /// This iterator is *fused*.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![(0, 1.), (1, 1.), (0, 2.), (0, 3.), (1, 3.), (1, 2.), (2, 2.)];\n    /// itertools::assert_equal(data.into_iter().dedup_by_with_count(|x, y| x.1 == y.1),\n    ///                         vec![(2, (0, 1.)), (1, (0, 2.)), (2, (0, 3.)), (2, (1, 2.))]);\n    /// ```\n    fn dedup_by_with_count<Cmp>(self, cmp: Cmp) -> DedupByWithCount<Self, Cmp>\n        where Self: Sized,\n              Cmp: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        adaptors::dedup_by_with_count(self, cmp)\n    }\n\n    /// Return an iterator adaptor that filters out elements that have\n    /// already been produced once during the iteration. Duplicates\n    /// are detected using hash and equality.\n    ///\n    /// Clones of visited elements are stored in a hash set in the\n    /// iterator.\n    ///\n    /// The iterator is stable, returning the non-duplicate items in the order\n    /// in which they occur in the adapted iterator. In a set of duplicate\n    /// items, the first item encountered is the item retained.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![10, 20, 30, 20, 40, 10, 50];\n    /// itertools::assert_equal(data.into_iter().unique(),\n    ///                         vec![10, 20, 30, 40, 50]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn unique(self) -> Unique<Self>\n        where Self: Sized,\n              Self::Item: Clone + Eq + Hash\n    {\n        unique_impl::unique(self)\n    }\n\n    /// Return an iterator adaptor that filters out elements that have\n    /// already been produced once during the iteration.\n    ///\n    /// Duplicates are detected by comparing the key they map to\n    /// with the keying function `f` by hash and equality.\n    /// The keys are stored in a hash set in the iterator.\n    ///\n    /// The iterator is stable, returning the non-duplicate items in the order\n    /// in which they occur in the adapted iterator. In a set of duplicate\n    /// items, the first item encountered is the item retained.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![\"a\", \"bb\", \"aa\", \"c\", \"ccc\"];\n    /// itertools::assert_equal(data.into_iter().unique_by(|s| s.len()),\n    ///                         vec![\"a\", \"bb\", \"ccc\"]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn unique_by<V, F>(self, f: F) -> UniqueBy<Self, V, F>\n        where Self: Sized,\n              V: Eq + Hash,\n              F: FnMut(&Self::Item) -> V\n    {\n        unique_impl::unique_by(self, f)\n    }\n\n    /// Return an iterator adaptor that borrows from this iterator and\n    /// takes items while the closure `accept` returns `true`.\n    ///\n    /// This adaptor can only be used on iterators that implement `PeekingNext`\n    /// like `.peekable()`, `put_back` and a few other collection iterators.\n    ///\n    /// The last and rejected element (first `false`) is still available when\n    /// `peeking_take_while` is done.\n    ///\n    ///\n    /// See also [`.take_while_ref()`](#method.take_while_ref)\n    /// which is a similar adaptor.\n    fn peeking_take_while<F>(&mut self, accept: F) -> PeekingTakeWhile<Self, F>\n        where Self: Sized + PeekingNext,\n              F: FnMut(&Self::Item) -> bool,\n    {\n        peeking_take_while::peeking_take_while(self, accept)\n    }\n\n    /// Return an iterator adaptor that borrows from a `Clone`-able iterator\n    /// to only pick off elements while the predicate `accept` returns `true`.\n    ///\n    /// It uses the `Clone` trait to restore the original iterator so that the\n    /// last and rejected element (first `false`) is still available when\n    /// `take_while_ref` is done.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut hexadecimals = \"0123456789abcdef\".chars();\n    ///\n    /// let decimals = hexadecimals.take_while_ref(|c| c.is_numeric())\n    ///                            .collect::<String>();\n    /// assert_eq!(decimals, \"0123456789\");\n    /// assert_eq!(hexadecimals.next(), Some('a'));\n    ///\n    /// ```\n    fn take_while_ref<F>(&mut self, accept: F) -> TakeWhileRef<Self, F>\n        where Self: Clone,\n              F: FnMut(&Self::Item) -> bool\n    {\n        adaptors::take_while_ref(self, accept)\n    }\n\n    /// Return an iterator adaptor that filters `Option<A>` iterator elements\n    /// and produces `A`. Stops on the first `None` encountered.\n    ///\n    /// Iterator element type is `A`, the unwrapped element.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // List all hexadecimal digits\n    /// itertools::assert_equal(\n    ///     (0..).map(|i| std::char::from_digit(i, 16)).while_some(),\n    ///     \"0123456789abcdef\".chars());\n    ///\n    /// ```\n    fn while_some<A>(self) -> WhileSome<Self>\n        where Self: Sized + Iterator<Item = Option<A>>\n    {\n        adaptors::while_some(self)\n    }\n\n    /// Return an iterator adaptor that iterates over the combinations of the\n    /// elements from an iterator.\n    ///\n    /// Iterator element can be any homogeneous tuple of type `Self::Item` with\n    /// size up to 4.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut v = Vec::new();\n    /// for (a, b) in (1..5).tuple_combinations() {\n    ///     v.push((a, b));\n    /// }\n    /// assert_eq!(v, vec![(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]);\n    ///\n    /// let mut it = (1..5).tuple_combinations();\n    /// assert_eq!(Some((1, 2, 3)), it.next());\n    /// assert_eq!(Some((1, 2, 4)), it.next());\n    /// assert_eq!(Some((1, 3, 4)), it.next());\n    /// assert_eq!(Some((2, 3, 4)), it.next());\n    /// assert_eq!(None, it.next());\n    ///\n    /// // this requires a type hint\n    /// let it = (1..5).tuple_combinations::<(_, _, _)>();\n    /// itertools::assert_equal(it, vec![(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]);\n    ///\n    /// // you can also specify the complete type\n    /// use itertools::TupleCombinations;\n    /// use std::ops::Range;\n    ///\n    /// let it: TupleCombinations<Range<u32>, (u32, u32, u32)> = (1..5).tuple_combinations();\n    /// itertools::assert_equal(it, vec![(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]);\n    /// ```\n    fn tuple_combinations<T>(self) -> TupleCombinations<Self, T>\n        where Self: Sized + Clone,\n              Self::Item: Clone,\n              T: adaptors::HasCombination<Self>,\n    {\n        adaptors::tuple_combinations(self)\n    }\n\n    /// Return an iterator adaptor that iterates over the `k`-length combinations of\n    /// the elements from an iterator.\n    ///\n    /// Iterator element type is `Vec<Self::Item>`. The iterator produces a new Vec per iteration,\n    /// and clones the iterator elements.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = (1..5).combinations(3);\n    /// itertools::assert_equal(it, vec![\n    ///     vec![1, 2, 3],\n    ///     vec![1, 2, 4],\n    ///     vec![1, 3, 4],\n    ///     vec![2, 3, 4],\n    /// ]);\n    /// ```\n    ///\n    /// Note: Combinations does not take into account the equality of the iterated values.\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = vec![1, 2, 2].into_iter().combinations(2);\n    /// itertools::assert_equal(it, vec![\n    ///     vec![1, 2], // Note: these are the same\n    ///     vec![1, 2], // Note: these are the same\n    ///     vec![2, 2],\n    /// ]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn combinations(self, k: usize) -> Combinations<Self>\n        where Self: Sized,\n              Self::Item: Clone\n    {\n        combinations::combinations(self, k)\n    }\n\n    /// Return an iterator that iterates over the `k`-length combinations of\n    /// the elements from an iterator, with replacement.\n    ///\n    /// Iterator element type is `Vec<Self::Item>`. The iterator produces a new Vec per iteration,\n    /// and clones the iterator elements.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = (1..4).combinations_with_replacement(2);\n    /// itertools::assert_equal(it, vec![\n    ///     vec![1, 1],\n    ///     vec![1, 2],\n    ///     vec![1, 3],\n    ///     vec![2, 2],\n    ///     vec![2, 3],\n    ///     vec![3, 3],\n    /// ]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn combinations_with_replacement(self, k: usize) -> CombinationsWithReplacement<Self>\n    where\n        Self: Sized,\n        Self::Item: Clone,\n    {\n        combinations_with_replacement::combinations_with_replacement(self, k)\n    }\n\n    /// Return an iterator adaptor that iterates over all k-permutations of the\n    /// elements from an iterator.\n    ///\n    /// Iterator element type is `Vec<Self::Item>` with length `k`. The iterator\n    /// produces a new Vec per iteration, and clones the iterator elements.\n    ///\n    /// If `k` is greater than the length of the input iterator, the resultant\n    /// iterator adaptor will be empty.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let perms = (5..8).permutations(2);\n    /// itertools::assert_equal(perms, vec![\n    ///     vec![5, 6],\n    ///     vec![5, 7],\n    ///     vec![6, 5],\n    ///     vec![6, 7],\n    ///     vec![7, 5],\n    ///     vec![7, 6],\n    /// ]);\n    /// ```\n    ///\n    /// Note: Permutations does not take into account the equality of the iterated values.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = vec![2, 2].into_iter().permutations(2);\n    /// itertools::assert_equal(it, vec![\n    ///     vec![2, 2], // Note: these are the same\n    ///     vec![2, 2], // Note: these are the same\n    /// ]);\n    /// ```\n    ///\n    /// Note: The source iterator is collected lazily, and will not be\n    /// re-iterated if the permutations adaptor is completed and re-iterated.\n    #[cfg(feature = \"use_std\")]\n    fn permutations(self, k: usize) -> Permutations<Self>\n        where Self: Sized,\n              Self::Item: Clone\n    {\n        permutations::permutations(self, k)\n    }\n\n    /// Return an iterator adaptor that pads the sequence to a minimum length of\n    /// `min` by filling missing elements using a closure `f`.\n    ///\n    /// Iterator element type is `Self::Item`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let it = (0..5).pad_using(10, |i| 2*i);\n    /// itertools::assert_equal(it, vec![0, 1, 2, 3, 4, 10, 12, 14, 16, 18]);\n    ///\n    /// let it = (0..10).pad_using(5, |i| 2*i);\n    /// itertools::assert_equal(it, vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n    ///\n    /// let it = (0..5).pad_using(10, |i| 2*i).rev();\n    /// itertools::assert_equal(it, vec![18, 16, 14, 12, 10, 4, 3, 2, 1, 0]);\n    /// ```\n    fn pad_using<F>(self, min: usize, f: F) -> PadUsing<Self, F>\n        where Self: Sized,\n              F: FnMut(usize) -> Self::Item\n    {\n        pad_tail::pad_using(self, min, f)\n    }\n\n    /// Return an iterator adaptor that wraps each element in a `Position` to\n    /// ease special-case handling of the first or last elements.\n    ///\n    /// Iterator element type is\n    /// [`Position<Self::Item>`](enum.Position.html)\n    ///\n    /// ```\n    /// use itertools::{Itertools, Position};\n    ///\n    /// let it = (0..4).with_position();\n    /// itertools::assert_equal(it,\n    ///                         vec![Position::First(0),\n    ///                              Position::Middle(1),\n    ///                              Position::Middle(2),\n    ///                              Position::Last(3)]);\n    ///\n    /// let it = (0..1).with_position();\n    /// itertools::assert_equal(it, vec![Position::Only(0)]);\n    /// ```\n    fn with_position(self) -> WithPosition<Self>\n        where Self: Sized,\n    {\n        with_position::with_position(self)\n    }\n\n    /// Return an iterator adaptor that yields the indices of all elements\n    /// satisfying a predicate, counted from the start of the iterator.\n    ///\n    /// Equivalent to `iter.enumerate().filter(|(_, v)| predicate(v)).map(|(i, _)| i)`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![1, 2, 3, 3, 4, 6, 7, 9];\n    /// itertools::assert_equal(data.iter().positions(|v| v % 2 == 0), vec![1, 4, 5]);\n    ///\n    /// itertools::assert_equal(data.iter().positions(|v| v % 2 == 1).rev(), vec![7, 6, 3, 2, 0]);\n    /// ```\n    fn positions<P>(self, predicate: P) -> Positions<Self, P>\n        where Self: Sized,\n              P: FnMut(Self::Item) -> bool,\n    {\n        adaptors::positions(self, predicate)\n    }\n\n    /// Return an iterator adaptor that applies a mutating function\n    /// to each element before yielding it.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let input = vec![vec![1], vec![3, 2, 1]];\n    /// let it = input.into_iter().update(|mut v| v.push(0));\n    /// itertools::assert_equal(it, vec![vec![1, 0], vec![3, 2, 1, 0]]);\n    /// ```\n    fn update<F>(self, updater: F) -> Update<Self, F>\n        where Self: Sized,\n              F: FnMut(&mut Self::Item),\n    {\n        adaptors::update(self, updater)\n    }\n\n    // non-adaptor methods\n    /// Advances the iterator and returns the next items grouped in a tuple of\n    /// a specific size (up to 4).\n    ///\n    /// If there are enough elements to be grouped in a tuple, then the tuple is\n    /// returned inside `Some`, otherwise `None` is returned.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut iter = 1..5;\n    ///\n    /// assert_eq!(Some((1, 2)), iter.next_tuple());\n    /// ```\n    fn next_tuple<T>(&mut self) -> Option<T>\n        where Self: Sized + Iterator<Item = T::Item>,\n              T: traits::HomogeneousTuple\n    {\n        T::collect_from_iter_no_buf(self)\n    }\n\n    /// Collects all items from the iterator into a tuple of a specific size\n    /// (up to 4).\n    ///\n    /// If the number of elements inside the iterator is **exactly** equal to\n    /// the tuple size, then the tuple is returned inside `Some`, otherwise\n    /// `None` is returned.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let iter = 1..3;\n    ///\n    /// if let Some((x, y)) = iter.collect_tuple() {\n    ///     assert_eq!((x, y), (1, 2))\n    /// } else {\n    ///     panic!(\"Expected two elements\")\n    /// }\n    /// ```\n    fn collect_tuple<T>(mut self) -> Option<T>\n        where Self: Sized + Iterator<Item = T::Item>,\n              T: traits::HomogeneousTuple\n    {\n        match self.next_tuple() {\n            elt @ Some(_) => match self.next() {\n                Some(_) => None,\n                None => elt,\n            },\n            _ => None\n        }\n    }\n\n\n    /// Find the position and value of the first element satisfying a predicate.\n    ///\n    /// The iterator is not advanced past the first element found.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let text = \"Hα\";\n    /// assert_eq!(text.chars().find_position(|ch| ch.is_lowercase()), Some((1, 'α')));\n    /// ```\n    fn find_position<P>(&mut self, mut pred: P) -> Option<(usize, Self::Item)>\n        where P: FnMut(&Self::Item) -> bool\n    {\n        let mut index = 0usize;\n        for elt in self {\n            if pred(&elt) {\n                return Some((index, elt));\n            }\n            index += 1;\n        }\n        None\n    }\n\n    /// Check whether all elements compare equal.\n    ///\n    /// Empty iterators are considered to have equal elements:\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![1, 1, 1, 2, 2, 3, 3, 3, 4, 5, 5];\n    /// assert!(!data.iter().all_equal());\n    /// assert!(data[0..3].iter().all_equal());\n    /// assert!(data[3..5].iter().all_equal());\n    /// assert!(data[5..8].iter().all_equal());\n    ///\n    /// let data : Option<usize> = None;\n    /// assert!(data.into_iter().all_equal());\n    /// ```\n    fn all_equal(&mut self) -> bool\n        where Self: Sized,\n              Self::Item: PartialEq,\n    {\n        match self.next() {\n            None => true,\n            Some(a) => self.all(|x| a == x),\n        }\n    }\n\n    /// Consume the first `n` elements from the iterator eagerly,\n    /// and return the same iterator again.\n    ///\n    /// It works similarly to *.skip(* `n` *)* except it is eager and\n    /// preserves the iterator type.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut iter = \"αβγ\".chars().dropping(2);\n    /// itertools::assert_equal(iter, \"γ\".chars());\n    /// ```\n    ///\n    /// *Fusing notes: if the iterator is exhausted by dropping,\n    /// the result of calling `.next()` again depends on the iterator implementation.*\n    fn dropping(mut self, n: usize) -> Self\n        where Self: Sized\n    {\n        if n > 0 {\n            self.nth(n - 1);\n        }\n        self\n    }\n\n    /// Consume the last `n` elements from the iterator eagerly,\n    /// and return the same iterator again.\n    ///\n    /// This is only possible on double ended iterators. `n` may be\n    /// larger than the number of elements.\n    ///\n    /// Note: This method is eager, dropping the back elements immediately and\n    /// preserves the iterator type.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let init = vec![0, 3, 6, 9].into_iter().dropping_back(1);\n    /// itertools::assert_equal(init, vec![0, 3, 6]);\n    /// ```\n    fn dropping_back(mut self, n: usize) -> Self\n        where Self: Sized,\n              Self: DoubleEndedIterator\n    {\n        if n > 0 {\n            (&mut self).rev().nth(n - 1);\n        }\n        self\n    }\n\n    /// Run the closure `f` eagerly on each element of the iterator.\n    ///\n    /// Consumes the iterator until its end.\n    ///\n    /// ```\n    /// use std::sync::mpsc::channel;\n    /// use itertools::Itertools;\n    ///\n    /// let (tx, rx) = channel();\n    ///\n    /// // use .foreach() to apply a function to each value -- sending it\n    /// (0..5).map(|x| x * 2 + 1).foreach(|x| { tx.send(x).unwrap(); } );\n    ///\n    /// drop(tx);\n    ///\n    /// itertools::assert_equal(rx.iter(), vec![1, 3, 5, 7, 9]);\n    /// ```\n    #[deprecated(note=\"Use .for_each() instead\", since=\"0.8\")]\n    fn foreach<F>(self, f: F)\n        where F: FnMut(Self::Item),\n              Self: Sized,\n    {\n        self.for_each(f)\n    }\n\n    /// Combine all an iterator's elements into one element by using `Extend`.\n    ///\n    /// This combinator will extend the first item with each of the rest of the\n    /// items of the iterator. If the iterator is empty, the default value of\n    /// `I::Item` is returned.\n    ///\n    /// ```rust\n    /// use itertools::Itertools;\n    ///\n    /// let input = vec![vec![1], vec![2, 3], vec![4, 5, 6]];\n    /// assert_eq!(input.into_iter().concat(),\n    ///            vec![1, 2, 3, 4, 5, 6]);\n    /// ```\n    fn concat(self) -> Self::Item\n        where Self: Sized,\n              Self::Item: Extend<<<Self as Iterator>::Item as IntoIterator>::Item> + IntoIterator + Default\n    {\n        concat(self)\n    }\n\n    /// `.collect_vec()` is simply a type specialization of `.collect()`,\n    /// for convenience.\n    #[cfg(feature = \"use_std\")]\n    fn collect_vec(self) -> Vec<Self::Item>\n        where Self: Sized\n    {\n        self.collect()\n    }\n\n    /// `.try_collect()` is more convenient way of writing\n    /// `.collect::<Result<_, _>>()`\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::{fs, io};\n    /// use itertools::Itertools;\n    ///\n    /// fn process_dir_entries(entries: &[fs::DirEntry]) {\n    ///     // ...\n    /// }\n    ///\n    /// fn do_stuff() -> std::io::Result<()> {\n    ///     let entries: Vec<_> = fs::read_dir(\".\")?.try_collect()?;\n    ///     process_dir_entries(&entries);\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn try_collect<T, U, E>(self) -> Result<U, E>\n    where\n        Self: Sized + Iterator<Item = Result<T, E>>,\n        Result<U, E>: FromIterator<Result<T, E>>,\n    {\n        self.collect()\n    }\n\n    /// Assign to each reference in `self` from the `from` iterator,\n    /// stopping at the shortest of the two iterators.\n    ///\n    /// The `from` iterator is queried for its next element before the `self`\n    /// iterator, and if either is exhausted the method is done.\n    ///\n    /// Return the number of elements written.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut xs = [0; 4];\n    /// xs.iter_mut().set_from(1..);\n    /// assert_eq!(xs, [1, 2, 3, 4]);\n    /// ```\n    #[inline]\n    fn set_from<'a, A: 'a, J>(&mut self, from: J) -> usize\n        where Self: Iterator<Item = &'a mut A>,\n              J: IntoIterator<Item = A>\n    {\n        let mut count = 0;\n        for elt in from {\n            match self.next() {\n                None => break,\n                Some(ptr) => *ptr = elt,\n            }\n            count += 1;\n        }\n        count\n    }\n\n    /// Combine all iterator elements into one String, separated by `sep`.\n    ///\n    /// Use the `Display` implementation of each element.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// assert_eq!([\"a\", \"b\", \"c\"].iter().join(\", \"), \"a, b, c\");\n    /// assert_eq!([1, 2, 3].iter().join(\", \"), \"1, 2, 3\");\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn join(&mut self, sep: &str) -> String\n        where Self::Item: std::fmt::Display\n    {\n        match self.next() {\n            None => String::new(),\n            Some(first_elt) => {\n                // estimate lower bound of capacity needed\n                let (lower, _) = self.size_hint();\n                let mut result = String::with_capacity(sep.len() * lower);\n                write!(&mut result, \"{}\", first_elt).unwrap();\n                for elt in self {\n                    result.push_str(sep);\n                    write!(&mut result, \"{}\", elt).unwrap();\n                }\n                result\n            }\n        }\n    }\n\n    /// Format all iterator elements, separated by `sep`.\n    ///\n    /// All elements are formatted (any formatting trait)\n    /// with `sep` inserted between each element.\n    ///\n    /// **Panics** if the formatter helper is formatted more than once.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = [1.1, 2.71828, -3.];\n    /// assert_eq!(\n    ///     format!(\"{:.2}\", data.iter().format(\", \")),\n    ///            \"1.10, 2.72, -3.00\");\n    /// ```\n    fn format(self, sep: &str) -> Format<Self>\n        where Self: Sized,\n    {\n        format::new_format_default(self, sep)\n    }\n\n    /// Format all iterator elements, separated by `sep`.\n    ///\n    /// This is a customizable version of `.format()`.\n    ///\n    /// The supplied closure `format` is called once per iterator element,\n    /// with two arguments: the element and a callback that takes a\n    /// `&Display` value, i.e. any reference to type that implements `Display`.\n    ///\n    /// Using `&format_args!(...)` is the most versatile way to apply custom\n    /// element formatting. The callback can be called multiple times if needed.\n    ///\n    /// **Panics** if the formatter helper is formatted more than once.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = [1.1, 2.71828, -3.];\n    /// let data_formatter = data.iter().format_with(\", \", |elt, f| f(&format_args!(\"{:.2}\", elt)));\n    /// assert_eq!(format!(\"{}\", data_formatter),\n    ///            \"1.10, 2.72, -3.00\");\n    ///\n    /// // .format_with() is recursively composable\n    /// let matrix = [[1., 2., 3.],\n    ///               [4., 5., 6.]];\n    /// let matrix_formatter = matrix.iter().format_with(\"\\n\", |row, f| {\n    ///                                 f(&row.iter().format_with(\", \", |elt, g| g(&elt)))\n    ///                              });\n    /// assert_eq!(format!(\"{}\", matrix_formatter),\n    ///            \"1, 2, 3\\n4, 5, 6\");\n    ///\n    ///\n    /// ```\n    fn format_with<F>(self, sep: &str, format: F) -> FormatWith<Self, F>\n        where Self: Sized,\n              F: FnMut(Self::Item, &mut dyn FnMut(&dyn fmt::Display) -> fmt::Result) -> fmt::Result,\n    {\n        format::new_format(self, sep, format)\n    }\n\n    /// Fold `Result` values from an iterator.\n    ///\n    /// Only `Ok` values are folded. If no error is encountered, the folded\n    /// value is returned inside `Ok`. Otherwise, the operation terminates\n    /// and returns the first `Err` value it encounters. No iterator elements are\n    /// consumed after the first error.\n    ///\n    /// The first accumulator value is the `start` parameter.\n    /// Each iteration passes the accumulator value and the next value inside `Ok`\n    /// to the fold function `f` and its return value becomes the new accumulator value.\n    ///\n    /// For example the sequence *Ok(1), Ok(2), Ok(3)* will result in a\n    /// computation like this:\n    ///\n    /// ```ignore\n    /// let mut accum = start;\n    /// accum = f(accum, 1);\n    /// accum = f(accum, 2);\n    /// accum = f(accum, 3);\n    /// ```\n    ///\n    /// With a `start` value of 0 and an addition as folding function,\n    /// this effectively results in *((0 + 1) + 2) + 3*\n    ///\n    /// ```\n    /// use std::ops::Add;\n    /// use itertools::Itertools;\n    ///\n    /// let values = [1, 2, -2, -1, 2, 1];\n    /// assert_eq!(\n    ///     values.iter()\n    ///           .map(Ok::<_, ()>)\n    ///           .fold_results(0, Add::add),\n    ///     Ok(3)\n    /// );\n    /// assert!(\n    ///     values.iter()\n    ///           .map(|&x| if x >= 0 { Ok(x) } else { Err(\"Negative number\") })\n    ///           .fold_results(0, Add::add)\n    ///           .is_err()\n    /// );\n    /// ```\n    fn fold_results<A, E, B, F>(&mut self, mut start: B, mut f: F) -> Result<B, E>\n        where Self: Iterator<Item = Result<A, E>>,\n              F: FnMut(B, A) -> B\n    {\n        for elt in self {\n            match elt {\n                Ok(v) => start = f(start, v),\n                Err(u) => return Err(u),\n            }\n        }\n        Ok(start)\n    }\n\n    /// Fold `Option` values from an iterator.\n    ///\n    /// Only `Some` values are folded. If no `None` is encountered, the folded\n    /// value is returned inside `Some`. Otherwise, the operation terminates\n    /// and returns `None`. No iterator elements are consumed after the `None`.\n    ///\n    /// This is the `Option` equivalent to `fold_results`.\n    ///\n    /// ```\n    /// use std::ops::Add;\n    /// use itertools::Itertools;\n    ///\n    /// let mut values = vec![Some(1), Some(2), Some(-2)].into_iter();\n    /// assert_eq!(values.fold_options(5, Add::add), Some(5 + 1 + 2 - 2));\n    ///\n    /// let mut more_values = vec![Some(2), None, Some(0)].into_iter();\n    /// assert!(more_values.fold_options(0, Add::add).is_none());\n    /// assert_eq!(more_values.next().unwrap(), Some(0));\n    /// ```\n    fn fold_options<A, B, F>(&mut self, mut start: B, mut f: F) -> Option<B>\n        where Self: Iterator<Item = Option<A>>,\n              F: FnMut(B, A) -> B\n    {\n        for elt in self {\n            match elt {\n                Some(v) => start = f(start, v),\n                None => return None,\n            }\n        }\n        Some(start)\n    }\n\n    /// Accumulator of the elements in the iterator.\n    ///\n    /// Like `.fold()`, without a base case. If the iterator is\n    /// empty, return `None`. With just one element, return it.\n    /// Otherwise elements are accumulated in sequence using the closure `f`.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// assert_eq!((0..10).fold1(|x, y| x + y).unwrap_or(0), 45);\n    /// assert_eq!((0..0).fold1(|x, y| x * y), None);\n    /// ```\n    fn fold1<F>(mut self, f: F) -> Option<Self::Item>\n        where F: FnMut(Self::Item, Self::Item) -> Self::Item,\n              Self: Sized,\n    {\n        self.next().map(move |x| self.fold(x, f))\n    }\n\n    /// Accumulate the elements in the iterator in a tree-like manner.\n    ///\n    /// You can think of it as, while there's more than one item, repeatedly\n    /// combining adjacent items.  It does so in bottom-up-merge-sort order,\n    /// however, so that it needs only logarithmic stack space.\n    ///\n    /// This produces a call tree like the following (where the calls under\n    /// an item are done after reading that item):\n    ///\n    /// ```text\n    /// 1 2 3 4 5 6 7\n    /// │ │ │ │ │ │ │\n    /// └─f └─f └─f │\n    ///   │   │   │ │\n    ///   └───f   └─f\n    ///       │     │\n    ///       └─────f\n    /// ```\n    ///\n    /// Which, for non-associative functions, will typically produce a different\n    /// result than the linear call tree used by `fold1`:\n    ///\n    /// ```text\n    /// 1 2 3 4 5 6 7\n    /// │ │ │ │ │ │ │\n    /// └─f─f─f─f─f─f\n    /// ```\n    ///\n    /// If `f` is associative, prefer the normal `fold1` instead.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // The same tree as above\n    /// let num_strings = (1..8).map(|x| x.to_string());\n    /// assert_eq!(num_strings.tree_fold1(|x, y| format!(\"f({}, {})\", x, y)),\n    ///     Some(String::from(\"f(f(f(1, 2), f(3, 4)), f(f(5, 6), 7))\")));\n    ///\n    /// // Like fold1, an empty iterator produces None\n    /// assert_eq!((0..0).tree_fold1(|x, y| x * y), None);\n    ///\n    /// // tree_fold1 matches fold1 for associative operations...\n    /// assert_eq!((0..10).tree_fold1(|x, y| x + y),\n    ///     (0..10).fold1(|x, y| x + y));\n    /// // ...but not for non-associative ones\n    /// assert_ne!((0..10).tree_fold1(|x, y| x - y),\n    ///     (0..10).fold1(|x, y| x - y));\n    /// ```\n    fn tree_fold1<F>(mut self, mut f: F) -> Option<Self::Item>\n        where F: FnMut(Self::Item, Self::Item) -> Self::Item,\n              Self: Sized,\n    {\n        type State<T> = Result<T, Option<T>>;\n\n        fn inner0<T, II, FF>(it: &mut II, f: &mut FF) -> State<T>\n            where\n                II: Iterator<Item = T>,\n                FF: FnMut(T, T) -> T\n        {\n            // This function could be replaced with `it.next().ok_or(None)`,\n            // but half the useful tree_fold1 work is combining adjacent items,\n            // so put that in a form that LLVM is more likely to optimize well.\n\n            let a =\n                if let Some(v) = it.next() { v }\n                else { return Err(None) };\n            let b =\n                if let Some(v) = it.next() { v }\n                else { return Err(Some(a)) };\n            Ok(f(a, b))\n        }\n\n        fn inner<T, II, FF>(stop: usize, it: &mut II, f: &mut FF) -> State<T>\n            where\n                II: Iterator<Item = T>,\n                FF: FnMut(T, T) -> T\n        {\n            let mut x = inner0(it, f)?;\n            for height in 0..stop {\n                // Try to get another tree the same size with which to combine it,\n                // creating a new tree that's twice as big for next time around.\n                let next =\n                    if height == 0 {\n                        inner0(it, f)\n                    } else {\n                        inner(height, it, f)\n                    };\n                match next {\n                    Ok(y) => x = f(x, y),\n\n                    // If we ran out of items, combine whatever we did manage\n                    // to get.  It's better combined with the current value\n                    // than something in a parent frame, because the tree in\n                    // the parent is always as least as big as this one.\n                    Err(None) => return Err(Some(x)),\n                    Err(Some(y)) => return Err(Some(f(x, y))),\n                }\n            }\n            Ok(x)\n        }\n\n        match inner(usize::max_value(), &mut self, &mut f) {\n            Err(x) => x,\n            _ => unreachable!(),\n        }\n    }\n\n    /// An iterator method that applies a function, producing a single, final value.\n    ///\n    /// `fold_while()` is basically equivalent to `fold()` but with additional support for\n    /// early exit via short-circuiting.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// use itertools::FoldWhile::{Continue, Done};\n    ///\n    /// let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    ///\n    /// let mut result = 0;\n    ///\n    /// // for loop:\n    /// for i in &numbers {\n    ///     if *i > 5 {\n    ///         break;\n    ///     }\n    ///     result = result + i;\n    /// }\n    ///\n    /// // fold:\n    /// let result2 = numbers.iter().fold(0, |acc, x| {\n    ///     if *x > 5 { acc } else { acc + x }\n    /// });\n    ///\n    /// // fold_while:\n    /// let result3 = numbers.iter().fold_while(0, |acc, x| {\n    ///     if *x > 5 { Done(acc) } else { Continue(acc + x) }\n    /// }).into_inner();\n    ///\n    /// // they're the same\n    /// assert_eq!(result, result2);\n    /// assert_eq!(result2, result3);\n    /// ```\n    ///\n    /// The big difference between the computations of `result2` and `result3` is that while\n    /// `fold()` called the provided closure for every item of the callee iterator,\n    /// `fold_while()` actually stopped iterating as soon as it encountered `Fold::Done(_)`.\n    #[deprecated(note=\"Use .try_fold() instead\", since=\"0.8\")]\n    fn fold_while<B, F>(&mut self, init: B, mut f: F) -> FoldWhile<B>\n        where Self: Sized,\n              F: FnMut(B, Self::Item) -> FoldWhile<B>\n    {\n        let mut acc = init;\n        while let Some(item) = self.next() {\n            match f(acc, item) {\n                FoldWhile::Continue(res) => acc = res,\n                res @ FoldWhile::Done(_) => return res,\n            }\n        }\n        FoldWhile::Continue(acc)\n    }\n\n    /// Iterate over the entire iterator and add all the elements.\n    ///\n    /// An empty iterator returns `None`, otherwise `Some(sum)`.\n    ///\n    /// # Panics\n    ///\n    /// When calling `sum1()` and a primitive integer type is being returned, this\n    /// method will panic if the computation overflows and debug assertions are\n    /// enabled.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let empty_sum = (1..1).sum1::<i32>();\n    /// assert_eq!(empty_sum, None);\n    ///\n    /// let nonempty_sum = (1..11).sum1::<i32>();\n    /// assert_eq!(nonempty_sum, Some(55));\n    /// ```\n    fn sum1<S>(mut self) -> Option<S>\n        where Self: Sized,\n              S: std::iter::Sum<Self::Item>,\n    {\n        self.next()\n            .map(|first| once(first).chain(self).sum())\n    }\n\n    /// Iterate over the entire iterator and multiply all the elements.\n    ///\n    /// An empty iterator returns `None`, otherwise `Some(product)`.\n    ///\n    /// # Panics\n    ///\n    /// When calling `product1()` and a primitive integer type is being returned,\n    /// method will panic if the computation overflows and debug assertions are\n    /// enabled.\n    ///\n    /// # Examples\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let empty_product = (1..1).product1::<i32>();\n    /// assert_eq!(empty_product, None);\n    ///\n    /// let nonempty_product = (1..11).product1::<i32>();\n    /// assert_eq!(nonempty_product, Some(3628800));\n    /// ```\n    fn product1<P>(mut self) -> Option<P>\n        where Self: Sized,\n              P: std::iter::Product<Self::Item>,\n    {\n        self.next()\n            .map(|first| once(first).chain(self).product())\n    }\n\n\n    /// Sort all iterator elements into a new iterator in ascending order.\n    ///\n    /// **Note:** This consumes the entire iterator, uses the\n    /// `slice::sort()` method and returns the result as a new\n    /// iterator that owns its elements.\n    ///\n    /// The sorted iterator, if directly collected to a `Vec`, is converted\n    /// without any extra copying or allocation cost.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // sort the letters of the text in ascending order\n    /// let text = \"bdacfe\";\n    /// itertools::assert_equal(text.chars().sorted(),\n    ///                         \"abcdef\".chars());\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn sorted(self) -> VecIntoIter<Self::Item>\n        where Self: Sized,\n              Self::Item: Ord\n    {\n        // Use .sort() directly since it is not quite identical with\n        // .sort_by(Ord::cmp)\n        let mut v = Vec::from_iter(self);\n        v.sort();\n        v.into_iter()\n    }\n\n    /// Sort all iterator elements into a new iterator in ascending order.\n    ///\n    /// **Note:** This consumes the entire iterator, uses the\n    /// `slice::sort_by()` method and returns the result as a new\n    /// iterator that owns its elements.\n    ///\n    /// The sorted iterator, if directly collected to a `Vec`, is converted\n    /// without any extra copying or allocation cost.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // sort people in descending order by age\n    /// let people = vec![(\"Jane\", 20), (\"John\", 18), (\"Jill\", 30), (\"Jack\", 27)];\n    ///\n    /// let oldest_people_first = people\n    ///     .into_iter()\n    ///     .sorted_by(|a, b| Ord::cmp(&b.1, &a.1))\n    ///     .map(|(person, _age)| person);\n    ///\n    /// itertools::assert_equal(oldest_people_first,\n    ///                         vec![\"Jill\", \"Jack\", \"Jane\", \"John\"]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn sorted_by<F>(self, cmp: F) -> VecIntoIter<Self::Item>\n        where Self: Sized,\n              F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n    {\n        let mut v = Vec::from_iter(self);\n        v.sort_by(cmp);\n        v.into_iter()\n    }\n\n    /// Sort all iterator elements into a new iterator in ascending order.\n    ///\n    /// **Note:** This consumes the entire iterator, uses the\n    /// `slice::sort_by_key()` method and returns the result as a new\n    /// iterator that owns its elements.\n    ///\n    /// The sorted iterator, if directly collected to a `Vec`, is converted\n    /// without any extra copying or allocation cost.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// // sort people in descending order by age\n    /// let people = vec![(\"Jane\", 20), (\"John\", 18), (\"Jill\", 30), (\"Jack\", 27)];\n    ///\n    /// let oldest_people_first = people\n    ///     .into_iter()\n    ///     .sorted_by_key(|x| -x.1)\n    ///     .map(|(person, _age)| person);\n    ///\n    /// itertools::assert_equal(oldest_people_first,\n    ///                         vec![\"Jill\", \"Jack\", \"Jane\", \"John\"]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn sorted_by_key<K, F>(self, f: F) -> VecIntoIter<Self::Item>\n        where Self: Sized,\n              K: Ord,\n              F: FnMut(&Self::Item) -> K,\n    {\n        let mut v = Vec::from_iter(self);\n        v.sort_by_key(f);\n        v.into_iter()\n    }\n\n    /// Collect all iterator elements into one of two\n    /// partitions. Unlike `Iterator::partition`, each partition may\n    /// have a distinct type.\n    ///\n    /// ```\n    /// use itertools::{Itertools, Either};\n    ///\n    /// let successes_and_failures = vec![Ok(1), Err(false), Err(true), Ok(2)];\n    ///\n    /// let (successes, failures): (Vec<_>, Vec<_>) = successes_and_failures\n    ///     .into_iter()\n    ///     .partition_map(|r| {\n    ///         match r {\n    ///             Ok(v) => Either::Left(v),\n    ///             Err(v) => Either::Right(v),\n    ///         }\n    ///     });\n    ///\n    /// assert_eq!(successes, [1, 2]);\n    /// assert_eq!(failures, [false, true]);\n    /// ```\n    fn partition_map<A, B, F, L, R>(self, mut predicate: F) -> (A, B)\n        where Self: Sized,\n              F: FnMut(Self::Item) -> Either<L, R>,\n              A: Default + Extend<L>,\n              B: Default + Extend<R>,\n    {\n        let mut left = A::default();\n        let mut right = B::default();\n\n        self.for_each(|val| match predicate(val) {\n            Either::Left(v) => left.extend(Some(v)),\n            Either::Right(v) => right.extend(Some(v)),\n        });\n\n        (left, right)\n    }\n\n    /// Return a `HashMap` of keys mapped to `Vec`s of values. Keys and values\n    /// are taken from `(Key, Value)` tuple pairs yielded by the input iterator.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let data = vec![(0, 10), (2, 12), (3, 13), (0, 20), (3, 33), (2, 42)];\n    /// let lookup = data.into_iter().into_group_map();\n    ///\n    /// assert_eq!(lookup[&0], vec![10, 20]);\n    /// assert_eq!(lookup.get(&1), None);\n    /// assert_eq!(lookup[&2], vec![12, 42]);\n    /// assert_eq!(lookup[&3], vec![13, 33]);\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn into_group_map<K, V>(self) -> HashMap<K, Vec<V>>\n        where Self: Iterator<Item=(K, V)> + Sized,\n              K: Hash + Eq,\n    {\n        group_map::into_group_map(self)\n    }\n\n    /// Return the minimum and maximum elements in the iterator.\n    ///\n    /// The return type `MinMaxResult` is an enum of three variants:\n    ///\n    /// - `NoElements` if the iterator is empty.\n    /// - `OneElement(x)` if the iterator has exactly one element.\n    /// - `MinMax(x, y)` is returned otherwise, where `x <= y`. Two\n    ///    values are equal if and only if there is more than one\n    ///    element in the iterator and all elements are equal.\n    ///\n    /// On an iterator of length `n`, `minmax` does `1.5 * n` comparisons,\n    /// and so is faster than calling `min` and `max` separately which does\n    /// `2 * n` comparisons.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// use itertools::MinMaxResult::{NoElements, OneElement, MinMax};\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().minmax(), NoElements);\n    ///\n    /// let a = [1];\n    /// assert_eq!(a.iter().minmax(), OneElement(&1));\n    ///\n    /// let a = [1, 2, 3, 4, 5];\n    /// assert_eq!(a.iter().minmax(), MinMax(&1, &5));\n    ///\n    /// let a = [1, 1, 1, 1];\n    /// assert_eq!(a.iter().minmax(), MinMax(&1, &1));\n    /// ```\n    ///\n    /// The elements can be floats but no particular result is guaranteed\n    /// if an element is NaN.\n    fn minmax(self) -> MinMaxResult<Self::Item>\n        where Self: Sized, Self::Item: PartialOrd\n    {\n        minmax::minmax_impl(self, |_| (), |x, y, _, _| x < y)\n    }\n\n    /// Return the minimum and maximum element of an iterator, as determined by\n    /// the specified function.\n    ///\n    /// The return value is a variant of `MinMaxResult` like for `minmax()`.\n    ///\n    /// For the minimum, the first minimal element is returned.  For the maximum,\n    /// the last maximal element wins.  This matches the behavior of the standard\n    /// `Iterator::min()` and `Iterator::max()` methods.\n    ///\n    /// The keys can be floats but no particular result is guaranteed\n    /// if a key is NaN.\n    fn minmax_by_key<K, F>(self, key: F) -> MinMaxResult<Self::Item>\n        where Self: Sized, K: PartialOrd, F: FnMut(&Self::Item) -> K\n    {\n        minmax::minmax_impl(self, key, |_, _, xk, yk| xk < yk)\n    }\n\n    /// Return the minimum and maximum element of an iterator, as determined by\n    /// the specified comparison function.\n    ///\n    /// The return value is a variant of `MinMaxResult` like for `minmax()`.\n    ///\n    /// For the minimum, the first minimal element is returned.  For the maximum,\n    /// the last maximal element wins.  This matches the behavior of the standard\n    /// `Iterator::min()` and `Iterator::max()` methods.\n    fn minmax_by<F>(self, mut compare: F) -> MinMaxResult<Self::Item>\n        where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering\n    {\n        minmax::minmax_impl(\n            self,\n            |_| (),\n            |x, y, _, _| Ordering::Less == compare(x, y)\n        )\n    }\n\n    /// Return the position of the maximum element in the iterator.\n    ///\n    /// If several elements are equally maximum, the position of the\n    /// last of them is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_max(), None);\n    ///\n    /// let a = [-3, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_max(), Some(3));\n    ///\n    /// let a = [1, 1, -1, -1];\n    /// assert_eq!(a.iter().position_max(), Some(1));\n    /// ```\n    fn position_max(self) -> Option<usize>\n        where Self: Sized, Self::Item: Ord\n    {\n        self.enumerate()\n            .max_by(|x, y| Ord::cmp(&x.1, &y.1))\n            .map(|x| x.0)\n    }\n\n    /// Return the position of the maximum element in the iterator, as\n    /// determined by the specified function.\n    ///\n    /// If several elements are equally maximum, the position of the\n    /// last of them is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_max_by_key(|x| x.abs()), None);\n    ///\n    /// let a = [-3_i32, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_max_by_key(|x| x.abs()), Some(4));\n    ///\n    /// let a = [1_i32, 1, -1, -1];\n    /// assert_eq!(a.iter().position_max_by_key(|x| x.abs()), Some(3));\n    /// ```\n    fn position_max_by_key<K, F>(self, mut key: F) -> Option<usize>\n        where Self: Sized, K: Ord, F: FnMut(&Self::Item) -> K\n    {\n        self.enumerate()\n            .max_by(|x, y| Ord::cmp(&key(&x.1), &key(&y.1)))\n            .map(|x| x.0)\n    }\n\n    /// Return the position of the maximum element in the iterator, as\n    /// determined by the specified comparison function.\n    ///\n    /// If several elements are equally maximum, the position of the\n    /// last of them is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_max_by(|x, y| x.cmp(y)), None);\n    ///\n    /// let a = [-3_i32, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_max_by(|x, y| x.cmp(y)), Some(3));\n    ///\n    /// let a = [1_i32, 1, -1, -1];\n    /// assert_eq!(a.iter().position_max_by(|x, y| x.cmp(y)), Some(1));\n    /// ```\n    fn position_max_by<F>(self, mut compare: F) -> Option<usize>\n        where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering\n    {\n        self.enumerate()\n            .max_by(|x, y| compare(&x.1, &y.1))\n            .map(|x| x.0)\n    }\n\n    /// Return the position of the minimum element in the iterator.\n    ///\n    /// If several elements are equally minimum, the position of the\n    /// first of them is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_min(), None);\n    ///\n    /// let a = [-3, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_min(), Some(4));\n    ///\n    /// let a = [1, 1, -1, -1];\n    /// assert_eq!(a.iter().position_min(), Some(2));\n    /// ```\n    fn position_min(self) -> Option<usize>\n        where Self: Sized, Self::Item: Ord\n    {\n        self.enumerate()\n            .min_by(|x, y| Ord::cmp(&x.1, &y.1))\n            .map(|x| x.0)\n    }\n\n    /// Return the position of the minimum element in the iterator, as\n    /// determined by the specified function.\n    ///\n    /// If several elements are equally minimum, the position of the\n    /// first of them is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_min_by_key(|x| x.abs()), None);\n    ///\n    /// let a = [-3_i32, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_min_by_key(|x| x.abs()), Some(1));\n    ///\n    /// let a = [1_i32, 1, -1, -1];\n    /// assert_eq!(a.iter().position_min_by_key(|x| x.abs()), Some(0));\n    /// ```\n    fn position_min_by_key<K, F>(self, mut key: F) -> Option<usize>\n        where Self: Sized, K: Ord, F: FnMut(&Self::Item) -> K\n    {\n        self.enumerate()\n            .min_by(|x, y| Ord::cmp(&key(&x.1), &key(&y.1)))\n            .map(|x| x.0)\n    }\n\n    /// Return the position of the minimum element in the iterator, as\n    /// determined by the specified comparison function.\n    ///\n    /// If several elements are equally minimum, the position of the\n    /// first of them is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_min_by(|x, y| x.cmp(y)), None);\n    ///\n    /// let a = [-3_i32, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_min_by(|x, y| x.cmp(y)), Some(4));\n    ///\n    /// let a = [1_i32, 1, -1, -1];\n    /// assert_eq!(a.iter().position_min_by(|x, y| x.cmp(y)), Some(2));\n    /// ```\n    fn position_min_by<F>(self, mut compare: F) -> Option<usize>\n        where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering\n    {\n        self.enumerate()\n            .min_by(|x, y| compare(&x.1, &y.1))\n            .map(|x| x.0)\n    }\n\n    /// Return the positions of the minimum and maximum elements in\n    /// the iterator.\n    ///\n    /// The return type [`MinMaxResult`] is an enum of three variants:\n    ///\n    /// - `NoElements` if the iterator is empty.\n    /// - `OneElement(xpos)` if the iterator has exactly one element.\n    /// - `MinMax(xpos, ypos)` is returned otherwise, where the\n    ///    element at `xpos` ≤ the element at `ypos`. While the\n    ///    referenced elements themselves may be equal, `xpos` cannot\n    ///    be equal to `ypos`.\n    ///\n    /// On an iterator of length `n`, `position_minmax` does `1.5 * n`\n    /// comparisons, and so is faster than calling `positon_min` and\n    /// `position_max` separately which does `2 * n` comparisons.\n    ///\n    /// For the minimum, if several elements are equally minimum, the\n    /// position of the first of them is returned. For the maximum, if\n    /// several elements are equally maximum, the position of the last\n    /// of them is returned.\n    ///\n    /// The elements can be floats but no particular result is\n    /// guaranteed if an element is NaN.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// use itertools::MinMaxResult::{NoElements, OneElement, MinMax};\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_minmax(), NoElements);\n    ///\n    /// let a = [10];\n    /// assert_eq!(a.iter().position_minmax(), OneElement(0));\n    ///\n    /// let a = [-3, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_minmax(), MinMax(4, 3));\n    ///\n    /// let a = [1, 1, -1, -1];\n    /// assert_eq!(a.iter().position_minmax(), MinMax(2, 1));\n    /// ```\n    ///\n    /// [`MinMaxResult`]: enum.MinMaxResult.html\n    fn position_minmax(self) -> MinMaxResult<usize>\n        where Self: Sized, Self::Item: PartialOrd\n    {\n        use crate::MinMaxResult::{NoElements, OneElement, MinMax};\n        match minmax::minmax_impl(self.enumerate(), |_| (), |x, y, _, _| x.1 < y.1) {\n            NoElements => NoElements,\n            OneElement(x) => OneElement(x.0),\n            MinMax(x, y) => MinMax(x.0, y.0),\n        }\n    }\n\n    /// Return the postions of the minimum and maximum elements of an\n    /// iterator, as determined by the specified function.\n    ///\n    /// The return value is a variant of [`MinMaxResult`] like for\n    /// [`position_minmax`].\n    ///\n    /// For the minimum, if several elements are equally minimum, the\n    /// position of the first of them is returned. For the maximum, if\n    /// several elements are equally maximum, the position of the last\n    /// of them is returned.\n    ///\n    /// The keys can be floats but no particular result is guaranteed\n    /// if a key is NaN.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// use itertools::MinMaxResult::{NoElements, OneElement, MinMax};\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_minmax_by_key(|x| x.abs()), NoElements);\n    ///\n    /// let a = [10_i32];\n    /// assert_eq!(a.iter().position_minmax_by_key(|x| x.abs()), OneElement(0));\n    ///\n    /// let a = [-3_i32, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_minmax_by_key(|x| x.abs()), MinMax(1, 4));\n    ///\n    /// let a = [1_i32, 1, -1, -1];\n    /// assert_eq!(a.iter().position_minmax_by_key(|x| x.abs()), MinMax(0, 3));\n    /// ```\n    ///\n    /// [`MinMaxResult`]: enum.MinMaxResult.html\n    /// [`position_minmax`]: #method.position_minmax\n    fn position_minmax_by_key<K, F>(self, mut key: F) -> MinMaxResult<usize>\n        where Self: Sized, K: PartialOrd, F: FnMut(&Self::Item) -> K\n    {\n        use crate::MinMaxResult::{NoElements, OneElement, MinMax};\n        match self.enumerate().minmax_by_key(|e| key(&e.1)) {\n            NoElements => NoElements,\n            OneElement(x) => OneElement(x.0),\n            MinMax(x, y) => MinMax(x.0, y.0),\n        }\n    }\n\n    /// Return the postions of the minimum and maximum elements of an\n    /// iterator, as determined by the specified comparison function.\n    ///\n    /// The return value is a variant of [`MinMaxResult`] like for\n    /// [`position_minmax`].\n    ///\n    /// For the minimum, if several elements are equally minimum, the\n    /// position of the first of them is returned. For the maximum, if\n    /// several elements are equally maximum, the position of the last\n    /// of them is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    /// use itertools::MinMaxResult::{NoElements, OneElement, MinMax};\n    ///\n    /// let a: [i32; 0] = [];\n    /// assert_eq!(a.iter().position_minmax_by(|x, y| x.cmp(y)), NoElements);\n    ///\n    /// let a = [10_i32];\n    /// assert_eq!(a.iter().position_minmax_by(|x, y| x.cmp(y)), OneElement(0));\n    ///\n    /// let a = [-3_i32, 0, 1, 5, -10];\n    /// assert_eq!(a.iter().position_minmax_by(|x, y| x.cmp(y)), MinMax(4, 3));\n    ///\n    /// let a = [1_i32, 1, -1, -1];\n    /// assert_eq!(a.iter().position_minmax_by(|x, y| x.cmp(y)), MinMax(2, 1));\n    /// ```\n    ///\n    /// [`MinMaxResult`]: enum.MinMaxResult.html\n    /// [`position_minmax`]: #method.position_minmax\n    fn position_minmax_by<F>(self, mut compare: F) -> MinMaxResult<usize>\n        where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering\n    {\n        use crate::MinMaxResult::{NoElements, OneElement, MinMax};\n        match self.enumerate().minmax_by(|x, y| compare(&x.1, &y.1)) {\n            NoElements => NoElements,\n            OneElement(x) => OneElement(x.0),\n            MinMax(x, y) => MinMax(x.0, y.0),\n        }\n    }\n\n    /// If the iterator yields exactly one element, that element will be returned, otherwise\n    /// an error will be returned containing an iterator that has the same output as the input\n    /// iterator.\n    ///\n    /// This provides an additional layer of validation over just calling `Iterator::next()`.\n    /// If your assumption that there should only be one element yielded is false this provides\n    /// the opportunity to detect and handle that, preventing errors at a distance.\n    ///\n    /// # Examples\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// assert_eq!((0..10).filter(|&x| x == 2).exactly_one().unwrap(), 2);\n    /// assert!((0..10).filter(|&x| x > 1 && x < 4).exactly_one().unwrap_err().eq(2..4));\n    /// assert!((0..10).filter(|&x| x > 1 && x < 5).exactly_one().unwrap_err().eq(2..5));\n    /// assert!((0..10).filter(|&_| false).exactly_one().unwrap_err().eq(0..0));\n    /// ```\n    fn exactly_one(mut self) -> Result<Self::Item, ExactlyOneError<Self>>\n    where\n        Self: Sized,\n    {\n        match self.next() {\n            Some(first) => {\n                match self.next() {\n                    Some(second) => {\n                        Err(ExactlyOneError::new((Some(first), Some(second)), self))\n                    }\n                    None => {\n                        Ok(first)\n                    }\n                }\n            }\n            None => Err(ExactlyOneError::new((None, None), self)),\n        }\n    }\n\n    /// An iterator adaptor that allows the user to peek at multiple `.next()`\n    /// values without advancing the base iterator.\n    ///\n    /// # Examples\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut iter = (0..10).multipeek();\n    /// assert_eq!(iter.peek(), Some(&0));\n    /// assert_eq!(iter.peek(), Some(&1));\n    /// assert_eq!(iter.peek(), Some(&2));\n    /// assert_eq!(iter.next(), Some(0));\n    /// assert_eq!(iter.peek(), Some(&1));\n    /// ```\n    #[cfg(feature = \"use_std\")]\n    fn multipeek(self) -> MultiPeek<Self>\n    where\n        Self: Sized,\n    {\n        multipeek_impl::multipeek(self)\n    }\n}\n\nimpl<T: ?Sized> Itertools for T where T: Iterator { }\n\n/// Return `true` if both iterables produce equal sequences\n/// (elements pairwise equal and sequences of the same length),\n/// `false` otherwise.\n///\n/// This is an `IntoIterator` enabled function that is similar to the standard\n/// library method `Iterator::eq`.\n///\n/// ```\n/// assert!(itertools::equal(vec![1, 2, 3], 1..4));\n/// assert!(!itertools::equal(&[0, 0], &[0, 0, 0]));\n/// ```\npub fn equal<I, J>(a: I, b: J) -> bool\n    where I: IntoIterator,\n          J: IntoIterator,\n          I::Item: PartialEq<J::Item>\n{\n    let mut ia = a.into_iter();\n    let mut ib = b.into_iter();\n    loop {\n        match ia.next() {\n            Some(x) => match ib.next() {\n                Some(y) => if x != y { return false; },\n                None => return false,\n            },\n            None => return ib.next().is_none()\n        }\n    }\n}\n\n/// Assert that two iterables produce equal sequences, with the same\n/// semantics as *equal(a, b)*.\n///\n/// **Panics** on assertion failure with a message that shows the\n/// two iteration elements.\n///\n/// ```ignore\n/// assert_equal(\"exceed\".split('c'), \"excess\".split('c'));\n/// // ^PANIC: panicked at 'Failed assertion Some(\"eed\") == Some(\"ess\") for iteration 1',\n/// ```\npub fn assert_equal<I, J>(a: I, b: J)\n    where I: IntoIterator,\n          J: IntoIterator,\n          I::Item: fmt::Debug + PartialEq<J::Item>,\n          J::Item: fmt::Debug,\n{\n    let mut ia = a.into_iter();\n    let mut ib = b.into_iter();\n    let mut i = 0;\n    loop {\n        match (ia.next(), ib.next()) {\n            (None, None) => return,\n            (a, b) => {\n                let equal = match (&a, &b) {\n                    (&Some(ref a), &Some(ref b)) => a == b,\n                    _ => false,\n                };\n                assert!(equal, \"Failed assertion {a:?} == {b:?} for iteration {i}\",\n                        i=i, a=a, b=b);\n                i += 1;\n            }\n        }\n    }\n}\n\n/// Partition a sequence using predicate `pred` so that elements\n/// that map to `true` are placed before elements which map to `false`.\n///\n/// The order within the partitions is arbitrary.\n///\n/// Return the index of the split point.\n///\n/// ```\n/// use itertools::partition;\n///\n/// # // use repeated numbers to not promise any ordering\n/// let mut data = [7, 1, 1, 7, 1, 1, 7];\n/// let split_index = partition(&mut data, |elt| *elt >= 3);\n///\n/// assert_eq!(data, [7, 7, 7, 1, 1, 1, 1]);\n/// assert_eq!(split_index, 3);\n/// ```\npub fn partition<'a, A: 'a, I, F>(iter: I, mut pred: F) -> usize\n    where I: IntoIterator<Item = &'a mut A>,\n          I::IntoIter: DoubleEndedIterator,\n          F: FnMut(&A) -> bool\n{\n    let mut split_index = 0;\n    let mut iter = iter.into_iter();\n    'main: while let Some(front) = iter.next() {\n        if !pred(front) {\n            loop {\n                match iter.next_back() {\n                    Some(back) => if pred(back) {\n                        std::mem::swap(front, back);\n                        break;\n                    },\n                    None => break 'main,\n                }\n            }\n        }\n        split_index += 1;\n    }\n    split_index\n}\n\n/// An enum used for controlling the execution of `.fold_while()`.\n///\n/// See [`.fold_while()`](trait.Itertools.html#method.fold_while) for more information.\n#[derive(Copy, Clone, Debug, Eq, PartialEq)]\npub enum FoldWhile<T> {\n    /// Continue folding with this value\n    Continue(T),\n    /// Fold is complete and will return this value\n    Done(T),\n}\n\nimpl<T> FoldWhile<T> {\n    /// Return the value in the continue or done.\n    pub fn into_inner(self) -> T {\n        match self {\n            FoldWhile::Continue(x) | FoldWhile::Done(x) => x,\n        }\n    }\n\n    /// Return true if `self` is `Done`, false if it is `Continue`.\n    pub fn is_done(&self) -> bool {\n        match *self {\n            FoldWhile::Continue(_) => false,\n            FoldWhile::Done(_) => true,\n        }\n    }\n}\n","traces":[{"line":294,"address":[4274240,4274032,4274096],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":299,"address":[4274077,4274285,4274290,4274082,4274157,4274162],"length":1,"stats":{"Line":4},"fn_name":null},{"line":355,"address":[5408832,5408928],"length":1,"stats":{"Line":2},"fn_name":"interleave<quick::Iter<i16, quick::Inexact>,quick::Iter<i16, quick::Inexact>>"},{"line":359,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":373,"address":[4246992,4247093],"length":1,"stats":{"Line":5},"fn_name":"interleave_shortest<core::iter::sources::Repeat<i32>,alloc::vec::IntoIter<i32>>"},{"line":377,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":392,"address":[4267408,4267360],"length":1,"stats":{"Line":5},"fn_name":"intersperse<core::iter::adapters::Map<core::slice::Iter<i32>, closure-1>>"},{"line":396,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":426,"address":[4215043,4214928],"length":1,"stats":{"Line":8},"fn_name":"zip_longest<itertools::adaptors::Batching<core::slice::Iter<core::option::Option<i32>>, closure-0>,core::iter::adapters::Cloned<core::slice::Iter<i32>>>"},{"line":430,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[4239792],"length":1,"stats":{"Line":2},"fn_name":"batching<core::slice::Iter<core::option::Option<i32>>,i32,closure-0>"},{"line":473,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":511,"address":[4371696,4371840,4371648,4371792,4371600,4371744],"length":1,"stats":{"Line":18},"fn_name":"group_by<core::slice::Iter<i32>,&i32,closure-0>"},{"line":516,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":547,"address":[4371072,4371148],"length":1,"stats":{"Line":2},"fn_name":"chunks<core::slice::Iter<i32>>"},{"line":550,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":585,"address":[4242112,4241968,4242016,4242064],"length":1,"stats":{"Line":8},"fn_name":"tuple_windows<core::iter::adapters::Cloned<core::slice::Iter<i32>>,(i32, i32)>"},{"line":590,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[4242160,4242256,4242304,4242208],"length":1,"stats":{"Line":8},"fn_name":"tuples<core::iter::adapters::Cloned<core::slice::Iter<i32>>,(i32, i32, i32)>"},{"line":662,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":683,"address":[4267712],"length":1,"stats":{"Line":3},"fn_name":"tee<core::iter::adapters::Cloned<core::slice::Iter<i32>>>"},{"line":687,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":708,"address":[5040672],"length":1,"stats":{"Line":7},"fn_name":"step<core::ops::range::Range<i32>>"},{"line":711,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":743,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":760,"address":[4273152],"length":1,"stats":{"Line":3},"fn_name":"merge<itertools::adaptors::Step<core::ops::range::Range<i32>>,itertools::adaptors::Step<core::ops::range::Range<i32>>>"},{"line":765,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":784,"address":[4371888,4372020],"length":1,"stats":{"Line":2},"fn_name":"merge_by<core::slice::Iter<(u32, &str)>,core::slice::Iter<(u32, &str)>,closure-0>"},{"line":789,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":824,"address":[4340784],"length":1,"stats":{"Line":1},"fn_name":"merge_join_by<alloc::vec::IntoIter<usize>,alloc::vec::IntoIter<usize>,fn(&usize, &usize) -> core::cmp::Ordering>"},{"line":829,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":849,"address":[4268176,4268048,4268128,4267952,4268000],"length":1,"stats":{"Line":5},"fn_name":"kmerge<core::iter::adapters::Map<core::ops::range::Range<i32>, closure-0>>"},{"line":854,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":878,"address":[4355424,4355344,4355264],"length":1,"stats":{"Line":3},"fn_name":"kmerge_by<alloc::vec::IntoIter<alloc::vec::Vec<i16>>,closure-0>"},{"line":885,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":899,"address":[4710256,4710375],"length":1,"stats":{"Line":8},"fn_name":"cartesian_product<itertools::cons_tuples_impl::ConsTuples<itertools::adaptors::Product<itertools::adaptors::Product<core::ops::range::Range<i32>, core::ops::range::Range<i32>>, core::ops::range::Range<i32>>, ((i32, i32), i32)>,core::ops::range::Range<i32>>"},{"line":905,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":934,"address":[5410496],"length":1,"stats":{"Line":1},"fn_name":"multi_cartesian_product<quick::ShiftRange<quick::Inexact>>"},{"line":940,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":976,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":993,"address":[4371024],"length":1,"stats":{"Line":4},"fn_name":"dedup<core::slice::Iter<i32>>"},{"line":997,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1015,"address":[4371504,4371552,4371456],"length":1,"stats":{"Line":5},"fn_name":"dedup_by<core::slice::Iter<(i32, i32)>,closure-1>"},{"line":1019,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1037,"address":[4369744],"length":1,"stats":{"Line":1},"fn_name":"dedup_with_count<core::slice::Iter<i32>>"},{"line":1040,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1059,"address":[4369840,4369792],"length":1,"stats":{"Line":2},"fn_name":"dedup_by_with_count<core::slice::Iter<(i32, i32)>,closure-1>"},{"line":1063,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1085,"address":[4268224],"length":1,"stats":{"Line":4},"fn_name":"unique<core::iter::adapters::Rev<core::slice::Iter<i32>>>"},{"line":1089,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1111,"address":[4268528],"length":1,"stats":{"Line":3},"fn_name":"unique_by<core::iter::adapters::Rev<core::slice::Iter<&str>>,alloc::string::String,closure-1>"},{"line":1116,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1131,"address":[4215824,4215792],"length":1,"stats":{"Line":9},"fn_name":"peeking_take_while<itertools::adaptors::PutBack<core::ops::range::Range<i32>>,closure-1>"},{"line":1135,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1156,"address":[5765904],"length":1,"stats":{"Line":1},"fn_name":"take_while_ref<core::slice::Iter<u8>,closure-0>"},{"line":1160,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1177,"address":[4267280],"length":1,"stats":{"Line":2},"fn_name":"while_some<core::iter::adapters::Map<core::ops::range::Range<i32>, closure-0>,i32>"},{"line":1180,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1216,"address":[5040576],"length":1,"stats":{"Line":3},"fn_name":"tuple_combinations<core::ops::range::Range<i32>,(i32, i32)>"},{"line":1221,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1254,"address":[4237680],"length":1,"stats":{"Line":3},"fn_name":"combinations<adaptors_no_collect::PanickingCounter>"},{"line":1258,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1281,"address":[4237776],"length":1,"stats":{"Line":2},"fn_name":"combinations_with_replacement<adaptors_no_collect::PanickingCounter>"},{"line":1286,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1327,"address":[4237728],"length":1,"stats":{"Line":5},"fn_name":"permutations<adaptors_no_collect::PanickingCounter>"},{"line":1331,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1351,"address":[4601712,4601632],"length":1,"stats":{"Line":6},"fn_name":"pad_using<alloc::vec::IntoIter<usize>,closure-2>"},{"line":1355,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1377,"address":[5410048],"length":1,"stats":{"Line":2},"fn_name":"with_position<quick::Iter<u8, quick::Exact>>"},{"line":1380,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1434,"address":[4243840],"length":1,"stats":{"Line":3},"fn_name":"next_tuple<core::slice::Iter<i32>,(&i32, &i32)>"},{"line":1438,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1459,"address":[4241689,4241632],"length":1,"stats":{"Line":2},"fn_name":"collect_tuple<core::iter::adapters::Cloned<core::slice::Iter<i32>>,(i32, i32)>"},{"line":1463,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":1464,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1465,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1466,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1468,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1483,"address":[4242256,4242332],"length":1,"stats":{"Line":1},"fn_name":"find_position<Iterator,closure-1>"},{"line":1486,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1487,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1488,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1489,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1491,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1493,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1512,"address":[4607532,4607424],"length":1,"stats":{"Line":2},"fn_name":"all_equal<core::str::Chars>"},{"line":1516,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1517,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1518,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":1537,"address":[4327744,4327712],"length":1,"stats":{"Line":2},"fn_name":"dropping<core::slice::Iter<i32>>"},{"line":1540,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1541,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1543,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1565,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1566,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1568,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1589,"address":[4242784],"length":1,"stats":{"Line":2},"fn_name":"foreach<&mut Iterator,closure-0>"},{"line":1593,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1609,"address":[4601552,4601472],"length":1,"stats":{"Line":2},"fn_name":"concat<alloc::vec::IntoIter<alloc::vec::Vec<()>>>"},{"line":1613,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1619,"address":[4267328],"length":1,"stats":{"Line":9},"fn_name":"collect_vec<core::iter::adapters::Map<itertools::groupbylazy::Groups<char, core::str::Chars, closure-3>, closure-4>>"},{"line":1622,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1651,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1670,"address":[4327935,4328368,4328443,4327872],"length":1,"stats":{"Line":2},"fn_name":"set_from<core::slice::IterMut<i32>,i32,core::ops::range::Range<i32>>"},{"line":1674,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1675,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1676,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1677,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1678,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1680,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1682,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1696,"address":[4370833,4369888],"length":1,"stats":{"Line":1},"fn_name":"join<core::slice::Iter<i32>>"},{"line":1699,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1700,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1701,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1703,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1704,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1705,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1706,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1707,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1708,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1710,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1730,"address":[4371264,4371312],"length":1,"stats":{"Line":2},"fn_name":"format<core::slice::Iter<i32>>"},{"line":1733,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1772,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1821,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1822,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1823,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1824,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1827,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1853,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1854,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1855,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1856,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1859,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1874,"address":[4267826,4267760],"length":1,"stats":{"Line":7},"fn_name":"fold1<core::iter::adapters::Map<core::slice::Iter<itertools::kmerge_impl::HeadTail<core::ops::range::Range<i32>>>, closure-0>,fn((usize, core::option::Option<usize>), (usize, core::option::Option<usize>)) -> (usize, core::option::Option<usize>)>"},{"line":1878,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":1929,"address":[4267053,4267024],"length":1,"stats":{"Line":3},"fn_name":"tree_fold1<core::iter::adapters::Map<core::ops::range::Range<usize>, closure-0>,closure-1>"},{"line":1933,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1935,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1936,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1937,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1938,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1944,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1945,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1946,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1947,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1948,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1949,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1950,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1953,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1954,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1955,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1956,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1958,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":1959,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1962,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1963,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1964,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1966,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1968,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1969,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1975,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1976,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1979,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1982,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1983,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1984,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2028,"address":[4600444,4600384],"length":1,"stats":{"Line":1},"fn_name":"fold_while<alloc::vec::IntoIter<i32>,i32,closure-0>"},{"line":2032,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2033,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":2034,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2035,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2036,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2039,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2063,"address":[4298800,4298844],"length":1,"stats":{"Line":1},"fn_name":"sum1<core::iter::adapters::Cloned<core::slice::Iter<i32>>,i32>"},{"line":2067,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2068,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":2091,"address":[4299052,4299008],"length":1,"stats":{"Line":1},"fn_name":"product1<core::iter::adapters::Cloned<core::slice::Iter<i32>>,i32>"},{"line":2095,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2096,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":2124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2153,"address":[4268359,4268272],"length":1,"stats":{"Line":2},"fn_name":"sorted_by<core::iter::adapters::Cloned<core::slice::Iter<i32>>,closure-0>"},{"line":2157,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2158,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":2159,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2186,"address":[4267543,4267456],"length":1,"stats":{"Line":2},"fn_name":"sorted_by_key<core::iter::adapters::Cloned<core::slice::Iter<i32>>,i32,closure-0>"},{"line":2191,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2192,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":2193,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2249,"address":[4911168],"length":1,"stats":{"Line":1},"fn_name":"into_group_map<core::iter::adapters::Map<alloc::vec::IntoIter<u8>, closure-0>,u8,u8>"},{"line":2253,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2291,"address":[4371360],"length":1,"stats":{"Line":5},"fn_name":"minmax<core::slice::Iter<test_std::minmax::Val>>"},{"line":2294,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":2308,"address":[4369696],"length":1,"stats":{"Line":1},"fn_name":"minmax_by_key<core::slice::Iter<test_std::minmax::Val>,u32,closure-0>"},{"line":2311,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":2322,"address":[4372140,4372096],"length":1,"stats":{"Line":1},"fn_name":"minmax_by<core::slice::Iter<test_std::minmax::Val>,closure-1>"},{"line":2325,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2327,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2328,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":2354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2439,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2465,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2466,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2493,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2494,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2495,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2545,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2546,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2547,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2548,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2549,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2591,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2592,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2593,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2594,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2595,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2634,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2635,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2636,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2637,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2638,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2659,"address":[4296416,4296491,4297227,4295680,4295755,4297963,4297152,4297888],"length":1,"stats":{"Line":5},"fn_name":"exactly_one<core::iter::adapters::Filter<core::ops::range::Range<i32>, closure-0>>"},{"line":2663,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":2664,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":2665,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":2666,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":2667,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":2669,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2670,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2674,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":2697,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2714,"address":[5032185,5042465,5029417,5030753,5035761,5043008,5040517,5029296,5028656,5033609,5037133,5032064,5040384,5041787,5034864,5034985,5043173,5032784,5026352,5036960,5039760,5027225,5030608,5039881,5041024,5036320,5037680,5037822,5026491,5034240,5039104,5039225,5042304,5031312,5038368,5038492,5028779,5031433,5027104,5027995,5027856,5029920,5041151,5034355,5032929,5030041,5033488,5035616,5036447,5041664],"length":1,"stats":{"Line":25},"fn_name":"equal<itertools::zip_eq_impl::ZipEq<core::slice::Iter<i32>, core::slice::Iter<i32>>,core::iter::adapters::zip::Zip<core::slice::Iter<i32>, core::slice::Iter<i32>>>"},{"line":2719,"address":[5034871,5036983,5026359,5029303,5030615,5040391,5027111,5035623,5038375,5037687,5039127,5041679,5029943,5028671,5032071,5043023,5034247,5032791,5036327,5033495,5039767,5041031,5031319,5027863,5042327],"length":1,"stats":{"Line":25},"fn_name":null},{"line":2720,"address":[5040449,5037041,5039825,5038433,5032129,5042385,5043081,5041089,5036385,5034929,5039190,5028729,5034305,5030006,5030061,5027169,5037754,5039245,5029361,5041737,5032849,5026420,5031377,5030673,5033553,5027936,5035681],"length":1,"stats":{"Line":27},"fn_name":null},{"line":2721,"address":[5031785,5035337,5037837,5034370,5041802,5032944,5029061,5039263,5039896,5037148,5031448,5036462,5040159,5043455,5028794,5035000,5030370,5027577,5031054,5032200,5035776,5037425,5042065,5036068,5033624,5033236,5028375,5029695,5029432,5032540,5034648,5027240,5036740,5030768,5038507,5038853,5039526,5041166,5040810,5040532,5042757,5043188,5028010,5041444,5030079,5026506,5038129,5026852,5042480,5033961],"length":1,"stats":{"Line":50},"fn_name":null},{"line":2722,"address":[5039980,5038543,5029444,5033685,5027301,5029516,5042578,5035812,5037246,5028059,5041243,5028801,5039275,5035018,5043223,5037193,5027366,5032980,5030780,5030872,5032236,5033750,5035788,5041814,5041886,5027258,5031466,5037938,5026618,5039908,5028135,5041833,5042487,5043276,5037155,5032212,5030101,5034390,5039294,5036539,5033045,5039927,5028882,5030811,5040609,5041186,5042525,5039347,5029463,5030120,5033642,5032956,5030177,5034447,5038619,5043195,5031574,5028022,5035877,5037849,5031509,5032309,5035061,5038519,5035126,5028829,5036482,5037873,5026542,5040552,5026518],"length":1,"stats":{"Line":46},"fn_name":null},{"line":2723,"address":[5041841,5039435,5040703,5030269,5031674,5042533,5036491,5035082,5037334,5032257,5040068,5035977,5028837,5028884,5036633,5033001,5039982,5035833,5038564,5032311,5028262,5033752,5035128,5031576,5035226,5027466,5037894,5029518,5027322,5030179,5038038,5040611,5043231,5030829,5033850,5033047,5026620,5040561,5037201,5026745,5026563,5041245,5042580,5038621,5034541,5030965,5036541,5028080,5033145,5028137,5029604,5043278,5041337,5028970,5043364,5042666,5030874,5038746,5039349,5027368,5035879,5041195,5037248,5029471,5041974,5034399,5030128,5032433,5039302,5039935,5041888,5031530,5034449,5033706,5037940],"length":1,"stats":{"Line":50},"fn_name":null},{"line":2724,"address":[5043421,5034543,5032391,5041934,5041976,5027468,5040125,5033907,5033816,5040028,5031676,5040070,5037336,5026703,5026747,5035943,5037391,5029661,5040663,5029027,5041297,5031731,5040776,5027432,5031640,5035228,5041339,5036034,5038748,5033852,5033147,5035979,5028972,5033202,5041410,5038819,5036635,5037294,5042031,5032435,5043366,5028335,5030271,5038704,5038095,5043324,5028220,5034614,5030967,5039492,5034501,5040705,5042668,5030930,5028930,5028264,5030229,5036706,5026818,5029606,5039395,5030326,5038040,5042723,5039437,5036593,5035283,5029564,5033111,5035192,5031020,5032506,5038004,5027523,5042626],"length":1,"stats":{"Line":50},"fn_name":null},{"line":2725,"address":[5040058,5030955,5029594,5028960,5035967,5026735,5035216,5030259,5034531,5038028,5036623,5039425,5032423,5040693,5042656,5033840,5038736,5041327,5037324,5043354,5028252,5033135,5027456,5041964,5031664],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2727,"address":[5031554,5026862,5042563,5040599,5028115,5028867,5034437,5038863,5041233,5035106,5040169,5041457,5043261,5043465,5029705,5028385,5029501,5030153,5033246,5033730,5038139,5042075,5032289,5037435,5041871,5035347,5037918,5031063,5030854,5026598,5027587,5032550,5036529,5034661,5033971,5036753,5039536,5040823,5039332,5029071,5036078,5042767,5031795,5038599,5027346,5030380,5033025,5039965,5035857,5037231],"length":1,"stats":{"Line":50},"fn_name":null},{"line":2742,"address":[4638906,4631136,4647824,4654352,4621904,4644324,4636383,4616621,4655648,4637488,4635158,4643064,4629920,4642864,4652928,4619008,4649120,4646592,4651648,4617912,4632432,4620724,4630037,4623298,4628730,4615327,4658224,4624856,4631336,4637605,4620560,4659684,4661007,4653104,4641552,4646719,4619198,4640256,4650416,4657044,4622068,4615184,4654552,4662307,4644160,4647999,4638704,4628576,4627312,4649276,4641694,4663456,4634992,4617712,4640456,4656880,4650543,4659520,4662144,4636256,4616480,4624656,4651835,4627454,4625952,4658424,4632549,4663648,4655775,4633648,4633802,4660864,4645376,4623120,4645540,4626137],"length":1,"stats":{"Line":49},"fn_name":"assert_equal<itertools::kmerge_impl::KMergeBy<itertools::adaptors::Step<core::ops::range::Range<i32>>, itertools::kmerge_impl::KMergeByLt>,core::ops::range::Range<i32>>"},{"line":2748,"address":[4631159,4658247,4651671,4655663,4662167,4647847,4660885,4659543,4641559,4616511,4624679,4633655,4645399,4620583,4634999,4646607,4615205,4623127,4619015,4632455,4625995,4628583,4617735,4636271,4638711,4642887,4652935,4621927,4656903,4654375,4644183,4627319,4650431,4663471,4640279,4649141,4629943,4637511],"length":1,"stats":{"Line":49},"fn_name":null},{"line":2749,"address":[4616574,4617814,4642966,4653042,4640358,4660964,4623236,4636344,4619136,4641632,4661029,4662260,4615349,4646742,4644262,4654454,4629998,4632510,4627392,4646680,4647952,4658326,4631238,4659622,4645478,4663550,4651788,4616644,4628668,4626160,4650504,4651858,4655798,4656982,4662330,4620662,4626090,4630060,4632572,4633740,4637628,4615284,4648022,4649214,4637566,4650566,4636406,4655736,4635084,4624758,4638844,4622006],"length":1,"stats":{"Line":69},"fn_name":null},{"line":2750,"address":[4651882,4628745,4641709,4657059,4659699,4653119,4623313,4638921,4627469,4630084,4649291,4655822,4646766,4640471,4632596,4615370,4644339,4645555,4658439,4620739,4650590,4626184,4636430,4661050,4663663,4633817,4619213,4637652,4648046,4624871,4631351,4635173,4654567,4643079,4616668,4617927,4662354,4622083],"length":1,"stats":{"Line":50},"fn_name":null},{"line":2751,"address":[4626195,4661061,4657070,4651893,4624882,4627480,4619224,4620750,4642675,4643090,4624450,4655460,4628756,4659332,4656715,4653130,4629731,4651483,4664568,4641376,4640058,4645206,4646422,4620350,4637323,4622950,4661976,4635184,4633828,4630963,4617550,4647659,4659710,4631362,4617938,4616310,4618820,4627136,4632244,4646777,4648954,4649302,4623324,4660699,4652761,4637663,4636441,4645566,4621739,4638932,4632607,4648057,4638531,4654173,4658059,4654578,4663674,4650601,4628386,4650231,4643972,4658450,4616679,4622094,4634803,4636090,4615381,4630095,4633475,4662365,4663294,4655833,4640482,4641720,4625764,4644350],"length":1,"stats":{"Line":100},"fn_name":null},{"line":2752,"address":[4646805,4617953,4623398,4619298,4663804,4620765,4661076,4651933,4662393,4661229,4637678,4645683,4623531,4630212,4630110,4640535,4646907,4655861,4636469,4632647,4658580,4650731,4650654,4662452,4649483,4631492,4652010,4635220,4653166,4620830,4633856,4653337,4654593,4648109,4659790,4646830,4619431,4630135,4634034,4659725,4616718,4618068,4622134,4645606,4654631,4638968,4643105,4645581,4644365,4628962,4655963,4640612,4620947,4643220,4615562,4639139,4663689,4657085,4662546,4635329,4628784,4622109,4641914,4661135,4639006,4649389,4649317,4655886,4615409,4626223,4631415,4622211,4633934,4640497,4627541,4654708,4632724,4644390,4659907,4625012,4628862,4619260,4657267,4644467,4653204,4627503,4637780,4636571,4626282,4616694,4627625,4641748,4663727,4641820,4632622,4626376,4617991,4635245,4648188,4631377,4658465,4650629,4624897,4624935,4637703,4623360,4615468,4636494,4643143,4616797,4648085,4651908,4657150,4658503],"length":1,"stats":{"Line":100},"fn_name":null},{"line":2753,"address":[4650705,4618074,4632698,4620956,4622185,4659916,4658586,4626359,4646881,4640618,4616803,4640586,4635331,4641919,4644473,4648194,4635312,4624986,4634039,4653311,4650737,4644441,4662529,4653346,4661212,4634021,4630218,4631498,4616764,4619405,4661234,4630186,4662551,4663810,4639161,4652016,4620921,4627608,4631466,4643194,4632730,4625018,4657276,4654714,4615567,4618042,4626381,4646913,4639113,4659881,4655937,4627627,4636545,4637786,4623505,4649466,4649488,4654682,4623553,4657241,4663778,4641897,4655969,4636577,4643226,4637754,4651984,4615545,4628967,4622217,4648155,4645657,4628949,4658554,4645689,4619453],"length":1,"stats":{"Line":100},"fn_name":null},{"line":2754,"address":[4616837,4620988,4630246,4661249,4636605,4648228,4615582,4619485,4657308,4663838,4631526,4659948,4622245,4626396,4652044,4649503,4634050,4658614,4662566,4625046,4632758,4650765,4655997,4639193,4643254,4645717,4640646,4654742,4637814,4618102,4623585,4635346,4644501,4646941,4653378,4627642,4641934,4628978],"length":1,"stats":{"Line":50},"fn_name":null},{"line":2755,"address":[4649559,4635599,4652270,4630472,4661485,4618134,4660096,4653688,4662809,4621052,4660208,4642090,4629240,4638040,4648256,4654975,4627702,4662622,4645937,4625174,4631558,4650797,4656230,4618230,4623681,4615725,4627789,4639519,4641990,4640885,4621248,4630361,4653583,4646973,4619703,4647174,4645832,4639411,4649746,4653474,4640774,4652159,4662709,4623803,4663870,4644533,4644616,4648469,4652076,4632790,4645749,4658847,4661379,4637929,4618335,4636838,4621136,4626452,4619581,4625279,4636733,4649646,4626539,4661305,4664077,4648358,4615638,4637846,4626645,4634312,4635406,4636637,4622360,4625078,4634114,4632873,4644721,4654774,4658646,4616954,4663966,4627895,4619811,4643382,4634210,4656125,4629138,4643487,4656029,4647069,4623911,4617065,4650893,4632984,4631759,4660012,4654870,4657456,4615825,4643286,4639289,4640678,4658742,4630278,4622465,4616865,4631654,4629042,4622277,4642190,4650998,4657372,4635493,4657568],"length":1,"stats":{"Line":100},"fn_name":null},{"line":2756,"address":[4642022,4623812,4632879,4629140,4643388,4649591,4627734,4663972,4657462,4625180,4615670,4615727,4635495,4642092,4663902,4662654,4661337,4630310,4630367,4650829,4660044,4618236,4631590,4657404,4637935,4654806,4660102,4632822,4645838,4656061,4621084,4654876,4618166,4622309,4622366,4649648,4648364,4639321,4639420,4644565,4616897,4658678,4631660,4648288,4647075,4616960,4636739,4619613,4634212,4662711,4645781,4635438,4621142,4627791,4661381,4658748,4626484,4634146,4629074,4643318,4653589,4623713,4656131,4652108,4652165,4619712,4650899,4640780,4625110,4636669,4644622,4626541,4653506,4647005,4637878,4640710],"length":1,"stats":{"Line":100},"fn_name":null},{"line":2757,"address":[4629130,4648350,4634202,4630353,4656117,4643374,4647061,4626531,4622352,4657448,4658734,4623795,4627781,4644608,4637921,4645824,4663958,4619695,4662701,4621128,4642082,4632865,4615717,4636725,4640766,4650885,4649638,4635485,4625166,4653575,4618222,4660088,4639403,4616946,4652151,4631646,4654862,4661371],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2759,"address":[4662861,4627950,4621303,4660217,4638095,4649798,4640894,4660263,4645989,4642242,4661494,4619889,4638049,4640940,4656239,4630481,4653697,4636890,4654984,4625288,4618387,4652279,4629249,4651007,4632993,4615877,4623946,4635608,4643539,4623989,4648478,4622517,4617117,4631768,4644773,4622474,4655027,4661540,4615834,4635654,4653740,4633039,4643496,4625331,4644730,4647226,4651050,4658899,4636847,4639554,4658856,4662818,4619846,4629295,4631811,4642199,4634367,4649755,4664132,4657623,4617074,4626654,4626700,4630527,4634321,4645946,4648521,4652325,4656282,4647183,4664086,4657577,4618344,4627904,4639597,4621257],"length":1,"stats":{"Line":50},"fn_name":null},{"line":2760,"address":[4647281,4649853,4658954,4622572,4628005,4639652,4660318,4644828,4631866,4638150,4624044,4630582,4657678,4661595,4664187,4625386,4651105,4662916,4655082,4636945,4640995,4648576,4618442,4635709,4629350,4633094,4617172,4643594,4646044,4656337,4626755,4619944,4621358,4642297,4653795,4615932,4652380,4634422],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2761,"address":[4645959,4662831,4663426,4659477,4621901,4626667,4631781,4651645,4663456,4663285,4623959,4643509,4650376,4658050,4624595,4616442,4628531,4619859,4650406,4656706,4654164,4647791,4625939,4655635,4649116,4618965,4620495,4651020,4625301,4652752,4664713,4627917,4660690,4644743,4660861,4631095,4631125,4632235,4647821,4642666,4655605,4625755,4649086,4627127,4636860,4643963,4621730,4654318,4645338,4617087,4638522,4656847,4644147,4645368,4640021,4637314,4661967,4628561,4629877,4617712,4647650,4615847,4630954,4648491,4618811,4628377,4652893,4651474,4622487,4664559,4629262,4644117,4655451,4625909,4648945,4618357,4633466,4656252,4623112,4658191,4629722,4627268,4633607,4659507,4632419,4664743,4634949,4646554,4640907,4630494,4646584,4616472,4634794,4642820,4640203,4662108,4652292,4638062,4664099,4621871,4636081,4641521,4642212,4627298,4634334,4638693,4623082,4653710,4639567,4617682,4621270,4658221,4658869,4659323,4651615,4633637,4660230,4636222,4645197,4637455,4636252,4652923,4635621,4657590,4629907,4650222,4620313,4617541,4649768,4656877,4624413,4641551,4660831,4633006,4634979,4637485,4642850,4654997,4622941,4661507,4616301,4641367,4647196,4662138,4638663,4618995,4654348,4632389,4646413],"length":1,"stats":{"Line":100},"fn_name":"assert_equal<core::slice::Iter<&str>,itertools::unique_impl::UniqueBy<core::slice::Iter<&str>, alloc::string::String, closure-0>>"},{"line":2784,"address":[4225984,4225024,4225504,4226047,4225087,4225567],"length":1,"stats":{"Line":4},"fn_name":"partition<i32,&mut [i32; 9],closure-2>"},{"line":2789,"address":[4225039,4225519,4225999],"length":1,"stats":{"Line":4},"fn_name":null},{"line":2790,"address":[4225528,4226008,4225048],"length":1,"stats":{"Line":4},"fn_name":null},{"line":2791,"address":[4226361,4225589,4225401,4225565,4226069,4226092,4225085,4225612,4225109,4225132,4225881,4226045],"length":1,"stats":{"Line":16},"fn_name":null},{"line":2792,"address":[4225843,4226323,4226136,4225176,4225363,4225656],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2793,"address":[4226304,4225344,4225824],"length":1,"stats":{"Line":3},"fn_name":null},{"line":2794,"address":[4225227,4225279,4226239,4225707,4226187,4225759],"length":1,"stats":{"Line":4},"fn_name":null},{"line":2795,"address":[4226241,4225281,4225252,4225732,4225761,4226212],"length":1,"stats":{"Line":8},"fn_name":null},{"line":2796,"address":[4225836,4226316,4225356],"length":1,"stats":{"Line":4},"fn_name":null},{"line":2799,"address":[4225757,4225277,4226237],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2803,"address":[4225847,4225461,4225941,4226327,4225367,4226421],"length":1,"stats":{"Line":4},"fn_name":null},{"line":2821,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2822,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2823,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2828,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2829,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2830,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2831,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":211,"coverable":299},{"path":["/","usr","src","itertools","src","merge_join.rs"],"content":"use std::cmp::Ordering;\nuse std::iter::Fuse;\nuse std::fmt;\n\nuse super::adaptors::{PutBack, put_back};\nuse crate::either_or_both::EitherOrBoth;\n\n/// Return an iterator adaptor that merge-joins items from the two base iterators in ascending order.\n///\n/// See [`.merge_join_by()`](trait.Itertools.html#method.merge_join_by) for more information.\npub fn merge_join_by<I, J, F>(left: I, right: J, cmp_fn: F)\n    -> MergeJoinBy<I::IntoIter, J::IntoIter, F>\n    where I: IntoIterator,\n          J: IntoIterator,\n          F: FnMut(&I::Item, &J::Item) -> Ordering\n{\n    MergeJoinBy {\n        left: put_back(left.into_iter().fuse()),\n        right: put_back(right.into_iter().fuse()),\n        cmp_fn,\n    }\n}\n\n/// An iterator adaptor that merge-joins items from the two base iterators in ascending order.\n///\n/// See [`.merge_join_by()`](../trait.Itertools.html#method.merge_join_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MergeJoinBy<I: Iterator, J: Iterator, F> {\n    left: PutBack<Fuse<I>>,\n    right: PutBack<Fuse<J>>,\n    cmp_fn: F\n}\n\nimpl<I, J, F> Clone for MergeJoinBy<I, J, F>\n    where I: Iterator,\n          J: Iterator,\n          PutBack<Fuse<I>>: Clone,\n          PutBack<Fuse<J>>: Clone,\n          F: Clone,\n{\n    clone_fields!(left, right, cmp_fn);\n}\n\nimpl<I, J, F> fmt::Debug for MergeJoinBy<I, J, F>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n          J: Iterator + fmt::Debug,\n          J::Item: fmt::Debug,\n{\n    debug_fmt_fields!(MergeJoinBy, left, right);\n}\n\nimpl<I, J, F> Iterator for MergeJoinBy<I, J, F>\n    where I: Iterator,\n          J: Iterator,\n          F: FnMut(&I::Item, &J::Item) -> Ordering\n{\n    type Item = EitherOrBoth<I::Item, J::Item>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match (self.left.next(), self.right.next()) {\n            (None, None) => None,\n            (Some(left), None) =>\n                Some(EitherOrBoth::Left(left)),\n            (None, Some(right)) =>\n                Some(EitherOrBoth::Right(right)),\n            (Some(left), Some(right)) => {\n                match (self.cmp_fn)(&left, &right) {\n                    Ordering::Equal =>\n                        Some(EitherOrBoth::Both(left, right)),\n                    Ordering::Less => {\n                        self.right.put_back(right);\n                        Some(EitherOrBoth::Left(left))\n                    },\n                    Ordering::Greater => {\n                        self.left.put_back(left);\n                        Some(EitherOrBoth::Right(right))\n                    }\n                }\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (a_lower, a_upper) = self.left.size_hint();\n        let (b_lower, b_upper) = self.right.size_hint();\n\n        let lower = ::std::cmp::max(a_lower, b_lower);\n\n        let upper = match (a_upper, b_upper) {\n            (Some(x), Some(y)) => x.checked_add(y),\n            _ => None,\n        };\n\n        (lower, upper)\n    }\n\n    fn count(mut self) -> usize {\n        let mut count = 0;\n        loop {\n            match (self.left.next(), self.right.next()) {\n                (None, None) => break count,\n                (Some(_left), None) => break count + 1 + self.left.into_parts().1.count(),\n                (None, Some(_right)) => break count + 1 + self.right.into_parts().1.count(),\n                (Some(left), Some(right)) => {\n                    count += 1;\n                    match (self.cmp_fn)(&left, &right) {\n                        Ordering::Equal => {}\n                        Ordering::Less => self.right.put_back(right),\n                        Ordering::Greater => self.left.put_back(left),\n                    }\n                }\n            }\n        }\n    }\n\n    fn last(mut self) -> Option<Self::Item> {\n        let mut previous_element = None;\n        loop {\n            match (self.left.next(), self.right.next()) {\n                (None, None) => break previous_element,\n                (Some(left), None) => {\n                    break Some(EitherOrBoth::Left(\n                        self.left.into_parts().1.last().unwrap_or(left),\n                    ))\n                }\n                (None, Some(right)) => {\n                    break Some(EitherOrBoth::Right(\n                        self.right.into_parts().1.last().unwrap_or(right),\n                    ))\n                }\n                (Some(left), Some(right)) => {\n                    previous_element = match (self.cmp_fn)(&left, &right) {\n                        Ordering::Equal => Some(EitherOrBoth::Both(left, right)),\n                        Ordering::Less => {\n                            self.right.put_back(right);\n                            Some(EitherOrBoth::Left(left))\n                        }\n                        Ordering::Greater => {\n                            self.left.put_back(left);\n                            Some(EitherOrBoth::Right(right))\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n        loop {\n            if n == 0 {\n                break self.next();\n            }\n            n -= 1;\n            match (self.left.next(), self.right.next()) {\n                (None, None) => break None,\n                (Some(_left), None) => break self.left.nth(n).map(EitherOrBoth::Left),\n                (None, Some(_right)) => break self.right.nth(n).map(EitherOrBoth::Right),\n                (Some(left), Some(right)) => match (self.cmp_fn)(&left, &right) {\n                    Ordering::Equal => {}\n                    Ordering::Less => self.right.put_back(right),\n                    Ordering::Greater => self.left.put_back(left),\n                },\n            }\n        }\n    }\n}\n","traces":[{"line":11,"address":[4243624,4243520,4241440,4241856,4242688,4242792,4243208,4242376,4243104,4243936,4241544,4244040,4241960,4242272],"length":1,"stats":{"Line":8},"fn_name":"merge_join_by<alloc::vec::Vec<u32>,alloc::vec::Vec<u32>,closure-0>"},{"line":18,"address":[4244083,4241587,4242698,4242419,4242835,4243251,4242282,4242003,4243530,4241866,4243114,4243667,4243946,4241450],"length":1,"stats":{"Line":16},"fn_name":null},{"line":19,"address":[4243761,4244090,4242097,4242426,4242513,4242929,4241594,4242842,4242010,4243258,4243345,4243674,4244177,4241681],"length":1,"stats":{"Line":16},"fn_name":null},{"line":60,"address":[4234528,4236262,4237024,4235430,4232864,4232934,4233696,4234598,4232102,4237094,4233766,4232032,4235360,4236192],"length":1,"stats":{"Line":9},"fn_name":"next<alloc::vec::IntoIter<u32>,alloc::vec::IntoIter<u32>,closure-0>"},{"line":61,"address":[4233252,4232372,4232050,4233988,4235542,4233856,4236484,4237316,4233046,4233714,4232762,4233024,4235258,4236922,4237042,4232954,4237114,4234710,4237184,4236090,4233786,4236210,4234036,4236374,4236532,4235450,4237364,4237754,4233156,4232122,4234618,4233878,4234916,4233594,4235378,4235700,4235520,4237206,4232214,4232420,4232882,4234084,4232192,4234688,4234820,4232324,4235748,4233204,4235652,4236352,4236580,4234426,4237412,4236282,4234546,4234868],"length":1,"stats":{"Line":43},"fn_name":null},{"line":62,"address":[4233008,4235646,4237168,4233860,4237188,4234814,4234672,4232196,4232318,4233150,4233028,4236356,4233840,4237310,4233982,4232176,4235524,4236336,4235504,4234692,4236478],"length":1,"stats":{"Line":27},"fn_name":null},{"line":63,"address":[4234825,4232216,4234712,4235544,4236376,4237208,4237321,4236489,4232329,4233048,4233161,4235657,4233880,4233993],"length":1,"stats":{"Line":11},"fn_name":null},{"line":64,"address":[4237332,4232340,4234836,4234004,4233172,4235668,4236500],"length":1,"stats":{"Line":4},"fn_name":null},{"line":65,"address":[4237369,4232377,4234041,4233209,4234873,4235705,4236537],"length":1,"stats":{"Line":5},"fn_name":null},{"line":66,"address":[4235716,4237380,4232388,4234052,4236548,4233220,4234884],"length":1,"stats":{"Line":5},"fn_name":null},{"line":67,"address":[4232229,4235557,4233061,4234725,4236389,4237221,4233893],"length":1,"stats":{"Line":6},"fn_name":null},{"line":68,"address":[4234352,4235924,4233098,4236016,4235015,4232429,4237421,4233428,4234260,4232688,4235092,4237588,4236756,4232266,4233351,4237258,4232519,4235184,4235757,4235847,4234093,4234762,4236426,4234925,4236589,4237680,4236848,4233930,4235594,4233261,4233520,4234183,4236679,4232596,4237511],"length":1,"stats":{"Line":19},"fn_name":null},{"line":69,"address":[4234929,4234097,4235761,4237425,4233265,4236593,4232433],"length":1,"stats":{"Line":6},"fn_name":null},{"line":70,"address":[4234185,4235849,4232521,4236681,4233353,4237513,4235017],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[4235102,4237598,4235934,4236766,4232606,4233438,4234270],"length":1,"stats":{"Line":5},"fn_name":null},{"line":73,"address":[4233464,4235960,4237624,4235128,4232632,4234296,4236792],"length":1,"stats":{"Line":5},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[4232492,4233324,4236652,4234988,4235820,4237484,4234156],"length":1,"stats":{"Line":5},"fn_name":null},{"line":77,"address":[4235186,4236850,4234354,4233522,4232690,4236018,4237682],"length":1,"stats":{"Line":5},"fn_name":null},{"line":84,"address":[4239056,4239456,4239856,4240256,4237856,4238256,4238656],"length":1,"stats":{"Line":8},"fn_name":"size_hint<alloc::vec::IntoIter<u32>,alloc::vec::IntoIter<u32>,closure-0>"},{"line":85,"address":[4238274,4239874,4238674,4239074,4237874,4240274,4239474],"length":1,"stats":{"Line":8},"fn_name":null},{"line":86,"address":[4239952,4240352,4238352,4238752,4237952,4239152,4239552],"length":1,"stats":{"Line":8},"fn_name":null},{"line":88,"address":[4238028,4240028,4239228,4238828,4238428,4240428,4239628],"length":1,"stats":{"Line":8},"fn_name":null},{"line":90,"address":[4240064,4240464,4238064,4240531,4239331,4239664,4240600,4238531,4238600,4239000,4239400,4239800,4238931,4238131,4240200,4239264,4240131,4238864,4238200,4238464,4239731],"length":1,"stats":{"Line":16},"fn_name":null},{"line":91,"address":[4238511,4240533,4239733,4238133,4238533,4238111,4240111,4238933,4239711,4239311,4239333,4238911,4240133,4240511],"length":1,"stats":{"Line":16},"fn_name":null},{"line":92,"address":[4238922,4238122,4238522,4239722,4240522,4240122,4239322],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[4238602,4239002,4239802,4238202,4239402,4240202,4240602],"length":1,"stats":{"Line":8},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":51,"coverable":74},{"path":["/","usr","src","itertools","src","minmax.rs"],"content":"\n/// `MinMaxResult` is an enum returned by `minmax`. See `Itertools::minmax()` for\n/// more detail.\n#[derive(Copy, Clone, PartialEq, Debug)]\npub enum MinMaxResult<T> {\n    /// Empty iterator\n    NoElements,\n\n    /// Iterator with one element, so the minimum and maximum are the same\n    OneElement(T),\n\n    /// More than one element in the iterator, the first element is not larger\n    /// than the second\n    MinMax(T, T)\n}\n\nimpl<T: Clone> MinMaxResult<T> {\n    /// `into_option` creates an `Option` of type `(T, T)`. The returned `Option`\n    /// has variant `None` if and only if the `MinMaxResult` has variant\n    /// `NoElements`. Otherwise `Some((x, y))` is returned where `x <= y`.\n    /// If the `MinMaxResult` has variant `OneElement(x)`, performing this\n    /// operation will make one clone of `x`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::MinMaxResult::{self, NoElements, OneElement, MinMax};\n    ///\n    /// let r: MinMaxResult<i32> = NoElements;\n    /// assert_eq!(r.into_option(), None);\n    ///\n    /// let r = OneElement(1);\n    /// assert_eq!(r.into_option(), Some((1, 1)));\n    ///\n    /// let r = MinMax(1, 2);\n    /// assert_eq!(r.into_option(), Some((1, 2)));\n    /// ```\n    pub fn into_option(self) -> Option<(T,T)> {\n        match self {\n            MinMaxResult::NoElements => None,\n            MinMaxResult::OneElement(x) => Some((x.clone(), x)),\n            MinMaxResult::MinMax(x, y) => Some((x, y))\n        }\n    }\n}\n\n/// Implementation guts for `minmax` and `minmax_by_key`.\npub fn minmax_impl<I, K, F, L>(mut it: I, mut key_for: F,\n                               mut lt: L) -> MinMaxResult<I::Item>\n    where I: Iterator,\n          F: FnMut(&I::Item) -> K,\n          L: FnMut(&I::Item, &I::Item, &K, &K) -> bool,\n{\n    let (mut min, mut max, mut min_key, mut max_key) = match it.next() {\n        None => return MinMaxResult::NoElements,\n        Some(x) => {\n            match it.next() {\n                None => return MinMaxResult::OneElement(x),\n                Some(y) => {\n                    let xk = key_for(&x);\n                    let yk = key_for(&y);\n                    if !lt(&y, &x, &yk, &xk) {(x, y, xk, yk)} else {(y, x, yk, xk)}\n                }\n            }\n        }\n    };\n\n    loop {\n        // `first` and `second` are the two next elements we want to look\n        // at.  We first compare `first` and `second` (#1). The smaller one\n        // is then compared to current minimum (#2). The larger one is\n        // compared to current maximum (#3). This way we do 3 comparisons\n        // for 2 elements.\n        let first = match it.next() {\n            None => break,\n            Some(x) => x\n        };\n        let second = match it.next() {\n            None => {\n                let first_key = key_for(&first);\n                if lt(&first, &min, &first_key, &min_key) {\n                    min = first;\n                } else if !lt(&first, &max, &first_key, &max_key) {\n                    max = first;\n                }\n                break;\n            }\n            Some(x) => x\n        };\n        let first_key = key_for(&first);\n        let second_key = key_for(&second);\n        if !lt(&second, &first, &second_key, &first_key) {\n            if lt(&first, &min, &first_key, &min_key) {\n                min = first;\n                min_key = first_key;\n            }\n            if !lt(&second, &max, &second_key, &max_key) {\n                max = second;\n                max_key = second_key;\n            }\n        } else {\n            if lt(&second, &min, &second_key, &min_key) {\n                min = second;\n                min_key = second_key;\n            }\n            if !lt(&first, &max, &first_key, &max_key) {\n                max = first;\n                max_key = first_key;\n            }\n        }\n    }\n\n    MinMaxResult::MinMax(min, max)\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[5132256,5132377,5128880,5122704,5119600,5125902,5122814,5129004,5125792,5119729],"length":1,"stats":{"Line":7},"fn_name":"minmax_impl<core::slice::Iter<test_std::minmax::Val>,(),closure-0,closure-1>"},{"line":54,"address":[5125810,5129677,5132397,5128906,5119832,5132282,5125922,5132480,5122722,5119749,5129027,5123368,5122834,5120286,5122917,5126456,5132934,5126005,5119634,5129113],"length":1,"stats":{"Line":19},"fn_name":null},{"line":55,"address":[5122927,5122842,5119842,5132405,5132490,5119757,5129123,5126015,5129035,5125930],"length":1,"stats":{"Line":10},"fn_name":null},{"line":56,"address":[5122873,5132436,5129066,5125961,5119788],"length":1,"stats":{"Line":6},"fn_name":null},{"line":57,"address":[5132468,5122905,5122963,5126051,5132529,5129258,5126137,5123049,5125993,5119881,5119967,5129098,5132615,5129165,5119820],"length":1,"stats":{"Line":12},"fn_name":null},{"line":58,"address":[5123051,5119969,5132537,5126059,5126139,5122971,5129260,5119889,5129173,5132617],"length":1,"stats":{"Line":7},"fn_name":null},{"line":59,"address":[5129196,5126082,5132560,5119912,5122994],"length":1,"stats":{"Line":5},"fn_name":null},{"line":60,"address":[5123018,5126106,5129220,5129322,5132584,5119936],"length":1,"stats":{"Line":6},"fn_name":null},{"line":61,"address":[5129384,5120032,5123114,5132680,5126202,5129337],"length":1,"stats":{"Line":6},"fn_name":null},{"line":62,"address":[5120186,5129399,5123278,5129531,5126243,5123155,5120196,5120073,5132844,5126366,5132721,5123268,5126356,5132834,5129521],"length":1,"stats":{"Line":14},"fn_name":null},{"line":68,"address":[5128197,5125109,5132982,5134676,5123416,5129753,5120334,5122028,5126504,5131492],"length":1,"stats":{"Line":10},"fn_name":null},{"line":74,"address":[5129862,5123625,5133091,5123525,5129962,5120443,5120543,5126613,5126713,5133191],"length":1,"stats":{"Line":5},"fn_name":null},{"line":75,"address":[5123637,5129887,5120555,5123550,5120468,5133116,5129974,5133203,5126725,5126638],"length":1,"stats":{"Line":7},"fn_name":null},{"line":76,"address":[5120491,5126661,5133139,5129910,5123573],"length":1,"stats":{"Line":5},"fn_name":null},{"line":78,"address":[5130003,5120531,5120689,5133179,5126701,5120584,5130112,5123613,5133337,5126754,5126859,5123666,5129950,5133232,5123771],"length":1,"stats":{"Line":10},"fn_name":null},{"line":79,"address":[5120592,5123674,5133240,5126762,5130011],"length":1,"stats":{"Line":5},"fn_name":null},{"line":80,"address":[5130122,5133347,5120699,5123781,5126869],"length":1,"stats":{"Line":5},"fn_name":null},{"line":81,"address":[5120738,5124139,5134799,5131615,5130292,5128320,5133502,5123820,5127024,5122151,5125232,5127227,5130495,5121057,5123936,5126908,5133386,5133705,5130176,5120854],"length":1,"stats":{"Line":17},"fn_name":null},{"line":82,"address":[5122130,5133625,5124059,5131594,5130415,5134778,5125211,5128299,5127147,5120977],"length":1,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[5121015,5130453,5133518,5124097,5127040,5128346,5130308,5134825,5125258,5127185,5133663,5122177,5120870,5123952,5131641],"length":1,"stats":{"Line":13},"fn_name":null},{"line":84,"address":[5133671,5125237,5134804,5128325,5127193,5121023,5124105,5130461,5131620,5122156],"length":1,"stats":{"Line":6},"fn_name":null},{"line":86,"address":[5133741,5127263,5124175,5130531,5121093],"length":1,"stats":{"Line":5},"fn_name":null},{"line":88,"address":[5123697,5126785,5133263,5130034,5120615],"length":1,"stats":{"Line":5},"fn_name":null},{"line":90,"address":[5123737,5120655,5121117,5133765,5127287,5130074,5130559,5133303,5124199,5126825],"length":1,"stats":{"Line":10},"fn_name":null},{"line":91,"address":[5130582,5133781,5124215,5121133,5127303],"length":1,"stats":{"Line":5},"fn_name":null},{"line":92,"address":[5124819,5133828,5121737,5121180,5127907,5128118,5124262,5130644,5131201,5134385,5134597,5127350,5121949,5125030,5131413],"length":1,"stats":{"Line":12},"fn_name":null},{"line":93,"address":[5121423,5134071,5125368,5124505,5134935,5127593,5131773,5122287,5130887,5128456],"length":1,"stats":{"Line":5},"fn_name":null},{"line":94,"address":[5131722,5134190,5122258,5127712,5134906,5124624,5128427,5121542,5125339,5131006],"length":1,"stats":{"Line":4},"fn_name":null},{"line":95,"address":[5131743,5134927,5122279,5125360,5128448],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[5124666,5127754,5131829,5121584,5134232,5125402,5134969,5122321,5128490,5131048],"length":1,"stats":{"Line":5},"fn_name":null},{"line":98,"address":[5131778,5124785,5125373,5134351,5122292,5127873,5131167,5128461,5134940,5121703],"length":1,"stats":{"Line":4},"fn_name":null},{"line":99,"address":[5134961,5125394,5131799,5128482,5122313],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[5131210,5127475,5133953,5122355,5121746,5125436,5124387,5130769,5131885,5135003,5128524,5121305,5127916,5134394,5124828],"length":1,"stats":{"Line":10},"fn_name":null},{"line":103,"address":[5121754,5122326,5127924,5124836,5131834,5134402,5125407,5128495,5131218,5134974],"length":1,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[5125428,5131855,5128516,5134995,5122347],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[5122389,5131260,5131941,5134444,5125469,5124878,5128557,5135037,5127966,5121796],"length":1,"stats":{"Line":8},"fn_name":null},{"line":107,"address":[5121915,5131379,5128085,5122360,5128529,5131890,5125441,5134563,5124997,5135008],"length":1,"stats":{"Line":8},"fn_name":null},{"line":108,"address":[5122381,5125461,5128549,5131911,5135029],"length":1,"stats":{"Line":4},"fn_name":null},{"line":113,"address":[5123457,5129794,5120375,5126545,5133023],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":43,"coverable":44},{"path":["/","usr","src","itertools","src","multipeek_impl.rs"],"content":"use std::iter::Fuse;\nuse std::collections::VecDeque;\nuse crate::size_hint;\nuse crate::PeekingNext;\n\n/// See [`multipeek()`](../fn.multipeek.html) for more information.\n#[derive(Clone, Debug)]\npub struct MultiPeek<I>\n    where I: Iterator\n{\n    iter: Fuse<I>,\n    buf: VecDeque<I::Item>,\n    index: usize,\n}\n\n/// An iterator adaptor that allows the user to peek at multiple `.next()`\n/// values without advancing the base iterator.\npub fn multipeek<I>(iterable: I) -> MultiPeek<I::IntoIter>\n    where I: IntoIterator\n{\n    MultiPeek {\n        iter: iterable.into_iter().fuse(),\n        buf: VecDeque::new(),\n        index: 0,\n    }\n}\n\nimpl<I> MultiPeek<I>\n    where I: Iterator\n{\n    /// Reset the peeking “cursor”\n    pub fn reset_peek(&mut self) {\n        self.index = 0;\n    }\n}\n\nimpl<I: Iterator> MultiPeek<I> {\n    /// Works exactly like `.next()` with the only difference that it doesn't\n    /// advance itself. `.peek()` can be called multiple times, to peek\n    /// further ahead.\n    pub fn peek(&mut self) -> Option<&I::Item> {\n        let ret = if self.index < self.buf.len() {\n            Some(&self.buf[self.index])\n        } else {\n            match self.iter.next() {\n                Some(x) => {\n                    self.buf.push_back(x);\n                    Some(&self.buf[self.index])\n                }\n                None => return None,\n            }\n        };\n\n        self.index += 1;\n        ret\n    }\n}\n\nimpl<I> PeekingNext for MultiPeek<I>\n    where I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool\n    {\n        if self.buf.is_empty() {\n            if let Some(r) = self.peek() {\n                if !accept(r) { return None }\n            }\n        } else {\n            if let Some(r) = self.buf.get(0) {\n                if !accept(r) { return None }\n            }\n        }\n        self.next()\n    }\n}\n\nimpl<I> Iterator for MultiPeek<I>\n    where I: Iterator\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.index = 0;\n        self.buf.pop_front().or_else(|| self.iter.next())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add_scalar(self.iter.size_hint(), self.buf.len())\n    }\n}\n\n// Same size\nimpl<I> ExactSizeIterator for MultiPeek<I>\n    where I: ExactSizeIterator\n{}\n\n\n","traces":[{"line":18,"address":[4306002,4305810,4305952,4305618,4305568,4306144,4306194,4305760],"length":1,"stats":{"Line":5},"fn_name":"multipeek<core::iter::adapters::Map<core::slice::Iter<u8>, closure-0>>"},{"line":22,"address":[4305974,4305590,4305782,4306024,4305640,4306166,4305832,4306216],"length":1,"stats":{"Line":10},"fn_name":null},{"line":23,"address":[4306236,4305852,4306044,4305660],"length":1,"stats":{"Line":5},"fn_name":null},{"line":32,"address":[4304448],"length":1,"stats":{"Line":1},"fn_name":"reset_peek<core::iter::adapters::Cloned<core::slice::Iter<i32>>>"},{"line":33,"address":[4304453],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[4304832,4304775,4305200,4304464,4305147,4305515],"length":1,"stats":{"Line":4},"fn_name":"peek<core::iter::adapters::Cloned<core::slice::Iter<i32>>>"},{"line":42,"address":[4304599,4304967,4305448,4304841,4304708,4305335,4305080,4305209,4304473],"length":1,"stats":{"Line":11},"fn_name":null},{"line":43,"address":[4304557,4304925,4305293],"length":1,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[4305364,4304627,4304530,4304898,4304996,4305266],"length":1,"stats":{"Line":4},"fn_name":null},{"line":46,"address":[4305003,4304629,4305371,4304601,4305337,4304969],"length":1,"stats":{"Line":8},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[4303088,4302176,4301792,4303472,4302608,4301744,4303040,4303904,4303952,4301312,4302224,4303520,4302656,4301360],"length":1,"stats":{"Line":7},"fn_name":"peeking_next<core::iter::adapters::Map<core::slice::Iter<u8>, closure-0>,closure-1>"},{"line":65,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":27,"coverable":27},{"path":["/","usr","src","itertools","src","pad_tail.rs"],"content":"use std::iter::Fuse;\nuse crate::size_hint;\n\n/// An iterator adaptor that pads a sequence to a minimum length by filling\n/// missing elements using a closure.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.pad_using()`](../trait.Itertools.html#method.pad_using) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct PadUsing<I, F> {\n    iter: Fuse<I>,\n    min: usize,\n    pos: usize,\n    filler: F,\n}\n\n/// Create a new **PadUsing** iterator.\npub fn pad_using<I, F>(iter: I, min: usize, filler: F) -> PadUsing<I, F>\n    where I: Iterator,\n          F: FnMut(usize) -> I::Item\n{\n    PadUsing {\n        iter: iter.fuse(),\n        min,\n        pos: 0,\n        filler,\n    }\n}\n\nimpl<I, F> Iterator for PadUsing<I, F>\n    where I: Iterator,\n          F: FnMut(usize) -> I::Item\n{\n    type Item = I::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.iter.next() {\n            None => {\n                if self.pos < self.min {\n                    let e = Some((self.filler)(self.pos));\n                    self.pos += 1;\n                    e\n                } else {\n                    None\n                }\n            },\n            e => {\n                self.pos += 1;\n                e\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let tail = self.min.saturating_sub(self.pos);\n        size_hint::max(self.iter.size_hint(), (tail, Some(tail)))\n    }\n}\n\nimpl<I, F> DoubleEndedIterator for PadUsing<I, F>\n    where I: DoubleEndedIterator + ExactSizeIterator,\n          F: FnMut(usize) -> I::Item\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        if self.min == 0 {\n            self.iter.next_back()\n        } else if self.iter.len() >= self.min {\n            self.min -= 1;\n            self.iter.next_back()\n        } else {\n            self.min -= 1;\n            Some((self.filler)(self.min))\n        }\n    }\n}\n\nimpl<I, F> ExactSizeIterator for PadUsing<I, F>\n    where I: ExactSizeIterator,\n          F: FnMut(usize) -> I::Item\n{}\n","traces":[{"line":20,"address":[5116633,5116329,5116368,5116465,5116192,5116496],"length":1,"stats":{"Line":6},"fn_name":"pad_using<alloc::vec::IntoIter<usize>,closure-2>"},{"line":25,"address":[5116511,5116207,5116398],"length":1,"stats":{"Line":6},"fn_name":null},{"line":39,"address":[4357952,4357472,4357025,4357991,4356976,4357511],"length":1,"stats":{"Line":6},"fn_name":"next<quick::Iter<i8, quick::Exact>,closure-0>"},{"line":40,"address":[5115351,5114860,5115580,5114585,5115068,5115863],"length":1,"stats":{"Line":12},"fn_name":null},{"line":41,"address":[5115627,5114637,5115115],"length":1,"stats":{"Line":6},"fn_name":null},{"line":42,"address":[5114856,5115737,5115859,5114740,5115347,5114723,5115206,5115718,5115225],"length":1,"stats":{"Line":17},"fn_name":null},{"line":43,"address":[5115232,5114747,5115744],"length":1,"stats":{"Line":5},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":47,"address":[4357140,4357627,4358107],"length":1,"stats":{"Line":6},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":51,"address":[4358329,4357362,4357766,4357571,4357849,4357085,4358051,4357279,4358246],"length":1,"stats":{"Line":10},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":16,"coverable":24},{"path":["/","usr","src","itertools","src","peek_nth.rs"],"content":"use crate::size_hint;\nuse crate::PeekingNext;\nuse std::collections::VecDeque;\nuse std::iter::Fuse;\n\n/// See [`peek_nth()`](../fn.peek_nth.html) for more information.\n#[derive(Clone, Debug)]\npub struct PeekNth<I>\nwhere\n    I: Iterator,\n{\n    iter: Fuse<I>,\n    buf: VecDeque<I::Item>,\n}\n\n/// A drop-in replacement for `std::iter::Peekable` which adds a `peek_nth`\n/// method allowing the user to `peek` at a value several iterations forward\n/// without advancing the base iterator.\n///\n/// This differs from `multipeek` in that subsequent calls to `peek` or\n/// `peek_nth` will always return the same value until `next` is called\n/// (making `reset_peek` unnecessary).\npub fn peek_nth<I>(iterable: I) -> PeekNth<I::IntoIter>\nwhere\n    I: IntoIterator,\n{\n    PeekNth {\n        iter: iterable.into_iter().fuse(),\n        buf: VecDeque::new(),\n    }\n}\n\nimpl<I> PeekNth<I>\nwhere\n    I: Iterator,\n{\n    /// Works exactly like the `peek` method in `std::iter::Peekable`\n    pub fn peek(&mut self) -> Option<&I::Item> {\n        self.peek_nth(0)\n    }\n\n    /// Returns a reference to the `nth` value without advancing the iterator.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```rust\n    /// use itertools::peek_nth;\n    ///\n    /// let xs = vec![1,2,3];\n    /// let mut iter = peek_nth(xs.iter());\n    ///\n    /// assert_eq!(iter.peek_nth(0), Some(&&1));\n    /// assert_eq!(iter.next(), Some(&1));\n    ///\n    /// // The iterator does not advance even if we call `peek_nth` multiple times\n    /// assert_eq!(iter.peek_nth(0), Some(&&2));\n    /// assert_eq!(iter.peek_nth(1), Some(&&3));\n    /// assert_eq!(iter.next(), Some(&2));\n    ///\n    /// // Calling `peek_nth` past the end of the iterator will return `None`\n    /// assert_eq!(iter.peek_nth(1), None);\n    /// ```\n    pub fn peek_nth(&mut self, n: usize) -> Option<&I::Item> {\n        let unbuffered_items = (n + 1).saturating_sub(self.buf.len());\n\n        self.buf.extend(self.iter.by_ref().take(unbuffered_items));\n\n        self.buf.get(n)\n    }\n}\n\nimpl<I> Iterator for PeekNth<I>\nwhere\n    I: Iterator,\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.buf.pop_front().or_else(|| self.iter.next())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add_scalar(self.iter.size_hint(), self.buf.len())\n    }\n}\n\nimpl<I> ExactSizeIterator for PeekNth<I> where I: ExactSizeIterator {}\n\nimpl<I> PeekingNext for PeekNth<I>\nwhere\n    I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n    where\n        F: FnOnce(&Self::Item) -> bool,\n    {\n        self.peek().filter(|item| accept(item))?;\n        self.next()\n    }\n}\n","traces":[{"line":23,"address":[4217234,4217184,4216800,4216992,4216850,4217042],"length":1,"stats":{"Line":4},"fn_name":"peek_nth<core::iter::adapters::Map<core::slice::Iter<u8>, closure-0>>"},{"line":28,"address":[6148563,6148502],"length":1,"stats":{"Line":8},"fn_name":null},{"line":29,"address":[4216892,4217084,4217276],"length":1,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[6148240],"length":1,"stats":{"Line":3},"fn_name":"peek_nth<quick::Iter<u16, quick::Exact>>"},{"line":66,"address":[4216789,4216533,4216302,4216503,4216558,4216759],"length":1,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[4216727,4216471],"length":1,"stats":{"Line":3},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[4214112,4213604,4214692,4213332,4213296,4213876,4214148,4214384,4214420,4213568,4214656,4214928,4214964,4213840],"length":1,"stats":{"Line":7},"fn_name":"peeking_next<core::iter::adapters::Map<core::slice::Iter<u8>, closure-0>,closure-5>"},{"line":99,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":10},"fn_name":null}],"covered":16,"coverable":16},{"path":["/","usr","src","itertools","src","peeking_take_while.rs"],"content":"use std::iter::Peekable;\nuse crate::PutBack;\n#[cfg(feature = \"use_std\")]\nuse crate::PutBackN;\n\n/// An iterator that allows peeking at an element before deciding to accept it.\n///\n/// See [`.peeking_take_while()`](trait.Itertools.html#method.peeking_take_while)\n/// for more information.\n///\n/// This is implemented by peeking adaptors like peekable and put back,\n/// but also by a few iterators that can be peeked natively, like the slice’s\n/// by reference iterator (`std::slice::Iter`).\npub trait PeekingNext : Iterator {\n    /// Pass a reference to the next iterator element to the closure `accept`;\n    /// if `accept` returns true, return it as the next element,\n    /// else None.\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool;\n}\n\nimpl<I> PeekingNext for Peekable<I>\n    where I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool\n    {\n        if let Some(r) = self.peek() {\n            if !accept(r) {\n                return None;\n            }\n        }\n        self.next()\n    }\n}\n\nimpl<I> PeekingNext for PutBack<I>\n    where I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool\n    {\n        if let Some(r) = self.next() {\n            if !accept(&r) {\n                self.put_back(r);\n                return None;\n            }\n            Some(r)\n        } else {\n            None\n        }\n    }\n}\n\n#[cfg(feature = \"use_std\")]\nimpl<I> PeekingNext for PutBackN<I>\n    where I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool\n    {\n        if let Some(r) = self.next() {\n            if !accept(&r) {\n                self.put_back(r);\n                return None;\n            }\n            Some(r)\n        } else {\n            None\n        }\n    }\n}\n\n/// An iterator adaptor that takes items while a closure returns `true`.\n///\n/// See [`.peeking_take_while()`](../trait.Itertools.html#method.peeking_take_while)\n/// for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct PeekingTakeWhile<'a, I: 'a, F>\n    where I: Iterator,\n{\n    iter: &'a mut I,\n    f: F,\n}\n\n/// Create a PeekingTakeWhile\npub fn peeking_take_while<I, F>(iter: &mut I, f: F) -> PeekingTakeWhile<I, F>\n    where I: Iterator,\n{\n    PeekingTakeWhile {\n        iter,\n        f,\n    }\n}\n\nimpl<'a, I, F> Iterator for PeekingTakeWhile<'a, I, F>\n    where I: PeekingNext,\n          F: FnMut(&I::Item) -> bool,\n\n{\n    type Item = I::Item;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.peeking_next(&mut self.f)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, hi) = self.iter.size_hint();\n        (0, hi)\n    }\n}\n\n// Some iterators are so lightweight we can simply clone them to save their\n// state and use that for peeking.\nmacro_rules! peeking_next_by_clone {\n    ([$($typarm:tt)*] $type_:ty) => {\n        impl<$($typarm)*> PeekingNext for $type_ {\n            fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n                where F: FnOnce(&Self::Item) -> bool\n            {\n                let saved_state = self.clone();\n                if let Some(r) = self.next() {\n                    if !accept(&r) {\n                        *self = saved_state;\n                    } else {\n                        return Some(r)\n                    }\n                }\n                None\n            }\n        }\n    }\n}\n\npeeking_next_by_clone! { ['a, T] ::std::slice::Iter<'a, T> }\npeeking_next_by_clone! { ['a] ::std::str::Chars<'a> }\npeeking_next_by_clone! { ['a] ::std::str::CharIndices<'a> }\npeeking_next_by_clone! { ['a] ::std::str::Bytes<'a> }\npeeking_next_by_clone! { ['a, T] ::std::option::Iter<'a, T> }\npeeking_next_by_clone! { ['a, T] ::std::result::Iter<'a, T> }\npeeking_next_by_clone! { [T] ::std::iter::Empty<T> }\n#[cfg(feature = \"use_std\")]\npeeking_next_by_clone! { ['a, T] ::std::collections::linked_list::Iter<'a, T> }\n#[cfg(feature = \"use_std\")]\npeeking_next_by_clone! { ['a, T] ::std::collections::vec_deque::Iter<'a, T> }\n\n// cloning a Rev has no extra overhead; peekable and put backs are never DEI.\npeeking_next_by_clone! { [I: Clone + PeekingNext + DoubleEndedIterator]\n                         ::std::iter::Rev<I> }\n","traces":[{"line":25,"address":[4227230,4227184],"length":1,"stats":{"Line":1},"fn_name":"peeking_next<core::ops::range::Range<i32>,&mut closure-0>"},{"line":28,"address":[4227198,4227251,4227330],"length":1,"stats":{"Line":3},"fn_name":null},{"line":29,"address":[4227289],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[4227332],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[4227358],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[4214736,4215120,4214795,4215179],"length":1,"stats":{"Line":2},"fn_name":"peeking_next<core::ops::range::Range<i32>,&mut closure-1>"},{"line":43,"address":[4215134,4214750,4215195,4215232,4214848,4214811],"length":1,"stats":{"Line":5},"fn_name":null},{"line":44,"address":[4215255,4214871],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[4239643,4239584,4240027,4239968],"length":1,"stats":{"Line":2},"fn_name":"peeking_next<core::ops::range::Range<i32>,&mut closure-1>"},{"line":62,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[4219024,4219184,4219056,4219152,4219120,4219216,4219248,4219280,4219088],"length":1,"stats":{"Line":9},"fn_name":"peeking_take_while<itertools::adaptors::PutBack<core::ops::range::Range<i32>>,closure-0>"},{"line":102,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[4220384,4220438,4220774,4220720],"length":1,"stats":{"Line":4},"fn_name":"peeking_next<i32,&mut closure-0>"},{"line":120,"address":[4220801,4220737,4220465,4220401],"length":1,"stats":{"Line":8},"fn_name":null},{"line":121,"address":[4220640,4220837,4220976,4220501],"length":1,"stats":{"Line":6},"fn_name":null},{"line":122,"address":[4220560,4220896],"length":1,"stats":{"Line":4},"fn_name":null},{"line":123,"address":[4220628,4220964],"length":1,"stats":{"Line":3},"fn_name":null},{"line":125,"address":[4220942,4220606],"length":1,"stats":{"Line":4},"fn_name":null},{"line":128,"address":[4220655,4220991],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":29,"coverable":32},{"path":["/","usr","src","itertools","src","permutations.rs"],"content":"use std::fmt;\nuse std::iter::once;\n\nuse super::lazy_buffer::LazyBuffer;\n\n/// An iterator adaptor that iterates through all the `k`-permutations of the\n/// elements from an iterator.\n///\n/// See [`.permutations()`](../trait.Itertools.html#method.permutations) for\n/// more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Permutations<I: Iterator> {\n    vals: LazyBuffer<I>,\n    state: PermutationState,\n}\n\nimpl<I> Clone for Permutations<I>\n    where I: Clone + Iterator,\n          I::Item: Clone,\n{\n    clone_fields!(vals, state);\n}\n\n#[derive(Clone, Debug)]\nenum PermutationState {\n    StartUnknownLen {\n        k: usize,\n    },\n    OngoingUnknownLen {\n        k: usize,\n        min_n: usize,\n    },\n    Complete(CompleteState),\n    Empty,\n}\n\n#[derive(Clone, Debug)]\nenum CompleteState {\n    Start {\n        n: usize,\n        k: usize,\n    },\n    Ongoing {\n        indices: Vec<usize>,\n        cycles: Vec<usize>,\n    }\n}\n\nenum CompleteStateRemaining {\n    Known(usize),\n    Overflow,\n}\n\nimpl<I> fmt::Debug for Permutations<I>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(Permutations, vals, state);\n}\n\npub fn permutations<I: Iterator>(iter: I, k: usize) -> Permutations<I> {\n    let mut vals = LazyBuffer::new(iter);\n\n    if k == 0 {\n        // Special case, yields single empty vec; `n` is irrelevant\n        let state = PermutationState::Complete(CompleteState::Start { n: 0, k: 0 });\n\n        return Permutations {\n            vals,\n            state\n        };\n    }\n\n    let mut enough_vals = true;\n\n    while vals.len() < k {\n        if !vals.get_next() {\n            enough_vals = false;\n            break;\n        }\n    }\n\n    let state = if enough_vals {\n        PermutationState::StartUnknownLen { k }\n    } else {\n        PermutationState::Empty\n    };\n\n    Permutations {\n        vals,\n        state\n    }\n}\n\nimpl<I> Iterator for Permutations<I>\nwhere\n    I: Iterator,\n    I::Item: Clone\n{\n    type Item = Vec<I::Item>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.advance();\n\n        let &mut Permutations { ref vals, ref state } = self;\n\n        match state {\n            &PermutationState::StartUnknownLen { .. } => panic!(\"unexpected iterator state\"),\n            &PermutationState::OngoingUnknownLen { k, min_n } => {\n                let latest_idx = min_n - 1;\n                let indices = (0..(k - 1)).chain(once(latest_idx));\n\n                Some(indices.map(|i| vals[i].clone()).collect())\n            }\n            &PermutationState::Complete(CompleteState::Start { .. }) => None,\n            &PermutationState::Complete(CompleteState::Ongoing { ref indices, ref cycles }) => {\n                let k = cycles.len();\n\n                Some(indices[0..k].iter().map(|&i| vals[i].clone()).collect())\n            },\n            &PermutationState::Empty => None\n        }\n    }\n\n    fn count(self) -> usize {\n        let Permutations { vals, state } = self;\n\n        fn from_complete(complete_state: CompleteState) -> usize {\n            match complete_state.remaining() {\n                CompleteStateRemaining::Known(count) => count,\n                CompleteStateRemaining::Overflow => {\n                    panic!(\"Iterator count greater than usize::MAX\");\n                }\n            }\n        }\n\n        match state {\n            PermutationState::StartUnknownLen { k } => {\n                let n = vals.len() + vals.it.count();\n                let complete_state = CompleteState::Start { n, k };\n\n                from_complete(complete_state)\n            }\n            PermutationState::OngoingUnknownLen { k, min_n } => {\n                let prev_iteration_count = min_n - k + 1;\n                let n = vals.len() + vals.it.count();\n                let complete_state = CompleteState::Start { n, k };\n\n                from_complete(complete_state) - prev_iteration_count\n            },\n            PermutationState::Complete(state) => from_complete(state),\n            PermutationState::Empty => 0\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        match self.state {\n            PermutationState::StartUnknownLen { .. } |\n            PermutationState::OngoingUnknownLen { .. } => (0, None), // TODO can we improve this lower bound?\n            PermutationState::Complete(ref state) => match state.remaining() {\n                CompleteStateRemaining::Known(count) => (count, Some(count)),\n                CompleteStateRemaining::Overflow => (::std::usize::MAX, None)\n            }\n            PermutationState::Empty => (0, Some(0))\n        }\n    }\n}\n\nimpl<I> Permutations<I>\nwhere\n    I: Iterator,\n    I::Item: Clone\n{\n    fn advance(&mut self) {\n        let &mut Permutations { ref mut vals, ref mut state } = self;\n\n        *state = match state {\n            &mut PermutationState::StartUnknownLen { k } => {\n                PermutationState::OngoingUnknownLen { k, min_n: k }\n            }\n            &mut PermutationState::OngoingUnknownLen { k, min_n } => {\n                if vals.get_next() {\n                    PermutationState::OngoingUnknownLen { k, min_n: min_n + 1 }\n                } else {\n                    let n = min_n;\n                    let prev_iteration_count = n - k + 1;\n                    let mut complete_state = CompleteState::Start { n, k };\n\n                    // Advance the complete-state iterator to the correct point\n                    for _ in 0..(prev_iteration_count + 1) {\n                        complete_state.advance();\n                    }\n\n                    PermutationState::Complete(complete_state)\n                }\n            }\n            &mut PermutationState::Complete(ref mut state) => {\n                state.advance();\n\n                return;\n            }\n            &mut PermutationState::Empty => { return; }\n        };\n    }\n}\n\nimpl CompleteState {\n    fn advance(&mut self) {\n        *self = match self {\n            &mut CompleteState::Start { n, k } => {\n                let indices = (0..n).collect();\n                let cycles = ((n - k)..n).rev().collect();\n\n                CompleteState::Ongoing {\n                    cycles,\n                    indices\n                }\n            },\n            &mut CompleteState::Ongoing { ref mut indices, ref mut cycles } => {\n                let n = indices.len();\n                let k = cycles.len();\n\n                for i in (0..k).rev() {\n                    if cycles[i] == 0 {\n                        cycles[i] = n - i - 1;\n\n                        let to_push = indices.remove(i);\n                        indices.push(to_push);\n                    } else {\n                        let swap_index = n - cycles[i];\n                        indices.swap(i, swap_index);\n\n                        cycles[i] -= 1;\n                        return;\n                    }\n                }\n\n                CompleteState::Start { n, k }\n            }\n        }\n    }\n\n    fn remaining(&self) -> CompleteStateRemaining {\n        use self::CompleteStateRemaining::{Known, Overflow};\n\n        match self {\n            &CompleteState::Start { n, k } => {\n                if n < k {\n                    return Known(0);\n                }\n\n                let count: Option<usize> = (n - k + 1..n + 1).fold(Some(1), |acc, i| {\n                    acc.and_then(|acc| acc.checked_mul(i))\n                });\n\n                match count {\n                    Some(count) => Known(count),\n                    None => Overflow\n                }\n            }\n            &CompleteState::Ongoing { ref indices, ref cycles } => {\n                let mut count: usize = 0;\n\n                for (i, &c) in cycles.iter().enumerate() {\n                    let radix = indices.len() - i;\n                    let next_count = count.checked_mul(radix)\n                        .and_then(|count| count.checked_add(c));\n\n                    count = match next_count {\n                        Some(count) => count,\n                        None => { return Overflow; }\n                    };\n                }\n\n                Known(count)\n            }\n        }\n    }\n}\n","traces":[{"line":61,"address":[4221472,4221536],"length":1,"stats":{"Line":5},"fn_name":"permutations<adaptors_no_collect::PanickingCounter>"},{"line":62,"address":[4221506],"length":1,"stats":{"Line":5},"fn_name":null},{"line":64,"address":[4221556],"length":1,"stats":{"Line":5},"fn_name":null},{"line":66,"address":[4221575],"length":1,"stats":{"Line":4},"fn_name":null},{"line":68,"address":[4221770],"length":1,"stats":{"Line":4},"fn_name":null},{"line":69,"address":[4221670],"length":1,"stats":{"Line":4},"fn_name":null},{"line":70,"address":[4221715],"length":1,"stats":{"Line":4},"fn_name":null},{"line":74,"address":[4221562],"length":1,"stats":{"Line":4},"fn_name":null},{"line":76,"address":[4221570,4221853,4221908],"length":1,"stats":{"Line":12},"fn_name":null},{"line":77,"address":[4221887],"length":1,"stats":{"Line":4},"fn_name":null},{"line":78,"address":[4221910],"length":1,"stats":{"Line":3},"fn_name":null},{"line":83,"address":[4221918,4221940],"length":1,"stats":{"Line":7},"fn_name":null},{"line":86,"address":[4221928],"length":1,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[4582960,4582990],"length":1,"stats":{"Line":1},"fn_name":"from_complete"},{"line":129,"address":[4583007,4582964,4583079],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[4583081,4583022],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[4583049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[5086260,5086580],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":208,"address":[4583136,4583171],"length":1,"stats":{"Line":2},"fn_name":"advance"},{"line":209,"address":[4583771,4583277,4584483,4584012],"length":1,"stats":{"Line":6},"fn_name":null},{"line":210,"address":[4583151,4583287],"length":1,"stats":{"Line":4},"fn_name":null},{"line":211,"address":[4583311],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[4584693,4583415,4583532],"length":1,"stats":{"Line":4},"fn_name":null},{"line":214,"address":[4583663],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[4583567],"length":1,"stats":{"Line":2},"fn_name":null},{"line":216,"address":[4583615],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[4583194],"length":1,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[4583231],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[4583784],"length":1,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[4583806,4584017,4584297],"length":1,"stats":{"Line":3},"fn_name":null},{"line":224,"address":[4584066],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[4584151,4584573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[4584259],"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[4584291],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[4584315,4584633,4584119],"length":1,"stats":{"Line":2},"fn_name":null},{"line":231,"address":[4584356],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[4584663,4584418],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[4583976],"length":1,"stats":{"Line":2},"fn_name":null},{"line":243,"address":[4584768],"length":1,"stats":{"Line":1},"fn_name":"remaining"},{"line":246,"address":[4584878,4585237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[4584783,4584885],"length":1,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[4584909],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[4584956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[4573616],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":253,"address":[4573566,4573552,4573640],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":256,"address":[4585197],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[4585168,4585201],"length":1,"stats":{"Line":2},"fn_name":null},{"line":258,"address":[4585185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[4584803],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[4584837],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[4584849,4585252,4585453,4585729],"length":1,"stats":{"Line":3},"fn_name":null},{"line":265,"address":[4585532,4585734],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[4585586,4585627],"length":1,"stats":{"Line":2},"fn_name":null},{"line":267,"address":[4573710,4573696],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":269,"address":[4585703,4585721],"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[4585669,4585705],"length":1,"stats":{"Line":2},"fn_name":null},{"line":271,"address":[4585686],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[4585420],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":96,"coverable":113},{"path":["/","usr","src","itertools","src","process_results_impl.rs"],"content":"\n/// An iterator that produces only the `T` values as long as the\n/// inner iterator produces `Ok(T)`.\n///\n/// Used by [`process_results`](../fn.process_results.html), see its docs\n/// for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Debug)]\npub struct ProcessResults<'a, I, E: 'a> {\n    error: &'a mut Result<(), E>,\n    iter: I,\n}\n\nimpl<'a, I, T, E> Iterator for ProcessResults<'a, I, E>\n    where I: Iterator<Item = Result<T, E>>\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.iter.next() {\n            Some(Ok(x)) => Some(x),\n            Some(Err(e)) => {\n                *self.error = Err(e);\n                None\n            }\n            None => None,\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, hi) = self.iter.size_hint();\n        (0, hi)\n    }\n}\n\n/// “Lift” a function of the values of an iterator so that it can process\n/// an iterator of `Result` values instead.\n///\n/// `iterable` is an iterator or iterable with `Result<T, E>` elements, where\n/// `T` is the value type and `E` the error type.\n///\n/// `processor` is a closure that receives an adapted version of the iterable\n/// as the only argument — the adapted iterator produces elements of type `T`,\n/// as long as the original iterator produces `Ok` values.\n///\n/// If the original iterable produces an error at any point, the adapted\n/// iterator ends and the `process_results` function will return the\n/// error iself.\n///\n/// Otherwise, the return value from the closure is returned wrapped\n/// inside `Ok`.\n///\n/// # Example\n///\n/// ```\n/// use itertools::process_results;\n///\n/// type R = Result<i32, &'static str>;\n///\n/// let first_values: Vec<R> = vec![Ok(1), Ok(0), Ok(3)];\n/// let second_values: Vec<R> = vec![Ok(2), Ok(1), Err(\"overflow\")];\n///\n/// // “Lift” the iterator .max() method to work on the values in Results using process_results\n///\n/// let first_max = process_results(first_values, |iter| iter.max().unwrap_or(0));\n/// let second_max = process_results(second_values, |iter| iter.max().unwrap_or(0));\n///\n/// assert_eq!(first_max, Ok(3));\n/// assert!(second_max.is_err());\n/// ```\npub fn process_results<I, F, T, E, R>(iterable: I, processor: F) -> Result<R, E>\n    where I: IntoIterator<Item = Result<T, E>>,\n          F: FnOnce(ProcessResults<I::IntoIter, E>) -> R\n{\n    let iter = iterable.into_iter();\n    let mut error = Ok(());\n\n    let result = processor(ProcessResults { error: &mut error, iter });\n\n    error.map(|_| result)\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","usr","src","itertools","src","put_back_n_impl.rs"],"content":"use crate::size_hint;\n\n/// An iterator adaptor that allows putting multiple\n/// items in front of the iterator.\n///\n/// Iterator element type is `I::Item`.\n#[derive(Debug, Clone)]\npub struct PutBackN<I: Iterator> {\n    top: Vec<I::Item>,\n    iter: I,\n}\n\n/// Create an iterator where you can put back multiple values to the front\n/// of the iteration.\n///\n/// Iterator element type is `I::Item`.\npub fn put_back_n<I>(iterable: I) -> PutBackN<I::IntoIter>\n    where I: IntoIterator\n{\n    PutBackN {\n        top: Vec::new(),\n        iter: iterable.into_iter(),\n    }\n}\n\nimpl<I: Iterator> PutBackN<I> {\n    /// Puts x in front of the iterator.\n    /// The values are yielded in order of the most recently put back\n    /// values first.\n    ///\n    /// ```rust\n    /// use itertools::put_back_n;\n    ///\n    /// let mut it = put_back_n(1..5);\n    /// it.next();\n    /// it.put_back(1);\n    /// it.put_back(0);\n    ///\n    /// assert!(itertools::equal(it, 0..5));\n    /// ```\n    #[inline]\n    pub fn put_back(&mut self, x: I::Item) {\n        self.top.push(x);\n    }\n}\n\nimpl<I: Iterator> Iterator for PutBackN<I> {\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.top.pop().or_else(|| self.iter.next())\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add_scalar(self.iter.size_hint(), self.top.len())\n    }\n}\n\n","traces":[{"line":17,"address":[5120405,5120352],"length":1,"stats":{"Line":3},"fn_name":"put_back_n<alloc::vec::IntoIter<u8>>"},{"line":21,"address":[5120362],"length":1,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[4243514],"length":1,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[4240573],"length":1,"stats":{"Line":3},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","usr","src","itertools","src","rciter_impl.rs"],"content":"\nuse std::iter::IntoIterator;\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n/// A wrapper for `Rc<RefCell<I>>`, that implements the `Iterator` trait.\n#[derive(Debug)]\npub struct RcIter<I> {\n    /// The boxed iterator.\n    pub rciter: Rc<RefCell<I>>,\n}\n\n/// Return an iterator inside a `Rc<RefCell<_>>` wrapper.\n///\n/// The returned `RcIter` can be cloned, and each clone will refer back to the\n/// same original iterator.\n///\n/// `RcIter` allows doing interesting things like using `.zip()` on an iterator with\n/// itself, at the cost of runtime borrow checking which may have a performance\n/// penalty.\n///\n/// Iterator element type is `Self::Item`.\n///\n/// ```\n/// use itertools::rciter;\n/// use itertools::zip;\n///\n/// // In this example a range iterator is created and we iterate it using\n/// // three separate handles (two of them given to zip).\n/// // We also use the IntoIterator implementation for `&RcIter`.\n///\n/// let mut iter = rciter(0..9);\n/// let mut z = zip(&iter, &iter);\n///\n/// assert_eq!(z.next(), Some((0, 1)));\n/// assert_eq!(z.next(), Some((2, 3)));\n/// assert_eq!(z.next(), Some((4, 5)));\n/// assert_eq!(iter.next(), Some(6));\n/// assert_eq!(z.next(), Some((7, 8)));\n/// assert_eq!(z.next(), None);\n/// ```\n///\n/// **Panics** in iterator methods if a borrow error is encountered in the\n/// iterator methods. It can only happen if the `RcIter` is reentered in\n/// `.next()`, i.e. if it somehow participates in an “iterator knot”\n/// where it is an adaptor of itself.\npub fn rciter<I>(iterable: I) -> RcIter<I::IntoIter>\n    where I: IntoIterator\n{\n    RcIter { rciter: Rc::new(RefCell::new(iterable.into_iter())) }\n}\n\nimpl<I> Clone for RcIter<I> {\n    #[inline]\n    clone_fields!(rciter);\n}\n\nimpl<A, I> Iterator for RcIter<I>\n    where I: Iterator<Item = A>\n{\n    type Item = A;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.rciter.borrow_mut().next()\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // To work sanely with other API that assume they own an iterator,\n        // so it can't change in other places, we can't guarantee as much\n        // in our size_hint. Other clones may drain values under our feet.\n        let (_, hi) = self.rciter.borrow().size_hint();\n        (0, hi)\n    }\n}\n\nimpl<I> DoubleEndedIterator for RcIter<I>\n    where I: DoubleEndedIterator\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.rciter.borrow_mut().next_back()\n    }\n}\n\n/// Return an iterator from `&RcIter<I>` (by simply cloning it).\nimpl<'a, I> IntoIterator for &'a RcIter<I>\n    where I: Iterator\n{\n    type Item = I::Item;\n    type IntoIter = RcIter<I>;\n\n    fn into_iter(self) -> RcIter<I> {\n        self.clone()\n    }\n}\n","traces":[{"line":47,"address":[4391696,4391792],"length":1,"stats":{"Line":3},"fn_name":"rciter<core::iter::adapters::Cloned<core::slice::Iter<i32>>>"},{"line":50,"address":[4391804,4391710],"length":1,"stats":{"Line":3},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":9,"coverable":11},{"path":["/","usr","src","itertools","src","repeatn.rs"],"content":"\n/// An iterator that produces *n* repetitions of an element.\n///\n/// See [`repeat_n()`](../fn.repeat_n.html) for more information.\n#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n#[derive(Clone, Debug)]\npub struct RepeatN<A> {\n    elt: Option<A>,\n    n: usize,\n}\n\n/// Create an iterator that produces `n` repetitions of `element`.\npub fn repeat_n<A>(element: A, n: usize) -> RepeatN<A>\n    where A: Clone,\n{\n    if n == 0 {\n        RepeatN { elt: None, n, }\n    } else {\n        RepeatN { elt: Some(element), n, }\n    }\n}\n\nimpl<A> Iterator for RepeatN<A>\n    where A: Clone\n{\n    type Item = A;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.n > 1 {\n            self.n -= 1;\n            self.elt.as_ref().cloned()\n        } else {\n            self.n = 0;\n            self.elt.take()\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (self.n, Some(self.n))\n    }\n}\n\nimpl<A> DoubleEndedIterator for RepeatN<A>\n    where A: Clone\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.next()\n    }\n}\n\nimpl<A> ExactSizeIterator for RepeatN<A>\n    where A: Clone\n{}\n","traces":[{"line":13,"address":[4287264,4287088],"length":1,"stats":{"Line":3},"fn_name":"repeat_n<test_core::count_clones::Foo>"},{"line":16,"address":[5024944,5025026],"length":1,"stats":{"Line":6},"fn_name":null},{"line":19,"address":[4287140,4287326],"length":1,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[5024672],"length":1,"stats":{"Line":3},"fn_name":"next<i32>"},{"line":29,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":30,"address":[4286891,4286981,4287011,4286823,4286703,4286793],"length":1,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":11,"coverable":13},{"path":["/","usr","src","itertools","src","size_hint.rs"],"content":"//! Arithmetic on **Iterator** *.size_hint()* values.\n//!\n\nuse std::usize;\nuse std::cmp;\n\n/// **SizeHint** is the return type of **Iterator::size_hint()**.\npub type SizeHint = (usize, Option<usize>);\n\n/// Add **SizeHint** correctly.\n#[inline]\npub fn add(a: SizeHint, b: SizeHint) -> SizeHint {\n    let min = a.0.checked_add(b.0).unwrap_or(usize::MAX);\n    let max = match (a.1, b.1) {\n        (Some(x), Some(y)) => x.checked_add(y),\n        _ => None,\n    };\n\n    (min, max)\n}\n\n/// Add **x** correctly to a **SizeHint**.\n#[inline]\npub fn add_scalar(sh: SizeHint, x: usize) -> SizeHint {\n    let (mut low, mut hi) = sh;\n    low = low.saturating_add(x);\n    hi = hi.and_then(|elt| elt.checked_add(x));\n    (low, hi)\n}\n\n/// Sbb **x** correctly to a **SizeHint**.\n#[inline]\n#[allow(dead_code)]\npub fn sub_scalar(sh: SizeHint, x: usize) -> SizeHint {\n    let (mut low, mut hi) = sh;\n    low = low.saturating_sub(x);\n    hi = hi.map(|elt| elt.saturating_sub(x));\n    (low, hi)\n}\n\n\n/// Multiply **SizeHint** correctly\n///\n/// ```ignore\n/// use std::usize;\n/// use itertools::size_hint;\n///\n/// assert_eq!(size_hint::mul((3, Some(4)), (3, Some(4))),\n///            (9, Some(16)));\n///\n/// assert_eq!(size_hint::mul((3, Some(4)), (usize::MAX, None)),\n///            (usize::MAX, None));\n///\n/// assert_eq!(size_hint::mul((3, None), (0, Some(0))),\n///            (0, Some(0)));\n/// ```\n#[inline]\npub fn mul(a: SizeHint, b: SizeHint) -> SizeHint {\n    let low = a.0.checked_mul(b.0).unwrap_or(usize::MAX);\n    let hi = match (a.1, b.1) {\n        (Some(x), Some(y)) => x.checked_mul(y),\n        (Some(0), None) | (None, Some(0)) => Some(0),\n        _ => None,\n    };\n    (low, hi)\n}\n\n/// Multiply **x** correctly with a **SizeHint**.\n#[inline]\npub fn mul_scalar(sh: SizeHint, x: usize) -> SizeHint {\n    let (mut low, mut hi) = sh;\n    low = low.saturating_mul(x);\n    hi = hi.and_then(|elt| elt.checked_mul(x));\n    (low, hi)\n}\n\n/// Return the maximum\n#[inline]\npub fn max(a: SizeHint, b: SizeHint) -> SizeHint {\n    let (a_lower, a_upper) = a;\n    let (b_lower, b_upper) = b;\n\n    let lower = cmp::max(a_lower, b_lower);\n\n    let upper = match (a_upper, b_upper) {\n        (Some(x), Some(y)) => Some(cmp::max(x, y)),\n        _ => None,\n    };\n\n    (lower, upper)\n}\n\n/// Return the minimum\n#[inline]\npub fn min(a: SizeHint, b: SizeHint) -> SizeHint {\n    let (a_lower, a_upper) = a;\n    let (b_lower, b_upper) = b;\n    let lower = cmp::min(a_lower, b_lower);\n    let upper = match (a_upper, b_upper) {\n        (Some(u1), Some(u2)) => Some(cmp::min(u1, u2)),\n        _ => a_upper.or(b_upper),\n    };\n    (lower, upper)\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":25,"address":[4263548],"length":1,"stats":{"Line":7},"fn_name":null},{"line":26,"address":[4263574],"length":1,"stats":{"Line":7},"fn_name":null},{"line":27,"address":[4263617],"length":1,"stats":{"Line":21},"fn_name":null},{"line":28,"address":[4263678],"length":1,"stats":{"Line":7},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[4582544,4582558],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[4582592,4582606],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":38,"coverable":43},{"path":["/","usr","src","itertools","src","sources.rs"],"content":"//! Iterators that are sources (produce elements from parameters,\n//! not from another iterator).\n#![allow(deprecated)]\n\nuse std::fmt;\nuse std::mem;\n\n/// See [`repeat_call`](../fn.repeat_call.html) for more information.\n#[derive(Clone)]\n#[deprecated(note=\"Use std repeat_with() instead\", since=\"0.8\")]\npub struct RepeatCall<F> {\n    f: F,\n}\n\nimpl<F> fmt::Debug for RepeatCall<F>\n{\n    debug_fmt_fields!(RepeatCall, );\n}\n\n/// An iterator source that produces elements indefinitely by calling\n/// a given closure.\n///\n/// Iterator element type is the return type of the closure.\n///\n/// ```\n/// use itertools::repeat_call;\n/// use itertools::Itertools;\n/// use std::collections::BinaryHeap;\n///\n/// let mut heap = BinaryHeap::from(vec![2, 5, 3, 7, 8]);\n///\n/// // extract each element in sorted order\n/// for element in repeat_call(|| heap.pop()).while_some() {\n///     print!(\"{}\", element);\n/// }\n///\n/// itertools::assert_equal(\n///     repeat_call(|| 1).take(5),\n///     vec![1, 1, 1, 1, 1]\n/// );\n/// ```\n#[deprecated(note=\"Use std repeat_with() instead\", since=\"0.8\")]\npub fn repeat_call<F, A>(function: F) -> RepeatCall<F>\n    where F: FnMut() -> A\n{\n    RepeatCall { f: function }\n}\n\nimpl<A, F> Iterator for RepeatCall<F>\n    where F: FnMut() -> A\n{\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        Some((self.f)())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (usize::max_value(), None)\n    }\n}\n\n/// Creates a new unfold source with the specified closure as the \"iterator\n/// function\" and an initial state to eventually pass to the closure\n///\n/// `unfold` is a general iterator builder: it has a mutable state value,\n/// and a closure with access to the state that produces the next value.\n///\n/// This more or less equivalent to a regular struct with an `Iterator`\n/// implementation, and is useful for one-off iterators.\n///\n/// ```\n/// // an iterator that yields sequential Fibonacci numbers,\n/// // and stops at the maximum representable value.\n///\n/// use itertools::unfold;\n///\n/// let (mut x1, mut x2) = (1u32, 1u32);\n/// let mut fibonacci = unfold((), move |_| {\n///     // Attempt to get the next Fibonacci number\n///     let next = x1.saturating_add(x2);\n///\n///     // Shift left: ret <- x1 <- x2 <- next\n///     let ret = x1;\n///     x1 = x2;\n///     x2 = next;\n///\n///     // If addition has saturated at the maximum, we are finished\n///     if ret == x1 && ret > 1 {\n///         return None;\n///     }\n///\n///     Some(ret)\n/// });\n///\n/// itertools::assert_equal(fibonacci.by_ref().take(8),\n///                         vec![1, 1, 2, 3, 5, 8, 13, 21]);\n/// assert_eq!(fibonacci.last(), Some(2_971_215_073))\n/// ```\npub fn unfold<A, St, F>(initial_state: St, f: F) -> Unfold<St, F>\n    where F: FnMut(&mut St) -> Option<A>\n{\n    Unfold {\n        f,\n        state: initial_state,\n    }\n}\n\nimpl<St, F> fmt::Debug for Unfold<St, F>\n    where St: fmt::Debug,\n{\n    debug_fmt_fields!(Unfold, state);\n}\n\n/// See [`unfold`](../fn.unfold.html) for more information.\n#[derive(Clone)]\n#[must_use = \"iterators are lazy and do nothing unless consumed\"]\npub struct Unfold<St, F> {\n    f: F,\n    /// Internal state that will be passed to the closure on the next iteration\n    pub state: St,\n}\n\nimpl<A, St, F> Iterator for Unfold<St, F>\n    where F: FnMut(&mut St) -> Option<A>\n{\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        (self.f)(&mut self.state)\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // no possible known bounds at this point\n        (0, None)\n    }\n}\n\n/// An iterator that infinitely applies function to value and yields results.\n///\n/// This `struct` is created by the [`iterate()`] function. See its documentation for more.\n///\n/// [`iterate()`]: ../fn.iterate.html\n#[derive(Clone)]\n#[must_use = \"iterators are lazy and do nothing unless consumed\"]\npub struct Iterate<St, F> {\n    state: St,\n    f: F,\n}\n\nimpl<St, F> fmt::Debug for Iterate<St, F>\n    where St: fmt::Debug,\n{\n    debug_fmt_fields!(Iterate, state);\n}\n\nimpl<St, F> Iterator for Iterate<St, F>\n    where F: FnMut(&St) -> St\n{\n    type Item = St;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let next_state = (self.f)(&self.state);\n        Some(mem::replace(&mut self.state, next_state))\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (usize::max_value(), None)\n    }\n}\n\n/// Creates a new iterator that infinitely applies function to value and yields results.\n///\n/// ```\n/// use itertools::iterate;\n///\n/// itertools::assert_equal(iterate(1, |&i| i * 3).take(5), vec![1, 3, 9, 27, 81]);\n/// ```\npub fn iterate<St, F>(initial_value: St, f: F) -> Iterate<St, F>\n    where F: FnMut(&St) -> St\n{\n    Iterate {\n        state: initial_value,\n        f,\n    }\n}\n","traces":[{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":13},{"path":["/","usr","src","itertools","src","tee.rs"],"content":"use super::size_hint;\n\nuse std::cell::RefCell;\nuse std::collections::VecDeque;\nuse std::rc::Rc;\n\n/// Common buffer object for the two tee halves\n#[derive(Debug)]\nstruct TeeBuffer<A, I> {\n    backlog: VecDeque<A>,\n    iter: I,\n    /// The owner field indicates which id should read from the backlog\n    owner: bool,\n}\n\n/// One half of an iterator pair where both return the same elements.\n///\n/// See [`.tee()`](../trait.Itertools.html#method.tee) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Debug)]\npub struct Tee<I>\n    where I: Iterator\n{\n    rcbuffer: Rc<RefCell<TeeBuffer<I::Item, I>>>,\n    id: bool,\n}\n\npub fn new<I>(iter: I) -> (Tee<I>, Tee<I>)\n    where I: Iterator\n{\n    let buffer = TeeBuffer{backlog: VecDeque::new(), iter, owner: false};\n    let t1 = Tee{rcbuffer: Rc::new(RefCell::new(buffer)), id: true};\n    let t2 = Tee{rcbuffer: t1.rcbuffer.clone(), id: false};\n    (t1, t2)\n}\n\nimpl<I> Iterator for Tee<I>\n    where I: Iterator,\n          I::Item: Clone\n{\n    type Item = I::Item;\n    fn next(&mut self) -> Option<Self::Item> {\n        // .borrow_mut may fail here -- but only if the user has tied some kind of weird\n        // knot where the iterator refers back to itself.\n        let mut buffer = self.rcbuffer.borrow_mut();\n        if buffer.owner == self.id {\n            match buffer.backlog.pop_front() {\n                None => {}\n                some_elt => return some_elt,\n            }\n        }\n        match buffer.iter.next() {\n            None => None,\n            Some(elt) => {\n                buffer.backlog.push_back(elt.clone());\n                buffer.owner = !self.id;\n                Some(elt)\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let buffer = self.rcbuffer.borrow();\n        let sh = buffer.iter.size_hint();\n\n        if buffer.owner == self.id {\n            let log_len = buffer.backlog.len();\n            size_hint::add_scalar(sh, log_len)\n        } else {\n            sh\n        }\n    }\n}\n\nimpl<I> ExactSizeIterator for Tee<I>\n    where I: ExactSizeIterator,\n          I::Item: Clone\n{}\n","traces":[{"line":28,"address":[4998072,4998496,4998573,4998016],"length":1,"stats":{"Line":3},"fn_name":"new<itertools::adaptors::DedupBy<core::slice::Iter<u8>, itertools::adaptors::DedupEq>>"},{"line":31,"address":[4998026,4998087,4998588,4998522],"length":1,"stats":{"Line":6},"fn_name":null},{"line":32,"address":[4674804],"length":1,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[4674928],"length":1,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[4674959],"length":1,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[4674048,4674108],"length":1,"stats":{"Line":3},"fn_name":"next<core::iter::adapters::Cloned<core::slice::Iter<i32>>>"},{"line":45,"address":[4674128,4674063,4674106],"length":1,"stats":{"Line":9},"fn_name":null},{"line":46,"address":[4674148,4674328,4674196],"length":1,"stats":{"Line":9},"fn_name":null},{"line":47,"address":[4674206],"length":1,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[4674254],"length":1,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[4996913,4996865,4996257,4996305],"length":1,"stats":{"Line":6},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":53,"address":[4996363,4996421,4996975,4997033],"length":1,"stats":{"Line":6},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":24,"coverable":24},{"path":["/","usr","src","itertools","src","tuple_impl.rs"],"content":"//! Some iterator that produces tuples\n\nuse std::iter::Fuse;\nuse std::iter::Take;\nuse std::iter::Cycle;\nuse std::marker::PhantomData;\n\n// `HomogeneousTuple` is a public facade for `TupleCollect`, allowing\n// tuple-related methods to be used by clients in generic contexts, while\n// hiding the implementation details of `TupleCollect`.\n// See https://github.com/rust-itertools/itertools/issues/387\n\n/// Implemented for homogeneous tuples of size up to 4.\npub trait HomogeneousTuple\n    : TupleCollect\n{}\n\nimpl<T: TupleCollect> HomogeneousTuple for T {}\n\n/// An iterator over a incomplete tuple.\n///\n/// See [`.tuples()`](../trait.Itertools.html#method.tuples) and\n/// [`Tuples::into_buffer()`](struct.Tuples.html#method.into_buffer).\n#[derive(Clone, Debug)]\npub struct TupleBuffer<T>\n    where T: HomogeneousTuple\n{\n    cur: usize,\n    buf: T::Buffer,\n}\n\nimpl<T> TupleBuffer<T>\n    where T: HomogeneousTuple\n{\n    fn new(buf: T::Buffer) -> Self {\n        TupleBuffer {\n            cur: 0,\n            buf,\n        }\n    }\n}\n\nimpl<T> Iterator for TupleBuffer<T>\n    where T: HomogeneousTuple\n{\n    type Item = T::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let s = self.buf.as_mut();\n        if let Some(ref mut item) = s.get_mut(self.cur) {\n            self.cur += 1;\n            item.take()\n        } else {\n            None\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let buffer = &self.buf.as_ref()[self.cur..];\n        let len = if buffer.len() == 0 {\n            0\n        } else {\n            buffer.iter()\n                  .position(|x| x.is_none())\n                  .unwrap_or(buffer.len())\n        };\n        (len, Some(len))\n    }\n}\n\nimpl<T> ExactSizeIterator for TupleBuffer<T>\n    where T: HomogeneousTuple\n{\n}\n\n/// An iterator that groups the items in tuples of a specific size.\n///\n/// See [`.tuples()`](../trait.Itertools.html#method.tuples) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Tuples<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    iter: Fuse<I>,\n    buf: T::Buffer,\n}\n\n/// Create a new tuples iterator.\npub fn tuples<I, T>(iter: I) -> Tuples<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    Tuples {\n        iter: iter.fuse(),\n        buf: Default::default(),\n    }\n}\n\nimpl<I, T> Iterator for Tuples<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        T::collect_from_iter(&mut self.iter, &mut self.buf)\n    }\n}\n\nimpl<I, T> Tuples<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    /// Return a buffer with the produced items that was not enough to be grouped in a tuple.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut iter = (0..5).tuples();\n    /// assert_eq!(Some((0, 1, 2)), iter.next());\n    /// assert_eq!(None, iter.next());\n    /// itertools::assert_equal(vec![3, 4], iter.into_buffer());\n    /// ```\n    pub fn into_buffer(self) -> TupleBuffer<T> {\n        TupleBuffer::new(self.buf)\n    }\n}\n\n\n/// An iterator over all contiguous windows that produces tuples of a specific size.\n///\n/// See [`.tuple_windows()`](../trait.Itertools.html#method.tuple_windows) for more\n/// information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Clone, Debug)]\npub struct TupleWindows<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    iter: I,\n    last: Option<T>,\n}\n\n/// Create a new tuple windows iterator.\npub fn tuple_windows<I, T>(mut iter: I) -> TupleWindows<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple,\n          T::Item: Clone\n{\n    use std::iter::once;\n\n    let mut last = None;\n    if T::num_items() != 1 {\n        // put in a duplicate item in front of the tuple; this simplifies\n        // .next() function.\n        if let Some(item) = iter.next() {\n            let iter = once(item.clone()).chain(once(item)).chain(&mut iter);\n            last = T::collect_from_iter_no_buf(iter);\n        }\n    }\n\n    TupleWindows {\n        last,\n        iter,\n    }\n}\n\nimpl<I, T> Iterator for TupleWindows<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple + Clone,\n          T::Item: Clone\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if T::num_items() == 1 {\n            return T::collect_from_iter_no_buf(&mut self.iter)\n        }\n        if let Some(ref mut last) = self.last {\n            if let Some(new) = self.iter.next() {\n                last.left_shift_push(new);\n                return Some(last.clone());\n            }\n        }\n        None\n    }\n}\n\n/// An iterator over all windows,wrapping back to the first elements when the\n/// window would otherwise exceed the length of the iterator, producing tuples\n/// of a specific size.\n///\n/// See [`.circular_tuple_windows()`](../trait.Itertools.html#method.circular_tuple_windows) for more\n/// information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Debug)]\npub struct CircularTupleWindows<I, T: Clone>\n    where I: Iterator<Item = T::Item> + Clone,\n          T: TupleCollect + Clone\n{\n    iter: Take<TupleWindows<Cycle<I>, T>>,\n    phantom_data: PhantomData<T>\n}\n\npub fn circular_tuple_windows<I, T>(iter: I) -> CircularTupleWindows<I, T>\n    where I: Iterator<Item = T::Item> + Clone + ExactSizeIterator,\n          T: TupleCollect + Clone,\n          T::Item: Clone\n{\n    let len = iter.len();\n    let iter = tuple_windows(iter.cycle()).take(len);\n\n    CircularTupleWindows {\n        iter: iter,\n        phantom_data: PhantomData{}\n    }\n}\n\nimpl<I, T> Iterator for CircularTupleWindows<I, T>\n    where I: Iterator<Item = T::Item> + Clone,\n          T: TupleCollect + Clone,\n          T::Item: Clone\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next()\n    }\n}\n\npub trait TupleCollect: Sized {\n    type Item;\n    type Buffer: Default + AsRef<[Option<Self::Item>]> + AsMut<[Option<Self::Item>]>;\n\n    fn collect_from_iter<I>(iter: I, buf: &mut Self::Buffer) -> Option<Self>\n        where I: IntoIterator<Item = Self::Item>;\n\n    fn collect_from_iter_no_buf<I>(iter: I) -> Option<Self>\n        where I: IntoIterator<Item = Self::Item>;\n\n    fn num_items() -> usize;\n\n    fn left_shift_push(&mut self, item: Self::Item);\n}\n\nmacro_rules! impl_tuple_collect {\n    ($N:expr; $A:ident ; $($X:ident),* ; $($Y:ident),* ; $($Y_rev:ident),*) => (\n        impl<$A> TupleCollect for ($($X),*,) {\n            type Item = $A;\n            type Buffer = [Option<$A>; $N - 1];\n\n            #[allow(unused_assignments, unused_mut)]\n            fn collect_from_iter<I>(iter: I, buf: &mut Self::Buffer) -> Option<Self>\n                where I: IntoIterator<Item = $A>\n            {\n                let mut iter = iter.into_iter();\n                $(\n                    let mut $Y = None;\n                )*\n\n                loop {\n                    $(\n                        $Y = iter.next();\n                        if $Y.is_none() {\n                            break\n                        }\n                    )*\n                    return Some(($($Y.unwrap()),*,))\n                }\n\n                let mut i = 0;\n                let mut s = buf.as_mut();\n                $(\n                    if i < s.len() {\n                        s[i] = $Y;\n                        i += 1;\n                    }\n                )*\n                return None;\n            }\n\n            #[allow(unused_assignments)]\n            fn collect_from_iter_no_buf<I>(iter: I) -> Option<Self>\n                where I: IntoIterator<Item = $A>\n            {\n                let mut iter = iter.into_iter();\n                loop {\n                    $(\n                        let $Y = if let Some($Y) = iter.next() {\n                            $Y\n                        } else {\n                            break;\n                        };\n                    )*\n                    return Some(($($Y),*,))\n                }\n\n                return None;\n            }\n\n            fn num_items() -> usize {\n                $N\n            }\n\n            fn left_shift_push(&mut self, item: $A) {\n                use std::mem::replace;\n\n                let &mut ($(ref mut $Y),*,) = self;\n                let tmp = item;\n                $(\n                    let tmp = replace($Y_rev, tmp);\n                )*\n                drop(tmp);\n            }\n        }\n    )\n}\n\nimpl_tuple_collect!(1; A; A; a; a);\nimpl_tuple_collect!(2; A; A, A; a, b; b, a);\nimpl_tuple_collect!(3; A; A, A, A; a, b, c; c, b, a);\nimpl_tuple_collect!(4; A; A, A, A, A; a, b, c, d; d, c, b, a);\n","traces":[{"line":35,"address":[4229248,4229360,4229328,4229184],"length":1,"stats":{"Line":5},"fn_name":"new<(i32, i32)>"},{"line":48,"address":[4212528,4213248,4212768,4213008],"length":1,"stats":{"Line":5},"fn_name":"next<(i32)>"},{"line":49,"address":[4212777,4212537,4213017,4213257],"length":1,"stats":{"Line":5},"fn_name":null},{"line":50,"address":[4213064,4212578,4212880,4213120,4213199,4213439,4213304,4212713,4213360,4212824,4212634,4212959],"length":1,"stats":{"Line":13},"fn_name":null},{"line":51,"address":[4213484,4213214,4213454,4212974,4213137,4212651,4212728,4213377,4212758,4212897,4213244,4213004],"length":1,"stats":{"Line":4},"fn_name":null},{"line":52,"address":[4212943,4213423,4212697,4213183],"length":1,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[4212872,4212626,4213352,4213112],"length":1,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[4229455,4229424,4229874,4229585,4229536,4229730,4229680,4229824],"length":1,"stats":{"Line":8},"fn_name":"tuples<core::iter::adapters::Cloned<core::slice::Iter<i32>>,(i32)>"},{"line":95,"address":[4229558,4229438,4229846,4229702],"length":1,"stats":{"Line":8},"fn_name":null},{"line":96,"address":[4229467,4229602,4229747,4229886,4229903],"length":1,"stats":{"Line":10},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":125,"address":[4228880,4228985,4228960,4228922,4229057,4229137,4229104,4229024],"length":1,"stats":{"Line":5},"fn_name":"into_buffer<core::iter::adapters::Cloned<core::slice::Iter<i32>>,(i32, i32, i32, i32)>"},{"line":126,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":146,"address":[4228224,4226816,4227594,4226154,4226080,4227520,4226890,4228298],"length":1,"stats":{"Line":8},"fn_name":"tuple_windows<core::iter::adapters::Cloned<core::slice::Iter<i32>>,(i32, i32, i32, i32)>"},{"line":153,"address":[4226836,4227540,4226100,4228244],"length":1,"stats":{"Line":8},"fn_name":null},{"line":154,"address":[4226714,4226922,4228330,4228116,4226910,4227582,4228286,4226174,4228771,4227406,4226878,4227614,4226186,4226142,4227626,4228318],"length":1,"stats":{"Line":24},"fn_name":null},{"line":157,"address":[4228340,4227636,4226196,4226932],"length":1,"stats":{"Line":6},"fn_name":null},{"line":158,"address":[4226637,4227017,4227060,4227721,4227764,4228050,4228425,4226281,4226324,4228468,4227342,4228715],"length":1,"stats":{"Line":12},"fn_name":null},{"line":159,"address":[4227176,4226659,4227364,4228584,4227880,4226443,4228072,4228741],"length":1,"stats":{"Line":12},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[4221920,4214720,4218676,4216036,4222052,4215936,4214776,4218560],"length":1,"stats":{"Line":8},"fn_name":"collect_from_iter<i32,&mut core::iter::adapters::fuse::Fuse<core::iter::adapters::Cloned<core::slice::Iter<i32>>>>"},{"line":257,"address":[4221946,4218586,4215962,4214743],"length":1,"stats":{"Line":8},"fn_name":null},{"line":259,"address":[4218691,4214791,4222067,4216051],"length":1,"stats":{"Line":8},"fn_name":null},{"line":264,"address":[4218933,4222151,4222271,4222391,4222417,4219986,4222464,4216220,4222490,4222318,4215202,4218980,4216176,4216946,4216888,4218907,4218860,4222344,4219006,4223810,4216237,4218756,4223688,4223749,4219925,4214829,4216097,4223871,4220047,4214812],"length":1,"stats":{"Line":60},"fn_name":null},{"line":265,"address":[4218953,4223854,4219026,4215231,4222364,4223915,4216193,4214846,4223793,4218880,4222510,4222291,4219969,4220030,4216254,4216984,4222437,4223732,4216932,4220091],"length":1,"stats":{"Line":40},"fn_name":null},{"line":266,"address":[4216313,4222412,4218928,4216235,4219001,4219088,4222339,4222485,4222572],"length":1,"stats":{"Line":12},"fn_name":null},{"line":269,"address":[4222529,4216318,4219045,4216273,4214928,4219093,4214859,4222577],"length":1,"stats":{"Line":16},"fn_name":null},{"line":272,"address":[4222172,4214893,4216118,4218777],"length":1,"stats":{"Line":8},"fn_name":null},{"line":273,"address":[4218797,4222192,4216138,4219360,4215001,4222938,4216494,4214907],"length":1,"stats":{"Line":16},"fn_name":null},{"line":275,"address":[4215022,4222962,4223287,4223129,4216515,4216673,4219697,4219384,4219542,4223445],"length":1,"stats":{"Line":20},"fn_name":null},{"line":276,"address":[4224334,4224752,4216725,4224001,4223026,4220365,4216570,4224668,4215345,4219594,4220242,4223184,4217119,4219439,4220697,4219749,4224082,4215271,4217242,4220488,4224208,4217038,4220616,4220161,4224459,4215074,4223342,4224587,4223500,4217370],"length":1,"stats":{"Line":18},"fn_name":null},{"line":277,"address":[4215148,4223429,4219681,4223586,4217057,4220664,4216812,4224020,4224146,4217340,4217180,4220426,4224802,4217418,4215469,4220748,4223113,4224272,4220180,4219836,4216657,4220586,4223271,4219526,4215439,4224557,4224635,4220303,4224397,4224719,4215290],"length":1,"stats":{"Line":24},"fn_name":null},{"line":280,"address":[4216836,4215161,4223610,4219860],"length":1,"stats":{"Line":8},"fn_name":null},{"line":284,"address":[4218120,4217760,4218096,4217509,4215519,4215664,4220898,4224896,4221352,4225563,4224962,4215685,4215472,4217472,4220832,4225520,4221312,4217826],"length":1,"stats":{"Line":11},"fn_name":"collect_from_iter_no_buf<i32,core::iter::adapters::chain::Chain<core::iter::adapters::chain::Chain<core::iter::sources::Once<i32>, core::iter::sources::Once<i32>>, &mut core::iter::adapters::Cloned<core::slice::Iter<i32>>>>"},{"line":287,"address":[4224906,4220842,4221332,4217770,4225543,4217489,4215673,4215476,4218108],"length":1,"stats":{"Line":11},"fn_name":null},{"line":290,"address":[4220955,4225045,4225696,4225646,4217526,4225722,4217589,4215536,4225255,4218174,4225072,4224982,4221508,4221565,4225859,4225620,4218137,4221031,4217633,4221369,4225095,4225317,4217843,4221084,4217563,4217906,4215702,4225282,4225583,4221535,4217659,4225805,4225019,4221140,4225130,4225190,4221057,4225832,4225779,4217880,4218250,4215721,4225225,4215555,4221482,4215581,4217933,4218227,4217982,4225673,4221406,4221459,4225160,4218278,4221591,4225749,4225885,4220918,4215747,4217610,4220981,4221008,4221432,4221114,4218202,4217956],"length":1,"stats":{"Line":81},"fn_name":null},{"line":291,"address":[4217917,4218212,4217993,4221602,4221151,4215755,4225816,4218288,4225331,4225144,4225657,4217597,4225056,4225239,4220992,4221443,4225733,4221519,4217667,4225896,4221068,4215589],"length":1,"stats":{"Line":27},"fn_name":null},{"line":293,"address":[4218335,4221474,4225274,4221554,4225764,4221099,4221224,4225847,4218238,4221103,4225851,4221023,4217625,4217948,4218041,4225087,4225418,4225688,4225175,4225270,4225768,4225179,4221660,4225965,4221550,4217712],"length":1,"stats":{"Line":11},"fn_name":null},{"line":296,"address":[4221613,4221162,4225907,4218301,4215759,4218004,4215593,4217675,4225342],"length":1,"stats":{"Line":11},"fn_name":null},{"line":299,"address":[4225603,4221389,4218149,4217863,4220938,4225002,4215615,4215781,4217546],"length":1,"stats":{"Line":6},"fn_name":null},{"line":302,"address":[4226064,4218400,4221728,4215824],"length":1,"stats":{"Line":8},"fn_name":"num_items<i32>"},{"line":306,"address":[4215840,4221744,4218416,4214656],"length":1,"stats":{"Line":6},"fn_name":"left_shift_push<i32>"},{"line":309,"address":[4215853,4218429,4221757,4214669],"length":1,"stats":{"Line":6},"fn_name":null},{"line":310,"address":[4221807,4218464,4214674,4215873],"length":1,"stats":{"Line":6},"fn_name":null},{"line":312,"address":[4221826,4215882,4218478,4214678],"length":1,"stats":{"Line":6},"fn_name":null},{"line":314,"address":[4214695,4218539,4215921,4221909],"length":1,"stats":{"Line":6},"fn_name":null}],"covered":62,"coverable":64},{"path":["/","usr","src","itertools","src","unique_impl.rs"],"content":"\nuse std::collections::HashMap;\nuse std::collections::hash_map::{Entry};\nuse std::hash::Hash;\nuse std::fmt;\n\n/// An iterator adapter to filter out duplicate elements.\n///\n/// See [`.unique_by()`](../trait.Itertools.html#method.unique) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct UniqueBy<I: Iterator, V, F> {\n    iter: I,\n    // Use a hashmap for the entry API\n    used: HashMap<V, ()>,\n    f: F,\n}\n\nimpl<I, V, F> fmt::Debug for UniqueBy<I, V, F>\n    where I: Iterator + fmt::Debug,\n          V: fmt::Debug + Hash + Eq,\n{\n    debug_fmt_fields!(UniqueBy, iter, used);\n}\n\n/// Create a new `UniqueBy` iterator.\npub fn unique_by<I, V, F>(iter: I, f: F) -> UniqueBy<I, V, F>\n    where V: Eq + Hash,\n          F: FnMut(&I::Item) -> V,\n          I: Iterator,\n{\n    UniqueBy {\n        iter,\n        used: HashMap::new(),\n        f,\n    }\n}\n\n// count the number of new unique keys in iterable (`used` is the set already seen)\nfn count_new_keys<I, K>(mut used: HashMap<K, ()>, iterable: I) -> usize\n    where I: IntoIterator<Item=K>,\n          K: Hash + Eq,\n{\n    let iter = iterable.into_iter();\n    let current_used = used.len();\n    used.extend(iter.map(|key| (key, ())));\n    used.len() - current_used\n}\n\nimpl<I, V, F> Iterator for UniqueBy<I, V, F>\n    where I: Iterator,\n          V: Eq + Hash,\n          F: FnMut(&I::Item) -> V\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        while let Some(v) = self.iter.next() {\n            let key = (self.f)(&v);\n            if self.used.insert(key, ()).is_none() {\n                return Some(v);\n            }\n        }\n        None\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, hi) = self.iter.size_hint();\n        ((low > 0 && self.used.is_empty()) as usize, hi)\n    }\n\n    fn count(self) -> usize {\n        let mut key_f = self.f;\n        count_new_keys(self.used, self.iter.map(move |elt| key_f(&elt)))\n    }\n}\n\nimpl<I, V, F> DoubleEndedIterator for UniqueBy<I, V, F>\n    where I: DoubleEndedIterator,\n          V: Eq + Hash,\n          F: FnMut(&I::Item) -> V\n{\n    fn next_back(&mut self) -> Option<I::Item> {\n        while let Some(v) = self.iter.next_back() {\n            let key = (self.f)(&v);\n            if self.used.insert(key, ()).is_none() {\n                return Some(v);\n            }\n        }\n        None\n    }\n}\n\nimpl<I> Iterator for Unique<I>\n    where I: Iterator,\n          I::Item: Eq + Hash + Clone\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        while let Some(v) = self.iter.iter.next() {\n            if let Entry::Vacant(entry) = self.iter.used.entry(v) {\n                let elt = entry.key().clone();\n                entry.insert(());\n                return Some(elt);\n            }\n        }\n        None\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, hi) = self.iter.iter.size_hint();\n        ((low > 0 && self.iter.used.is_empty()) as usize, hi)\n    }\n\n    fn count(self) -> usize {\n        count_new_keys(self.iter.used, self.iter.iter)\n    }\n}\n\nimpl<I> DoubleEndedIterator for Unique<I>\n    where I: DoubleEndedIterator,\n          I::Item: Eq + Hash + Clone\n{\n    fn next_back(&mut self) -> Option<I::Item> {\n        while let Some(v) = self.iter.iter.next_back() {\n            if let Entry::Vacant(entry) = self.iter.used.entry(v) {\n                let elt = entry.key().clone();\n                entry.insert(());\n                return Some(elt);\n            }\n        }\n        None\n    }\n}\n\n/// An iterator adapter to filter out duplicate elements.\n///\n/// See [`.unique()`](../trait.Itertools.html#method.unique) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Unique<I: Iterator> {\n    iter: UniqueBy<I, I::Item, ()>,\n}\n\nimpl<I> fmt::Debug for Unique<I>\n    where I: Iterator + fmt::Debug,\n          I::Item: Hash + Eq + fmt::Debug,\n{\n    debug_fmt_fields!(Unique, iter);\n}\n\npub fn unique<I>(iter: I) -> Unique<I>\n    where I: Iterator,\n          I::Item: Eq + Hash,\n{\n    Unique {\n        iter: UniqueBy {\n            iter,\n            used: HashMap::new(),\n            f: (),\n        }\n    }\n}\n","traces":[{"line":27,"address":[4604880,4604850,4604994,4605024,4605138,4604736],"length":1,"stats":{"Line":3},"fn_name":"unique_by<core::iter::adapters::Rev<core::slice::Iter<&str>>,alloc::string::String,closure-1>"},{"line":34,"address":[4604910,4605054,4604766],"length":1,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[4913872,4913922],"length":1,"stats":{"Line":1},"fn_name":"count_new_keys<core::iter::adapters::Cloned<core::slice::Iter<i8>>,i8>"},{"line":44,"address":[4913889,4913949],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[4913990,4914019],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[4914027,4914254,4914240],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}<core::iter::adapters::Cloned<core::slice::Iter<i8>>,i8>"},{"line":47,"address":[4914086,4914199],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[4603373,4603101,4603312,4603040],"length":1,"stats":{"Line":4},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[4604512,4604690,4604288,4604466],"length":1,"stats":{"Line":4},"fn_name":"unique<core::slice::Iter<i32>>"},{"line":160,"address":[4604357,4604581],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":40,"coverable":46},{"path":["/","usr","src","itertools","src","with_position.rs"],"content":"use std::iter::{Fuse,Peekable};\n\n/// An iterator adaptor that wraps each element in an [`Position`](../enum.Position.html).\n///\n/// Iterator element type is `Position<I::Item>`.\n///\n/// See [`.with_position()`](../trait.Itertools.html#method.with_position) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct WithPosition<I>\n    where I: Iterator,\n{\n    handled_first: bool,\n    peekable: Peekable<Fuse<I>>,\n}\n\nimpl<I> Clone for WithPosition<I>\n    where I: Clone + Iterator,\n          I::Item: Clone,\n{\n    clone_fields!(handled_first, peekable);\n}\n\n/// Create a new `WithPosition` iterator.\npub fn with_position<I>(iter: I) -> WithPosition<I>\n    where I: Iterator,\n{\n    WithPosition {\n        handled_first: false,\n        peekable: iter.fuse().peekable(),\n    }\n}\n\n/// A value yielded by `WithPosition`.\n/// Indicates the position of this element in the iterator results.\n///\n/// See [`.with_position()`](trait.Itertools.html#method.with_position) for more information.\n#[derive(Copy, Clone, Debug, PartialEq)]\npub enum Position<T> {\n    /// This is the first element.\n    First(T),\n    /// This is neither the first nor the last element.\n    Middle(T),\n    /// This is the last element.\n    Last(T),\n    /// This is the only element.\n    Only(T),\n}\n\nimpl<T> Position<T> {\n    /// Return the inner value.\n    pub fn into_inner(self) -> T {\n        match self {\n            Position::First(x) |\n            Position::Middle(x) |\n            Position::Last(x) |\n            Position::Only(x) => x,\n        }\n    }\n}\n\nimpl<I: Iterator> Iterator for WithPosition<I> {\n    type Item = Position<I::Item>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.peekable.next() {\n            Some(item) => {\n                if !self.handled_first {\n                    // Haven't seen the first item yet, and there is one to give.\n                    self.handled_first = true;\n                    // Peek to see if this is also the last item,\n                    // in which case tag it as `Only`.\n                    match self.peekable.peek() {\n                        Some(_) => Some(Position::First(item)),\n                        None => Some(Position::Only(item)),\n                    }\n                } else {\n                    // Have seen the first item, and there's something left.\n                    // Peek to see if this is the last item.\n                    match self.peekable.peek() {\n                        Some(_) => Some(Position::Middle(item)),\n                        None => Some(Position::Last(item)),\n                    }\n                }\n            }\n            // Iterator is finished.\n            None => None,\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.peekable.size_hint()\n    }\n}\n\nimpl<I> ExactSizeIterator for WithPosition<I>\n    where I: ExactSizeIterator,\n{ }\n","traces":[{"line":24,"address":[5093600,5093472],"length":1,"stats":{"Line":2},"fn_name":"with_position<core::slice::Iter<u8>>"},{"line":29,"address":[5093494,5093622],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[5093142,5092576,5092738,5092960],"length":1,"stats":{"Line":2},"fn_name":"next<quick::Iter<u8, quick::Exact>>"},{"line":65,"address":[5092593,5092975,5092627,5093027],"length":1,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":16,"coverable":22},{"path":["/","usr","src","itertools","src","zip_eq_impl.rs"],"content":"use super::size_hint;\n\n/// An iterator which iterates two other iterators simultaneously\n///\n/// See [`.zip_eq()`](../trait.Itertools.html#method.zip_eq) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct ZipEq<I, J> {\n    a: I,\n    b: J,\n}\n\n/// Iterate `i` and `j` in lock step.\n///\n/// **Panics** if the iterators are not of the same length.\n///\n/// `IntoIterator` enabled version of `i.zip_eq(j)`.\n///\n/// ```\n/// use itertools::zip_eq;\n///\n/// let data = [1, 2, 3, 4, 5];\n/// for (a, b) in zip_eq(&data[..data.len() - 1], &data[1..]) {\n///     /* loop body */\n/// }\n/// ```\npub fn zip_eq<I, J>(i: I, j: J) -> ZipEq<I::IntoIter, J::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator\n{\n    ZipEq {\n        a: i.into_iter(),\n        b: j.into_iter(),\n    }\n}\n\nimpl<I, J> Iterator for ZipEq<I, J>\n    where I: Iterator,\n          J: Iterator\n{\n    type Item = (I::Item, J::Item);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match (self.a.next(), self.b.next()) {\n            (None, None) => None,\n            (Some(a), Some(b)) => Some((a, b)),\n            (None, Some(_)) | (Some(_), None) =>\n            panic!(\"itertools: .zip_eq() reached end of one iterator before the other\")\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::min(self.a.size_hint(), self.b.size_hint())\n    }\n}\n\nimpl<I, J> ExactSizeIterator for ZipEq<I, J>\n    where I: ExactSizeIterator,\n          J: ExactSizeIterator\n{}\n","traces":[{"line":27,"address":[4226944,4227053,4227168,4227277],"length":1,"stats":{"Line":3},"fn_name":"zip_eq<&[i32; 2],&[i32; 3]>"},{"line":32,"address":[4226961,4227185],"length":1,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[4227240,4227016],"length":1,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":7,"coverable":11},{"path":["/","usr","src","itertools","src","zip_longest.rs"],"content":"use std::cmp::Ordering::{Equal, Greater, Less};\nuse super::size_hint;\nuse std::iter::Fuse;\n\nuse crate::either_or_both::EitherOrBoth;\n\n// ZipLongest originally written by SimonSapin,\n// and dedicated to itertools https://github.com/rust-lang/rust/pull/19283\n\n/// An iterator which iterates two other iterators simultaneously\n///\n/// This iterator is *fused*.\n///\n/// See [`.zip_longest()`](../trait.Itertools.html#method.zip_longest) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct ZipLongest<T, U> {\n    a: Fuse<T>,\n    b: Fuse<U>,\n}\n\n/// Create a new `ZipLongest` iterator.\npub fn zip_longest<T, U>(a: T, b: U) -> ZipLongest<T, U> \n    where T: Iterator,\n          U: Iterator\n{\n    ZipLongest {\n        a: a.fuse(),\n        b: b.fuse(),\n    }\n}\n\nimpl<T, U> Iterator for ZipLongest<T, U>\n    where T: Iterator,\n          U: Iterator\n{\n    type Item = EitherOrBoth<T::Item, U::Item>;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        match (self.a.next(), self.b.next()) {\n            (None, None) => None,\n            (Some(a), None) => Some(EitherOrBoth::Left(a)),\n            (None, Some(b)) => Some(EitherOrBoth::Right(b)),\n            (Some(a), Some(b)) => Some(EitherOrBoth::Both(a, b)),\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::max(self.a.size_hint(), self.b.size_hint())\n    }\n}\n\nimpl<T, U> DoubleEndedIterator for ZipLongest<T, U>\n    where T: DoubleEndedIterator + ExactSizeIterator,\n          U: DoubleEndedIterator + ExactSizeIterator\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        match self.a.len().cmp(&self.b.len()) {\n            Equal => match (self.a.next_back(), self.b.next_back()) {\n                (None, None) => None,\n                (Some(a), Some(b)) => Some(EitherOrBoth::Both(a, b)),\n                // These can only happen if .len() is inconsistent with .next_back()\n                (Some(a), None) => Some(EitherOrBoth::Left(a)),\n                (None, Some(b)) => Some(EitherOrBoth::Right(b)),\n            },\n            Greater => self.a.next_back().map(EitherOrBoth::Left),\n            Less => self.b.next_back().map(EitherOrBoth::Right),\n        }\n    }\n}\n\nimpl<T, U> ExactSizeIterator for ZipLongest<T, U>\n    where T: ExactSizeIterator,\n          U: ExactSizeIterator\n{}\n","traces":[{"line":23,"address":[5062695,5062470,5062352,5062182,5061935,5062576,5061824,5062048],"length":1,"stats":{"Line":8},"fn_name":"zip_longest<itertools::adaptors::DedupBy<quick::Iter<i16, quick::Exact>, itertools::adaptors::DedupEq>,quick::Iter<i16, quick::Exact>>"},{"line":28,"address":[5061846,5062058,5062389,5062598],"length":1,"stats":{"Line":8},"fn_name":null},{"line":29,"address":[4230013,4229501,4230257,4229757],"length":1,"stats":{"Line":8},"fn_name":null},{"line":40,"address":[4227843,4227792,4228160,4228211],"length":1,"stats":{"Line":6},"fn_name":"next<core::iter::adapters::Map<core::slice::Iter<i32>, closure-0>,core::iter::adapters::Map<core::slice::Iter<i32>, closure-1>>"},{"line":41,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":42,"address":[5058615,5058983,5058704,5058964,5059072,5059332,5059351,5059700,5059440,5059719,5058596,5059808],"length":1,"stats":{"Line":18},"fn_name":null},{"line":43,"address":[4228406,4227952,4228320,4228038],"length":1,"stats":{"Line":10},"fn_name":null},{"line":44,"address":[5059123,5058755,5059491,5059859],"length":1,"stats":{"Line":5},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":50,"address":[5060176,5059952,5060064],"length":1,"stats":{"Line":5},"fn_name":"size_hint<quick::Iter<i16, quick::Exact>,quick::Iter<i16, quick::Exact>>"},{"line":51,"address":[5059964,5060188,5060076],"length":1,"stats":{"Line":5},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":63,"address":[4229035,4229130,4229014],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":17,"coverable":20},{"path":["/","usr","src","itertools","src","ziptuple.rs"],"content":"use super::size_hint;\n\n/// See [`multizip`](../fn.multizip.html) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Zip<T> {\n    t: T,\n}\n\n/// An iterator that generalizes *.zip()* and allows running multiple iterators in lockstep.\n///\n/// The iterator `Zip<(I, J, ..., M)>` is formed from a tuple of iterators (or values that\n/// implement `IntoIterator`) and yields elements\n/// until any of the subiterators yields `None`.\n///\n/// The iterator element type is a tuple like like `(A, B, ..., E)` where `A` to `E` are the\n/// element types of the subiterator.\n///\n/// **Note:** The result of this macro is a value of a named type (`Zip<(I, J,\n/// ..)>` of each component iterator `I, J, ...`) if each component iterator is\n/// nameable.\n///\n/// Prefer [`izip!()`] over `multizip` for the performance benefits of using the\n/// standard library `.zip()`. Prefer `multizip` if a nameable type is needed.\n///\n/// [`izip!()`]: macro.izip.html\n///\n/// ```\n/// use itertools::multizip;\n///\n/// // iterate over three sequences side-by-side\n/// let mut results = [0, 0, 0, 0];\n/// let inputs = [3, 7, 9, 6];\n///\n/// for (r, index, input) in multizip((&mut results, 0..10, &inputs)) {\n///     *r = index * 10 + input;\n/// }\n///\n/// assert_eq!(results, [0 + 3, 10 + 7, 29, 36]);\n/// ```\npub fn multizip<T, U>(t: U) -> Zip<T>\n    where Zip<T>: From<U>,\n          Zip<T>: Iterator,\n{\n    Zip::from(t)\n}\n\nmacro_rules! impl_zip_iter {\n    ($($B:ident),*) => (\n        #[allow(non_snake_case)]\n        impl<$($B: IntoIterator),*> From<($($B,)*)> for Zip<($($B::IntoIter,)*)> {\n            fn from(t: ($($B,)*)) -> Self {\n                let ($($B,)*) = t;\n                Zip { t: ($($B.into_iter(),)*) }\n            }\n        }\n\n        #[allow(non_snake_case)]\n        #[allow(unused_assignments)]\n        impl<$($B),*> Iterator for Zip<($($B,)*)>\n            where\n            $(\n                $B: Iterator,\n            )*\n        {\n            type Item = ($($B::Item,)*);\n\n            fn next(&mut self) -> Option<Self::Item>\n            {\n                let ($(ref mut $B,)*) = self.t;\n\n                // NOTE: Just like iter::Zip, we check the iterators\n                // for None in order. We may finish unevenly (some\n                // iterators gave n + 1 elements, some only n).\n                $(\n                    let $B = match $B.next() {\n                        None => return None,\n                        Some(elt) => elt\n                    };\n                )*\n                Some(($($B,)*))\n            }\n\n            fn size_hint(&self) -> (usize, Option<usize>)\n            {\n                let sh = (::std::usize::MAX, None);\n                let ($(ref $B,)*) = self.t;\n                $(\n                    let sh = size_hint::min($B.size_hint(), sh);\n                )*\n                sh\n            }\n        }\n\n        #[allow(non_snake_case)]\n        impl<$($B),*> ExactSizeIterator for Zip<($($B,)*)> where\n            $(\n                $B: ExactSizeIterator,\n            )*\n        { }\n    );\n}\n\nimpl_zip_iter!(A);\nimpl_zip_iter!(A, B);\nimpl_zip_iter!(A, B, C);\nimpl_zip_iter!(A, B, C, D);\nimpl_zip_iter!(A, B, C, D, E);\nimpl_zip_iter!(A, B, C, D, E, F);\nimpl_zip_iter!(A, B, C, D, E, F, G);\nimpl_zip_iter!(A, B, C, D, E, F, G, H);\n","traces":[{"line":41,"address":[4252288,4252128,4252208],"length":1,"stats":{"Line":7},"fn_name":"multizip<(core::ops::range::Range<i32>, core::ops::range::Range<i32>, core::ops::range::Range<i8>, core::slice::Iter<isize>),(core::ops::range::Range<i32>, core::ops::range::Range<i32>, core::ops::range::Range<i8>, core::slice::Iter<isize>)>"},{"line":45,"address":[4738119],"length":1,"stats":{"Line":7},"fn_name":null},{"line":52,"address":[5133152,5133300,5134329,5133648,5133812,5134160],"length":1,"stats":{"Line":7},"fn_name":"from<&itertools::rciter_impl::RcIter<quick::Iter<i16, quick::Inexact>>,&itertools::rciter_impl::RcIter<quick::Iter<i16, quick::Inexact>>,quick::Iter<i16, quick::Inexact>>"},{"line":53,"address":[4737210],"length":1,"stats":{"Line":7},"fn_name":null},{"line":54,"address":[4250719,4250571,4250118,4249969,4251308,4251470],"length":1,"stats":{"Line":7},"fn_name":null},{"line":68,"address":[4736731,4736624],"length":1,"stats":{"Line":7},"fn_name":"next<itertools::groupbylazy::Group<char, core::str::Chars, closure-3>,itertools::groupbylazy::Group<char, core::str::Chars, closure-3>,itertools::groupbylazy::Group<char, core::str::Chars, closure-3>,itertools::groupbylazy::Group<char, core::str::Chars, closure-3>>"},{"line":70,"address":[4736639],"length":1,"stats":{"Line":7},"fn_name":null},{"line":76,"address":[4736985,4736896,4736794,4736932,4737019,4736697,4736843,4737118],"length":1,"stats":{"Line":39},"fn_name":null},{"line":77,"address":[4736746,4736924,4737023,4737125,4736914,4736833,4736936,4736812,4737002,4737012,4737133,4736847],"length":1,"stats":{"Line":52},"fn_name":null},{"line":78,"address":[4737045,4736767,4736958,4736869],"length":1,"stats":{"Line":21},"fn_name":null},{"line":81,"address":[4737067],"length":1,"stats":{"Line":5},"fn_name":null},{"line":84,"address":[5132384,5132000,5132768],"length":1,"stats":{"Line":3},"fn_name":"size_hint<itertools::adaptors::DedupBy<quick::Iter<i16, quick::Exact>, itertools::adaptors::DedupEq>,quick::Iter<i16, quick::Exact>,quick::Iter<i16, quick::Exact>>"},{"line":86,"address":[5132786,5132018,5132402],"length":1,"stats":{"Line":3},"fn_name":null},{"line":87,"address":[5132056,5132824,5132440],"length":1,"stats":{"Line":3},"fn_name":null},{"line":89,"address":[5132100,5132868,5132484],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":15,"coverable":15},{"path":["/","usr","src","itertools","tests","adaptors_no_collect.rs"],"content":"use itertools::Itertools;\n\nstruct PanickingCounter {\n    curr: usize,\n    max: usize,\n}\n\nimpl Iterator for PanickingCounter {\n    type Item = ();\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.curr += 1;\n\n        if self.curr == self.max {\n            panic!(\n                \"Input iterator reached maximum of {} suggesting collection by adaptor\",\n                self.max\n            );\n        }\n\n        Some(())\n    }\n}\n\nfn no_collect_test<A, T>(to_adaptor: T)\n    where A: Iterator, T: Fn(PanickingCounter) -> A\n{\n    let counter = PanickingCounter { curr: 0, max: 10_000 };\n    let adaptor = to_adaptor(counter);\n\n    for _ in adaptor.take(5) {}\n}\n\n#[test]\nfn permutations_no_collect() {\n    no_collect_test(|iter| iter.permutations(5))\n}\n\n#[test]\nfn combinations_no_collect() {\n    no_collect_test(|iter| iter.combinations(5))\n}\n\n#[test]\nfn combinations_with_replacement_no_collect() {\n    no_collect_test(|iter| iter.combinations_with_replacement(5))\n}","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[4238432,4238524,4239148,4237824,4237904,4239056],"length":1,"stats":{"Line":3},"fn_name":"no_collect_test<itertools::combinations::Combinations<adaptors_no_collect::PanickingCounter>,closure-0>"},{"line":28,"address":[4237831,4238439,4239063],"length":1,"stats":{"Line":3},"fn_name":null},{"line":29,"address":[4237857,4239089,4238465],"length":1,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[4238663,4239601,4237919,4239306,4239163,4238030,4238325,4238958,4238539],"length":1,"stats":{"Line":6},"fn_name":null},{"line":35,"address":[4239712,4239717],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":36,"address":[4232737],"length":1,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[4232752],"length":1,"stats":{"Line":3},"fn_name":"combinations_no_collect"},{"line":41,"address":[4232753],"length":1,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[4232768],"length":1,"stats":{"Line":3},"fn_name":"combinations_with_replacement_no_collect"},{"line":46,"address":[4232769],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":13,"coverable":16},{"path":["/","usr","src","itertools","tests","fold_specialization.rs"],"content":"use itertools::Itertools;\n\n#[test]\nfn specialization_intersperse() {\n    let mut iter = (1..2).intersperse(0);\n    iter.clone().for_each(|x| assert_eq!(Some(x), iter.next()));\n\n    let mut iter = (1..3).intersperse(0);\n    iter.clone().for_each(|x| assert_eq!(Some(x), iter.next()));\n\n    let mut iter = (1..4).intersperse(0);\n    iter.clone().for_each(|x| assert_eq!(Some(x), iter.next()));\n}\n","traces":[{"line":4,"address":[4217184],"length":1,"stats":{"Line":3},"fn_name":"specialization_intersperse"},{"line":5,"address":[4217193],"length":1,"stats":{"Line":1},"fn_name":null},{"line":6,"address":[4217227],"length":1,"stats":{"Line":3},"fn_name":null},{"line":8,"address":[4217269],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[4217303],"length":1,"stats":{"Line":3},"fn_name":null},{"line":11,"address":[4217351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[4217400],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","usr","src","itertools","tests","merge_join.rs"],"content":"use itertools::EitherOrBoth;\nuse itertools::free::merge_join_by;\n\n#[test]\nfn empty() {\n    let left: Vec<u32> = vec![];\n    let right: Vec<u32> = vec![];\n    let expected_result: Vec<EitherOrBoth<u32, u32>> = vec![];\n    let actual_result = merge_join_by(left, right, |l, r| l.cmp(r))\n        .collect::<Vec<_>>();\n    assert_eq!(expected_result, actual_result);\n}\n\n#[test]\nfn left_only() {\n    let left: Vec<u32> = vec![1,2,3];\n    let right: Vec<u32> = vec![];\n    let expected_result: Vec<EitherOrBoth<u32, u32>> = vec![\n        EitherOrBoth::Left(1),\n        EitherOrBoth::Left(2),\n        EitherOrBoth::Left(3)\n    ];\n    let actual_result = merge_join_by(left, right, |l, r| l.cmp(r))\n        .collect::<Vec<_>>();\n    assert_eq!(expected_result, actual_result);\n}\n\n#[test]\nfn right_only() {\n    let left: Vec<u32> = vec![];\n    let right: Vec<u32> = vec![1,2,3];\n    let expected_result: Vec<EitherOrBoth<u32, u32>> = vec![\n        EitherOrBoth::Right(1),\n        EitherOrBoth::Right(2),\n        EitherOrBoth::Right(3)\n    ];\n    let actual_result = merge_join_by(left, right, |l, r| l.cmp(r))\n        .collect::<Vec<_>>();\n    assert_eq!(expected_result, actual_result);\n}\n\n#[test]\nfn first_left_then_right() {\n    let left: Vec<u32> = vec![1,2,3];\n    let right: Vec<u32> = vec![4,5,6];\n    let expected_result: Vec<EitherOrBoth<u32, u32>> = vec![\n        EitherOrBoth::Left(1),\n        EitherOrBoth::Left(2),\n        EitherOrBoth::Left(3),\n        EitherOrBoth::Right(4),\n        EitherOrBoth::Right(5),\n        EitherOrBoth::Right(6)\n    ];\n    let actual_result = merge_join_by(left, right, |l, r| l.cmp(r))\n        .collect::<Vec<_>>();\n    assert_eq!(expected_result, actual_result);\n}\n\n#[test]\nfn first_right_then_left() {\n    let left: Vec<u32> = vec![4,5,6];\n    let right: Vec<u32> = vec![1,2,3];\n    let expected_result: Vec<EitherOrBoth<u32, u32>> = vec![\n        EitherOrBoth::Right(1),\n        EitherOrBoth::Right(2),\n        EitherOrBoth::Right(3),\n        EitherOrBoth::Left(4),\n        EitherOrBoth::Left(5),\n        EitherOrBoth::Left(6)\n    ];\n    let actual_result = merge_join_by(left, right, |l, r| l.cmp(r))\n        .collect::<Vec<_>>();\n    assert_eq!(expected_result, actual_result);\n}\n\n#[test]\nfn interspersed_left_and_right() {\n    let left: Vec<u32> = vec![1,3,5];\n    let right: Vec<u32> = vec![2,4,6];\n    let expected_result: Vec<EitherOrBoth<u32, u32>> = vec![\n        EitherOrBoth::Left(1),\n        EitherOrBoth::Right(2),\n        EitherOrBoth::Left(3),\n        EitherOrBoth::Right(4),\n        EitherOrBoth::Left(5),\n        EitherOrBoth::Right(6)\n    ];\n    let actual_result = merge_join_by(left, right, |l, r| l.cmp(r))\n        .collect::<Vec<_>>();\n    assert_eq!(expected_result, actual_result);\n}\n\n#[test]\nfn overlapping_left_and_right() {\n    let left: Vec<u32> = vec![1,3,4,6];\n    let right: Vec<u32> = vec![2,3,4,5];\n    let expected_result: Vec<EitherOrBoth<u32, u32>> = vec![\n        EitherOrBoth::Left(1),\n        EitherOrBoth::Right(2),\n        EitherOrBoth::Both(3, 3),\n        EitherOrBoth::Both(4, 4),\n        EitherOrBoth::Right(5),\n        EitherOrBoth::Left(6)\n    ];\n    let actual_result = merge_join_by(left, right, |l, r| l.cmp(r))\n        .collect::<Vec<_>>();\n    assert_eq!(expected_result, actual_result);\n}\n","traces":[{"line":5,"address":[4213248,4213291],"length":1,"stats":{"Line":3},"fn_name":"empty"},{"line":6,"address":[4213255],"length":1,"stats":{"Line":1},"fn_name":null},{"line":7,"address":[4213311],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[4213318],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[4213341],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[4213492,4213623],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[4214128,4214209],"length":1,"stats":{"Line":3},"fn_name":"left_only"},{"line":16,"address":[4214224,4214135],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[4214237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[4214244,4214333],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4214267],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[4214289],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[4214311],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[4214440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[4214722,4214591],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[4215259,4215216],"length":1,"stats":{"Line":3},"fn_name":"right_only"},{"line":30,"address":[4215223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[4215284,4215345],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[4215363,4215434],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[4215368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[4215390],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[4215412],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[4215541],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[4215692,4215823],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4216385,4216304],"length":1,"stats":{"Line":3},"fn_name":"first_left_then_right"},{"line":44,"address":[4216400,4216311],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[4216479,4216418],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[4216497,4216634],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[4216502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[4216524],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[4216546],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[4216568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[4216590],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[4216612],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[4216807],"length":1,"stats":{"Line":3},"fn_name":null},{"line":56,"address":[4216958,4217089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4217649,4217568],"length":1,"stats":{"Line":3},"fn_name":"first_right_then_left"},{"line":61,"address":[4217664,4217575],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[4217743,4217682],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[4217761,4217898],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[4217766],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[4217788],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[4217810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[4217832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[4217854],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[4217876],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[4218071],"length":1,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[4218353,4218222],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[4218832,4218913],"length":1,"stats":{"Line":3},"fn_name":"interspersed_left_and_right"},{"line":78,"address":[4218928,4218839],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[4219007,4218946],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[4219025,4219162],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[4219030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[4219052],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[4219074],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[4219096],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[4219118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[4219140],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[4219335],"length":1,"stats":{"Line":3},"fn_name":null},{"line":90,"address":[4219617,4219486],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[4220184,4220096],"length":1,"stats":{"Line":3},"fn_name":"overlapping_left_and_right"},{"line":95,"address":[4220103,4220199],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[4220293,4220217],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[4220470,4220311],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[4220316],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[4220338],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[4220360],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[4220393],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[4220426],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[4220448],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[4220643],"length":1,"stats":{"Line":3},"fn_name":null},{"line":107,"address":[4220794,4220925],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":72,"coverable":72},{"path":["/","usr","src","itertools","tests","peeking_take_while.rs"],"content":"use itertools::Itertools;\nuse itertools::{put_back, put_back_n};\n\n#[test]\nfn peeking_take_while_peekable() {\n    let mut r = (0..10).peekable();\n    r.peeking_take_while(|x| *x <= 3).count();\n    assert_eq!(r.next(), Some(4));\n}\n\n#[test]\nfn peeking_take_while_put_back() {\n    let mut r = put_back(0..10);\n    r.peeking_take_while(|x| *x <= 3).count();\n    assert_eq!(r.next(), Some(4));\n    r.peeking_take_while(|_| true).count();\n    assert_eq!(r.next(), None);\n}\n\n#[test]\nfn peeking_take_while_put_back_n() {\n    let mut r = put_back_n(6..10);\n    for elt in (0..6).rev() {\n        r.put_back(elt);\n    }\n    r.peeking_take_while(|x| *x <= 3).count();\n    assert_eq!(r.next(), Some(4));\n    r.peeking_take_while(|_| true).count();\n    assert_eq!(r.next(), None);\n}\n\n#[test]\nfn peeking_take_while_slice_iter() {\n    let v = [1, 2, 3, 4, 5, 6];\n    let mut r = v.iter();\n    r.peeking_take_while(|x| **x <= 3).count();\n    assert_eq!(r.next(), Some(&4));\n    r.peeking_take_while(|_| true).count();\n    assert_eq!(r.next(), None);\n}\n\n#[test]\nfn peeking_take_while_slice_iter_rev() {\n    let v = [1, 2, 3, 4, 5, 6];\n    let mut r = v.iter().rev();\n    r.peeking_take_while(|x| **x >= 3).count();\n    assert_eq!(r.next(), Some(&2));\n    r.peeking_take_while(|_| true).count();\n    assert_eq!(r.next(), None);\n}\n","traces":[{"line":5,"address":[4233264],"length":1,"stats":{"Line":3},"fn_name":"peeking_take_while_peekable"},{"line":6,"address":[4233271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":7,"address":[4211776,4211789],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":8,"address":[4233335,4233448],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[4211808,4211813],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":13,"address":[4233751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[4233800],"length":1,"stats":{"Line":3},"fn_name":null},{"line":15,"address":[4233997,4233842],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[4211872,4211885,4211897],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":17,"address":[4234442,4234317],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[4211909,4211904],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":22,"address":[4234743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[4234923,4234809,4235089,4235042],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[4235080],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[4211949,4211936],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":27,"address":[4235117,4235301],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[4211993,4211981,4211968],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":29,"address":[4235812,4235660],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[4212005,4212000],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":34,"address":[4236151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[4236230],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[4212045,4212032],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":37,"address":[4236285,4236442],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[4212105,4212093,4212080],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":39,"address":[4236754,4236881],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4212112,4212117],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":44,"address":[4237175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[4237241],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[4212144,4212157],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":47,"address":[4237349,4237506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[4212192,4212217,4212205],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":49,"address":[4237818,4237945],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":32,"coverable":32},{"path":["/","usr","src","itertools","tests","quick.rs"],"content":"//! The purpose of these tests is to cover corner cases of iterators\n//! and adaptors.\n//!\n//! In particular we test the tedious size_hint and exact size correctness.\n\nuse quickcheck as qc;\nuse std::default::Default;\nuse std::ops::Range;\nuse std::cmp::{max, min, Ordering};\nuse std::collections::HashSet;\nuse itertools::Itertools;\nuse itertools::{\n    multizip,\n    EitherOrBoth,\n    iproduct,\n    izip,\n};\nuse itertools::free::{\n    cloned,\n    enumerate,\n    multipeek,\n    peek_nth,\n    put_back,\n    put_back_n,\n    rciter,\n    zip,\n    zip_eq,\n};\n\nuse rand::Rng;\nuse rand::seq::SliceRandom;\nuse quickcheck::TestResult;\n\n/// Trait for size hint modifier types\ntrait HintKind: Copy + Send + qc::Arbitrary {\n    fn loosen_bounds(&self, org_hint: (usize, Option<usize>)) -> (usize, Option<usize>);\n}\n\n/// Exact size hint variant that leaves hints unchanged\n#[derive(Clone, Copy, Debug)]\nstruct Exact {}\n\nimpl HintKind for Exact {\n    fn loosen_bounds(&self, org_hint: (usize, Option<usize>)) -> (usize, Option<usize>) {\n        org_hint\n    }\n}\n\nimpl qc::Arbitrary for Exact {\n    fn arbitrary<G: qc::Gen>(_: &mut G) -> Self {\n        Exact {}\n    }\n}\n\n/// Inexact size hint variant to simulate imprecise (but valid) size hints\n///\n/// Will always decrease the lower bound and increase the upper bound\n/// of the size hint by set amounts.\n#[derive(Clone, Copy, Debug)]\nstruct Inexact {\n    underestimate: usize,\n    overestimate: usize,\n}\n\nimpl HintKind for Inexact {\n    fn loosen_bounds(&self, org_hint: (usize, Option<usize>)) -> (usize, Option<usize>) {\n        let (org_lower, org_upper) = org_hint;\n        (org_lower.saturating_sub(self.underestimate),\n         org_upper.and_then(move |x| x.checked_add(self.overestimate)))\n    }\n}\n\nimpl qc::Arbitrary for Inexact {\n    fn arbitrary<G: qc::Gen>(g: &mut G) -> Self {\n        let ue_value = usize::arbitrary(g);\n        let oe_value = usize::arbitrary(g);\n        // Compensate for quickcheck using extreme values too rarely\n        let ue_choices = &[0, ue_value, usize::max_value()];\n        let oe_choices = &[0, oe_value, usize::max_value()];\n        Inexact {\n            underestimate: *ue_choices.choose(g).unwrap(),\n            overestimate: *oe_choices.choose(g).unwrap(),\n        }\n    }\n\n    fn shrink(&self) -> Box<dyn Iterator<Item=Self>> {\n        let underestimate_value = self.underestimate;\n        let overestimate_value = self.overestimate;\n        Box::new(\n            underestimate_value.shrink().flat_map(move |ue_value|\n                overestimate_value.shrink().map(move |oe_value|\n                    Inexact {\n                        underestimate: ue_value,\n                        overestimate: oe_value,\n                    }\n                )\n            )\n        )\n    }\n}\n\n/// Our base iterator that we can impl Arbitrary for\n///\n/// By default we'll return inexact bounds estimates for size_hint\n/// to make tests harder to pass.\n///\n/// NOTE: Iter is tricky and is not fused, to help catch bugs.\n/// At the end it will return None once, then return Some(0),\n/// then return None again.\n#[derive(Clone, Debug)]\nstruct Iter<T, SK: HintKind = Inexact> {\n    iterator: Range<T>,\n    // fuse/done flag\n    fuse_flag: i32,\n    hint_kind: SK,\n}\n\nimpl<T, HK> Iter<T, HK> where HK: HintKind\n{\n    fn new(it: Range<T>, hint_kind: HK) -> Self {\n        Iter {\n            iterator: it,\n            fuse_flag: 0,\n            hint_kind,\n        }\n    }\n}\n\nimpl<T, HK> Iterator for Iter<T, HK>\n    where Range<T>: Iterator,\n          <Range<T> as Iterator>::Item: Default,\n          HK: HintKind,\n{\n    type Item = <Range<T> as Iterator>::Item;\n\n    fn next(&mut self) -> Option<Self::Item>\n    {\n        let elt = self.iterator.next();\n        if elt.is_none() {\n            self.fuse_flag += 1;\n            // check fuse flag\n            if self.fuse_flag == 2 {\n                return Some(Default::default())\n            }\n        }\n        elt\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>)\n    {\n        let org_hint = self.iterator.size_hint();\n        self.hint_kind.loosen_bounds(org_hint)\n    }\n}\n\nimpl<T, HK> DoubleEndedIterator for Iter<T, HK>\n    where Range<T>: DoubleEndedIterator,\n          <Range<T> as Iterator>::Item: Default,\n          HK: HintKind\n{\n    fn next_back(&mut self) -> Option<Self::Item> { self.iterator.next_back() }\n}\n\nimpl<T> ExactSizeIterator for Iter<T, Exact> where Range<T>: ExactSizeIterator,\n    <Range<T> as Iterator>::Item: Default,\n{ }\n\nimpl<T, HK> qc::Arbitrary for Iter<T, HK>\n    where T: qc::Arbitrary,\n          HK: HintKind,\n{\n    fn arbitrary<G: qc::Gen>(g: &mut G) -> Self\n    {\n        Iter::new(T::arbitrary(g)..T::arbitrary(g), HK::arbitrary(g))\n    }\n\n    fn shrink(&self) -> Box<dyn Iterator<Item=Iter<T, HK>>>\n    {\n        let r = self.iterator.clone();\n        let hint_kind = self.hint_kind;\n        Box::new(\n            r.start.shrink().flat_map(move |a|\n                r.end.shrink().map(move |b|\n                    Iter::new(a.clone()..b, hint_kind)\n                )\n            )\n        )\n    }\n}\n\n/// A meta-iterator which yields `Iter<i32>`s whose start/endpoints are\n/// increased or decreased linearly on each iteration.\n#[derive(Clone, Debug)]\nstruct ShiftRange<HK = Inexact> {\n    range_start: i32,\n    range_end: i32,\n    start_step: i32,\n    end_step: i32,\n    iter_count: u32,\n    hint_kind: HK,\n}\n\nimpl<HK> Iterator for ShiftRange<HK> where HK: HintKind {\n    type Item = Iter<i32, HK>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.iter_count == 0 {\n            return None;\n        }\n\n        let iter = Iter::new(self.range_start..self.range_end, self.hint_kind);\n\n        self.range_start += self.start_step;\n        self.range_end += self.end_step;\n        self.iter_count -= 1;\n\n        Some(iter)\n    }\n}\n\nimpl ExactSizeIterator for ShiftRange<Exact> { }\n\nimpl<HK> qc::Arbitrary for ShiftRange<HK>\n    where HK: HintKind\n{\n    fn arbitrary<G: qc::Gen>(g: &mut G) -> Self {\n        const MAX_STARTING_RANGE_DIFF: i32 = 32;\n        const MAX_STEP_MODULO: i32 = 8;\n        const MAX_ITER_COUNT: u32 = 3;\n\n        let range_start = qc::Arbitrary::arbitrary(g);\n        let range_end = range_start + g.gen_range(0, MAX_STARTING_RANGE_DIFF + 1);\n        let start_step = g.gen_range(-MAX_STEP_MODULO, MAX_STEP_MODULO + 1);\n        let end_step = g.gen_range(-MAX_STEP_MODULO, MAX_STEP_MODULO + 1);\n        let iter_count = g.gen_range(0, MAX_ITER_COUNT + 1);\n        let hint_kind = qc::Arbitrary::arbitrary(g);\n\n        ShiftRange {\n            range_start,\n            range_end,\n            start_step,\n            end_step,\n            iter_count,\n            hint_kind,\n        }\n    }\n}\n\nfn correct_count<I, F>(get_it: F) -> bool\nwhere\n    I: Iterator,\n    F: Fn() -> I\n{\n    let mut counts = vec![get_it().count()];\n\n    'outer: loop {\n        let mut it = get_it();\n\n        for _ in 0..(counts.len() - 1) {\n            if let None = it.next() {\n                panic!(\"Iterator shouldn't be finished, may not be deterministic\");\n            }\n        }\n\n        if let None = it.next() {\n            break 'outer;\n        }\n\n        counts.push(it.count());\n    }\n\n    let total_actual_count = counts.len() - 1;\n\n    for (i, returned_count) in counts.into_iter().enumerate() {\n        let actual_count = total_actual_count - i;\n        if actual_count != returned_count {\n            println!(\"Total iterations: {} True count: {} returned count: {}\", i, actual_count, returned_count);\n\n            return false;\n        }\n    }\n\n    true\n}\n\nfn correct_size_hint<I: Iterator>(mut it: I) -> bool {\n    // record size hint at each iteration\n    let initial_hint = it.size_hint();\n    let mut hints = Vec::with_capacity(initial_hint.0 + 1);\n    hints.push(initial_hint);\n    while let Some(_) = it.next() {\n        hints.push(it.size_hint())\n    }\n\n    let mut true_count = hints.len(); // start off +1 too much\n\n    // check all the size hints\n    for &(low, hi) in &hints {\n        true_count -= 1;\n        if low > true_count ||\n            (hi.is_some() && hi.unwrap() < true_count)\n        {\n            println!(\"True size: {:?}, size hint: {:?}\", true_count, (low, hi));\n            //println!(\"All hints: {:?}\", hints);\n            return false\n        }\n    }\n    true\n}\n\nfn exact_size<I: ExactSizeIterator>(mut it: I) -> bool {\n    // check every iteration\n    let (mut low, mut hi) = it.size_hint();\n    if Some(low) != hi { return false; }\n    while let Some(_) = it.next() {\n        let (xlow, xhi) = it.size_hint();\n        if low != xlow + 1 { return false; }\n        low = xlow;\n        hi = xhi;\n        if Some(low) != hi { return false; }\n    }\n    let (low, hi) = it.size_hint();\n    low == 0 && hi == Some(0)\n}\n\n// Exact size for this case, without ExactSizeIterator\nfn exact_size_for_this<I: Iterator>(mut it: I) -> bool {\n    // check every iteration\n    let (mut low, mut hi) = it.size_hint();\n    if Some(low) != hi { return false; }\n    while let Some(_) = it.next() {\n        let (xlow, xhi) = it.size_hint();\n        if low != xlow + 1 { return false; }\n        low = xlow;\n        hi = xhi;\n        if Some(low) != hi { return false; }\n    }\n    let (low, hi) = it.size_hint();\n    low == 0 && hi == Some(0)\n}\n\n/*\n * NOTE: Range<i8> is broken!\n * (all signed ranges are)\n#[quickcheck]\nfn size_range_i8(a: Iter<i8>) -> bool {\n    exact_size(a)\n}\n\n#[quickcheck]\nfn size_range_i16(a: Iter<i16>) -> bool {\n    exact_size(a)\n}\n\n#[quickcheck]\nfn size_range_u8(a: Iter<u8>) -> bool {\n    exact_size(a)\n}\n */\n\nmacro_rules! quickcheck {\n    // accept several property function definitions\n    // The property functions can use pattern matching and `mut` as usual\n    // in the function arguments, but the functions can not be generic.\n    {$($(#$attr:tt)* fn $fn_name:ident($($arg:tt)*) -> $ret:ty { $($code:tt)* })*} => (\n        $(\n            #[test]\n            $(#$attr)*\n            fn $fn_name() {\n                fn prop($($arg)*) -> $ret {\n                    $($code)*\n                }\n                ::quickcheck::quickcheck(quickcheck!(@fn prop [] $($arg)*));\n            }\n        )*\n    );\n    // parse argument list (with patterns allowed) into prop as fn(_, _) -> _\n    (@fn $f:ident [$($t:tt)*]) => {\n        $f as fn($($t),*) -> _\n    };\n    (@fn $f:ident [$($p:tt)*] : $($tail:tt)*) => {\n        quickcheck!(@fn $f [$($p)* _] $($tail)*)\n    };\n    (@fn $f:ident [$($p:tt)*] $t:tt $($tail:tt)*) => {\n        quickcheck!(@fn $f [$($p)*] $($tail)*)\n    };\n}\n\nquickcheck! {\n\n    fn size_product(a: Iter<u16>, b: Iter<u16>) -> bool {\n        correct_size_hint(a.cartesian_product(b))\n    }\n    fn size_product3(a: Iter<u16>, b: Iter<u16>, c: Iter<u16>) -> bool {\n        correct_size_hint(iproduct!(a, b, c))\n    }\n\n    fn correct_cartesian_product3(a: Iter<u16>, b: Iter<u16>, c: Iter<u16>,\n                                  take_manual: usize) -> ()\n    {\n        // test correctness of iproduct through regular iteration (take)\n        // and through fold.\n        let ac = a.clone();\n        let br = &b.clone();\n        let cr = &c.clone();\n        let answer: Vec<_> = ac.flat_map(move |ea| br.clone().flat_map(move |eb| cr.clone().map(move |ec| (ea, eb, ec)))).collect();\n        let mut product_iter = iproduct!(a, b, c);\n        let mut actual = Vec::new();\n\n        actual.extend((&mut product_iter).take(take_manual));\n        if actual.len() == take_manual {\n            product_iter.fold((), |(), elt| actual.push(elt));\n        }\n        assert_eq!(answer, actual);\n    }\n\n    fn size_multi_product(a: ShiftRange) -> bool {\n        correct_size_hint(a.multi_cartesian_product())\n    }\n    fn correct_multi_product3(a: ShiftRange, take_manual: usize) -> () {\n        // Fix no. of iterators at 3\n        let a = ShiftRange { iter_count: 3, ..a };\n\n        // test correctness of MultiProduct through regular iteration (take)\n        // and through fold.\n        let mut iters = a.clone();\n        let i0 = iters.next().unwrap();\n        let i1r = &iters.next().unwrap();\n        let i2r = &iters.next().unwrap();\n        let answer: Vec<_> = i0.flat_map(move |ei0| i1r.clone().flat_map(move |ei1| i2r.clone().map(move |ei2| vec![ei0, ei1, ei2]))).collect();\n        let mut multi_product = a.clone().multi_cartesian_product();\n        let mut actual = Vec::new();\n\n        actual.extend((&mut multi_product).take(take_manual));\n        if actual.len() == take_manual {\n            multi_product.fold((), |(), elt| actual.push(elt));\n        }\n        assert_eq!(answer, actual);\n\n        assert_eq!(answer.into_iter().last(), a.clone().multi_cartesian_product().last());\n    }\n\n    #[allow(deprecated)]\n    fn size_step(a: Iter<i16, Exact>, s: usize) -> bool {\n        let mut s = s;\n        if s == 0 {\n            s += 1; // never zero\n        }\n        let filt = a.clone().dedup();\n        correct_size_hint(filt.step(s)) &&\n            exact_size(a.step(s))\n    }\n\n    #[allow(deprecated)]\n    fn equal_step(a: Iter<i16>, s: usize) -> bool {\n        let mut s = s;\n        if s == 0 {\n            s += 1; // never zero\n        }\n        let mut i = 0;\n        itertools::equal(a.clone().step(s), a.filter(|_| {\n            let keep = i % s == 0;\n            i += 1;\n            keep\n        }))\n    }\n\n    #[allow(deprecated)]\n    fn equal_step_vec(a: Vec<i16>, s: usize) -> bool {\n        let mut s = s;\n        if s == 0 {\n            s += 1; // never zero\n        }\n        let mut i = 0;\n        itertools::equal(a.iter().step(s), a.iter().filter(|_| {\n            let keep = i % s == 0;\n            i += 1;\n            keep\n        }))\n    }\n\n    fn size_multipeek(a: Iter<u16, Exact>, s: u8) -> bool {\n        let mut it = multipeek(a);\n        // peek a few times\n        for _ in 0..s {\n            it.peek();\n        }\n        exact_size(it)\n    }\n\n    fn size_peek_nth(a: Iter<u16, Exact>, s: u8) -> bool {\n        let mut it = peek_nth(a);\n        // peek a few times\n        for n in 0..s {\n            it.peek_nth(n as usize);\n        }\n        exact_size(it)\n    }\n\n    fn equal_merge(a: Vec<i16>, b: Vec<i16>) -> bool {\n        let mut sa = a.clone();\n        let mut sb = b.clone();\n        sa.sort();\n        sb.sort();\n        let mut merged = sa.clone();\n        merged.extend(sb.iter().cloned());\n        merged.sort();\n        itertools::equal(&merged, sa.iter().merge(&sb))\n    }\n    fn size_merge(a: Iter<u16>, b: Iter<u16>) -> bool {\n        correct_size_hint(a.merge(b))\n    }\n    fn size_zip(a: Iter<i16, Exact>, b: Iter<i16, Exact>, c: Iter<i16, Exact>) -> bool {\n        let filt = a.clone().dedup();\n        correct_size_hint(multizip((filt, b.clone(), c.clone()))) &&\n            exact_size(multizip((a, b, c)))\n    }\n    fn size_zip_rc(a: Iter<i16>, b: Iter<i16>) -> bool {\n        let rc = rciter(a.clone());\n        correct_size_hint(multizip((&rc, &rc, b)))\n    }\n\n    fn size_zip_macro(a: Iter<i16, Exact>, b: Iter<i16, Exact>, c: Iter<i16, Exact>) -> bool {\n        let filt = a.clone().dedup();\n        correct_size_hint(izip!(filt, b.clone(), c.clone())) &&\n            exact_size(izip!(a, b, c))\n    }\n    fn equal_kmerge(a: Vec<i16>, b: Vec<i16>, c: Vec<i16>) -> bool {\n        use itertools::free::kmerge;\n        let mut sa = a.clone();\n        let mut sb = b.clone();\n        let mut sc = c.clone();\n        sa.sort();\n        sb.sort();\n        sc.sort();\n        let mut merged = sa.clone();\n        merged.extend(sb.iter().cloned());\n        merged.extend(sc.iter().cloned());\n        merged.sort();\n        itertools::equal(merged.into_iter(), kmerge(vec![sa, sb, sc]))\n    }\n\n    // Any number of input iterators\n    fn equal_kmerge_2(mut inputs: Vec<Vec<i16>>) -> bool {\n        use itertools::free::kmerge;\n        // sort the inputs\n        for input in &mut inputs {\n            input.sort();\n        }\n        let mut merged = inputs.concat();\n        merged.sort();\n        itertools::equal(merged.into_iter(), kmerge(inputs))\n    }\n\n    // Any number of input iterators\n    fn equal_kmerge_by_ge(mut inputs: Vec<Vec<i16>>) -> bool {\n        // sort the inputs\n        for input in &mut inputs {\n            input.sort();\n            input.reverse();\n        }\n        let mut merged = inputs.concat();\n        merged.sort();\n        merged.reverse();\n        itertools::equal(merged.into_iter(),\n                         inputs.into_iter().kmerge_by(|x, y| x >= y))\n    }\n\n    // Any number of input iterators\n    fn equal_kmerge_by_lt(mut inputs: Vec<Vec<i16>>) -> bool {\n        // sort the inputs\n        for input in &mut inputs {\n            input.sort();\n        }\n        let mut merged = inputs.concat();\n        merged.sort();\n        itertools::equal(merged.into_iter(),\n                         inputs.into_iter().kmerge_by(|x, y| x < y))\n    }\n\n    // Any number of input iterators\n    fn equal_kmerge_by_le(mut inputs: Vec<Vec<i16>>) -> bool {\n        // sort the inputs\n        for input in &mut inputs {\n            input.sort();\n        }\n        let mut merged = inputs.concat();\n        merged.sort();\n        itertools::equal(merged.into_iter(),\n                         inputs.into_iter().kmerge_by(|x, y| x <= y))\n    }\n    fn size_kmerge(a: Iter<i16>, b: Iter<i16>, c: Iter<i16>) -> bool {\n        use itertools::free::kmerge;\n        correct_size_hint(kmerge(vec![a, b, c]))\n    }\n    fn equal_zip_eq(a: Vec<i32>, b: Vec<i32>) -> bool {\n        let len = std::cmp::min(a.len(), b.len());\n        let a = &a[..len];\n        let b = &b[..len];\n        itertools::equal(zip_eq(a, b), zip(a, b))\n    }\n    fn size_zip_longest(a: Iter<i16, Exact>, b: Iter<i16, Exact>) -> bool {\n        let filt = a.clone().dedup();\n        let filt2 = b.clone().dedup();\n        correct_size_hint(filt.zip_longest(b.clone())) &&\n        correct_size_hint(a.clone().zip_longest(filt2)) &&\n            exact_size(a.zip_longest(b))\n    }\n    fn size_2_zip_longest(a: Iter<i16>, b: Iter<i16>) -> bool {\n        let it = a.clone().zip_longest(b.clone());\n        let jt = a.clone().zip_longest(b.clone());\n        itertools::equal(a.clone(),\n                         it.filter_map(|elt| match elt {\n                             EitherOrBoth::Both(x, _) => Some(x),\n                             EitherOrBoth::Left(x) => Some(x),\n                             _ => None,\n                         }\n                         ))\n            &&\n        itertools::equal(b.clone(),\n                         jt.filter_map(|elt| match elt {\n                             EitherOrBoth::Both(_, y) => Some(y),\n                             EitherOrBoth::Right(y) => Some(y),\n                             _ => None,\n                         }\n                         ))\n    }\n    fn size_interleave(a: Iter<i16>, b: Iter<i16>) -> bool {\n        correct_size_hint(a.interleave(b))\n    }\n    fn exact_interleave(a: Iter<i16, Exact>, b: Iter<i16, Exact>) -> bool {\n        exact_size_for_this(a.interleave(b))\n    }\n    fn size_interleave_shortest(a: Iter<i16>, b: Iter<i16>) -> bool {\n        correct_size_hint(a.interleave_shortest(b))\n    }\n    fn exact_interleave_shortest(a: Vec<()>, b: Vec<()>) -> bool {\n        exact_size_for_this(a.iter().interleave_shortest(&b))\n    }\n    fn size_intersperse(a: Iter<i16>, x: i16) -> bool {\n        correct_size_hint(a.intersperse(x))\n    }\n    fn equal_intersperse(a: Vec<i32>, x: i32) -> bool {\n        let mut inter = false;\n        let mut i = 0;\n        for elt in a.iter().cloned().intersperse(x) {\n            if inter {\n                if elt != x { return false }\n            } else {\n                if elt != a[i] { return false }\n                i += 1;\n            }\n            inter = !inter;\n        }\n        true\n    }\n\n    fn equal_combinations_2(a: Vec<u8>) -> bool {\n        let mut v = Vec::new();\n        for (i, x) in enumerate(&a) {\n            for y in &a[i + 1..] {\n                v.push((x, y));\n            }\n        }\n        itertools::equal(a.iter().tuple_combinations::<(_, _)>(), v)\n    }\n\n    fn collect_tuple_matches_size(a: Iter<i16>) -> bool {\n        let size = a.clone().count();\n        a.collect_tuple::<(_, _, _)>().is_some() == (size == 3)\n    }\n\n    fn correct_permutations(vals: HashSet<i32>, k: usize) -> () {\n        // Test permutations only on iterators of distinct integers, to prevent\n        // false positives.\n\n        const MAX_N: usize = 5;\n\n        let n = min(vals.len(), MAX_N);\n        let vals: HashSet<i32> = vals.into_iter().take(n).collect();\n\n        let perms = vals.iter().permutations(k);\n\n        let mut actual = HashSet::new();\n\n        for perm in perms {\n            assert_eq!(perm.len(), k);\n\n            let all_items_valid = perm.iter().all(|p| vals.contains(p));\n            assert!(all_items_valid, \"perm contains value not from input: {:?}\", perm);\n\n            // Check that all perm items are distinct\n            let distinct_len = {\n                let perm_set: HashSet<_> = perm.iter().collect();\n                perm_set.len()\n            };\n            assert_eq!(perm.len(), distinct_len);\n\n            // Check that the perm is new\n            assert!(actual.insert(perm.clone()), \"perm already encountered: {:?}\", perm);\n        }\n    }\n\n    fn permutations_lexic_order(a: usize, b: usize) -> () {\n        let a = a % 6;\n        let b = b % 6;\n\n        let n = max(a, b);\n        let k = min (a, b);\n\n        let expected_first: Vec<usize> = (0..k).collect();\n        let expected_last: Vec<usize> = ((n - k)..n).rev().collect();\n\n        let mut perms = (0..n).permutations(k);\n\n        let mut curr_perm = match perms.next() {\n            Some(p) => p,\n            None => { return; }\n        };\n\n        assert_eq!(expected_first, curr_perm);\n\n        while let Some(next_perm) = perms.next() {\n            assert!(\n                next_perm > curr_perm,\n                \"next perm isn't greater-than current; next_perm={:?} curr_perm={:?} n={}\",\n                next_perm, curr_perm, n\n            );\n\n            curr_perm = next_perm;\n        }\n\n        assert_eq!(expected_last, curr_perm);\n\n    }\n\n    fn permutations_count(n: usize, k: usize) -> bool {\n        let n = n % 6;\n\n        correct_count(|| (0..n).permutations(k))\n    }\n\n    fn permutations_size(a: Iter<i32>, k: usize) -> bool {\n        correct_size_hint(a.take(5).permutations(k))\n    }\n\n    fn permutations_k0_yields_once(n: usize) -> () {\n        let k = 0;\n        let expected: Vec<Vec<usize>> = vec![vec![]];\n        let actual = (0..n).permutations(k).collect_vec();\n\n        assert_eq!(expected, actual);\n    }\n}\n\nquickcheck! {\n    fn equal_dedup(a: Vec<i32>) -> bool {\n        let mut b = a.clone();\n        b.dedup();\n        itertools::equal(&b, a.iter().dedup())\n    }\n}\n\nquickcheck! {\n    fn equal_dedup_by(a: Vec<(i32, i32)>) -> bool {\n        let mut b = a.clone();\n        b.dedup_by(|x, y| x.0==y.0);\n        itertools::equal(&b, a.iter().dedup_by(|x, y| x.0==y.0))\n    }\n}\n\nquickcheck! {\n    fn size_dedup(a: Vec<i32>) -> bool {\n        correct_size_hint(a.iter().dedup())\n    }\n}\n\nquickcheck! {\n    fn size_dedup_by(a: Vec<(i32, i32)>) -> bool {\n        correct_size_hint(a.iter().dedup_by(|x, y| x.0==y.0))\n    }\n}\n\nquickcheck! {\n    fn exact_repeatn((n, x): (usize, i32)) -> bool {\n        let it = itertools::repeat_n(x, n);\n        exact_size(it)\n    }\n}\n\nquickcheck! {\n    fn size_put_back(a: Vec<u8>, x: Option<u8>) -> bool {\n        let mut it = put_back(a.into_iter());\n        match x {\n            Some(t) => it.put_back(t),\n            None => {}\n        }\n        correct_size_hint(it)\n    }\n}\n\nquickcheck! {\n    fn size_put_backn(a: Vec<u8>, b: Vec<u8>) -> bool {\n        let mut it = put_back_n(a.into_iter());\n        for elt in b {\n            it.put_back(elt)\n        }\n        correct_size_hint(it)\n    }\n}\n\nquickcheck! {\n    fn size_tee(a: Vec<u8>) -> bool {\n        let (mut t1, mut t2) = a.iter().tee();\n        t1.next();\n        t1.next();\n        t2.next();\n        exact_size(t1) && exact_size(t2)\n    }\n}\n\nquickcheck! {\n    fn size_tee_2(a: Vec<u8>) -> bool {\n        let (mut t1, mut t2) = a.iter().dedup().tee();\n        t1.next();\n        t1.next();\n        t2.next();\n        correct_size_hint(t1) && correct_size_hint(t2)\n    }\n}\n\nquickcheck! {\n    fn size_take_while_ref(a: Vec<u8>, stop: u8) -> bool {\n        correct_size_hint(a.iter().take_while_ref(|x| **x != stop))\n    }\n}\n\nquickcheck! {\n    fn equal_partition(a: Vec<i32>) -> bool {\n        let mut a = a;\n        let mut ap = a.clone();\n        let split_index = itertools::partition(&mut ap, |x| *x >= 0);\n        let parted = (0..split_index).all(|i| ap[i] >= 0) &&\n            (split_index..a.len()).all(|i| ap[i] < 0);\n\n        a.sort();\n        ap.sort();\n        parted && (a == ap)\n    }\n}\n\nquickcheck! {\n    fn size_combinations(it: Iter<i16>) -> bool {\n        correct_size_hint(it.tuple_combinations::<(_, _)>())\n    }\n}\n\nquickcheck! {\n    fn equal_combinations(it: Iter<i16>) -> bool {\n        let values = it.clone().collect_vec();\n        let mut cmb = it.tuple_combinations();\n        for i in 0..values.len() {\n            for j in i+1..values.len() {\n                let pair = (values[i], values[j]);\n                if pair != cmb.next().unwrap() {\n                    return false;\n                }\n            }\n        }\n        cmb.next() == None\n    }\n}\n\nquickcheck! {\n    fn size_pad_tail(it: Iter<i8>, pad: u8) -> bool {\n        correct_size_hint(it.clone().pad_using(pad as usize, |_| 0)) &&\n            correct_size_hint(it.dropping(1).rev().pad_using(pad as usize, |_| 0))\n    }\n}\n\nquickcheck! {\n    fn size_pad_tail2(it: Iter<i8, Exact>, pad: u8) -> bool {\n        exact_size(it.pad_using(pad as usize, |_| 0))\n    }\n}\n\nquickcheck! {\n    fn size_unique(it: Iter<i8>) -> bool {\n        correct_size_hint(it.unique())\n    }\n\n    fn count_unique(it: Vec<i8>, take_first: u8) -> () {\n        let answer = {\n            let mut v = it.clone();\n            v.sort(); v.dedup();\n            v.len()\n        };\n        let mut iter = cloned(&it).unique();\n        let first_count = (&mut iter).take(take_first as usize).count();\n        let rest_count = iter.count();\n        assert_eq!(answer, first_count + rest_count);\n    }\n}\n\nquickcheck! {\n    fn fuzz_group_by_lazy_1(it: Iter<u8>) -> bool {\n        let jt = it.clone();\n        let groups = it.group_by(|k| *k);\n        let res = itertools::equal(jt, groups.into_iter().flat_map(|(_, x)| x));\n        res\n    }\n}\n\nquickcheck! {\n    fn fuzz_group_by_lazy_2(data: Vec<u8>) -> bool {\n        let groups = data.iter().group_by(|k| *k / 10);\n        let res = itertools::equal(data.iter(), groups.into_iter().flat_map(|(_, x)| x));\n        res\n    }\n}\n\nquickcheck! {\n    fn fuzz_group_by_lazy_3(data: Vec<u8>) -> bool {\n        let grouper = data.iter().group_by(|k| *k / 10);\n        let groups = grouper.into_iter().collect_vec();\n        let res = itertools::equal(data.iter(), groups.into_iter().flat_map(|(_, x)| x));\n        res\n    }\n}\n\nquickcheck! {\n    fn fuzz_group_by_lazy_duo(data: Vec<u8>, order: Vec<(bool, bool)>) -> bool {\n        let grouper = data.iter().group_by(|k| *k / 3);\n        let mut groups1 = grouper.into_iter();\n        let mut groups2 = grouper.into_iter();\n        let mut elts = Vec::<&u8>::new();\n        let mut old_groups = Vec::new();\n\n        let tup1 = |(_, b)| b;\n        for &(ord, consume_now) in &order {\n            let iter = &mut [&mut groups1, &mut groups2][ord as usize];\n            match iter.next() {\n                Some((_, gr)) => if consume_now {\n                    for og in old_groups.drain(..) {\n                        elts.extend(og);\n                    }\n                    elts.extend(gr);\n                } else {\n                    old_groups.push(gr);\n                },\n                None => break,\n            }\n        }\n        for og in old_groups.drain(..) {\n            elts.extend(og);\n        }\n        for gr in groups1.map(&tup1) { elts.extend(gr); }\n        for gr in groups2.map(&tup1) { elts.extend(gr); }\n        itertools::assert_equal(&data, elts);\n        true\n    }\n}\n\nquickcheck! {\n    fn equal_chunks_lazy(a: Vec<u8>, size: u8) -> bool {\n        let mut size = size;\n        if size == 0 {\n            size += 1;\n        }\n        let chunks = a.iter().chunks(size as usize);\n        let it = a.chunks(size as usize);\n        for (a, b) in chunks.into_iter().zip(it) {\n            if !itertools::equal(a, b) {\n                return false;\n            }\n        }\n        true\n    }\n}\n\nquickcheck! {\n    fn equal_tuple_windows_1(a: Vec<u8>) -> bool {\n        let x = a.windows(1).map(|s| (&s[0], ));\n        let y = a.iter().tuple_windows::<(_,)>();\n        itertools::equal(x, y)\n    }\n\n    fn equal_tuple_windows_2(a: Vec<u8>) -> bool {\n        let x = a.windows(2).map(|s| (&s[0], &s[1]));\n        let y = a.iter().tuple_windows::<(_, _)>();\n        itertools::equal(x, y)\n    }\n\n    fn equal_tuple_windows_3(a: Vec<u8>) -> bool {\n        let x = a.windows(3).map(|s| (&s[0], &s[1], &s[2]));\n        let y = a.iter().tuple_windows::<(_, _, _)>();\n        itertools::equal(x, y)\n    }\n\n    fn equal_tuple_windows_4(a: Vec<u8>) -> bool {\n        let x = a.windows(4).map(|s| (&s[0], &s[1], &s[2], &s[3]));\n        let y = a.iter().tuple_windows::<(_, _, _, _)>();\n        itertools::equal(x, y)\n    }\n\n    fn equal_tuples_1(a: Vec<u8>) -> bool {\n        let x = a.chunks(1).map(|s| (&s[0], ));\n        let y = a.iter().tuples::<(_,)>();\n        itertools::equal(x, y)\n    }\n\n    fn equal_tuples_2(a: Vec<u8>) -> bool {\n        let x = a.chunks(2).filter(|s| s.len() == 2).map(|s| (&s[0], &s[1]));\n        let y = a.iter().tuples::<(_, _)>();\n        itertools::equal(x, y)\n    }\n\n    fn equal_tuples_3(a: Vec<u8>) -> bool {\n        let x = a.chunks(3).filter(|s| s.len() == 3).map(|s| (&s[0], &s[1], &s[2]));\n        let y = a.iter().tuples::<(_, _, _)>();\n        itertools::equal(x, y)\n    }\n\n    fn equal_tuples_4(a: Vec<u8>) -> bool {\n        let x = a.chunks(4).filter(|s| s.len() == 4).map(|s| (&s[0], &s[1], &s[2], &s[3]));\n        let y = a.iter().tuples::<(_, _, _, _)>();\n        itertools::equal(x, y)\n    }\n\n    fn exact_tuple_buffer(a: Vec<u8>) -> bool {\n        let mut iter = a.iter().tuples::<(_, _, _, _)>();\n        (&mut iter).last();\n        let buffer = iter.into_buffer();\n        assert_eq!(buffer.len(), a.len() % 4);\n        exact_size(buffer)\n    }\n}\n\n// with_position\nquickcheck! {\n    fn with_position_exact_size_1(a: Vec<u8>) -> bool {\n        exact_size_for_this(a.iter().with_position())\n    }\n    fn with_position_exact_size_2(a: Iter<u8, Exact>) -> bool {\n        exact_size_for_this(a.with_position())\n    }\n}\n\nquickcheck! {\n    fn correct_group_map_modulo_key(a: Vec<u8>, modulo: u8) -> () {\n        let modulo = if modulo == 0 { 1 } else { modulo }; // Avoid `% 0`\n        let count = a.len();\n        let lookup = a.into_iter().map(|i| (i % modulo, i)).into_group_map();\n\n        assert_eq!(lookup.values().flat_map(|vals| vals.iter()).count(), count);\n\n        for (&key, vals) in lookup.iter() {\n            assert!(vals.iter().all(|&val| val % modulo == key));\n        }\n    }\n}\n\n/// A peculiar type: Equality compares both tuple items, but ordering only the\n/// first item.  This is so we can check the stability property easily.\n#[derive(Clone, Debug, PartialEq, Eq)]\nstruct Val(u32, u32);\n\nimpl PartialOrd<Val> for Val {\n    fn partial_cmp(&self, other: &Val) -> Option<Ordering> {\n        self.0.partial_cmp(&other.0)\n    }\n}\n\nimpl Ord for Val {\n    fn cmp(&self, other: &Val) -> Ordering {\n        self.0.cmp(&other.0)\n    }\n}\n\nimpl qc::Arbitrary for Val {\n    fn arbitrary<G: qc::Gen>(g: &mut G) -> Self {\n        let (x, y) = <(u32, u32)>::arbitrary(g);\n        Val(x, y)\n    }\n    fn shrink(&self) -> Box<dyn Iterator<Item = Self>> {\n        Box::new((self.0, self.1).shrink().map(|(x, y)| Val(x, y)))\n    }\n}\n\nquickcheck! {\n    fn minmax(a: Vec<Val>) -> bool {\n        use itertools::MinMaxResult;\n\n\n        let minmax = a.iter().minmax();\n        let expected = match a.len() {\n            0 => MinMaxResult::NoElements,\n            1 => MinMaxResult::OneElement(&a[0]),\n            _ => MinMaxResult::MinMax(a.iter().min().unwrap(),\n                                      a.iter().max().unwrap()),\n        };\n        minmax == expected\n    }\n}\n\nquickcheck! {\n    fn minmax_f64(a: Vec<f64>) -> TestResult {\n        use itertools::MinMaxResult;\n\n        if a.iter().any(|x| x.is_nan()) {\n            return TestResult::discard();\n        }\n\n        let min = cloned(&a).fold1(f64::min);\n        let max = cloned(&a).fold1(f64::max);\n\n        let minmax = cloned(&a).minmax();\n        let expected = match a.len() {\n            0 => MinMaxResult::NoElements,\n            1 => MinMaxResult::OneElement(min.unwrap()),\n            _ => MinMaxResult::MinMax(min.unwrap(), max.unwrap()),\n        };\n        TestResult::from_bool(minmax == expected)\n    }\n}\n\nquickcheck! {\n    #[allow(deprecated)]\n    fn tree_fold1_f64(mut a: Vec<f64>) -> TestResult {\n        fn collapse_adjacent<F>(x: Vec<f64>, mut f: F) -> Vec<f64>\n            where F: FnMut(f64, f64) -> f64\n        {\n            let mut out = Vec::new();\n            for i in (0..x.len()).step(2) {\n                if i == x.len()-1 {\n                    out.push(x[i])\n                } else {\n                    out.push(f(x[i], x[i+1]));\n                }\n            }\n            out\n        }\n\n        if a.iter().any(|x| x.is_nan()) {\n            return TestResult::discard();\n        }\n\n        let actual = a.iter().cloned().tree_fold1(f64::atan2);\n\n        while a.len() > 1 {\n            a = collapse_adjacent(a, f64::atan2);\n        }\n        let expected = a.pop();\n\n        TestResult::from_bool(actual == expected)\n    }\n}\n\nquickcheck! {\n    fn exactly_one_i32(a: Vec<i32>) -> TestResult {\n        let ret = a.iter().cloned().exactly_one();\n        match a.len() {\n            1 => TestResult::from_bool(ret.unwrap() == a[0]),\n            _ => TestResult::from_bool(ret.unwrap_err().eq(a.iter().cloned())),\n        }\n    }\n}\n","traces":[{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":136,"address":[5414000,5413097,5413335,5414039,5413056,5413296,5412871,5413799,5412393,5412832,5413520,5412352,5413559,5413760,5414240,5412592,5412633,5414281],"length":1,"stats":{"Line":9},"fn_name":"next<i16,quick::Inexact>"},{"line":138,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":149,"address":[5414864,5414736,5414992,5415248,5414608,5415120,5414480,5415376],"length":1,"stats":{"Line":8},"fn_name":"size_hint<i8,quick::Exact>"},{"line":151,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":161,"address":[5415504,5415513],"length":1,"stats":{"Line":2},"fn_name":"next_back<i8,quick::Inexact>"},{"line":172,"address":[5415552,5416238,5415807,5416014,5416400,5416447,5416848,5416894,5417310,5417072,5416624,5417280,5415760,5415984,5417103,5416192,5416670,5415583],"length":1,"stats":{"Line":9},"fn_name":"arbitrary<u16,quick::Exact,quickcheck::arbitrary::StdThreadGen>"},{"line":174,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":177,"address":[5417488,5419711,5419024,5419648,5418752,5419065,5417856,5417549,5420079,5418189,5420016,5418795,5419280,5418496,5419341,5418537,5417899,5418128],"length":1,"stats":{"Line":0},"fn_name":"shrink<i32,quick::Inexact>"},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[5424416,5424502],"length":1,"stats":{"Line":1},"fn_name":"correct_count<itertools::permutations::Permutations<core::ops::range::Range<usize>>,closure-0>"},{"line":254,"address":[5424542,5424439,5424525,5426227],"length":1,"stats":{"Line":3},"fn_name":null},{"line":256,"address":[5425351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[5424617],"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[5425049,5424632,5426393,5424906],"length":1,"stats":{"Line":2},"fn_name":null},{"line":260,"address":[5424948],"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[5424998],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[5425058,5424896],"length":1,"stats":{"Line":2},"fn_name":null},{"line":269,"address":[5425173],"length":1,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[5426445,5425364,5425143],"length":1,"stats":{"Line":2},"fn_name":null},{"line":274,"address":[5425748,5425586,5425400,5425621],"length":1,"stats":{"Line":3},"fn_name":null},{"line":275,"address":[5426495,5425692,5426525],"length":1,"stats":{"Line":1},"fn_name":null},{"line":276,"address":[5425730],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[5425753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[5426156],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[5426209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":286,"address":[5427897,5433113,5427856,5434400,5435769,5442249,5451408,5440953,5457961,5429152,5455321,5431785,5450105,5446185,5437024,5433072,5426569,5448768,5454025,5426528,5437065,5439584,5451449,5447529,5431744,5455280,5435728,5447488,5444816,5456633,5457920,5453984,5446144,5434450,5439625,5438350,5448809,5452688,5429193,5430505,5456592,5442208,5438304,5444857,5430464,5450064,5443577,5440912,5452729,5443536],"length":1,"stats":{"Line":25},"fn_name":"correct_size_hint<itertools::ziptuple::Zip<(itertools::rciter_impl::RcIter<quick::Iter<i16, quick::Inexact>>, itertools::rciter_impl::RcIter<quick::Iter<i16, quick::Inexact>>, quick::Iter<i16, quick::Inexact>)>>"},{"line":288,"address":[5457943,5430487,5427879,5446167,5447511,5437047,5451431,5450087,5452711,5435751,5440935,5455303,5442231,5431767,5426551,5439607,5444839,5448791,5438343,5454007,5434443,5433095,5456615,5429175,5443559],"length":1,"stats":{"Line":25},"fn_name":null},{"line":289,"address":[5446200,5448878,5439640,5437134,5443592,5443646,5439475,5455390,5433182,5429262,5434296,5433128,5432969,5451292,5451518,5436914,5447372,5430357,5431800,5427966,5426651,5450120,5459106,5434465,5427745,5440968,5447544,5446040,5440808,5447598,5448824,5457816,5431867,5438202,5452586,5452798,5456715,5426584,5454040,5430574,5446267,5430520,5431638,5435614,5442318,5448666,5441022,5429041,5438365,5452744,5456485,5443432,5429208,5450187,5456648,5444939,5449954,5444710,5427912,5439707,5435838,5435784,5434532,5442264,5451464,5438419,5444872,5453873,5455336,5457976,5458030,5454094,5437080,5455170,5442098],"length":1,"stats":{"Line":50},"fn_name":null},{"line":290,"address":[5446274,5426658,5442325,5435845,5443653,5433189,5431874,5437141,5447605,5439714,5444946,5438426,5448885,5450194,5451525,5454101,5455397,5458037,5430581,5427973,5452805,5434539,5441029,5429269,5456722],"length":1,"stats":{"Line":25},"fn_name":null},{"line":291,"address":[5429349,5456950,5430636,5438643,5447826,5434594,5439769,5433456,5450434,5442592,5446329,5441258,5430798,5433269,5428201,5435900,5431954,5431929,5429324,5442405,5437362,5439942,5443708,5438481,5448965,5450282,5439794,5429517,5454330,5428028,5426879,5451580,5433244,5426713,5438506,5458266,5455645,5458092,5451746,5452860,5454156,5453033,5450249,5447685,5430661,5432103,5434756,5435925,5448940,5445174,5456777,5446514,5443870,5441109,5455452,5445001,5452885,5437221,5454181,5441084,5443733,5446362,5436074,5445026,5447660,5449114,5434619,5458117,5451605,5428053,5437196,5426738,5442380,5455477,5456802],"length":1,"stats":{"Line":75},"fn_name":null},{"line":292,"address":[5434696,5437302,5449054,5441198,5428141,5436014,5447766,5450348,5451686,5452973,5442532,5443810,5426819,5458206,5432043,5430738,5438583,5445114,5439882,5455585,5446428,5429457,5433396,5456890,5454270],"length":1,"stats":{"Line":25},"fn_name":null},{"line":295,"address":[5426892,5447811,5451759,5439955,5458279,5437347,5458251,5429530,5455658,5436087,5453018,5429502,5450447,5454343,5456935,5456963,5442605,5441271,5443855,5428186,5433441,5446527,5434769,5443883,5434741,5441243,5445159,5445187,5453046,5449099,5432088,5442577,5447839,5438656,5449127,5455630,5430783,5439927,5450419,5428214,5432116,5433469,5437375,5446499,5438628,5454315,5426864,5436059,5430811,5451731],"length":1,"stats":{"Line":50},"fn_name":null},{"line":298,"address":[5455674,5449143,5451908,5458704,5454359,5446670,5443899,5436236,5455807,5457112,5443030,5449552,5450866,5458295,5442621,5426908,5458428,5433894,5448264,5441420,5429546,5428230,5429679,5437391,5451775,5430960,5453062,5436103,5447988,5428639,5439075,5453195,5427041,5456979,5457388,5433485,5430827,5446543,5449276,5445336,5441287,5447855,5450463,5453471,5454492,5429955,5436512,5431236,5444032,5432265,5435188,5445612,5427317,5438799,5439971,5452184,5445203,5434912,5446946,5456083,5437800,5440380,5437524,5433618,5441696,5432132,5450590,5440104,5444308,5438672,5432541,5442754,5454768,5428363,5434785],"length":1,"stats":{"Line":50},"fn_name":null},{"line":299,"address":[5436966,5432326,5444093,5451344,5445397,5428424,5450651,5452638,5436297,5429740,5433021,5438860,5455222,5441481,5456537,5435666,5437585,5442150,5451969,5457173,5448718,5458489,5427797,5440860,5444762,5431021,5438254,5459158,5455868,5430409,5427102,5434973,5446731,5433679,5447424,5457868,5439527,5429093,5449337,5453925,5434348,5450006,5440165,5443484,5431690,5442815,5454553,5446092,5448049,5453256],"length":1,"stats":{"Line":25},"fn_name":null},{"line":300,"address":[5435082,5437761,5445453,5455924,5436353,5444202,5438916,5433735,5442991,5446907,5455977,5427158,5428480,5429796,5433788,5450707,5439036,5442924,5448105,5452025,5444269,5431077,5452145,5436406,5441537,5429849,5445573,5453432,5458545,5454729,5452078,5436473,5457349,5442871,5450760,5458665,5444149,5427211,5435149,5445506,5449393,5453312,5440274,5437641,5446840,5433855,5448225,5428600,5432502,5440221,5456044,5450827,5454662,5457229,5437694,5457282,5441657,5446787,5429916,5431197,5458598,5435029,5428533,5432435,5449446,5438969,5440341,5441590,5432382,5427278,5449513,5431130,5448158,5453365,5454609],"length":1,"stats":{"Line":75},"fn_name":null},{"line":301,"address":[5431213,5433871,5452055,5445589,5448170,5448241,5429826,5446923,5431107,5453342,5428510,5436489,5437671,5448135,5428545,5438946,5458681,5427294,5433765,5432412,5428616,5444285,5438981,5431142,5450737,5435165,5450772,5452161,5454639,5457294,5458575,5435059,5441602,5429932,5441673,5442936,5444214,5449458,5432518,5427188,5429861,5436383,5437706,5437777,5442901,5444179,5446817,5457365,5439052,5457259,5449423,5449529,5452090,5450843,5435094,5440251,5441567,5454745,5440357,5453448,5443007,5455989,5458610,5436418,5427223,5440286,5454674,5432447,5445483,5456060,5445518,5453377,5446852,5455954,5433800],"length":1,"stats":{"Line":50},"fn_name":null},{"line":303,"address":[5429960,5428644,5444313,5450871,5440385,5445617,5449557,5454773,5453476,5431241,5432546,5437805,5446951,5433899,5435193,5452189,5456088,5441701,5443035,5457393,5458709,5448269,5436517,5439080,5427322],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[5440715,5436847,5427652,5435521,5442031,5451199,5445947,5455103,5434229,5428974,5431571,5459039,5448599,5452519,5432876,5456418,5439408,5430290,5443365,5444643,5447279,5449887,5453806,5457723,5438135],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[5453169,5458402,5433592,5428337,5454466,5430934,5432239,5440078,5434886,5455781,5444006,5436210,5429653,5457086,5437498,5442728,5446644,5449250,5438773,5447962,5450564,5427015,5451882,5441394,5445310],"length":1,"stats":{"Line":25},"fn_name":null},{"line":311,"address":[5462112,5463552,5460672,5461440,5464294,5465008,5462144,5459216,5459248,5465040,5461408,5463584,5465712,5459920,5462848,5462816,5465744,5459952,5460704,5464256],"length":1,"stats":{"Line":10},"fn_name":"exact_size<itertools::repeatn::RepeatN<i32>>"},{"line":313,"address":[5459967,5462833,5460689,5464309,5462863,5465759,5459937,5464287,5465025,5460719,5462129,5459233,5463569,5463599,5465055,5461425,5461455,5462159,5459263,5465729],"length":1,"stats":{"Line":20},"fn_name":null},{"line":314,"address":[5459348,5465140,5462893,5462958,5459293,5462192,5464345,5465847,5460063,5459356,5462255,5464418,5465855,5465148,5460749,5465792,5461548,5460055,5462247,5461485,5460000,5462966,5463629,5463692,5464410,5460814,5463684,5461540,5465085,5460822],"length":1,"stats":{"Line":20},"fn_name":null},{"line":315,"address":[5459387,5461546,5465179,5463007,5464060,5460820,5461579,5462964,5460476,5461911,5463690,5464791,5463345,5462286,5464416,5459354,5462622,5465886,5462253,5461201,5466222,5460061,5465146,5460863,5463723,5465853,5460094,5465517,5459718,5464459],"length":1,"stats":{"Line":30},"fn_name":null},{"line":316,"address":[5461650,5459457,5463084,5460215,5460940,5465256,5462361,5463799,5465961,5464530],"length":1,"stats":{"Line":10},"fn_name":null},{"line":317,"address":[5463210,5464747,5462571,5464740,5463925,5462487,5466171,5459667,5462578,5465311,5463854,5466382,5460636,5461860,5460425,5459512,5460995,5461157,5464656,5464961,5465382,5465677,5459878,5461066,5459583,5460341,5461150,5461705,5461371,5461776,5461867,5462071,5464585,5465466,5466016,5459674,5465473,5466087,5460432,5462782,5463294,5464009,5466178,5464016,5463139,5464220,5463301,5460270,5462416,5463515],"length":1,"stats":{"Line":20},"fn_name":null},{"line":318,"address":[5463220,5463935,5461076,5459593,5462497,5464666,5465392,5461786,5466097,5460351],"length":1,"stats":{"Line":10},"fn_name":null},{"line":319,"address":[5463945,5463230,5459603,5460361,5461086,5462507,5461796,5465402,5464676,5466107],"length":1,"stats":{"Line":10},"fn_name":null},{"line":320,"address":[5459691,5462522,5464756,5459683,5465417,5466187,5464025,5465482,5460441,5460449,5462587,5460376,5461884,5464033,5464764,5462595,5461811,5459618,5466122,5463310,5461876,5463960,5463318,5461101,5464691,5461166,5461174,5463245,5466195,5465490],"length":1,"stats":{"Line":20},"fn_name":null},{"line":322,"address":[5461194,5462615,5465522,5461916,5462627,5461904,5466215,5464053,5463350,5459723,5459711,5463338,5461206,5464065,5465510,5466227,5464784,5464796,5460469,5460481],"length":1,"stats":{"Line":20},"fn_name":null},{"line":323,"address":[5459832,5466336,5464915,5459771,5462736,5465570,5465631,5460529,5463469,5464174,5464113,5460590,5461964,5461254,5464844,5462675,5462025,5463398,5461325,5466275],"length":1,"stats":{"Line":20},"fn_name":null},{"line":327,"address":[5467888,5468576,5468608,5467152,5467184,5467856,5466416,5466448],"length":1,"stats":{"Line":4},"fn_name":"exact_size_for_this<itertools::with_position::WithPosition<core::slice::Iter<u8>>>"},{"line":329,"address":[5467169,5467903,5467873,5468593,5466463,5466433,5468623,5467199],"length":1,"stats":{"Line":8},"fn_name":null},{"line":330,"address":[5466496,5467229,5468708,5468716,5467284,5466551,5467996,5466559,5467292,5467988,5468653,5467933],"length":1,"stats":{"Line":8},"fn_name":null},{"line":331,"address":[5468747,5467323,5469079,5468027,5468714,5468381,5467290,5466557,5467994,5467661,5466590,5466950],"length":1,"stats":{"Line":12},"fn_name":null},{"line":332,"address":[5468120,5466689,5468818,5467400],"length":1,"stats":{"Line":4},"fn_name":null},{"line":333,"address":[5469028,5466815,5466899,5466906,5467821,5468246,5468873,5469239,5468944,5467110,5468337,5466744,5468330,5468541,5468175,5467617,5467526,5467610,5469035,5467455],"length":1,"stats":{"Line":8},"fn_name":null},{"line":334,"address":[5467536,5468954,5468256,5466825],"length":1,"stats":{"Line":4},"fn_name":null},{"line":335,"address":[5466835,5467546,5468964,5468266],"length":1,"stats":{"Line":4},"fn_name":null},{"line":336,"address":[5466915,5469052,5468354,5468281,5466923,5466850,5467626,5468979,5469044,5468346,5467634,5467561],"length":1,"stats":{"Line":8},"fn_name":null},{"line":338,"address":[5469072,5468386,5467666,5466943,5469084,5466955,5467654,5468374],"length":1,"stats":{"Line":8},"fn_name":null},{"line":339,"address":[5467064,5469193,5467003,5467714,5467775,5469132,5468434,5468495],"length":1,"stats":{"Line":8},"fn_name":null},{"line":369,"address":[5476965,5478688,5478720,5478437,5479712,5480368,5481269,5482037,5478304,5477088,5479952,5482512,5483925,5479157,5477093,5478213,5479056,5482544,5482480,5477472,5478997,5475413,5478656,5479024,5477029,5482933,5477024,5477760,5476389,5477861,5478240,5477792,5475856,5477056,5478725,5476928,5479237,5479653,5478544,5475408,5480885,5479120,5481392,5481664,5477408,5477824,5476357,5478373,5478912,5480208,5480373,5480576,5479061,5479957,5482576,5476933,5477120,5483045,5478432,5479029,5480240,5478309,5476656,5479456,5482517,5479493,5475888,5479152,5477664,5478693,5479584,5477413,5481669,5479232,5475349,5477061,5477669,5482581,5483920,5478992,5478176,5478917,5479429,5482032,5478208,5478549,5478336,5475861,5478277,5479424,5480245,5480213,5477125,5481397,5476352,5478752,5481264,5478368,5479680,5479589,5482965,5478400,5477445,5477797,5477573,5478272,5483040,5475893,5482960,5479648,5480581,5477856,5478880,5480085,5480880,5475376,5479824,5479488,5478181,5482928,5479093,5475381,5479125,5477765,5475344,5479685,5478661,5478405,5476992,5480080,5477477,5476384,5479461,5482485,5478885,5482549,5476997,5477440,5478245,5479829,5478757,5477568,5478512,5477829,5478341,5478517,5479088,5476661,5479717,5476960],"length":1,"stats":{"Line":225},"fn_name":"{{closure}}"},{"line":370,"address":[5816024,5839712,5832736,5837888,5839040,5846080,5848048,5815984,5821616,5823840,5809088,5822128,5837792,5816240,5813315,5837376,5825360,5851696,5845040,5846140,5831104,5835578,5808736,5845744,5820637,5812640,5833633,5828416,5823104,5812976,5835520,5821296,5833088,5850816,5823248,5833272,5808592,5832938,5844704,5848078,5843402,5834736,5846816,5852561,5843360,5839392,5847279,5848320,5844764,5832509,5819917,5836160,5851813,5833200,5815344,5845392,5835296,5848224,5810400,5835331,5837956,5813728,5819024,5818397,5814144,5831216,5832480,5839072,5844428,5813809,5813280,5832912,5815488,5836201,5831392,5814225,5836064,5844368,5819085,5834816,5845100,5846448,5834192,5823504,5845452,5833536,5850224,5837680,5852464,5825606,5828531,5840272,5832762,5845804,5810512,5814560,5819856,5832208,5824483,5848375,5818336,5840410,5847200,5823376,5816916,5823894,5822672,5820576,5824448,5831469,5839328,5809164,5839784,5850301,5816816,5810651,5821649,5834272,5846508,5846876,5814612,5823535,5823728,5825536,5832237,5850923],"length":1,"stats":{"Line":75},"fn_name":"prop"},{"line":373,"address":[5844689,5825345,5814545,5820561,5823089,5808577,5819009,5815473,5823489,5816225,5828401,5823361,5815329,5813265,5845377,5846801,5810497,5848033,5823825,5852449,5822657,5833073,5833185,5840257,5844353,5848305,5834721,5835281,5839025,5847185,5816801,5839313,5832465,5833521,5834177,5814129,5815969,5845729,5812625,5843345,5832721,5836049,5837361,5818321,5839697,5837873,5850209,5848209,5832193,5837665,5813713,5851681,5831377,5808721,5825521,5850801,5821281,5809073,5832897,5821601,5823713,5836145,5835505,5846065,5831201,5819841,5837777,5831089,5845025,5812961,5822113,5823233,5824433,5810385,5846433],"length":1,"stats":{"Line":75},"fn_name":null},{"line":392,"address":[5808599],"length":1,"stats":{"Line":1},"fn_name":null},{"line":395,"address":[5808743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":403,"address":[5809103],"length":1,"stats":{"Line":1},"fn_name":null},{"line":404,"address":[5809179],"length":1,"stats":{"Line":1},"fn_name":null},{"line":405,"address":[5809216],"length":1,"stats":{"Line":1},"fn_name":null},{"line":406,"address":[5475632,5475440,5475504,5475521,5475649,5475454],"length":1,"stats":{"Line":7},"fn_name":"{{closure}}"},{"line":407,"address":[5809533,5809391],"length":1,"stats":{"Line":2},"fn_name":null},{"line":408,"address":[5809679],"length":1,"stats":{"Line":1},"fn_name":null},{"line":410,"address":[5809702],"length":1,"stats":{"Line":1},"fn_name":null},{"line":411,"address":[5809776,5809887],"length":1,"stats":{"Line":2},"fn_name":null},{"line":412,"address":[5475801,5475760],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":414,"address":[5810008,5809897],"length":1,"stats":{"Line":1},"fn_name":null},{"line":418,"address":[5810404],"length":1,"stats":{"Line":1},"fn_name":null},{"line":422,"address":[5810527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":426,"address":[5810617],"length":1,"stats":{"Line":1},"fn_name":null},{"line":427,"address":[5810666],"length":1,"stats":{"Line":1},"fn_name":null},{"line":428,"address":[5810718],"length":1,"stats":{"Line":1},"fn_name":null},{"line":429,"address":[5810786],"length":1,"stats":{"Line":1},"fn_name":null},{"line":430,"address":[5476064,5476048,5475920,5475936,5476176,5476160],"length":1,"stats":{"Line":7},"fn_name":"{{closure}}"},{"line":431,"address":[5811024],"length":1,"stats":{"Line":1},"fn_name":null},{"line":432,"address":[5811070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":434,"address":[5811093],"length":1,"stats":{"Line":1},"fn_name":null},{"line":435,"address":[5811290,5811173],"length":1,"stats":{"Line":2},"fn_name":null},{"line":436,"address":[5476297,5476288],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":438,"address":[5811471,5811300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":440,"address":[5811823,5811405],"length":1,"stats":{"Line":2},"fn_name":null},{"line":445,"address":[5812670],"length":1,"stats":{"Line":1},"fn_name":null},{"line":446,"address":[5812675],"length":1,"stats":{"Line":1},"fn_name":null},{"line":447,"address":[5812685,5812926,5812956],"length":1,"stats":{"Line":1},"fn_name":null},{"line":449,"address":[5812723],"length":1,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[5812920,5812769,5812878],"length":1,"stats":{"Line":3},"fn_name":null},{"line":451,"address":[5812902,5812823],"length":1,"stats":{"Line":2},"fn_name":null},{"line":456,"address":[5812991],"length":1,"stats":{"Line":1},"fn_name":null},{"line":457,"address":[5812996],"length":1,"stats":{"Line":1},"fn_name":null},{"line":458,"address":[5813259,5813011,5813229],"length":1,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[5813049],"length":1,"stats":{"Line":1},"fn_name":null},{"line":461,"address":[5476416],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":462,"address":[5476430,5476581],"length":1,"stats":{"Line":1},"fn_name":null},{"line":463,"address":[5476641,5476512,5476611],"length":1,"stats":{"Line":1},"fn_name":null},{"line":470,"address":[5813295],"length":1,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[5813330,5813300,5813370],"length":1,"stats":{"Line":3},"fn_name":null},{"line":472,"address":[5813646,5813332],"length":1,"stats":{"Line":1},"fn_name":null},{"line":474,"address":[5813385],"length":1,"stats":{"Line":1},"fn_name":null},{"line":475,"address":[5476688],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":476,"address":[5476853,5476702],"length":1,"stats":{"Line":1},"fn_name":null},{"line":477,"address":[5476883,5476913,5476784],"length":1,"stats":{"Line":1},"fn_name":null},{"line":483,"address":[5813758],"length":1,"stats":{"Line":1},"fn_name":null},{"line":485,"address":[5814004,5813824,5814036],"length":1,"stats":{"Line":2},"fn_name":null},{"line":486,"address":[5814029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":488,"address":[5813931],"length":1,"stats":{"Line":1},"fn_name":null},{"line":492,"address":[5814174],"length":1,"stats":{"Line":1},"fn_name":null},{"line":494,"address":[5814407,5814240,5814454],"length":1,"stats":{"Line":2},"fn_name":null},{"line":495,"address":[5814444],"length":1,"stats":{"Line":1},"fn_name":null},{"line":497,"address":[5814347],"length":1,"stats":{"Line":1},"fn_name":null},{"line":501,"address":[5814583],"length":1,"stats":{"Line":1},"fn_name":null},{"line":502,"address":[5814643],"length":1,"stats":{"Line":1},"fn_name":null},{"line":503,"address":[5814739,5814690],"length":1,"stats":{"Line":2},"fn_name":null},{"line":504,"address":[5814770],"length":1,"stats":{"Line":1},"fn_name":null},{"line":505,"address":[5814820],"length":1,"stats":{"Line":1},"fn_name":null},{"line":506,"address":[5814835,5814912],"length":1,"stats":{"Line":2},"fn_name":null},{"line":507,"address":[5814962],"length":1,"stats":{"Line":1},"fn_name":null},{"line":508,"address":[5815004],"length":1,"stats":{"Line":1},"fn_name":null},{"line":511,"address":[5815351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":514,"address":[5815540],"length":1,"stats":{"Line":1},"fn_name":null},{"line":515,"address":[5815586,5815966,5815793,5815953],"length":1,"stats":{"Line":3},"fn_name":null},{"line":516,"address":[5815932,5815663],"length":1,"stats":{"Line":2},"fn_name":null},{"line":519,"address":[5815991,5816039],"length":1,"stats":{"Line":2},"fn_name":null},{"line":520,"address":[5816059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":524,"address":[5816292],"length":1,"stats":{"Line":1},"fn_name":null},{"line":525,"address":[5477193],"length":1,"stats":{"Line":4},"fn_name":null},{"line":526,"address":[5477321],"length":1,"stats":{"Line":3},"fn_name":null},{"line":530,"address":[5816823,5816931],"length":1,"stats":{"Line":2},"fn_name":null},{"line":531,"address":[5817010,5816955],"length":1,"stats":{"Line":2},"fn_name":null},{"line":532,"address":[5817034],"length":1,"stats":{"Line":1},"fn_name":null},{"line":533,"address":[5817057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":534,"address":[5817111],"length":1,"stats":{"Line":1},"fn_name":null},{"line":535,"address":[5817165],"length":1,"stats":{"Line":1},"fn_name":null},{"line":536,"address":[5817221],"length":1,"stats":{"Line":1},"fn_name":null},{"line":537,"address":[5817244],"length":1,"stats":{"Line":1},"fn_name":null},{"line":538,"address":[5817352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":539,"address":[5817460],"length":1,"stats":{"Line":1},"fn_name":null},{"line":540,"address":[5817494,5818134],"length":1,"stats":{"Line":1},"fn_name":null},{"line":547,"address":[5818343,5818571,5818503,5818417],"length":1,"stats":{"Line":3},"fn_name":null},{"line":548,"address":[5818534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":550,"address":[5818486,5818591],"length":1,"stats":{"Line":2},"fn_name":null},{"line":551,"address":[5818611],"length":1,"stats":{"Line":1},"fn_name":null},{"line":552,"address":[5818915,5818645],"length":1,"stats":{"Line":1},"fn_name":null},{"line":558,"address":[5819031,5819105,5819206,5819321],"length":1,"stats":{"Line":3},"fn_name":null},{"line":559,"address":[5819240],"length":1,"stats":{"Line":1},"fn_name":null},{"line":560,"address":[5819287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":562,"address":[5819189,5819344],"length":1,"stats":{"Line":2},"fn_name":null},{"line":563,"address":[5819367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":564,"address":[5819409],"length":1,"stats":{"Line":1},"fn_name":null},{"line":565,"address":[5819443,5819600],"length":1,"stats":{"Line":2},"fn_name":null},{"line":566,"address":[5477523,5477504],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":572,"address":[5819863,5819937,5820023,5820091],"length":1,"stats":{"Line":3},"fn_name":null},{"line":573,"address":[5820054],"length":1,"stats":{"Line":1},"fn_name":null},{"line":575,"address":[5820006,5820111],"length":1,"stats":{"Line":2},"fn_name":null},{"line":576,"address":[5820131],"length":1,"stats":{"Line":1},"fn_name":null},{"line":577,"address":[5820319,5820165],"length":1,"stats":{"Line":2},"fn_name":null},{"line":578,"address":[5477619,5477600],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":584,"address":[5820583,5820811,5820657,5820743],"length":1,"stats":{"Line":3},"fn_name":null},{"line":585,"address":[5820774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":587,"address":[5820726,5820831],"length":1,"stats":{"Line":2},"fn_name":null},{"line":588,"address":[5820851],"length":1,"stats":{"Line":1},"fn_name":null},{"line":589,"address":[5820885,5821039],"length":1,"stats":{"Line":2},"fn_name":null},{"line":590,"address":[5477696,5477715],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":594,"address":[5821303],"length":1,"stats":{"Line":1},"fn_name":null},{"line":597,"address":[5821711,5821623,5821664],"length":1,"stats":{"Line":3},"fn_name":null},{"line":598,"address":[5821750],"length":1,"stats":{"Line":1},"fn_name":null},{"line":599,"address":[5821830],"length":1,"stats":{"Line":1},"fn_name":null},{"line":600,"address":[5821943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":603,"address":[5822165],"length":1,"stats":{"Line":1},"fn_name":null},{"line":604,"address":[5822211],"length":1,"stats":{"Line":1},"fn_name":null},{"line":605,"address":[5822461,5822411,5822635,5822257,5822601,5822648],"length":1,"stats":{"Line":5},"fn_name":null},{"line":606,"address":[5822425,5822527],"length":1,"stats":{"Line":2},"fn_name":null},{"line":607,"address":[5822334,5822614],"length":1,"stats":{"Line":2},"fn_name":null},{"line":610,"address":[5822679],"length":1,"stats":{"Line":1},"fn_name":null},{"line":611,"address":[5822751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":612,"address":[5822816,5823067,5822942,5823080],"length":1,"stats":{"Line":3},"fn_name":null},{"line":613,"address":[5477888,5477991,5477967],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":614,"address":[5477930,5477969],"length":1,"stats":{"Line":2},"fn_name":null},{"line":615,"address":[5477993],"length":1,"stats":{"Line":1},"fn_name":null},{"line":616,"address":[5477960],"length":1,"stats":{"Line":1},"fn_name":null},{"line":620,"address":[5823038,5822850],"length":1,"stats":{"Line":2},"fn_name":null},{"line":621,"address":[5478032,5478111,5478135],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":622,"address":[5478113,5478074],"length":1,"stats":{"Line":2},"fn_name":null},{"line":623,"address":[5478137],"length":1,"stats":{"Line":1},"fn_name":null},{"line":624,"address":[5478104],"length":1,"stats":{"Line":1},"fn_name":null},{"line":629,"address":[5823111],"length":1,"stats":{"Line":1},"fn_name":null},{"line":632,"address":[5823282],"length":1,"stats":{"Line":1},"fn_name":null},{"line":635,"address":[5823380],"length":1,"stats":{"Line":1},"fn_name":null},{"line":638,"address":[5823518,5823557,5823618],"length":1,"stats":{"Line":3},"fn_name":null},{"line":641,"address":[5823737],"length":1,"stats":{"Line":1},"fn_name":null},{"line":644,"address":[5823854],"length":1,"stats":{"Line":1},"fn_name":null},{"line":645,"address":[5823859],"length":1,"stats":{"Line":1},"fn_name":null},{"line":646,"address":[5824360,5823909,5824171,5823877,5823963],"length":1,"stats":{"Line":4},"fn_name":null},{"line":647,"address":[5824201,5824253],"length":1,"stats":{"Line":2},"fn_name":null},{"line":648,"address":[5824249,5824255],"length":1,"stats":{"Line":1},"fn_name":null},{"line":650,"address":[5824212,5824301,5824331],"length":1,"stats":{"Line":2},"fn_name":null},{"line":651,"address":[5824385,5824305,5824343],"length":1,"stats":{"Line":2},"fn_name":null},{"line":653,"address":[5824348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":655,"address":[5824153],"length":1,"stats":{"Line":1},"fn_name":null},{"line":659,"address":[5824455],"length":1,"stats":{"Line":1},"fn_name":null},{"line":660,"address":[5824980,5824717,5824498,5824555],"length":1,"stats":{"Line":3},"fn_name":null},{"line":661,"address":[5825304,5825068,5824783,5824985],"length":1,"stats":{"Line":2},"fn_name":null},{"line":662,"address":[5825024],"length":1,"stats":{"Line":1},"fn_name":null},{"line":665,"address":[5824688,5825073],"length":1,"stats":{"Line":2},"fn_name":null},{"line":669,"address":[5825364],"length":1,"stats":{"Line":1},"fn_name":null},{"line":670,"address":[5825412],"length":1,"stats":{"Line":1},"fn_name":null},{"line":679,"address":[5825551,5825621],"length":1,"stats":{"Line":2},"fn_name":null},{"line":680,"address":[5825669],"length":1,"stats":{"Line":1},"fn_name":null},{"line":682,"address":[5825825,5825881],"length":1,"stats":{"Line":2},"fn_name":null},{"line":684,"address":[5825897],"length":1,"stats":{"Line":1},"fn_name":null},{"line":686,"address":[5826074,5828078,5825904,5826052],"length":1,"stats":{"Line":4},"fn_name":null},{"line":687,"address":[5826482,5826320,5826271],"length":1,"stats":{"Line":2},"fn_name":null},{"line":689,"address":[5478464,5478478],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":690,"address":[5827031,5826991],"length":1,"stats":{"Line":1},"fn_name":null},{"line":694,"address":[5827243,5827005],"length":1,"stats":{"Line":2},"fn_name":null},{"line":695,"address":[5827305],"length":1,"stats":{"Line":1},"fn_name":null},{"line":697,"address":[5827377,5827528],"length":1,"stats":{"Line":1},"fn_name":null},{"line":700,"address":[5827859,5827898,5827518],"length":1,"stats":{"Line":2},"fn_name":null},{"line":705,"address":[5828439],"length":1,"stats":{"Line":1},"fn_name":null},{"line":706,"address":[5828470],"length":1,"stats":{"Line":1},"fn_name":null},{"line":708,"address":[5828504],"length":1,"stats":{"Line":1},"fn_name":null},{"line":709,"address":[5828562],"length":1,"stats":{"Line":1},"fn_name":null},{"line":711,"address":[5828584],"length":1,"stats":{"Line":1},"fn_name":null},{"line":712,"address":[5830929,5828642,5828775],"length":1,"stats":{"Line":2},"fn_name":null},{"line":714,"address":[5828810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":716,"address":[5828893,5828977],"length":1,"stats":{"Line":1},"fn_name":null},{"line":717,"address":[5828979,5828919],"length":1,"stats":{"Line":2},"fn_name":null},{"line":718,"address":[5829203],"length":1,"stats":{"Line":0},"fn_name":null},{"line":721,"address":[5829051,5829231,5829242],"length":1,"stats":{"Line":2},"fn_name":null},{"line":723,"address":[5829671,5829618,5829237,5830924],"length":1,"stats":{"Line":4},"fn_name":null},{"line":724,"address":[5829838,5829748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":725,"address":[5829727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":726,"address":[5829823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":730,"address":[5829761,5830818],"length":1,"stats":{"Line":1},"fn_name":null},{"line":733,"address":[5830417,5830298],"length":1,"stats":{"Line":1},"fn_name":null},{"line":738,"address":[5831118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":740,"address":[5478576,5478588],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":744,"address":[5831231],"length":1,"stats":{"Line":1},"fn_name":null},{"line":748,"address":[5831407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":749,"address":[5831484,5832106,5831434],"length":1,"stats":{"Line":2},"fn_name":null},{"line":750,"address":[5831553],"length":1,"stats":{"Line":1},"fn_name":null},{"line":752,"address":[5831654,5831785],"length":1,"stats":{"Line":1},"fn_name":null},{"line":758,"address":[5832222],"length":1,"stats":{"Line":1},"fn_name":null},{"line":759,"address":[5832254],"length":1,"stats":{"Line":1},"fn_name":null},{"line":760,"address":[5832279,5832309],"length":1,"stats":{"Line":2},"fn_name":null},{"line":766,"address":[5832494],"length":1,"stats":{"Line":1},"fn_name":null},{"line":767,"address":[5478784,5478802],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":768,"address":[5478832,5478850],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":774,"address":[5832833,5832774,5832745],"length":1,"stats":{"Line":3},"fn_name":null},{"line":780,"address":[5478944,5478962],"length":1,"stats":{"Line":5},"fn_name":"{{closure}}"},{"line":785,"address":[5833101],"length":1,"stats":{"Line":1},"fn_name":null},{"line":786,"address":[5833110],"length":1,"stats":{"Line":1},"fn_name":null},{"line":787,"address":[5833133],"length":1,"stats":{"Line":1},"fn_name":null},{"line":793,"address":[5833220,5833287],"length":1,"stats":{"Line":2},"fn_name":null},{"line":794,"address":[5833326,5833358],"length":1,"stats":{"Line":2},"fn_name":null},{"line":795,"address":[5833310,5833330],"length":1,"stats":{"Line":2},"fn_name":null},{"line":798,"address":[5833360],"length":1,"stats":{"Line":1},"fn_name":null},{"line":804,"address":[5833543,5833648],"length":1,"stats":{"Line":2},"fn_name":null},{"line":805,"address":[5833656,5833890,5833900,5833937,5833833],"length":1,"stats":{"Line":4},"fn_name":null},{"line":806,"address":[5833892,5833928],"length":1,"stats":{"Line":2},"fn_name":null},{"line":808,"address":[5833942],"length":1,"stats":{"Line":1},"fn_name":null},{"line":814,"address":[5834199,5834315],"length":1,"stats":{"Line":2},"fn_name":null},{"line":815,"address":[5834379],"length":1,"stats":{"Line":1},"fn_name":null},{"line":816,"address":[5834423],"length":1,"stats":{"Line":1},"fn_name":null},{"line":817,"address":[5834435],"length":1,"stats":{"Line":1},"fn_name":null},{"line":818,"address":[5834530,5834442],"length":1,"stats":{"Line":2},"fn_name":null},{"line":824,"address":[5834859,5834743],"length":1,"stats":{"Line":2},"fn_name":null},{"line":825,"address":[5834940],"length":1,"stats":{"Line":1},"fn_name":null},{"line":826,"address":[5834987],"length":1,"stats":{"Line":1},"fn_name":null},{"line":827,"address":[5834999],"length":1,"stats":{"Line":1},"fn_name":null},{"line":828,"address":[5835094,5835006],"length":1,"stats":{"Line":2},"fn_name":null},{"line":834,"address":[5479197,5479184],"length":1,"stats":{"Line":5},"fn_name":"{{closure}}"},{"line":840,"address":[5835527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":841,"address":[5835554],"length":1,"stats":{"Line":1},"fn_name":null},{"line":842,"address":[5479264,5479277],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":843,"address":[5479296,5479317],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":844,"address":[5479360,5479381],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":846,"address":[5835858,5835738],"length":1,"stats":{"Line":2},"fn_name":null},{"line":847,"address":[5835870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":848,"address":[5835904,5835971],"length":1,"stats":{"Line":2},"fn_name":null},{"line":854,"address":[5836068],"length":1,"stats":{"Line":1},"fn_name":null},{"line":860,"address":[5836167,5836216],"length":1,"stats":{"Line":2},"fn_name":null},{"line":861,"address":[5836245],"length":1,"stats":{"Line":1},"fn_name":null},{"line":862,"address":[5836291,5836786,5836535,5836337],"length":1,"stats":{"Line":3},"fn_name":null},{"line":863,"address":[5837128,5837313,5836569,5836791],"length":1,"stats":{"Line":2},"fn_name":null},{"line":864,"address":[5836825],"length":1,"stats":{"Line":1},"fn_name":null},{"line":865,"address":[5836944],"length":1,"stats":{"Line":1},"fn_name":null},{"line":866,"address":[5837177,5837133],"length":1,"stats":{"Line":0},"fn_name":null},{"line":870,"address":[5837184,5836520],"length":1,"stats":{"Line":2},"fn_name":null},{"line":876,"address":[5479520,5479535,5479540],"length":1,"stats":{"Line":5},"fn_name":"{{closure}}"},{"line":877,"address":[5479552,5479567,5479572],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":883,"address":[5479631,5479616,5479636],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":889,"address":[5837796],"length":1,"stats":{"Line":1},"fn_name":null},{"line":893,"address":[5837903],"length":1,"stats":{"Line":1},"fn_name":null},{"line":894,"address":[5837927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":895,"address":[5837979,5838034,5838065],"length":1,"stats":{"Line":3},"fn_name":null},{"line":896,"address":[5838072],"length":1,"stats":{"Line":1},"fn_name":null},{"line":898,"address":[5838142],"length":1,"stats":{"Line":1},"fn_name":null},{"line":899,"address":[5838211],"length":1,"stats":{"Line":1},"fn_name":null},{"line":900,"address":[5838276],"length":1,"stats":{"Line":1},"fn_name":null},{"line":901,"address":[5838402,5838977,5838556],"length":1,"stats":{"Line":1},"fn_name":null},{"line":907,"address":[5839047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":908,"address":[5479744,5479757],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":909,"address":[5479776,5479784],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":916,"address":[5479856,5479870],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":917,"address":[5479904,5479912],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":924,"address":[5479998,5479984],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":925,"address":[5839883,5839839],"length":1,"stats":{"Line":2},"fn_name":null},{"line":926,"address":[5480040,5480032],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":933,"address":[5480112,5480126],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":934,"address":[5840492],"length":1,"stats":{"Line":1},"fn_name":null},{"line":935,"address":[5840525,5840557],"length":1,"stats":{"Line":2},"fn_name":null},{"line":936,"address":[5840573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":937,"address":[5840580],"length":1,"stats":{"Line":1},"fn_name":null},{"line":939,"address":[5480160,5480168],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":940,"address":[5841578,5840682,5840611],"length":1,"stats":{"Line":3},"fn_name":null},{"line":941,"address":[5843181,5840792,5840889],"length":1,"stats":{"Line":2},"fn_name":null},{"line":942,"address":[5840966,5840913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":943,"address":[5840968,5841566,5840923],"length":1,"stats":{"Line":3},"fn_name":null},{"line":944,"address":[5841150,5841115,5841223,5841498],"length":1,"stats":{"Line":4},"fn_name":null},{"line":945,"address":[5841412],"length":1,"stats":{"Line":1},"fn_name":null},{"line":947,"address":[5841503],"length":1,"stats":{"Line":1},"fn_name":null},{"line":949,"address":[5841033],"length":1,"stats":{"Line":1},"fn_name":null},{"line":951,"address":[5841583],"length":1,"stats":{"Line":1},"fn_name":null},{"line":954,"address":[5840874,5841604,5841959,5841684],"length":1,"stats":{"Line":4},"fn_name":null},{"line":955,"address":[5841873],"length":1,"stats":{"Line":1},"fn_name":null},{"line":957,"address":[5843019,5842358,5841964],"length":1,"stats":{"Line":2},"fn_name":null},{"line":958,"address":[5843060,5842381,5842760,5842325],"length":1,"stats":{"Line":2},"fn_name":null},{"line":959,"address":[5842697],"length":1,"stats":{"Line":1},"fn_name":null},{"line":966,"address":[5843375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":967,"address":[5843417,5843449,5843388],"length":1,"stats":{"Line":3},"fn_name":null},{"line":968,"address":[5844263,5843419],"length":1,"stats":{"Line":1},"fn_name":null},{"line":970,"address":[5843464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":971,"address":[5843550],"length":1,"stats":{"Line":1},"fn_name":null},{"line":972,"address":[5843628,5844147],"length":1,"stats":{"Line":2},"fn_name":null},{"line":973,"address":[5844133,5844047],"length":1,"stats":{"Line":2},"fn_name":null},{"line":974,"address":[5844152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":977,"address":[5844112],"length":1,"stats":{"Line":1},"fn_name":null},{"line":983,"address":[5480295,5480272],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":984,"address":[5844473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":985,"address":[5844552],"length":1,"stats":{"Line":1},"fn_name":null},{"line":989,"address":[5480423,5480400],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":990,"address":[5844809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":991,"address":[5844888],"length":1,"stats":{"Line":1},"fn_name":null},{"line":995,"address":[5480608,5480636],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":996,"address":[5845145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":997,"address":[5845224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1001,"address":[5480940,5480912],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":1002,"address":[5845497],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1003,"address":[5845576],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1007,"address":[5481319,5481296],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":1008,"address":[5845849],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1009,"address":[5845959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1013,"address":[5481438,5481424,5481511,5481488],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":1014,"address":[5846202],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1015,"address":[5846284],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1019,"address":[5481696,5481760,5481710,5481788],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":1020,"address":[5846570],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1021,"address":[5846652],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1025,"address":[5482064,5482156,5482078,5482128],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":1026,"address":[5846938],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1027,"address":[5847020],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1031,"address":[5847328,5847207],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1032,"address":[5847351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1033,"address":[5847358],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1034,"address":[5847653,5847437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1035,"address":[5847599],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1042,"address":[5848052,5848090,5848149],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1045,"address":[5848243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1051,"address":[5848335,5848397],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1052,"address":[5848414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1053,"address":[5482608,5482622],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1055,"address":[5482720,5482734],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":1057,"address":[5849294,5849519,5848812,5849159],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1058,"address":[5482814,5482800],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1069,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1070,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1075,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1076,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1081,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1082,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1083,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1085,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1086,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1095,"address":[5850355,5850239],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1096,"address":[5850505,5850370,5850444],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1097,"address":[5850432,5850387],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1098,"address":[5850449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1099,"address":[5850415,5850520,5850686],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1100,"address":[5850591],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1102,"address":[5850735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1110,"address":[5482992,5483006],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":1111,"address":[5851052],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1114,"address":[5851029,5851119],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1115,"address":[5851204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1117,"address":[5851307],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1118,"address":[5851441,5851349,5851504],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1119,"address":[5851429,5851378],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1120,"address":[5851446],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1121,"address":[5851398,5851506],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1123,"address":[5851595],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1130,"address":[5483120,5483152],"length":1,"stats":{"Line":1},"fn_name":"collapse_adjacent<fn(f64, f64) -> f64>"},{"line":1133,"address":[5483145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1134,"address":[5483203,5483293,5483167,5483437,5483789],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1135,"address":[5483858,5483471,5483619,5483787],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1136,"address":[5483569],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1138,"address":[5483890,5483920,5483540,5483629],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1144,"address":[5483086,5483072],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":1145,"address":[5851912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1148,"address":[5851883,5851971],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1150,"address":[5852259,5852085],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1151,"address":[5852146],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1153,"address":[5852269,5852128],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1155,"address":[5852308],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1161,"address":[5852602,5852482],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1162,"address":[5852644,5852923,5853071],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1163,"address":[5852760,5852673],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1164,"address":[5852679,5852936],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":443,"coverable":474},{"path":["/","usr","src","itertools","tests","specializations.rs"],"content":"use itertools::{EitherOrBoth, Itertools};\nuse std::fmt::Debug;\nuse std::ops::BitXor;\nuse quickcheck::quickcheck;\n\nstruct Unspecialized<I>(I);\nimpl<I> Iterator for Unspecialized<I>\nwhere\n    I: Iterator,\n{\n    type Item = I::Item;\n\n    #[inline(always)]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.0.next()\n    }\n\n    #[inline(always)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.0.size_hint()\n    }\n}\n\nfn check_specialized<'a, V, IterItem, Iter, F>(iterator: &Iter, mapper: F)\nwhere\n    V: Eq + Debug,\n    IterItem: 'a,\n    Iter: Iterator<Item = IterItem> + Clone + 'a,\n    F: Fn(Box<dyn Iterator<Item = IterItem> + 'a>) -> V,\n{\n    assert_eq!(\n        mapper(Box::new(Unspecialized(iterator.clone()))),\n        mapper(Box::new(iterator.clone()))\n    )\n}\n\nfn check_specialized_count_last_nth_sizeh<'a, IterItem, Iter>(\n    it: &Iter,\n    known_expected_size: Option<usize>,\n) where\n    IterItem: 'a + Eq + Debug,\n    Iter: Iterator<Item = IterItem> + Clone + 'a,\n{\n    let size = it.clone().count();\n    if let Some(expected_size) = known_expected_size {\n        assert_eq!(size, expected_size);\n    }\n    check_specialized(it, |i| i.count());\n    check_specialized(it, |i| i.last());\n    for n in 0..size + 2 {\n        check_specialized(it, |mut i| i.nth(n));\n    }\n    let mut it_sh = it.clone();\n    for n in 0..size + 2 {\n        let len = it_sh.clone().count();\n        let (min, max) = it_sh.size_hint();\n        assert_eq!((size - n.min(size)), len);\n        assert!(min <= len);\n        if let Some(max) = max {\n            assert!(len <= max);\n        }\n        it_sh.next();\n    }\n}\n\nfn check_specialized_fold_xor<'a, IterItem, Iter>(it: &Iter)\nwhere\n    IterItem: 'a\n        + BitXor\n        + Eq\n        + Debug\n        + BitXor<<IterItem as BitXor>::Output, Output = <IterItem as BitXor>::Output>\n        + Clone,\n    <IterItem as BitXor>::Output:\n        BitXor<Output = <IterItem as BitXor>::Output> + Eq + Debug + Clone,\n    Iter: Iterator<Item = IterItem> + Clone + 'a,\n{\n    check_specialized(it, |mut i| {\n        let first = i.next().map(|f| f.clone() ^ (f.clone() ^ f));\n        i.fold(first, |acc, v: IterItem| acc.map(move |a| v ^ a))\n    });\n}\n\nfn put_back_test(test_vec: Vec<i32>, known_expected_size: Option<usize>) {\n    {\n        // Lexical lifetimes support\n        let pb = itertools::put_back(test_vec.iter());\n        check_specialized_count_last_nth_sizeh(&pb, known_expected_size);\n        check_specialized_fold_xor(&pb);\n    }\n\n    let mut pb = itertools::put_back(test_vec.into_iter());\n    pb.put_back(1);\n    check_specialized_count_last_nth_sizeh(&pb, known_expected_size.map(|x| x + 1));\n    check_specialized_fold_xor(&pb)\n}\n\n#[test]\nfn put_back() {\n    put_back_test(vec![7, 4, 1], Some(3));\n}\n\nquickcheck! {\n    fn put_back_qc(test_vec: Vec<i32>) -> () {\n        put_back_test(test_vec, None)\n    }\n}\n\nfn merge_join_by_test(i1: Vec<usize>, i2: Vec<usize>, known_expected_size: Option<usize>) {\n    let i1 = i1.into_iter();\n    let i2 = i2.into_iter();\n    let mjb = i1.clone().merge_join_by(i2.clone(), std::cmp::Ord::cmp);\n    check_specialized_count_last_nth_sizeh(&mjb, known_expected_size);\n    // Rust 1.24 compatibility:\n    fn eob_left_z(eob: EitherOrBoth<usize, usize>) -> usize {\n        eob.left().unwrap_or(0)\n    }\n    fn eob_right_z(eob: EitherOrBoth<usize, usize>) -> usize {\n        eob.left().unwrap_or(0)\n    }\n    fn eob_both_z(eob: EitherOrBoth<usize, usize>) -> usize {\n        let (a, b) = eob.both().unwrap_or((0, 0));\n        assert_eq!(a, b);\n        a\n    }\n    check_specialized_fold_xor(&mjb.clone().map(eob_left_z));\n    check_specialized_fold_xor(&mjb.clone().map(eob_right_z));\n    check_specialized_fold_xor(&mjb.clone().map(eob_both_z));\n\n    // And the other way around\n    let mjb = i2.merge_join_by(i1, std::cmp::Ord::cmp);\n    check_specialized_count_last_nth_sizeh(&mjb, known_expected_size);\n    check_specialized_fold_xor(&mjb.clone().map(eob_left_z));\n    check_specialized_fold_xor(&mjb.clone().map(eob_right_z));\n    check_specialized_fold_xor(&mjb.clone().map(eob_both_z));\n}\n\n#[test]\nfn merge_join_by() {\n    let i1 = vec![1, 3, 5, 7, 8, 9];\n    let i2 = vec![0, 3, 4, 5];\n    merge_join_by_test(i1, i2, Some(8));\n}\n\nquickcheck! {\n    fn merge_join_by_qc(i1: Vec<usize>, i2: Vec<usize>) -> () {\n        merge_join_by_test(i1, i2, None)\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[4277776,4282560,4270081,4278761,4274016,4281681,4272049,4274067,4274944,4275937,4276832,4282617,4271009,4278704,4277819,4279648,4280688,4275888,4270960,4276881,4279697,4270032,4280737,4273040,4272000,4273089,4274993,4281632],"length":1,"stats":{"Line":25},"fn_name":"check_specialized<core::option::Option<&i32>,&i32,itertools::adaptors::PutBack<core::slice::Iter<i32>>,closure-1>"},{"line":31,"address":[4281232,4271600,4275488,4276331,4276423,4280184,4282063,4277399,4278217,4279167,4277299,4273519,4281243,4278309,4271496,4273622,4275399,4272640,4275499,4280299,4279256,4278320,4279267,4271611,4274465,4281143,4280288,4274557,4282155,4282166,4272536,4272651,4273611,4274568,4270578,4277388,4276434,4270475,4283103,4283011,4270567,4283114],"length":1,"stats":{"Line":56},"fn_name":null},{"line":32,"address":[4276863,4273071,4274248,4280879,4270221,4277804,4279679,4271024,4277834,4275952,4282632,4273104,4282757,4273279,4272064,4276896,4275919,4278776,4270063,4270096,4277021,4272031,4275008,4274975,4270991,4278000,4278903,4271205,4282599,4280752,4281696,4274052,4275135,4279712,4276077,4281663,4281823,4272245,4274082,4279893,4278743,4280719],"length":1,"stats":{"Line":84},"fn_name":null},{"line":33,"address":[4282931,4272363,4277121,4278075,4273439,4271398,4274323,4275235,4278147,4271323,4274395,4272438,4279003,4275307,4279075,4280086,4277207,4273367,4276251,4270395,4280979,4281051,4276165,4270309,4280011,4281911,4281983,4282845],"length":1,"stats":{"Line":53},"fn_name":null},{"line":37,"address":[4285649,4283504,4283569,4287696,4287761,4285584],"length":1,"stats":{"Line":3},"fn_name":"check_specialized_count_last_nth_sizeh<&i32,itertools::adaptors::PutBack<core::slice::Iter<i32>>>"},{"line":44,"address":[4285664,4283535,4287727,4283584,4287776,4285615],"length":1,"stats":{"Line":10},"fn_name":null},{"line":45,"address":[4287929,4283605,4285817,4285685,4283737,4287797],"length":1,"stats":{"Line":8},"fn_name":null},{"line":46,"address":[4285829,4283637,4283749,4287941,4285717,4287829],"length":1,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[4289840,4289888,4289811,4289859,4288276,4289792,4286164,4289907,4284084],"length":1,"stats":{"Line":15},"fn_name":"{{closure}}<&i32,itertools::adaptors::PutBack<core::slice::Iter<i32>>>"},{"line":49,"address":[4288289,4290003,4289936,4290067,4284097,4286177,4289984,4290048,4289958],"length":1,"stats":{"Line":18},"fn_name":"{{closure}}<itertools::either_or_both::EitherOrBoth<usize, usize>,itertools::merge_join::MergeJoinBy<alloc::vec::IntoIter<usize>, alloc::vec::IntoIter<usize>, fn(&usize, &usize) -> core::cmp::Ordering>>"},{"line":50,"address":[4285458,4288499,4288294,4286182,4287572,4289674,4288570,4284378,4284102,4286458,4284307,4286387],"length":1,"stats":{"Line":12},"fn_name":null},{"line":51,"address":[4284341,4290115,4290096,4290208,4286421,4290320,4288533,4290339,4290230],"length":1,"stats":{"Line":18},"fn_name":"{{closure}}<&i32,itertools::adaptors::PutBack<core::slice::Iter<i32>>>"},{"line":53,"address":[4288476,4286364,4284284],"length":1,"stats":{"Line":6},"fn_name":null},{"line":54,"address":[4285488,4287602,4285445,4286463,4284501,4286594,4288832,4284614,4287559,4288575,4288706,4284383,4286720,4289704,4289661],"length":1,"stats":{"Line":18},"fn_name":null},{"line":55,"address":[4288890,4284672,4286778],"length":1,"stats":{"Line":6},"fn_name":null},{"line":56,"address":[4288946,4286834,4284728],"length":1,"stats":{"Line":6},"fn_name":null},{"line":57,"address":[4289786,4286889,4289756,4287654,4284783,4285570,4287684,4289001,4284998,4287104,4285540,4289216],"length":1,"stats":{"Line":6},"fn_name":null},{"line":58,"address":[4287076,4284970,4289544,4289188,4287432,4285326],"length":1,"stats":{"Line":6},"fn_name":null},{"line":59,"address":[4289614,4289531,4287502,4285359,4287419,4285396,4287465,4285313,4289577],"length":1,"stats":{"Line":12},"fn_name":null},{"line":60,"address":[4285377,4287483,4289595,4287504,4285398,4289616],"length":1,"stats":{"Line":6},"fn_name":null},{"line":62,"address":[4287550,4285436,4289654],"length":1,"stats":{"Line":6},"fn_name":null},{"line":66,"address":[4290464,4290528,4290496,4290432,4290560],"length":1,"stats":{"Line":10},"fn_name":"check_specialized_fold_xor<i32,itertools::adaptors::PutBack<alloc::vec::IntoIter<i32>>>"},{"line":78,"address":[4292581,4290537,4290569,4292144,4290505,4292928,4292775,4292375,4292190,4290441,4290473,4292983,4292720,4292320,4292528],"length":1,"stats":{"Line":20},"fn_name":"{{closure}}<&i32,itertools::adaptors::PutBack<core::slice::Iter<i32>>>"},{"line":79,"address":[4290809,4292547,4290592,4290800,4292163,4291200,4292207,4292797,4292739,4292339,4291417,4291209,4292397,4290601,4291016,4291408,4291008,4292601,4292947,4293005],"length":1,"stats":{"Line":40},"fn_name":"{{closure}}<usize,core::iter::adapters::Map<itertools::merge_join::MergeJoinBy<alloc::vec::IntoIter<usize>, alloc::vec::IntoIter<usize>, fn(&usize, &usize) -> core::cmp::Ordering>, fn(itertools::either_or_both::EitherOrBoth<usize, usize>) -> usize>>"},{"line":80,"address":[4292000,4292102,4292434,4292632,4292834,4292238,4291680,4291630,4291712,4291648,4291856,4291725,4291800,4291880,4291616,4291936,4291957,4293042,4291758,4291744,4292080,4291692,4291776,4291662,4292024],"length":1,"stats":{"Line":47},"fn_name":"{{closure}}<usize,core::iter::adapters::Map<itertools::merge_join::MergeJoinBy<alloc::vec::IntoIter<usize>, alloc::vec::IntoIter<usize>, fn(&usize, &usize) -> core::cmp::Ordering>, fn(itertools::either_or_both::EitherOrBoth<usize, usize>) -> usize>>"},{"line":84,"address":[4306032,4306103],"length":1,"stats":{"Line":1},"fn_name":"put_back_test"},{"line":87,"address":[4306118,4306086],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[4306186],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[4306198],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[4306205],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[4306298],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[4293145,4293136],"length":1,"stats":{"Line":5},"fn_name":"{{closure}}"},{"line":95,"address":[4306371],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[4293221,4293216],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":100,"address":[4308692],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[4308820],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[4306480,4306667],"length":1,"stats":{"Line":1},"fn_name":"merge_join_by_test"},{"line":110,"address":[4306503],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[4306682,4306607],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[4306690,4307695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[4306811],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[4307968],"length":1,"stats":{"Line":2},"fn_name":"eob_left_z"},{"line":116,"address":[4307972],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[4308064],"length":1,"stats":{"Line":2},"fn_name":"eob_right_z"},{"line":119,"address":[4308068],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[4308160],"length":1,"stats":{"Line":2},"fn_name":"eob_both_z"},{"line":122,"address":[4308167],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[4308408,4308300],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[4306834,4306875],"length":1,"stats":{"Line":4},"fn_name":null},{"line":127,"address":[4306943],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[4307037],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[4307115],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[4307232],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[4307255,4307296],"length":1,"stats":{"Line":4},"fn_name":null},{"line":134,"address":[4307364],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[4307458],"length":1,"stats":{"Line":2},"fn_name":null},{"line":139,"address":[4293280,4293285],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":140,"address":[4308887,4308994],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[4309012],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[4309084],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[4309268],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":63,"coverable":65},{"path":["/","usr","src","itertools","tests","test_core.rs"],"content":"//! Licensed under the Apache License, Version 2.0\n//! http://www.apache.org/licenses/LICENSE-2.0 or the MIT license\n//! http://opensource.org/licenses/MIT, at your\n//! option. This file may not be copied, modified, or distributed\n//! except according to those terms.\n#![no_std]\n\nuse core::iter;\nuse itertools as it;\nuse crate::it::Itertools;\nuse crate::it::interleave;\nuse crate::it::multizip;\nuse crate::it::free::put_back;\nuse crate::it::iproduct;\nuse crate::it::izip;\n\n#[test]\nfn product2() {\n    let s = \"αβ\";\n\n    let mut prod = iproduct!(s.chars(), 0..2);\n    assert!(prod.next() == Some(('α', 0)));\n    assert!(prod.next() == Some(('α', 1)));\n    assert!(prod.next() == Some(('β', 0)));\n    assert!(prod.next() == Some(('β', 1)));\n    assert!(prod.next() == None);\n}\n\n#[test]\nfn product_temporary() {\n    for (_x, _y, _z) in iproduct!(\n        [0, 1, 2].iter().cloned(),\n        [0, 1, 2].iter().cloned(),\n        [0, 1, 2].iter().cloned())\n    {\n        // ok\n    }\n}\n\n\n#[test]\nfn izip_macro() {\n    let mut zip = izip!(2..3);\n    assert!(zip.next() == Some(2));\n    assert!(zip.next().is_none());\n\n    let mut zip = izip!(0..3, 0..2, 0..2i8);\n    for i in 0..2 {\n        assert!((i as usize, i, i as i8) == zip.next().unwrap());\n    }\n    assert!(zip.next().is_none());\n\n    let xs: [isize; 0] = [];\n    let mut zip = izip!(0..3, 0..2, 0..2i8, &xs);\n    assert!(zip.next().is_none());\n}\n\n#[test]\nfn izip2() {\n    let _zip1: iter::Zip<_, _> = izip!(1.., 2..);\n    let _zip2: iter::Zip<_, _> = izip!(1.., 2.., );\n}\n\n#[test]\nfn izip3() {\n    let mut zip: iter::Map<iter::Zip<_, _>, _> = izip!(0..3, 0..2, 0..2i8);\n    for i in 0..2 {\n        assert!((i as usize, i, i as i8) == zip.next().unwrap());\n    }\n    assert!(zip.next().is_none());\n}\n\n#[test]\nfn multizip3() {\n    let mut zip = multizip((0..3, 0..2, 0..2i8));\n    for i in 0..2 {\n        assert!((i as usize, i, i as i8) == zip.next().unwrap());\n    }\n    assert!(zip.next().is_none());\n\n    let xs: [isize; 0] = [];\n    let mut zip = multizip((0..3, 0..2, 0..2i8, xs.iter()));\n    assert!(zip.next().is_none());\n\n    for (_, _, _, _, _) in multizip((0..3, 0..2, xs.iter(), &xs, xs.to_vec())) {\n        /* test compiles */\n    }\n}\n\n#[test]\nfn write_to() {\n    let xs = [7, 9, 8];\n    let mut ys = [0; 5];\n    let cnt = ys.iter_mut().set_from(xs.iter().map(|x| *x));\n    assert!(cnt == xs.len());\n    assert!(ys == [7, 9, 8, 0, 0]);\n\n    let cnt = ys.iter_mut().set_from(0..10);\n    assert!(cnt == ys.len());\n    assert!(ys == [0, 1, 2, 3, 4]);\n}\n\n#[test]\nfn test_interleave() {\n    let xs: [u8; 0]  = [];\n    let ys = [7u8, 9, 8, 10];\n    let zs = [2u8, 77];\n    let it = interleave(xs.iter(), ys.iter());\n    it::assert_equal(it, ys.iter());\n\n    let rs = [7u8, 2, 9, 77, 8, 10];\n    let it = interleave(ys.iter(), zs.iter());\n    it::assert_equal(it, rs.iter());\n}\n\n#[allow(deprecated)]\n#[test]\nfn foreach() {\n    let xs = [1i32, 2, 3];\n    let mut sum = 0;\n    xs.iter().foreach(|elt| sum += *elt);\n    assert!(sum == 6);\n}\n\n#[test]\nfn dropping() {\n    let xs = [1, 2, 3];\n    let mut it = xs.iter().dropping(2);\n    assert_eq!(it.next(), Some(&3));\n    assert!(it.next().is_none());\n    let mut it = xs.iter().dropping(5);\n    assert!(it.next().is_none());\n}\n\n#[test]\nfn batching() {\n    let xs = [0, 1, 2, 1, 3];\n    let ys = [(0, 1), (2, 1)];\n\n    // An iterator that gathers elements up in pairs\n    let pit = xs.iter().cloned().batching(|it| {\n               match it.next() {\n                   None => None,\n                   Some(x) => match it.next() {\n                       None => None,\n                       Some(y) => Some((x, y)),\n                   }\n               }\n           });\n    it::assert_equal(pit, ys.iter().cloned());\n}\n\n#[test]\nfn test_put_back() {\n    let xs = [0, 1, 1, 1, 2, 1, 3, 3];\n    let mut pb = put_back(xs.iter().cloned());\n    pb.next();\n    pb.put_back(1);\n    pb.put_back(0);\n    it::assert_equal(pb, xs.iter().cloned());\n}\n\n#[allow(deprecated)]\n#[test]\nfn step() {\n    it::assert_equal((0..10).step(1), 0..10);\n    it::assert_equal((0..10).step(2), (0..10).filter(|x: &i32| *x % 2 == 0));\n    it::assert_equal((0..10).step(10), 0..1);\n}\n\n#[allow(deprecated)]\n#[test]\nfn merge() {\n    it::assert_equal((0..10).step(2).merge((1..10).step(2)), 0..10);\n}\n\n\n#[test]\nfn repeatn() {\n    let s = \"α\";\n    let mut it = it::repeat_n(s, 3);\n    assert_eq!(it.len(), 3);\n    assert_eq!(it.next(), Some(s));\n    assert_eq!(it.next(), Some(s));\n    assert_eq!(it.next(), Some(s));\n    assert_eq!(it.next(), None);\n    assert_eq!(it.next(), None);\n}\n\n#[test]\nfn count_clones() {\n    // Check that RepeatN only clones N - 1 times.\n\n    use core::cell::Cell;\n    #[derive(PartialEq, Debug)]\n    struct Foo {\n        n: Cell<usize>\n    }\n\n    impl Clone for Foo\n    {\n        fn clone(&self) -> Self\n        {\n            let n = self.n.get();\n            self.n.set(n + 1);\n            Foo { n: Cell::new(n + 1) }\n        }\n    }\n\n\n    for n in 0..10 {\n        let f = Foo{n: Cell::new(0)};\n        let it = it::repeat_n(f, n);\n        // drain it\n        let last = it.last();\n        if n == 0 {\n            assert_eq!(last, None);\n        } else {\n            assert_eq!(last, Some(Foo{n: Cell::new(n - 1)}));\n        }\n    }\n}\n\n#[test]\nfn part() {\n    let mut data = [7, 1, 1, 9, 1, 1, 3];\n    let i = it::partition(&mut data, |elt| *elt >= 3);\n    assert_eq!(i, 3);\n    assert_eq!(data, [7, 3, 9, 1, 1, 1, 1]);\n\n    let i = it::partition(&mut data, |elt| *elt == 1);\n    assert_eq!(i, 4);\n    assert_eq!(data, [1, 1, 1, 1, 9, 3, 7]);\n\n    let mut data = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let i = it::partition(&mut data, |elt| *elt % 3 == 0);\n    assert_eq!(i, 3);\n    assert_eq!(data, [9, 6, 3, 4, 5, 2, 7, 8, 1]);\n}\n\n#[test]\nfn tree_fold1() {\n    for i in 0..100 {\n        assert_eq!((0..i).tree_fold1(|x, y| x + y), (0..i).fold1(|x, y| x + y));\n    }\n}\n\n#[test]\nfn exactly_one() {\n    assert_eq!((0..10).filter(|&x| x == 2).exactly_one().unwrap(), 2);\n    assert!((0..10).filter(|&x| x > 1 && x < 4).exactly_one().unwrap_err().eq(2..4));\n    assert!((0..10).filter(|&x| x > 1 && x < 5).exactly_one().unwrap_err().eq(2..5));\n    assert!((0..10).filter(|&_| false).exactly_one().unwrap_err().eq(0..0));\n}\n\n#[test]\nfn sum1() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq!(v[..0].iter().cloned().sum1::<i32>(), None);\n    assert_eq!(v[1..2].iter().cloned().sum1::<i32>(), Some(1));\n    assert_eq!(v[1..3].iter().cloned().sum1::<i32>(), Some(3));\n    assert_eq!(v.iter().cloned().sum1::<i32>(), Some(55));\n}\n\n#[test]\nfn product1() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq!(v[..0].iter().cloned().product1::<i32>(), None);\n    assert_eq!(v[..1].iter().cloned().product1::<i32>(), Some(0));\n    assert_eq!(v[1..3].iter().cloned().product1::<i32>(), Some(2));\n    assert_eq!(v[1..5].iter().cloned().product1::<i32>(), Some(24));\n}\n","traces":[{"line":18,"address":[4226464],"length":1,"stats":{"Line":3},"fn_name":"product2"},{"line":19,"address":[4226478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[4226498],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[4226617,4226681],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[4226666,4226711,4226762],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[4226747,4226843,4226792],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[4226873,4226828,4226930],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[4227032,4226909,4226960,4227002],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[4273968,4273973],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":31,"address":[4227204,4227124,4227338,4227503],"length":1,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[4227047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[4227139],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[4227273],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[4227648],"length":1,"stats":{"Line":3},"fn_name":"izip_macro"},{"line":43,"address":[4227655],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[4227697,4227761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[4227746,4227873,4227791],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[4227815,4227903],"length":1,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[4228036,4228316,4228175],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[4228205,4228321],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[4228429,4228152,4228351],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[4228459,4228378],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[4228678,4228708,4228622],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[4228720],"length":1,"stats":{"Line":3},"fn_name":"izip2"},{"line":60,"address":[4228724],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[4228757],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[4274213,4274208],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":66,"address":[4228807],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[4229270,4229129,4228990],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[4229275,4229159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[4229305,4229106,4229370,4229340],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[4229376,4229536],"length":1,"stats":{"Line":3},"fn_name":"multizip3"},{"line":75,"address":[4229383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[4229690,4229551,4229831],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[4229720,4229836],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[4229982,4229667,4229866],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[4229897,4230012],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[4230145,4230266],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[4230300,4230197,4230625,4230582],"length":1,"stats":{"Line":3},"fn_name":null},{"line":91,"address":[4230864],"length":1,"stats":{"Line":3},"fn_name":"write_to"},{"line":92,"address":[4230871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[4230895],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[4230921],"length":1,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[4231101,4231031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[4231078,4231174,4231135],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[4231151,4231204],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[4231266,4231336],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[4231414,4231370,4231384,4231313],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[4231424],"length":1,"stats":{"Line":3},"fn_name":"test_interleave"},{"line":106,"address":[4231435],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[4231455],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[4231465],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[4231543],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[4231623],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[4231671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[4231760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[4231856],"length":1,"stats":{"Line":3},"fn_name":"foreach"},{"line":119,"address":[4231860],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[4231884],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[4231892],"length":1,"stats":{"Line":3},"fn_name":null},{"line":122,"address":[4231967,4231997,4231948],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[4232000],"length":1,"stats":{"Line":3},"fn_name":"dropping"},{"line":127,"address":[4232007],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[4232040],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[4232107,4232252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[4232539,4232226,4232599],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[4232566,4232644],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[4232665,4232721,4232751],"length":1,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[4232752],"length":1,"stats":{"Line":3},"fn_name":"batching"},{"line":137,"address":[4232759],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[4232799],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[4232875],"length":1,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[4274717,4274646,4274730,4274805],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[4274672,4274724],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[4274685,4274790],"length":1,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[4274732,4274799],"length":1,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[4274745],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[4232969],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[4233056],"length":1,"stats":{"Line":3},"fn_name":"test_put_back"},{"line":155,"address":[4233063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[4233127],"length":1,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[4233200],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[4233210],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[4233227],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[4233237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[4233360],"length":1,"stats":{"Line":3},"fn_name":"step"},{"line":166,"address":[4233367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[4233440],"length":1,"stats":{"Line":3},"fn_name":null},{"line":168,"address":[4233534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[4233632],"length":1,"stats":{"Line":3},"fn_name":"merge"},{"line":174,"address":[4233639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[4233808],"length":1,"stats":{"Line":3},"fn_name":"repeatn"},{"line":180,"address":[4233822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[4233842],"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[4234029,4233868],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[4234528,4234363,4233996],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[4234502,4234870,4235035],"length":1,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[4235377,4235009,4235542],"length":1,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[4235877,4235516,4236021],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[4235995,4236320,4236426],"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[4236720],"length":1,"stats":{"Line":3},"fn_name":"count_clones"},{"line":202,"address":[4238000],"length":1,"stats":{"Line":1},"fn_name":"clone"},{"line":204,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[4236879,4236727,4237965],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[4236925],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[4236954],"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[4236983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[4237207,4237052,4237675],"length":1,"stats":{"Line":3},"fn_name":null},{"line":217,"address":[4237212,4237097],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[4237680,4237066,4238000,4237970,4237525],"length":1,"stats":{"Line":2},"fn_name":"clone"},{"line":225,"address":[4238448],"length":1,"stats":{"Line":3},"fn_name":"part"},{"line":226,"address":[4238455],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[4238532],"length":1,"stats":{"Line":3},"fn_name":null},{"line":228,"address":[4238553,4238761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[4238652,4239095,4239127],"length":1,"stats":{"Line":2},"fn_name":null},{"line":231,"address":[4239101],"length":1,"stats":{"Line":3},"fn_name":null},{"line":232,"address":[4239462,4239670],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[4239561,4240004,4240135],"length":1,"stats":{"Line":2},"fn_name":null},{"line":235,"address":[4240010],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[4240109],"length":1,"stats":{"Line":3},"fn_name":null},{"line":237,"address":[4240470,4240672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[4240961,4240569,4240975],"length":1,"stats":{"Line":2},"fn_name":null},{"line":242,"address":[4241264],"length":1,"stats":{"Line":3},"fn_name":"tree_fold1"},{"line":243,"address":[4241365,4241271,4241595],"length":1,"stats":{"Line":2},"fn_name":null},{"line":244,"address":[4241600,4241392],"length":1,"stats":{"Line":5},"fn_name":null},{"line":249,"address":[4241888],"length":1,"stats":{"Line":3},"fn_name":"exactly_one"},{"line":250,"address":[4241895,4242140],"length":1,"stats":{"Line":3},"fn_name":null},{"line":251,"address":[4242086,4242427,4242593],"length":1,"stats":{"Line":4},"fn_name":null},{"line":252,"address":[4242789,4242623,4242542],"length":1,"stats":{"Line":4},"fn_name":null},{"line":253,"address":[4242738,4242942,4242819,4242972],"length":1,"stats":{"Line":4},"fn_name":null},{"line":257,"address":[4242976],"length":1,"stats":{"Line":3},"fn_name":"sum1"},{"line":258,"address":[4242994],"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[4243021,4243370],"length":1,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[4243721,4243288,4244013],"length":1,"stats":{"Line":2},"fn_name":null},{"line":261,"address":[4244364,4244606,4243931],"length":1,"stats":{"Line":2},"fn_name":null},{"line":262,"address":[4244575,4244933,4245083],"length":1,"stats":{"Line":2},"fn_name":null},{"line":266,"address":[4245376],"length":1,"stats":{"Line":3},"fn_name":"product1"},{"line":267,"address":[4245394],"length":1,"stats":{"Line":1},"fn_name":null},{"line":268,"address":[4245421,4245735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[4245696,4246086,4246378],"length":1,"stats":{"Line":2},"fn_name":null},{"line":270,"address":[4247021,4246729,4246296],"length":1,"stats":{"Line":2},"fn_name":null},{"line":271,"address":[4247535,4247360,4246939],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":144,"coverable":144},{"path":["/","usr","src","itertools","tests","test_std.rs"],"content":"use permutohedron;\nuse itertools as it;\nuse crate::it::Itertools;\nuse crate::it::multizip;\nuse crate::it::multipeek;\nuse crate::it::peek_nth;\nuse crate::it::free::rciter;\nuse crate::it::free::put_back_n;\nuse crate::it::FoldWhile;\nuse crate::it::cloned;\nuse crate::it::iproduct;\nuse crate::it::izip;\n\n#[test]\nfn product3() {\n    let prod = iproduct!(0..3, 0..2, 0..2);\n    assert_eq!(prod.size_hint(), (12, Some(12)));\n    let v = prod.collect_vec();\n    for i in 0..3 {\n        for j in 0..2 {\n            for k in 0..2 {\n                assert!((i, j, k) == v[(i * 2 * 2 + j * 2 + k) as usize]);\n            }\n        }\n    }\n    for (_, _, _, _) in iproduct!(0..3, 0..2, 0..2, 0..3) {\n        /* test compiles */\n    }\n}\n\n#[test]\nfn interleave_shortest() {\n    let v0: Vec<i32> = vec![0, 2, 4];\n    let v1: Vec<i32> = vec![1, 3, 5, 7];\n    let it = v0.into_iter().interleave_shortest(v1.into_iter());\n    assert_eq!(it.size_hint(), (6, Some(6)));\n    assert_eq!(it.collect_vec(), vec![0, 1, 2, 3, 4, 5]);\n\n    let v0: Vec<i32> = vec![0, 2, 4, 6, 8];\n    let v1: Vec<i32> = vec![1, 3, 5];\n    let it = v0.into_iter().interleave_shortest(v1.into_iter());\n    assert_eq!(it.size_hint(), (7, Some(7)));\n    assert_eq!(it.collect_vec(), vec![0, 1, 2, 3, 4, 5, 6]);\n\n    let i0 = ::std::iter::repeat(0);\n    let v1: Vec<_> = vec![1, 3, 5];\n    let it = i0.interleave_shortest(v1.into_iter());\n    assert_eq!(it.size_hint(), (7, Some(7)));\n\n    let v0: Vec<_> = vec![0, 2, 4];\n    let i1 = ::std::iter::repeat(1);\n    let it = v0.into_iter().interleave_shortest(i1);\n    assert_eq!(it.size_hint(), (6, Some(6)));\n}\n\n\n#[test]\nfn unique_by() {\n    let xs = [\"aaa\", \"bbbbb\", \"aa\", \"ccc\", \"bbbb\", \"aaaaa\", \"cccc\"];\n    let ys = [\"aaa\", \"bbbbb\", \"ccc\"];\n    it::assert_equal(ys.iter(), xs.iter().unique_by(|x| x[..2].to_string()));\n    it::assert_equal(ys.iter(), xs.iter().rev().unique_by(|x| x[..2].to_string()).rev());\n    let ys_rev = [\"cccc\", \"aaaaa\", \"bbbb\"];\n    it::assert_equal(ys_rev.iter(), xs.iter().unique_by(|x| x[..2].to_string()).rev());\n}\n\n#[test]\nfn unique() {\n    let xs = [0, 1, 2, 3, 2, 1, 3];\n    let ys = [0, 1, 2, 3];\n    it::assert_equal(ys.iter(), xs.iter().unique());\n    it::assert_equal(ys.iter(), xs.iter().rev().unique().rev());\n    let ys_rev = [3, 1, 2, 0];\n    it::assert_equal(ys_rev.iter(), xs.iter().unique().rev());\n\n    let xs = [0, 1];\n    let ys = [0, 1];\n    it::assert_equal(ys.iter(), xs.iter().unique());\n    it::assert_equal(ys.iter(), xs.iter().rev().unique().rev());\n    let ys_rev = [1, 0];\n    it::assert_equal(ys_rev.iter(), xs.iter().unique().rev());\n}\n\n#[test]\nfn intersperse() {\n    let xs = [\"a\", \"\", \"b\", \"c\"];\n    let v: Vec<&str> = xs.iter().map(|x| x.clone()).intersperse(\", \").collect();\n    let text: String = v.concat();\n    assert_eq!(text, \"a, , b, c\".to_string());\n\n    let ys = [0, 1, 2, 3];\n    let mut it = ys[..0].iter().map(|x| *x).intersperse(1);\n    assert!(it.next() == None);\n}\n\n#[test]\nfn dedup() {\n    let xs = [0, 1, 1, 1, 2, 1, 3, 3];\n    let ys = [0, 1, 2, 1, 3];\n    it::assert_equal(ys.iter(), xs.iter().dedup());\n    let xs = [0, 0, 0, 0, 0];\n    let ys = [0];\n    it::assert_equal(ys.iter(), xs.iter().dedup());\n\n    let xs = [0, 1, 1, 1, 2, 1, 3, 3];\n    let ys = [0, 1, 2, 1, 3];\n    let mut xs_d = Vec::new();\n    xs.iter().dedup().fold((), |(), &elt| xs_d.push(elt));\n    assert_eq!(&xs_d, &ys);\n}\n\n#[test]\nfn dedup_by() {\n    let xs = [(0, 0), (0, 1), (1, 1), (2, 1), (0, 2), (3, 1), (0, 3), (1, 3)];\n    let ys = [(0, 0), (0, 1), (0, 2), (3, 1), (0, 3)];\n    it::assert_equal(ys.iter(), xs.iter().dedup_by(|x, y| x.1==y.1));\n    let xs = [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)];\n    let ys = [(0, 1)];\n    it::assert_equal(ys.iter(), xs.iter().dedup_by(|x, y| x.0==y.0));\n\n    let xs = [(0, 0), (0, 1), (1, 1), (2, 1), (0, 2), (3, 1), (0, 3), (1, 3)];\n    let ys = [(0, 0), (0, 1), (0, 2), (3, 1), (0, 3)];\n    let mut xs_d = Vec::new();\n    xs.iter().dedup_by(|x, y| x.1==y.1).fold((), |(), &elt| xs_d.push(elt));\n    assert_eq!(&xs_d, &ys);\n}\n\n#[test]\nfn dedup_with_count() {\n    let xs: [i32; 8] = [0, 1, 1, 1, 2, 1, 3, 3];\n    let ys: [(usize, &i32); 5] = [(1, &0), (3, &1), (1, &2), (1, &1), (2, &3)];\n\n    it::assert_equal(ys.iter().cloned(), xs.iter().dedup_with_count());\n\n    let xs: [i32; 5] = [0, 0, 0, 0, 0];\n    let ys: [(usize, &i32); 1] = [(5, &0)];\n\n    it::assert_equal(ys.iter().cloned(), xs.iter().dedup_with_count());\n}\n\n\n#[test]\nfn dedup_by_with_count() {\n    let xs = [(0, 0), (0, 1), (1, 1), (2, 1), (0, 2), (3, 1), (0, 3), (1, 3)];\n    let ys = [(1, &(0, 0)), (3, &(0, 1)), (1, &(0, 2)), (1, &(3, 1)), (2, &(0, 3))];\n\n    it::assert_equal(ys.iter().cloned(), xs.iter().dedup_by_with_count(|x, y| x.1==y.1));\n\n    let xs = [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)];\n    let ys = [( 5, &(0, 1))];\n\n    it::assert_equal(ys.iter().cloned(), xs.iter().dedup_by_with_count(|x, y| x.0==y.0));\n}\n\n#[test]\nfn all_equal() {\n    assert!(\"\".chars().all_equal());\n    assert!(\"A\".chars().all_equal());\n    assert!(!\"AABBCCC\".chars().all_equal());\n    assert!(\"AAAAAAA\".chars().all_equal());\n    for (_key, mut sub) in &\"AABBCCC\".chars().group_by(|&x| x) {\n        assert!(sub.all_equal());\n    }\n}\n\n#[test]\nfn test_put_back_n() {\n    let xs = [0, 1, 1, 1, 2, 1, 3, 3];\n    let mut pb = put_back_n(xs.iter().cloned());\n    pb.next();\n    pb.next();\n    pb.put_back(1);\n    pb.put_back(0);\n    it::assert_equal(pb, xs.iter().cloned());\n}\n\n#[test]\nfn tee() {\n    let xs  = [0, 1, 2, 3];\n    let (mut t1, mut t2) = xs.iter().cloned().tee();\n    assert_eq!(t1.next(), Some(0));\n    assert_eq!(t2.next(), Some(0));\n    assert_eq!(t1.next(), Some(1));\n    assert_eq!(t1.next(), Some(2));\n    assert_eq!(t1.next(), Some(3));\n    assert_eq!(t1.next(), None);\n    assert_eq!(t2.next(), Some(1));\n    assert_eq!(t2.next(), Some(2));\n    assert_eq!(t1.next(), None);\n    assert_eq!(t2.next(), Some(3));\n    assert_eq!(t2.next(), None);\n    assert_eq!(t1.next(), None);\n    assert_eq!(t2.next(), None);\n\n    let (t1, t2) = xs.iter().cloned().tee();\n    it::assert_equal(t1, xs.iter().cloned());\n    it::assert_equal(t2, xs.iter().cloned());\n\n    let (t1, t2) = xs.iter().cloned().tee();\n    it::assert_equal(t1.zip(t2), xs.iter().cloned().zip(xs.iter().cloned()));\n}\n\n\n#[test]\nfn test_rciter() {\n    let xs = [0, 1, 1, 1, 2, 1, 3, 5, 6];\n\n    let mut r1 = rciter(xs.iter().cloned());\n    let mut r2 = r1.clone();\n    assert_eq!(r1.next(), Some(0));\n    assert_eq!(r2.next(), Some(1));\n    let mut z = r1.zip(r2);\n    assert_eq!(z.next(), Some((1, 1)));\n    assert_eq!(z.next(), Some((2, 1)));\n    assert_eq!(z.next(), Some((3, 5)));\n    assert_eq!(z.next(), None);\n\n    // test intoiterator\n    let r1 = rciter(0..5);\n    let mut z = izip!(&r1, r1);\n    assert_eq!(z.next(), Some((0, 1)));\n}\n\n#[allow(deprecated)]\n#[test]\nfn trait_pointers() {\n    struct ByRef<'r, I: ?Sized>(&'r mut I) ;\n\n    impl<'r, X, I: ?Sized> Iterator for ByRef<'r, I> where\n        I: 'r + Iterator<Item=X>\n    {\n        type Item = X;\n        fn next(&mut self) -> Option<Self::Item>\n        {\n            self.0.next()\n        }\n    }\n\n    let mut it = Box::new(0..10) as Box<dyn Iterator<Item=i32>>;\n    assert_eq!(it.next(), Some(0));\n\n    {\n        /* make sure foreach works on non-Sized */\n        let jt: &mut dyn Iterator<Item = i32> = &mut *it;\n        assert_eq!(jt.next(), Some(1));\n\n        {\n            let mut r = ByRef(jt);\n            assert_eq!(r.next(), Some(2));\n        }\n\n        assert_eq!(jt.find_position(|x| *x == 4), Some((1, 4)));\n        jt.foreach(|_| ());\n    }\n}\n\n#[test]\nfn merge_by() {\n    let odd : Vec<(u32, &str)> = vec![(1, \"hello\"), (3, \"world\"), (5, \"!\")];\n    let even = vec![(2, \"foo\"), (4, \"bar\"), (6, \"baz\")];\n    let expected = vec![(1, \"hello\"), (2, \"foo\"), (3, \"world\"), (4, \"bar\"), (5, \"!\"), (6, \"baz\")];\n    let results = odd.iter().merge_by(even.iter(), |a, b| a.0 <= b.0);\n    it::assert_equal(results, expected.iter());\n}\n\n#[test]\nfn merge_by_btree() {\n    use std::collections::BTreeMap;\n    let mut bt1 = BTreeMap::new();\n    bt1.insert(\"hello\", 1);\n    bt1.insert(\"world\", 3);\n    let mut bt2 = BTreeMap::new();\n    bt2.insert(\"foo\", 2);\n    bt2.insert(\"bar\", 4);\n    let results = bt1.into_iter().merge_by(bt2.into_iter(), |a, b| a.0 <= b.0 );\n    let expected = vec![(\"bar\", 4), (\"foo\", 2), (\"hello\", 1), (\"world\", 3)];\n    it::assert_equal(results, expected.into_iter());\n}\n\n#[allow(deprecated)]\n#[test]\nfn kmerge() {\n    let its = (0..4).map(|s| (s..10).step(4));\n\n    it::assert_equal(its.kmerge(), 0..10);\n}\n\n#[allow(deprecated)]\n#[test]\nfn kmerge_2() {\n    let its = vec![3, 2, 1, 0].into_iter().map(|s| (s..10).step(4));\n\n    it::assert_equal(its.kmerge(), 0..10);\n}\n\n#[test]\nfn kmerge_empty() {\n    let its = (0..4).map(|_| 0..0);\n    assert_eq!(its.kmerge().next(), None);\n}\n\n#[test]\nfn kmerge_size_hint() {\n    let its = (0..5).map(|_| (0..10));\n    assert_eq!(its.kmerge().size_hint(), (50, Some(50)));\n}\n\n#[test]\nfn kmerge_empty_size_hint() {\n    let its = (0..5).map(|_| (0..0));\n    assert_eq!(its.kmerge().size_hint(), (0, Some(0)));\n}\n\n#[test]\nfn join() {\n    let many = [1, 2, 3];\n    let one  = [1];\n    let none: Vec<i32> = vec![];\n\n    assert_eq!(many.iter().join(\", \"), \"1, 2, 3\");\n    assert_eq!( one.iter().join(\", \"), \"1\");\n    assert_eq!(none.iter().join(\", \"), \"\");\n}\n\n#[test]\nfn sorted_by() {\n    let sc = [3, 4, 1, 2].iter().cloned().sorted_by(|&a, &b| {\n        a.cmp(&b)\n    });\n    it::assert_equal(sc, vec![1, 2, 3, 4]);\n\n    let v = (0..5).sorted_by(|&a, &b| a.cmp(&b).reverse());\n    it::assert_equal(v, vec![4, 3, 2, 1, 0]);\n}\n\n#[test]\nfn sorted_by_key() {\n    let sc = [3, 4, 1, 2].iter().cloned().sorted_by_key(|&x| x);\n    it::assert_equal(sc, vec![1, 2, 3, 4]);\n\n    let v = (0..5).sorted_by_key(|&x| -x);\n    it::assert_equal(v, vec![4, 3, 2, 1, 0]);\n}\n\n#[test]\nfn test_multipeek() {\n    let nums = vec![1u8,2,3,4,5];\n\n    let mp = multipeek(nums.iter().map(|&x| x));\n    assert_eq!(nums, mp.collect::<Vec<_>>());\n\n    let mut mp = multipeek(nums.iter().map(|&x| x));\n    assert_eq!(mp.peek(), Some(&1));\n    assert_eq!(mp.next(), Some(1));\n    assert_eq!(mp.peek(), Some(&2));\n    assert_eq!(mp.peek(), Some(&3));\n    assert_eq!(mp.next(), Some(2));\n    assert_eq!(mp.peek(), Some(&3));\n    assert_eq!(mp.peek(), Some(&4));\n    assert_eq!(mp.peek(), Some(&5));\n    assert_eq!(mp.peek(), None);\n    assert_eq!(mp.next(), Some(3));\n    assert_eq!(mp.next(), Some(4));\n    assert_eq!(mp.peek(), Some(&5));\n    assert_eq!(mp.peek(), None);\n    assert_eq!(mp.next(), Some(5));\n    assert_eq!(mp.next(), None);\n    assert_eq!(mp.peek(), None);\n\n}\n\n#[test]\nfn test_multipeek_reset() {\n    let data = [1, 2, 3, 4];\n\n    let mut mp = multipeek(cloned(&data));\n    assert_eq!(mp.peek(), Some(&1));\n    assert_eq!(mp.next(), Some(1));\n    assert_eq!(mp.peek(), Some(&2));\n    assert_eq!(mp.peek(), Some(&3));\n    mp.reset_peek();\n    assert_eq!(mp.peek(), Some(&2));\n    assert_eq!(mp.next(), Some(2));\n}\n\n#[test]\nfn test_multipeek_peeking_next() {\n    use crate::it::PeekingNext;\n    let nums = vec![1u8,2,3,4,5,6,7];\n\n    let mut mp = multipeek(nums.iter().map(|&x| x));\n    assert_eq!(mp.peeking_next(|&x| x != 0), Some(1));\n    assert_eq!(mp.next(), Some(2));\n    assert_eq!(mp.peek(), Some(&3));\n    assert_eq!(mp.peek(), Some(&4));\n    assert_eq!(mp.peeking_next(|&x| x == 3), Some(3));\n    assert_eq!(mp.peek(), Some(&4));\n    assert_eq!(mp.peeking_next(|&x| x != 4), None);\n    assert_eq!(mp.peeking_next(|&x| x == 4), Some(4));\n    assert_eq!(mp.peek(), Some(&5));\n    assert_eq!(mp.peek(), Some(&6));\n    assert_eq!(mp.peeking_next(|&x| x != 5), None);\n    assert_eq!(mp.peek(), Some(&7));\n    assert_eq!(mp.peeking_next(|&x| x == 5), Some(5));\n    assert_eq!(mp.peeking_next(|&x| x == 6), Some(6));\n    assert_eq!(mp.peek(), Some(&7));\n    assert_eq!(mp.peek(), None);\n    assert_eq!(mp.next(), Some(7));\n    assert_eq!(mp.peek(), None);\n}\n\n#[test]\nfn test_peek_nth() {\n    let nums = vec![1u8,2,3,4,5];\n\n    let iter = peek_nth(nums.iter().map(|&x| x));\n    assert_eq!(nums, iter.collect::<Vec<_>>());\n\n    let mut iter = peek_nth(nums.iter().map(|&x| x));\n\n    assert_eq!(iter.peek_nth(0), Some(&1));\n    assert_eq!(iter.peek_nth(0), Some(&1));\n    assert_eq!(iter.next(), Some(1));\n\n    assert_eq!(iter.peek_nth(0), Some(&2));\n    assert_eq!(iter.peek_nth(1), Some(&3));\n    assert_eq!(iter.next(), Some(2));\n\n    assert_eq!(iter.peek_nth(0), Some(&3));\n    assert_eq!(iter.peek_nth(1), Some(&4));\n    assert_eq!(iter.peek_nth(2), Some(&5));\n    assert_eq!(iter.peek_nth(3), None);\n\n    assert_eq!(iter.next(), Some(3));\n    assert_eq!(iter.next(), Some(4));\n\n    assert_eq!(iter.peek_nth(0), Some(&5));\n    assert_eq!(iter.peek_nth(1), None);\n    assert_eq!(iter.next(), Some(5));\n    assert_eq!(iter.next(), None);\n\n    assert_eq!(iter.peek_nth(0), None);\n    assert_eq!(iter.peek_nth(1), None);\n}\n\n#[test]\nfn test_peek_nth_peeking_next() {\n    use it::PeekingNext;\n    let nums = vec![1u8,2,3,4,5,6,7];\n    let mut iter = peek_nth(nums.iter().map(|&x| x));\n\n    assert_eq!(iter.peeking_next(|&x| x != 0), Some(1));\n    assert_eq!(iter.next(), Some(2));\n\n    assert_eq!(iter.peek_nth(0), Some(&3));\n    assert_eq!(iter.peek_nth(1), Some(&4));\n    assert_eq!(iter.peeking_next(|&x| x == 3), Some(3));\n    assert_eq!(iter.peek(), Some(&4));\n\n    assert_eq!(iter.peeking_next(|&x| x != 4), None);\n    assert_eq!(iter.peeking_next(|&x| x == 4), Some(4));\n    assert_eq!(iter.peek_nth(0), Some(&5));\n    assert_eq!(iter.peek_nth(1), Some(&6));\n\n    assert_eq!(iter.peeking_next(|&x| x != 5), None);\n    assert_eq!(iter.peek(), Some(&5));\n\n    assert_eq!(iter.peeking_next(|&x| x == 5), Some(5));\n    assert_eq!(iter.peeking_next(|&x| x == 6), Some(6));\n    assert_eq!(iter.peek_nth(0), Some(&7));\n    assert_eq!(iter.peek_nth(1), None);\n    assert_eq!(iter.next(), Some(7));\n    assert_eq!(iter.peek(), None);\n}\n\n#[test]\nfn pad_using() {\n    it::assert_equal((0..0).pad_using(1, |_| 1), 1..2);\n\n    let v: Vec<usize> = vec![0, 1, 2];\n    let r = v.into_iter().pad_using(5, |n| n);\n    it::assert_equal(r, vec![0, 1, 2, 3, 4]);\n\n    let v: Vec<usize> = vec![0, 1, 2];\n    let r = v.into_iter().pad_using(1, |_| panic!());\n    it::assert_equal(r, vec![0, 1, 2]);\n}\n\n#[test]\nfn group_by() {\n    for (ch1, sub) in &\"AABBCCC\".chars().group_by(|&x| x) {\n        for ch2 in sub {\n            assert_eq!(ch1, ch2);\n        }\n    }\n\n    for (ch1, sub) in &\"AAABBBCCCCDDDD\".chars().group_by(|&x| x) {\n        for ch2 in sub {\n            assert_eq!(ch1, ch2);\n            if ch1 == 'C' {\n                break;\n            }\n        }\n    }\n\n    let toupper = |ch: &char| ch.to_uppercase().nth(0).unwrap();\n\n    // try all possible orderings\n    for indices in permutohedron::Heap::new(&mut [0, 1, 2, 3]) {\n        let groups = \"AaaBbbccCcDDDD\".chars().group_by(&toupper);\n        let mut subs = groups.into_iter().collect_vec();\n\n        for &idx in &indices[..] {\n            let (key, text) = match idx {\n                 0 => ('A', \"Aaa\".chars()),\n                 1 => ('B', \"Bbb\".chars()),\n                 2 => ('C', \"ccCc\".chars()),\n                 3 => ('D', \"DDDD\".chars()),\n                 _ => unreachable!(),\n            };\n            assert_eq!(key, subs[idx].0);\n            it::assert_equal(&mut subs[idx].1, text);\n        }\n    }\n\n    let groups = \"AAABBBCCCCDDDD\".chars().group_by(|&x| x);\n    let mut subs = groups.into_iter().map(|(_, g)| g).collect_vec();\n\n    let sd = subs.pop().unwrap();\n    let sc = subs.pop().unwrap();\n    let sb = subs.pop().unwrap();\n    let sa = subs.pop().unwrap();\n    for (a, b, c, d) in multizip((sa, sb, sc, sd)) {\n        assert_eq!(a, 'A');\n        assert_eq!(b, 'B');\n        assert_eq!(c, 'C');\n        assert_eq!(d, 'D');\n    }\n\n    // check that the key closure is called exactly n times\n    {\n        let mut ntimes = 0;\n        let text = \"AABCCC\";\n        for (_, sub) in &text.chars().group_by(|&x| { ntimes += 1; x}) {\n            for _ in sub {\n            }\n        }\n        assert_eq!(ntimes, text.len());\n    }\n\n    {\n        let mut ntimes = 0;\n        let text = \"AABCCC\";\n        for _ in &text.chars().group_by(|&x| { ntimes += 1; x}) {\n        }\n        assert_eq!(ntimes, text.len());\n    }\n\n    {\n        let text = \"ABCCCDEEFGHIJJKK\";\n        let gr = text.chars().group_by(|&x| x);\n        it::assert_equal(gr.into_iter().flat_map(|(_, sub)| sub), text.chars());\n    }\n}\n\n#[test]\nfn group_by_lazy_2() {\n    let data = vec![0, 1];\n    let groups = data.iter().group_by(|k| *k);\n    let gs = groups.into_iter().collect_vec();\n    it::assert_equal(data.iter(), gs.into_iter().flat_map(|(_k, g)| g));\n\n    let data = vec![0, 1, 1, 0, 0];\n    let groups = data.iter().group_by(|k| *k);\n    let mut gs = groups.into_iter().collect_vec();\n    gs[1..].reverse();\n    it::assert_equal(&[0, 0, 0, 1, 1], gs.into_iter().flat_map(|(_, g)| g));\n\n    let grouper = data.iter().group_by(|k| *k);\n    let mut groups = Vec::new();\n    for (k, group) in &grouper {\n        if *k == 1 {\n            groups.push(group);\n        }\n    }\n    it::assert_equal(&mut groups[0], &[1, 1]);\n\n    let data = vec![0, 0, 0, 1, 1, 0, 0, 2, 2, 3, 3];\n    let grouper = data.iter().group_by(|k| *k);\n    let mut groups = Vec::new();\n    for (i, (_, group)) in grouper.into_iter().enumerate() {\n        if i < 2 {\n            groups.push(group);\n        } else if i < 4 {\n            for _ in group {\n            }\n        } else {\n            groups.push(group);\n        }\n    }\n    it::assert_equal(&mut groups[0], &[0, 0, 0]);\n    it::assert_equal(&mut groups[1], &[1, 1]);\n    it::assert_equal(&mut groups[2], &[3, 3]);\n\n    // use groups as chunks\n    let data = vec![0, 0, 0, 1, 1, 0, 0, 2, 2, 3, 3];\n    let mut i = 0;\n    let grouper = data.iter().group_by(move |_| { let k = i / 3; i += 1; k });\n    for (i, group) in &grouper {\n        match i {\n            0 => it::assert_equal(group, &[0, 0, 0]),\n            1 => it::assert_equal(group, &[1, 1, 0]),\n            2 => it::assert_equal(group, &[0, 2, 2]),\n            3 => it::assert_equal(group, &[3, 3]),\n            _ => unreachable!(),\n        }\n    }\n}\n\n#[test]\nfn group_by_lazy_3() {\n    // test consuming each group on the lap after it was produced\n    let data = vec![0, 0, 0, 1, 1, 0, 0, 1, 1, 2, 2];\n    let grouper = data.iter().group_by(|elt| *elt);\n    let mut last = None;\n    for (key, group) in &grouper {\n        if let Some(gr) = last.take() {\n            for elt in gr {\n                assert!(elt != key && i32::abs(elt - key) == 1);\n            }\n        }\n        last = Some(group);\n    }\n}\n\n#[test]\nfn chunks() {\n    let data = vec![0, 0, 0, 1, 1, 0, 0, 2, 2, 3, 3];\n    let grouper = data.iter().chunks(3);\n    for (i, chunk) in grouper.into_iter().enumerate() {\n        match i {\n            0 => it::assert_equal(chunk, &[0, 0, 0]),\n            1 => it::assert_equal(chunk, &[1, 1, 0]),\n            2 => it::assert_equal(chunk, &[0, 2, 2]),\n            3 => it::assert_equal(chunk, &[3, 3]),\n            _ => unreachable!(),\n        }\n    }\n}\n\n#[test]\nfn concat_empty() {\n    let data: Vec<Vec<()>> = Vec::new();\n    assert_eq!(data.into_iter().concat(), Vec::new())\n}\n\n#[test]\nfn concat_non_empty() {\n    let data = vec![vec![1,2,3], vec![4,5,6], vec![7,8,9]];\n    assert_eq!(data.into_iter().concat(), vec![1,2,3,4,5,6,7,8,9])\n}\n\n#[test]\nfn combinations() {\n    assert!((1..3).combinations(5).next().is_none());\n\n    let it = (1..3).combinations(2);\n    it::assert_equal(it, vec![\n        vec![1, 2],\n        ]);\n\n    let it = (1..5).combinations(2);\n    it::assert_equal(it, vec![\n        vec![1, 2],\n        vec![1, 3],\n        vec![1, 4],\n        vec![2, 3],\n        vec![2, 4],\n        vec![3, 4],\n        ]);\n\n    it::assert_equal((0..0).tuple_combinations::<(_, _)>(), <Vec<_>>::new());\n    it::assert_equal((0..1).tuple_combinations::<(_, _)>(), <Vec<_>>::new());\n    it::assert_equal((0..2).tuple_combinations::<(_, _)>(), vec![(0, 1)]);\n\n    it::assert_equal((0..0).combinations(2), <Vec<Vec<_>>>::new());\n    it::assert_equal((0..1).combinations(1), vec![vec![0]]);\n    it::assert_equal((0..2).combinations(1), vec![vec![0], vec![1]]);\n    it::assert_equal((0..2).combinations(2), vec![vec![0, 1]]);\n}\n\n#[test]\nfn combinations_of_too_short() {\n    for i in 1..10 {\n        assert!((0..0).combinations(i).next().is_none());\n        assert!((0..i - 1).combinations(i).next().is_none());\n    }\n}\n\n\n#[test]\nfn combinations_zero() {\n    it::assert_equal((1..3).combinations(0), vec![vec![]]);\n    it::assert_equal((0..0).combinations(0), vec![vec![]]);\n}\n\n#[test]\nfn permutations_zero() {\n    it::assert_equal((1..3).permutations(0), vec![vec![]]);\n    it::assert_equal((0..0).permutations(0), vec![vec![]]);\n}\n\n#[test]\nfn combinations_with_replacement() {\n    // Pool smaller than n\n    it::assert_equal((0..1).combinations_with_replacement(2), vec![vec![0, 0]]);\n    // Pool larger than n\n    it::assert_equal(\n        (0..3).combinations_with_replacement(2),\n        vec![\n            vec![0, 0],\n            vec![0, 1],\n            vec![0, 2],\n            vec![1, 1],\n            vec![1, 2],\n            vec![2, 2],\n        ],\n    );\n    // Zero size\n    it::assert_equal(\n        (0..3).combinations_with_replacement(0),\n        vec![vec![]],\n    );\n    // Zero size on empty pool\n    it::assert_equal(\n        (0..0).combinations_with_replacement(0),\n        vec![vec![]],\n    );\n    // Empty pool\n    it::assert_equal(\n        (0..0).combinations_with_replacement(2),\n        <Vec<Vec<_>>>::new(),\n    );\n}\n\n#[test]\nfn diff_mismatch() {\n    let a = vec![1, 2, 3, 4];\n    let b = vec![1.0, 5.0, 3.0, 4.0];\n    let b_map = b.into_iter().map(|f| f as i32);\n    let diff = it::diff_with(a.iter(), b_map, |a, b| *a == b);\n\n    assert!(match diff {\n        Some(it::Diff::FirstMismatch(1, _, from_diff)) =>\n            from_diff.collect::<Vec<_>>() == vec![5, 3, 4],\n        _ => false,\n    });\n}\n\n#[test]\nfn diff_longer() {\n    let a = vec![1, 2, 3, 4];\n    let b = vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0];\n    let b_map = b.into_iter().map(|f| f as i32);\n    let diff = it::diff_with(a.iter(), b_map, |a, b| *a == b);\n\n    assert!(match diff {\n        Some(it::Diff::Longer(_, remaining)) =>\n            remaining.collect::<Vec<_>>() == vec![5, 6],\n        _ => false,\n    });\n}\n\n#[test]\nfn diff_shorter() {\n    let a = vec![1, 2, 3, 4];\n    let b = vec![1.0, 2.0];\n    let b_map = b.into_iter().map(|f| f as i32);\n    let diff = it::diff_with(a.iter(), b_map, |a, b| *a == b);\n\n    assert!(match diff {\n        Some(it::Diff::Shorter(len, _)) => len == 2,\n        _ => false,\n    });\n}\n\n#[test]\nfn minmax() {\n    use std::cmp::Ordering;\n    use crate::it::MinMaxResult;\n\n    // A peculiar type: Equality compares both tuple items, but ordering only the\n    // first item.  This is so we can check the stability property easily.\n    #[derive(Clone, Debug, PartialEq, Eq)]\n    struct Val(u32, u32);\n\n    impl PartialOrd<Val> for Val {\n        fn partial_cmp(&self, other: &Val) -> Option<Ordering> {\n            self.0.partial_cmp(&other.0)\n        }\n    }\n\n    impl Ord for Val {\n        fn cmp(&self, other: &Val) -> Ordering {\n            self.0.cmp(&other.0)\n        }\n    }\n\n    assert_eq!(None::<Option<u32>>.iter().minmax(), MinMaxResult::NoElements);\n\n    assert_eq!(Some(1u32).iter().minmax(), MinMaxResult::OneElement(&1));\n\n    let data = vec![Val(0, 1), Val(2, 0), Val(0, 2), Val(1, 0), Val(2, 1)];\n\n    let minmax = data.iter().minmax();\n    assert_eq!(minmax, MinMaxResult::MinMax(&Val(0, 1), &Val(2, 1)));\n\n    let (min, max) = data.iter().minmax_by_key(|v| v.1).into_option().unwrap();\n    assert_eq!(min, &Val(2, 0));\n    assert_eq!(max, &Val(0, 2));\n\n    let (min, max) = data.iter().minmax_by(|x, y| x.1.cmp(&y.1)).into_option().unwrap();\n    assert_eq!(min, &Val(2, 0));\n    assert_eq!(max, &Val(0, 2));\n}\n\n#[test]\nfn format() {\n    let data = [0, 1, 2, 3];\n    let ans1 = \"0, 1, 2, 3\";\n    let ans2 = \"0--1--2--3\";\n\n    let t1 = format!(\"{}\", data.iter().format(\", \"));\n    assert_eq!(t1, ans1);\n    let t2 = format!(\"{:?}\", data.iter().format(\"--\"));\n    assert_eq!(t2, ans2);\n\n    let dataf = [1.1, 2.71828, -22.];\n    let t3 = format!(\"{:.2e}\", dataf.iter().format(\", \"));\n    assert_eq!(t3, \"1.10e0, 2.72e0, -2.20e1\");\n}\n\n#[test]\nfn while_some() {\n    let ns = (1..10).map(|x| if x % 5 != 0 { Some(x) } else { None })\n                    .while_some();\n    it::assert_equal(ns, vec![1, 2, 3, 4]);\n}\n\n#[allow(deprecated)]\n#[test]\nfn fold_while() {\n    let mut iterations = 0;\n    let vec = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    let sum = vec.into_iter().fold_while(0, |acc, item| {\n        iterations += 1;\n        let new_sum = acc.clone() + item;\n        if new_sum <= 20 {\n            FoldWhile::Continue(new_sum)\n        } else {\n            FoldWhile::Done(acc)\n        }\n    }).into_inner();\n    assert_eq!(iterations, 6);\n    assert_eq!(sum, 15);\n}\n\n#[test]\nfn tree_fold1() {\n    let x = [\n        \"\",\n        \"0\",\n        \"0 1 x\",\n        \"0 1 x 2 x\",\n        \"0 1 x 2 3 x x\",\n        \"0 1 x 2 3 x x 4 x\",\n        \"0 1 x 2 3 x x 4 5 x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 9 x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 9 x 10 x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 9 x 10 11 x x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 9 x 10 11 x x 12 x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 9 x 10 11 x x 12 13 x x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 9 x 10 11 x x 12 13 x 14 x x x\",\n        \"0 1 x 2 3 x x 4 5 x 6 7 x x x 8 9 x 10 11 x x 12 13 x 14 15 x x x x\",\n    ];\n    for (i, &s) in x.iter().enumerate() {\n        let expected = if s == \"\" { None } else { Some(s.to_string()) };\n        let num_strings = (0..i).map(|x| x.to_string());\n        let actual = num_strings.tree_fold1(|a, b| format!(\"{} {} x\", a, b));\n        assert_eq!(actual, expected);\n    }\n}\n","traces":[{"line":15,"address":[4392080,4392016],"length":1,"stats":{"Line":3},"fn_name":"product3"},{"line":16,"address":[4392095,4392023],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[4392524,4392324],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[4392455],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[4392972,4393081,4392859,4393251],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[4393256,4393426,4393111],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[4393696,4393431,4393286],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[4393701,4393465,4394331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[4394200,4393742,4393027],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[4394636,4394496],"length":1,"stats":{"Line":3},"fn_name":"interleave_shortest"},{"line":33,"address":[4394503,4394651],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[4394669,4394754],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[4399229,4394762],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[4394967,4395200],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[4395570,4395086],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[4396191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[4396271,4396338],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[4396346,4399363],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[4396784,4396551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4397154,4396670],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[4397774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[4397812],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[4397860],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[4398159,4398092,4397961],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[4398108,4398495],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[4398508],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[4398530],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[4398755,4398636,4398779],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[4399776],"length":1,"stats":{"Line":3},"fn_name":"unique_by"},{"line":59,"address":[4399832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4399966],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[4400026],"length":1,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[4933672,4933648],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":63,"address":[4400303],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[4400363],"length":1,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[4400496],"length":1,"stats":{"Line":3},"fn_name":"unique"},{"line":69,"address":[4400503],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[4400580],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[4400624],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[4400756],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[4400946],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[4400990],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[4401131],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[4401153],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[4401175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[4401283],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[4401437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[4401459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[4401754,4401600],"length":1,"stats":{"Line":3},"fn_name":"intersperse"},{"line":86,"address":[4401628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[4401715,4401785],"length":1,"stats":{"Line":4},"fn_name":null},{"line":88,"address":[4401880],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[4402104,4401952],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[4402457],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[4402501],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[4402722,4402634],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[4402848,4403037],"length":1,"stats":{"Line":3},"fn_name":"dedup"},{"line":98,"address":[4402855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[4402943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[4402998,4403052],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[4403147],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[4403202],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[4403213],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[4403327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[4403415],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[4403470],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[4403564,4403496],"length":1,"stats":{"Line":4},"fn_name":null},{"line":109,"address":[4403603,4403746],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[4404776,4404080],"length":1,"stats":{"Line":3},"fn_name":"dedup_by"},{"line":114,"address":[4404087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[4404487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[4404737,4404791],"length":1,"stats":{"Line":4},"fn_name":null},{"line":117,"address":[4404886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[4405136],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[4405186],"length":1,"stats":{"Line":3},"fn_name":null},{"line":121,"address":[4405306],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[4405706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[4405956],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[4406050,4405982],"length":1,"stats":{"Line":6},"fn_name":null},{"line":125,"address":[4406089,4406232],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[4406576],"length":1,"stats":{"Line":3},"fn_name":"dedup_with_count"},{"line":130,"address":[4406583],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[4406647],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[4406942],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[4407072],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[4407127],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[4407186],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[4407328],"length":1,"stats":{"Line":3},"fn_name":"dedup_by_with_count"},{"line":144,"address":[4407335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[4407717],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[4408012],"length":1,"stats":{"Line":3},"fn_name":null},{"line":149,"address":[4408142],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[4408392],"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[4408451],"length":1,"stats":{"Line":3},"fn_name":null},{"line":156,"address":[4408635,4408592],"length":1,"stats":{"Line":3},"fn_name":"all_equal"},{"line":157,"address":[4408650,4408703,4408599],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[4408674,4408733,4408786],"length":1,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[4408757,4408816,4408871],"length":1,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[4408842,4408957,4408901],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[4409400,4408932,4408987,4409308],"length":1,"stats":{"Line":6},"fn_name":null},{"line":162,"address":[4409324,4409362,4409289],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[4409536,4409653],"length":1,"stats":{"Line":3},"fn_name":"test_put_back_n"},{"line":168,"address":[4409543],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[4409623,4409678],"length":1,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[4409726],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[4409738],"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[4409755],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[4409769],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[4409983,4409776],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[4410064,4410210],"length":1,"stats":{"Line":3},"fn_name":"tee"},{"line":179,"address":[4410071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[4410241,4410171],"length":1,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[4410420,4410582,4410359],"length":1,"stats":{"Line":2},"fn_name":null},{"line":182,"address":[4411111,4410558,4410949],"length":1,"stats":{"Line":2},"fn_name":null},{"line":183,"address":[4411087,4411478,4411640],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[4412169,4411616,4412007],"length":1,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[4412145,4412536,4412698],"length":1,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[4412674,4413227,4413065],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[4413594,4413203,4413756],"length":1,"stats":{"Line":2},"fn_name":null},{"line":188,"address":[4413732,4414123,4414285],"length":1,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[4414652,4414261,4414814],"length":1,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[4415343,4414790,4415181],"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[4415872,4415319,4415710],"length":1,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[4415848,4416239,4416401],"length":1,"stats":{"Line":2},"fn_name":null},{"line":193,"address":[4416768,4416937,4416377],"length":1,"stats":{"Line":2},"fn_name":null},{"line":195,"address":[4417313,4416911],"length":1,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[4417443,4417576,4418417],"length":1,"stats":{"Line":2},"fn_name":null},{"line":197,"address":[4418458,4417654],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[4417837],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[4417982,4418081,4418551],"length":1,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[4418736,4418905],"length":1,"stats":{"Line":3},"fn_name":"test_rciter"},{"line":206,"address":[4418743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[4418866,4418936],"length":1,"stats":{"Line":2},"fn_name":null},{"line":209,"address":[4419002],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[4419049,4419239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[4419786,4419215,4419606],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[4419736],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[4420325,4420162,4420293],"length":1,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[4420823,4420685,4420315],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[4420813,4421183,4421321],"length":1,"stats":{"Line":2},"fn_name":null},{"line":216,"address":[4421681,4421311,4421847],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[4422197,4421793],"length":1,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[4422221],"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[4422404,4422285,4422428],"length":1,"stats":{"Line":2},"fn_name":null},{"line":226,"address":[4422992,4423112],"length":1,"stats":{"Line":3},"fn_name":"trait_pointers"},{"line":233,"address":[4934736],"length":1,"stats":{"Line":1},"fn_name":"next<i32,Iterator>"},{"line":235,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":239,"address":[4423135,4423110,4422999],"length":1,"stats":{"Line":3},"fn_name":null},{"line":240,"address":[4423166,4423209,4423415],"length":1,"stats":{"Line":2},"fn_name":null},{"line":244,"address":[4423339],"length":1,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[4423976,4423371,4423782],"length":1,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[4423920],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[4424507,4424343,4423952],"length":1,"stats":{"Line":2},"fn_name":null},{"line":252,"address":[4424837,4424963,4424497],"length":1,"stats":{"Line":4},"fn_name":null},{"line":253,"address":[4424953],"length":1,"stats":{"Line":3},"fn_name":null},{"line":258,"address":[4425591,4425312],"length":1,"stats":{"Line":3},"fn_name":"merge_by"},{"line":259,"address":[4425319],"length":1,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[4425616],"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[4425857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[4426372,4426285],"length":1,"stats":{"Line":4},"fn_name":null},{"line":263,"address":[4426451],"length":1,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[4426720,4426787],"length":1,"stats":{"Line":3},"fn_name":"merge_by_btree"},{"line":269,"address":[4426727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[4426802],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[4426831],"length":1,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[4426865],"length":1,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[4426872],"length":1,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[4426909],"length":1,"stats":{"Line":1},"fn_name":null},{"line":275,"address":[4427660,4426938],"length":1,"stats":{"Line":3},"fn_name":null},{"line":276,"address":[4427122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[4427715,4427416],"length":1,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[4427856],"length":1,"stats":{"Line":3},"fn_name":"kmerge"},{"line":283,"address":[4427860],"length":1,"stats":{"Line":3},"fn_name":null},{"line":285,"address":[4427904],"length":1,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[4427968],"length":1,"stats":{"Line":3},"fn_name":"kmerge_2"},{"line":291,"address":[4427975],"length":1,"stats":{"Line":3},"fn_name":null},{"line":293,"address":[4428066],"length":1,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[4428252,4428192],"length":1,"stats":{"Line":3},"fn_name":"kmerge_empty"},{"line":298,"address":[4428199],"length":1,"stats":{"Line":3},"fn_name":null},{"line":299,"address":[4428267],"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[4428800,4428860],"length":1,"stats":{"Line":3},"fn_name":"kmerge_size_hint"},{"line":304,"address":[4428807],"length":1,"stats":{"Line":3},"fn_name":null},{"line":305,"address":[4428875],"length":1,"stats":{"Line":1},"fn_name":null},{"line":309,"address":[4429436,4429376],"length":1,"stats":{"Line":3},"fn_name":"kmerge_empty_size_hint"},{"line":310,"address":[4429383],"length":1,"stats":{"Line":3},"fn_name":null},{"line":311,"address":[4429451],"length":1,"stats":{"Line":1},"fn_name":null},{"line":315,"address":[4429952,4430018],"length":1,"stats":{"Line":3},"fn_name":"join"},{"line":316,"address":[4429959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":317,"address":[4429992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":318,"address":[4430003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":320,"address":[4430046,4430154],"length":1,"stats":{"Line":2},"fn_name":null},{"line":321,"address":[4430677],"length":1,"stats":{"Line":1},"fn_name":null},{"line":322,"address":[4431279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":326,"address":[4432132,4431936],"length":1,"stats":{"Line":3},"fn_name":"sorted_by"},{"line":327,"address":[4431943],"length":1,"stats":{"Line":3},"fn_name":null},{"line":328,"address":[4935503],"length":1,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[4432147,4432419,4432034],"length":1,"stats":{"Line":1},"fn_name":null},{"line":332,"address":[4432196],"length":1,"stats":{"Line":3},"fn_name":null},{"line":333,"address":[4432245,4432442],"length":1,"stats":{"Line":1},"fn_name":null},{"line":337,"address":[4432708,4432512],"length":1,"stats":{"Line":3},"fn_name":"sorted_by_key"},{"line":338,"address":[4432519],"length":1,"stats":{"Line":3},"fn_name":null},{"line":339,"address":[4432995,4432723,4432610],"length":1,"stats":{"Line":1},"fn_name":null},{"line":341,"address":[4432772],"length":1,"stats":{"Line":3},"fn_name":null},{"line":342,"address":[4433018,4432821],"length":1,"stats":{"Line":1},"fn_name":null},{"line":346,"address":[4433088,4433161],"length":1,"stats":{"Line":3},"fn_name":"test_multipeek"},{"line":347,"address":[4433101],"length":1,"stats":{"Line":1},"fn_name":null},{"line":349,"address":[4433184,4433277],"length":1,"stats":{"Line":4},"fn_name":null},{"line":350,"address":[4433331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":352,"address":[4433935],"length":1,"stats":{"Line":3},"fn_name":null},{"line":353,"address":[4434268,4434075,4434230],"length":1,"stats":{"Line":2},"fn_name":null},{"line":354,"address":[4434244,4434791,4434635],"length":1,"stats":{"Line":2},"fn_name":null},{"line":355,"address":[4435305,4434773,4435159],"length":1,"stats":{"Line":2},"fn_name":null},{"line":356,"address":[4435825,4435287,4435673],"length":1,"stats":{"Line":2},"fn_name":null},{"line":357,"address":[4435801,4436192,4436348],"length":1,"stats":{"Line":2},"fn_name":null},{"line":358,"address":[4436330,4436716,4436862],"length":1,"stats":{"Line":2},"fn_name":null},{"line":359,"address":[4436844,4437230,4437376],"length":1,"stats":{"Line":2},"fn_name":null},{"line":360,"address":[4437890,4437358,4437744],"length":1,"stats":{"Line":2},"fn_name":null},{"line":361,"address":[4438410,4437872,4438258],"length":1,"stats":{"Line":2},"fn_name":null},{"line":362,"address":[4438777,4438386,4438939],"length":1,"stats":{"Line":2},"fn_name":null},{"line":363,"address":[4438915,4439306,4439462],"length":1,"stats":{"Line":2},"fn_name":null},{"line":364,"address":[4439976,4439444,4439830],"length":1,"stats":{"Line":2},"fn_name":null},{"line":365,"address":[4440344,4440496,4439958],"length":1,"stats":{"Line":2},"fn_name":null},{"line":366,"address":[4441025,4440472,4440863],"length":1,"stats":{"Line":2},"fn_name":null},{"line":367,"address":[4441392,4441548,4441001],"length":1,"stats":{"Line":2},"fn_name":null},{"line":368,"address":[4442012,4441530,4441886],"length":1,"stats":{"Line":2},"fn_name":null},{"line":373,"address":[4442400,4442482],"length":1,"stats":{"Line":3},"fn_name":"test_multipeek_reset"},{"line":374,"address":[4442407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":376,"address":[4442497,4442451],"length":1,"stats":{"Line":2},"fn_name":null},{"line":377,"address":[4442689,4442534,4442727],"length":1,"stats":{"Line":2},"fn_name":null},{"line":378,"address":[4443094,4443250,4442703],"length":1,"stats":{"Line":2},"fn_name":null},{"line":379,"address":[4443618,4443764,4443232],"length":1,"stats":{"Line":2},"fn_name":null},{"line":380,"address":[4444132,4444270,4443746],"length":1,"stats":{"Line":2},"fn_name":null},{"line":381,"address":[4444260],"length":1,"stats":{"Line":1},"fn_name":null},{"line":382,"address":[4444638,4444813],"length":1,"stats":{"Line":1},"fn_name":null},{"line":383,"address":[4445150,4444789,4445286],"length":1,"stats":{"Line":2},"fn_name":null},{"line":387,"address":[4445713,4445632],"length":1,"stats":{"Line":3},"fn_name":"test_multipeek_peeking_next"},{"line":389,"address":[4445645],"length":1,"stats":{"Line":1},"fn_name":null},{"line":391,"address":[4445736,4445829],"length":1,"stats":{"Line":4},"fn_name":null},{"line":392,"address":[4446061,4445891,4446099],"length":1,"stats":{"Line":4},"fn_name":null},{"line":393,"address":[4446466,4446622,4446075],"length":1,"stats":{"Line":2},"fn_name":null},{"line":394,"address":[4446604,4446990,4447136],"length":1,"stats":{"Line":2},"fn_name":null},{"line":395,"address":[4447118,4447504,4447656],"length":1,"stats":{"Line":2},"fn_name":null},{"line":396,"address":[4448179,4448023,4447632],"length":1,"stats":{"Line":4},"fn_name":null},{"line":397,"address":[4448547,4448161,4448699],"length":1,"stats":{"Line":2},"fn_name":null},{"line":398,"address":[4449228,4449066,4448675],"length":1,"stats":{"Line":4},"fn_name":null},{"line":399,"address":[4449204,4449595,4449751],"length":1,"stats":{"Line":4},"fn_name":null},{"line":400,"address":[4450265,4449733,4450119],"length":1,"stats":{"Line":2},"fn_name":null},{"line":401,"address":[4450247,4450633,4450785],"length":1,"stats":{"Line":2},"fn_name":null},{"line":402,"address":[4451152,4450761,4451308],"length":1,"stats":{"Line":4},"fn_name":null},{"line":403,"address":[4451290,4451676,4451828],"length":1,"stats":{"Line":2},"fn_name":null},{"line":404,"address":[4452357,4451804,4452195],"length":1,"stats":{"Line":4},"fn_name":null},{"line":405,"address":[4452724,4452333,4452880],"length":1,"stats":{"Line":4},"fn_name":null},{"line":406,"address":[4453248,4453394,4452862],"length":1,"stats":{"Line":2},"fn_name":null},{"line":407,"address":[4453914,4453762,4453376],"length":1,"stats":{"Line":2},"fn_name":null},{"line":408,"address":[4454281,4453890,4454437],"length":1,"stats":{"Line":2},"fn_name":null},{"line":409,"address":[4454907,4454781,4454419],"length":1,"stats":{"Line":2},"fn_name":null},{"line":413,"address":[4455353,4455280],"length":1,"stats":{"Line":3},"fn_name":"test_peek_nth"},{"line":414,"address":[4455293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":416,"address":[4455376,4455469],"length":1,"stats":{"Line":4},"fn_name":null},{"line":417,"address":[4455523],"length":1,"stats":{"Line":1},"fn_name":null},{"line":419,"address":[4456111],"length":1,"stats":{"Line":3},"fn_name":null},{"line":421,"address":[4456446,4456255,4456410],"length":1,"stats":{"Line":2},"fn_name":null},{"line":422,"address":[4456428,4456814,4456966],"length":1,"stats":{"Line":2},"fn_name":null},{"line":423,"address":[4456942,4457333,4457493],"length":1,"stats":{"Line":2},"fn_name":null},{"line":425,"address":[4457475,4457861,4458012],"length":1,"stats":{"Line":2},"fn_name":null},{"line":426,"address":[4458380,4458532,4457994],"length":1,"stats":{"Line":2},"fn_name":null},{"line":427,"address":[4459059,4458508,4458899],"length":1,"stats":{"Line":2},"fn_name":null},{"line":429,"address":[4459041,4459427,4459578],"length":1,"stats":{"Line":2},"fn_name":null},{"line":430,"address":[4460097,4459560,4459946],"length":1,"stats":{"Line":2},"fn_name":null},{"line":431,"address":[4460616,4460465,4460079],"length":1,"stats":{"Line":2},"fn_name":null},{"line":432,"address":[4460598,4461136,4460984],"length":1,"stats":{"Line":2},"fn_name":null},{"line":434,"address":[4461665,4461112,4461503],"length":1,"stats":{"Line":2},"fn_name":null},{"line":435,"address":[4462192,4461641,4462032],"length":1,"stats":{"Line":2},"fn_name":null},{"line":437,"address":[4462560,4462711,4462174],"length":1,"stats":{"Line":2},"fn_name":null},{"line":438,"address":[4463231,4462693,4463079],"length":1,"stats":{"Line":2},"fn_name":null},{"line":439,"address":[4463760,4463207,4463598],"length":1,"stats":{"Line":2},"fn_name":null},{"line":440,"address":[4464287,4463736,4464127],"length":1,"stats":{"Line":2},"fn_name":null},{"line":442,"address":[4464655,4464806,4464269],"length":1,"stats":{"Line":2},"fn_name":null},{"line":443,"address":[4465150,4465276,4464788],"length":1,"stats":{"Line":2},"fn_name":null},{"line":447,"address":[4465745,4465664],"length":1,"stats":{"Line":3},"fn_name":"test_peek_nth_peeking_next"},{"line":449,"address":[4465677],"length":1,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[4465861,4465768],"length":1,"stats":{"Line":4},"fn_name":null},{"line":452,"address":[4465923,4466131,4466093],"length":1,"stats":{"Line":4},"fn_name":null},{"line":453,"address":[4466498,4466658,4466107],"length":1,"stats":{"Line":2},"fn_name":null},{"line":455,"address":[4466640,4467026,4467177],"length":1,"stats":{"Line":2},"fn_name":null},{"line":456,"address":[4467697,4467159,4467545],"length":1,"stats":{"Line":2},"fn_name":null},{"line":457,"address":[4468064,4468220,4467673],"length":1,"stats":{"Line":4},"fn_name":null},{"line":458,"address":[4468740,4468588,4468202],"length":1,"stats":{"Line":2},"fn_name":null},{"line":460,"address":[4469269,4468716,4469107],"length":1,"stats":{"Line":4},"fn_name":null},{"line":461,"address":[4469245,4469636,4469796],"length":1,"stats":{"Line":4},"fn_name":null},{"line":462,"address":[4470315,4470164,4469778],"length":1,"stats":{"Line":2},"fn_name":null},{"line":463,"address":[4470297,4470683,4470835],"length":1,"stats":{"Line":2},"fn_name":null},{"line":465,"address":[4471358,4470811,4471202],"length":1,"stats":{"Line":4},"fn_name":null},{"line":466,"address":[4471726,4471878,4471340],"length":1,"stats":{"Line":2},"fn_name":null},{"line":468,"address":[4472245,4472407,4471854],"length":1,"stats":{"Line":4},"fn_name":null},{"line":469,"address":[4472774,4472934,4472383],"length":1,"stats":{"Line":4},"fn_name":null},{"line":470,"address":[4473453,4473302,4472916],"length":1,"stats":{"Line":2},"fn_name":null},{"line":471,"address":[4473435,4473973,4473821],"length":1,"stats":{"Line":2},"fn_name":null},{"line":472,"address":[4474340,4474496,4473949],"length":1,"stats":{"Line":2},"fn_name":null},{"line":473,"address":[4474834,4474478,4474960],"length":1,"stats":{"Line":2},"fn_name":null},{"line":477,"address":[4475390,4475328],"length":1,"stats":{"Line":3},"fn_name":"pad_using"},{"line":478,"address":[4475335,4475405],"length":1,"stats":{"Line":4},"fn_name":null},{"line":480,"address":[4475437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":481,"address":[4475496],"length":1,"stats":{"Line":3},"fn_name":null},{"line":482,"address":[4475573,4476091],"length":1,"stats":{"Line":1},"fn_name":null},{"line":484,"address":[4475755],"length":1,"stats":{"Line":1},"fn_name":null},{"line":485,"address":[4475817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":486,"address":[4476117,4475912],"length":1,"stats":{"Line":1},"fn_name":null},{"line":490,"address":[4476307,4476192],"length":1,"stats":{"Line":3},"fn_name":"group_by"},{"line":491,"address":[4476697,4476212,4476322,4477363],"length":1,"stats":{"Line":6},"fn_name":null},{"line":492,"address":[4476715,4476862,4476810,4476990,4476634],"length":1,"stats":{"Line":4},"fn_name":null},{"line":493,"address":[4476995,4476892],"length":1,"stats":{"Line":1},"fn_name":null},{"line":497,"address":[4477375,4478479,4477782],"length":1,"stats":{"Line":5},"fn_name":null},{"line":498,"address":[4477800,4477719,4478461,4477895],"length":1,"stats":{"Line":4},"fn_name":null},{"line":499,"address":[4477964,4478101],"length":1,"stats":{"Line":1},"fn_name":null},{"line":500,"address":[4478082],"length":1,"stats":{"Line":1},"fn_name":null},{"line":501,"address":[4478466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":506,"address":[4936814,4936800],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":509,"address":[4478484,4478717,4480450],"length":1,"stats":{"Line":2},"fn_name":null},{"line":510,"address":[4478982],"length":1,"stats":{"Line":1},"fn_name":null},{"line":511,"address":[4479056],"length":1,"stats":{"Line":1},"fn_name":null},{"line":513,"address":[4479112,4480432,4479327,4479217],"length":1,"stats":{"Line":3},"fn_name":null},{"line":514,"address":[4479773,4479610,4479527,4479693],"length":1,"stats":{"Line":4},"fn_name":null},{"line":515,"address":[4479367,4479449],"length":1,"stats":{"Line":2},"fn_name":null},{"line":516,"address":[4479532],"length":1,"stats":{"Line":1},"fn_name":null},{"line":517,"address":[4479615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":518,"address":[4479695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":521,"address":[4479819,4480034],"length":1,"stats":{"Line":1},"fn_name":null},{"line":522,"address":[4479993,4480402],"length":1,"stats":{"Line":2},"fn_name":null},{"line":526,"address":[4478683,4480455],"length":1,"stats":{"Line":4},"fn_name":null},{"line":527,"address":[4480492,4480564],"length":1,"stats":{"Line":4},"fn_name":null},{"line":529,"address":[4480639,4480587],"length":1,"stats":{"Line":2},"fn_name":null},{"line":530,"address":[4480663],"length":1,"stats":{"Line":1},"fn_name":null},{"line":531,"address":[4480724],"length":1,"stats":{"Line":1},"fn_name":null},{"line":532,"address":[4480785],"length":1,"stats":{"Line":1},"fn_name":null},{"line":533,"address":[4481265,4481221,4480822,4482914],"length":1,"stats":{"Line":3},"fn_name":null},{"line":534,"address":[4481622,4481419],"length":1,"stats":{"Line":1},"fn_name":null},{"line":535,"address":[4482088,4481516],"length":1,"stats":{"Line":1},"fn_name":null},{"line":536,"address":[4481982,4482554],"length":1,"stats":{"Line":1},"fn_name":null},{"line":537,"address":[4482448,4482919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":542,"address":[4483279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":543,"address":[4483291],"length":1,"stats":{"Line":1},"fn_name":null},{"line":544,"address":[4483323,4483747,4483934],"length":1,"stats":{"Line":5},"fn_name":null},{"line":545,"address":[4483757,4483901,4483676,4483852],"length":1,"stats":{"Line":3},"fn_name":null},{"line":548,"address":[4484155,4483939],"length":1,"stats":{"Line":1},"fn_name":null},{"line":552,"address":[4484082],"length":1,"stats":{"Line":1},"fn_name":null},{"line":553,"address":[4484094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":554,"address":[4484865,4484126,4484850,4484532],"length":1,"stats":{"Line":6},"fn_name":null},{"line":556,"address":[4484870,4485062],"length":1,"stats":{"Line":1},"fn_name":null},{"line":560,"address":[4485007],"length":1,"stats":{"Line":1},"fn_name":null},{"line":561,"address":[4485039,4485395],"length":1,"stats":{"Line":4},"fn_name":null},{"line":562,"address":[4485912,4485460,4485410],"length":1,"stats":{"Line":4},"fn_name":null},{"line":567,"address":[4486501,4486384],"length":1,"stats":{"Line":3},"fn_name":"group_by_lazy_2"},{"line":568,"address":[4486391],"length":1,"stats":{"Line":1},"fn_name":null},{"line":569,"address":[4486524,4486625],"length":1,"stats":{"Line":4},"fn_name":null},{"line":570,"address":[4486693,4486640],"length":1,"stats":{"Line":2},"fn_name":null},{"line":571,"address":[4486709],"length":1,"stats":{"Line":3},"fn_name":null},{"line":573,"address":[4486930],"length":1,"stats":{"Line":1},"fn_name":null},{"line":574,"address":[4487104,4487000],"length":1,"stats":{"Line":4},"fn_name":null},{"line":575,"address":[4487119,4487172],"length":1,"stats":{"Line":2},"fn_name":null},{"line":576,"address":[4487180],"length":1,"stats":{"Line":1},"fn_name":null},{"line":577,"address":[4487246],"length":1,"stats":{"Line":3},"fn_name":null},{"line":579,"address":[4487381],"length":1,"stats":{"Line":3},"fn_name":null},{"line":580,"address":[4487482],"length":1,"stats":{"Line":1},"fn_name":null},{"line":581,"address":[4487538,4487579,4488057,4487497],"length":1,"stats":{"Line":4},"fn_name":null},{"line":582,"address":[4488025,4487911,4487960],"length":1,"stats":{"Line":3},"fn_name":null},{"line":583,"address":[4487962],"length":1,"stats":{"Line":1},"fn_name":null},{"line":586,"address":[4488062,4487926],"length":1,"stats":{"Line":2},"fn_name":null},{"line":588,"address":[4488094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":589,"address":[4488206,4488310],"length":1,"stats":{"Line":4},"fn_name":null},{"line":590,"address":[4488325],"length":1,"stats":{"Line":1},"fn_name":null},{"line":591,"address":[4488340,4489159,4488378,4488432],"length":1,"stats":{"Line":4},"fn_name":null},{"line":592,"address":[4489149,4488860,4488737],"length":1,"stats":{"Line":3},"fn_name":null},{"line":593,"address":[4488805],"length":1,"stats":{"Line":1},"fn_name":null},{"line":594,"address":[4488797,4489145],"length":1,"stats":{"Line":2},"fn_name":null},{"line":595,"address":[4488923,4489069,4489117],"length":1,"stats":{"Line":2},"fn_name":null},{"line":598,"address":[4488865],"length":1,"stats":{"Line":1},"fn_name":null},{"line":601,"address":[4489164,4488758],"length":1,"stats":{"Line":2},"fn_name":null},{"line":602,"address":[4489183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":603,"address":[4489234],"length":1,"stats":{"Line":1},"fn_name":null},{"line":606,"address":[4489295],"length":1,"stats":{"Line":1},"fn_name":null},{"line":607,"address":[4489399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":608,"address":[4489480,4489418],"length":1,"stats":{"Line":4},"fn_name":null},{"line":609,"address":[4489531,4490181,4489589],"length":1,"stats":{"Line":3},"fn_name":null},{"line":610,"address":[4490099,4490032,4490163,4489965],"length":1,"stats":{"Line":4},"fn_name":null},{"line":611,"address":[4489903,4489822],"length":1,"stats":{"Line":2},"fn_name":null},{"line":612,"address":[4489970],"length":1,"stats":{"Line":1},"fn_name":null},{"line":613,"address":[4490037],"length":1,"stats":{"Line":1},"fn_name":null},{"line":614,"address":[4490101],"length":1,"stats":{"Line":1},"fn_name":null},{"line":621,"address":[4491024,4491169],"length":1,"stats":{"Line":3},"fn_name":"group_by_lazy_3"},{"line":623,"address":[4491031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":624,"address":[4491189,4491260],"length":1,"stats":{"Line":4},"fn_name":null},{"line":625,"address":[4491267],"length":1,"stats":{"Line":1},"fn_name":null},{"line":626,"address":[4491284,4491354,4492497],"length":1,"stats":{"Line":3},"fn_name":null},{"line":627,"address":[4491590,4491627],"length":1,"stats":{"Line":2},"fn_name":null},{"line":628,"address":[4491850,4491704,4491901,4492060],"length":1,"stats":{"Line":3},"fn_name":null},{"line":629,"address":[4491951,4492065],"length":1,"stats":{"Line":1},"fn_name":null},{"line":632,"address":[4492380,4492227],"length":1,"stats":{"Line":1},"fn_name":null},{"line":637,"address":[4492672,4492809],"length":1,"stats":{"Line":3},"fn_name":"chunks"},{"line":638,"address":[4492679],"length":1,"stats":{"Line":1},"fn_name":null},{"line":639,"address":[4492829,4492905],"length":1,"stats":{"Line":2},"fn_name":null},{"line":640,"address":[4492917,4492973,4493621],"length":1,"stats":{"Line":3},"fn_name":null},{"line":641,"address":[4493405,4493603,4493472,4493539],"length":1,"stats":{"Line":4},"fn_name":null},{"line":642,"address":[4493252,4493343],"length":1,"stats":{"Line":2},"fn_name":null},{"line":643,"address":[4493410],"length":1,"stats":{"Line":1},"fn_name":null},{"line":644,"address":[4493477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":645,"address":[4493541],"length":1,"stats":{"Line":1},"fn_name":null},{"line":652,"address":[4493808,4493827],"length":1,"stats":{"Line":3},"fn_name":"concat_empty"},{"line":653,"address":[4493815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":654,"address":[4493961,4494077,4493842],"length":1,"stats":{"Line":2},"fn_name":null},{"line":658,"address":[4494530,4494448],"length":1,"stats":{"Line":3},"fn_name":"concat_non_empty"},{"line":659,"address":[4494545,4494465],"length":1,"stats":{"Line":1},"fn_name":null},{"line":660,"address":[4494832,4495165,4495039,4495141],"length":1,"stats":{"Line":3},"fn_name":null},{"line":664,"address":[4495708,4495600],"length":1,"stats":{"Line":3},"fn_name":"combinations"},{"line":665,"address":[4495607,4495733,4495878],"length":1,"stats":{"Line":2},"fn_name":null},{"line":667,"address":[4495822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":668,"address":[4496097,4495908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":669,"address":[4496037],"length":1,"stats":{"Line":1},"fn_name":null},{"line":672,"address":[4496210],"length":1,"stats":{"Line":1},"fn_name":null},{"line":673,"address":[4496453,4496585,4496264,4496651,4496717,4496519,4496783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":674,"address":[4496393],"length":1,"stats":{"Line":1},"fn_name":null},{"line":675,"address":[4496478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":676,"address":[4496544],"length":1,"stats":{"Line":1},"fn_name":null},{"line":677,"address":[4496610],"length":1,"stats":{"Line":1},"fn_name":null},{"line":678,"address":[4496676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":679,"address":[4496742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":682,"address":[4497019],"length":1,"stats":{"Line":1},"fn_name":null},{"line":683,"address":[4497102],"length":1,"stats":{"Line":1},"fn_name":null},{"line":684,"address":[4497185],"length":1,"stats":{"Line":1},"fn_name":null},{"line":686,"address":[4497337,4498397],"length":1,"stats":{"Line":1},"fn_name":null},{"line":687,"address":[4497453,4498438],"length":1,"stats":{"Line":1},"fn_name":null},{"line":688,"address":[4497715,4498464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":689,"address":[4498490,4498061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":693,"address":[4498896,4498949],"length":1,"stats":{"Line":3},"fn_name":"combinations_of_too_short"},{"line":694,"address":[4498969,4499459,4499030,4498903],"length":1,"stats":{"Line":3},"fn_name":null},{"line":695,"address":[4499247,4499061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":696,"address":[4499277,4499222,4499464],"length":1,"stats":{"Line":2},"fn_name":null},{"line":702,"address":[4499685,4499616],"length":1,"stats":{"Line":3},"fn_name":"combinations_zero"},{"line":703,"address":[4499710,4500046,4499627],"length":1,"stats":{"Line":2},"fn_name":null},{"line":704,"address":[4499830,4500082],"length":1,"stats":{"Line":1},"fn_name":null},{"line":708,"address":[4500277,4500208],"length":1,"stats":{"Line":3},"fn_name":"permutations_zero"},{"line":709,"address":[4500653,4500219,4500302],"length":1,"stats":{"Line":2},"fn_name":null},{"line":710,"address":[4500692,4500437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":714,"address":[4500912,4500816],"length":1,"stats":{"Line":3},"fn_name":"combinations_with_replacement"},{"line":716,"address":[4502412,4500937,4500823],"length":1,"stats":{"Line":2},"fn_name":null},{"line":719,"address":[4501129],"length":1,"stats":{"Line":1},"fn_name":null},{"line":720,"address":[4501488,4501620,4501290,4501422,4501356,4501201,4501554],"length":1,"stats":{"Line":1},"fn_name":null},{"line":721,"address":[4501230],"length":1,"stats":{"Line":1},"fn_name":null},{"line":722,"address":[4501315],"length":1,"stats":{"Line":1},"fn_name":null},{"line":723,"address":[4501381],"length":1,"stats":{"Line":1},"fn_name":null},{"line":724,"address":[4501447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":725,"address":[4501513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":726,"address":[4501579],"length":1,"stats":{"Line":1},"fn_name":null},{"line":731,"address":[4501860],"length":1,"stats":{"Line":1},"fn_name":null},{"line":732,"address":[4502487,4501927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":736,"address":[4502076],"length":1,"stats":{"Line":1},"fn_name":null},{"line":737,"address":[4502531,4502143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":741,"address":[4502288],"length":1,"stats":{"Line":1},"fn_name":null},{"line":742,"address":[4502358],"length":1,"stats":{"Line":1},"fn_name":null},{"line":747,"address":[4502880,4502968],"length":1,"stats":{"Line":3},"fn_name":"diff_mismatch"},{"line":748,"address":[4502887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":749,"address":[4502993],"length":1,"stats":{"Line":1},"fn_name":null},{"line":750,"address":[4503085],"length":1,"stats":{"Line":3},"fn_name":null},{"line":751,"address":[4503167],"length":1,"stats":{"Line":3},"fn_name":null},{"line":753,"address":[4503647,4503332,4503709],"length":1,"stats":{"Line":1},"fn_name":null},{"line":754,"address":[4503337,4503290],"length":1,"stats":{"Line":2},"fn_name":null},{"line":755,"address":[4503415],"length":1,"stats":{"Line":1},"fn_name":null},{"line":756,"address":[4503324],"length":1,"stats":{"Line":0},"fn_name":null},{"line":761,"address":[4504096,4504184],"length":1,"stats":{"Line":3},"fn_name":"diff_longer"},{"line":762,"address":[4504103],"length":1,"stats":{"Line":1},"fn_name":null},{"line":763,"address":[4504209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":764,"address":[4504332],"length":1,"stats":{"Line":3},"fn_name":null},{"line":765,"address":[4504414],"length":1,"stats":{"Line":3},"fn_name":null},{"line":767,"address":[4504938,4504579,4504876],"length":1,"stats":{"Line":1},"fn_name":null},{"line":768,"address":[4504584,4504537],"length":1,"stats":{"Line":2},"fn_name":null},{"line":769,"address":[4504651],"length":1,"stats":{"Line":1},"fn_name":null},{"line":770,"address":[4504571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":775,"address":[4505328,4505408],"length":1,"stats":{"Line":3},"fn_name":"diff_shorter"},{"line":776,"address":[4505335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":777,"address":[4505433],"length":1,"stats":{"Line":1},"fn_name":null},{"line":778,"address":[4505497],"length":1,"stats":{"Line":3},"fn_name":null},{"line":779,"address":[4505573],"length":1,"stats":{"Line":3},"fn_name":null},{"line":781,"address":[4505728,4505802,4505774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":782,"address":[4505730,4505686],"length":1,"stats":{"Line":2},"fn_name":null},{"line":783,"address":[4505720],"length":1,"stats":{"Line":0},"fn_name":null},{"line":788,"address":[4506013,4505984],"length":1,"stats":{"Line":3},"fn_name":"minmax"},{"line":798,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":799,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":804,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":805,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":809,"address":[4506184,4506028,4505991],"length":1,"stats":{"Line":2},"fn_name":null},{"line":811,"address":[4506159,4506519,4506917],"length":1,"stats":{"Line":2},"fn_name":null},{"line":813,"address":[4506654],"length":1,"stats":{"Line":1},"fn_name":null},{"line":815,"address":[4507260,4507364],"length":1,"stats":{"Line":2},"fn_name":null},{"line":816,"address":[4507517,4507371],"length":1,"stats":{"Line":1},"fn_name":null},{"line":818,"address":[4507893,4507491],"length":1,"stats":{"Line":4},"fn_name":null},{"line":819,"address":[4508056,4508267],"length":1,"stats":{"Line":1},"fn_name":null},{"line":820,"address":[4508674,4508165,4508634],"length":1,"stats":{"Line":2},"fn_name":null},{"line":822,"address":[4509050,4508648],"length":1,"stats":{"Line":4},"fn_name":null},{"line":823,"address":[4509213,4509424],"length":1,"stats":{"Line":1},"fn_name":null},{"line":824,"address":[4509749,4509773,4509322],"length":1,"stats":{"Line":2},"fn_name":null},{"line":828,"address":[4510736,4510895],"length":1,"stats":{"Line":3},"fn_name":"format"},{"line":829,"address":[4510757],"length":1,"stats":{"Line":1},"fn_name":null},{"line":830,"address":[4510801],"length":1,"stats":{"Line":1},"fn_name":null},{"line":831,"address":[4510821],"length":1,"stats":{"Line":1},"fn_name":null},{"line":833,"address":[4510917,4510841],"length":1,"stats":{"Line":2},"fn_name":null},{"line":834,"address":[4511348,4511166],"length":1,"stats":{"Line":1},"fn_name":null},{"line":835,"address":[4511291,4511708],"length":1,"stats":{"Line":2},"fn_name":null},{"line":836,"address":[4512208,4511968],"length":1,"stats":{"Line":1},"fn_name":null},{"line":838,"address":[4512107],"length":1,"stats":{"Line":1},"fn_name":null},{"line":839,"address":[4512151,4512562],"length":1,"stats":{"Line":2},"fn_name":null},{"line":840,"address":[4512951,4512813],"length":1,"stats":{"Line":1},"fn_name":null},{"line":844,"address":[4513360],"length":1,"stats":{"Line":3},"fn_name":"while_some"},{"line":845,"address":[4513364],"length":1,"stats":{"Line":3},"fn_name":null},{"line":847,"address":[4513429],"length":1,"stats":{"Line":1},"fn_name":null},{"line":852,"address":[4513520,4513648],"length":1,"stats":{"Line":3},"fn_name":"fold_while"},{"line":853,"address":[4513527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":854,"address":[4513538],"length":1,"stats":{"Line":1},"fn_name":null},{"line":855,"address":[4513663,4513819],"length":1,"stats":{"Line":3},"fn_name":null},{"line":856,"address":[4938913,4939050],"length":1,"stats":{"Line":1},"fn_name":null},{"line":857,"address":[4939110,4938957,4939080],"length":1,"stats":{"Line":1},"fn_name":null},{"line":858,"address":[4939020,4938999],"length":1,"stats":{"Line":2},"fn_name":null},{"line":859,"address":[4939025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":861,"address":[4939004],"length":1,"stats":{"Line":1},"fn_name":null},{"line":863,"address":[4513847,4513787],"length":1,"stats":{"Line":2},"fn_name":null},{"line":864,"address":[4513860,4514060],"length":1,"stats":{"Line":1},"fn_name":null},{"line":865,"address":[4514361,4513957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":869,"address":[4515219,4514672],"length":1,"stats":{"Line":3},"fn_name":"tree_fold1"},{"line":870,"address":[4514817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":889,"address":[4515180,4515404,4515234,4516195],"length":1,"stats":{"Line":3},"fn_name":null},{"line":890,"address":[4515485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":891,"address":[4515617],"length":1,"stats":{"Line":3},"fn_name":null},{"line":892,"address":[4515709],"length":1,"stats":{"Line":3},"fn_name":null},{"line":893,"address":[4515879,4515748],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":529,"coverable":534},{"path":["/","usr","src","itertools","tests","tuples.rs"],"content":"use itertools::Itertools;\n\n#[test]\nfn tuples() {\n    let v = [1, 2, 3, 4, 5];\n    let mut iter = v.iter().cloned().tuples();\n    assert_eq!(Some((1,)), iter.next());\n    assert_eq!(Some((2,)), iter.next());\n    assert_eq!(Some((3,)), iter.next());\n    assert_eq!(Some((4,)), iter.next());\n    assert_eq!(Some((5,)), iter.next());\n    assert_eq!(None, iter.next());\n    assert_eq!(None, iter.into_buffer().next());\n\n    let mut iter = v.iter().cloned().tuples();\n    assert_eq!(Some((1, 2)), iter.next());\n    assert_eq!(Some((3, 4)), iter.next());\n    assert_eq!(None, iter.next());\n    itertools::assert_equal(vec![5], iter.into_buffer());\n\n    let mut iter = v.iter().cloned().tuples();\n    assert_eq!(Some((1, 2, 3)), iter.next());\n    assert_eq!(None, iter.next());\n    itertools::assert_equal(vec![4, 5], iter.into_buffer());\n\n    let mut iter = v.iter().cloned().tuples();\n    assert_eq!(Some((1, 2, 3, 4)), iter.next());\n    assert_eq!(None, iter.next());\n    itertools::assert_equal(vec![5], iter.into_buffer());\n}\n\n#[test]\nfn tuple_windows() {\n    let v = [1, 2, 3, 4, 5];\n\n    let mut iter = v.iter().cloned().tuple_windows();\n    assert_eq!(Some((1,)), iter.next());\n    assert_eq!(Some((2,)), iter.next());\n    assert_eq!(Some((3,)), iter.next());\n\n    let mut iter = v.iter().cloned().tuple_windows();\n    assert_eq!(Some((1, 2)), iter.next());\n    assert_eq!(Some((2, 3)), iter.next());\n    assert_eq!(Some((3, 4)), iter.next());\n    assert_eq!(Some((4, 5)), iter.next());\n    assert_eq!(None, iter.next());\n\n    let mut iter = v.iter().cloned().tuple_windows();\n    assert_eq!(Some((1, 2, 3)), iter.next());\n    assert_eq!(Some((2, 3, 4)), iter.next());\n    assert_eq!(Some((3, 4, 5)), iter.next());\n    assert_eq!(None, iter.next());\n\n    let mut iter = v.iter().cloned().tuple_windows();\n    assert_eq!(Some((1, 2, 3, 4)), iter.next());\n    assert_eq!(Some((2, 3, 4, 5)), iter.next());\n    assert_eq!(None, iter.next());\n\n    let v = [1, 2, 3];\n    let mut iter = v.iter().cloned().tuple_windows::<(_, _, _, _)>();\n    assert_eq!(None, iter.next());\n}\n\n#[test]\nfn next_tuple() {\n    let v = [1, 2, 3, 4, 5];\n    let mut iter = v.iter();\n    assert_eq!(iter.next_tuple().map(|(&x, &y)| (x, y)), Some((1, 2)));\n    assert_eq!(iter.next_tuple().map(|(&x, &y)| (x, y)), Some((3, 4)));\n    assert_eq!(iter.next_tuple::<(_, _)>(), None);\n}\n\n#[test]\nfn collect_tuple() {\n    let v = [1, 2];\n    let iter = v.iter().cloned();\n    assert_eq!(iter.collect_tuple(), Some((1, 2)));\n\n    let v = [1];\n    let iter = v.iter().cloned();\n    assert_eq!(iter.collect_tuple::<(_, _)>(), None);\n\n    let v = [1, 2, 3];\n    let iter = v.iter().cloned();\n    assert_eq!(iter.collect_tuple::<(_, _)>(), None);\n}\n","traces":[{"line":4,"address":[4211312,4211317],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":5,"address":[4244525],"length":1,"stats":{"Line":1},"fn_name":null},{"line":6,"address":[4244604,4244674],"length":1,"stats":{"Line":2},"fn_name":null},{"line":7,"address":[4244932,4244732],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[4245425,4244885,4245275],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9,"address":[4245918,4245378,4245768],"length":1,"stats":{"Line":2},"fn_name":null},{"line":10,"address":[4246261,4246411,4245871],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[4246754,4246904,4246364],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[4246857,4247247,4247399],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[4247914,4247350,4247742],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[4247872,4248265],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[4248503,4248315],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[4248846,4248990,4248462],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[4249333,4248949,4249487],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4252314,4249822,4249436],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[4249924],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[4250215,4250027],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[4250174,4250558,4250718],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[4251053,4250661,4252355],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[4251155],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[4251446,4251258],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[4251759,4251901,4251405],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[4251850,4252188,4252396],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[4211349,4211344],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":34,"address":[4252509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[4252564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[4252867,4252667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[4253210,4253360,4252820],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[4253848,4253703,4253313],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[4253806,4254199],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[4254249,4254437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4254396,4254780,4254924],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[4255411,4255267,4254883],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[4255754,4255898,4255370],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[4256241,4255857,4256386],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[4256344,4256737],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[4256975,4256787],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[4257462,4256934,4257318],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[4257949,4257805,4257421],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[4258292,4258437,4257908],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[4258788,4258395],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[4258838,4259026],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[4259369,4258985,4259513],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[4259472,4259856,4260034],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[4259959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4259992,4260367],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[4260542,4260405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[4211376,4211381],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":66,"address":[4260839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[4260907],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[4211408,4211422],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":69,"address":[4211470,4211456],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":70,"address":[4261937,4262043,4261612],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[4211509,4211504],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":75,"address":[4262343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[4262365],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[4262455,4262647],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[4262594],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[4262998,4262605],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[4263035,4263249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[4263174],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[4263207,4263582],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[4263742,4263613],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":63,"coverable":63},{"path":["/","usr","src","itertools","tests","zip.rs"],"content":"use itertools::Itertools;\nuse itertools::EitherOrBoth::{Both, Left, Right};\nuse itertools::free::zip_eq;\n\n#[test]\nfn zip_longest_fused() {\n    let a = [Some(1), None, Some(3), Some(4)];\n    let b = [1, 2, 3];\n\n    let unfused = a.iter().batching(|it| *it.next().unwrap())\n        .zip_longest(b.iter().cloned());\n    itertools::assert_equal(unfused,\n                       vec![Both(1, 1), Right(2), Right(3)]);\n}\n\n#[test]\nfn test_zip_longest_size_hint() {\n    let c = (1..10).cycle();\n    let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let v2 = &[10, 11, 12];\n\n    assert_eq!(c.zip_longest(v.iter()).size_hint(), (std::usize::MAX, None));\n\n    assert_eq!(v.iter().zip_longest(v2.iter()).size_hint(), (10, Some(10)));\n}\n\n#[test]\nfn test_double_ended_zip_longest() {\n    let xs = [1, 2, 3, 4, 5, 6];\n    let ys = [1, 2, 3, 7];\n    let a = xs.iter().map(|&x| x);\n    let b = ys.iter().map(|&x| x);\n    let mut it = a.zip_longest(b);\n    assert_eq!(it.next(), Some(Both(1, 1)));\n    assert_eq!(it.next(), Some(Both(2, 2)));\n    assert_eq!(it.next_back(), Some(Left(6)));\n    assert_eq!(it.next_back(), Some(Left(5)));\n    assert_eq!(it.next_back(), Some(Both(4, 7)));\n    assert_eq!(it.next(), Some(Both(3, 3)));\n    assert_eq!(it.next(), None);\n}\n\n\n#[should_panic]\n#[test]\nfn zip_eq_panic1()\n{\n    let a = [1, 2];\n    let b = [1, 2, 3];\n\n    zip_eq(&a, &b).count();\n}\n\n#[should_panic]\n#[test]\nfn zip_eq_panic2()\n{\n    let a: [i32; 0] = [];\n    let b = [1, 2, 3];\n\n    zip_eq(&a, &b).count();\n}\n\n","traces":[{"line":6,"address":[4214336,4214341],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":7,"address":[4230567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[4230687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[4214382,4214368],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":11,"address":[4230773],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[4230860,4231111],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[4230924],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[4231152],"length":1,"stats":{"Line":3},"fn_name":"test_zip_longest_size_hint"},{"line":18,"address":[4231159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[4231208],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[4231235],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[4231250,4231534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[4232042,4231503,4231853],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[4214480,4214485],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":29,"address":[4232343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[4232409],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[4214512,4214525],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":32,"address":[4214544,4214557],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":33,"address":[4232633],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[4232678,4232835],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[4233170,4232809,4233306],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[4233777,4233641,4233280],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[4234112,4234248,4233751],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[4234583,4234719,4234222],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[4235190,4235054,4234693],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[4235164,4235595,4235489],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[4214581,4214576],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":48,"address":[4235892],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[4235908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[4235932],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[4214608,4214613],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":59,"address":[4235972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[4235996],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":33,"coverable":33}]}