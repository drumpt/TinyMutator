{"files":[{"path":["/","mnt","c","Users","kms2","Desktop","KAIST","7학기","소프트웨어 테스팅 자동화 기법","PJ","mutagen","examples","simple","src","bubblesort.rs"],"content":"use mutagen::mutate;\n\n#[cfg_attr(test, mutate)]\npub fn bubblesort_for(arr: &mut [u8]) {\n    let n = arr.len();\n    for _ in 1..n {\n        for i in 1..n {\n            if arr[i - 1] > arr[i] {\n                arr.swap(i - 1, i);\n            }\n        }\n    }\n}\n\n#[cfg_attr(test, mutate)]\npub fn bubblesort_while(arr: &mut [u8]) {\n    let n = arr.len();\n    let mut change = true;\n    while change {\n        change = false;\n        for i in 1..n {\n            if arr[i - 1] > arr[i] {\n                arr.swap(i - 1, i);\n                change = true;\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::*;\n\n    #[test]\n    fn test_bubblesort_for_123() {\n        let mut arr = vec![1, 2, 3];\n        bubblesort_for(&mut arr);\n        assert_eq!(&*arr, [1, 2, 3]);\n    }\n    #[test]\n    fn test_bubblesort_for_321() {\n        let mut arr = vec![3, 2, 1];\n        bubblesort_for(&mut arr);\n        assert_eq!(&*arr, [1, 2, 3]);\n    }\n\n    #[test]\n    fn test_bubblesort_while_123() {\n        let mut arr = vec![1, 2, 3];\n        bubblesort_while(&mut arr);\n        assert_eq!(&*arr, [1, 2, 3]);\n    }\n    #[test]\n    fn test_bubblesort_while_321() {\n        let mut arr = vec![3, 2, 1];\n        bubblesort_while(&mut arr);\n        assert_eq!(&*arr, [1, 2, 3]);\n    }\n}\n","traces":[{"line":4,"address":[4207552],"length":1,"stats":{"Line":2},"fn_name":"bubblesort_for"},{"line":5,"address":[4207591],"length":1,"stats":{"Line":2},"fn_name":null},{"line":6,"address":[4207819,4207613,4208036],"length":1,"stats":{"Line":3},"fn_name":null},{"line":7,"address":[4207845,4208041,4208497],"length":1,"stats":{"Line":3},"fn_name":null},{"line":8,"address":[4208075,4208502,4208495],"length":1,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[4208327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[4207811],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[4208576],"length":1,"stats":{"Line":1},"fn_name":"bubblesort_while"},{"line":17,"address":[4208615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[4208637],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[4208683,4208957],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[4208703],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[4208962,4208760,4209490],"length":1,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[4208996,4209495],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[4209260],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[4209442],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[4208695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[4237520,4237525],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":37,"address":[4239287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[4239354],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[4239416,4239587],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[4237537,4237535],"length":1,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[4237552,4237557],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":43,"address":[4239927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[4239994],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[4240227,4240056],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[4237569,4237567],"length":1,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[4237589,4237584],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":50,"address":[4240567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[4240634],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[4240696,4240867],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[4237601,4237599],"length":1,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[4237621,4237616],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":56,"address":[4241207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[4241274],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[4241507,4241336],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[4237633,4237631],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":37,"coverable":37},{"path":["/","mnt","c","Users","kms2","Desktop","KAIST","7학기","소프트웨어 테스팅 자동화 기법","PJ","mutagen","examples","simple","src","ggt.rs"],"content":"use mutagen::mutate;\n\n#[cfg_attr(test, mutate)]\npub fn ggt_loop(mut a: u32, mut b: u32) -> u32 {\n    loop {\n        if a == 0 {\n            return b;\n        }\n        if b == 0 {\n            return a;\n        }\n        if a > b {\n            a -= b;\n        } else {\n            b -= a;\n        }\n    }\n}\n\n#[cfg_attr(test, mutate)]\npub fn ggt_rec(mut a: u32, mut b: u32) -> u32 {\n    if a == b || a == 0 || b == 0 {\n        return a | b;\n    }\n    if a == 1 || b == 1 {\n        return 1;\n    }\n    if a > b {\n        ggt_rec(a - b, b)\n    } else {\n        ggt_rec(a, b - a)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::*;\n\n    #[test]\n    fn test_ggt_loop_4_4() {\n        assert_eq!(ggt_loop(4, 4), 4)\n    }\n    #[test]\n    fn test_ggt_loop_3_5() {\n        assert_eq!(ggt_loop(3, 5), 1)\n    }\n    #[test]\n    fn test_ggt_loop_5_3() {\n        assert_eq!(ggt_loop(5, 3), 1)\n    }\n\n    #[test]\n    fn test_ggt_rec_4_4() {\n        assert_eq!(ggt_rec(4, 4), 4)\n    }\n    #[test]\n    fn test_ggt_rec_3_5() {\n        assert_eq!(ggt_rec(3, 5), 1)\n    }\n    #[test]\n    fn test_ggt_rec_5_3() {\n        assert_eq!(ggt_rec(5, 3), 1)\n    }\n    #[test]\n    fn test_ggt_rec_0_2() {\n        assert_eq!(ggt_rec(0, 2), 2)\n    }\n    #[test]\n    fn test_ggt_rec_2_0() {\n        assert_eq!(ggt_rec(2, 0), 2)\n    }\n    #[test]\n    fn test_ggt_rec_2_4() {\n        assert_eq!(ggt_rec(2, 4), 2)\n    }\n}\n","traces":[{"line":4,"address":[4237648],"length":1,"stats":{"Line":3},"fn_name":"ggt_loop"},{"line":5,"address":[4237978],"length":1,"stats":{"Line":3},"fn_name":null},{"line":6,"address":[4237660],"length":1,"stats":{"Line":3},"fn_name":null},{"line":7,"address":[4237757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[4237744,4237776],"length":1,"stats":{"Line":4},"fn_name":null},{"line":10,"address":[4237860],"length":1,"stats":{"Line":3},"fn_name":null},{"line":12,"address":[4237870,4237847,4237968],"length":1,"stats":{"Line":5},"fn_name":null},{"line":13,"address":[4237938,4237983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[4237914,4237974,4238013,4238043],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[4237765],"length":1,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[4238048],"length":1,"stats":{"Line":1},"fn_name":"ggt_rec"},{"line":22,"address":[4238069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[4238653,4238596],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[4238583,4238685],"length":1,"stats":{"Line":6},"fn_name":null},{"line":26,"address":[4238990],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[4239273,4238977,4239226,4239033],"length":1,"stats":{"Line":6},"fn_name":null},{"line":29,"address":[4239136],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[4239228,4239083],"length":1,"stats":{"Line":4},"fn_name":null},{"line":33,"address":[4238638,4239275,4239280],"length":1,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[4213381,4213376],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":42,"address":[4224759,4224868],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4224853],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[4225152],"length":1,"stats":{"Line":3},"fn_name":"test_ggt_loop_3_5"},{"line":46,"address":[4225159,4225269],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[4225254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[4225552],"length":1,"stats":{"Line":3},"fn_name":"test_ggt_loop_5_3"},{"line":50,"address":[4225559,4225669],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[4213457,4213455],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[4213472,4213477],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":55,"address":[4225959,4226068],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[4213487,4213489],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[4213509,4213504],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":59,"address":[4226469,4226359],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4213519,4213521],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[4213541,4213536],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":63,"address":[4226869,4226759],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[4213551,4213553],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[4213568,4213573],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":67,"address":[4227266,4227161],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[4213585,4213583],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[4213600,4213605],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":71,"address":[4227561,4227666],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[4213617,4213615],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[4213632,4213637],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":75,"address":[4227959,4228069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[4213647,4213649],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":45,"coverable":46},{"path":["/","mnt","c","Users","kms2","Desktop","KAIST","7학기","소프트웨어 테스팅 자동화 기법","PJ","mutagen","examples","simple","src","lazy_add.rs"],"content":"use mutagen::mutate;\n\nenum LazyAdd {\n    Val(u8),\n    Lazy(Box<LazyAdd>, Box<LazyAdd>),\n}\n\nimpl From<u8> for LazyAdd {\n    fn from(v: u8) -> Self {\n        Self::Val(v)\n    }\n}\n\nimpl std::ops::Add<LazyAdd> for LazyAdd {\n    type Output = LazyAdd;\n    fn add(self, rhs: LazyAdd) -> LazyAdd {\n        LazyAdd::Lazy(Box::new(self), Box::new(rhs))\n    }\n}\n\n#[cfg_attr(test, mutate)]\nimpl LazyAdd {\n    pub fn eval(self) -> u8 {\n        match self {\n            Self::Val(v) => v,\n            Self::Lazy(l, r) => l.eval() + r.eval(),\n        }\n    }\n\n    pub fn add_one(self) -> Self {\n        self + 1.into()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::*;\n\n    #[test]\n    fn add_one_to_zero() {\n        assert_eq!(LazyAdd::from(0).add_one().eval(), 1);\n    }\n}\n","traces":[{"line":4,"address":[4234727,4234715,4234704],"length":1,"stats":{"Line":2},"fn_name":"{{constructor}}"},{"line":9,"address":[4234736],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":10,"address":[4234748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[4234772,4234767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[4235012,4234784],"length":1,"stats":{"Line":1},"fn_name":"add"},{"line":17,"address":[4234794,4234913,4235027],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[4235069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[4235152,4235327],"length":1,"stats":{"Line":1},"fn_name":"eval"},{"line":24,"address":[4235247,4235268,4235438],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[4235159,4235254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[4235277,4235186,4235342,4235440],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[4235478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[4235520,4235617],"length":1,"stats":{"Line":1},"fn_name":"add_one"},{"line":31,"address":[4235778,4235530,4235647],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[4235770],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[4215216],"length":1,"stats":{"Line":3},"fn_name":"add_one_to_zero"},{"line":42,"address":[4215358,4215225],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4215343],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":18,"coverable":18},{"path":["/","mnt","c","Users","kms2","Desktop","KAIST","7학기","소프트웨어 테스팅 자동화 기법","PJ","mutagen","examples","simple","src","not_covered.rs"],"content":"use mutagen::mutate;\n\n#[cfg_attr(test, mutate)]\npub fn simple_assert_not_covered() {\n    1 < 3;\n}\n\n// There are no tests since the function above is supposed to be no covered by tests\n","traces":[{"line":4,"address":[4209568],"length":1,"stats":{"Line":0},"fn_name":"simple_assert_not_covered"},{"line":5,"address":[4209572],"length":1,"stats":{"Line":0},"fn_name":null},{"line":6,"address":[4209732,4209727],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["/","mnt","c","Users","kms2","Desktop","KAIST","7학기","소프트웨어 테스팅 자동화 기법","PJ","mutagen","examples","simple","src","primetest.rs"],"content":"use mutagen::mutate;\n\n#[cfg_attr(test, mutate)]\npub fn primetest(n: u32) -> bool {\n    if n % 2 == 0u32 {\n        return n == 2;\n    }\n    if n == 1 {\n        return false;\n    }\n    let mut k = 3;\n    while k * k <= n {\n        if n % k == 0u32 {\n            return false;\n        }\n        k += 2;\n    }\n    true\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::*;\n\n    #[test]\n    fn test_primetest_0() {\n        assert!(!primetest(0))\n    }\n    #[test]\n    fn test_primetest_1() {\n        assert!(!primetest(1))\n    }\n    #[test]\n    fn test_primetest_2() {\n        assert!(primetest(2))\n    }\n    #[test]\n    fn test_primetest_3() {\n        assert!(primetest(3))\n    }\n    #[test]\n    fn test_primetest_4() {\n        assert!(!primetest(4))\n    }\n    #[test]\n    fn test_primetest_25() {\n        assert!(!primetest(25))\n    }\n    #[test]\n    fn test_primetest_29() {\n        assert!(primetest(29))\n    }\n    #[test]\n    fn test_primetest_31() {\n        assert!(primetest(31))\n    }\n}\n","traces":[{"line":4,"address":[4231024],"length":1,"stats":{"Line":2},"fn_name":"primetest"},{"line":5,"address":[4231038,4232023],"length":1,"stats":{"Line":2},"fn_name":null},{"line":6,"address":[4231270,4231306],"length":1,"stats":{"Line":2},"fn_name":null},{"line":8,"address":[4231397,4231254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9,"address":[4231504],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[4231546,4231491],"length":1,"stats":{"Line":8},"fn_name":null},{"line":12,"address":[4231984,4231573],"length":1,"stats":{"Line":7},"fn_name":null},{"line":13,"address":[4232053,4231722],"length":1,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[4231884],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[4231871,4232083,4232113,4231926],"length":1,"stats":{"Line":6},"fn_name":null},{"line":18,"address":[4231706,4231989],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4232018,4231286],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[4221888],"length":1,"stats":{"Line":3},"fn_name":"test_primetest_0"},{"line":28,"address":[4221914,4221891,4221944],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[4209759,4209761],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[4221952],"length":1,"stats":{"Line":3},"fn_name":"test_primetest_1"},{"line":32,"address":[4221953,4222011,4221981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[4209791,4209793],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[4209813,4209808],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":36,"address":[4222043,4222073,4222017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[4209823,4209825],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[4209840,4209845],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":40,"address":[4222137,4222081,4222107],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[4209857,4209855],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[4209872,4209877],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":44,"address":[4222203,4222173,4222145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[4209889,4209887],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[4209904,4209909],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":48,"address":[4222237,4222267,4222209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[4209919,4209921],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[4209936,4209941],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":52,"address":[4222299,4222273,4222329],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[4209951,4209953],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[4209968,4209973],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":56,"address":[4222363,4222393,4222337],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[4209985,4209983],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":36,"coverable":36},{"path":["/","mnt","c","Users","kms2","Desktop","KAIST","7학기","소프트웨어 테스팅 자동화 기법","PJ","mutagen","examples","simple","src","simple_add.rs"],"content":"use mutagen::mutate;\n\n#[cfg_attr(test, mutate)]\npub fn simple_add() -> i32 {\n    1 + 2\n}\n\n#[cfg_attr(test, mutate)]\npub fn simple_add_u8() -> u8 {\n    1 + 2\n}\n\n#[cfg_attr(test, mutate)]\npub fn add_repeated_u8() -> u8 {\n    1 + 2 + 3 * 2\n}\n\n#[cfg_attr(test, mutate)]\npub fn add_two_u8(x: u8) -> u8 {\n    x + 2\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::*;\n\n    #[test]\n    fn test_simple_add() {\n        assert_eq!(simple_add(), 3);\n    }\n\n    #[test]\n    fn test_simple_add_u8() {\n        assert_eq!(simple_add_u8(), 3);\n    }\n\n    #[test]\n    fn test_add_two_u8() {\n        assert_eq!(add_two_u8(1), 3);\n    }\n\n    #[test]\n    fn test_add_repeated_u8() {\n        assert_eq!(add_repeated_u8(), 9);\n    }\n}\n","traces":[{"line":4,"address":[4214528],"length":1,"stats":{"Line":1},"fn_name":"simple_add"},{"line":5,"address":[4214532],"length":1,"stats":{"Line":1},"fn_name":null},{"line":6,"address":[4214653,4214648],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[4214656],"length":1,"stats":{"Line":1},"fn_name":"simple_add_u8"},{"line":10,"address":[4214660],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[4214782,4214787],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[4214800],"length":1,"stats":{"Line":1},"fn_name":"add_repeated_u8"},{"line":15,"address":[4214804],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[4215097,4215092],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[4215104],"length":1,"stats":{"Line":1},"fn_name":"add_two_u8"},{"line":20,"address":[4215113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[4215211,4215206],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[4213056,4213061],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":30,"address":[4229451,4229351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[4213073,4213071],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[4213093,4213088],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":35,"address":[4229735,4229832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[4213105,4213103],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[4213125,4213120],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":40,"address":[4230221,4230119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[4213137,4213135],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[4213152,4213157],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":45,"address":[4230503,4230600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[4213167,4213169],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":24,"coverable":24},{"path":["/","mnt","c","Users","kms2","Desktop","KAIST","7학기","소프트웨어 테스팅 자동화 기법","PJ","mutagen","mutagen-core","src","comm","coverage.rs"],"content":"use super::BakedMutation;\nuse serde::{Deserialize, Serialize};\n\n/// A single coverage hit.\n#[derive(Debug, Serialize, Deserialize)]\npub struct CoverageHit {\n    pub mutator_id: usize,\n}\n\n/// A collection that tracks which mutations have been covered.\n///\n/// The collection can be created my\n#[derive(Debug, Serialize, Deserialize)]\npub struct CoverageCollection {\n    num_covered: usize,\n    coverage: Vec<bool>,\n}\n\nimpl CoverageCollection {\n    /// Create a collection about coverage where no mutator has been covered.\n    pub fn new_empty(num_mutations: usize) -> Self {\n        Self {\n            num_covered: 0,\n            coverage: vec![false; num_mutations + 1],\n        }\n    }\n\n    /// Create a collection about coverage from a list of coverage hits.\n    pub fn from_coverage_hits(\n        num_mutations: usize,\n        hits: &[CoverageHit],\n        mutations: &[BakedMutation],\n    ) -> Self {\n        let mut coverage = vec![false; num_mutations + 1];\n        let mut num_covered = 0;\n\n        for hit in hits {\n            if !coverage[hit.mutator_id] {\n                for m in mutations {\n                    if m.mutator_id() == hit.mutator_id {\n                        num_covered += 1;\n                        coverage[m.id()] = true;\n                    }\n                }\n            }\n        }\n\n        Self {\n            num_covered,\n            coverage,\n        }\n    }\n\n    /// Merge multiple coverage collections into a single one.\n    pub fn merge<'a>(\n        num_mutations: usize,\n        coverages: impl IntoIterator<Item = &'a CoverageCollection>,\n    ) -> Self {\n        let mut coverage = vec![false; num_mutations + 1];\n        let mut num_covered = 0;\n\n        for c in coverages {\n            for m_id in 1..=num_mutations {\n                if c.is_covered(m_id) {\n                    if !coverage[m_id] {\n                        num_covered += 1;\n                        coverage[m_id] = true;\n                    }\n                }\n            }\n        }\n\n        Self {\n            num_covered,\n            coverage,\n        }\n    }\n\n    /// Checks if the given mutation is covered.\n    pub fn is_covered(&self, m_id: usize) -> bool {\n        self.coverage[m_id]\n    }\n\n    /// Returns the number of covered mutations.\n    pub fn num_covered(&self) -> usize {\n        self.num_covered\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::comm::Mutation;\n\n    #[test]\n    fn coverage_collection_empty() {\n        let c = CoverageCollection::new_empty(2);\n\n        assert!(!c.is_covered(1));\n        assert!(!c.is_covered(2))\n    }\n\n    #[test]\n    fn coverage_collection_single_covered() {\n        let c = CoverageCollection::from_coverage_hits(\n            2,\n            &[CoverageHit { mutator_id: 1 }],\n            &[Mutation::new_stub().with_id(1, 1)],\n        );\n\n        assert!(c.is_covered(1));\n        assert!(!c.is_covered(2));\n        assert_eq!(c.num_covered(), 1);\n    }\n    #[test]\n    fn coverage_collection_covered_all_mutations_of_mutator() {\n        let c = CoverageCollection::from_coverage_hits(\n            2,\n            &[CoverageHit { mutator_id: 1 }],\n            &[\n                Mutation::new_stub().with_id(1, 1),\n                Mutation::new_stub().with_id(2, 1),\n            ],\n        );\n\n        assert!(c.is_covered(1));\n        assert!(c.is_covered(2));\n        assert_eq!(c.num_covered(), 2);\n    }\n\n    #[test]\n    fn coverage_collection_merge() {\n        let mutations = [\n            Mutation::new_stub().with_id(1, 1),\n            Mutation::new_stub().with_id(2, 2),\n            Mutation::new_stub().with_id(3, 3),\n            Mutation::new_stub().with_id(4, 3),\n        ];\n        let c1 =\n            CoverageCollection::from_coverage_hits(4, &[CoverageHit { mutator_id: 2 }], &mutations);\n        let c2 =\n            CoverageCollection::from_coverage_hits(4, &[CoverageHit { mutator_id: 3 }], &mutations);\n\n        let c = CoverageCollection::merge(4, &[c1, c2]);\n\n        assert!(c.is_covered(2));\n        assert!(c.is_covered(3));\n        assert!(c.is_covered(4));\n        assert_eq!(c.num_covered(), 3);\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":24},{"path":["/","mnt","c","Users","kms2","Desktop","KAIST","7학기","소프트웨어 테스팅 자동화 기법","PJ","mutagen","mutagen-core","src","comm","mutagen_files.rs"],"content":"use failure::{bail, format_err, Fallible};\nuse serde::{de::DeserializeOwned, Serialize};\nuse std::fs::File;\nuse std::io::{BufRead, BufReader, BufWriter, Write};\nuse std::path::{Path, PathBuf};\nuse std::process::Command;\nuse std::str;\n\nconst DEFAULT_MUTAGEN_DIR: &str = \"target/mutagen\";\nconst DEFAULT_MUTAGEN_FILENAME: &str = \"mutations\";\nconst JSON_MUTAGEN_FILENAME: &str = \"mutations.json\";\n\nconst DEFAULT_COVERAGE_FILENAME: &str = \"coverage\";\n\n/// Finds the file that contains the descriptions of all mutations as written by the procedural macro\npub fn get_mutations_file() -> Fallible<PathBuf> {\n    Ok(mutagen_dir()?.join(DEFAULT_MUTAGEN_FILENAME))\n}\n\npub fn get_mutations_file_json() -> Fallible<PathBuf> {\n    Ok(mutagen_dir()?.join(JSON_MUTAGEN_FILENAME))\n}\n\npub fn get_coverage_file() -> Fallible<PathBuf> {\n    Ok(mutagen_dir()?.join(DEFAULT_COVERAGE_FILENAME))\n}\n\n/// queries `cargo` for the workspace root and locates the directory to write mutagen-specific information\nfn mutagen_dir() -> Fallible<PathBuf> {\n    let metadata = Command::new(\"cargo\").arg(\"metadata\").output()?;\n    if !metadata.status.success() {\n        bail!(\"{}\", str::from_utf8(&metadata.stderr)?);\n    }\n    let meta_json = json::parse(str::from_utf8(&metadata.stdout)?)?;\n    let root_dir = Path::new(\n        meta_json[\"workspace_root\"]\n            .as_str()\n            .ok_or_else(|| format_err!(\"cargo metadata misses workspace_root\"))?,\n    );\n    Ok(root_dir.join(DEFAULT_MUTAGEN_DIR))\n}\n\npub fn read_items<T: DeserializeOwned>(filepath: &Path) -> Fallible<Vec<T>> {\n    BufReader::new(File::open(filepath)?)\n        .lines()\n        .map(|line| {\n            serde_json::from_str(&line?).map_err(|e| format_err!(\"mutation format error: {}\", e))\n        })\n        .collect()\n}\n\npub fn append_item<T: Serialize + ?Sized>(file: &mut File, item: &T) -> Fallible<()> {\n    let mut w = BufWriter::new(file);\n    serde_json::to_writer(&mut w, item)?;\n    writeln!(&mut w)?; // write newline\n    Ok(())\n}\n","traces":[{"line":16,"address":[6025477,6025408],"length":1,"stats":{"Line":0},"fn_name":"get_mutations_file"},{"line":17,"address":[6025492,6025723,6025640,6025418],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[6025824,6025893],"length":1,"stats":{"Line":0},"fn_name":"get_mutations_file_json"},{"line":21,"address":[6026139,6025834,6025908,6026056],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[6026240,6026309],"length":1,"stats":{"Line":0},"fn_name":"get_coverage_file"},{"line":25,"address":[6026324,6026250,6026472,6026555],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[6026716,6026656],"length":1,"stats":{"Line":0},"fn_name":"mutagen_dir"},{"line":30,"address":[6027097,6026731,6026673],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[6027167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[6027244,6027612],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[6027827,6028217,6027206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[6028365,6028466,6028171,6028525],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[5734144,5734156],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":40,"address":[6028717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[5734288,5734345],"length":1,"stats":{"Line":0},"fn_name":"append_item<mutagen_core::comm::mutation::BakedMutation>"},{"line":53,"address":[5734311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[5734539,5734360,5734425,5734601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[5734603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[5734865],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":19},{"path":["/","mnt","c","Users","kms2","Desktop","KAIST","7학기","소프트웨어 테스팅 자동화 기법","PJ","mutagen","mutagen-core","src","comm","mutation.rs"],"content":"use std::ops::Deref;\nuse std::path::{Path, PathBuf};\n\nuse proc_macro2::Span;\nuse serde::{Deserialize, Serialize};\n\nuse crate::transformer::TransformContext;\n\n/// description of a single mutation baked into the code with a given id\n#[derive(Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct BakedMutation {\n    id: usize,\n    // id of the mutator that generates this mutation\n    mutator_id: usize,\n    mutation: Mutation,\n}\n\n// TODO: document fields and getters\n/// Mutation in source code\n#[derive(Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct Mutation {\n    pub impl_name: Option<String>,\n    pub fn_name: Option<String>,\n    pub mutator: String,\n    pub original_code: String,\n    pub mutated_code: String,\n    pub source_file: PathBuf,\n    pub location_in_file: String,\n}\n\nimpl Mutation {\n    pub fn new_spanned(\n        context: &TransformContext,\n        mutator: String,\n        original_code: String,\n        mutated_code: String,\n        span: Span,\n    ) -> Self {\n        let impl_name = context.impl_name.clone();\n        let fn_name = context.fn_name.clone();\n        let start = span.start();\n        let end = span.end();\n        let source_file = span.unwrap().source_file().path();\n        let location_in_file = format!(\n            \"{}:{}-{}:{}\",\n            start.line, start.column, end.line, end.column\n        );\n\n        Self {\n            impl_name,\n            fn_name,\n            mutator,\n            original_code,\n            mutated_code,\n            source_file,\n            location_in_file,\n        }\n    }\n\n    /// Give the mutation an id and mutator id.\n    ///\n    /// This creates a baked mutation.\n    pub fn with_id(self, id: usize, mutator_id: usize) -> BakedMutation {\n        BakedMutation {\n            id,\n            mutator_id,\n            mutation: self,\n        }\n    }\n\n    /// construct a string representation of the mutation\n    pub fn mutation_description(&self) -> String {\n        if self.mutated_code.is_empty() {\n            format!(\"remove `{}`\", &self.original_code)\n        } else if self.original_code.is_empty() {\n            format!(\"insert `{}`\", &self.mutated_code)\n        } else {\n            format!(\n                \"replace `{}` with `{}`\",\n                &self.original_code, &self.mutated_code,\n            )\n        }\n    }\n\n    pub fn context_description_in_brackets(&self) -> String {\n        match (&self.fn_name, &self.impl_name) {\n            (None, None) => format!(\"\"),\n            (Some(fn_name), None) => format!(\"(fn {})\", fn_name),\n            (None, Some(impl_name)) => format!(\"(impl {})\", impl_name),\n            (Some(fn_name), Some(impl_name)) => format!(\"(fn {}::{})\", impl_name, fn_name),\n        }\n    }\n}\n\nimpl BakedMutation {\n    pub fn id(&self) -> usize {\n        self.id\n    }\n\n    pub fn mutator_id(&self) -> usize {\n        self.mutator_id\n    }\n\n    pub fn mutator_name(&self) -> &str {\n        self.mutation.mutator.deref()\n    }\n\n    pub fn fn_name(&self) -> Option<&str> {\n        // TODO: use Option::deref instead\n        self.mutation.fn_name.as_ref().map(String::deref)\n    }\n\n    pub fn original_code(&self) -> &str {\n        self.mutation.original_code.deref()\n    }\n\n    pub fn mutated_code(&self) -> &str {\n        self.mutation.mutated_code.deref()\n    }\n\n    pub fn source_file(&self) -> &Path {\n        self.mutation.source_file.deref()\n    }\n    pub fn location_in_file(&self) -> &str {\n        self.mutation.location_in_file.deref()\n    }\n    pub fn mutation_description(&self) -> String {\n        self.mutation.mutation_description()\n    }\n    pub fn context_description_in_brackets(&self) -> String {\n        self.mutation.context_description_in_brackets()\n    }\n}\n\nimpl AsRef<Mutation> for BakedMutation {\n    fn as_ref(&self) -> &Mutation {\n        &self.mutation\n    }\n}\n\n#[cfg(test)]\nimpl Mutation {\n    /// Create a new mutation for testing purposes.\n    pub fn new_stub() -> Self {\n        Self {\n            impl_name: None,\n            fn_name: None,\n            mutator: \"stub\".to_owned(),\n            original_code: \"stub\".to_owned(),\n            mutated_code: \"stub\".to_owned(),\n            source_file: PathBuf::new(),\n            location_in_file: \"stub\".to_owned(),\n        }\n    }\n}\n","traces":[{"line":32,"address":[5697201,5697104],"length":1,"stats":{"Line":0},"fn_name":"new_spanned"},{"line":39,"address":[5697122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[5697224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[5697357,5697298],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[5697381,5697440],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[5697472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[5697736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[5697712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[5699008],"length":1,"stats":{"Line":0},"fn_name":"with_id"},{"line":72,"address":[5699152],"length":1,"stats":{"Line":0},"fn_name":"mutation_description"},{"line":73,"address":[5699492,5699170,5700102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[5699264],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[5699234,5699501,5699904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[5699676],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[5699921,5699571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[5699533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[5700128],"length":1,"stats":{"Line":0},"fn_name":"context_description_in_brackets"},{"line":86,"address":[5700250,5700554,5700146,5701020,5700787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[5700436,5700169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[5700252,5700566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[5700799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[5700289,5701040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[5701248],"length":1,"stats":{"Line":0},"fn_name":"id"},{"line":97,"address":[5701253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[5701264],"length":1,"stats":{"Line":0},"fn_name":"mutator_id"},{"line":101,"address":[5701269],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[5701280],"length":1,"stats":{"Line":0},"fn_name":"mutator_name"},{"line":105,"address":[5701289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[5701344],"length":1,"stats":{"Line":0},"fn_name":"fn_name"},{"line":110,"address":[5701353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[5701424],"length":1,"stats":{"Line":0},"fn_name":"original_code"},{"line":114,"address":[5701433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[5701488],"length":1,"stats":{"Line":0},"fn_name":"mutated_code"},{"line":118,"address":[5701497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[5701552],"length":1,"stats":{"Line":0},"fn_name":"source_file"},{"line":122,"address":[5701561],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[5701616],"length":1,"stats":{"Line":0},"fn_name":"location_in_file"},{"line":125,"address":[5701625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[5701680],"length":1,"stats":{"Line":0},"fn_name":"mutation_description"},{"line":128,"address":[5701692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[5701728],"length":1,"stats":{"Line":0},"fn_name":"context_description_in_brackets"},{"line":131,"address":[5701740],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[5701776],"length":1,"stats":{"Line":0},"fn_name":"as_ref"},{"line":137,"address":[5701781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":50},{"path":["/","mnt","c","Users","kms2","Desktop","KAIST","7학기","소프트웨어 테스팅 자동화 기법","PJ","mutagen","mutagen-core","src","comm","report.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::collections::{BTreeMap, HashMap};\nuse std::fmt;\n\nuse super::BakedMutation;\n\n#[derive(Serialize, Deserialize, Default)]\npub struct MutagenReport {\n    mutant_results: HashMap<BakedMutation, MutantStatus>,\n    summary: ReportSummary,\n}\n\n#[derive(Copy, Clone, Default, Serialize, Deserialize)]\npub struct ReportSummary {\n    num_mutations: usize,\n    killed: usize,\n    timeout: usize,\n    survived: usize,\n    not_covered: usize,\n}\n\nimpl MutagenReport {\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    pub fn add_mutation_result(&mut self, mutation: BakedMutation, status: MutantStatus) {\n        assert!(!self.mutant_results.contains_key(&mutation));\n        // TODO: instead use: .expect_none(\"mutation already added\");\n        self.mutant_results.insert(mutation, status);\n        self.summary.add_mutation_result(status);\n    }\n\n    /// creates a map of mutations per file.\n    ///\n    /// The map gets iterated in alphabetical order of the files and the list of mutations is sorted by mutation-id\n    fn mutations_per_file(\n        &self,\n    ) -> BTreeMap<&std::path::Path, Vec<(&BakedMutation, MutantStatus)>> {\n        let mut map = BTreeMap::new();\n        // collect mutations by source file\n        for (m, s) in &self.mutant_results {\n            map.entry(m.source_file()).or_insert(vec![]).push((m, *s));\n        }\n        // sort list of mutations per source file by id\n        for (_, ms) in &mut map {\n            ms.sort_unstable_by_key(|(m, _)| m.id());\n        }\n        map\n    }\n\n    pub fn print_survived(&self) {\n        println!(\"SURVIVED\");\n        let mutations_per_file = self.mutations_per_file().into_iter().collect::<Vec<_>>();\n\n        for (file, mutations) in mutations_per_file {\n            let num_mutations = mutations.len();\n            // TODO: use mutations.drain_filter\n            let survived = mutations\n                .into_iter()\n                .filter(|(_, s)| s.survived())\n                .collect::<Vec<_>>();\n            let num_survived = survived.len();\n\n            println!(\"    {}\", file.display());\n            if num_survived == 0 {\n                println!(\"            all {} mutants killed\", num_mutations);\n            } else if num_survived == num_mutations {\n                println!(\"            all {} mutants survived\", num_survived);\n            } else {\n                println!(\n                    \"            {}/{}({:.2}%) mutants survived\",\n                    num_survived,\n                    num_mutations,\n                    compute_percent(num_mutations, num_survived)\n                );\n            }\n            for (m, s) in survived {\n                println!(\n                    \"        {}: {} at {}{}{}\",\n                    m.id(),\n                    m.mutation_description(),\n                    m.location_in_file(),\n                    m.context_description_in_brackets(),\n                    if s == MutantStatus::NotCovered {\n                        format!(\" {}\", MutantStatus::NotCovered)\n                    } else {\n                        \"\".to_owned()\n                    },\n                );\n            }\n        }\n    }\n\n    pub fn summary(&self) -> ReportSummary {\n        self.summary\n    }\n}\n\nimpl ReportSummary {\n    fn add_mutation_result(&mut self, status: MutantStatus) {\n        self.num_mutations += 1;\n        match status {\n            MutantStatus::NotCovered => {\n                self.not_covered += 1;\n                self.survived += 1;\n            }\n            MutantStatus::Survived => self.survived += 1,\n            MutantStatus::Killed(_) => self.killed += 1,\n            MutantStatus::Timeout => {\n                self.timeout += 1;\n                self.killed += 1;\n            }\n        }\n    }\n\n    pub fn print(&self) {\n        let percent_mutations_killed = compute_percent(self.num_mutations, self.killed);\n        let percent_mutations_timeout = compute_percent(self.num_mutations, self.timeout);\n        let percent_mutations_survived = compute_percent(self.num_mutations, self.survived);\n        let percent_mutations_not_covered = compute_percent(self.num_mutations, self.not_covered);\n\n        println!();\n        println!(\"{} generated mutants\", self.num_mutations);\n        println!(\n            \"{}({:.2}%) mutants killed, {}({:.2}%) by timeout\",\n            self.killed, percent_mutations_killed, self.timeout, percent_mutations_timeout,\n        );\n        println!(\n            \"{}({:.2}%) mutants SURVIVED, {}({:.2}%) NOT COVERED\",\n            self.survived,\n            percent_mutations_survived,\n            self.not_covered,\n            percent_mutations_not_covered,\n        );\n    }\n}\n\n/// Result from a test run\n#[derive(Debug, PartialEq, Eq, Copy, Clone, Serialize, Deserialize)]\npub enum MutantStatus {\n    /// The test suite did not cover the mutator\n    NotCovered,\n    /// test pass\n    Survived,\n    /// the test broke with an error code\n    Killed(Option<i32>),\n    /// the test timed out\n    Timeout,\n}\n\nimpl MutantStatus {\n    fn survived(self) -> bool {\n        self == Self::NotCovered || self == Self::Survived\n    }\n}\n\nimpl fmt::Display for MutantStatus {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            Self::NotCovered => write!(f, \"NOT COVERED\"),\n            Self::Survived => write!(f, \"SURVIVED\"),\n            Self::Killed(_) => write!(f, \"killed\"),\n            Self::Timeout => write!(f, \"killed (timeout)\"),\n        }\n    }\n}\n\nfn compute_percent(total: usize, num: usize) -> f64 {\n    100.0 * num as f64 / total as f64\n}\n","traces":[{"line":23,"address":[5705232],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":24,"address":[5705240],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[5705264,5705342],"length":1,"stats":{"Line":0},"fn_name":"add_mutation_result"},{"line":28,"address":[5705293,5705361,5705457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[5705369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[5705492],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[5705584,5705625],"length":1,"stats":{"Line":0},"fn_name":"mutations_per_file"},{"line":40,"address":[5705617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[5705640,5705711,5705820,5706080],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[5705886],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[5706085,5706212,5705793,5706315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[4972720,4972734],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[5706464,5706352],"length":1,"stats":{"Line":0},"fn_name":"print_survived"},{"line":53,"address":[5706373,5706479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[5706493],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[5706558,5710141],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[5707000,5707078],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[5707086],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[4972768,4972782],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":63,"address":[5707215],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[5707258],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[5707529,5707747,5708497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[5707567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[5708495,5707985,5707540],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[5707805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[5708016],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[5707999,5707759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[5708499,5708676,5708722,5710112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[5709378,5709015,5709076],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[5708823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[5708894],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[5708921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[5708988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[5709366,5709034],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[5709121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[5709092],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[5710432],"length":1,"stats":{"Line":0},"fn_name":"summary"},{"line":96,"address":[5710444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[5710480],"length":1,"stats":{"Line":0},"fn_name":"add_mutation_result"},{"line":102,"address":[5710497,5710884],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[5710722,5710774,5710823,5710629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[5710541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[5710636,5711034],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[5711064,5710678,5711094],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[5711004,5710732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[5710974,5710781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[5710914,5710596,5710835],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[5710944,5710839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[5711104],"length":1,"stats":{"Line":0},"fn_name":"print"},{"line":118,"address":[5711120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[5711160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[5711189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[5711218],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[5711244],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[5711319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[5711541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[5711519],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[5712050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[5712028],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[5712043],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[5712480],"length":1,"stats":{"Line":0},"fn_name":"survived"},{"line":154,"address":[5712492,5712570],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[5712592],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":160,"address":[5712954,5712799,5712876,5712725,5712981],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[5712615,5712732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[5712809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[5712883],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[5712672,5712961],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[5713008],"length":1,"stats":{"Line":0},"fn_name":"compute_percent"},{"line":170,"address":[5713021],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":76},{"path":["/","mnt","c","Users","kms2","Desktop","KAIST","7학기","소프트웨어 테스팅 자동화 기법","PJ","mutagen","mutagen-core","src","mutator","mutator_binop_bit.rs"],"content":"//! Mutator for binary bit-operations `|`, `&`, `^`.\n\nuse std::convert::TryFrom;\nuse std::ops::Deref;\nuse std::ops::{BitAnd, BitOr, BitXor};\n\nuse proc_macro2::Span;\nuse quote::quote_spanned;\nuse syn::spanned::Spanned;\nuse syn::{BinOp, Expr};\n\nuse crate::comm::Mutation;\nuse crate::transformer::transform_info::SharedTransformInfo;\nuse crate::transformer::TransformContext;\n\nuse crate::MutagenRuntimeConfig;\n\npub fn run_and<L: BitAnd<R>, R>(\n    mutator_id: usize,\n    left: L,\n    right: R,\n    runtime: impl Deref<Target = MutagenRuntimeConfig>,\n) -> <L as BitAnd<R>>::Output {\n    runtime.covered(mutator_id);\n    let mutations = MutationBinopBit::possible_mutations(BinopBit::And);\n    if let Some(m) = runtime.get_mutation_for_mutator(mutator_id, &mutations) {\n        match m.op {\n            BinopBit::Or => left.and_may_or(right),\n            BinopBit::Xor => left.and_may_xor(right),\n            _ => unreachable!(),\n        }\n    } else {\n        left & right\n    }\n}\npub fn run_or<L: BitOr<R>, R>(\n    mutator_id: usize,\n    left: L,\n    right: R,\n    runtime: impl Deref<Target = MutagenRuntimeConfig>,\n) -> <L as BitOr<R>>::Output {\n    runtime.covered(mutator_id);\n    let mutations = MutationBinopBit::possible_mutations(BinopBit::Or);\n    if let Some(m) = runtime.get_mutation_for_mutator(mutator_id, &mutations) {\n        match m.op {\n            BinopBit::And => left.or_may_and(right),\n            BinopBit::Xor => left.or_may_xor(right),\n            _ => unreachable!(),\n        }\n    } else {\n        left | right\n    }\n}\npub fn run_xor<L: BitXor<R>, R>(\n    mutator_id: usize,\n    left: L,\n    right: R,\n    runtime: impl Deref<Target = MutagenRuntimeConfig>,\n) -> <L as BitXor<R>>::Output {\n    runtime.covered(mutator_id);\n    let mutations = MutationBinopBit::possible_mutations(BinopBit::Xor);\n    if let Some(m) = runtime.get_mutation_for_mutator(mutator_id, &mutations) {\n        match m.op {\n            BinopBit::And => left.xor_may_and(right),\n            BinopBit::Or => left.xor_may_or(right),\n            _ => unreachable!(),\n        }\n    } else {\n        left ^ right\n    }\n}\n\npub fn transform(\n    e: Expr,\n    transform_info: &SharedTransformInfo,\n    context: &TransformContext,\n) -> Expr {\n    let e = match ExprBinopBit::try_from(e) {\n        Ok(e) => e,\n        Err(e) => return e,\n    };\n\n    let mutator_id = transform_info.add_mutations(\n        MutationBinopBit::possible_mutations(e.op)\n            .iter()\n            .map(|m| m.to_mutation(&e, context)),\n    );\n\n    let left = &e.left;\n    let right = &e.right;\n\n    let run_fn = match e.op {\n        BinopBit::And => quote_spanned! {e.span()=> run_and},\n        BinopBit::Or => quote_spanned! {e.span()=> run_or},\n        BinopBit::Xor => quote_spanned! {e.span()=> run_xor},\n    };\n    let op_token = e.op_token;\n    let tmp_var = transform_info.get_next_tmp_var(op_token.span());\n    syn::parse2(quote_spanned! {e.span()=>\n        {\n            let #tmp_var = #left;\n            if false {#tmp_var #op_token #right} else {\n                ::mutagen::mutator::mutator_binop_bit::#run_fn(\n                    #mutator_id,\n                    #tmp_var,\n                    #right,\n                    ::mutagen::MutagenRuntimeConfig::get_default()\n                )\n            }\n        }\n    })\n    .expect(\"transformed code invalid\")\n}\n\n#[derive(Copy, Clone, Debug, PartialEq, Eq)]\nstruct MutationBinopBit {\n    op: BinopBit,\n}\n\nimpl MutationBinopBit {\n    fn possible_mutations(original_op: BinopBit) -> Vec<Self> {\n        [BinopBit::And, BinopBit::Or, BinopBit::Xor]\n            .iter()\n            .copied()\n            .filter(|&op| op != original_op)\n            .map(|op| MutationBinopBit { op })\n            .collect()\n    }\n\n    fn to_mutation(self, original_expr: &ExprBinopBit, context: &TransformContext) -> Mutation {\n        Mutation::new_spanned(\n            &context,\n            \"binop_bit\".to_owned(),\n            format!(\"{}\", original_expr.op),\n            format!(\"{}\", self.op),\n            original_expr.span(),\n        )\n    }\n}\n\n#[derive(Clone, Debug)]\nstruct ExprBinopBit {\n    op: BinopBit,\n    left: Expr,\n    right: Expr,\n    op_token: syn::BinOp,\n}\n\nimpl TryFrom<Expr> for ExprBinopBit {\n    type Error = Expr;\n    fn try_from(expr: Expr) -> Result<Self, Expr> {\n        match expr {\n            Expr::Binary(expr) => match expr.op {\n                BinOp::BitAnd(_) => Ok(ExprBinopBit {\n                    op: BinopBit::And,\n                    left: *expr.left,\n                    right: *expr.right,\n                    op_token: expr.op,\n                }),\n                BinOp::BitOr(_) => Ok(ExprBinopBit {\n                    op: BinopBit::Or,\n                    left: *expr.left,\n                    right: *expr.right,\n                    op_token: expr.op,\n                }),\n                BinOp::BitXor(_) => Ok(ExprBinopBit {\n                    op: BinopBit::Xor,\n                    left: *expr.left,\n                    right: *expr.right,\n                    op_token: expr.op,\n                }),\n                _ => Err(Expr::Binary(expr)),\n            },\n            _ => Err(expr),\n        }\n    }\n}\n\nimpl syn::spanned::Spanned for ExprBinopBit {\n    fn span(&self) -> Span {\n        self.op_token.span()\n    }\n}\n\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\nenum BinopBit {\n    And,\n    Or,\n    Xor,\n}\n\nuse std::fmt;\n\nimpl fmt::Display for BinopBit {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            BinopBit::And => write!(f, \"&\"),\n            BinopBit::Or => write!(f, \"|\"),\n            BinopBit::Xor => write!(f, \"^\"),\n        }\n    }\n}\n\n// specification of the traits `AndToOr`, `OrToAnd`, ...\n//\n// These traits consist of a function `max_x` that panics if the operation `x`\n// cannot be performed due to type constraints\nmacro_rules! binary_x_to_y {\n    { $($may_ty:ident, $may_fn:ident, $t1:ident, $t2:ident, $t2_op:tt,)* } => {\n        $(\n            trait $may_ty<R> {\n                type Output;\n                fn $may_fn(self, r: R) -> Self::Output;\n            }\n\n            impl <L, R> $may_ty<R> for L where L: $t1<R> {\n                type Output = <L as $t1<R>>::Output;\n                default fn $may_fn(self, _r: R) -> <L as $t1<R>>::Output {\n                    MutagenRuntimeConfig::get_default().optimistic_assumption_failed();\n                }\n            }\n\n            impl<L, R> $may_ty<R> for L\n            where\n                L: $t1<R>,\n                L: $t2<R>,\n                <L as $t2<R>>::Output: Into<<L as $t1<R>>::Output>,\n            {\n                fn $may_fn(self, r: R) -> Self::Output {\n                    (self $t2_op r).into()\n                }\n            }\n        )*\n\n    }\n}\n\nbinary_x_to_y!(\n    AndToOr, and_may_or, BitAnd, BitOr, |,\n    AndToXor, and_may_xor, BitAnd, BitXor, ^,\n    OrToAnd, or_may_and, BitOr, BitAnd, &,\n    OrToXor, or_may_xor, BitOr, BitXor, ^,\n    XorToAnd, xor_may_and, BitXor, BitAnd, &,\n    XorToOr, xor_may_or, BitXor, BitOr, |,\n);\n\n#[cfg(test)]\nmod tests {\n\n    use super::*;\n\n    #[test]\n    fn and_inactive() {\n        let result = run_and(1, 0b11, 0b10, &MutagenRuntimeConfig::without_mutation());\n        assert_eq!(result, 0b10);\n    }\n    #[test]\n    fn and_active1() {\n        let result = run_and(1, 0b11, 0b10, &MutagenRuntimeConfig::with_mutation_id(1));\n        assert_eq!(result, 0b11);\n    }\n    #[test]\n    fn and_active2() {\n        let result = run_and(1, 0b11, 0b10, &MutagenRuntimeConfig::with_mutation_id(2));\n        assert_eq!(result, 0b01);\n    }\n\n    #[test]\n    fn or_inactive() {\n        let result = run_or(1, 0b11, 0b10, &MutagenRuntimeConfig::without_mutation());\n        assert_eq!(result, 0b11);\n    }\n    #[test]\n    fn or_active1() {\n        let result = run_or(1, 0b11, 0b10, &MutagenRuntimeConfig::with_mutation_id(1));\n        assert_eq!(result, 0b10);\n    }\n    #[test]\n    fn or_active2() {\n        let result = run_or(1, 0b11, 0b10, &MutagenRuntimeConfig::with_mutation_id(2));\n        assert_eq!(result, 0b01);\n    }\n\n    #[test]\n    fn xor_inactive() {\n        let result = run_xor(1, 0b11, 0b10, &MutagenRuntimeConfig::without_mutation());\n        assert_eq!(result, 0b01);\n    }\n    #[test]\n    fn xor_active1() {\n        let result = run_xor(1, 0b11, 0b10, &MutagenRuntimeConfig::with_mutation_id(1));\n        assert_eq!(result, 0b10);\n    }\n    #[test]\n    fn xor_active2() {\n        let result = run_xor(1, 0b11, 0b10, &MutagenRuntimeConfig::with_mutation_id(2));\n        assert_eq!(result, 0b11);\n    }\n}\n","traces":[{"line":36,"address":[4213664,4213784],"length":1,"stats":{"Line":1},"fn_name":"run_or<u32,u32,std::sync::rwlock::RwLockReadGuard<mutagen_core::runtime_config::MutagenRuntimeConfig>>"},{"line":42,"address":[4213698],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4213844],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[4213941,4213870,4214032,4214199],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[4214154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[4214111,4214048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[4214156],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[4214205,4213994],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[4663312,4663428],"length":1,"stats":{"Line":0},"fn_name":"transform"},{"line":78,"address":[4663558,4663344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[4663560,4663443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[4663458],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[4663911],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[4663740,4663863,4663671],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[4663839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[4663983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[4663991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[4664437,4664251,4664068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[4664007,4664070],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[4664256],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[4664046,4664442],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[4664604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[4664652],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[4664733,4664795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[4667824],"length":1,"stats":{"Line":1},"fn_name":"possible_mutations"},{"line":122,"address":[4667836,4667913],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[4667903],"length":1,"stats":{"Line":3},"fn_name":null},{"line":126,"address":[4732830,4732816],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":130,"address":[4668102,4667984],"length":1,"stats":{"Line":0},"fn_name":"to_mutation"},{"line":132,"address":[4668019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[4668048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[4668117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[4668334],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[4668545],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[4668848,4668940],"length":1,"stats":{"Line":0},"fn_name":"try_from"},{"line":152,"address":[4670450,4669073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[4669078,4669438,4668864,4669768,4670074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[4669597,4669170],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[4669443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[4669497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[4669543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[4669915],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[4669773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[4669821],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[4669861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[4670221],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[4670079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[4670127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[4670167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[4669242],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[4668955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[4670736],"length":1,"stats":{"Line":0},"fn_name":"span"},{"line":181,"address":[4670748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[4670784],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":196,"address":[4670978,4670904,4671079,4671052],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[4670911,4670807],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[4670985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[4671059,4670851],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[4214432,4214480],"length":1,"stats":{"Line":0},"fn_name":"or_may_and<u32,u32>"},{"line":230,"address":[4214444,4214492],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":9,"coverable":63},{"path":["/","mnt","c","Users","kms2","Desktop","KAIST","7학기","소프트웨어 테스팅 자동화 기법","PJ","mutagen","mutagen-core","src","mutator","mutator_binop_bool.rs"],"content":"//! Mutator for binary operations `&&` and `||`.\n\nuse std::convert::TryFrom;\nuse std::ops::Deref;\n\nuse proc_macro2::{Span, TokenStream};\nuse quote::quote_spanned;\nuse syn::spanned::Spanned;\nuse syn::{BinOp, Expr};\n\nuse crate::comm::Mutation;\nuse crate::transformer::transform_info::SharedTransformInfo;\nuse crate::transformer::TransformContext;\n\nuse crate::MutagenRuntimeConfig;\n\npub fn run_left(\n    mutator_id: usize,\n    original_op: BinopBool,\n    left: bool,\n    runtime: impl Deref<Target = MutagenRuntimeConfig>,\n) -> Option<bool> {\n    runtime.covered(mutator_id);\n    let mutations = MutationBinopBool::possible_mutations(original_op);\n    let op = runtime\n        .get_mutation_for_mutator(mutator_id, &mutations)\n        .map(|m| m.op)\n        .unwrap_or(original_op);\n    op.short_circuit_left(left)\n}\n\npub fn transform(\n    e: Expr,\n    transform_info: &SharedTransformInfo,\n    context: &TransformContext,\n) -> Expr {\n    let e = match ExprBinopBool::try_from(e) {\n        Ok(e) => e,\n        Err(e) => return e,\n    };\n\n    let mutator_id = transform_info.add_mutations(\n        MutationBinopBool::possible_mutations(e.op)\n            .iter()\n            .map(|m| m.to_mutation(&e, context)),\n    );\n\n    let left = &e.left;\n    let right = &e.right;\n    let op = e.op_tokens();\n\n    syn::parse2(quote_spanned! {e.span=>\n        if let Some(x) = ::mutagen::mutator::mutator_binop_bool::run_left(\n                #mutator_id,\n                #op,\n                #left,\n                ::mutagen::MutagenRuntimeConfig::get_default()\n            ) {\n            x\n        } else {\n            #right\n        }\n    })\n    .expect(\"transformed code invalid\")\n}\n\n#[derive(Copy, Clone, Debug, PartialEq, Eq)]\nstruct MutationBinopBool {\n    op: BinopBool,\n}\n\nimpl MutationBinopBool {\n    fn possible_mutations(original_op: BinopBool) -> Vec<Self> {\n        [BinopBool::And, BinopBool::Or]\n            .iter()\n            .copied()\n            .filter(|&op| op != original_op)\n            .map(|op| MutationBinopBool { op })\n            .collect()\n    }\n\n    fn to_mutation(self, original_op: &ExprBinopBool, context: &TransformContext) -> Mutation {\n        Mutation::new_spanned(\n            &context,\n            \"binop_bool\".to_owned(),\n            format!(\"{}\", original_op),\n            format!(\"{}\", self.op),\n            original_op.span,\n        )\n    }\n}\n\n#[derive(Clone, Debug)]\nstruct ExprBinopBool {\n    op: BinopBool,\n    left: Expr,\n    right: Expr,\n    span: Span,\n}\n\nimpl TryFrom<Expr> for ExprBinopBool {\n    type Error = Expr;\n    fn try_from(expr: Expr) -> Result<Self, Expr> {\n        match expr {\n            Expr::Binary(expr) => match expr.op {\n                BinOp::And(t) => Ok(ExprBinopBool {\n                    op: BinopBool::And,\n                    left: *expr.left,\n                    right: *expr.right,\n                    span: t.span(),\n                }),\n                BinOp::Or(t) => Ok(ExprBinopBool {\n                    op: BinopBool::Or,\n                    left: *expr.left,\n                    right: *expr.right,\n                    span: t.span(),\n                }),\n                _ => Err(Expr::Binary(expr)),\n            },\n            _ => Err(expr),\n        }\n    }\n}\n\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\npub enum BinopBool {\n    And,\n    Or,\n}\n\nimpl BinopBool {\n    pub fn short_circuit_left(self, left: bool) -> Option<bool> {\n        match self {\n            BinopBool::And if !left => Some(false),\n            BinopBool::Or if left => Some(true),\n            _ => None,\n        }\n    }\n}\n\nimpl ExprBinopBool {\n    fn op_tokens(&self) -> TokenStream {\n        let mut tokens = TokenStream::new();\n        tokens.extend(quote_spanned!(self.span=>\n            ::mutagen::mutator::mutator_binop_bool::BinopBool::));\n        tokens.extend(match self.op {\n            BinopBool::And => quote_spanned!(self.span=> And),\n            BinopBool::Or => quote_spanned!(self.span=> Or),\n        });\n        tokens\n    }\n}\n\nuse std::fmt;\n\nimpl fmt::Display for BinopBool {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            BinopBool::And => write!(f, \"&&\"),\n            BinopBool::Or => write!(f, \"||\"),\n        }\n    }\n}\n\nimpl fmt::Display for ExprBinopBool {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{}\", self.op)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::*;\n\n    #[test]\n    fn possible_mutations_and() {\n        assert_eq!(\n            MutationBinopBool::possible_mutations(BinopBool::And),\n            vec![MutationBinopBool { op: BinopBool::Or }]\n        )\n    }\n\n    #[test]\n    fn possible_mutations_or() {\n        assert_eq!(\n            MutationBinopBool::possible_mutations(BinopBool::Or),\n            vec![MutationBinopBool { op: BinopBool::And }]\n        )\n    }\n\n    #[test]\n    fn short_circuit_left_and_false() {\n        assert_eq!(BinopBool::And.short_circuit_left(false), Some(false))\n    }\n    #[test]\n    fn short_circuit_left_and_true() {\n        assert_eq!(BinopBool::And.short_circuit_left(true), None)\n    }\n\n    #[test]\n    fn short_circuit_left_or_false() {\n        assert_eq!(BinopBool::Or.short_circuit_left(false), None)\n    }\n    #[test]\n    fn short_circuit_left_or_true() {\n        assert_eq!(BinopBool::Or.short_circuit_left(true), Some(true))\n    }\n\n    #[test]\n    fn mutator_and_inactive() {\n        assert_eq!(\n            run_left(\n                1,\n                BinopBool::And,\n                true,\n                &MutagenRuntimeConfig::without_mutation()\n            ),\n            None\n        );\n        assert_eq!(\n            run_left(\n                1,\n                BinopBool::And,\n                false,\n                &MutagenRuntimeConfig::without_mutation()\n            ),\n            Some(false)\n        );\n    }\n    #[test]\n    fn mutator_and_active() {\n        assert_eq!(\n            run_left(\n                1,\n                BinopBool::And,\n                true,\n                &MutagenRuntimeConfig::with_mutation_id(1)\n            ),\n            Some(true)\n        );\n        assert_eq!(\n            run_left(\n                1,\n                BinopBool::And,\n                false,\n                &MutagenRuntimeConfig::with_mutation_id(1)\n            ),\n            None\n        );\n    }\n\n    #[test]\n    fn mutator_or_inactive() {\n        assert_eq!(\n            run_left(\n                1,\n                BinopBool::Or,\n                true,\n                &MutagenRuntimeConfig::without_mutation()\n            ),\n            Some(true)\n        );\n        assert_eq!(\n            run_left(\n                1,\n                BinopBool::Or,\n                false,\n                &MutagenRuntimeConfig::without_mutation()\n            ),\n            None\n        );\n    }\n    #[test]\n    fn mutator_or_active() {\n        assert_eq!(\n            run_left(\n                1,\n                BinopBool::Or,\n                true,\n                &MutagenRuntimeConfig::with_mutation_id(1)\n            ),\n            None\n        );\n        assert_eq!(\n            run_left(\n                1,\n                BinopBool::Or,\n                false,\n                &MutagenRuntimeConfig::with_mutation_id(1)\n            ),\n            Some(false)\n        );\n    }\n}\n","traces":[{"line":17,"address":[4219424,4219522],"length":1,"stats":{"Line":1},"fn_name":"run_left<std::sync::rwlock::RwLockReadGuard<mutagen_core::runtime_config::MutagenRuntimeConfig>>"},{"line":23,"address":[4219477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[4219554],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[4219583,4219654],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[4219595],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[4219856,4219865],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}<std::sync::rwlock::RwLockReadGuard<mutagen_core::runtime_config::MutagenRuntimeConfig>>"},{"line":29,"address":[4219729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[4544816,4544932],"length":1,"stats":{"Line":0},"fn_name":"transform"},{"line":37,"address":[4545062,4544848],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[4545064,4544947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[4544962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[4545410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[4545245,4545365,4545175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[4545341],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[4545482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[4545490],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[4545514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[4545676,4545524],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[4548576],"length":1,"stats":{"Line":1},"fn_name":"possible_mutations"},{"line":74,"address":[4548669,4548592],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[4548659],"length":1,"stats":{"Line":3},"fn_name":null},{"line":78,"address":[5736946,5736928],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":82,"address":[4548752,4548855],"length":1,"stats":{"Line":0},"fn_name":"to_mutation"},{"line":84,"address":[4548788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[4548809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[4548870],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[4549081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[4549284],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[4549536,4549622],"length":1,"stats":{"Line":0},"fn_name":"try_from"},{"line":104,"address":[4549755,4550963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[4550795,4549546,4550082,4549760,4550400],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[4550087,4550227,4549852],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[4550119],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[4550162],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[4550195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[4550482,4550622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[4550514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[4550557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[4550590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[4549904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[4549637],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[4551280],"length":1,"stats":{"Line":1},"fn_name":"short_circuit_left"},{"line":133,"address":[4551343,4551381,4551362],"length":1,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[4551338],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[4551408,4551449],"length":1,"stats":{"Line":0},"fn_name":"op_tokens"},{"line":143,"address":[4551441],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[4551589,4551464],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[4552613,4552272,4552634,4552441],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[4552234,4552274,4552446],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[4552470,4552250,4552615],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[4552752],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":158,"address":[4552844,4552918,4552942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[4552775,4552851],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[4552797,4552925],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[4552976],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":167,"address":[4553006],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":13,"coverable":60},{"path":["/","mnt","c","Users","kms2","Desktop","KAIST","7학기","소프트웨어 테스팅 자동화 기법","PJ","mutagen","mutagen-core","src","mutator","mutator_binop_cmp.rs"],"content":"//! Mutator for comparison operations `<`, `<=`, `=>`, `>`\n\nuse std::convert::TryFrom;\nuse std::ops::Deref;\n\nuse proc_macro2::{Span, TokenStream};\nuse quote::quote_spanned;\nuse syn::spanned::Spanned;\nuse syn::{BinOp, Expr};\n\nuse crate::comm::Mutation;\nuse crate::transformer::transform_info::SharedTransformInfo;\nuse crate::transformer::TransformContext;\n\nuse crate::MutagenRuntimeConfig;\n\npub fn run<L: PartialOrd<R>, R>(\n    mutator_id: usize,\n    left: L,\n    right: R,\n    original_op: BinopCmp,\n    runtime: impl Deref<Target = MutagenRuntimeConfig>,\n) -> bool {\n    runtime.covered(mutator_id);\n    let mutations = MutationBinopCmp::possible_mutations(original_op);\n    if let Some(m) = runtime.get_mutation_for_mutator(mutator_id, &mutations) {\n        m.mutate(left, right)\n    } else {\n        original_op.cmp(left, right)\n    }\n}\n\npub fn transform(\n    e: Expr,\n    transform_info: &SharedTransformInfo,\n    context: &TransformContext,\n) -> Expr {\n    let e = match ExprBinopCmp::try_from(e) {\n        Ok(e) => e,\n        Err(e) => return e,\n    };\n\n    let mutator_id = transform_info.add_mutations(\n        MutationBinopCmp::possible_mutations(e.op)\n            .iter()\n            .map(|m| m.to_mutation(&e, context)),\n    );\n\n    let left = &e.left;\n    let right = &e.right;\n    let op = e.op_tokens();\n\n    syn::parse2(quote_spanned! {e.span=>\n        ::mutagen::mutator::mutator_binop_cmp::run(\n                #mutator_id,\n                &(#left),\n                &(#right),\n                #op,\n                ::mutagen::MutagenRuntimeConfig::get_default()\n            )\n    })\n    .expect(\"transformed code invalid\")\n}\n\n#[derive(Copy, Clone, Debug, PartialEq, Eq)]\nstruct MutationBinopCmp {\n    op: BinopCmp,\n}\n\nimpl MutationBinopCmp {\n    fn possible_mutations(original_op: BinopCmp) -> Vec<Self> {\n        [BinopCmp::Lt, BinopCmp::Le, BinopCmp::Ge, BinopCmp::Gt]\n            .iter()\n            .copied()\n            .filter(|&op| op != original_op)\n            .map(|op| MutationBinopCmp { op })\n            .collect()\n    }\n\n    fn mutate<L: PartialOrd<R>, R>(self, left: L, right: R) -> bool {\n        self.op.cmp(left, right)\n    }\n\n    fn to_mutation(self, original_op: &ExprBinopCmp, context: &TransformContext) -> Mutation {\n        Mutation::new_spanned(\n            &context,\n            \"binop_cmp\".to_owned(),\n            format!(\"{}\", original_op.op),\n            format!(\"{}\", self.op),\n            original_op.span,\n        )\n    }\n}\n\n#[derive(Clone, Debug)]\nstruct ExprBinopCmp {\n    op: BinopCmp,\n    left: Expr,\n    right: Expr,\n    span: Span,\n}\n\nimpl TryFrom<Expr> for ExprBinopCmp {\n    type Error = Expr;\n    fn try_from(expr: Expr) -> Result<Self, Expr> {\n        match expr {\n            Expr::Binary(expr) => match expr.op {\n                BinOp::Lt(t) => Ok(ExprBinopCmp {\n                    op: BinopCmp::Lt,\n                    left: *expr.left,\n                    right: *expr.right,\n                    span: t.span(),\n                }),\n                BinOp::Le(t) => Ok(ExprBinopCmp {\n                    op: BinopCmp::Le,\n                    left: *expr.left,\n                    right: *expr.right,\n                    span: t.span(),\n                }),\n                BinOp::Ge(t) => Ok(ExprBinopCmp {\n                    op: BinopCmp::Ge,\n                    left: *expr.left,\n                    right: *expr.right,\n                    span: t.span(),\n                }),\n                BinOp::Gt(t) => Ok(ExprBinopCmp {\n                    op: BinopCmp::Gt,\n                    left: *expr.left,\n                    right: *expr.right,\n                    span: t.span(),\n                }),\n                _ => Err(Expr::Binary(expr)),\n            },\n            _ => Err(expr),\n        }\n    }\n}\n\nimpl ExprBinopCmp {\n    fn op_tokens(&self) -> TokenStream {\n        let mut tokens = TokenStream::new();\n        tokens.extend(quote_spanned!(self.span=>\n            ::mutagen::mutator::mutator_binop_cmp::BinopCmp::));\n        tokens.extend(match self.op {\n            BinopCmp::Lt => quote_spanned!(self.span=> Lt),\n            BinopCmp::Le => quote_spanned!(self.span=> Le),\n            BinopCmp::Ge => quote_spanned!(self.span=> Ge),\n            BinopCmp::Gt => quote_spanned!(self.span=> Gt),\n        });\n        tokens\n    }\n}\n\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\npub enum BinopCmp {\n    Lt,\n    Le,\n    Ge,\n    Gt,\n}\n\nimpl BinopCmp {\n    fn cmp<L: PartialOrd<R>, R>(self, left: L, right: R) -> bool {\n        match self {\n            BinopCmp::Lt => left < right,\n            BinopCmp::Le => left <= right,\n            BinopCmp::Ge => left >= right,\n            BinopCmp::Gt => left > right,\n        }\n    }\n}\n\nuse std::fmt;\n\nimpl fmt::Display for BinopCmp {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            BinopCmp::Lt => write!(f, \"<\"),\n            BinopCmp::Le => write!(f, \"<=\"),\n            BinopCmp::Ge => write!(f, \">=\"),\n            BinopCmp::Gt => write!(f, \">\"),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::*;\n\n    #[test]\n    fn possible_mutations_le() {\n        assert_eq!(\n            MutationBinopCmp::possible_mutations(BinopCmp::Le),\n            vec![\n                MutationBinopCmp { op: BinopCmp::Lt },\n                MutationBinopCmp { op: BinopCmp::Ge },\n                MutationBinopCmp { op: BinopCmp::Gt },\n            ]\n        )\n    }\n\n    #[test]\n    fn possible_mutations_gt() {\n        assert_eq!(\n            MutationBinopCmp::possible_mutations(BinopCmp::Gt),\n            vec![\n                MutationBinopCmp { op: BinopCmp::Lt },\n                MutationBinopCmp { op: BinopCmp::Le },\n                MutationBinopCmp { op: BinopCmp::Ge },\n            ]\n        )\n    }\n\n    #[test]\n    fn cmp_lt() {\n        assert_eq!(BinopCmp::Lt.cmp(1, 2), true);\n        assert_eq!(BinopCmp::Lt.cmp(3, 3), false);\n        assert_eq!(BinopCmp::Lt.cmp(5, 4), false);\n    }\n\n    #[test]\n    fn cmp_le() {\n        assert_eq!(BinopCmp::Le.cmp(1, 2), true);\n        assert_eq!(BinopCmp::Le.cmp(3, 3), true);\n        assert_eq!(BinopCmp::Le.cmp(5, 4), false);\n    }\n\n    #[test]\n    fn cmp_ge() {\n        assert_eq!(BinopCmp::Ge.cmp(1, 2), false);\n        assert_eq!(BinopCmp::Ge.cmp(3, 3), true);\n        assert_eq!(BinopCmp::Ge.cmp(5, 4), true);\n    }\n\n    #[test]\n    fn cmp_gt() {\n        assert_eq!(BinopCmp::Gt.cmp(1, 2), false);\n        assert_eq!(BinopCmp::Gt.cmp(3, 3), false);\n        assert_eq!(BinopCmp::Gt.cmp(5, 4), true);\n    }\n\n    use crate::MutagenRuntimeConfig;\n\n    #[test]\n    fn mutator_cmp_gt_inactive() {\n        assert_eq!(\n            run(\n                1,\n                1,\n                2,\n                BinopCmp::Gt,\n                &MutagenRuntimeConfig::without_mutation()\n            ),\n            false\n        );\n        assert_eq!(\n            run(\n                1,\n                5,\n                4,\n                BinopCmp::Gt,\n                &MutagenRuntimeConfig::without_mutation()\n            ),\n            true\n        );\n    }\n    #[test]\n    fn mutator_cmp_gt_active1() {\n        assert_eq!(\n            run(\n                1,\n                1,\n                2,\n                BinopCmp::Gt,\n                &MutagenRuntimeConfig::with_mutation_id(1)\n            ),\n            true\n        );\n        assert_eq!(\n            run(\n                1,\n                3,\n                3,\n                BinopCmp::Gt,\n                &MutagenRuntimeConfig::with_mutation_id(1)\n            ),\n            false\n        );\n    }\n}\n","traces":[{"line":17,"address":[4210752,4210144,4211360,4211495,4210279,4210887],"length":1,"stats":{"Line":4},"fn_name":"run<&u8,&u8,std::sync::rwlock::RwLockReadGuard<mutagen_core::runtime_config::MutagenRuntimeConfig>>"},{"line":24,"address":[4210795,4211403,4210187],"length":1,"stats":{"Line":4},"fn_name":null},{"line":25,"address":[4210951,4211559,4210343],"length":1,"stats":{"Line":4},"fn_name":null},{"line":26,"address":[4210535,4210975,4211751,4210438,4210601,4211817,4210367,4211654,4211046,4211209,4211583,4211143],"length":1,"stats":{"Line":12},"fn_name":null},{"line":27,"address":[4210551,4211159,4211767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[4211099,4211823,4210607,4210491,4211215,4211707],"length":1,"stats":{"Line":14},"fn_name":null},{"line":33,"address":[5606564,5606448],"length":1,"stats":{"Line":0},"fn_name":"transform"},{"line":38,"address":[5606480,5606694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[5606696,5606579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[5606594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[5607011],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[5606792,5606858,5606966],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[4926240,4926257],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":49,"address":[5607083],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[5607091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[5607115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[5607125,5607250],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[5609584],"length":1,"stats":{"Line":2},"fn_name":"possible_mutations"},{"line":72,"address":[5609673,5609596],"length":1,"stats":{"Line":4},"fn_name":null},{"line":75,"address":[4926320,4926334],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":76,"address":[4926384,4926398],"length":1,"stats":{"Line":5},"fn_name":"{{closure}}"},{"line":80,"address":[4210048,4210000,4210096],"length":1,"stats":{"Line":0},"fn_name":"mutate<&i32,&i32>"},{"line":81,"address":[4210019,4210115,4210067],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[5609744,5609864],"length":1,"stats":{"Line":0},"fn_name":"to_mutation"},{"line":86,"address":[5609783],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[5609807],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[5609879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[5610096],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[5610304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[5610668,5610576],"length":1,"stats":{"Line":0},"fn_name":"try_from"},{"line":106,"address":[5612794,5610801],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[5611916,5610806,5610592,5612626,5611506,5612269,5611148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[5611318,5610898,5611153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[5611183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[5611241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[5611283],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[5611743,5611588],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[5611620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[5611669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[5611711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[5612096,5611956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[5611988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[5612031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[5612064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[5612309,5612453],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[5612339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[5612388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[5612421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[5610952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[5610683],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[5613193,5613152],"length":1,"stats":{"Line":0},"fn_name":"op_tokens"},{"line":141,"address":[5613185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[5613208,5613333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[5614038,5614207,5614589,5614780,5614398,5614759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[5613981,5614040,5614212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[5614403,5614231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[5614594,5614422],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[5614016,5614618,5614761],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[4211968,4212260,4212448,4212208,4212020,4212500],"length":1,"stats":{"Line":7},"fn_name":"cmp<&u8,&u8>"},{"line":164,"address":[4212566,4212363,4212396,4212533,4212086,4212603,4212326,4212636,4212053,4212123,4212156,4212293],"length":1,"stats":{"Line":4},"fn_name":null},{"line":165,"address":[4212545,4212305,4212227,4211987,4212065,4212467],"length":1,"stats":{"Line":7},"fn_name":null},{"line":166,"address":[4212582,4212102,4212342],"length":1,"stats":{"Line":4},"fn_name":null},{"line":167,"address":[4212375,4212615,4212135],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[4212642,4212402,4212282,4212042,4212162,4212522],"length":1,"stats":{"Line":14},"fn_name":null},{"line":176,"address":[5614944],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":177,"address":[5615061,5615212,5615317,5615135,5615290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[5614967,5615068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[5615145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[5615219],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[5615008,5615297],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":14,"coverable":76},{"path":["/","mnt","c","Users","kms2","Desktop","KAIST","7학기","소프트웨어 테스팅 자동화 기법","PJ","mutagen","mutagen-core","src","mutator","mutator_binop_eq.rs"],"content":"//! Mutator for binary operations `==` and `!=`\n\nuse std::convert::TryFrom;\nuse std::ops::Deref;\n\nuse proc_macro2::{Span, TokenStream};\nuse quote::quote_spanned;\nuse syn::spanned::Spanned;\nuse syn::{BinOp, Expr};\n\nuse crate::comm::Mutation;\nuse crate::transformer::transform_info::SharedTransformInfo;\nuse crate::transformer::TransformContext;\n\nuse crate::MutagenRuntimeConfig;\n\npub fn run<L: PartialEq<R>, R>(\n    mutator_id: usize,\n    left: L,\n    right: R,\n    original_op: BinopEq,\n    runtime: impl Deref<Target = MutagenRuntimeConfig>,\n) -> bool {\n    runtime.covered(mutator_id);\n    let mutations = MutationBinopEq::possible_mutations(original_op);\n    if let Some(m) = runtime.get_mutation_for_mutator(mutator_id, &mutations) {\n        m.mutate(left, right)\n    } else {\n        original_op.eq(left, right)\n    }\n}\n\npub fn transform(\n    e: Expr,\n    transform_info: &SharedTransformInfo,\n    context: &TransformContext,\n) -> Expr {\n    let e = match ExprBinopEq::try_from(e) {\n        Ok(e) => e,\n        Err(e) => return e,\n    };\n\n    let mutator_id = transform_info.add_mutations(\n        MutationBinopEq::possible_mutations(e.op)\n            .iter()\n            .map(|m| m.to_mutation(&e, context)),\n    );\n\n    let left = &e.left;\n    let right = &e.right;\n    let op = e.op_tokens();\n\n    syn::parse2(quote_spanned! {e.span=>\n        ::mutagen::mutator::mutator_binop_eq::run(\n                #mutator_id,\n                &(#left),\n                &(#right),\n                #op,\n                ::mutagen::MutagenRuntimeConfig::get_default()\n            )\n    })\n    .expect(\"transformed code invalid\")\n}\n\n#[derive(Copy, Clone, Debug, PartialEq, Eq)]\nstruct MutationBinopEq {\n    op: BinopEq,\n}\n\nimpl MutationBinopEq {\n    fn possible_mutations(original_op: BinopEq) -> Vec<Self> {\n        [BinopEq::Eq, BinopEq::Ne]\n            .iter()\n            .copied()\n            .filter(|&op| op != original_op)\n            .map(|op| MutationBinopEq { op })\n            .collect()\n    }\n\n    fn mutate<L: PartialEq<R>, R>(self, left: L, right: R) -> bool {\n        self.op.eq(left, right)\n    }\n\n    fn to_mutation(self, original_op: &ExprBinopEq, context: &TransformContext) -> Mutation {\n        Mutation::new_spanned(\n            &context,\n            \"binop_eq\".to_owned(),\n            format!(\"{}\", original_op.op),\n            format!(\"{}\", self.op),\n            original_op.span,\n        )\n    }\n}\n\n#[derive(Clone, Debug)]\nstruct ExprBinopEq {\n    op: BinopEq,\n    left: Expr,\n    right: Expr,\n    span: Span,\n}\n\nimpl TryFrom<Expr> for ExprBinopEq {\n    type Error = Expr;\n    fn try_from(expr: Expr) -> Result<Self, Expr> {\n        match expr {\n            Expr::Binary(expr) => match expr.op {\n                BinOp::Eq(t) => Ok(ExprBinopEq {\n                    op: BinopEq::Eq,\n                    left: *expr.left,\n                    right: *expr.right,\n                    span: t.span(),\n                }),\n                BinOp::Ne(t) => Ok(ExprBinopEq {\n                    op: BinopEq::Ne,\n                    left: *expr.left,\n                    right: *expr.right,\n                    span: t.span(),\n                }),\n                _ => Err(Expr::Binary(expr)),\n            },\n            _ => Err(expr),\n        }\n    }\n}\n\nimpl ExprBinopEq {\n    fn op_tokens(&self) -> TokenStream {\n        let mut tokens = TokenStream::new();\n        tokens.extend(quote_spanned!(self.span=>\n                ::mutagen::mutator::mutator_binop_eq::BinopEq::));\n        tokens.extend(match self.op {\n            BinopEq::Eq => quote_spanned!(self.span=> Eq),\n            BinopEq::Ne => quote_spanned!(self.span=> Ne),\n        });\n        tokens\n    }\n}\n\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\npub enum BinopEq {\n    Eq,\n    Ne,\n}\n\nimpl BinopEq {\n    fn eq<L: PartialEq<R>, R>(self, left: L, right: R) -> bool {\n        match self {\n            BinopEq::Eq => left == right,\n            BinopEq::Ne => left != right,\n        }\n    }\n}\n\nuse std::fmt;\n\nimpl fmt::Display for BinopEq {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            BinopEq::Eq => write!(f, \"==\"),\n            BinopEq::Ne => write!(f, \"!=\"),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::*;\n\n    #[test]\n    fn eq_inactive() {\n        let result = run(\n            1,\n            5,\n            4,\n            BinopEq::Eq,\n            &MutagenRuntimeConfig::without_mutation(),\n        );\n        assert_eq!(result, false);\n    }\n    #[test]\n    fn eq_active() {\n        let result = run(\n            1,\n            5,\n            4,\n            BinopEq::Eq,\n            &MutagenRuntimeConfig::with_mutation_id(1),\n        );\n        assert_eq!(result, true);\n    }\n\n    #[test]\n    fn ne_inactive() {\n        let result = run(\n            1,\n            5,\n            4,\n            BinopEq::Ne,\n            &MutagenRuntimeConfig::without_mutation(),\n        );\n        assert_eq!(result, true);\n    }\n    #[test]\n    fn ne_active() {\n        let result = run(\n            1,\n            5,\n            4,\n            BinopEq::Ne,\n            &MutagenRuntimeConfig::with_mutation_id(1),\n        );\n        assert_eq!(result, false);\n    }\n}\n","traces":[{"line":17,"address":[4228480,4228619],"length":1,"stats":{"Line":1},"fn_name":"run<&u32,&u32,std::sync::rwlock::RwLockReadGuard<mutagen_core::runtime_config::MutagenRuntimeConfig>>"},{"line":24,"address":[4228527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[4228683],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[4228712,4228951,4228783,4228885],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[4228901],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[4228957,4228836],"length":1,"stats":{"Line":4},"fn_name":null},{"line":33,"address":[4721968,4722084],"length":1,"stats":{"Line":0},"fn_name":"transform"},{"line":38,"address":[4722000,4722214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[4722099,4722216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[4722114],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[4722532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[4722379,4722312,4722487],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[4692145,4692128],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":49,"address":[4722604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[4722612],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[4722636],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[4722771,4722646],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[4725104],"length":1,"stats":{"Line":1},"fn_name":"possible_mutations"},{"line":72,"address":[4725197,4725120],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[4692222,4692208],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":76,"address":[4692272,4692290],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":80,"address":[4228416],"length":1,"stats":{"Line":0},"fn_name":"mutate<&u32,&u32>"},{"line":81,"address":[4228439],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[4725280,4725404],"length":1,"stats":{"Line":0},"fn_name":"to_mutation"},{"line":86,"address":[4725323],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[4725347],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[4725419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[4725636],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[4725844],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[4726198,4726112],"length":1,"stats":{"Line":0},"fn_name":"try_from"},{"line":106,"address":[4726331,4727539],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[4726122,4726658,4726976,4727371,4726336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[4726663,4726803,4726428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[4726695],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[4726738],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[4726771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[4727198,4727058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[4727090],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[4727133],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[4727166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[4726480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[4726213],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[4727856,4727897],"length":1,"stats":{"Line":0},"fn_name":"op_tokens"},{"line":129,"address":[4727889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[4727912,4728037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[4728889,4729061,4728720,4729082],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[4728722,4728682,4728894],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[4728918,4728698,4729063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[4229104,4229143],"length":1,"stats":{"Line":1},"fn_name":"eq<&u32,&u32>"},{"line":148,"address":[4229176,4229209],"length":1,"stats":{"Line":3},"fn_name":null},{"line":149,"address":[4229188,4229127],"length":1,"stats":{"Line":6},"fn_name":null},{"line":150,"address":[4229165,4229219],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[4729200],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":159,"address":[4729292,4729366,4729390],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[4729223,4729299],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[4729373,4729245],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":12,"coverable":60},{"path":["/","mnt","c","Users","kms2","Desktop","KAIST","7학기","소프트웨어 테스팅 자동화 기법","PJ","mutagen","mutagen-core","src","mutator","mutator_binop_num.rs"],"content":"//! Mutator for numeric binary operations `+`, `-`, `/`, `*`.\n\nuse std::convert::TryFrom;\nuse std::ops::Deref;\nuse std::ops::{Add, Div, Mul, Sub};\n\nuse proc_macro2::Span;\nuse quote::quote_spanned;\nuse syn::spanned::Spanned;\nuse syn::{BinOp, Expr};\n\nuse crate::comm::Mutation;\nuse crate::transformer::transform_info::SharedTransformInfo;\nuse crate::transformer::TransformContext;\n\nuse crate::MutagenRuntimeConfig;\n\npub fn run_add<L: Add<R>, R>(\n    mutator_id: usize,\n    left: L,\n    right: R,\n    runtime: impl Deref<Target = MutagenRuntimeConfig>,\n) -> <L as Add<R>>::Output {\n    runtime.covered(mutator_id);\n    if runtime.is_mutation_active(mutator_id) {\n        left.may_sub(right)\n    } else {\n        left + right\n    }\n}\npub fn run_sub<L: Sub<R>, R>(\n    mutator_id: usize,\n    left: L,\n    right: R,\n    runtime: impl Deref<Target = MutagenRuntimeConfig>,\n) -> <L as Sub<R>>::Output {\n    runtime.covered(mutator_id);\n    if runtime.is_mutation_active(mutator_id) {\n        left.may_add(right)\n    } else {\n        left - right\n    }\n}\npub fn run_mul<L: Mul<R>, R>(\n    mutator_id: usize,\n    left: L,\n    right: R,\n    runtime: impl Deref<Target = MutagenRuntimeConfig>,\n) -> <L as Mul<R>>::Output {\n    runtime.covered(mutator_id);\n    if runtime.is_mutation_active(mutator_id) {\n        left.may_div(right)\n    } else {\n        left * right\n    }\n}\npub fn run_div<L: Div<R>, R>(\n    mutator_id: usize,\n    left: L,\n    right: R,\n    runtime: impl Deref<Target = MutagenRuntimeConfig>,\n) -> <L as Div<R>>::Output {\n    runtime.covered(mutator_id);\n    if runtime.is_mutation_active(mutator_id) {\n        left.may_mul(right)\n    } else {\n        left / right\n    }\n}\n\npub fn transform(\n    e: Expr,\n    transform_info: &SharedTransformInfo,\n    context: &TransformContext,\n) -> Expr {\n    let e = match ExprBinopNum::try_from(e) {\n        Ok(e) => e,\n        Err(e) => return e,\n    };\n\n    let mutator_id = transform_info.add_mutations(\n        MutationBinopNum::possible_mutations(e.op)\n            .iter()\n            .map(|m| m.to_mutation(&e, context)),\n    );\n\n    let left = &e.left;\n    let right = &e.right;\n    let run_fn = match e.op {\n        BinopNum::Add => quote_spanned! {e.span()=> run_add},\n        BinopNum::Sub => quote_spanned! {e.span()=> run_sub},\n        BinopNum::Mul => quote_spanned! {e.span()=> run_mul},\n        BinopNum::Div => quote_spanned! {e.span()=> run_div},\n    };\n    let op_token = e.op_token;\n    let tmp_var = transform_info.get_next_tmp_var(op_token.span());\n    syn::parse2(quote_spanned! {e.span()=>\n        {\n            let #tmp_var = #left;\n            if false {#tmp_var #op_token #right} else {\n                ::mutagen::mutator::mutator_binop_num::#run_fn(\n                    #mutator_id,\n                    #tmp_var,\n                    #right,\n                    ::mutagen::MutagenRuntimeConfig::get_default()\n                )\n            }\n        }\n    })\n    .expect(\"transformed code invalid\")\n}\n\n#[derive(Copy, Clone, Debug, PartialEq, Eq)]\nstruct MutationBinopNum {\n    op: BinopNum,\n}\n\nimpl MutationBinopNum {\n    fn possible_mutations(original_op: BinopNum) -> Vec<Self> {\n        match original_op {\n            BinopNum::Add => vec![MutationBinopNum { op: BinopNum::Sub }],\n            BinopNum::Sub => vec![MutationBinopNum { op: BinopNum::Add }],\n            BinopNum::Mul => vec![MutationBinopNum { op: BinopNum::Div }],\n            BinopNum::Div => vec![MutationBinopNum { op: BinopNum::Mul }],\n        }\n    }\n\n    fn to_mutation(self, original_expr: &ExprBinopNum, context: &TransformContext) -> Mutation {\n        Mutation::new_spanned(\n            &context,\n            \"binop_num\".to_owned(),\n            format!(\"{}\", original_expr.op),\n            format!(\"{}\", self.op),\n            original_expr.span(),\n        )\n    }\n}\n\n#[derive(Clone, Debug)]\nstruct ExprBinopNum {\n    op: BinopNum,\n    left: Expr,\n    right: Expr,\n    op_token: syn::BinOp,\n}\n\nimpl TryFrom<Expr> for ExprBinopNum {\n    type Error = Expr;\n    fn try_from(expr: Expr) -> Result<Self, Expr> {\n        match expr {\n            Expr::Binary(expr) => match expr.op {\n                BinOp::Add(_) => Ok(ExprBinopNum {\n                    op: BinopNum::Add,\n                    left: *expr.left,\n                    right: *expr.right,\n                    op_token: expr.op,\n                }),\n                BinOp::Sub(_) => Ok(ExprBinopNum {\n                    op: BinopNum::Sub,\n                    left: *expr.left,\n                    right: *expr.right,\n                    op_token: expr.op,\n                }),\n                BinOp::Mul(_) => Ok(ExprBinopNum {\n                    op: BinopNum::Mul,\n                    left: *expr.left,\n                    right: *expr.right,\n                    op_token: expr.op,\n                }),\n                BinOp::Div(_) => Ok(ExprBinopNum {\n                    op: BinopNum::Div,\n                    left: *expr.left,\n                    right: *expr.right,\n                    op_token: expr.op,\n                }),\n                _ => Err(Expr::Binary(expr)),\n            },\n            _ => Err(expr),\n        }\n    }\n}\n\nimpl syn::spanned::Spanned for ExprBinopNum {\n    fn span(&self) -> Span {\n        self.op_token.span()\n    }\n}\n\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\nenum BinopNum {\n    Add,\n    Sub,\n    Mul,\n    Div,\n}\n\nuse std::fmt;\n\nimpl fmt::Display for BinopNum {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            BinopNum::Add => write!(f, \"+\"),\n            BinopNum::Sub => write!(f, \"-\"),\n            BinopNum::Mul => write!(f, \"*\"),\n            BinopNum::Div => write!(f, \"/\"),\n        }\n    }\n}\n\n// specification of the traits `AddToSub`, `SubToAdd`, ...\n//\n// These traits consist of a function `max_x` that panics if the operation `x`\n// cannot be performed due to type constraints\nmacro_rules! binary_x_to_y {\n    { $($may_ty:ident, $may_fn:ident, $t1:ident, $t2:ident, $t2_op:tt,)* } => {\n        $(\n            trait $may_ty<R> {\n                type Output;\n                fn $may_fn(self, r: R) -> Self::Output;\n            }\n\n            impl <L, R> $may_ty<R> for L where L: $t1<R> {\n                type Output = <L as $t1<R>>::Output;\n                default fn $may_fn(self, _r: R) -> <L as $t1<R>>::Output {\n                    MutagenRuntimeConfig::get_default().optimistic_assumption_failed();\n                }\n            }\n\n            impl<L, R> $may_ty<R> for L\n            where\n                L: $t1<R>,\n                L: $t2<R>,\n                <L as $t2<R>>::Output: Into<<L as $t1<R>>::Output>,\n            {\n                fn $may_fn(self, r: R) -> Self::Output {\n                    (self $t2_op r).into()\n                }\n            }\n        )*\n\n    }\n}\n\nbinary_x_to_y!(\n    AddToSub, may_sub, Add, Sub, -,\n    SubToAdd, may_add, Sub, Add, +,\n    MulToDiv, may_div, Mul, Div, /,\n    DivToMul, may_mul, Div, Mul, *,\n);\n\n#[cfg(test)]\nmod tests {\n\n    use super::*;\n\n    #[test]\n    fn sum_inactive() {\n        let result = run_add(1, 5, 4, &MutagenRuntimeConfig::without_mutation());\n        assert_eq!(result, 9);\n    }\n    #[test]\n    fn sum_active() {\n        let result = run_add(1, 5, 4, &MutagenRuntimeConfig::with_mutation_id(1));\n        assert_eq!(result, 1);\n    }\n\n    #[test]\n    fn str_add_inactive() {\n        let result = run_add(\n            1,\n            \"x\".to_string(),\n            \"y\",\n            &MutagenRuntimeConfig::without_mutation(),\n        );\n        assert_eq!(&result, \"xy\");\n    }\n    #[test]\n    #[should_panic]\n    fn str_add_active() {\n        run_add(\n            1,\n            \"x\".to_string(),\n            \"y\",\n            &MutagenRuntimeConfig::with_mutation_id(1),\n        );\n    }\n}\n","traces":[{"line":18,"address":[4243392,4243488,4243024,4243122,4242480,4242601],"length":1,"stats":{"Line":3},"fn_name":"run_add<example_simple::lazy_add::LazyAdd,example_simple::lazy_add::LazyAdd,std::sync::rwlock::RwLockReadGuard<mutagen_core::runtime_config::MutagenRuntimeConfig>>"},{"line":24,"address":[4243047,4243414,4242503],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[4242666,4243657,4242898,4243544,4243303,4243178],"length":1,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[4243620,4242813,4243260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[4243225,4243663,4243591,4243309,4242713],"length":1,"stats":{"Line":5},"fn_name":null},{"line":31,"address":[4244464,4244560,4244816,4244919],"length":1,"stats":{"Line":3},"fn_name":"run_sub<u32,u32,std::sync::rwlock::RwLockReadGuard<mutagen_core::runtime_config::MutagenRuntimeConfig>>"},{"line":37,"address":[4244843,4244486],"length":1,"stats":{"Line":5},"fn_name":null},{"line":38,"address":[4244729,4245096,4244616,4244975],"length":1,"stats":{"Line":5},"fn_name":null},{"line":39,"address":[4244692,4245054],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[4245022,4245103,4244735,4244663],"length":1,"stats":{"Line":10},"fn_name":null},{"line":44,"address":[4244194,4243840,4244096,4243744],"length":1,"stats":{"Line":5},"fn_name":"run_mul<u32,u32,std::sync::rwlock::RwLockReadGuard<mutagen_core::runtime_config::MutagenRuntimeConfig>>"},{"line":50,"address":[4243766,4244119],"length":1,"stats":{"Line":5},"fn_name":null},{"line":51,"address":[4243896,4244009,4244250,4244375],"length":1,"stats":{"Line":5},"fn_name":null},{"line":52,"address":[4244332,4243972],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[4244297,4243943,4244015,4244381],"length":1,"stats":{"Line":10},"fn_name":null},{"line":71,"address":[4680324,4680208],"length":1,"stats":{"Line":0},"fn_name":"transform"},{"line":76,"address":[4680454,4680240],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[4680456,4680339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[4680354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[4680809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[4680567,4680632,4680758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[4680734],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[4680881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[4680889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[4681518,4681332,4681146,4680963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[4680905,4680965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[4681151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[4681337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[4681523,4680941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[4681685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[4681733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[4681876,4681814],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[4684928],"length":1,"stats":{"Line":0},"fn_name":"possible_mutations"},{"line":120,"address":[4685115,4685029,4685072,4685158],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[4684940,4685031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[4685074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[4685117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[4684983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[4685184,4685302],"length":1,"stats":{"Line":0},"fn_name":"to_mutation"},{"line":130,"address":[4685219],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[4685248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[4685317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[4685534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[4685745],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[4686048,4686140],"length":1,"stats":{"Line":0},"fn_name":"try_from"},{"line":150,"address":[4686273,4687982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[4686278,4687606,4686970,4686064,4686616,4687300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[4686781,4686370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[4686621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[4686675],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[4686721],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[4687129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[4686975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[4687029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[4687075],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[4687447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[4687305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[4687353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[4687393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[4687753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[4687611],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[4687659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[4687699],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[4686420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[4686155],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[4688272],"length":1,"stats":{"Line":0},"fn_name":"span"},{"line":185,"address":[4688284],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[4688320],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":201,"address":[4688666,4688588,4688511,4688437,4688693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[4688444,4688343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[4688521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[4688595],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[4688673,4688384],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[4216483,4216448],"length":1,"stats":{"Line":0},"fn_name":"may_sub<example_simple::lazy_add::LazyAdd,example_simple::lazy_add::LazyAdd>"},{"line":225,"address":[4216546,4216500,4216452],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[4245488,4245200,4245248,4245360,4245424,4245312],"length":1,"stats":{"Line":0},"fn_name":"may_sub<i32,i32>"},{"line":236,"address":[4245259,4245324,4245371,4245500,4245212,4245438],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":12,"coverable":81},{"path":["/","mnt","c","Users","kms2","Desktop","KAIST","7학기","소프트웨어 테스팅 자동화 기법","PJ","mutagen","mutagen-core","src","mutator","mutator_lit_bool.rs"],"content":"//! Mutator for boolean literals.\n\nuse std::convert::TryFrom;\nuse std::ops::Deref;\n\nuse proc_macro2::Span;\nuse quote::quote_spanned;\nuse syn::{Expr, ExprLit, Lit, LitBool};\n\nuse crate::comm::Mutation;\nuse crate::transformer::transform_info::SharedTransformInfo;\nuse crate::transformer::TransformContext;\n\nuse crate::MutagenRuntimeConfig;\n\npub fn run(\n    mutator_id: usize,\n    original_lit: bool,\n    runtime: impl Deref<Target = MutagenRuntimeConfig>,\n) -> bool {\n    runtime.covered(mutator_id);\n    if runtime.is_mutation_active(mutator_id) {\n        !original_lit\n    } else {\n        original_lit\n    }\n}\n\npub fn transform(\n    e: Expr,\n    transform_info: &SharedTransformInfo,\n    context: &TransformContext,\n) -> Expr {\n    let e = match ExprLitBool::try_from(e) {\n        Ok(e) => e,\n        Err(e) => return e,\n    };\n\n    let mutator_id = transform_info.add_mutation(Mutation::new_spanned(\n        &context,\n        \"lit_bool\".to_owned(),\n        format!(\"{:?}\", e.value),\n        format!(\"{:?}\", !e.value),\n        e.span,\n    ));\n\n    let value = e.value;\n    syn::parse2(quote_spanned! {e.span=>\n        ::mutagen::mutator::mutator_lit_bool::run(\n                #mutator_id,\n                #value,\n                ::mutagen::MutagenRuntimeConfig::get_default()\n            )\n    })\n    .expect(\"transformed code invalid\")\n}\n\n#[derive(Clone, Debug)]\nstruct ExprLitBool {\n    value: bool,\n    span: Span,\n}\n\nimpl TryFrom<Expr> for ExprLitBool {\n    type Error = Expr;\n    fn try_from(expr: Expr) -> Result<Self, Expr> {\n        match expr {\n            Expr::Lit(ExprLit {\n                lit: Lit::Bool(LitBool { value, span }),\n                ..\n            }) => Ok(ExprLitBool { value, span }),\n            _ => Err(expr),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::*;\n    use crate::MutagenRuntimeConfig;\n\n    #[test]\n    pub fn false_inactive() {\n        let result = run(1, false, &MutagenRuntimeConfig::without_mutation());\n        assert_eq!(result, false)\n    }\n    #[test]\n    pub fn true_inactive() {\n        let result = run(1, true, &MutagenRuntimeConfig::without_mutation());\n        assert_eq!(result, true)\n    }\n    #[test]\n    pub fn false_active() {\n        let result = run(1, false, &MutagenRuntimeConfig::with_mutation_id(1));\n        assert_eq!(result, true)\n    }\n    #[test]\n    pub fn true_active() {\n        let result = run(1, true, &MutagenRuntimeConfig::with_mutation_id(1));\n        assert_eq!(result, false)\n    }\n}\n","traces":[{"line":16,"address":[4215840,4215914],"length":1,"stats":{"Line":1},"fn_name":"run<std::sync::rwlock::RwLockReadGuard<mutagen_core::runtime_config::MutagenRuntimeConfig>>"},{"line":21,"address":[4215873],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[4215944,4216001],"length":1,"stats":{"Line":4},"fn_name":null},{"line":23,"address":[4216007],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[4215995],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[4972832,4972958],"length":1,"stats":{"Line":0},"fn_name":"transform"},{"line":34,"address":[4973086,4972858],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[4972973,4973095],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[4972989],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[4973717,4973816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[4973159],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[4973167,4973214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[4973222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[4973454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[4973687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[4973838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[4973854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[4975616],"length":1,"stats":{"Line":0},"fn_name":"try_from"},{"line":67,"address":[4975884,4975754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[4975626],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[4975764],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[4975811],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[4975663],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":4,"coverable":24},{"path":["/","mnt","c","Users","kms2","Desktop","KAIST","7학기","소프트웨어 테스팅 자동화 기법","PJ","mutagen","mutagen-core","src","mutator","mutator_lit_int.rs"],"content":"//! Mutator for int literals.\n\nuse std::convert::TryFrom;\nuse std::ops::Deref;\n\nuse proc_macro2::Span;\nuse quote::quote_spanned;\nuse syn::{Expr, ExprLit, Lit, LitInt};\n\nuse crate::comm::Mutation;\nuse crate::transformer::transform_info::SharedTransformInfo;\nuse crate::transformer::TransformContext;\n\nuse crate::MutagenRuntimeConfig;\n\npub fn run<T: IntMutable>(\n    mutator_id: usize,\n    original_lit: T,\n    runtime: impl Deref<Target = MutagenRuntimeConfig>,\n) -> T {\n    runtime.covered(mutator_id);\n    let mutations = MutationLitInt::possible_mutations(original_lit.as_u128());\n    if let Some(m) = runtime.get_mutation_for_mutator(mutator_id, &mutations) {\n        m.mutate(original_lit)\n    } else {\n        original_lit\n    }\n}\n\npub fn transform(\n    e: Expr,\n    transform_info: &SharedTransformInfo,\n    context: &TransformContext,\n) -> Expr {\n    let e = match ExprLitInt::try_from(e) {\n        Ok(e) => e,\n        Err(e) => return e,\n    };\n\n    let mutator_id = transform_info.add_mutations(\n        MutationLitInt::possible_mutations(e.value)\n            .into_iter()\n            .map(|m| m.to_mutation(&e, context)),\n    );\n\n    let original_lit = e.lit;\n    syn::parse2(quote_spanned! {e.span=>\n        ::mutagen::mutator::mutator_lit_int::run(\n                #mutator_id,\n                #original_lit,\n                ::mutagen::MutagenRuntimeConfig::get_default()\n            )\n    })\n    .expect(\"transformed code invalid\")\n}\n\n#[derive(Copy, Clone, Debug, PartialEq, Eq)]\nenum MutationLitInt {\n    Relative(i128),\n}\n\nimpl MutationLitInt {\n    fn possible_mutations(val: u128) -> Vec<Self> {\n        let mut mutations = vec![];\n        if val != u128::max_value() {\n            mutations.push(MutationLitInt::Relative(1));\n        }\n        if val != 0 {\n            mutations.push(MutationLitInt::Relative(-1));\n        }\n        mutations\n    }\n\n    fn mutate<T: IntMutable>(self, val: T) -> T {\n        match self {\n            Self::Relative(r) => IntMutable::from_u128(val.as_u128().wrapping_add(r as u128)),\n        }\n    }\n\n    fn to_mutation(self, original_lit: &ExprLitInt, context: &TransformContext) -> Mutation {\n        Mutation::new_spanned(\n            &context,\n            \"lit_int\".to_owned(),\n            format!(\"{}\", original_lit.value),\n            format!(\"{}\", self.mutate::<u128>(original_lit.value)),\n            original_lit.span,\n        )\n    }\n}\n\n// trait for operations that mutate integers of any type\npub trait IntMutable: Copy {\n    fn from_u128(val: u128) -> Self;\n    fn as_u128(self) -> u128;\n}\n\n// implementation for `IntMutable` for all integer types\nmacro_rules! lit_int_mutables {\n    { $($suf:ident, $ty:ident,)* } => {\n        $(\n            impl IntMutable for $ty {\n                fn from_u128(val: u128) -> Self {\n                    val as $ty\n                }\n                fn as_u128(self) -> u128 {\n                    self as u128\n                }\n            }\n        )*\n\n    }\n}\n\nlit_int_mutables! {\n    I8, i8,\n    I16, i16,\n    I32, i32,\n    I64, i64,\n    I128, i128,\n    Isize, isize,\n    U8, u8,\n    U16, u16,\n    U32, u32,\n    U64, u64,\n    U128, u128,\n    Usize, usize,\n}\n\n#[derive(Clone, Debug)]\npub struct ExprLitInt {\n    pub value: u128,\n    pub lit: LitInt,\n    pub span: Span,\n}\n\nimpl TryFrom<Expr> for ExprLitInt {\n    type Error = Expr;\n    fn try_from(expr: Expr) -> Result<Self, Expr> {\n        match expr {\n            Expr::Lit(expr) => match expr.lit {\n                Lit::Int(lit) => match lit.base10_parse::<u128>() {\n                    Ok(value) => Ok(ExprLitInt {\n                        value,\n                        span: lit.span(),\n                        lit,\n                    }),\n                    Err(_) => Err(Expr::Lit(ExprLit {\n                        lit: Lit::Int(lit),\n                        attrs: expr.attrs,\n                    })),\n                },\n                _ => Err(Expr::Lit(expr)),\n            },\n            _ => Err(expr),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::*;\n    use crate::MutagenRuntimeConfig;\n\n    #[test]\n    pub fn mutator_lit_int_zero_inactive() {\n        let result = run(1, 0, &MutagenRuntimeConfig::without_mutation());\n        assert_eq!(result, 0)\n    }\n\n    #[test]\n    pub fn mutator_lit_int_zero_active() {\n        let result = run(1, 0, &MutagenRuntimeConfig::with_mutation_id(1));\n        assert_eq!(result, 1)\n    }\n\n    #[test]\n    fn lit_u8_suffixed_active() {\n        let result: u8 = run(1, 1u8, &MutagenRuntimeConfig::with_mutation_id(1));\n        assert_eq!(result, 2);\n    }\n\n    #[test]\n    fn possible_mutations_with_zero() {\n        assert_eq!(\n            MutationLitInt::possible_mutations(0),\n            vec![MutationLitInt::Relative(1)]\n        );\n    }\n\n    #[test]\n    fn possible_mutations_with_one() {\n        assert_eq!(\n            MutationLitInt::possible_mutations(1),\n            vec![MutationLitInt::Relative(1), MutationLitInt::Relative(-1)]\n        );\n    }\n\n    #[test]\n    fn possible_mutations_with_max_value() {\n        assert_eq!(\n            MutationLitInt::possible_mutations(u128::max_value()),\n            vec![MutationLitInt::Relative(-1)]\n        );\n    }\n\n    #[test]\n    fn mutate_relative1() {\n        assert_eq!(MutationLitInt::Relative(1).mutate(2), 3)\n    }\n\n    #[test]\n    fn mutate_relative_neg1() {\n        assert_eq!(MutationLitInt::Relative(-1).mutate(2), 1)\n    }\n}\n","traces":[{"line":16,"address":[4218557,4217232,4217648,4217311,4218064,4218480,4217727,4218141],"length":1,"stats":{"Line":5},"fn_name":"run<u8,std::sync::rwlock::RwLockReadGuard<mutagen_core::runtime_config::MutagenRuntimeConfig>>"},{"line":21,"address":[4217686,4218517,4217270,4218101],"length":1,"stats":{"Line":5},"fn_name":null},{"line":22,"address":[4217343,4217755,4218169,4218585],"length":1,"stats":{"Line":5},"fn_name":null},{"line":23,"address":[4217520,4217936,4217812,4218225,4217879,4218292,4218347,4217398,4218641,4218708,4218763,4217465],"length":1,"stats":{"Line":21},"fn_name":null},{"line":24,"address":[4217535,4218362,4217951,4218778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[4217516,4217931,4218343,4218759],"length":1,"stats":{"Line":7},"fn_name":null},{"line":30,"address":[5662628,5662528],"length":1,"stats":{"Line":0},"fn_name":"transform"},{"line":35,"address":[5662551,5662751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[5662643,5662753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[5662658],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[5663023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[5662924,5662980,5662857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[4673376,4673398],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":46,"address":[5663065],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[5663214,5663089],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[5664864,5664909],"length":1,"stats":{"Line":2},"fn_name":"possible_mutations"},{"line":64,"address":[5664901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[5664984,5664933,5664957],"length":1,"stats":{"Line":7},"fn_name":null},{"line":66,"address":[5664959],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[5664996,5665034],"length":1,"stats":{"Line":7},"fn_name":null},{"line":69,"address":[5665005],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[4216656,4217088,4216800,4216944],"length":1,"stats":{"Line":0},"fn_name":"mutate<u32>"},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[4216674,4216962,4216818,4217107],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[5665232,5665072],"length":1,"stats":{"Line":0},"fn_name":"to_mutation"},{"line":82,"address":[5665122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[5665146],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[5665247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[5665471],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[5665787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[5668064,5668624,5668192,5668128,5667936,5668256,5668000,5668448,5668320,5668512,5668560,5668384],"length":1,"stats":{"Line":0},"fn_name":"from_u128"},{"line":105,"address":[5668224,5668592,5667968,5668096,5668352,5668160,5668544,5668288,5668656,5668480,5668032,5668416],"length":1,"stats":{"Line":6},"fn_name":"as_u128"},{"line":106,"address":[5668040,5668487,5667976,5668169,5668103,5668297,5668424,5668360],"length":1,"stats":{"Line":3},"fn_name":null},{"line":138,"address":[5666064,5666137],"length":1,"stats":{"Line":0},"fn_name":"try_from"},{"line":139,"address":[5667382,5666249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[5666484,5666254,5666074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[5666489,5667085,5666302,5666877],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[5666974,5666884,5666540],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[5666916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[5666953],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[5666682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[5666600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[5666635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[5666323],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[5666152],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":13,"coverable":47},{"path":["/","mnt","c","Users","kms2","Desktop","KAIST","7학기","소프트웨어 테스팅 자동화 기법","PJ","mutagen","mutagen-core","src","mutator","mutator_stmt_call.rs"],"content":"//! Mutator for removing statements that only consist of a method or function call.\n\nuse std::convert::TryFrom;\nuse std::ops::Deref;\n\nuse proc_macro2::{Span, TokenStream};\nuse quote::quote_spanned;\nuse quote::ToTokens;\nuse syn::spanned::Spanned;\nuse syn::{Expr, Stmt};\n\nuse crate::comm::Mutation;\nuse crate::transformer::transform_info::SharedTransformInfo;\nuse crate::transformer::TransformContext;\n\nuse crate::MutagenRuntimeConfig;\n\npub fn should_run(mutator_id: usize, runtime: impl Deref<Target = MutagenRuntimeConfig>) -> bool {\n    runtime.covered(mutator_id);\n    // should run if mutation is inactive\n    !runtime.is_mutation_active(mutator_id)\n}\n\npub fn transform(\n    s: Stmt,\n    transform_info: &SharedTransformInfo,\n    context: &TransformContext,\n) -> Stmt {\n    let s = match StmtCall::try_from(s) {\n        Ok(s) => s,\n        Err(s) => return s,\n    };\n\n    let mutator_id = transform_info.add_mutation(Mutation::new_spanned(\n        &context,\n        \"stmt_call\".to_owned(),\n        format!(\n            \"{}\",\n            context\n                .original_stmt\n                .to_token_stream()\n                .to_string()\n                .replace(\"\\n\", \" \")\n        ),\n        \"\".to_owned(),\n        s.span,\n    ));\n\n    let call = &s.call;\n\n    syn::parse2(quote_spanned! {s.span=>\n        if ::mutagen::mutator::mutator_stmt_call::should_run(\n                #mutator_id,\n                ::mutagen::MutagenRuntimeConfig::get_default()\n            )\n        {\n            #call;\n        } else {\n            ::mutagen::mutator::mutator_stmt_call::stmt_call_to_none()\n        }\n    })\n    .expect(\"transformed code invalid\")\n}\n\n#[derive(Debug, Clone)]\nstruct StmtCall {\n    call: TokenStream,\n    span: Span,\n}\n\nimpl TryFrom<Stmt> for StmtCall {\n    type Error = Stmt;\n    fn try_from(stmt: Stmt) -> Result<Self, Stmt> {\n        match stmt {\n            Stmt::Semi(Expr::MethodCall(call), _) => Ok(StmtCall {\n                span: call.span(),\n                call: call.into_token_stream(),\n            }),\n            Stmt::Semi(Expr::Call(call), _) => Ok(StmtCall {\n                span: call.span(),\n                call: call.into_token_stream(),\n            }),\n            _ => return Err(stmt),\n        }\n    }\n}\n\n/// a trait for optimistically removing a statement containing a method- or function call.\n///\n/// This operation is optimistic, since the statement could have the type `!` and can be used in surprising contexts:\n///\n/// * `let x = {f(return y);}`\n/// * `let x = {std::process::abort();}`\n///\n/// Above examples compile and it is not possible to remove the statements without introducing compiler errors.\npub trait StmtCallToNone {\n    fn stmt_call_to_none() -> Self;\n}\n\nimpl<T> StmtCallToNone for T {\n    default fn stmt_call_to_none() -> Self {\n        MutagenRuntimeConfig::get_default().optimistic_assumption_failed();\n    }\n}\n\nimpl StmtCallToNone for () {\n    fn stmt_call_to_none() -> () {}\n}\n\npub fn stmt_call_to_none<T: StmtCallToNone>() -> T {\n    <T as StmtCallToNone>::stmt_call_to_none()\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::*;\n\n    #[test]\n    fn stmt_inactive() {\n        let result = should_run(1, &MutagenRuntimeConfig::without_mutation());\n        assert_eq!(result, true);\n    }\n    #[test]\n    fn stmt_active() {\n        let result = should_run(1, &MutagenRuntimeConfig::with_mutation_id(1));\n        assert_eq!(result, false);\n    }\n}\n","traces":[{"line":18,"address":[4212864,4212924],"length":1,"stats":{"Line":2},"fn_name":"should_run<std::sync::rwlock::RwLockReadGuard<mutagen_core::runtime_config::MutagenRuntimeConfig>>"},{"line":19,"address":[4212888],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[4212954],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[4538831,4538704],"length":1,"stats":{"Line":0},"fn_name":"transform"},{"line":29,"address":[4538961,4538731],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[4538963,4538846],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[4538861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[4539920,4539791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[4539091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[4539173,4539099],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[4539288,4539372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[4539181],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[4539188,4539307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[4539735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[4539761],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[4539973],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[4539981],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[4543152,4543205],"length":1,"stats":{"Line":0},"fn_name":"try_from"},{"line":74,"address":[4544016,4543672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[4543162,4543548,4543319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[4543420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[4543449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[4543892,4543677],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[4543750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[4543777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[4543220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[4544369,4544368],"length":1,"stats":{"Line":0},"fn_name":"stmt_call_to_none"},{"line":110,"address":[4213040],"length":1,"stats":{"Line":0},"fn_name":"stmt_call_to_none<()>"},{"line":111,"address":[4213041],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":3,"coverable":31},{"path":["/","mnt","c","Users","kms2","Desktop","KAIST","7학기","소프트웨어 테스팅 자동화 기법","PJ","mutagen","mutagen-core","src","mutator","mutator_unop_not.rs"],"content":"//! Mutator for binary operation `+`.\n\nuse std::convert::TryFrom;\nuse std::ops::Deref;\nuse std::ops::Not;\n\nuse proc_macro2::Span;\nuse quote::quote_spanned;\nuse syn::spanned::Spanned;\nuse syn::{Expr, UnOp};\n\nuse crate::comm::Mutation;\nuse crate::transformer::transform_info::SharedTransformInfo;\nuse crate::transformer::TransformContext;\n\nuse crate::MutagenRuntimeConfig;\n\npub fn run<T: Not>(\n    mutator_id: usize,\n    val: T,\n    runtime: impl Deref<Target = MutagenRuntimeConfig>,\n) -> <T as Not>::Output {\n    runtime.covered(mutator_id);\n    if runtime.is_mutation_active(mutator_id) {\n        val.may_none()\n    } else {\n        !val\n    }\n}\n\npub fn transform(\n    e: Expr,\n    transform_info: &SharedTransformInfo,\n    context: &TransformContext,\n) -> Expr {\n    let e = match ExprUnopNot::try_from(e) {\n        Ok(e) => e,\n        Err(e) => return e,\n    };\n\n    let mutator_id = transform_info.add_mutation(Mutation::new_spanned(\n        &context,\n        \"unop_not\".to_owned(),\n        \"!\".to_owned(),\n        \"\".to_owned(),\n        e.span(),\n    ));\n\n    let expr = &e.expr;\n    let op_token = e.op_token;\n    let tmp_var = transform_info.get_next_tmp_var(op_token.span());\n    syn::parse2(quote_spanned! {e.span()=>\n        {\n            let #tmp_var = #expr;\n            if false {!#tmp_var} else {\n                ::mutagen::mutator::mutator_unop_not::run(\n                    #mutator_id,\n                    #tmp_var,\n                    ::mutagen::MutagenRuntimeConfig::get_default()\n                )\n            }\n        }\n    })\n    .expect(\"transformed code invalid\")\n}\n\n#[derive(Clone, Debug)]\nstruct ExprUnopNot {\n    expr: Expr,\n    op_token: syn::UnOp,\n}\n\nimpl TryFrom<Expr> for ExprUnopNot {\n    type Error = Expr;\n    fn try_from(expr: Expr) -> Result<Self, Expr> {\n        match expr {\n            Expr::Unary(expr) => match expr.op {\n                UnOp::Not(_) => Ok(ExprUnopNot {\n                    expr: *expr.expr,\n                    op_token: expr.op,\n                }),\n                _ => Err(Expr::Unary(expr)),\n            },\n            e => Err(e),\n        }\n    }\n}\n\nimpl syn::spanned::Spanned for ExprUnopNot {\n    fn span(&self) -> Span {\n        self.op_token.span()\n    }\n}\n\n/// trait that is used to optimistically remove a negation `!` from an expression\n///\n/// This trait provides a function `may_none` that passes the input value unchanged\n/// If the value cannot be converted to the output type of the negation using `Into`, the optimistic assumption fails.\npub trait NotToNone {\n    type Output;\n    // do nothing\n    fn may_none(self) -> Self::Output;\n}\n\nimpl<T> NotToNone for T\nwhere\n    T: Not,\n{\n    type Output = <T as Not>::Output;\n\n    default fn may_none(self) -> <T as Not>::Output {\n        MutagenRuntimeConfig::get_default().optimistic_assumption_failed();\n    }\n}\n\nimpl<T> NotToNone for T\nwhere\n    T: Not,\n    T: Into<<T as Not>::Output>,\n{\n    fn may_none(self) -> Self::Output {\n        self.into()\n    }\n}\n\n/// types for testing the optimistic mutator that removes the negation\n#[cfg(any(test, feature = \"self_test\"))]\npub mod optimistic_types {\n\n    use std::ops::Not;\n\n    #[derive(Debug, PartialEq)]\n    pub struct TypeWithNotOtherOutput();\n    #[derive(Debug, PartialEq)]\n    pub struct TypeWithNotTarget();\n\n    impl Not for TypeWithNotOtherOutput {\n        type Output = TypeWithNotTarget;\n\n        fn not(self) -> <Self as Not>::Output {\n            TypeWithNotTarget()\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::optimistic_types::*;\n    use super::*;\n\n    #[test]\n    fn boolnot_inactive() {\n        // input is true, but will be negated by non-active mutator\n        let result = run(1, true, &MutagenRuntimeConfig::without_mutation());\n        assert_eq!(result, false);\n    }\n    #[test]\n    fn boolnot_active() {\n        let result = run(1, true, &MutagenRuntimeConfig::with_mutation_id(1));\n        assert_eq!(result, true);\n    }\n\n    #[test]\n    fn optimistic_incorrect_inactive() {\n        let result = run(\n            1,\n            TypeWithNotOtherOutput(),\n            &MutagenRuntimeConfig::without_mutation(),\n        );\n        assert_eq!(result, TypeWithNotTarget());\n    }\n    #[test]\n    #[should_panic]\n    fn optimistic_incorrect_active() {\n        run(\n            1,\n            TypeWithNotOtherOutput(),\n            &MutagenRuntimeConfig::with_mutation_id(1),\n        );\n    }\n}\n","traces":[{"line":31,"address":[4716742,4716608],"length":1,"stats":{"Line":0},"fn_name":"transform"},{"line":36,"address":[4716634,4716872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[4716757,4716874],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[4716772],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[4717169,4717273],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[4716982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[4716990,4717065],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[4717073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[4717108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[4717142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[4717326],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[4717334],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[4717350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[4717477,4717412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[4720528,4720597],"length":1,"stats":{"Line":0},"fn_name":"try_from"},{"line":76,"address":[4721235,4720746],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[4720751,4720981,4720538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[4720799,4721066],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[4720986],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[4721034],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[4720820],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[4720612],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[4721440],"length":1,"stats":{"Line":0},"fn_name":"span"},{"line":91,"address":[4721452],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":30},{"path":["/","mnt","c","Users","kms2","Desktop","KAIST","7학기","소프트웨어 테스팅 자동화 기법","PJ","mutagen","mutagen-core","src","runtime_config.rs"],"content":"//! Tells mutators what to do at runtime\n//!\n//! Currently, 3 modes are supported\n//!\n//! * do nothing\n//! * activate a single mutation\n//! * report the coverage of mutators\n//!\n//! The main method to configure the global runtime configuration is via environment variables.\n//! The variable `MUTATION_ID` activates a single mutation\n//! The variable `MUTAGEN_MODE` is used to specify other configurations.\n//!\n//! * `MUTAGEN_MODE=mutation`: activate a single mutation (default)\n//! * `MUTAGEN_MODE=coverage`: perform coverage analysis\n//!\n//! In the mode `coverage`, it is required to add the environment variable `MUTAGEN_NUM_MUTATIONS=N` where `N` are the total number of mutations\n\nuse lazy_static::lazy_static;\nuse std::fs::File;\nuse std::io::{BufWriter, Write};\nuse std::ops::Deref;\nuse std::sync::atomic::{AtomicU64, Ordering};\nuse std::sync::RwLock;\n\nuse crate::comm;\n\nlazy_static! {\n    static ref RUNTIME_CONFIG: RwLock<MutagenRuntimeConfig> =\n        {\n            // sets the global config such that\n            // * config constructed via `from_env` when outside tests\n            // * during tests, `from_env` is not called\n            #[cfg(not(any(test, feature = \"self_test\")))]\n            let config = MutagenRuntimeConfig::from_env();\n            #[cfg(any(test, feature = \"self_test\"))]\n            let config = MutagenRuntimeConfig::without_mutation();\n            RwLock::new(config)\n        };\n}\n\npub enum MutagenRuntimeConfig {\n    Pass,\n    Mutation(usize),\n    Coverage(CoverageRecorder),\n}\n\n/// Counts how many times each mutator has been covered and reports when a mutator is covered the first time.\npub struct CoverageRecorder {\n    coverage: CoverageHitCollector,\n    coverage_file: File,\n}\n\nimpl MutagenRuntimeConfig {\n    /// Success the currently active runtime-config based on the environment variable `MUTATION_ID`.\n    ///\n    /// During tests, the global runtime_config can be set to any value to allow\n    /// exhaustive testing.\n    pub fn get_default() -> impl Deref<Target = Self> {\n        RUNTIME_CONFIG.read().unwrap()\n    }\n\n    /// Creates a runtime config from environment variables.\n    ///\n    /// See the module documentation for configuration options\n    #[cfg_attr(any(test, feature = \"self_test\"), allow(dead_code))]\n    // private fn `from_env` is not used when during test (cfg-switch in RUNTIME_CONFIG)\n    fn from_env() -> Self {\n        let mode = std::env::var(\"MUTAGEN_MODE\").ok().unwrap_or(\"\".to_owned());\n        match &*mode {\n            \"coverage\" => {\n                let num_mutations = std::env::var(\"MUTAGEN_NUM_MUTATIONS\")\n                    .ok()\n                    .and_then(|s| s.parse().ok())\n                    .expect(\"environment variable `MUTAGEN_NUM_MUTATIONS` missing\");\n                Self::Coverage(CoverageRecorder::new(num_mutations))\n            }\n            \"\" | \"mutation\" => {\n                let mutation_id = std::env::var(\"MUTATION_ID\")\n                    .ok()\n                    .and_then(|s| s.parse().ok())\n                    .unwrap_or(0);\n                if mutation_id == 0 {\n                    Self::Pass\n                } else {\n                    Self::Mutation(mutation_id)\n                }\n            }\n            m => panic!(\"unknown mutagen mode: `{}`\", m),\n        }\n    }\n\n    /// Records that mutator with the given id is covered.\n    ///\n    /// This does nothing if coverage is not enabled.\n    pub fn covered(&self, mutator_id: usize) {\n        if let Self::Coverage(coverage) = &self {\n            coverage.covered(mutator_id)\n        }\n    }\n\n    /// Function to abort the computation in case a optimistic mutation fails.\n    ///\n    /// In the future, this will be configurable\n    pub fn optimistic_assumption_failed(&self) -> ! {\n        match self {\n            Self::Mutation(m_id) => {\n                panic!(\"optimistic assumption failed for mutation {}\", m_id);\n            }\n            _ => panic!(\"optimistic assumption failed without mutation\"),\n        }\n    }\n\n    pub fn mutation_id(&self) -> Option<usize> {\n        if let Self::Mutation(m_id) = self {\n            Some(*m_id)\n        } else {\n            None\n        }\n    }\n\n    /// Checks if the given mutation is activated.\n    pub fn is_mutation_active(&self, mutation_id: usize) -> bool {\n        self.mutation_id() == Some(mutation_id)\n    }\n\n    /// Returns the active mutation for a given mutator, or None if no mutation of the mutator is activated.\n    pub fn get_mutation_for_mutator<'a, T>(\n        &self,\n        mutator_id: usize,\n        mutations: &'a [T],\n    ) -> Option<&'a T> {\n        let m_id = self.mutation_id()?;\n        if m_id < mutator_id {\n            return None;\n        }\n        let index = m_id - mutator_id;\n        mutations.get(index)\n    }\n}\n\nimpl CoverageRecorder {\n    fn new(num_mutations: usize) -> Self {\n        let coverage = CoverageHitCollector::new(num_mutations);\n        let coverage_filepath = comm::get_coverage_file().unwrap();\n        let coverage_file = File::create(&coverage_filepath)\n            .unwrap_or_else(|_| panic!(\"unable to open file {:?}\", &coverage_filepath));\n\n        Self {\n            coverage,\n            coverage_file,\n        }\n    }\n\n    fn covered(&self, mutator_id: usize) {\n        // report first coverage\n        if self.coverage.hit(mutator_id) {\n            let coverage_hit = comm::CoverageHit { mutator_id };\n\n            let mut w = BufWriter::new(&self.coverage_file);\n            serde_json::to_writer(&mut w, &coverage_hit).expect(\"unable to write to coverage file\");\n            // write newline\n            writeln!(&mut w).expect(\"unable to write to coverage file\");\n        }\n    }\n}\n\n/// struct that collects coverage of mutators.\n///\n/// It has to be created with a known size.\n///\n/// The method `hit`, is used for recording coverage hits.\nstruct CoverageHitCollector(Vec<AtomicU64>);\n\nimpl CoverageHitCollector {\n    /// constructs a HotCoverageCollection for a given number of mutations\n    fn new(num_mutations: usize) -> Self {\n        Self((0..=num_mutations).map(|_| AtomicU64::new(0)).collect())\n    }\n\n    /// records a single coverage hit.\n    ///\n    /// Returns true iff this hit was the first for this mutator\n    fn hit(&self, mutator_id: usize) -> bool {\n        0 == self.0[mutator_id].fetch_add(1, Ordering::Relaxed)\n    }\n}\n\n/// module with functions used for isolated and exhaustive tests of the `#[mutate]` attribute\n#[cfg(any(test, feature = \"self_test\"))]\nmod test_tools {\n\n    use super::*;\n    use std::sync::Mutex;\n\n    lazy_static! {\n        /// a lock to ensure that the tests are run sequentially since global information is set.\n        static ref TEST_LOCK: Mutex<()> = Mutex::new(());\n    }\n\n    impl MutagenRuntimeConfig {\n        /// sets the global `mutation_id` correctly before running the test and runs tests sequentially.\n        ///\n        /// The lock is required to ensure that set `mutation_id` is valid for the complete duration of the test case.\n        fn test_with_runtime<F: FnOnce() -> ()>(self, testcase: F) {\n            let lock = TEST_LOCK.lock();\n            *RUNTIME_CONFIG.write().unwrap() = self;\n            testcase();\n            drop(lock); // drop here to show the extended lifetime of lock guard\n        }\n\n        pub fn test_without_mutation<F: FnOnce() -> ()>(testcase: F) {\n            Self::test_with_runtime(Self::without_mutation(), testcase)\n        }\n\n        pub fn test_with_mutation_id<F: FnOnce() -> ()>(mutation_id: usize, testcase: F) {\n            Self::test_with_runtime(Self::with_mutation_id(mutation_id), testcase)\n        }\n\n        pub fn without_mutation() -> Self {\n            Self::Pass\n        }\n\n        pub fn with_mutation_id(mutation_id: usize) -> Self {\n            assert!(mutation_id != 0);\n            MutagenRuntimeConfig::Mutation(mutation_id)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn config_mutation_active() {\n        let config = MutagenRuntimeConfig::with_mutation_id(1);\n\n        assert!(config.is_mutation_active(1));\n    }\n    #[test]\n    fn config_mutation_inactive() {\n        let config = MutagenRuntimeConfig::with_mutation_id(1);\n\n        assert!(!config.is_mutation_active(2));\n    }\n    #[test]\n    fn config_mutation_no_mutation() {\n        let config = MutagenRuntimeConfig::without_mutation();\n\n        assert!(!config.is_mutation_active(1));\n    }\n\n    #[test]\n    fn coverage_hit_collector_hit() {\n        let collector = CoverageHitCollector::new(1);\n        assert!(collector.hit(1));\n    }\n    #[test]\n    fn coverage_hit_collector_repeated_hit() {\n        let collector = CoverageHitCollector::new(1);\n        collector.hit(1);\n\n        assert!(!collector.hit(1));\n    }\n    #[test]\n    fn coverage_hit_collector_hit_different_mutators() {\n        let collector = CoverageHitCollector::new(2);\n        assert!(collector.hit(1));\n        assert!(collector.hit(2));\n    }\n    #[test]\n    #[should_panic]\n    fn coverage_hit_collector_out_of_bounds() {\n        CoverageHitCollector::new(1).hit(2);\n    }\n}\n","traces":[{"line":34,"address":[4609271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[4609294],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[5545456],"length":1,"stats":{"Line":4},"fn_name":"get_default"},{"line":59,"address":[5545467],"length":1,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[5545620,5545552],"length":1,"stats":{"Line":1},"fn_name":"from_env"},{"line":68,"address":[5545569,5546578,5545635],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[5545750,5546455,5546275],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[5545783,5545868],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[5721184,5721193],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":75,"address":[5546242],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[5545878],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[5721328,5721337],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":82,"address":[5546451,5546410],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[5546444],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[5546429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[5546462,5545976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[5546672],"length":1,"stats":{"Line":1},"fn_name":"covered"},{"line":96,"address":[5546731,5546686],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[5546719],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[5546752],"length":1,"stats":{"Line":0},"fn_name":"optimistic_assumption_failed"},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[5546764,5546817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[5546828],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[5546775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[5546976],"length":1,"stats":{"Line":2},"fn_name":"mutation_id"},{"line":114,"address":[5547004,5546985],"length":1,"stats":{"Line":4},"fn_name":null},{"line":115,"address":[5547025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[5546995],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[5547072],"length":1,"stats":{"Line":2},"fn_name":"is_mutation_active"},{"line":123,"address":[5547086],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[4220512,4221088,4221376,4220224,4220800],"length":1,"stats":{"Line":10},"fn_name":"get_mutation_for_mutator<mutagen_core::mutator::mutator_binop_bit::MutationBinopBit>"},{"line":132,"address":[4220842,4220554,4220266,4220939,4221130,4221515,4220651,4220674,4221538,4221250,4220363,4220962,4221227,4220386,4221418],"length":1,"stats":{"Line":24},"fn_name":null},{"line":133,"address":[4220639,4221215,4220927,4220351,4221503],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[4221292,4220716,4221580,4220428,4221004],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[4221274,4220444,4220698,4221629,4220765,4221020,4221053,4221083,4221308,4220507,4220410,4220795,4221341,4221562,4221659,4220477,4220732,4220986,4221371,4221596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[4220750,4221038,4221326,4221614,4220462],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[5547168,5547227],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":143,"address":[5547186],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[5547242],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[5547368,5547286,5547320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[5547312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[5547568,5547618],"length":1,"stats":{"Line":0},"fn_name":"covered"},{"line":156,"address":[5547867,5547637,5547591],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[5547653],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[5547663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[5547684],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[5547759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[5547904],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":177,"address":[5547920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[5548032],"length":1,"stats":{"Line":0},"fn_name":"hit"},{"line":184,"address":[5548053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":20,"coverable":64},{"path":["/","mnt","c","Users","kms2","Desktop","KAIST","7학기","소프트웨어 테스팅 자동화 기법","PJ","mutagen","mutagen-core","src","transformer","arg_ast.rs"],"content":"//! A AST type for `#[mutate]` configuration via arguments.\n//!\n//! The token stream of the input args is parsed into the `ArgAst` type by `ArgAstList::parse_list`.\n//!\n//! Please refer to the customization documentation about the format of arguments.\n\nuse proc_macro2::{Delimiter, TokenStream, TokenTree};\n\n#[derive(Debug, Eq, PartialEq, Clone)]\npub struct ArgAstList(pub Vec<ArgAst>);\n\n#[derive(Debug, Eq, PartialEq, Clone)]\npub enum ArgAst {\n    ArgFn(ArgFn),\n    ArgEq(ArgEq),\n}\n\n#[derive(Debug, Eq, PartialEq, Clone)]\npub struct ArgFn {\n    pub name: String,\n    pub args: ArgAstList,\n}\n\n#[derive(Debug, Eq, PartialEq, Clone)]\npub struct ArgEq {\n    pub name: String,\n    pub val: ArgFn,\n}\n\nimpl ArgAstList {\n    pub fn parse_list(input: TokenStream) -> Result<Self, ()> {\n        let mut args = Vec::new();\n\n        let mut tt_iter = input.into_iter();\n        while let Some(next) = tt_iter.next() {\n            let name = if let TokenTree::Ident(next) = next {\n                next.to_string()\n            } else if let TokenTree::Literal(next) = next {\n                next.to_string()\n            } else {\n                return Err(());\n            };\n\n            args.push(ArgAst::parse_single(name, &mut tt_iter)?);\n        }\n\n        Ok(Self(args))\n    }\n\n    pub fn find_named_arg(&self, name: &str) -> Result<Option<&ArgFn>, ()> {\n        let named_args = self\n            .0\n            .iter()\n            .filter(|ast| ast.name() == name)\n            .map(|ast| Ok(&ast.expect_eq_ref()?.val))\n            .collect::<Result<Vec<&ArgFn>, ()>>()?;\n        if named_args.len() > 1 {\n            return Err(());\n        }\n        Ok(named_args.get(0).copied())\n    }\n}\n\nimpl ArgAst {\n    fn new_fn(name: String, args: ArgAstList) -> Self {\n        Self::ArgFn(ArgFn::new(name, args))\n    }\n    fn new_eq(name: String, val: ArgFn) -> Self {\n        Self::ArgEq(ArgEq::new(name, val))\n    }\n\n    pub fn name(&self) -> &str {\n        match self {\n            ArgAst::ArgFn(ArgFn { name, .. }) => name,\n            ArgAst::ArgEq(ArgEq { name, .. }) => name,\n        }\n    }\n\n    fn parse_single(\n        name: String,\n        tt_iter: &mut impl Iterator<Item = TokenTree>,\n    ) -> Result<Self, ()> {\n        match tt_iter.next() {\n            None => return Ok(Self::new_fn(name, ArgAstList(vec![]))),\n\n            // parse fn-variant\n            Some(TokenTree::Group(g)) => {\n                if g.delimiter() != Delimiter::Parenthesis {\n                    return Err(());\n                }\n                let args = ArgAstList::parse_list(g.stream())?;\n                tt_expect_comma_or_end(tt_iter)?;\n                return Ok(Self::new_fn(name, args));\n            }\n\n            // parse eq-variant\n            Some(TokenTree::Punct(p)) => {\n                if p.as_char() == ',' {\n                    return Ok(Self::new_fn(name, ArgAstList(vec![])));\n                }\n                if p.as_char() != '=' {\n                    return Err(());\n                }\n\n                let next = tt_iter.next();\n                let next = if let Some(TokenTree::Ident(next)) = next {\n                    next.to_string()\n                } else if let Some(TokenTree::Literal(next)) = next {\n                    next.to_string()\n                } else {\n                    return Err(());\n                };\n\n                // parse value, only allow ArgFn values.\n                let val = Self::parse_single(next, tt_iter)?.expect_fn()?;\n                return Ok(Self::new_eq(name, val));\n            }\n            _ => return Err(()),\n        }\n    }\n\n    pub fn expect_fn(self) -> Result<ArgFn, ()> {\n        match self {\n            ArgAst::ArgFn(f) => Ok(f),\n            ArgAst::ArgEq(_) => Err(()),\n        }\n    }\n    pub fn expect_fn_ref(&self) -> Result<&ArgFn, ()> {\n        match self {\n            ArgAst::ArgFn(f) => Ok(f),\n            ArgAst::ArgEq(_) => Err(()),\n        }\n    }\n    pub fn expect_eq_ref(&self) -> Result<&ArgEq, ()> {\n        match self {\n            ArgAst::ArgFn(_) => Err(()),\n            ArgAst::ArgEq(e) => Ok(e),\n        }\n    }\n}\n\nfn tt_expect_comma_or_end(tt_iter: &mut impl Iterator<Item = TokenTree>) -> Result<(), ()> {\n    match tt_iter.next() {\n        None => {}\n        Some(TokenTree::Punct(p)) => {\n            if p.as_char() != ',' {\n                return Err(());\n            }\n        }\n        _ => return Err(()),\n    }\n    Ok(())\n}\n\nimpl ArgFn {\n    pub fn new(name: String, args: ArgAstList) -> Self {\n        Self { name, args }\n    }\n}\n\nimpl ArgEq {\n    pub fn new(name: String, val: ArgFn) -> Self {\n        Self { name, val }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use proc_macro2::TokenStream;\n    use std::str::FromStr;\n\n    #[test]\n    fn no_args() {\n        let input = TokenStream::new();\n\n        let parsed = ArgAstList::parse_list(input);\n\n        assert_eq!(parsed, Ok(ArgAstList(vec![])));\n    }\n\n    #[test]\n    fn single_arg() {\n        let input = TokenStream::from_str(\"a1\").unwrap();\n\n        let parsed = ArgAstList::parse_list(input);\n\n        let expected = ArgAst::new_fn(\"a1\".to_string(), ArgAstList(vec![]));\n        assert_eq!(parsed, Ok(ArgAstList(vec![expected])));\n    }\n\n    #[test]\n    fn single_arg_int() {\n        let input = TokenStream::from_str(\"1\").unwrap();\n\n        let parsed = ArgAstList::parse_list(input);\n\n        let expected = ArgAst::new_fn(\"1\".to_string(), ArgAstList(vec![]));\n        assert_eq!(parsed, Ok(ArgAstList(vec![expected])));\n    }\n\n    #[test]\n    fn single_arg_with_args() {\n        let input = TokenStream::from_str(\"a2(x, y, z)\").unwrap();\n\n        let parsed = ArgAstList::parse_list(input);\n\n        let mut expected = ArgFn::new(\"a2\".to_string(), ArgAstList(vec![]));\n        expected\n            .args\n            .0\n            .push(ArgAst::new_fn(\"x\".to_string(), ArgAstList(vec![])));\n        expected\n            .args\n            .0\n            .push(ArgAst::new_fn(\"y\".to_string(), ArgAstList(vec![])));\n        expected\n            .args\n            .0\n            .push(ArgAst::new_fn(\"z\".to_string(), ArgAstList(vec![])));\n        let expected = ArgAst::ArgFn(expected);\n        assert_eq!(parsed, Ok(ArgAstList(vec![expected])));\n    }\n\n    #[test]\n    fn single_arg_with_trailing_comma() {\n        let input = TokenStream::from_str(\"a2(x,)\").unwrap();\n\n        let parsed = ArgAstList::parse_list(input);\n\n        let mut expected = ArgFn::new(\"a2\".to_string(), ArgAstList(vec![]));\n        expected\n            .args\n            .0\n            .push(ArgAst::new_fn(\"x\".to_string(), ArgAstList(vec![])));\n        let expected = ArgAst::ArgFn(expected);\n        assert_eq!(parsed, Ok(ArgAstList(vec![expected])));\n    }\n\n    #[test]\n    fn single_arg_with_eq_args() {\n        let input = TokenStream::from_str(\"a2(x=a)\").unwrap();\n\n        let parsed = ArgAstList::parse_list(input);\n\n        let mut expected = ArgFn::new(\"a2\".to_string(), ArgAstList(vec![]));\n        expected.args.0.push(ArgAst::new_eq(\n            \"x\".to_string(),\n            ArgFn::new(\"a\".to_owned(), ArgAstList(vec![])),\n        ));\n        let expected = ArgAst::ArgFn(expected);\n        assert_eq!(parsed, Ok(ArgAstList(vec![expected])));\n    }\n\n    #[test]\n    fn chained_eq_gives_error() {\n        let input = TokenStream::from_str(\"a = b = c\").unwrap();\n        let parsed = ArgAstList::parse_list(input);\n        assert_eq!(parsed, Err(()));\n    }\n\n    #[test]\n    fn multiple_args() {\n        let input = TokenStream::from_str(\"a2, b5\").unwrap();\n\n        let parsed = ArgAstList::parse_list(input);\n\n        let expected1 = ArgAst::new_fn(\"a2\".to_string(), ArgAstList(vec![]));\n        let expected2 = ArgAst::new_fn(\"b5\".to_string(), ArgAstList(vec![]));\n        assert_eq!(parsed, Ok(ArgAstList(vec![expected1, expected2])));\n    }\n\n    #[test]\n    fn nested_args() {\n        let input = TokenStream::from_str(\"g55(h3(X))\").unwrap();\n\n        let parsed = ArgAstList::parse_list(input);\n\n        let mut expected = ArgFn::new(\"g55\".to_string(), ArgAstList(vec![]));\n        let mut expected1 = ArgFn::new(\"h3\".to_string(), ArgAstList(vec![]));\n        expected1\n            .args\n            .0\n            .push(ArgAst::new_fn(\"X\".to_string(), ArgAstList(vec![])));\n        expected.args.0.push(ArgAst::ArgFn(expected1));\n        let expected = ArgAst::ArgFn(expected);\n        assert_eq!(parsed, Ok(ArgAstList(vec![expected])));\n    }\n\n    #[test]\n    fn nested_args_with_trailing_arg() {\n        let input = TokenStream::from_str(\"g55(h3(X), z)\").unwrap();\n\n        let parsed = ArgAstList::parse_list(input);\n\n        let mut expected = ArgFn::new(\"g55\".to_string(), ArgAstList(vec![]));\n        let mut expected1 = ArgFn::new(\"h3\".to_string(), ArgAstList(vec![]));\n        expected1\n            .args\n            .0\n            .push(ArgAst::new_fn(\"X\".to_string(), ArgAstList(vec![])));\n        expected.args.0.push(ArgAst::ArgFn(expected1));\n        expected\n            .args\n            .0\n            .push(ArgAst::new_fn(\"z\".to_string(), ArgAstList(vec![])));\n        let expected = ArgAst::ArgFn(expected);\n        assert_eq!(parsed, Ok(ArgAstList(vec![expected])));\n    }\n\n    #[test]\n    fn single_arg_with_eq_args_nested() {\n        let input = TokenStream::from_str(\"a2(x=a(b))\").unwrap();\n\n        let parsed = ArgAstList::parse_list(input);\n\n        let mut expected = ArgFn::new(\"a2\".to_string(), ArgAstList(vec![]));\n        let mut expected1 = ArgFn::new(\"a\".to_owned(), ArgAstList(vec![]));\n        expected1\n            .args\n            .0\n            .push(ArgAst::new_fn(\"b\".to_owned(), ArgAstList(vec![])));\n        expected\n            .args\n            .0\n            .push(ArgAst::new_eq(\"x\".to_string(), expected1));\n        let expected = ArgAst::ArgFn(expected);\n        assert_eq!(parsed, Ok(ArgAstList(vec![expected])));\n    }\n\n    #[test]\n    fn list_of_eq_args() {\n        let input = TokenStream::from_str(\"x = a, y = b\").unwrap();\n\n        let parsed = ArgAstList::parse_list(input);\n\n        let expected1 = ArgEq::new(\n            \"x\".to_string(),\n            ArgFn::new(\"a\".to_owned(), ArgAstList(vec![])),\n        );\n        let expected2 = ArgEq::new(\n            \"y\".to_string(),\n            ArgFn::new(\"b\".to_owned(), ArgAstList(vec![])),\n        );\n\n        let expected = ArgAstList(vec![ArgAst::ArgEq(expected1), ArgAst::ArgEq(expected2)]);\n        assert_eq!(parsed, Ok(expected));\n    }\n}\n","traces":[{"line":31,"address":[4673632,4673716],"length":1,"stats":{"Line":0},"fn_name":"parse_list"},{"line":32,"address":[4673642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[4673731],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[4675102,4673898,4673848,4673802],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[4673946,4674113,4673987],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[4674043],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[4674256,4673963,4674094,4674070,4674135],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[4674191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[4674123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[4674305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[4674687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[4675339,4675296],"length":1,"stats":{"Line":0},"fn_name":"find_named_arg"},{"line":51,"address":[4675623,4675321,4675535,4675364,4675393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[4675380],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[5654718,5654704],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":56,"address":[4675491,4675654,4675625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[4675735,4675599],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[4675770,4675793],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[4675741,4675798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[4675936],"length":1,"stats":{"Line":0},"fn_name":"new_fn"},{"line":66,"address":[4675943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[4676064],"length":1,"stats":{"Line":0},"fn_name":"new_eq"},{"line":69,"address":[4676074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[4676192],"length":1,"stats":{"Line":0},"fn_name":"name"},{"line":73,"address":[4676308,4676252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[4676259,4676201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[4676315,4676221],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[5654832,5654964],"length":1,"stats":{"Line":0},"fn_name":"parse_single<proc_macro2::token_stream::IntoIter>"},{"line":83,"address":[5654979,5654850],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[5654987,5655080,5657561,5655252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[5655307,5655024],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[5655444,5655357],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[5655508,5655482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[5655751,5655529,5655450,5655695],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[5655941,5655684,5655779,5655983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[5655993,5655834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[5655489,5655421,5656022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[5656046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[5657837,5656104],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[5656078,5656284],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[5656318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[5656289,5656331],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[5656552,5656416,5656347],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[5656487],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[5656574,5656514,5656710,5656379],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[5656645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[5656562,5657975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[5656712,5657380,5657074,5658158],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[5657455,5657257],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[5655068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[4676352],"length":1,"stats":{"Line":0},"fn_name":"expect_fn"},{"line":123,"address":[4676399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[4676362,4676411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[4676392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[4676560],"length":1,"stats":{"Line":0},"fn_name":"expect_fn_ref"},{"line":129,"address":[4676592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[4676569,4676600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[4676583],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[4676640],"length":1,"stats":{"Line":0},"fn_name":"expect_eq_ref"},{"line":135,"address":[4676683],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[4676687,4676649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[4676667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[5658464,5658505],"length":1,"stats":{"Line":0},"fn_name":"tt_expect_comma_or_end<proc_macro2::token_stream::IntoIter>"},{"line":143,"address":[5658479,5658631,5658579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[5658520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[5658557,5658584],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[5658602],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[5658729,5658636],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[5658569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[5658790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[4676720],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":162,"address":[4676848],"length":1,"stats":{"Line":0},"fn_name":"new"}],"covered":0,"coverable":74},{"path":["/","mnt","c","Users","kms2","Desktop","KAIST","7학기","소프트웨어 테스팅 자동화 기법","PJ","mutagen","mutagen-core","src","transformer","mutate_args.rs"],"content":"//! parse arguments for the `#[mutate]` attribute and gather all information necessary to transform the source code.\n//!\n//! Please refer to the customization documentation about the format of arguments.\n\nuse super::arg_ast::{ArgAstList, ArgFn};\nuse proc_macro2::TokenStream;\n\n#[derive(PartialEq, Eq, Debug)]\npub struct ArgOptions {\n    pub conf: Conf,\n    pub transformers: Transformers,\n}\n\n#[derive(PartialEq, Eq, Debug)]\npub enum Transformers {\n    All,\n    Only(TransformerList),\n    Not(TransformerList),\n}\n\n#[derive(PartialEq, Eq, Debug)]\npub enum Conf {\n    Global,\n    Local(LocalConf),\n}\n\n#[derive(PartialEq, Eq, Debug, Default)]\npub struct LocalConf {\n    pub expected_mutations: Option<usize>,\n}\n\n#[derive(PartialEq, Eq, Debug)]\npub struct TransformerList {\n    pub transformers: Vec<String>,\n}\n\nimpl Default for ArgOptions {\n    fn default() -> Self {\n        Self {\n            conf: Conf::Global,\n            transformers: Transformers::All,\n        }\n    }\n}\n\nimpl ArgOptions {\n    pub fn parse(args: TokenStream) -> Result<Self, ()> {\n        let mut options: Self = Default::default();\n\n        let ast = ArgAstList::parse_list(args)?;\n        if let Some(conf) = ast.find_named_arg(\"conf\")? {\n            options.conf = Conf::parse(&conf)?;\n        }\n        if let Some(transformers_arg) = ast.find_named_arg(\"mutators\")? {\n            match &*transformers_arg.name {\n                \"only\" => {\n                    options.transformers = Transformers::parse_only(&transformers_arg.args)?;\n                }\n                \"not\" => {\n                    options.transformers = Transformers::parse_not(&transformers_arg.args)?;\n                }\n                _ => return Err(()),\n            }\n        }\n        Ok(options)\n    }\n}\n\nimpl Conf {\n    fn parse(conf: &ArgFn) -> Result<Self, ()> {\n        match &*conf.name {\n            \"local\" => {\n                let expected_mutations = conf.args.find_named_arg(\"expected_mutations\")?;\n                let expected_mutations = expected_mutations\n                    .map(|arg| arg.name.parse::<usize>())\n                    .transpose()\n                    .map_err(|_| ())?;\n                Ok(Conf::Local(LocalConf { expected_mutations }))\n            }\n            \"global\" => Ok(Conf::Global),\n            _ => Err(()),\n        }\n    }\n}\n\nimpl TransformerList {\n    fn parse(ast: &ArgAstList) -> Result<Self, ()> {\n        let transformers = ast\n            .0\n            .iter()\n            .map(|t| {\n                let t = t.expect_fn_ref()?;\n                if !t.args.0.is_empty() {\n                    return Err(());\n                }\n                Ok(t.name.clone())\n            })\n            .collect::<Result<Vec<_>, ()>>()?;\n        Ok(Self { transformers })\n    }\n}\n\nimpl Transformers {\n    fn parse_only(ast: &ArgAstList) -> Result<Self, ()> {\n        Ok(Transformers::Only(TransformerList::parse(ast)?))\n    }\n\n    fn parse_not(ast: &ArgAstList) -> Result<Self, ()> {\n        Ok(Transformers::Not(TransformerList::parse(ast)?))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::*;\n    use proc_macro2::TokenStream;\n    use std::str::FromStr;\n\n    #[test]\n    fn config_for_empty_args() {\n        let input = TokenStream::new();\n\n        let parsed = ArgOptions::parse(input);\n\n        let expected = Ok(ArgOptions::default());\n\n        assert_eq!(expected, parsed);\n    }\n\n    #[test]\n    fn config_local() {\n        let input = TokenStream::from_str(\"conf = local\").unwrap();\n\n        let parsed = ArgOptions::parse(input);\n\n        assert!(parsed.is_ok());\n        let parsed = parsed.unwrap();\n\n        let expected_conf_local = Conf::Local(LocalConf::default());\n        assert_eq!(parsed.conf, expected_conf_local);\n        assert_eq!(parsed.transformers, Transformers::All);\n    }\n\n    #[test]\n    fn config_local_single_mutator() {\n        let input = TokenStream::from_str(\"conf = local, mutators = only(binop_add)\").unwrap();\n\n        let parsed = ArgOptions::parse(input);\n\n        assert!(parsed.is_ok());\n        let parsed = parsed.unwrap();\n\n        let expected_conf_local = Conf::Local(LocalConf::default());\n        assert_eq!(parsed.conf, expected_conf_local);\n\n        let expected_transformers = Transformers::Only(TransformerList {\n            transformers: vec![\"binop_add\".to_owned()],\n        });\n        assert_eq!(parsed.transformers, expected_transformers);\n    }\n}\n","traces":[{"line":38,"address":[6029856],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":47,"address":[6029952,6030032],"length":1,"stats":{"Line":0},"fn_name":"parse"},{"line":48,"address":[6029962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[6030310,6030047,6030339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[6030267,6030435,6030815,6030630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[6030656,6030817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[6031722,6030854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[6031079,6032093,6032247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[6031114],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[6031255,6031944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[6031183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[6031492,6032098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[6031238],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[6031724],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[6032416],"length":1,"stats":{"Line":0},"fn_name":"parse"},{"line":71,"address":[6032431,6032558,6032950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[6032474],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[6032719,6032691,6032575],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[6032672,6032834,6032742,6032952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[5401840,5401857],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[5401920,5401926,5401928],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":78,"address":[6032876],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[6032518,6032984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[6032549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[6033040,6033089],"length":1,"stats":{"Line":0},"fn_name":"parse"},{"line":88,"address":[6033063,6033234,6033441,6033114],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[5401936],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":92,"address":[5402059,5401958,5402084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[5402029,5402098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[5402130],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[5402139,5402109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[6033443,6033467,6033193],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[6033312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[6033520,6033563],"length":1,"stats":{"Line":0},"fn_name":"parse_only"},{"line":105,"address":[6033538,6033632,6033791,6033817,6033844,6033578],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[6033915,6033872],"length":1,"stats":{"Line":0},"fn_name":"parse_not"},{"line":109,"address":[6033930,6034143,6034169,6034196,6033984,6033890],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":40},{"path":["/","mnt","c","Users","kms2","Desktop","KAIST","7학기","소프트웨어 테스팅 자동화 기법","PJ","mutagen","mutagen-core","src","transformer","transform_info.rs"],"content":"use lazy_static::lazy_static;\nuse std::fs::{create_dir_all, File};\nuse std::iter;\nuse std::sync::{Arc, Mutex, MutexGuard};\n\nuse proc_macro2::Span;\n\nuse super::mutate_args::LocalConf;\nuse crate::comm;\nuse crate::comm::{BakedMutation, Mutation};\n\nlazy_static! {\n    static ref GLOBAL_TRANSFORM_INFO: SharedTransformInfo = Default::default();\n}\n\n#[derive(Default)]\npub struct SharedTransformInfo(Arc<Mutex<MutagenTransformInfo>>);\n\n/// Contains information about all mutations inserted into the code under test\n///\n/// This struct is used to collect the mutations during transformation.\n/// After running all transformers, this struct contains all mutators\n/// and their mutations inserted into the code\n#[derive(Debug)]\npub struct MutagenTransformInfo {\n    mutations: Vec<BakedMutation>,\n    mutagen_file: Option<File>,\n    expected_mutations: Option<usize>,\n    tmp_var_id: usize,\n}\n\nimpl Default for MutagenTransformInfo {\n    fn default() -> Self {\n        Self {\n            mutations: vec![],\n            mutagen_file: None,\n            expected_mutations: None,\n            tmp_var_id: 0,\n        }\n    }\n}\n\nimpl MutagenTransformInfo {\n    fn with_default_mutagen_file(&mut self) {\n        // open file only once\n        if self.mutagen_file.is_none() {\n            let mutagen_filepath = comm::get_mutations_file().unwrap();\n            let mutagen_dir = mutagen_filepath.parent().unwrap();\n            if !mutagen_dir.exists() {\n                create_dir_all(&mutagen_dir).unwrap();\n            }\n            let mutagen_file = File::create(&mutagen_filepath)\n                .unwrap_or_else(|_| panic!(\"unable to open file {:?}\", &mutagen_filepath));\n\n            self.mutagen_file = Some(mutagen_file);\n        }\n    }\n\n    /// add a mutation and return the id used for it, also writes the mutation to the global file.\n    fn add_mutation(&mut self, mutation: Mutation, mutator_id: usize) -> usize {\n        let mut_id = 1 + self.mutations.len();\n        let mutation = mutation.with_id(mut_id, mutator_id);\n\n        // write the mutation if file was configured\n        if let Some(mutagen_file) = &mut self.mutagen_file {\n            comm::append_item(mutagen_file, &mutation).expect(\"unable to write to mutagen file\");\n        }\n\n        // add mutation to list\n        self.mutations.push(mutation);\n\n        // return next mutation id\n        mut_id\n    }\n\n    fn get_num_mutations(&self) -> usize {\n        self.mutations.len()\n    }\n\n    fn get_next_mutation_id(&self) -> usize {\n        self.mutations.len() + 1\n    }\n\n    fn check_mutations(&mut self) {\n        if let Some(expected_mutations) = self.expected_mutations {\n            let actual_mutations = self.mutations.len();\n            if expected_mutations != actual_mutations {\n                panic!(\n                    \"expected {} mutations but inserted {}\",\n                    expected_mutations, actual_mutations\n                );\n            }\n        }\n    }\n\n    fn get_next_tmp_var(&mut self, span: Span) -> syn::Ident {\n        self.tmp_var_id += 1;\n        syn::Ident::new(&format!(\"__mutagen_tmp_{}\", self.tmp_var_id), span)\n    }\n}\n\nimpl SharedTransformInfo {\n    fn lock_transform_info(&self) -> MutexGuard<MutagenTransformInfo> {\n        self.0.lock().unwrap()\n    }\n\n    fn new(transform_info: MutagenTransformInfo) -> SharedTransformInfo {\n        SharedTransformInfo(Arc::new(Mutex::new(transform_info)))\n    }\n\n    pub fn global_info() -> Self {\n        GLOBAL_TRANSFORM_INFO\n            .lock_transform_info()\n            .with_default_mutagen_file();\n        GLOBAL_TRANSFORM_INFO.clone_shared()\n    }\n\n    pub fn local_info(conf: LocalConf) -> Self {\n        let mut transform_info = MutagenTransformInfo::default();\n        if let Some(n) = conf.expected_mutations {\n            transform_info.expected_mutations = Some(n);\n        }\n        Self::new(transform_info)\n    }\n\n    pub fn add_mutation(&self, mutation: Mutation) -> usize {\n        self.add_mutations(iter::once(mutation))\n    }\n\n    pub fn add_mutations(&self, mutations: impl IntoIterator<Item = Mutation>) -> usize {\n        let mut transform_info = self.lock_transform_info();\n\n        let mutator_id = transform_info.get_next_mutation_id();\n\n        // add all mutations within a single lock and return the first id\n        for mutation in mutations.into_iter() {\n            transform_info.add_mutation(mutation, mutator_id);\n        }\n        mutator_id\n    }\n\n    pub fn clone_shared(&self) -> Self {\n        Self(Arc::clone(&self.0))\n    }\n\n    pub fn get_num_mutations(&self) -> usize {\n        self.lock_transform_info().get_num_mutations()\n    }\n\n    pub fn check_mutations(&self) {\n        self.lock_transform_info().check_mutations()\n    }\n\n    pub fn get_next_tmp_var(&self, span: Span) -> syn::Ident {\n        self.lock_transform_info().get_next_tmp_var(span)\n    }\n}\n","traces":[{"line":13,"address":[4606980],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[4965120],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":35,"address":[4965127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[4965308,4965264],"length":1,"stats":{"Line":0},"fn_name":"with_default_mutagen_file"},{"line":46,"address":[4965726,4965279,4965327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[4965338],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[4965444,4965380],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[4965508,4965604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[4965551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[4965643,4965606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[4656175,4656160],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":55,"address":[4965685,4965736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[4965934,4965856],"length":1,"stats":{"Line":0},"fn_name":"add_mutation"},{"line":61,"address":[4965879,4965954,4966406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[4965990],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[4966110,4966225],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[4966156],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[4966227],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[4966464],"length":1,"stats":{"Line":0},"fn_name":"get_num_mutations"},{"line":77,"address":[4966473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[4966496],"length":1,"stats":{"Line":0},"fn_name":"get_next_mutation_id"},{"line":81,"address":[4966578,4966505,4966548],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[4966592],"length":1,"stats":{"Line":0},"fn_name":"check_mutations"},{"line":85,"address":[4966607],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[4966638],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[4966652],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[4966683],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[4966928,4966998],"length":1,"stats":{"Line":0},"fn_name":"get_next_tmp_var"},{"line":97,"address":[4967342,4966946,4967030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[4967034],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[4967392],"length":1,"stats":{"Line":0},"fn_name":"lock_transform_info"},{"line":104,"address":[4967401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[4967488],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":108,"address":[4967495],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[4967650,4967600],"length":1,"stats":{"Line":0},"fn_name":"global_info"},{"line":112,"address":[4967611,4967662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[4967726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[4967792],"length":1,"stats":{"Line":0},"fn_name":"local_info"},{"line":119,"address":[4967809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[4967820],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[4967843],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[4967877],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[4967952],"length":1,"stats":{"Line":0},"fn_name":"add_mutation"},{"line":127,"address":[4967967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[4657376,4658400,4657457,4662414,4659454,4656400,4659376,4656478,4660352,4661360,4661438,4660430,4658478,4662336],"length":1,"stats":{"Line":0},"fn_name":"add_mutations<core::iter::adapters::Map<core::slice::Iter<mutagen_core::mutator::mutator_binop_eq::MutationBinopEq>, closure-0>>"},{"line":131,"address":[4660367,4657391,4659474,4661458,4657480,4661375,4659391,4656498,4660450,4662351,4658498,4662434,4656415,4658415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[4657577,4662456,4657502,4660472,4658520,4656520,4658589,4660541,4659496,4656589,4661549,4659565,4661480,4662525],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[4657585,4661746,4660549,4658597,4662722,4657779,4659573,4656786,4660132,4659762,4658786,4657156,4661119,4662533,4662116,4656597,4659156,4661557,4660732,4663092,4658165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[4660039,4658017,4660970,4658073,4661984,4662023,4661026,4662960,4657024,4659024,4662999,4657063,4660000,4659063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[4968064],"length":1,"stats":{"Line":0},"fn_name":"clone_shared"},{"line":143,"address":[4968073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[4968141,4968112],"length":1,"stats":{"Line":0},"fn_name":"get_num_mutations"},{"line":147,"address":[4968121,4968153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[4968269,4968240],"length":1,"stats":{"Line":0},"fn_name":"check_mutations"},{"line":151,"address":[4968281,4968249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[4968418,4968368],"length":1,"stats":{"Line":0},"fn_name":"get_next_tmp_var"},{"line":155,"address":[4968430,4968380],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":60},{"path":["/","mnt","c","Users","kms2","Desktop","KAIST","7학기","소프트웨어 테스팅 자동화 기법","PJ","mutagen","mutagen-core","src","transformer.rs"],"content":"use proc_macro2::TokenStream;\nuse quote::ToTokens;\nuse syn::fold::Fold;\n\nmod arg_ast;\nmod mutate_args;\npub mod transform_context;\npub mod transform_info;\npub use transform_context::TransformContext;\n\nuse crate::mutator::*;\nuse transform_info::SharedTransformInfo;\n\npub fn do_transform_item(args: TokenStream, input: TokenStream) -> TokenStream {\n    let input = match syn::parse2::<syn::Item>(input) {\n        Ok(ast) => ast,\n        Err(e) => return TokenStream::from(e.to_compile_error()),\n    };\n    MutagenTransformerBundle::setup_from_attr(args.into()).mutagen_process_item(input)\n}\n\npub enum MutagenTransformer {\n    Expr(Box<MutagenExprTransformer>),\n    Stmt(Box<MutagenStmtTransformer>),\n}\n\npub struct MutagenTransformerBundle {\n    transform_info: SharedTransformInfo,\n    transform_context: TransformContext,\n    expr_transformers: Vec<Box<MutagenExprTransformer>>,\n    stmt_transformers: Vec<Box<MutagenStmtTransformer>>,\n}\n\n/// function-type that describes expression-transformers.\n///\n// the transformer should not inspect the expression recursively since recursion is performed by the `MutagenTransformerBundle`\ntype MutagenExprTransformer =\n    dyn FnMut(syn::Expr, &SharedTransformInfo, &TransformContext) -> syn::Expr;\n\n/// function-type that describes expression-transformers.\n///\n// the transformer should not inspect the expression recursively since recursion is performed by the `MutagenTransformerBundle`\ntype MutagenStmtTransformer =\n    dyn FnMut(syn::Stmt, &SharedTransformInfo, &TransformContext) -> syn::Stmt;\n\nimpl Fold for MutagenTransformerBundle {\n    fn fold_expr(&mut self, e: syn::Expr) -> syn::Expr {\n        // save the original expr into the context\n        let old_expr = self.transform_context.original_expr.replace(e.clone());\n\n        // transform content of the expression first\n        let mut result = syn::fold::fold_expr(self, e);\n\n        // call all transformers on this expression\n        for transformer in &mut self.expr_transformers {\n            result = transformer(result, &self.transform_info, &self.transform_context);\n        }\n\n        // reset original_stmt to original state\n        self.transform_context.original_expr = old_expr;\n        result\n    }\n\n    fn fold_stmt(&mut self, s: syn::Stmt) -> syn::Stmt {\n        // save the original stmt into the context\n        let old_stmt = self.transform_context.original_stmt.replace(s.clone());\n\n        // transform content of the statement first\n        let mut result = syn::fold::fold_stmt(self, s);\n\n        // call all transformers on this statement\n        for transformer in &mut self.stmt_transformers {\n            result = transformer(result, &self.transform_info, &self.transform_context);\n        }\n\n        // reset original_stmt to original state\n        self.transform_context.original_stmt = old_stmt;\n        result\n    }\n\n    fn fold_item_fn(&mut self, i: syn::ItemFn) -> syn::ItemFn {\n        // do not mutate const functions\n        if i.sig.constness.is_some() {\n            return i;\n        }\n        // do not mutate unsafe functions\n        if i.sig.unsafety.is_some() {\n            return i;\n        }\n\n        // insert the new functionname into context\n        let old_fn_name = self\n            .transform_context\n            .fn_name\n            .replace(i.sig.ident.to_string());\n\n        // do transformations\n        let result = syn::fold::fold_item_fn(self, i);\n\n        // restore old context\n        self.transform_context.fn_name = old_fn_name;\n\n        result\n    }\n\n    fn fold_impl_item_method(&mut self, i: syn::ImplItemMethod) -> syn::ImplItemMethod {\n        // do not mutate const functions\n        if i.sig.constness.is_some() {\n            return i;\n        }\n        // do not mutate unsafe functions\n        if i.sig.unsafety.is_some() {\n            return i;\n        }\n\n        // insert the new functionname into context\n        let old_fn_name = self\n            .transform_context\n            .fn_name\n            .replace(i.sig.ident.to_string());\n\n        // do transformations\n        let result = syn::fold::fold_impl_item_method(self, i);\n\n        // restore old context\n        self.transform_context.fn_name = old_fn_name;\n\n        result\n    }\n\n    fn fold_item_impl(&mut self, i: syn::ItemImpl) -> syn::ItemImpl {\n        // insert the new item name into context\n        let old_fn_name = self\n            .transform_context\n            .impl_name\n            .replace(i.self_ty.to_token_stream().to_string());\n\n        // do transformations\n        let result = syn::fold::fold_item_impl(self, i);\n\n        // restore old context\n        self.transform_context.impl_name = old_fn_name;\n\n        result\n    }\n\n    fn fold_expr_repeat(&mut self, e: syn::ExprRepeat) -> syn::ExprRepeat {\n        let syn::ExprRepeat {\n            attrs,\n            bracket_token,\n            expr,\n            semi_token,\n            len,\n        } = e;\n\n        // mutate expr only, `len` is constant and should not be mutated\n        let expr = Box::new(syn::fold::fold_expr(self, *expr));\n\n        syn::ExprRepeat {\n            attrs,\n            bracket_token,\n            expr,\n            semi_token,\n            len,\n        }\n    }\n\n    fn fold_foreign_item_fn(&mut self, i: syn::ForeignItemFn) -> syn::ForeignItemFn {\n        // do not mutate const functions\n        if i.sig.constness.is_some() {\n            return i;\n        }\n        if i.sig.unsafety.is_some() {\n            return i;\n        }\n\n        // insert the new functionname into context\n        let old_fn_name = self\n            .transform_context\n            .fn_name\n            .replace(i.sig.ident.to_string());\n\n        // do transformations\n        let result = syn::fold::fold_foreign_item_fn(self, i);\n\n        // restore old context\n        self.transform_context.fn_name = old_fn_name;\n\n        result\n    }\n\n    fn fold_pat(&mut self, i: syn::Pat) -> syn::Pat {\n        // do not mutate patterns\n        i\n    }\n\n    fn fold_item_const(&mut self, i: syn::ItemConst) -> syn::ItemConst {\n        // do not mutate const-items\n        i\n    }\n\n    fn fold_item_static(&mut self, i: syn::ItemStatic) -> syn::ItemStatic {\n        // do not mutate static items\n        i\n    }\n\n    fn fold_type(&mut self, t: syn::Type) -> syn::Type {\n        // do not mutate types\n        t\n    }\n\n    fn fold_expr_unsafe(&mut self, e: syn::ExprUnsafe) -> syn::ExprUnsafe {\n        // do not mutate unsafe blocks\n        e\n    }\n}\n\nimpl MutagenTransformerBundle {\n    pub fn mutagen_process_item(&mut self, target: syn::Item) -> TokenStream {\n        let stream = self.fold_item(target).into_token_stream();\n        self.transform_info.check_mutations();\n        stream\n    }\n\n    pub fn mk_transformer(\n        transformer_name: &str,\n        _transformer_args: &[String],\n    ) -> MutagenTransformer {\n        match transformer_name {\n            \"lit_int\" => MutagenTransformer::Expr(Box::new(mutator_lit_int::transform)),\n            \"lit_bool\" => MutagenTransformer::Expr(Box::new(mutator_lit_bool::transform)),\n            \"unop_not\" => MutagenTransformer::Expr(Box::new(mutator_unop_not::transform)),\n            \"binop_bit\" => MutagenTransformer::Expr(Box::new(mutator_binop_bit::transform)),\n            \"binop_num\" => MutagenTransformer::Expr(Box::new(mutator_binop_num::transform)),\n            \"binop_eq\" => MutagenTransformer::Expr(Box::new(mutator_binop_eq::transform)),\n            \"binop_cmp\" => MutagenTransformer::Expr(Box::new(mutator_binop_cmp::transform)),\n            \"binop_bool\" => MutagenTransformer::Expr(Box::new(mutator_binop_bool::transform)),\n            \"stmt_call\" => MutagenTransformer::Stmt(Box::new(mutator_stmt_call::transform)),\n            _ => panic!(\"unknown transformer {}\", transformer_name),\n        }\n    }\n\n    // this funciton gives a vec of all transformers, in order they are executed\n    pub fn all_transformers() -> Vec<String> {\n        [\n            \"lit_int\",\n            \"lit_bool\",\n            \"unop_not\",\n            \"binop_bit\",\n            \"binop_num\",\n            \"binop_eq\",\n            \"binop_cmp\",\n            \"binop_bool\",\n            \"stmt_call\",\n        ]\n        .iter()\n        .copied()\n        .map(ToOwned::to_owned)\n        .collect()\n    }\n\n    /// parse the arguments of the `#[mutate]` attribute\n    fn setup_from_attr(args: TokenStream) -> Self {\n        use self::mutate_args::*;\n\n        let options = ArgOptions::parse(args).expect(\"invalid options\");\n\n        // create transform_info\n        let transform_info: SharedTransformInfo = match options.conf {\n            Conf::Global => SharedTransformInfo::global_info(),\n            Conf::Local(local_conf) => SharedTransformInfo::local_info(local_conf),\n        };\n\n        // create transformers\n        let transformers = match options.transformers {\n            Transformers::All => Self::all_transformers(),\n            Transformers::Only(list) => {\n                let mut transformers = list.transformers;\n                transformers.sort_by_key(|t| TRANSFORMER_ORDER[t]);\n                transformers\n            }\n            Transformers::Not(list) => {\n                let mut transformers = Self::all_transformers();\n                for l in &list.transformers {\n                    // transformers.remove_item(l)\n                    if let Some(pos) = transformers.iter().position(|x| *x == *l) {\n                        transformers.remove(pos);\n                    }\n                }\n                transformers\n            }\n        };\n        let mut expr_transformers = Vec::new();\n        let mut stmt_transformers = Vec::new();\n        for t in &transformers {\n            let t = Self::mk_transformer(t, &[]);\n            match t {\n                MutagenTransformer::Expr(t) => expr_transformers.push(t),\n                MutagenTransformer::Stmt(t) => stmt_transformers.push(t),\n            }\n        }\n\n        let transform_context = TransformContext::default();\n\n        Self {\n            transform_context,\n            transform_info,\n            expr_transformers,\n            stmt_transformers,\n        }\n    }\n}\n\nuse lazy_static::lazy_static;\nuse std::collections::HashMap;\n\nlazy_static! {\n    static ref TRANSFORMER_ORDER: HashMap<String, usize> = {\n        MutagenTransformerBundle::all_transformers()\n            .into_iter()\n            .enumerate()\n            .map(|(i, s)| (s, i))\n            .collect()\n    };\n}\n","traces":[{"line":14,"address":[5632880,5632989],"length":1,"stats":{"Line":0},"fn_name":"do_transform_item"},{"line":15,"address":[5633088,5632890],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[5633090,5633004],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[5633267,5633026],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[5633382,5633174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[5633632,5633750],"length":1,"stats":{"Line":0},"fn_name":"fold_expr"},{"line":49,"address":[5633650,5633765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[5633805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[5633904,5634392,5634097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[5634131],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[5634022,5634519],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[5634601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[5634736,5634851],"length":1,"stats":{"Line":0},"fn_name":"fold_stmt"},{"line":66,"address":[5634866,5634754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[5634906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[5635490,5635005,5635195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[5635229],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[5635123,5635617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[5635699],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[5635824,5635915],"length":1,"stats":{"Line":0},"fn_name":"fold_item_fn"},{"line":83,"address":[5635934,5635842],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[5635969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[5636020,5635945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[5636068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[5636031,5636104],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[5636130,5636040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[5636138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[5636211,5636361,5636307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[5636407],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[5636544,5636635],"length":1,"stats":{"Line":0},"fn_name":"fold_impl_item_method"},{"line":108,"address":[5636562,5636654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[5636689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[5636740,5636665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[5636788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[5636824,5636751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[5636760,5636850],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[5636858],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[5637081,5636931,5637027],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[5637127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[5637264,5637371],"length":1,"stats":{"Line":0},"fn_name":"fold_item_impl"},{"line":133,"address":[5637407,5637282],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[5637386,5637433,5637313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[5637473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[5637729,5637675,5637546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[5638135,5637872],"length":1,"stats":{"Line":0},"fn_name":"fold_expr_repeat"},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[5637890],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[5637923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[5637941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[5637950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[5637971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[5637983,5638200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[5638587,5638496],"length":1,"stats":{"Line":0},"fn_name":"fold_foreign_item_fn"},{"line":170,"address":[5638606,5638514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[5638641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[5638617,5638692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[5638740],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[5638776,5638703],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[5638712,5638802],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[5638810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[5638979,5638883,5639033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[5639079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[5639216],"length":1,"stats":{"Line":0},"fn_name":"fold_pat"},{"line":194,"address":[5639228],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[5639264],"length":1,"stats":{"Line":0},"fn_name":"fold_item_const"},{"line":199,"address":[5639276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[5639312],"length":1,"stats":{"Line":0},"fn_name":"fold_item_static"},{"line":204,"address":[5639324],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[5639360],"length":1,"stats":{"Line":0},"fn_name":"fold_type"},{"line":209,"address":[5639372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[5639408],"length":1,"stats":{"Line":0},"fn_name":"fold_expr_unsafe"},{"line":214,"address":[5639420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[5639456,5639542],"length":1,"stats":{"Line":0},"fn_name":"mutagen_process_item"},{"line":220,"address":[5639562,5639474],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[5639573],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[5639632],"length":1,"stats":{"Line":0},"fn_name":"mk_transformer"},{"line":229,"address":[5640423,5640541,5640659,5640718,5640777,5640364,5640305,5640482,5640600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[5639681,5640290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[5639751,5640349],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[5640408,5639805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[5639859,5640467],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[5639913,5640526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[5639967,5640585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[5640644,5640021],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[5640075,5640703],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[5640129,5640762],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[5640183,5640784],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[5640896],"length":1,"stats":{"Line":0},"fn_name":"all_transformers"},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[5641145,5641040],"length":1,"stats":{"Line":0},"fn_name":"setup_from_attr"},{"line":266,"address":[5641050,5641174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[5641320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[5641239,5643021,5641322],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[5641263,5641352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[5641686,5642225,5641465],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[5641368,5641475,5643239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[5641485],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[5641525],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[5641557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[5641638],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[5641407],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[5641455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[5641795,5641753,5641691,5642220,5641917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[5642218,5641951],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[5642169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[5641863],"length":1,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[5642227],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[5642246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[5642373,5642284,5642334,5642699,5642453],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[5642487],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[5642626,5642695],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[5642544,5642628],"length":1,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[5642559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[5642443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[4607146],"length":1,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[5685376,5685388],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"}],"covered":0,"coverable":136},{"path":["/","mnt","c","Users","kms2","Desktop","KAIST","7학기","소프트웨어 테스팅 자동화 기법","PJ","mutagen","mutagen-runner","src","progress.rs"],"content":"//! Custom implementation of printing progress of the cargo-mutagen runner.\n//!\n//! This module contains a progress bar similar to the one cargo uses.\n//! If the output is not a terminal or the terminal is too small, no progress bar is shown.\n//! The progress bar tries to be adaptive as possible and only uses a single line in every case.\n//!\n//! The main challenges is to be able to continue writing to the line above the progress bar.\n//! The output to the terminal should look identical to piped output but contains a progress bar.\n\nuse failure::Fallible;\n\nuse std::path::Path;\nuse std::time::Duration;\n\nuse mutagen_core::comm::{BakedMutation, MutantStatus};\n\nuse super::progress_bar::{ProgressBar, ProgressBarState};\n\n/// Print progress during mutation testing\npub struct Progress {\n    num_mutations: usize,\n    num_covered: usize,\n    tested_mutations: usize,\n    bar: ProgressBar,\n}\n\nimpl Progress {\n    pub fn new(num_mutations: usize) -> Self {\n        Self {\n            num_mutations,\n            num_covered: 0,\n            tested_mutations: 0,\n            bar: ProgressBar::new(),\n        }\n    }\n\n    /// Print summary information after the compilation of the test binaries.\n    pub fn summary_compile(&mut self, num_mutations: usize, num_testsuites: usize) -> Fallible<()> {\n        self.bar.println(\"\")?;\n        self.bar\n            .println(&format!(\"Total mutations: {}\", num_mutations))?;\n\n        self.bar.set_total(num_testsuites);\n\n        Ok(())\n    }\n\n    /// Start the section that runs the test suites unmutated.\n    pub fn section_testsuite_unmutated(&mut self, num_tests: usize) -> Fallible<()> {\n        self.bar.println(\"\")?;\n        self.bar.println(&format!(\"Run {} tests\", num_tests))?;\n        Ok(())\n    }\n\n    /// start the section of test-runs for each mutation\n    pub fn section_mutants(&mut self) -> Fallible<()> {\n        self.bar.println(\"\")?;\n        self.bar\n            .println(&format!(\"Test {} Mutants\", self.num_mutations))?;\n        Ok(())\n    }\n\n    /// start the section of the\n    pub fn section_summary(&mut self) -> Fallible<()> {\n        self.bar.println(\"\")?;\n        self.bar.clear_bar()?;\n        Ok(())\n    }\n\n    /// indicate the start of a run of a single testsuite without mutations\n    pub fn start_testsuite_unmutated(&mut self, bin: &Path, id: usize) -> Fallible<()> {\n        let log_string = format!(\"{} ... \", bin.display());\n        self.bar.print(log_string)?;\n\n        if self.bar.shows_progress() {\n            let bar = ProgressBarState {\n                action: \"Run Tests\",\n                current: id + 1,\n                action_details: format!(\"{}\", bin.display()),\n            };\n\n            self.bar.set_state(bar)?;\n        }\n\n        Ok(())\n    }\n\n    /// indicate the end of a run of a single testsuite and display the result.\n    pub fn finish_testsuite_unmutated(&mut self, ok: bool, num_covered: usize) -> Fallible<()> {\n        if ok && num_covered > 0 {\n            self.bar.println(&format!(\n                \"ok ({}/{} covered)\",\n                num_covered, self.num_mutations\n            ))\n        } else if ok && num_covered == 0 {\n            self.bar.println(\"ok (NOTHING COVERED)\")\n        } else {\n            self.bar.println(\"FAILED\")\n        }\n    }\n\n    /// print a summary after the testsuites have been run, especially coverage information.\n    pub fn summary_testsuite_unmutated(&mut self, num_covered: usize) -> Fallible<()> {\n        self.num_covered = num_covered;\n        self.bar.set_total(num_covered);\n\n        self.bar.println(\"\")?;\n        self.bar.println(&format!(\n            \"Mutations covered: {}/{}\",\n            self.num_covered, self.num_mutations\n        ))\n    }\n\n    /// indicate that a test-run of a covered mutation begins.\n    ///\n    /// The information about the mutation is logged to the console.\n    /// A call to `finish_mutation` should follow a call to this function\n    pub fn start_mutation_covered(&mut self, m: &BakedMutation) -> Fallible<()> {\n        let mut mutant_log_string = mutation_log_string(m);\n        mutant_log_string += \" ... \";\n\n        self.bar.print(mutant_log_string)?;\n\n        self.tested_mutations += 1;\n\n        // write progress bar\n        if self.bar.shows_progress() {\n            let action_details = format!(\n                \"{}{}\",\n                m.source_file().display(),\n                m.context_description_in_brackets(),\n            );\n            let bar = ProgressBarState {\n                action: \"Test Mutants\",\n                current: self.tested_mutations,\n                action_details: action_details,\n            };\n            self.bar.set_state(bar)?;\n        }\n\n        Ok(())\n    }\n\n    pub fn skip_mutation_uncovered(&mut self, m: &BakedMutation) -> Fallible<()> {\n        self.bar.println(&format!(\n            \"{} ... {}\",\n            mutation_log_string(m),\n            MutantStatus::NotCovered\n        ))\n    }\n\n    /// indicate that a mutation started with `start_mutation` has been finished.\n    ///\n    /// The status is printed and progress bar is updated\n    pub fn finish_mutation(&mut self, status: MutantStatus) -> Fallible<()> {\n        self.bar.println(&format!(\"{}\", status))?;\n        Ok(())\n    }\n\n    /// indicate that mutation-testing is finished\n    ///\n    /// clears the progress-bar\n    pub fn finish(mut self, mutagen_time: Duration) -> Fallible<()> {\n        let rounded_time = Duration::from_secs(mutagen_time.as_secs());\n        self.bar.println(&format!(\n            \"Total time: {}\",\n            ::humantime::format_duration(rounded_time)\n        ))?;\n        self.bar.finish()?;\n        Ok(())\n    }\n}\n\n/// Generate a string used for logging\nfn mutation_log_string(m: &BakedMutation) -> String {\n    format!(\n        \"{}: {}, {}, at {}@{}{}\",\n        m.id(),\n        m.mutator_name(),\n        m.mutation_description(),\n        m.source_file().display(),\n        m.location_in_file(),\n        m.context_description_in_brackets(),\n    )\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":71},{"path":["/","mnt","c","Users","kms2","Desktop","KAIST","7학기","소프트웨어 테스팅 자동화 기법","PJ","mutagen","mutagen-runner","src","progress_bar.rs"],"content":"//! Custom implementation of printing progress of the cargo-mutagen runner.\n//!\n//! This module contains a progress bar similar to the one cargo uses.\n//! If the output is not a terminal or the terminal is too small, no progress bar is shown.\n//! The progress bar tries to be adaptive as possible and only uses a single line in every case.\n//!\n//! The main challenges is to be able to continue writing to the line above the progress bar.\n\nuse console::Term;\nuse failure::Fallible;\nuse std::io::Write;\n\n/// Print progress during mutation testing\npub struct ProgressBar {\n    term: Term,\n    term_width: usize,\n    show_progress: bool,\n    total: usize,\n    current_log_str: Option<String>,\n    current_bar_state: Option<ProgressBarState>,\n}\n\npub struct ProgressBarState {\n    pub action: &'static str,\n    pub current: usize,\n    pub action_details: String,\n}\n\nimpl ProgressBar {\n    pub fn new() -> Self {\n        let term = Term::stdout();\n        let term_width = term.size().1 as usize;\n        let show_progress = term.is_term() && term_width > 20;\n\n        Self {\n            term,\n            term_width,\n            show_progress,\n            total: 0,\n            current_log_str: None,\n            current_bar_state: None,\n        }\n    }\n\n    /// re-sets to total actions to perform\n    pub fn set_total(&mut self, total: usize) {\n        self.total = total;\n    }\n\n    pub fn shows_progress(&self) -> bool {\n        self.show_progress\n    }\n\n    /// prints some text to stdout.\n    ///\n    /// If the progress bar is shown, the text is printed above the progress bar.\n    /// The next call to `println` will continue writing the line started by this function.\n    pub fn print(&mut self, s: String) -> Fallible<()> {\n        if self.show_progress {\n            self.term.clear_line()?;\n        }\n\n        // TODO: allow multiple print-calls and newlines\n        assert!(\n            self.current_log_str.is_none(),\n            \"consecutive calls to ProgressBar::print are currently not supported\"\n        );\n        assert!(\n            !s.contains('\\n'),\n            \"newlines are currently not supported in ProgressBar::print\"\n        );\n\n        write!(&self.term, \"{}\", &s)?;\n\n        if self.show_progress {\n            writeln!(&self.term)?;\n\n            self.write_progress_bar()?;\n\n            self.current_log_str = Some(s);\n        }\n        Ok(())\n    }\n\n    /// prints a line to stdout.\n    ///\n    /// If the progress bar is shown, the line is printed above the progress bar.\n    pub fn println(&mut self, s: &str) -> Fallible<()> {\n        if self.show_progress {\n            self.term.clear_line()?;\n\n            if let Some(log_str) = self.current_log_str.take() {\n                let log_str_lines = 1 + (log_str.len() + 1) / self.term_width;\n                self.term.clear_last_lines(log_str_lines)?;\n                writeln!(&self.term, \"{}{}\", log_str, s)?;\n            } else {\n                writeln!(&self.term, \"{}\", s)?;\n            }\n\n            self.write_progress_bar()?;\n        } else {\n            writeln!(&self.term, \"{}\", s)?;\n        }\n\n        self.current_log_str = None;\n\n        Ok(())\n    }\n\n    /// clears the progress bar\n    pub fn clear_bar(&mut self) -> Fallible<()> {\n        if let Some(_) = self.current_bar_state.take() {\n            self.term.clear_line()?;\n        }\n        Ok(())\n    }\n\n    /// finish the progress bar\n    ///\n    /// clears the progress-indicator\n    pub fn finish(self) -> Fallible<()> {\n        if self.show_progress {\n            self.term.clear_line()?;\n            writeln!(&self.term)?;\n        }\n        Ok(())\n    }\n\n    /// updates the state of the progress bar and draws the new state if the progress is shown\n    pub fn set_state(&mut self, bar: ProgressBarState) -> Fallible<()> {\n        if self.show_progress {\n            self.current_bar_state = Some(bar);\n            self.write_progress_bar()?;\n        }\n        Ok(())\n    }\n\n    fn write_progress_bar(&self) -> Fallible<()> {\n        if let Some(bar) = &self.current_bar_state {\n            if self.total == 0 {\n                return Ok(());\n            }\n            let current_total_string = format!(\"{}/{}\", bar.current, self.total);\n            let action_name = console::style(format!(\"{:>12}\", bar.action)).bold();\n\n            let main_part_len = self.term_width.min(80);\n\n            // construct progress bar\n            let bar_width = main_part_len - 18 - current_total_string.len();\n            let mut bar_pos = bar_width * bar.current / self.total;\n            if bar_pos == bar_width {\n                bar_pos -= 1;\n            }\n            let bar1 = \"=\".repeat(bar_pos);\n            let bar2 = \" \".repeat(bar_width - bar_pos - 1);\n\n            // print status details right to progress bar, if there is space for it\n            let mut action_details = bar.action_details.to_owned();\n            action_details = format!(\": {}\", action_details);\n            let space_after_main_bar = self.term_width - main_part_len;\n            if space_after_main_bar < 10 {\n                action_details = \"\".to_owned();\n            } else if space_after_main_bar < action_details.len() {\n                action_details = format!(\"{:.*}...\", space_after_main_bar - 5, action_details);\n            }\n\n            write!(\n                &self.term,\n                \"{} [{}>{}] {}{}\\r\",\n                action_name, bar1, bar2, current_total_string, action_details\n            )?;\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":72},{"path":["/","mnt","c","Users","kms2","Desktop","KAIST","7학기","소프트웨어 테스팅 자동화 기법","PJ","mutagen","mutagen-runner","src","test_bin.rs"],"content":"use failure::{bail, Fallible};\nuse std::fs;\nuse std::io::Write;\nuse std::path::Path;\nuse std::process::{Command, Stdio};\nuse std::time::{Duration, Instant};\n\nuse wait_timeout::ChildExt;\n\nuse mutagen_core::comm::{self, BakedMutation, CoverageCollection, CoverageHit, MutantStatus};\n\nuse super::Progress;\n\n/// wrapper around a test-binary that can be executed\n#[derive(Debug)]\npub struct TestBin<'a> {\n    id: usize,\n    pub bin_path: &'a Path,\n}\n\n// wrapper around a test-binary, which has been run already and its runtime has been timed.\n#[derive(Debug)]\npub struct TestBinTested<'a> {\n    test_bin: TestBin<'a>,\n    exe_time: Duration,\n    pub coverage: CoverageCollection,\n}\n\nimpl<'a> TestBin<'a> {\n    pub fn new(bin_path: &'a Path, id: usize) -> Self {\n        Self { id, bin_path }\n    }\n\n    // run the test and record the covered mutators and the time required to run the tests.\n    pub fn run_test(\n        self,\n        progress: &mut Progress,\n        mutations: &[BakedMutation],\n    ) -> Fallible<TestBinTested<'a>> {\n        let num_mutations = mutations.len();\n        let test_start = Instant::now();\n\n        progress.start_testsuite_unmutated(&self.bin_path, self.id)?;\n\n        ::std::io::stdout().flush()?;\n\n        // run test suite\n        let mut command = Command::new(self.bin_path);\n        command.env(\"MUTAGEN_MODE\", \"coverage\");\n        command.env(\"MUTAGEN_NUM_MUTATIONS\", format!(\"{}\", num_mutations));\n        command.env(\"MUTAGEN_TESTSUITE\", &self.bin_path);\n        command.stdout(Stdio::null());\n        let mut test_run = command.spawn()?;\n        let status = test_run.wait()?;\n        let exe_time = test_start.elapsed();\n\n        let success = status.success();\n\n        if !success {\n            bail!(\"test suite fails. Retry after `cargo test` succeeds\");\n        }\n\n        // read the coverage-file for this testsuite and delete it afterwards\n        let coverage = {\n            let coverage_file = comm::get_coverage_file()?;\n            if !coverage_file.exists() {\n                // no coverage file means that no mutations has been covered\n                CoverageCollection::new_empty(num_mutations)\n            } else {\n                let coverage_hits = comm::read_items::<CoverageHit>(&coverage_file)?;\n                // delete coverage file after the execution of this testsuite\n                fs::remove_file(coverage_file)?;\n\n                CoverageCollection::from_coverage_hits(num_mutations, &coverage_hits, &mutations)\n            }\n        };\n\n        progress.finish_testsuite_unmutated(success, coverage.num_covered())?;\n\n        Ok(TestBinTested {\n            test_bin: self,\n            coverage,\n            exe_time,\n        })\n    }\n}\n\nimpl<'a> TestBinTested<'a> {\n    /// Checks if any mutation is covered.\n    ///\n    /// Returns false, if no mutation is covered by the testsuite\n    pub fn coveres_any_mutation(&self) -> bool {\n        self.coverage.num_covered() != 0\n    }\n\n    pub fn check_mutant(&self, mutation: &BakedMutation) -> Fallible<MutantStatus> {\n        // run command and wait for its output\n        let mut command = Command::new(self.test_bin.bin_path);\n        command.env(\"MUTATION_ID\", mutation.id().to_string());\n        command.stdout(Stdio::null());\n        command.stderr(Stdio::null());\n        let mut test_run = command.spawn()?;\n\n        let wait_time = 5 * self.exe_time + Duration::from_millis(500);\n        let timeout = test_run.wait_timeout(wait_time)?;\n\n        Ok(match timeout {\n            Some(status) => {\n                if status.success() {\n                    MutantStatus::Survived\n                } else {\n                    MutantStatus::Killed(status.code())\n                }\n            }\n            None => {\n                test_run.kill()?;\n                MutantStatus::Timeout\n            }\n        })\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":47},{"path":["/","mnt","c","Users","kms2","Desktop","KAIST","7학기","소프트웨어 테스팅 자동화 기법","PJ","mutagen","mutagen-selftest","src","test_not_mutated.rs"],"content":"//! tests that ensure that no mutation is triggered in certain cases\n\nmod static_const {\n\n    use ::mutagen::mutate;\n\n    #[mutate(conf = local(expected_mutations = 0))]\n    const X: i32 = 5;\n\n    #[test]\n    fn x_is_5() {\n        assert_eq!(X, 5)\n    }\n}\nmod const_fn {\n\n    use ::mutagen::mutate;\n\n    #[mutate(conf = local(expected_mutations = 0))]\n    const fn x() -> i32 {\n        5\n    }\n\n    #[test]\n    fn x_is_5() {\n        assert_eq!(x(), 5)\n    }\n}\n\nmod const_method {\n\n    use ::mutagen::mutate;\n\n    struct X;\n\n    #[mutate(conf = local(expected_mutations = 0))]\n    impl X {\n        const fn x() -> i32 {\n            5\n        }\n    }\n\n    #[test]\n    fn x_is_5() {\n        assert_eq!(X::x(), 5)\n    }\n}\n\nmod array_expr_size {\n\n    use ::mutagen::mutate;\n\n    #[mutate(conf = local(expected_mutations = 0))]\n    fn x() -> Vec<()> {\n        [(); 5].to_vec()\n    }\n\n    #[test]\n    fn x_is_vec5() {\n        assert_eq!(x().len(), 5)\n    }\n}\n\nmod array_returntype_size {\n\n    use ::mutagen::mutate;\n\n    #[mutate(conf = local(expected_mutations = 0))]\n    fn x() -> Option<[(); 5]> {\n        None\n    }\n\n    #[test]\n    fn x_is_none() {\n        assert_eq!(x(), None)\n    }\n}\n\nmod tuple_index_access {\n\n    use ::mutagen::mutate;\n\n    #[mutate(conf = local(expected_mutations = 0))]\n    fn x() -> &'static str {\n        ((), \"\").1\n    }\n\n    #[test]\n    fn x_is_emptystr() {\n        assert_eq!(x(), \"\")\n    }\n}\nmod int_as_pattern {\n\n    use ::mutagen::mutate;\n\n    #[mutate(conf = local(expected_mutations = 0))]\n    fn x(i: i8) -> &'static str {\n        match i {\n            0 => \"zero\",\n            1..=127 => \"positive\",\n            _ => \"negative\",\n        }\n    }\n\n    #[test]\n    fn x_zero() {\n        assert_eq!(x(0), \"zero\")\n    }\n    #[test]\n    fn x_one_positive() {\n        assert_eq!(x(1), \"positive\")\n    }\n    #[test]\n    fn x_minus_one_negative() {\n        assert_eq!(x(-1), \"negative\")\n    }\n}\n\nmod unsafe_fn {\n    use ::mutagen::mutate;\n\n    #[mutate(conf = local(expected_mutations = 0))]\n    unsafe fn x() -> u8 {\n        5\n    }\n\n    #[test]\n    fn x_is_5() {\n        unsafe { assert_eq!(x(), 5) }\n    }\n}\n\nmod unsafe_method {\n\n    use ::mutagen::mutate;\n\n    struct X;\n\n    #[mutate(conf = local(expected_mutations = 0))]\n    impl X {\n        unsafe fn x() -> i32 {\n            5\n        }\n    }\n\n    #[test]\n    fn x_is_5() {\n        assert_eq!(unsafe { X::x() }, 5)\n    }\n}\n\nmod unsafe_block {\n\n    use ::mutagen::mutate;\n\n    #[mutate(conf = local(expected_mutations = 0))]\n    fn x() -> u8 {\n        // this is a dummy-unsafe-block with something that *could* be mutated but should not\n        #[allow(unused_unsafe)]\n        unsafe {\n            5\n        }\n    }\n\n    #[test]\n    fn x_is_5() {\n        assert_eq!(x(), 5)\n    }\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4}]}